{
    "5810": {
        "db_id": "customer_complaints",
        "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?",
        "ground_truth": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5",
        "amends": [
            "Do select `t1.first_name` with table alias instead of `first_name` without qualification. Do add `FROM staff AS t1 JOIN complaints AS t2` with explicit table aliases and join instead of single table `FROM staff`. Do add join condition `ON t1.staff_id = t2.staff_id` instead of omitting any join. Do add `GROUP BY t2.staff_id` for aggregation instead of no grouping. Do change ordering to `ORDER BY count(*)` for complaint count aggregation instead of `ORDER BY complaint_count DESC` using a direct column. Do keep `LIMIT 5` unchanged. The amended query now correctly aggregates complaint counts by joining staff with complaints and counts per staff member instead of relying on a potentially non-existent complaint_count column.",
            "Do use `ORDER BY count(*)` without `DESC` instead of `ORDER BY count(*) DESC` to sort in ascending order rather than descending order. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting columns from tables with aliases: use the exact alias qualification as shown in the amends (e.g., t1.first_name instead of unqualified first_name). 2) When joining staff and complaints tables: use explicit table aliases staff AS t1 and complaints AS t2 and link them with the exact join condition t1.staff_id = t2.staff_id. 3) When counting complaints per staff member: group by t2.staff_id and use count(*) to calculate the number of complaints handled. 4) When ordering by complaint count: use count(*) in descending order instead of a direct complaint_count column. 5) When limiting to top 5 results: keep LIMIT 5 unchanged after ordering by complaint count in descending order.",
            "1) When the question asks for \"top 5 staff who have handled the greatest number of complaints\": rank staff by complaint count in descending order and keep the first 5 rows. 2) When ordering by count of complaints: use ORDER BY count(*) DESC to sort in descending order (greatest to smallest). 3) When the question asks for \"first names\": select the first_name column from the staff table. 4) When combining staff and complaints tables: link rows where staff.staff_id = complaints.staff_id using an inner join. 5) When counting complaints per staff: group by staff_id and count all rows in each group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM staff ORDER BY complaint_count DESC LIMIT 5;",
            "SELECT t1.first_name\nFROM staff AS t1\nJOIN complaints AS t2 ON t1.staff_id = t2.staff_id\nGROUP BY t2.staff_id\nORDER BY count(*) DESC\nLIMIT 5",
            "SELECT t1.first_name \nFROM staff AS t1 \nJOIN complaints AS t2 ON t1.staff_id = t2.staff_id \nGROUP BY t2.staff_id \nORDER BY count(*) \nLIMIT 5"
        ],
        "rule_sql": [
            "SELECT t1.first_name\nFROM Staff AS t1\nINNER JOIN Complaints AS t2 ON t1.staff_id = t2.staff_id\nGROUP BY t2.staff_id\nORDER BY COUNT(*) DESC\nLIMIT 5"
        ]
    },
    "3873": {
        "db_id": "insurance_policies",
        "question": "Compute the total amount of settlement across all the settlements.",
        "ground_truth": "SELECT sum(Amount_Settled) FROM Settlements",
        "amends": [
            "Do reference the column as `Amount_Settled` instead of `amount` to match the correct column name. Do use the correct table name `Settlements` instead of `settlements` with proper capitalization. Do remove the `WHERE amount > 0` filter instead of keeping it, as the right query aggregates all settlement amounts without filtering. The amended query now correctly sums all settlement amounts from the Settlements table without unnecessary filtering, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"total amount of settlement\": sum the values from the exact column \"Amount_Settled\" in table \"Settlements\". 2) When referencing the settlement amount column: use the exact identifier \"Amount_Settled\" with proper capitalization, not \"amount\". 3) When referencing the settlements table: use the exact identifier \"Settlements\" with proper capitalization, not \"settlements\". 4) When computing total settlement amount across all settlements: include all rows without filtering out any settlement amounts."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(amount) FROM settlements WHERE amount > 0;",
            "SELECT SUM(Amount_Settled) AS Total_Settlement_Amount FROM Settlements;"
        ],
        "rule_sql": [
            "SELECT SUM(Amount_Settled) AS Total_Settlement_Amount FROM Settlements;"
        ]
    },
    "1598": {
        "db_id": "customers_and_invoices",
        "question": "What are the different product colors?",
        "ground_truth": "SELECT DISTINCT product_color FROM Products",
        "amends": [
            "Do reference the column as `product_color` instead of `color` to match the actual column name in the table. Do reference the table as `Products` instead of `products` to match the correct table name casing. Do remove the `WHERE color IS NOT NULL` filter instead of keeping it, as the DISTINCT operation inherently excludes NULL values. Do remove the `ORDER BY color` clause instead of including it, as the result ordering is not required. The amended query now correctly selects distinct product colors from the Products table without unnecessary filtering or sorting."
        ],
        "rules": [
            "1) When the question asks for \"different product colors\": select distinct values from the exact column \"product_color\" in table \"Products\". 2) When referencing the table containing product colors: use the exact table name \"Products\" with proper casing. 3) When selecting distinct values: do not include a NULL filter as the DISTINCT operation inherently excludes NULL values. 4) When the question does not specify ordering: do not include any ORDER BY clause in the result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT color FROM products WHERE color IS NOT NULL ORDER BY color;",
            "SELECT DISTINCT product_color FROM Products;"
        ],
        "rule_sql": [
            "SELECT DISTINCT product_color FROM Products;"
        ]
    },
    "2868": {
        "db_id": "icfp_1",
        "question": "How many papers have \"Atsushi Ohori\" published?",
        "ground_truth": "SELECT count(*) FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid WHERE  t1.fname  =  \"Atsushi\" AND t1.lname  =  \"Ohori\"",
        "amends": [
            "Do join `authors AS t1` and `authorship AS t2` on `t1.authid = t2.authid` instead of querying only the `papers` table. Do then join `papers AS t3` on `t2.paperid = t3.paperid` instead of omitting these table relationships. Do filter with `t1.fname = \"Atsushi\" AND t1.lname = \"Ohori\"` instead of using `author = 'Atsushi Ohori'` which incorrectly assumes a combined name column exists. Do count papers through the authorship relationship instead of directly from papers without proper author filtering. The amended query now correctly counts papers by joining through the author and authorship tables to match the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about papers published by an author: join authors AS T1 and authorship AS T2 on T1.authid = T2.authid, then join papers AS T3 on T2.paperid = T3.paperid. 2) When the question mentions author name \"Atsushi Ohori\": split into T1.fname = \"Atsushi\" AND T1.lname = \"Ohori\" instead of using a combined name column. 3) When counting papers by an author: count through the authorship relationship using the paperid from T3 instead of counting directly from papers without proper author filtering. 4) When combining tables for author-paper relationships: perform inner joins using exact key equality T1.authid = T2.authid and T2.paperid = T3.paperid, keeping only matching pairs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM papers WHERE author = 'Atsushi Ohori';",
            "SELECT COUNT(DISTINCT t3.paperID) \nFROM Authors AS t1 \nJOIN Authorship AS t2 ON t1.authID = t2.authID \nJOIN Papers AS t3 ON t2.paperID = t3.paperID \nWHERE t1.fname = 'Atsushi' AND t1.lname = 'Ohori'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T3.paperID) \nFROM Authors AS T1 \nINNER JOIN Authorship AS T2 ON T1.authID = T2.authID \nINNER JOIN Papers AS T3 ON T2.paperID = T3.paperID \nWHERE T1.fname = 'Atsushi' AND T1.lname = 'Ohori'"
        ]
    },
    "2123": {
        "db_id": "cre_Doc_Control_Systems",
        "question": "What is draft detail of the document with id 7?",
        "ground_truth": "SELECT draft_details FROM Document_Drafts WHERE document_id = 7;",
        "amends": [
            "Do select `draft_details` instead of `*` to return only the specific column needed. Do query from `Document_Drafts` instead of `documents` to access the correct table containing draft information. The filter on `document_id = 7` remains correctly positioned in the WHERE clause. The amended query now correctly retrieves draft details from the appropriate Document_Drafts table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"draft detail of the document with id 7\": make sure the output order: draft_details. 2) When the question mentions \"document with id 7\": \"document_id\" actually means \"document_id in schema\" and use the exact literal value 7. 3) When querying for draft information: use table \"Document_Drafts\" instead of \"documents\" to access the correct table containing draft details. 4) When selecting columns for draft details: select only \"draft_details\" instead of all columns to return the specific column needed."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM documents WHERE document_id = 7;",
            "SELECT draft_details FROM Document_Drafts WHERE document_id = 7"
        ],
        "rule_sql": [
            "SELECT draft_details FROM Document_Drafts WHERE document_id = 7;"
        ]
    },
    "6328": {
        "db_id": "e_government",
        "question": "Find name of the services that has never been used.",
        "ground_truth": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id",
        "amends": [
            "Do select `service_name` instead of `name` from the `services` table. Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do add a join with `party_services` table on `service_id` instead of checking against `usage_log` table. Do reference the table with alias `t1` for clarity instead of using the base table name directly. The amended query now correctly identifies services by name that are not associated with any party services, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting service names from the services table: use the exact column token \"service_name\" instead of \"name\". 2) When finding services that have never been used: use an EXCEPT set operation instead of NOT IN with a subquery. 3) When checking for unused services: join with the party_services table on service_id instead of checking against usage_log table. 4) When referencing the services table: use alias t1 for clarity instead of the base table name directly. 5) When combining services and party_services tables: link rows where t1.service_id equals party_services.service_id to identify services not associated with any party services."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM services WHERE service_id NOT IN (SELECT service_id FROM usage_log)",
            "SELECT t1.service_name FROM Services t1 EXCEPT SELECT t1.service_name FROM Services t1 JOIN Party_Services ps ON t1.service_id = ps.service_id"
        ],
        "rule_sql": [
            "SELECT t1.service_name FROM Services t1\nEXCEPT\nSELECT t1.service_name FROM Services t1\nJOIN Party_Services ON t1.service_id = Party_Services.service_id"
        ]
    },
    "3186": {
        "db_id": "college_1",
        "question": "What is the description for the CIS-220 and how many credits does it have?",
        "ground_truth": "SELECT crs_credit ,  crs_description FROM course WHERE crs_code  =  'CIS-220'",
        "amends": [
            "Do use column names `crs_credit` and `crs_description` instead of `course_credits` and `course_description`. Do reference table `course` instead of `courses`. Do use filter column `crs_code` instead of `course_code` while maintaining the same filter value 'CIS-220'. The amended query now correctly matches the target schema and behavior.",
            "Do reverse the column order to `crs_credit, crs_description` instead of `crs_description, crs_credit` while maintaining the same `WHERE crs_code = 'CIS-220'` filter, which preserves the identical logical result despite the different column sequence in the output."
        ],
        "rules": [
            "1) When the question asks for course description and credits: use columns \"crs_description\" and \"crs_credit\" from table \"course\". 2) When filtering by course code 'CIS-220': use column \"crs_code\" with exact literal value 'CIS-220' (case-sensitive with hyphen). 3) When referencing the course table: use table name \"course\" (singular) not \"courses\" (plural).",
            "1) When the question asks for both description and credits of a course: output the columns in the order of credits first, then description. 2) When filtering for a specific course code like 'CIS-220': use the exact literal 'CIS-220' with the same case and hyphen. 3) When selecting from the COURSE table: use the exact table name \"COURSE\" as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_description, course_credits FROM courses WHERE course_code = 'CIS-220';",
            "SELECT crs_description, crs_credit FROM COURSE WHERE crs_code = 'CIS-220';",
            "SELECT crs_credit, crs_description FROM COURSE WHERE crs_code = 'CIS-220'"
        ],
        "rule_sql": [
            "SELECT crs_credit, crs_description FROM COURSE WHERE crs_code = 'CIS-220'"
        ]
    },
    "4648": {
        "db_id": "college_3",
        "question": "How many students have had at least one \"B\" grade?",
        "ground_truth": "SELECT COUNT(DISTINCT StuID) FROM ENROLLED_IN WHERE Grade  =  \"B\"",
        "amends": [
            "Do `COUNT(DISTINCT StuID)` instead of `COUNT(*)` to count unique student IDs rather than all rows. Do query from `ENROLLED_IN` table instead of `students` table to access enrollment records. Do filter on `Grade = \"B\"` instead of `grade = 'B'` to use the correct column name and table context. Do use double quotes for string literal instead of single quotes to match the database's string formatting requirements. The amended query now correctly counts distinct students who received a B grade in their enrollments rather than counting all B-grade records from an incorrect table."
        ],
        "rules": [
            "1) When counting students: count distinct \"StuID\" values instead of counting all rows to ensure each student is counted only once. 2) When accessing enrollment records: use the \"ENROLLED_IN\" table instead of a \"students\" table to get the correct data source. 3) When filtering for B grades: use the exact column name \"Grade\" and filter for the exact string literal \"B\" with double quotes. 4) When handling string literals: use double quotes instead of single quotes to match the database's string formatting requirements."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE grade = 'B';",
            "SELECT COUNT(DISTINCT StuID) FROM Enrolled_in WHERE Grade = \"B\""
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT StuID) FROM Enrolled_in WHERE Grade = \"B\""
        ]
    },
    "3137": {
        "db_id": "assets_maintenance",
        "question": "How many engineer visits are required at most for a single fault log? List the number and the log entry id.",
        "ground_truth": "SELECT count(*) ,  T1.fault_log_entry_id FROM Fault_Log AS T1 JOIN Engineer_Visits AS T2 ON T1.fault_log_entry_id  =  T2.fault_log_entry_id GROUP BY T1.fault_log_entry_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use `count(*)` instead of `MAX(COUNT(engineer_id))` to count total records per group. Do join `Engineer_Visits` table with alias `T2` instead of querying only `fault_logs` table. Do use `ON T1.fault_log_entry_id = T2.fault_log_entry_id` join condition instead of no join condition. Do group by `T1.fault_log_entry_id` instead of `log_entry_id` to match the joined table structure. Do add `ORDER BY count(*) DESC LIMIT 1` instead of omitting ordering and limiting to get only the highest count record. The amended query now correctly counts engineer visits per fault log entry and returns the entry with the most visits.",
            "Do place `count(*)` before `T1.fault_log_entry_id` in the SELECT list instead of after it. Do reference `count(*)` directly in the ORDER BY clause instead of using the alias `visit_count`. Do remove the alias `visit_count` from the COUNT aggregation instead of keeping it. The amended query now correctly orders by the actual count value rather than an alias that isn't available in the ORDER BY clause, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting engineer visits per fault log entry: use count(*) to count total records per group instead of MAX(COUNT(engineer_id)). 2) When combining fault log and engineer visit data: join the Engineer_Visits table (as T2) with the fault_logs table using ON T1.fault_log_entry_id = T2.fault_log_entry_id instead of querying only the fault_logs table. 3) When grouping by fault log entries: group by T1.fault_log_entry_id instead of log_entry_id to match the joined table structure. 4) When finding the fault log with the most engineer visits: add ORDER BY count(*) DESC LIMIT 1 to get only the highest count record.",
            "1) When ordering by a count value in descending order: use the actual count expression directly in the ORDER BY clause instead of an alias. 2) When selecting both a grouping key and a count: place the count(*) before the grouping key (T1.fault_log_entry_id) in the SELECT list. 3) When counting visits per fault log entry: do not assign an alias to the count(*) aggregation in the SELECT clause."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(COUNT(engineer_id)), log_entry_id FROM fault_logs GROUP BY log_entry_id;",
            "SELECT T1.fault_log_entry_id, COUNT(*) AS visit_count\nFROM Fault_Log T1\nJOIN Engineer_Visits T2 ON T1.fault_log_entry_id = T2.fault_log_entry_id\nGROUP BY T1.fault_log_entry_id\nORDER BY visit_count DESC\nLIMIT 1;",
            "SELECT count(*), T1.fault_log_entry_id\nFROM Fault_Log T1\nJOIN Engineer_Visits T2 ON T1.fault_log_entry_id = T2.fault_log_entry_id\nGROUP BY T1.fault_log_entry_id\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS visit_count, T1.fault_log_entry_id\nFROM Fault_Log T1\nJOIN Engineer_Visits T2 ON T1.fault_log_entry_id = T2.fault_log_entry_id\nGROUP BY T1.fault_log_entry_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "4714": {
        "db_id": "department_store",
        "question": "Count the number of distinct product types.",
        "ground_truth": "SELECT count(DISTINCT product_type_code) FROM products",
        "amends": [
            "Do use `count(DISTINCT product_type_code)` instead of `COUNT(product_type)` to count distinct product type codes rather than all product type values, which changes the aggregation to count unique values instead of total occurrences. The amended query now correctly counts distinct product type codes from the products table, matching the intended behavior."
        ],
        "rules": [
            "1) When counting distinct product types: use \"product_type_code\" instead of \"product_type\" to count unique product type codes. 2) When the question asks for \"distinct product types\": compute the number of unique values of the exact token \"product_type_code\" from the products table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(product_type) FROM products;",
            "SELECT COUNT(DISTINCT product_type_code) FROM Products;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT product_type_code) FROM Products;"
        ]
    },
    "5285": {
        "db_id": "manufactory_1",
        "question": "Give the distinct headquarters of manufacturers.",
        "ground_truth": "SELECT DISTINCT headquarter FROM manufacturers",
        "amends": [
            "Do select `headquarter` instead of `manufacturer` and use `DISTINCT` instead of `GROUP BY headquarters` to properly retrieve unique headquarters locations. Do remove the incorrect `GROUP BY` clause instead of using it for deduplication, as grouping by headquarters while selecting manufacturer would produce incorrect results. The amended query now correctly returns distinct headquarters values from the manufacturers table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for distinct headquarters of manufacturers: select the exact column \"headquarter\" from table \"manufacturers\" and return only unique values. 2) When deduplicating values: use DISTINCT on the target column instead of GROUP BY to avoid incorrect grouping behavior. 3) When selecting from a single table: do not include unnecessary GROUP BY clauses that would produce incorrect results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT manufacturer FROM manufacturers GROUP BY headquarters;",
            "SELECT DISTINCT Headquarter FROM Manufacturers;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Headquarter FROM Manufacturers;"
        ]
    },
    "6079": {
        "db_id": "customers_and_addresses",
        "question": "How many customers are living in city \"Lake Geovannyton\"?",
        "ground_truth": "SELECT count(*) FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.city  =  \"Lake Geovannyton\"",
        "amends": [
            "Do add joins to `customer_addresses` and `addresses` tables instead of querying only the `customers` table. Do use `JOIN` with `t1.customer_id = t2.customer_id` and `t2.address_id = t3.address_id` instead of missing these table relationships. Do filter on `t3.city` instead of filtering on a non-existent `city` column in the `customers` table. Do use double quotes around 'Lake Geovannyton' instead of single quotes for consistency. The amended query now correctly counts customers by joining through the address relationships to find those in the specified city, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about customers living in a specific city: join customers table (T1) with customer_addresses table (T2) using T1.customer_id = T2.customer_id, then join with addresses table (T3) using T2.address_id = T3.address_id. 2) When filtering for city \"Lake Geovannyton\": apply the filter condition to T3.city = \"Lake Geovannyton\" using double quotes. 3) When counting customers: count the number of rows using the customer relationships established through the joins."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE city = 'Lake Geovannyton';",
            "SELECT COUNT(DISTINCT c.customer_id) \nFROM Customers c\nJOIN Customer_Addresses ca ON c.customer_id = ca.customer_id\nJOIN Addresses a ON ca.address_id = a.address_id\nWHERE a.city = \"Lake Geovannyton\""
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT c.customer_id) \nFROM Customers c\nJOIN Customer_Addresses ca ON c.customer_id = ca.customer_id\nJOIN Addresses a ON ca.address_id = a.address_id\nWHERE a.city = \"Lake Geovannyton\""
        ]
    },
    "3375": {
        "db_id": "sports_competition",
        "question": "Show total points of all players.",
        "ground_truth": "SELECT sum(Points) FROM player",
        "amends": [
            "Do use the column name `Points` instead of `goals` in the SELECT clause. Do reference the table name `player` instead of `players` in the FROM clause. The amended query now correctly calculates the sum of points from the player table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"total points of all players\": use the exact column name \"Points\" from the player table. 2) When referencing the table containing player data: use the exact table name \"player\" (not \"players\"). 3) When calculating the sum of points: compute the total of all values in the \"Points\" column from the player table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(goals) FROM players;",
            "SELECT SUM(Points) FROM player;"
        ],
        "rule_sql": [
            "SELECT SUM(Points) AS TotalPoints FROM player;"
        ]
    },
    "393": {
        "db_id": "flight_1",
        "question": "What is the average price for flights from Los Angeles to Honolulu.",
        "ground_truth": "SELECT avg(price) FROM Flight WHERE origin  =  \"Los Angeles\" AND destination  =  \"Honolulu\"",
        "amends": [
            "Do reference table `Flight` instead of `flights` in the FROM clause. Do use column `origin` instead of `departure_city` for the first filter condition. Do use column `destination` instead of `arrival_city` for the second filter condition. Do use double quotes around string literals \"Los Angeles\" and \"Honolulu\" instead of single quotes. The amended query now correctly calculates the average price for flights from Los Angeles to Honolulu."
        ],
        "rules": [
            "1) When answering about \"average price for flights from Los Angeles to Honolulu\": make sure the output order: average price. 2) When the question mentions \"flights\": \"flights\" actually means table \"Flight\" in schema. 3) When the question mentions \"from Los Angeles\": \"Los Angeles\" actually means column \"origin\" with value \"Los Angeles\" in schema. 4) When the question mentions \"to Honolulu\": \"Honolulu\" actually means column \"destination\" with value \"Honolulu\" in schema. 5) When handling text literals: do not change case, spacing, or punctuation - use exact literals \"Los Angeles\" and \"Honolulu\" with double quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(price) FROM flights WHERE departure_city = 'Los Angeles' AND arrival_city = 'Honolulu';",
            "SELECT AVG(price) FROM flight WHERE origin = \"Los Angeles\" AND destination = \"Honolulu\""
        ],
        "rule_sql": [
            "SELECT AVG(price) AS \"average price\" FROM flight WHERE origin = 'Los Angeles' AND destination = 'Honolulu';"
        ]
    },
    "1022": {
        "db_id": "university_basketball",
        "question": "What are the names of all the teams in the basketball competition, sorted by all home scores in descending order?",
        "ground_truth": "SELECT team_name FROM basketball_match ORDER BY All_Home DESC",
        "amends": [
            "Do reference the `basketball_match` table instead of the `teams` table. Do order by `All_Home` column instead of `home_score` column. The amended query now correctly retrieves team names ordered by the appropriate scoring metric from the correct data source."
        ],
        "rules": [
            "1) When answering about team names in the basketball competition: use the \"basketball_match\" table instead of the \"teams\" table. 2) When ordering by home scores: use the \"All_Home\" column instead of the \"home_score\" column. 3) When sorting in descending order: sort by \"All_Home\" in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT team_name FROM teams ORDER BY home_score DESC;",
            "SELECT Team_Name FROM basketball_match ORDER BY All_Home DESC;"
        ],
        "rule_sql": [
            "SELECT Team_Name FROM basketball_match ORDER BY All_Home DESC;"
        ]
    },
    "280": {
        "db_id": "twitter_1",
        "question": "Find the number of users who posted some tweets.",
        "ground_truth": "SELECT count(DISTINCT UID) FROM tweets",
        "amends": [
            "Do use `count(DISTINCT UID)` instead of `COUNT(*)` to count distinct user IDs rather than all rows. Do query from `tweets` table instead of `users` table to access the appropriate data source. Do remove the `WHERE tweet_id IS NOT NULL` filter instead of keeping it since the count should include all tweets regardless of tweet_id status. The amended query now correctly counts distinct users from the tweets table, matching the intended behavior."
        ],
        "rules": [
            "1) When counting users who posted tweets: use the \"tweets\" table as the data source instead of the \"users\" table. 2) When counting distinct users: use count(DISTINCT UID) instead of COUNT(*) to count unique user IDs. 3) When counting all users who posted tweets: do not apply any filter on tweet_id status, include all tweets regardless of whether tweet_id is null or not."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE tweet_id IS NOT NULL",
            "SELECT COUNT(DISTINCT uid) FROM tweets;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT uid) FROM tweets;"
        ]
    },
    "3562": {
        "db_id": "music_1",
        "question": "How many artists are male and how many are female?",
        "ground_truth": "SELECT count(*) ,  gender FROM artist GROUP BY gender",
        "amends": [
            "Do select `count(*)` and `gender` instead of `gender, COUNT(*)` with different column order. Do reference table `artist` instead of `artists` in the FROM clause. Do remove the WHERE filter `gender IN ('male', 'female')` instead of keeping it, allowing all gender values to be included in the aggregation. Do maintain the GROUP BY `gender` clause to preserve the grouping logic. The amended query now correctly counts all artists by gender without filtering out any gender values, matching the RIGHT_SQL's behavior.",
            "Do place the `gender` column after the aggregate function instead of before it in the SELECT list. Do maintain the same `COUNT(*)` aggregate function and `GROUP BY gender` clause without changes to the grouping logic. The amended query now correctly matches the RIGHT_SQL's behavior by preserving the same result set with identical grouping and counting logic."
        ],
        "rules": [
            "1) When answering about \"how many artists are male and how many are female\": make sure the output order: count(*) then gender. 2) When referring to the artists table: use the exact table name \"artist\" instead of \"artists\". 3) When counting artists by gender: include all gender values without filtering out any values using WHERE conditions. 4) When grouping by gender: maintain the GROUP BY \"gender\" clause to organize results by gender values.",
            "1) When answering about \"how many artists are male and how many are female\": make sure the output order: first the gender value, then the count of artists with that gender. 2) When the question asks for \"count of artists\": compute the number of rows using the canonical key for artists. 3) When the question says \"by gender\": organize results by the \"gender\" column and compute counts per gender group. 4) When handling text literals: do not change case, spacing, or punctuation for gender values like 'Male' and 'Female'."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gender, COUNT(*) FROM artists WHERE gender IN ('male', 'female') GROUP BY gender;",
            "SELECT gender, COUNT(*) FROM artist GROUP BY gender;",
            "SELECT COUNT(*), gender FROM artist GROUP BY gender;"
        ],
        "rule_sql": [
            "SELECT gender, COUNT(*) FROM artist GROUP BY gender ORDER BY gender;"
        ]
    },
    "79": {
        "db_id": "student_assessment",
        "question": "List the id of students who registered some courses and the number of their registered courses?",
        "ground_truth": "SELECT T1.student_id ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id",
        "amends": [
            "Do use `students AS T1` as the primary table instead of `registrations` alone. Do add `JOIN student_course_registrations AS T2` with `ON T1.student_id = T2.student_id` instead of querying only one table. Do specify `T1.student_id` in both SELECT and GROUP BY instead of just `student_id` to avoid ambiguity. The amended query now correctly joins the student and registration tables to count course registrations per student, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"students who registered some courses\": use \"students AS T1\" as the primary table instead of registrations alone. 2) When combining student and registration information: add JOIN student_course_registrations AS T2 with ON T1.student_id = T2.student_id to link student records with their course registrations. 3) When selecting student identifiers: specify T1.student_id in both SELECT and GROUP BY instead of just student_id to avoid ambiguity. 4) When counting registered courses per student: count the number of registrations using the join relationship between T1 and T2 tables."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id, COUNT(*) FROM registrations GROUP BY student_id",
            "SELECT T1.student_id, COUNT(T2.course_id) AS number_of_registered_courses\nFROM Students AS T1\nJOIN Student_Course_Registrations AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id"
        ],
        "rule_sql": [
            "SELECT T1.student_id, COUNT(T2.course_id) AS number_of_registered_courses\nFROM Students AS T1\nJOIN Student_Course_Registrations AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id"
        ]
    },
    "5662": {
        "db_id": "customers_and_products_contacts",
        "question": "Show the minimum, maximum, average price for all products.",
        "ground_truth": "SELECT min(product_price) ,  max(product_price) ,  avg(product_price) FROM products",
        "amends": [
            "Do include `avg(product_price)` in the SELECT list instead of omitting it. Do reference column `product_price` instead of `price` for both aggregate functions. Do maintain the same FROM clause with table `products` without any changes to joins or filters. The amended query now correctly calculates all three price statistics (minimum, maximum, and average) using the proper column name, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"minimum, maximum, average price for all products\": make sure the output order: minimum price, maximum price, average price. 2) When the question mentions \"price\": \"price\" actually means \"product_price\" in schema. 3) When calculating price statistics: use MIN(\"product_price\"), MAX(\"product_price\"), and AVG(\"product_price\") from table \"products\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(price), MAX(price) FROM products;",
            "SELECT MIN(product_price) AS min_price, MAX(product_price) AS max_price, AVG(product_price) AS avg_price FROM Products;"
        ],
        "rule_sql": [
            "SELECT MIN(product_price) AS minimum_price, MAX(product_price) AS maximum_price, AVG(product_price) AS average_price FROM Products;"
        ]
    },
    "3829": {
        "db_id": "e_learning",
        "question": "Find the enrollment date for all the tests that have \"Pass\" result.",
        "ground_truth": "SELECT T1.date_of_enrolment FROM Student_Course_Enrolment AS T1 JOIN Student_Tests_Taken AS T2 ON T1.registration_id  =  T2.registration_id WHERE T2.test_result  =  \"Pass\"",
        "amends": [
            "Do select `T1.date_of_enrolment` from `Student_Course_Enrolment AS T1` instead of `enrollment_date` from `tests`. Do add `JOIN Student_Tests_Taken AS T2` with join condition `ON T1.registration_id = T2.registration_id` instead of querying only the tests table. Do filter on `T2.test_result = \"Pass\"` instead of `result = 'Pass'`. The amended query now correctly joins enrollment and test tables to retrieve enrollment dates for students who passed tests, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"enrollment date\": use \"T1.date_of_enrolment\" from \"Student_Course_Enrolment AS T1\" instead of \"enrollment_date\" from \"tests\". 2) When combining enrollment and test information: join \"Student_Course_Enrolment AS T1\" with \"Student_Tests_Taken AS T2\" using the condition \"T1.registration_id = T2.registration_id\" to link related records. 3) When filtering for tests with \"Pass\" result: use the exact filter \"T2.test_result = \\\"Pass\\\"\" with double quotes around the literal value. 4) When answering about enrollment dates for passed tests: ensure the query includes both enrollment and test tables joined on registration_id to correctly associate enrollment dates with test results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT enrollment_date FROM tests WHERE result = 'Pass';",
            "SELECT T1.date_of_enrolment \nFROM Student_Course_Enrolment AS T1\nJOIN Student_Tests_Taken AS T2 ON T1.registration_id = T2.registration_id\nWHERE T2.test_result = 'Pass'"
        ],
        "rule_sql": [
            "SELECT T1.date_of_enrolment \nFROM Student_Course_Enrolment AS T1\nJOIN Student_Tests_Taken AS T2 ON T1.registration_id = T2.registration_id\nWHERE T2.test_result = \"Pass\""
        ]
    },
    "1809": {
        "db_id": "small_bank_1",
        "question": "What are the names of customers with checking balances lower than the average checking balance?",
        "ground_truth": "SELECT T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  <  (SELECT avg(balance) FROM checking)",
        "amends": [
            "Do reference `T1.name` from the `accounts` table instead of `name` from `customers`. Do join `accounts AS T1` with `checking AS T2` on `T1.custid = T2.custid` instead of querying only the `customers` table. Do filter on `T2.balance < (SELECT avg(balance) FROM checking)` instead of `checking_balance < (SELECT AVG(checking_balance) FROM customers)`. Do use the correct table `checking` for balance calculations instead of `customers`. The amended query now correctly compares individual account balances against the average checking account balance."
        ],
        "rules": [
            "1) When answering about customer names: use T1.name from the accounts table instead of name from customers table. 2) When combining account and checking information: link rows where T1.custid = T2.custid and keep only matching pairs (inner match). 3) When filtering for checking balances lower than average: use T2.balance < (SELECT avg(balance) FROM checking) instead of checking_balance from customers table. 4) When calculating average checking balance: use the checking table for balance calculations instead of customers table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM customers WHERE checking_balance < (SELECT AVG(checking_balance) FROM customers);",
            "SELECT T1.name \nFROM ACCOUNTS AS T1\nJOIN CHECKING AS T2 ON T1.custid = T2.custid\nWHERE T2.balance < (SELECT AVG(balance) FROM CHECKING)"
        ],
        "rule_sql": [
            "SELECT T1.name \nFROM ACCOUNTS T1\nINNER JOIN CHECKING T2 ON T1.custid = T2.custid\nWHERE T2.balance < (SELECT AVG(balance) FROM CHECKING)"
        ]
    },
    "5990": {
        "db_id": "game_1",
        "question": "What are the ids of all students who live in CHI?",
        "ground_truth": "SELECT StuID FROM Student WHERE city_code  =  \"CHI\"",
        "amends": [
            "Do reference the `StuID` column instead of `student_id` and use the `Student` table instead of `students`. Do filter on `city_code = \"CHI\"` instead of `city = 'CHI'` to match the correct column name and use double quotes for the string literal instead of single quotes. The amended query now correctly retrieves student IDs from the Student table where the city code equals CHI."
        ],
        "rules": [
            "1) When answering about student IDs: use the exact column name \"StuID\" from the Student table. 2) When filtering for students who live in CHI: use the exact column name \"city_code\" and the exact literal value \"CHI\" with double quotes. 3) When referring to the student table: use the exact table name \"Student\" (not \"students\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id FROM students WHERE city = 'CHI';",
            "SELECT StuID FROM Student WHERE city_code = \"CHI\";"
        ],
        "rule_sql": [
            "SELECT StuID FROM Student WHERE city_code = \"CHI\";"
        ]
    },
    "5545": {
        "db_id": "products_gen_characteristics",
        "question": "Give the color description for the product 'catnip'.",
        "ground_truth": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code WHERE t1.product_name  =  \"catnip\"",
        "amends": [
            "Do select `t2.color_description` instead of `color` and add table alias `t1` for the products table. Do add a `JOIN` with `ref_colors AS t2` on `t1.color_code = t2.color_code` instead of querying only the products table. Do filter on `t1.product_name = \"catnip\"` instead of `name = 'catnip'` to use the correct column name and table reference. The amended query now correctly joins to the reference table to retrieve the color description instead of the raw color code, and uses proper table aliasing and column references throughout."
        ],
        "rules": [
            "1) When the question asks for \"color description\" for a product: select \"t2.color_description\" instead of \"color\" from the products table. 2) When joining tables to get color information: add a JOIN with \"ref_colors AS t2\" on \"t1.color_code = t2.color_code\" to link products to their color descriptions. 3) When filtering for product name: use \"t1.product_name = 'catnip'\" with exact literal value and proper table reference instead of just \"name = 'catnip'\". 4) When using table aliases: use \"t1\" for the products table and \"t2\" for the ref_colors table as established in the join."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT color FROM products WHERE name = 'catnip';",
            "SELECT t2.color_description \nFROM Products AS t1 \nJOIN Ref_Colors AS t2 ON t1.color_code = t2.color_code \nWHERE t1.product_name = 'catnip'"
        ],
        "rule_sql": [
            "SELECT t2.color_description \nFROM Products AS t1\nJOIN Ref_Colors AS t2 ON t1.color_code = t2.color_code\nWHERE t1.product_name = 'catnip'"
        ]
    },
    "5947": {
        "db_id": "cre_Theme_park",
        "question": "Show the description and code of the attraction type most tourist attractions belong to.",
        "ground_truth": "SELECT T1.Attraction_Type_Description ,  T2.Attraction_Type_Code FROM Ref_Attraction_Types AS T1 JOIN Tourist_Attractions AS T2 ON T1.Attraction_Type_Code  =  T2.Attraction_Type_Code GROUP BY T2.Attraction_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.Attraction_Type_Description` and `T2.Attraction_Type_Code` instead of `description` and `code`. Do join `Ref_Attraction_Types AS T1` with `Tourist_Attractions AS T2` on `T1.Attraction_Type_Code = T2.Attraction_Type_Code` instead of querying only `attraction_types`. Do add `GROUP BY T2.Attraction_Type_Code` instead of omitting it to properly aggregate counts by attraction type code. The amended query now correctly joins the reference table with actual tourist attractions to find the most common attraction type by count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"the attraction type most tourist attractions belong to\": make sure the output order: T1.Attraction_Type_Description, T2.Attraction_Type_Code. 2) When combining Ref_Attraction_Types as T1 and Tourist_Attractions as T2: link rows where T1.Attraction_Type_Code = T2.Attraction_Type_Code and keep only matching pairs (inner match). 3) When the question asks for \"most tourist attractions belong to\": rank attraction types by count of tourist attractions in descending order and keep the first 1 row. 4) When counting tourist attractions per attraction type: compute the number of rows using T2.Attraction_Type_Code as the grouping key. 5) When organizing results by attraction type: group by T2.Attraction_Type_Code to compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description, code FROM attraction_types ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T1.Attraction_Type_Description, T2.Attraction_Type_Code\nFROM Ref_Attraction_Types AS T1\nJOIN Tourist_Attractions AS T2 ON T1.Attraction_Type_Code = T2.Attraction_Type_Code\nGROUP BY T2.Attraction_Type_Code\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Attraction_Type_Description, T2.Attraction_Type_Code\nFROM Ref_Attraction_Types T1\nINNER JOIN Tourist_Attractions T2 ON T1.Attraction_Type_Code = T2.Attraction_Type_Code\nGROUP BY T2.Attraction_Type_Code\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "3836": {
        "db_id": "e_learning",
        "question": "Find the student ID and login name of the student with the most course enrollments",
        "ground_truth": "SELECT T1.student_id ,  T2.login_name FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do join `Student_Course_Enrolment AS T1` with `Students AS T2` on `T1.student_id = T2.student_id` instead of querying only the `students` table. Do select `T1.student_id` and `T2.login_name` instead of `student_id` and `login_name` without table aliases. Do add `GROUP BY T1.student_id` to aggregate enrollment counts per student instead of omitting grouping. The amended query now correctly identifies the student with the most course enrollments by joining enrollment records with student details and grouping before counting."
        ],
        "rules": [
            "1) When answering about \"student with the most course enrollments\": join Student_Course_Enrolment AS T1 with Students AS T2 on T1.student_id = T2.student_id to combine enrollment records with student details. 2) When counting course enrollments per student: group by T1.student_id to aggregate enrollment counts for each student. 3) When selecting output columns: use T1.student_id and T2.login_name to get the student ID from enrollment records and login name from student details. 4) When finding the student with the most enrollments: order by the count of enrollments in descending order and take the first row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id, login_name FROM students ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T1.student_id, T2.login_name\nFROM Student_Course_Enrolment AS T1\nJOIN Students AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.student_id, T2.login_name\nFROM Student_Course_Enrolment AS T1\nJOIN Students AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "149": {
        "db_id": "bike_1",
        "question": "What is the average bike availability in stations that are not located in Palo Alto?",
        "ground_truth": "SELECT avg(bikes_available) FROM status WHERE station_id NOT IN (SELECT id FROM station WHERE city  =  \"Palo Alto\")",
        "amends": [
            "Do reference the `status` table instead of `stations` in the FROM clause. Do use a subquery with `station_id NOT IN (SELECT id FROM station WHERE city = 'Palo Alto')` instead of the direct filter `city != 'Palo Alto'` in the WHERE clause. Do apply the average function to `bikes_available` from the status table instead of assuming it exists in the stations table. The amended query now correctly calculates average bike availability by excluding Palo Alto stations through proper table relationships and subquery filtering, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about average bike availability: use the \"bikes_available\" column from the \"status\" table. 2) When excluding stations located in Palo Alto: use a subquery to filter stations where \"city\" equals 'Palo Alto' from the \"station\" table and exclude those station IDs from the main query. 3) When combining data from multiple tables: use \"station_id\" to relate the \"status\" table with the \"station\" table through a subquery condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(bikes_available) FROM stations WHERE city != 'Palo Alto';",
            "SELECT AVG(bikes_available) AS average_bike_availability FROM status WHERE station_id NOT IN (SELECT id FROM station WHERE city = 'Palo Alto')"
        ],
        "rule_sql": [
            "SELECT AVG(bikes_available) AS average_bike_availability\nFROM status\nWHERE station_id NOT IN (\n    SELECT id \n    FROM station \n    WHERE city = 'Palo Alto'\n);"
        ]
    },
    "402": {
        "db_id": "flight_1",
        "question": "What is the average distance and price for all flights from LA?",
        "ground_truth": "SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  \"Los Angeles\"",
        "amends": [
            "Do reference table `Flight` instead of `flights` in the FROM clause. Do use filter condition `origin = \"Los Angeles\"` instead of `origin = 'LAX'` in the WHERE clause. Do use lowercase `avg` function calls instead of uppercase `AVG` for both aggregate functions. The amended query now correctly calculates average distance and price for flights originating from Los Angeles instead of LAX airport code."
        ],
        "rules": [
            "1) When referencing the flights table: use the exact table name \"Flight\" instead of \"flights\". 2) When filtering for flights from Los Angeles: use the exact literal value \"Los Angeles\" for the origin column instead of airport code 'LAX'. 3) When calculating average values: use lowercase \"avg\" function calls instead of uppercase \"AVG\" for both distance and price columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(distance), AVG(price) FROM flights WHERE origin = 'LAX';",
            "SELECT avg(distance) AS average_distance, avg(price) AS average_price FROM flight WHERE origin = 'Los Angeles';"
        ],
        "rule_sql": [
            "SELECT avg(distance) AS average_distance, avg(price) AS average_price FROM Flight WHERE origin = 'Los Angeles';"
        ]
    },
    "3015": {
        "db_id": "loan_1",
        "question": "What is the average number of bank customers?",
        "ground_truth": "SELECT avg(no_of_customers) FROM bank",
        "amends": [
            "Do select `avg(no_of_customers)` from the `bank` table instead of selecting `AVG(customer_id)` from the `customers` table. Do use the correct table name `bank` instead of `customers` and the correct column name `no_of_customers` instead of `customer_id`. The amended query now correctly calculates the average number of customers from the bank table as intended."
        ],
        "rules": [
            "1) When answering about \"average number of bank customers\": compute the average of the exact column \"no_of_customers\" from table \"bank\". 2) When the question mentions \"bank customers\": \"bank customers\" actually means \"no_of_customers\" in the bank table schema. 3) When choosing identifier delimiters: do not replace the exact table name \"bank\" or column name \"no_of_customers\" with any other identifiers."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(customer_id) FROM customers;",
            "SELECT AVG(no_of_customers) FROM bank;"
        ],
        "rule_sql": [
            "SELECT AVG(no_of_customers) FROM bank;"
        ]
    },
    "2928": {
        "db_id": "sakila_1",
        "question": "What is the most popular full name of the actors?",
        "ground_truth": "SELECT first_name ,  last_name FROM actor GROUP BY first_name ,  last_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use table name `actor` instead of `actors` in the FROM clause. Do remove the `COUNT(*) as count` column from the SELECT list instead of including it. Do add the aggregate function `count(*)` directly in the ORDER BY clause instead of referencing an alias. Do maintain the GROUP BY on `first_name, last_name` and the DESC ordering with LIMIT 1. The amended query now correctly counts occurrences per actor name combination and returns the most common one without displaying the count value in the results."
        ],
        "rules": [
            "1) When the question asks about \"actors\": use the exact table name \"actor\" instead of \"actors\". 2) When counting occurrences of actor full names: group by both \"first_name\" and \"last_name\" columns. 3) When finding the most popular name: order the results by count(*) in descending order and keep only the top result (LIMIT 1). 4) When displaying results: include only \"first_name\" and \"last_name\" columns in the output, do not include the count value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name, COUNT(*) as count FROM actors GROUP BY first_name, last_name ORDER BY count DESC LIMIT 1;",
            "SELECT first_name, last_name FROM actor GROUP BY first_name, last_name ORDER BY count(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT first_name, last_name FROM actor GROUP BY first_name, last_name ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "4858": {
        "db_id": "local_govt_and_lot",
        "question": "How many customers did not have any event?",
        "ground_truth": "SELECT count(*) FROM customers WHERE customer_id NOT IN ( SELECT customer_id FROM customer_events )",
        "amends": [
            "Do reference the `customer_events` table instead of the `events` table in the subquery. Do maintain the same `COUNT(*)` aggregation and `NOT IN` predicate structure, but ensure the subquery correctly queries from the proper customer events source table. The amended query now correctly identifies customers without associated events by using the appropriate customer events table reference."
        ],
        "rules": [
            "1) When the question asks about customers without events: use the \"customer_events\" table instead of the \"events\" table to identify associated events. 2) When counting customers without events: maintain the COUNT(*) aggregation and NOT IN predicate structure to count customers whose customer_id does not appear in the customer_events table. 3) When combining customer and event information: ensure the subquery correctly queries from the customer_events table to identify which customers have associated events."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE customer_id NOT IN (SELECT customer_id FROM events);",
            "SELECT COUNT(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Customer_Events WHERE customer_id IS NOT NULL)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Customers WHERE customer_id NOT IN (SELECT DISTINCT customer_id FROM Customer_Events WHERE customer_id IS NOT NULL)"
        ]
    },
    "2217": {
        "db_id": "formula_1",
        "question": "Find the names of Japanese constructors that have once earned more than 5 points?",
        "ground_truth": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = \"Japanese\" AND T2.points > 5",
        "amends": [
            "Do add `constructorstandings` table with `JOIN` on `T1.constructorid = T2.constructorid` instead of querying only `constructors` table. Do reference `T2.points` from the joined table instead of `points` from the original table. Do use table alias `T1` for `constructors` and `T2` for `constructorstandings` instead of no aliases. Do use double quotes around \"Japanese\" instead of single quotes. The amended query now correctly filters by points from the constructor standings table rather than a non-existent points column in the constructors table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about Japanese constructors with more than 5 points: use table alias T1 for \"constructors\" and T2 for \"constructorstandings\" instead of no aliases. 2) When combining constructor data with standings data: link rows where T1.constructorid = T2.constructorid and keep only matching pairs (inner match). 3) When filtering by nationality: use double quotes around \"Japanese\" instead of single quotes. 4) When filtering by points: reference T2.points from the joined constructorstandings table instead of points from the constructors table. 5) When checking point threshold: use T2.points > 5 to find constructors that earned more than 5 points."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM constructors WHERE nationality = 'Japanese' AND points > 5;",
            "SELECT T1.name FROM constructors T1 JOIN constructorStandings T2 ON T1.constructorId = T2.constructorId WHERE T1.nationality = \"Japanese\" AND T2.points > 5 GROUP BY T1.name"
        ],
        "rule_sql": [
            "SELECT T1.name FROM constructors T1 INNER JOIN constructorstandings T2 ON T1.constructorId = T2.constructorId WHERE T1.nationality = \"Japanese\" AND T2.points > 5"
        ]
    },
    "3455": {
        "db_id": "hr_1",
        "question": "display the country ID and number of cities for each country.",
        "ground_truth": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id",
        "amends": [
            "Do use table `locations` instead of `cities` in the FROM clause while keeping the same aggregation structure with `country_id` grouping and `COUNT(*)` calculation, which correctly addresses the data source requirement. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"country ID and number of cities for each country\": make sure the output order: country_id, COUNT(*) 2) When the question mentions \"cities\": \"cities\" actually means \"locations in schema\" 3) When the question says \"per country\"/\"by country\": organize results by country_id and compute requested aggregates per group 4) When the question asks for \"number of cities\": compute the count of all rows in the locations table using COUNT(*)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country_id, COUNT(*) FROM cities GROUP BY country_id;",
            "SELECT COUNTRY_ID, COUNT(*) AS number_of_cities FROM locations GROUP BY COUNTRY_ID;"
        ],
        "rule_sql": [
            "SELECT COUNTRY_ID, COUNT(*) FROM locations GROUP BY COUNTRY_ID"
        ]
    },
    "3949": {
        "db_id": "hospital_1",
        "question": "Which patient is undergoing the most recent treatment?",
        "ground_truth": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1",
        "amends": [
            "Do select `patient` instead of `patient_id` from the source table. Do use `undergoes` as the source table instead of `treatments`. Do order by `dateundergoes` instead of `treatment_date` while maintaining ascending order. The amended query now correctly retrieves the patient from the undergoes table ordered by date.",
            "Do use lowercase `patient` instead of uppercase `Patient` for the column name. Do use lowercase `dateundergoes` instead of uppercase `DateUndergoes` for the ORDER BY clause. Do remove `DESC` ordering instead of keeping it to sort in ascending order by default. The amended query now matches RIGHT_SQL's behavior with proper lowercase column references and default ascending sort order."
        ],
        "rules": [
            "1) When answering about \"most recent treatment\": order by \"DateUndergoes\" in ascending order to get the most recent date first. 2) When selecting the patient undergoing treatment: select \"Patient\" from the \"undergoes\" table instead of \"patient_id\" from \"treatments\". 3) When the question asks for \"which patient\": return the single patient with the maximum \"DateUndergoes\" value by taking the first result after ordering.",
            "1) When the question asks for \"patient\": use the exact column name \"patient\" (lowercase) from the Undergoes table. 2) When ordering by treatment date to find the most recent: sort by \"dateundergoes\" in descending order (most recent first) instead of ascending order. 3) When selecting the patient with the most recent treatment: take only the first row after sorting by dateundergoes in descending order."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT patient_id FROM treatments ORDER BY treatment_date ASC LIMIT 1;",
            "SELECT Patient FROM Undergoes ORDER BY DateUndergoes DESC LIMIT 1;",
            "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT patient FROM Undergoes ORDER BY DateUndergoes DESC LIMIT 1;"
        ]
    },
    "114": {
        "db_id": "bike_1",
        "question": "For each city, what is the highest latitude for its stations?",
        "ground_truth": "SELECT city ,  max(lat) FROM station GROUP BY city",
        "amends": [
            "Do reference the `station` table instead of `stations` in the FROM clause. Do use the `lat` column instead of `latitude` for the MAX aggregate function. Do maintain the same GROUP BY clause on `city` and the same basic aggregation structure. The amended query now correctly references the actual table and column names to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"highest latitude for stations per city\": make sure the output order: city, then maximum latitude value. 2) When the question mentions \"stations\": \"stations\" actually means \"station\" in schema. 3) When the question mentions \"latitude\": \"latitude\" actually means \"lat\" in schema. 4) When the question asks for \"highest latitude per city\": group results by the exact token \"city\" and compute the maximum value of the exact token \"lat\" for each group. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms - use identifiers exactly as they appear in the schema (unquoted in this case)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, MAX(latitude) FROM stations GROUP BY city;",
            "SELECT city, MAX(lat) AS highest_latitude FROM station GROUP BY city;"
        ],
        "rule_sql": [
            "SELECT city, MAX(lat) FROM station GROUP BY city;"
        ]
    },
    "5495": {
        "db_id": "voter_2",
        "question": "What are the distinct first names of the students who have vice president votes and reside in a city whose city code is not PIT?",
        "ground_truth": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  \"PIT\"",
        "amends": [
            "Do use `T1.Fname` with table alias instead of `first_name` without qualification. Do join `STUDENT AS T1` with `VOTING_RECORD AS T2` on `T1.StuID = T2.VICE_PRESIDENT_Vote` instead of querying a single table. Do use `EXCEPT` to exclude students with `city_code = \"PIT\"` instead of filtering with `city_code != 'PIT'` in the WHERE clause. Do remove the `WHERE votes = 'vice president'` condition entirely since the join on `VICE_PRESIDENT_Vote` already handles this logic. The amended query now correctly identifies students who voted for vice president while excluding those from Pittsburgh, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about distinct first names of students: use T1.Fname as the output column. 2) When the question mentions students who have vice president votes: join STUDENT AS T1 with VOTING_RECORD AS T2 on T1.StuID = T2.VICE_PRESIDENT_Vote to identify these students. 3) When the question mentions students who reside in a city whose city code is not PIT: use EXCEPT to exclude students with city_code = \"PIT\" instead of filtering with inequality. 4) When combining T1 and T2 for shared entities: link rows where T1.StuID = T2.VICE_PRESIDENT_Vote and keep only matching pairs (inner match). 5) When handling text literals: use exact literal \"PIT\" with double quotes as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT first_name FROM students WHERE votes = 'vice president' AND city_code != 'PIT';",
            "SELECT DISTINCT T1.Fname\nFROM STUDENT AS T1\nJOIN VOTING_RECORD AS T2 ON T1.StuID = T2.VICE_PRESIDENT_Vote\nEXCEPT\nSELECT DISTINCT T1.Fname\nFROM STUDENT AS T1\nJOIN VOTING_RECORD AS T2 ON T1.StuID = T2.VICE_PRESIDENT_Vote\nWHERE T1.city_code = 'PIT'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Fname\nFROM Student AS T1\nJOIN Voting_record AS T2 ON T1.StuID = T2.Vice_President_Vote\nEXCEPT\nSELECT DISTINCT T1.Fname\nFROM Student AS T1\nJOIN Voting_record AS T2 ON T1.StuID = T2.Vice_President_Vote\nWHERE T1.city_code = \"PIT\""
        ]
    },
    "3954": {
        "db_id": "hospital_1",
        "question": "Find the names of nurses who are nursing an undergoing treatment.",
        "ground_truth": "SELECT DISTINCT T2.name FROM undergoes AS T1 JOIN nurse AS T2 ON T1.AssistingNurse  =  T2.EmployeeID",
        "amends": [
            "Do use `DISTINCT T2.name` instead of `name` to eliminate duplicates. Do join `undergoes AS T1` and `nurse AS T2` instead of querying only `nurses` table. Do specify join condition `ON T1.AssistingNurse = T2.EmployeeID` instead of filtering by `status = 'undergoing treatment'`. The amended query now correctly retrieves distinct nurse names who are assisting in undergoing treatments rather than nurses with a specific status, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"names of nurses who are nursing an undergoing treatment\": make sure the output order: T2.name. 2) When the question asks for nurse names: use \"T2.name\" from the nurse table. 3) When combining undergoes table (T1) and nurse table (T2): link rows where T1.AssistingNurse = T2.EmployeeID and keep only matching pairs (inner match). 4) When eliminating duplicate nurse names: use DISTINCT on T2.name. 5) When the question mentions \"nursing an undergoing treatment\": this means the nurse must be assisting in treatments, not filtering by a status field."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM nurses WHERE status = 'undergoing treatment';",
            "SELECT DISTINCT T2.Name FROM Undergoes AS T1 JOIN Nurse AS T2 ON T1.AssistingNurse = T2.EmployeeID"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.name FROM Undergoes T1 INNER JOIN Nurse T2 ON T1.AssistingNurse = T2.EmployeeID ORDER BY T2.name;"
        ]
    },
    "700": {
        "db_id": "customers_card_transactions",
        "question": "What are card ids, customer ids, card types, and card numbers for each customer card?",
        "ground_truth": "SELECT card_id ,  customer_id ,  card_type_code ,  card_number FROM Customers_cards",
        "amends": [
            "Do reference `card_type_code` instead of `card_type` in the SELECT list. Do reference table `Customers_cards` instead of `customer_cards` in the FROM clause. Do remove the `WHERE customer_id IS NULL` filter instead of keeping it. The amended query now correctly selects all columns from the Customers_cards table without unnecessary filtering."
        ],
        "rules": [
            "1) When selecting card type information: use \"card_type_code\" instead of \"card_type\" as the column name. 2) When referencing the customer cards table: use \"Customers_Cards\" as the exact table name with proper case and spelling. 3) When the question asks for all customer cards: do not apply any WHERE filter that would restrict results to only NULL customer_id values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT card_id, customer_id, card_type, card_number FROM customer_cards WHERE customer_id IS NULL;",
            "SELECT card_id, customer_id, card_type_code, card_number FROM Customers_Cards"
        ],
        "rule_sql": [
            "SELECT card_id, customer_id, card_type_code, card_number FROM Customers_Cards"
        ]
    },
    "3532": {
        "db_id": "music_1",
        "question": "Find the id of the song that lasts the longest.",
        "ground_truth": "SELECT f_id FROM files ORDER BY duration DESC LIMIT 1",
        "amends": [
            "Do select `f_id` from the `files` table instead of `id` from `songs`. Do order by `duration DESC` instead of `ASC`. The amended query now correctly retrieves the file ID with the longest duration from the files table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"the id of the song that lasts the longest\": make sure the output order: f_id. 2) When the question mentions \"id\": \"id\" actually means \"f_id in schema\". 3) When the question mentions \"longest\" or \"lasts the longest\": rank rows by duration in descending order and keep the first 1 row. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM songs ORDER BY duration ASC LIMIT 1;",
            "SELECT f_id FROM files ORDER BY duration DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT f_id FROM files ORDER BY duration DESC LIMIT 1"
        ]
    },
    "2099": {
        "db_id": "cre_Doc_Control_Systems",
        "question": "What is the description of document status code 'working'?",
        "ground_truth": "SELECT document_status_description FROM Ref_Document_Status WHERE document_status_code = \"working\";",
        "amends": [
            "Do reference `document_status_description` instead of `description` in the SELECT list. Do use table `Ref_Document_Status` instead of `document_status` as the FROM source. Do filter on `document_status_code` instead of `status_code` in the WHERE clause. Do use double quotes around the string literal \"working\" instead of single quotes. The amended query now correctly references the proper column names and table structure to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"description\" of a document status code: use the exact column name \"document_status_description\" from table \"Ref_Document_Status\" instead of \"description\". 2) When filtering for document status codes: use the exact column name \"document_status_code\" instead of \"status_code\" in the WHERE clause. 3) When referencing string literals for document status codes: use double quotes around the exact value \"working\" instead of single quotes. 4) When querying document status information: use table \"Ref_Document_Status\" as the source instead of \"document_status\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description FROM document_status WHERE status_code = 'working';",
            "SELECT document_status_description FROM Ref_Document_Status WHERE document_status_code = \"working\";"
        ],
        "rule_sql": [
            "SELECT document_status_description FROM Ref_Document_Status WHERE document_status_code = \"working\";"
        ]
    },
    "2851": {
        "db_id": "customer_deliveries",
        "question": "Find the states which do not have any employee in their record.",
        "ground_truth": "SELECT state_province_county FROM addresses WHERE address_id NOT IN (SELECT employee_address_id FROM Employees)",
        "amends": [
            "Do select `state_province_county` from the `addresses` table instead of `state` from `employees`. Do filter with `address_id NOT IN` a subquery selecting `employee_address_id` from `Employees` instead of checking `employee_id IS NULL`. Do completely change the data source to `addresses` instead of `employees` and use a correlated subquery pattern instead of a simple null check. The amended query now correctly identifies addresses not associated with any employee rather than incorrectly looking for null employee IDs."
        ],
        "rules": [
            "1) When answering about \"states which do not have any employee\": make sure the output order: state_province_county. 2) When the question mentions \"states\": \"states\" actually means \"state_province_county in Addresses table\". 3) When identifying addresses not associated with any employee: filter addresses where address_id is not found in the employee_address_id values from the Employees table. 4) When combining Addresses and Employees tables: use an inner match pattern where addresses are kept only if their address_id does not appear in the employee_address_id column of Employees. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for state_province_county and other column names."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT state FROM employees WHERE employee_id IS NULL;",
            "SELECT DISTINCT state_province_county \nFROM Addresses \nWHERE address_id NOT IN (\n    SELECT employee_address_id \n    FROM Employees\n)"
        ],
        "rule_sql": [
            "SELECT DISTINCT a.state_province_county\nFROM Addresses a\nWHERE a.address_id NOT IN (\n    SELECT employee_address_id \n    FROM Employees\n)\nORDER BY a.state_province_county;"
        ]
    },
    "297": {
        "db_id": "twitter_1",
        "question": "Find the name of the user who tweeted more than once, and number of tweets tweeted by them.",
        "ground_truth": "SELECT T1.name ,  count(*) FROM user_profiles AS T1 JOIN tweets AS T2 ON T1.uid  =  T2.uid GROUP BY T2.uid HAVING count(*)  >  1",
        "amends": [
            "Do reference `user_profiles` as `T1` instead of `users` and `tweets` as `T2` instead of `tweets`. Do use `T1.uid = T2.uid` as the join condition instead of `users.user_id = tweets.user_id`. Do select `T1.name` instead of `name` and omit the `tweet_count` alias instead of including it. Do group by `T2.uid` instead of `users.user_id` while keeping the same `HAVING count(*) > 1` condition. The amended query now correctly joins on the proper uid columns and maintains the intended logic of finding users with more than one tweet."
        ],
        "rules": [
            "1) When the question asks about users who tweeted: use table \"user_profiles\" as T1 and table \"tweets\" as T2 instead of \"users\" and \"tweets\". 2) When combining user_profiles and tweets: link rows where T1.uid = T2.uid exactly. 3) When selecting the user name: use T1.name instead of just name. 4) When counting tweets per user: group by T2.uid and count all rows. 5) When filtering for users with more than one tweet: keep only groups where the count is greater than 1. 6) When presenting results: output T1.name and the count without any alias for the count column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, COUNT(*) as tweet_count FROM users JOIN tweets ON users.user_id = tweets.user_id GROUP BY users.user_id HAVING tweet_count > 1",
            "SELECT T1.name, COUNT(*) FROM user_profiles T1 JOIN tweets T2 ON T1.uid = T2.uid GROUP BY T2.uid HAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T1.name, COUNT(*) FROM user_profiles AS T1 JOIN tweets AS T2 ON T1.uid = T2.uid GROUP BY T2.uid HAVING COUNT(*) > 1"
        ]
    },
    "2093": {
        "db_id": "pilot_record",
        "question": "Show the names of pilots and fleet series of the aircrafts they have flied with in ascending order of the rank of the pilot.",
        "ground_truth": "SELECT T3.Pilot_name ,  T2.Fleet_Series FROM pilot_record AS T1 JOIN aircraft AS T2 ON T1.Aircraft_ID  =  T2.Aircraft_ID JOIN pilot AS T3 ON T1.Pilot_ID  =  T3.Pilot_ID ORDER BY T3.Rank",
        "amends": [
            "Do `T3.Pilot_name` and `T2.Fleet_Series` instead of `p.name` and `a.fleet_series` for the SELECT list. Do `pilot_record AS T1` as the primary FROM source instead of starting with `pilots p`. Do `JOIN aircraft AS T2 ON T1.Aircraft_ID = T2.Aircraft_ID` instead of `JOIN aircrafts a ON f.aircraft_id = a.aircraft_id` with corrected table aliases and join condition. Do `JOIN pilot AS T3 ON T1.Pilot_ID = T3.Pilot_ID` instead of `JOIN flights f ON p.pilot_id = f.pilot_id` with the correct join direction and table relationships. Do `ORDER BY T3.Rank` instead of `ORDER BY p.rank ASC` with the correct table alias and removing the unnecessary ASC keyword. The amended query now correctly navigates through pilot_record as the central table linking pilots to aircraft, matching RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting pilot names and fleet series: use T3.Pilot_name and T2.Fleet_Series as the output columns. 2) When starting from the primary source: use pilot_record AS T1 as the base table. 3) When joining aircraft information: combine T1 with aircraft AS T2 where T1.Aircraft_ID = T2.Aircraft_ID. 4) When joining pilot information: combine T1 with pilot AS T3 where T1.Pilot_ID = T3.Pilot_ID. 5) When ordering by pilot rank: sort the results by T3.Rank in ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.name, a.fleet_series FROM pilots p JOIN flights f ON p.pilot_id = f.pilot_id JOIN aircrafts a ON f.aircraft_id = a.aircraft_id ORDER BY p.rank ASC;",
            "SELECT T3.Pilot_name, T2.Fleet_Series\nFROM pilot_record AS T1\nJOIN aircraft AS T2 ON T1.Aircraft_ID = T2.Aircraft_ID\nJOIN pilot AS T3 ON T1.Pilot_ID = T3.Pilot_ID\nORDER BY T3.Rank;"
        ],
        "rule_sql": [
            "SELECT T3.Pilot_name, T2.Fleet_Series\nFROM pilot_record AS T1\nJOIN aircraft AS T2 ON T1.Aircraft_ID = T2.Aircraft_ID\nJOIN pilot AS T3 ON T1.Pilot_ID = T3.Pilot_ID\nORDER BY T3.Rank ASC;"
        ]
    },
    "6865": {
        "db_id": "flight_4",
        "question": "Find the cities which have exactly two airports.",
        "ground_truth": "SELECT city FROM airports GROUP BY city HAVING count(*)  =  2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM airports GROUP BY city HAVING COUNT(*) = 2;"
        ],
        "rule_sql": [
            "SELECT city, COUNT(*) as airport_count\nFROM airports\nGROUP BY city\nHAVING COUNT(*) = 2\nORDER BY city;",
            "SELECT city, COUNT(*) as airport_count\nFROM airports\nGROUP BY city\nHAVING COUNT(*) = 2;",
            "SELECT city, COUNT(*) as airport_count\nFROM airports\nGROUP BY city\nHAVING COUNT(*) = 2;",
            "SELECT city, COUNT(*) as airport_count\nFROM airports\nGROUP BY city\nHAVING COUNT(*) = 2;"
        ]
    },
    "2039": {
        "db_id": "party_people",
        "question": "How many regions do we have?",
        "ground_truth": "SELECT count(*) FROM region",
        "amends": [
            "Do query the `region` table instead of the `countries` table. The amended query now correctly counts records from the region table as specified in the target query."
        ],
        "rules": [
            "1) When answering about \"how many regions\": make sure to count records from the \"region\" table instead of the \"countries\" table. 2) When counting entities: compute the number of rows using the canonical table \"region\" as specified in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries;",
            "SELECT COUNT(*) FROM region;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM region;"
        ]
    },
    "2237": {
        "db_id": "machine_repair",
        "question": "What are the team and starting year of technicians?",
        "ground_truth": "SELECT Team ,  Starting_Year FROM technician",
        "amends": [
            "Do reference the `technician` table instead of `technicians` to match the correct table name. Do use column names `Team` and `Starting_Year` instead of `team` and `starting_year` to match the correct column capitalization. Do remove the `WHERE role = 'manager'` filter instead of keeping it since the right query does not include this condition. The amended query now correctly selects all records from the technician table without filtering."
        ],
        "rules": [
            "1) When the question asks about technicians: use the table name \"technician\" exactly as shown in the schema, not \"technicians\". 2) When selecting team information: use the column name \"Team\" with exact capitalization as shown in the schema. 3) When selecting starting year information: use the column name \"Starting_Year\" with exact capitalization as shown in the schema. 4) When the question does not specify any filtering conditions: do not apply any WHERE clause filters like 'role = \"manager\"'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT team, starting_year FROM technicians WHERE role = 'manager';",
            "SELECT Team, Starting_Year FROM technician;"
        ],
        "rule_sql": [
            "SELECT Team, Starting_Year FROM technician;"
        ]
    },
    "1347": {
        "db_id": "college_2",
        "question": "Count the number of courses without prerequisites.",
        "ground_truth": "SELECT count(*) FROM course WHERE course_id NOT IN (SELECT course_id FROM prereq)",
        "amends": [
            "Do use `count(*)` from the `course` table instead of `COUNT(*)` from `courses`. Do change the WHERE filter to use a subquery condition `course_id NOT IN (SELECT course_id FROM prereq)` instead of checking `prerequisite_id IS NOT NULL`. Do remove the incorrect table name `courses` and use the correct `course` table instead. The amended query now correctly identifies courses without prerequisites by checking against the prereq table instead of relying on a potentially incorrect prerequisite_id field, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting courses without prerequisites: use the exact table name \"course\" instead of \"courses\". 2) When identifying courses without prerequisites: check that the course_id is not found in the prereq table using a subquery condition (course_id NOT IN (SELECT course_id FROM prereq)) instead of checking prerequisite_id IS NOT NULL. 3) When counting entities: use count(*) from the correct table to get the total count of courses meeting the condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM courses WHERE prerequisite_id IS NOT NULL;",
            "SELECT COUNT(*) FROM course WHERE course_id NOT IN (SELECT course_id FROM prereq)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM course WHERE course_id NOT IN (SELECT course_id FROM prereq)"
        ]
    },
    "0": {
        "db_id": "department_management",
        "question": "How many heads of the departments are older than 56 ?",
        "ground_truth": "SELECT count(*) FROM head WHERE age  >  56",
        "amends": [
            "Do reference table `head` instead of `departments` while keeping the same `COUNT(*)` aggregate and `age > 56` filter unchanged. The amended query now correctly queries the intended table while maintaining the same counting logic and age-based filtering condition, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"heads of the departments\": use table \"head\" instead of \"departments\" for counting heads. 2) When counting heads older than 56: apply the condition age > 56 to filter the heads. 3) When counting the number of heads: use COUNT(*) to count all matching rows from the head table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM departments WHERE age > 56;",
            "SELECT COUNT(*) FROM head WHERE age > 56"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM head WHERE age > 56"
        ]
    },
    "157": {
        "db_id": "bike_1",
        "question": "For each zip code, return how many times max wind speed reached 25?",
        "ground_truth": "SELECT zip_code , count(*) FROM weather WHERE max_wind_Speed_mph  >=  25 GROUP BY zip_code",
        "amends": [
            "Do reference table `weather` instead of `weather_data`. Do use column `max_wind_Speed_mph` instead of `max_wind_speed`. Do apply filter `>= 25` instead of `= 25` to capture all wind speeds at or above the threshold instead of exactly 25 mph. The amended query now correctly counts zip codes with maximum wind speeds of 25 mph or greater, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about zip codes and wind speeds: use table \"weather\" instead of \"weather_data\". 2) When measuring maximum wind speed: use column \"max_wind_Speed_mph\" instead of \"max_wind_speed\". 3) When filtering for wind speeds reaching 25 mph: apply condition >= 25 instead of = 25 to capture all wind speeds at or above the threshold. 4) When counting occurrences per zip code: group by zip_code and count the number of rows where max_wind_Speed_mph >= 25."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT zip_code, COUNT(*) FROM weather_data WHERE max_wind_speed = 25 GROUP BY zip_code;",
            "SELECT zip_code, COUNT(*) AS count_max_wind_25_or_more\nFROM weather\nWHERE max_wind_Speed_mph >= 25\nGROUP BY zip_code\nORDER BY zip_code;"
        ],
        "rule_sql": [
            "SELECT zip_code, COUNT(*) AS count_max_wind_25\nFROM weather\nWHERE max_wind_Speed_mph >= 25\nGROUP BY zip_code;"
        ]
    },
    "4530": {
        "db_id": "document_management",
        "question": "What are the names of documents that contain the substring \"CV\"?",
        "ground_truth": "SELECT document_name FROM documents WHERE document_name LIKE \"%CV%\"",
        "amends": [
            "Do reference `document_name` in the SELECT list and WHERE clause instead of `name`, as the correct column name is `document_name` rather than `name`. Do use double quotes for the string pattern instead of single quotes, though this is a cosmetic difference that doesn't affect functionality. The amended query now correctly filters for documents containing \"CV\" in the document_name field, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for document names containing \"CV\": use the exact column token \"document_name\" from the Documents table instead of \"name\". 2) When filtering for documents containing the substring \"CV\": use the pattern \"%CV%\" with double quotes around the literal value. 3) When producing output: return only the \"document_name\" column in the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM documents WHERE name LIKE '%CV%';",
            "SELECT document_name FROM Documents WHERE document_name LIKE \"%CV%\""
        ],
        "rule_sql": [
            "SELECT document_name FROM Documents WHERE document_name LIKE \"%CV%\";"
        ]
    },
    "5844": {
        "db_id": "tracking_share_transactions",
        "question": "Find the number of investors in total.",
        "ground_truth": "SELECT count(*) FROM INVESTORS",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM investors WHERE investor_id IS NOT NULL;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS total_investors FROM Investors;"
        ]
    },
    "1376": {
        "db_id": "college_2",
        "question": "Which department has the lowest budget?",
        "ground_truth": "SELECT dept_name FROM department ORDER BY budget LIMIT 1",
        "amends": [
            "Do select `dept_name` instead of `department_name` and remove `budget` from the SELECT list instead of including it. Do reference table `department` instead of `departments` as the FROM source. Do use `ORDER BY budget` in ascending order instead of `ORDER BY budget DESC` for descending order. The amended query now correctly retrieves the department with the smallest budget from the department table."
        ],
        "rules": [
            "1) When the question asks about \"department\": use table \"department\" instead of \"departments\" as the source table. 2) When selecting the department name: use column \"dept_name\" instead of \"department_name\". 3) When finding the department with the lowest budget: order by \"budget\" in ascending order instead of descending order. 4) When outputting results for the department with lowest budget: include only \"dept_name\" in the output, not \"budget\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department_name, budget FROM departments ORDER BY budget DESC LIMIT 1;",
            "SELECT dept_name FROM department ORDER BY budget ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT dept_name FROM department ORDER BY budget ASC LIMIT 1;"
        ]
    },
    "5759": {
        "db_id": "dorm_1",
        "question": "What is the name and capacity of the dorm with the fewest amount of amenities?",
        "ground_truth": "SELECT T1.dorm_name ,  T1.student_capacity FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid JOIN dorm_amenity AS T3 ON T2.amenid  =  T3.amenid GROUP BY T2.dormid ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do select `T1.dorm_name` and `T1.student_capacity` instead of `name` and `capacity`. Do use `FROM dorm AS T1` with explicit table aliases instead of `FROM dorms`. Do add `JOIN has_amenity AS T2 ON T1.dormid = T2.dormid` and `JOIN dorm_amenity AS T3 ON T2.amenid = T3.amenid` instead of omitting these joins. Do add `GROUP BY T2.dormid` instead of omitting grouping. Do use `ORDER BY count(*)` instead of `ORDER BY COUNT(amenities)`. The amended query now correctly joins the necessary tables to count amenities per dorm and returns the dorm with the fewest amenities."
        ],
        "rules": [
            "1) When answering about \"name and capacity of the dorm with the fewest amenities\": make sure the output order: T1.dorm_name, T1.student_capacity. 2) When the question mentions \"name\": \"name\" actually means \"T1.dorm_name in schema\". 3) When the question mentions \"capacity\": \"capacity\" actually means \"T1.student_capacity in schema\". 4) When combining T1, T2, and T3 for shared entities: link rows where T1.dormid = T2.dormid and T2.amenid = T3.amenid; keep only matching pairs (inner match). 5) When the question asks for \"fewest amount of amenities\": rank rows by count(*) in ascending order and keep the first 1 row. 6) When the question says \"per dorm\"/\"by dorm\": organize results by T2.dormid and compute requested aggregates per group. 7) When counting amenities: compute the number of rows using count(*) for each dorm group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, capacity FROM dorms ORDER BY COUNT(amenities) ASC LIMIT 1;",
            "SELECT T1.dorm_name, T1.student_capacity\nFROM Dorm AS T1\nJOIN Has_amenity AS T2 ON T1.dormid = T2.dormid\nGROUP BY T2.dormid\nORDER BY COUNT(*) ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.dorm_name, T1.student_capacity\nFROM Dorm T1\nJOIN Has_amenity T2 ON T1.dormid = T2.dormid\nGROUP BY T1.dormid\nORDER BY COUNT(*) ASC\nLIMIT 1;"
        ]
    },
    "5146": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "What are the order dates of orders with price higher than 1000?",
        "ground_truth": "SELECT T1.Order_Date FROM Customer_Orders AS T1 JOIN ORDER_ITEMS AS T2 ON T1.Order_ID  =  T2.Order_ID JOIN Products AS T3 ON T2.Product_ID  =  T3.Product_ID WHERE T3.Product_price  >  1000",
        "amends": [
            "Do add `T1.Order_Date` instead of `order_date` and change the source to `Customer_Orders AS T1` instead of `orders`. Do add `JOIN ORDER_ITEMS AS T2 ON T1.Order_ID = T2.Order_ID` and `JOIN Products AS T3 ON T2.Product_ID = T3.Product_ID` instead of querying a single table. Do change the filter to `T3.Product_price > 1000` instead of `price > 1000` to reference the correct table and column. The amended query now correctly joins the necessary tables to filter by product price rather than a potentially ambiguous price column, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"order dates of orders with price higher than 1000\": make sure the output order: T1.Order_Date\n2) When the question mentions \"orders\": \"orders\" actually means \"Customer_Orders AS T1\" in schema\n3) When the question mentions \"price higher than 1000\": \"price\" actually means \"T3.Product_price > 1000\" in schema\n4) When combining T1 and T2 for shared entities: link rows where T1.Order_ID = T2.Order_ID; keep only matching pairs (inner match)\n5) When combining T2 and T3 for shared entities: link rows where T2.Product_ID = T3.Product_ID; keep only matching pairs (inner match)\n6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for identifiers like T1.Order_Date, T1.Order_ID, T2.Order_ID, T2.Product_ID, T3.Product_ID, and T3.Product_price"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT order_date FROM orders WHERE price > 1000;",
            "SELECT T1.Order_Date\nFROM Customer_Orders AS T1\nJOIN Order_Items AS T2 ON T1.Order_ID = T2.Order_ID\nJOIN Products AS T3 ON T2.Product_ID = T3.Product_ID\nWHERE T3.Product_Price > 1000"
        ],
        "rule_sql": [
            "SELECT T1.Order_Date\nFROM Customer_Orders AS T1\nINNER JOIN Order_Items AS T2 ON T1.Order_ID = T2.Order_ID\nINNER JOIN Products AS T3 ON T2.Product_ID = T3.Product_ID\nWHERE T3.Product_Price > 1000"
        ]
    },
    "1355": {
        "db_id": "college_2",
        "question": "What is the name of the department with an instructure who has a name like 'Soisalon'?",
        "ground_truth": "SELECT dept_name FROM instructor WHERE name LIKE '%Soisalon%'",
        "amends": [
            "Do select `dept_name` from the `instructor` table instead of `department_name` from the `departments` table. Do use the `name` column with wildcards on both sides (`%Soisalon%`) for the LIKE pattern instead of only a trailing wildcard (`Soisalon%`) on the `instructor_name` column. The amended query now correctly searches for the pattern anywhere in the name field of the instructor table rather than just names starting with that pattern in a different table."
        ],
        "rules": [
            "1) When the question asks for department name information: use the \"dept_name\" column from the \"instructor\" table instead of \"department_name\" from a \"departments\" table. 2) When searching for names containing a pattern like 'Soisalon': use wildcards on both sides of the pattern (\"%Soisalon%\") in the \"name\" column rather than only a trailing wildcard. 3) When the question mentions an instructor with a specific name pattern: search in the \"instructor\" table's \"name\" column rather than a different table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department_name FROM departments WHERE instructor_name LIKE 'Soisalon%';",
            "SELECT dept_name FROM instructor WHERE name LIKE '%Soisalon%'"
        ],
        "rule_sql": [
            "SELECT DISTINCT dept_name FROM instructor WHERE name LIKE '%Soisalon%';"
        ]
    },
    "222": {
        "db_id": "book_2",
        "question": "Show the title and publication dates of books.",
        "ground_truth": "SELECT T1.Title ,  T2.Publication_Date FROM book AS T1 JOIN publication AS T2 ON T1.Book_ID  =  T2.Book_ID",
        "amends": [
            "Do add `T2.Publication_Date` to the SELECT list instead of `author`. Do change the FROM clause to use `book AS T1 JOIN publication AS T2` instead of just `books`. Do add the join condition `ON T1.Book_ID = T2.Book_ID` instead of having no join. Do remove the `author` column and instead include `Publication_Date` from the joined table. The amended query now correctly joins the book and publication tables to retrieve title and publication date information, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"title and publication dates of books\": make sure the output order: title, Publication_Date. 2) When the question mentions \"books\": \"books\" actually means \"book AS T1\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.Book_ID = T2.Book_ID; keep only matching pairs (inner match). 4) When selecting publication dates: use T2.Publication_Date from the publication table instead of author from the book table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title, author FROM books;",
            "SELECT T1.Title, T2.Publication_Date FROM book AS T1 JOIN publication AS T2 ON T1.Book_ID = T2.Book_ID"
        ],
        "rule_sql": [
            "SELECT T1.Title, T2.Publication_Date FROM book AS T1 INNER JOIN publication AS T2 ON T1.Book_ID = T2.Book_ID"
        ]
    },
    "3013": {
        "db_id": "loan_1",
        "question": "What is the average number of customers across banks in the state of Utah?",
        "ground_truth": "SELECT avg(no_of_customers) FROM bank WHERE state  =  'Utah'",
        "amends": [
            "Do reference the `no_of_customers` column instead of the non-existent `customers` column. Do use the correct table name `bank` instead of the incorrect plural `banks`. Do maintain the lowercase `avg` aggregate function and the filter condition `state = 'Utah'` without changes. The amended query now correctly calculates the average number of customers for banks in Utah using the proper schema elements."
        ],
        "rules": [
            "1) When the question asks for \"customers\" in the context of banks: \"customers\" actually means \"no_of_customers\" in the schema. 2) When referring to the table containing bank information: use the exact table name \"bank\" instead of plural forms. 3) When filtering for banks in a specific state: use the exact literal value 'Utah' with the correct case and quotes. 4) When calculating the average number of customers: use the avg aggregate function on the \"no_of_customers\" column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(customers) FROM banks WHERE state = 'Utah';",
            "SELECT AVG(no_of_customers) FROM bank WHERE state = 'Utah';"
        ],
        "rule_sql": [
            "SELECT AVG(no_of_customers) FROM bank WHERE state = 'Utah';"
        ]
    },
    "6535": {
        "db_id": "wine_1",
        "question": "Find the names of all distinct wines that have appellations in North Coast area.",
        "ground_truth": "SELECT DISTINCT T2.Name FROM APPELLATIONs AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.Area  =  \"North Coast\"",
        "amends": [
            "Do select `T2.Name` instead of `wine_name` and use table aliases `T1` and `T2` instead of direct table references. Do join `APPELLATIONs AS T1` with `WINE AS T2` on `T1.Appelation = T2.Appelation` instead of querying a single table. Do filter on `T1.Area = \"North Coast\"` instead of `appellation_area = 'North Coast'` and use double quotes instead of single quotes for the string literal. The amended query now correctly joins the two related tables to find wines from the North Coast area, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"names of all distinct wines that have appellations in North Coast area\": make sure the output order: T2.Name\n2) When the question mentions \"wines\": \"wines\" actually means \"WINE table as T2\" in schema\n3) When the question mentions \"appellations in North Coast area\": \"appellations\" actually means \"APPELLATIONs table as T1\" and \"North Coast area\" actually means \"T1.Area = \\\"North Coast\\\"\"\n4) When combining T1 and T2 for shared entities: link rows where T1.Appelation = T2.Appelation; keep only matching pairs (inner match)\n5) When the question asks for \"distinct wines\": compute the number of unique values of T2.Name\n6) When handling text literals: do not change case, spacing, or punctuation - use exactly \\\"North Coast\\\" with double quotes"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT wine_name FROM wines WHERE appellation_area = 'North Coast';",
            "SELECT DISTINCT T2.Name FROM appellations AS T1 JOIN wine AS T2 ON T1.Appelation = T2.Appelation WHERE T1.Area = \"North Coast\""
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.Name\nFROM appellations AS T1\nINNER JOIN wine AS T2 ON T1.Appelation = T2.Appelation\nWHERE T1.Area = \"North Coast\"\nORDER BY T2.Name"
        ]
    },
    "2111": {
        "db_id": "cre_Doc_Control_Systems",
        "question": "What is the document status description of the document with id 1?",
        "ground_truth": "SELECT Ref_Document_Status.document_status_description FROM Ref_Document_Status JOIN Documents ON Documents.document_status_code = Ref_Document_Status.document_status_code WHERE Documents.document_id = 1;",
        "amends": [
            "Do select `Ref_Document_Status.document_status_description` instead of just `status` from the result set. Do add `Ref_Document_Status` table via `JOIN` instead of querying only the `documents` table. Do join on `Documents.document_status_code = Ref_Document_Status.document_status_code` instead of having no join condition. Do filter on `Documents.document_id = 1` instead of `id = 1` to use the correct column name. The amended query now correctly retrieves the document status description from the reference table by joining on the status code rather than returning a potentially ambiguous status field directly, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"document status description\": select \"Ref_Document_Status\".\"document_status_description\" instead of just \"status\". 2) When querying document status information: join the \"documents\" table with \"Ref_Document_Status\" table using the condition \"Documents\".\"document_status_code\" = \"Ref_Document_Status\".\"document_status_code\". 3) When filtering by document id: use \"Documents\".\"document_id\" = 1 instead of just \"id\" = 1 to reference the correct column name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT status FROM documents WHERE id = 1;",
            "SELECT Ref_Document_Status.document_status_description \nFROM Documents \nJOIN Ref_Document_Status ON Documents.document_status_code = Ref_Document_Status.document_status_code \nWHERE Documents.document_id = 1"
        ],
        "rule_sql": [
            "SELECT Ref_Document_Status.document_status_description \nFROM Documents \nJOIN Ref_Document_Status ON Documents.document_status_code = Ref_Document_Status.document_status_code \nWHERE Documents.document_id = 1"
        ]
    },
    "2793": {
        "db_id": "election",
        "question": "Which people severed as governor most frequently?",
        "ground_truth": "SELECT Governor FROM party GROUP BY Governor ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select `Governor` instead of `name` and `COUNT(*)` as `governor_count`. Do use `FROM party` instead of `FROM people`. Do group by `Governor` instead of `name`. Do order by `COUNT(*)` instead of `governor_count`. The amended query now correctly counts governors by party affiliation rather than counting all people by name.",
            "Do remove the `COUNT(*) AS governor_count` column from the SELECT list instead of including it, since the query only needs to return the Governor with the highest count. Do add `LIMIT 1` at the end instead of omitting it, to return only the single Governor with the maximum count rather than all Governors ordered by count. The amended query now correctly returns just the Governor with the highest occurrence count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"people who served as governor most frequently\": make sure the output order: Governor, governor_count. 2) When the question mentions \"people\": \"people\" actually means \"Governor in party table\". 3) When counting governors: compute the number of occurrences using the exact token \"Governor\" from the party table. 4) When grouping by governor: organize results by the exact token \"Governor\" and count occurrences per governor. 5) When ranking by frequency: rank rows by the count of governor occurrences in descending order and keep the first 1 row.",
            "1) When answering about \"which people served as governor most frequently\": make sure the output order: Governor only. 2) When the question asks for the most frequently serving governor: count occurrences using the canonical key for Governor and return only the single Governor with the maximum count. 3) When counting occurrences of Governor: compute the number of rows using the exact token \"Governor\" from the schema. 4) When the question implies finding the top result: rank rows by count of Governor in descending order and keep only the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, COUNT(*) as governor_count FROM people GROUP BY name ORDER BY governor_count DESC LIMIT 1;",
            "SELECT Governor, COUNT(*) AS governor_count FROM party GROUP BY Governor ORDER BY COUNT(*) DESC;",
            "SELECT Governor FROM party GROUP BY Governor ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Governor, COUNT(*) AS governor_count FROM party GROUP BY Governor ORDER BY governor_count DESC LIMIT 1;"
        ]
    },
    "4728": {
        "db_id": "department_store",
        "question": "Count the number of stores the chain South has.",
        "ground_truth": "SELECT count(*) FROM department_stores AS T1 JOIN department_store_chain AS T2 ON T1.dept_store_chain_id  =  T2.dept_store_chain_id WHERE T2.dept_store_chain_name  =  \"South\"",
        "amends": [
            "Do join `department_stores` with `department_store_chain` on `dept_store_chain_id` instead of querying only the `stores` table. Do filter on `dept_store_chain_name = \"South\"` instead of `chain = 'South'`. Do use table aliases `T1` and `T2` instead of no aliases. The amended query now correctly counts department stores belonging to the \"South\" chain by properly joining the related tables."
        ],
        "rules": [
            "1) When the question asks about stores belonging to a chain: join table \"Department_Stores\" as T1 with table \"Department_Store_Chain\" as T2 using the exact key T1.dept_store_chain_id = T2.dept_store_chain_id. 2) When filtering for chain name \"South\": use the exact literal \"South\" with T2.dept_store_chain_name = \"South\". 3) When counting department stores: count using the canonical key T1.dept_store_chain_id to get the number of stores belonging to the specified chain."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM stores WHERE chain = 'South';",
            "SELECT COUNT(*) \nFROM Department_Stores T1\nJOIN Department_Store_Chain T2 ON T1.dept_store_chain_id = T2.dept_store_chain_id\nWHERE T2.dept_store_chain_name = 'South'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.dept_store_id) \nFROM Department_Stores AS T1\nJOIN Department_Store_Chain AS T2 ON T1.dept_store_chain_id = T2.dept_store_chain_id\nWHERE T2.dept_store_chain_name = 'South';"
        ]
    },
    "6106": {
        "db_id": "customers_and_addresses",
        "question": "What are the name and active date of the customers whose contact channel code is email?",
        "ground_truth": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  'Email'",
        "amends": [
            "Do select `t1.customer_name` and `t2.active_from_date` instead of `name` and `active_date`. Do join `customer_contact_channels AS t2` on `t1.customer_id = t2.customer_id` instead of querying only the `customers` table. Do filter on `t2.channel_code = 'Email'` instead of `contact_channel = 'phone'`. Do use table aliases `t1` and `t2` instead of no aliases. The amended query now correctly retrieves customer names with their email channel activation dates instead of phone channel data."
        ],
        "rules": [
            "1) When the question asks for customer name and active date: select \"t1\".\"customer_name\" and \"t2\".\"active_from_date\" as output columns. 2) When combining customer information with contact channel data: join \"customers\" as \"t1\" with \"customer_contact_channels\" as \"t2\" where \"t1\".\"customer_id\" = \"t2\".\"customer_id\" and keep only matching pairs. 3) When filtering for email contact channels: include only rows where \"t2\".\"channel_code\" equals exactly 'Email' (case-sensitive). 4) When answering about contact channel codes: 'email' in the question refers to the literal value 'Email' in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, active_date FROM customers WHERE contact_channel = 'phone';",
            "SELECT t1.customer_name, t2.active_from_date\nFROM Customers AS t1\nJOIN Customer_Contact_Channels AS t2 ON t1.customer_id = t2.customer_id\nWHERE t2.channel_code = 'Email'"
        ],
        "rule_sql": [
            "SELECT t1.customer_name, t2.active_from_date\nFROM Customers AS t1\nJOIN Customer_Contact_Channels AS t2 ON t1.customer_id = t2.customer_id\nWHERE t2.channel_code = 'Email';"
        ]
    },
    "5852": {
        "db_id": "tracking_share_transactions",
        "question": "Show the average amount of transactions with type code \"SALE\".",
        "ground_truth": "SELECT avg(amount_of_transaction) FROM TRANSACTIONS WHERE transaction_type_code  =  \"SALE\"",
        "amends": [
            "Do reference column `amount_of_transaction` instead of `amount` in the SELECT clause. Do use filter condition `transaction_type_code = \"SALE\"` instead of `type = 'SALE'` in the WHERE clause. The amended query now correctly calculates the average transaction amount for sales transactions using the appropriate column names and filter criteria."
        ],
        "rules": [
            "1) When answering about \"average amount of transactions\": use column \"amount_of_transaction\" for the amount calculation. 2) When filtering for transactions with type code \"SALE\": use condition \"transaction_type_code = 'SALE'\" exactly as specified. 3) When computing the average: calculate the mean of the \"amount_of_transaction\" values that satisfy the type code condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(amount) FROM transactions WHERE type = 'SALE';",
            "SELECT AVG(amount_of_transaction) FROM Transactions WHERE transaction_type_code = 'SALE'"
        ],
        "rule_sql": [
            "SELECT AVG(amount_of_transaction) FROM Transactions WHERE transaction_type_code = 'SALE'"
        ]
    },
    "3420": {
        "db_id": "hr_1",
        "question": "What are the full name, hire data, salary and department id for employees without the letter M in their first name, ordered by ascending department id?",
        "ground_truth": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id",
        "amends": [
            "Do select individual columns `first_name`, `last_name`, `hire_date`, `salary`, `department_id` instead of concatenating `first_name || ' ' || last_name` as `full_name`. Do use `NOT LIKE '%M%'` filter instead of `LIKE '%M%'` to exclude names containing 'M' instead of including them. Do remove the explicit `ASC` keyword from `ORDER BY department_id` instead of keeping it, as ascending order is the default. The amended query now correctly selects individual name components and filters for employees whose first names do not contain the letter 'M', matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"full name, hire data, salary and department id\": select the individual columns \"first_name\", \"last_name\", \"hire_date\", \"salary\", \"department_id\" instead of concatenating them as \"full_name\". 2) When filtering for employees \"without the letter M in their first name\": use the condition \"first_name NOT LIKE '%M%'\" instead of \"LIKE '%M%'\" to exclude names containing 'M'. 3) When ordering by \"ascending department id\": use \"ORDER BY department_id\" without the explicit \"ASC\" keyword since ascending order is the default."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name || ' ' || last_name AS full_name, hire_date, salary, department_id \nFROM employees \nWHERE first_name LIKE '%M%' \nORDER BY department_id ASC;",
            "SELECT first_name, last_name, hire_date, salary, department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id;"
        ],
        "rule_sql": [
            "SELECT first_name, last_name, hire_date, salary, department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id"
        ]
    },
    "6782": {
        "db_id": "activity_1",
        "question": "How many faculty members participate in each activity? Return the activity names and the number of faculty members.",
        "ground_truth": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID",
        "amends": [
            "Do join `Activity AS T1` and `Faculty_participates_in AS T2` on `T1.actID = T2.actID` instead of querying only `faculty_activities` without proper table relationships. Do select from the joined tables instead of a single table. Do group by `T1.actID` instead of `activity_name` to ensure proper aggregation. Do reference `T1.activity_name` in the SELECT list instead of just `activity_name` to specify the table source. The amended query now correctly counts faculty participation by joining the activity and participation tables and grouping by activity ID to match the intended behavior."
        ],
        "rules": [
            "1) When answering about faculty participation in activities: combine tables Activity as T1 and Faculty_participates_in as T2 where T1.actID equals T2.actID to link activities with faculty participation records. 2) When counting faculty members per activity: count using the canonical key from the participation table (T2 records) grouped by T1.actID. 3) When selecting activity names: use T1.activity_name from the Activity table to display the activity names. 4) When grouping results: organize by T1.actID to ensure proper aggregation of faculty counts per activity."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT activity_name, COUNT(*) FROM faculty_activities GROUP BY activity_name;",
            "SELECT T1.activity_name, COUNT(T2.FacID) AS faculty_count\nFROM Activity AS T1\nJOIN Faculty_Participates_in AS T2 ON T1.actid = T2.actid\nGROUP BY T1.actid, T1.activity_name"
        ],
        "rule_sql": [
            "SELECT T1.activity_name, COUNT(T2.FacID) AS faculty_count\nFROM Activity AS T1\nJOIN Faculty_Participates_in AS T2 ON T1.actid = T2.actid\nGROUP BY T1.actid, T1.activity_name;"
        ]
    },
    "105": {
        "db_id": "student_assessment",
        "question": "List the id of students who registered course statistics in the order of registration date.",
        "ground_truth": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = \"statistics\" ORDER BY T2.registration_date",
        "amends": [
            "Do use `T2.student_id` instead of `student_id` in the SELECT list. Do join `courses AS T1` and `student_course_registrations AS T2` instead of querying only `registrations`. Do use the join condition `T1.course_id = T2.course_id` instead of filtering directly on course_name. Do filter on `T1.course_name = \"statistics\"` instead of `course_name = 'statistics'`. Do order by `T2.registration_date` instead of `registration_date DESC`. The amended query now correctly joins the courses table to access course information and properly references the registration date from the student_course_registrations table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"students who registered course statistics\": join tables \"courses AS T1\" and \"student_course_registrations AS T2\" using the condition T1.course_id = T2.course_id. 2) When filtering for course \"statistics\": use T1.course_name = \"statistics\" exactly as written. 3) When selecting student identifiers: use T2.student_id from the student_course_registrations table. 4) When ordering by registration date: use T2.registration_date in ascending order (without DESC). 5) When combining tables for course registration data: perform an inner match where T1.course_id equals T2.course_id to ensure only valid course-registration pairs are included."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id FROM registrations WHERE course_name = 'statistics' ORDER BY registration_date DESC;",
            "SELECT T2.student_id\nFROM courses AS T1\nJOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id\nWHERE T1.course_name = 'statistics'\nORDER BY T2.registration_date"
        ],
        "rule_sql": [
            "SELECT T2.student_id\nFROM courses AS T1\nINNER JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id\nWHERE T1.course_name = 'statistics'\nORDER BY T2.registration_date"
        ]
    },
    "699": {
        "db_id": "customers_card_transactions",
        "question": "Show ids, customer ids, card type codes, card numbers for all cards.",
        "ground_truth": "SELECT card_id ,  customer_id ,  card_type_code ,  card_number FROM Customers_cards",
        "amends": [
            "Do reference `card_id` instead of `id` and `card_type_code` instead of `card_type` in the SELECT list. Do query from `Customers_cards` table instead of `cards` table. Do filter on `card_type_code = 'VISA'` instead of the incorrect column reference. The amended query now correctly retrieves card information from the appropriate table with proper column names.",
            "Do use the correct table name `Customers_cards` instead of the incorrect `Customers_Cards` to match the actual schema. The amended query now correctly references the intended table and matches the RIGHT_SQL's behavior.",
            "Do include all columns without filtering instead of adding a `WHERE card_type_code = 'VISA'` filter that restricts the results to only Visa cards. The amended query removes the conditional filter to return all card records from the `Customers_cards` table regardless of card type, which now matches the right SQL's behavior of returning the complete dataset."
        ],
        "rules": [
            "1) When selecting card identifiers: use \"card_id\" instead of \"id\" as the exact column name. 2) When selecting card type information: use \"card_type_code\" instead of \"card_type\" as the exact column name. 3) When querying card data: use the \"Customers_cards\" table instead of the \"cards\" table. 4) When filtering for VISA cards: use the condition \"card_type_code = 'VISA'\" with exact case and quotes.",
            "1) When the question asks for card information: use the exact table name \"Customers_cards\" with the correct case and spelling. 2) When showing all cards: do not filter by card type unless explicitly specified in the question - include all card types, not just 'VISA'.",
            "1) When answering about \"all cards\" without filtering conditions: do not apply any WHERE clause filters that restrict the results based on card type or other attributes. 2) When the question asks for \"ids, customer ids, card type codes, card numbers\": make sure the output order is card_id, customer_id, card_type_code, card_number exactly as specified in the schema. 3) When selecting from the Customers_cards table: include all rows from the table without conditional filtering unless explicitly specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, customer_id, card_type, card_number FROM cards WHERE card_type_code = 'VISA';",
            "SELECT card_id, customer_id, card_type_code, card_number FROM Customers_Cards WHERE card_type_code = 'VISA'",
            "SELECT card_id, customer_id, card_type_code, card_number FROM Customers_cards WHERE card_type_code = 'VISA'",
            "SELECT card_id, customer_id, card_type_code, card_number FROM Customers_cards"
        ],
        "rule_sql": [
            "SELECT card_id, customer_id, card_type_code, card_number FROM Customers_Cards"
        ]
    },
    "3908": {
        "db_id": "hospital_1",
        "question": "Find the id of the appointment with the most recent start date?",
        "ground_truth": "SELECT appointmentid FROM appointment ORDER BY START DESC LIMIT 1",
        "amends": [
            "Do select `appointmentid` instead of `id` and use `START` for ordering instead of `start_date`. Do reference table `appointment` instead of `appointments`. The amended query now correctly retrieves the first appointment by start time from the proper table structure."
        ],
        "rules": [
            "1) When answering about \"the appointment with the most recent start date\": make sure the output order: \"appointmentid\" 2) When the question mentions \"id\": \"id\" actually means \"appointmentid\" in schema 3) When the question mentions \"most recent start date\": use \"START\" for ordering in descending direction to get the most recent first 4) When the question asks for the single most recent appointment: rank rows by \"START\" in descending order and keep the first 1 row 5) When referencing the appointments table: use table \"appointment\" instead of \"appointments\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM appointments ORDER BY start_date ASC LIMIT 1;",
            "SELECT AppointmentID FROM Appointment ORDER BY Start DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT appointmentid FROM appointment ORDER BY Start DESC LIMIT 1;"
        ]
    },
    "6569": {
        "db_id": "wine_1",
        "question": "Find the distinct winery of wines having price between 50 and 100.",
        "ground_truth": "SELECT DISTINCT Winery FROM WINE WHERE Price BETWEEN 50 AND 100",
        "amends": [
            "Do use `DISTINCT Winery` instead of `winery` to eliminate duplicate results. Do use `BETWEEN 50 AND 100` instead of `price > 100 AND price < 50` to correctly filter for prices between 50 and 100 inclusive, fixing the contradictory filter logic. Do reference `WINE` table instead of `wines` to match the correct table name. The amended query now correctly returns distinct wineries with prices between 50 and 100, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"distinct winery\": use DISTINCT with the exact column token \"Winery\" to eliminate duplicate results. 2) When filtering for prices between 50 and 100: use BETWEEN 50 AND 100 to include both endpoints (inclusive range) instead of contradictory greater/less than conditions. 3) When referencing the table containing wine data: use the exact table name \"WINE\" instead of \"wines\" to match the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT winery FROM wines WHERE price > 100 AND price < 50;",
            "SELECT DISTINCT Winery FROM wine WHERE Price BETWEEN 50 AND 100"
        ],
        "rule_sql": [
            "SELECT DISTINCT Winery FROM WINE WHERE Price BETWEEN 50 AND 100;"
        ]
    },
    "1958": {
        "db_id": "cinema",
        "question": "How many films have the word 'Dummy' in their titles?",
        "ground_truth": "SELECT count(*) FROM film WHERE title LIKE \"%Dummy%\"",
        "amends": [
            "Do reference the `film` table instead of the `films` table in the FROM clause. Do use double quotes for the string literal pattern instead of single quotes. The amended query now correctly counts records from the film table containing 'Dummy' in the title, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about films: use the exact table name \"film\" instead of \"films\" as shown in the schema. 2) When searching for text patterns in string literals: use double quotes for the pattern exactly as shown in the amends (e.g., \"%Dummy%\") instead of single quotes. 3) When counting records that match a text pattern in a column: count all rows where the title column contains the exact literal 'Dummy' using the pattern \"%Dummy%\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM films WHERE title LIKE '%Dummy%';",
            "SELECT COUNT(*) FROM film WHERE Title LIKE \"%Dummy%\""
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM film WHERE Title LIKE \"%Dummy%\""
        ]
    },
    "5929": {
        "db_id": "cre_Theme_park",
        "question": "What are the visit date and details of the visitor whose detail is 'Vincent'?",
        "ground_truth": "SELECT T2.Visit_Date ,  T2.Visit_Details FROM VISITORS AS T1 JOIN VISITS AS T2 ON T1.Tourist_ID  =  T2.Tourist_ID WHERE T1.Tourist_Details  =  \"Vincent\"",
        "amends": [
            "Do add table `VISITS AS T2` with a `JOIN` on `T1.Tourist_ID = T2.Tourist_ID` instead of querying only the `visitors` table. Do change the source table to `VISITORS AS T1` instead of `visitors`. Do change the filter condition to `T1.Tourist_Details = \"Vincent\"` instead of `details = 'Vincent'`. Do change the selected columns to `T2.Visit_Date` and `T2.Visit_Details` instead of `visit_date` and `details`. The amended query now correctly joins the two tables and filters on the tourist details while selecting visit information from the related table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about visit date and details of a visitor: select T2.Visit_Date and T2.Visit_Details from the VISITS table instead of visitor information. 2) When the question mentions a visitor detail 'Vincent': filter using T1.Tourist_Details = \"Vincent\" with exact case and double quotes. 3) When combining visitor and visit information: join VISITORS AS T1 and VISITS AS T2 using T1.Tourist_ID = T2.Tourist_ID to link related records. 4) When selecting from multiple tables: use the alias T1 for VISITORS and T2 for VISITS as established in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT visit_date, details FROM visitors WHERE details = 'Vincent';",
            "SELECT T2.Visit_Date, T2.Visit_Details \nFROM VISITORS AS T1 \nJOIN VISITS AS T2 ON T1.Tourist_ID = T2.Tourist_ID \nWHERE T1.Tourist_Details = 'Vincent'"
        ],
        "rule_sql": [
            "SELECT T2.Visit_Date, T2.Visit_Details \nFROM VISITORS AS T1 \nJOIN VISITS AS T2 ON T1.Tourist_ID = T2.Tourist_ID \nWHERE T1.Tourist_Details = \"Vincent\""
        ]
    },
    "1433": {
        "db_id": "college_2",
        "question": "What are the names and salaries of instructors who advise students in the Math department?",
        "ground_truth": "SELECT T2.name ,  T2.salary FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id WHERE T3.dept_name  =  'Math'",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `i` and `s`. Do reference `advisor` and `instructor` tables instead of `instructors` and `students`. Do join `advisor AS T1` with `instructor AS T2` on `T1.i_id = T2.id` instead of joining `instructors i` with `students s` on `i.id = s.instructor_id`. Do add an additional join to `student AS T3` on `T1.s_id = T3.id` instead of omitting it. Do filter on `T3.dept_name = 'Math'` instead of `s.department = 'Math'`. Do select columns `T2.name` and `T2.salary` from the `instructor` table instead of `i.name` and `i.salary` from the `instructors` table. The amended query now correctly follows the advisor-student-instructor relationship structure and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"names and salaries of instructors who advise students in the Math department\": make sure the output order: T2.name, T2.salary\n2) When combining tables for advisor-instructor-student relationships: link advisor AS T1 with instructor AS T2 on T1.i_id = T2.id, then link advisor AS T1 with student AS T3 on T1.s_id = T3.id; keep only matching pairs (inner match)\n3) When filtering for Math department students: use T3.dept_name = 'Math' exactly as specified\n4) When selecting instructor information: use T2.name and T2.salary from the instructor table instead of other table columns\n5) When using table aliases: always use T1 for advisor table, T2 for instructor table, and T3 for student table as established in the amends"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT i.name, i.salary FROM instructors i JOIN students s ON i.id = s.instructor_id WHERE s.department = 'Math';",
            "SELECT T2.name, T2.salary\nFROM advisor AS T1\nJOIN instructor AS T2 ON T1.i_ID = T2.ID\nJOIN student AS T3 ON T1.s_ID = T3.ID\nWHERE T3.dept_name = 'Math'"
        ],
        "rule_sql": [
            "SELECT T2.name, T2.salary\nFROM advisor AS T1\nINNER JOIN instructor AS T2 ON T1.i_ID = T2.ID\nINNER JOIN student AS T3 ON T1.s_ID = T3.ID\nWHERE T3.dept_name = 'Math'"
        ]
    },
    "2429": {
        "db_id": "candidate_poll",
        "question": "What are the names of all female candidates in alphabetical order (sex is F)?",
        "ground_truth": "SELECT t1.name FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id WHERE t1.sex  =  'F' ORDER BY t1.name",
        "amends": [
            "Do select `t1.name` from the `people` table instead of `name` from the `candidates` table. Do join `candidate` as `t2` on `t1.people_id = t2.people_id` instead of querying only the `candidates` table. Do filter on `t1.sex = 'F'` instead of `sex = 'M'` to select female candidates. Do order by `t1.name` instead of just `name` to specify the table alias. The amended query now correctly joins the people and candidate tables to select female candidates with proper table references."
        ],
        "rules": [
            "1) When answering about female candidates: select \"t1.name\" from the \"people\" table instead of from the \"candidates\" table. 2) When combining people and candidate tables: link rows where \"t1.people_id = t2.people_id\" and keep only matching pairs (inner match). 3) When filtering for female candidates: use the condition \"t1.sex = 'F'\" exactly as specified, not 'M'. 4) When ordering results alphabetically: order by \"t1.name\" to specify the table alias explicitly. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table and column names."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM candidates WHERE sex = 'M' ORDER BY name ASC;",
            "SELECT t1.Name FROM people t1 JOIN candidate t2 ON t1.People_ID = t2.People_ID WHERE t1.Sex = 'F' ORDER BY t1.Name"
        ],
        "rule_sql": [
            "SELECT t1.\"Name\" FROM \"people\" t1 INNER JOIN \"candidate\" t2 ON t1.\"People_ID\" = t2.\"People_ID\" WHERE t1.\"Sex\" = 'F' ORDER BY t1.\"Name\""
        ]
    },
    "2218": {
        "db_id": "formula_1",
        "question": "What are the names of all the Japanese constructors that have earned more than 5 points?",
        "ground_truth": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = \"Japanese\" AND T2.points > 5",
        "amends": [
            "Do add `constructorstandings` table with `JOIN` on `T1.constructorid = T2.constructorid` instead of querying only `constructors` table. Do reference `T2.points` from the joined table instead of `points` from the original table. Do use table aliases `T1` and `T2` instead of no aliases. Do use double quotes around 'Japanese' instead of single quotes. The amended query now correctly filters by constructor points from the standings table instead of incorrectly using a points column that may not exist in the constructors table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about Japanese constructors with more than 5 points: use the \"constructors\" table as T1 and \"constructorstandings\" table as T2 with an inner join on T1.constructorid = T2.constructorid. 2) When filtering by nationality: use T1.nationality = \"Japanese\" (with double quotes) instead of single quotes. 3) When filtering by points: use T2.points > 5 instead of points from the constructors table. 4) When selecting constructor names: output T1.name from the constructors table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM constructors WHERE nationality = 'Japanese' AND points > 5;",
            "SELECT T1.name FROM constructors T1 JOIN constructorStandings T2 ON T1.constructorId = T2.constructorId WHERE T1.nationality = \"Japanese\" AND T2.points > 5"
        ],
        "rule_sql": [
            "SELECT T1.name FROM constructors AS T1 INNER JOIN constructorStandings AS T2 ON T1.constructorId = T2.constructorId WHERE T1.nationality = \"Japanese\" AND T2.points > 5"
        ]
    },
    "5184": {
        "db_id": "music_2",
        "question": "Hom many musicians performed in the song \"Flash\"?",
        "ground_truth": "SELECT count(*) FROM performance AS T1 JOIN band AS T2 ON T1.bandmate  =  T2.id JOIN songs AS T3 ON T3.songid  =  T1.songid WHERE T3.Title  =  \"Flash\"",
        "amends": [
            "Do join `performance AS T1` and `band AS T2` on `T1.bandmate = T2.id` instead of querying only `musicians` table. Do add join to `songs AS T3` on `T3.songid = T1.songid` instead of omitting these tables. Do filter on `T3.Title = \"Flash\"` instead of `song_name = 'Flash'` to reference the correct column name and table. Do remove the direct table reference to `musicians` instead of keeping it, as the correct logic requires joining through performance and band tables to properly count performances of the song \"Flash\". The amended query now correctly counts performances of the specified song through proper table relationships."
        ],
        "rules": [
            "1) When answering about \"musicians performed in the song 'Flash'\": make sure the output order: count of musicians who performed in \"Flash\". 2) When the question mentions \"musicians performed\": this actually means \"band members who performed\" through the performance and band tables. 3) When combining T1 (performance), T2 (band), and T3 (songs): link rows where T1.bandmate = T2.id and T3.songid = T1.songid; keep only matching pairs (inner match). 4) When filtering for the song \"Flash\": use T3.Title = \"Flash\" exactly as specified. 5) When counting musicians who performed: compute the number of rows using the canonical key from the performance table (T1.bandmate)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM musicians WHERE song_name = 'Flash';",
            "SELECT COUNT(DISTINCT T1.Bandmate) \nFROM Performance AS T1\nJOIN Band AS T2 ON T1.Bandmate = T2.Id\nJOIN Songs AS T3 ON T3.SongId = T1.SongId\nWHERE T3.Title = 'Flash'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT p.Bandmate) \nFROM Performance p\nJOIN Songs s ON p.SongId = s.SongId\nWHERE s.Title = 'Flash'"
        ]
    },
    "3025": {
        "db_id": "loan_1",
        "question": "What are the states, account types, and credit scores for customers who have 0 loans?",
        "ground_truth": "SELECT state ,  acc_type ,  credit_score FROM customer WHERE no_of_loans  =  0",
        "amends": [
            "Do reference table `customer` instead of `customers` in the FROM clause. Do use column `acc_type` instead of `account_type` in the SELECT list. Do filter on `no_of_loans = 0` instead of `loans = 0` in the WHERE clause. The amended query now correctly references the actual table and column names to match the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"customers\": use table \"customer\" instead of \"customers\" in the FROM clause. 2) When the question asks for \"account types\": use column \"acc_type\" instead of \"account_type\" in the SELECT list. 3) When filtering for customers with \"0 loans\": use condition \"no_of_loans = 0\" instead of \"loans = 0\" in the WHERE clause."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT state, account_type, credit_score FROM customers WHERE loans = 0;",
            "SELECT state, acc_type, credit_score FROM customer WHERE no_of_loans = 0"
        ],
        "rule_sql": [
            "SELECT state, acc_type, credit_score FROM customer WHERE no_of_loans = 0;"
        ]
    },
    "6724": {
        "db_id": "activity_1",
        "question": "What are the first name, last name, and phone number of all the female faculty members?",
        "ground_truth": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  'F'",
        "amends": [
            "Do select `Fname`, `Lname`, and `phone` instead of `first_name`, `last_name`, and `phone_number`. Do use table name `Faculty` instead of `faculty`. Do filter on `Sex = 'F'` instead of `gender = 'male'`. The amended query now correctly retrieves female faculty members with the appropriate column names and table reference."
        ],
        "rules": [
            "1) When the question asks for first name, last name, and phone number: select \"Fname\", \"Lname\", and \"phone\" columns instead of first_name, last_name, and phone_number. 2) When referring to the faculty table: use the exact table name \"Faculty\" instead of faculty. 3) When filtering for female faculty members: use the condition \"Sex = 'F'\" instead of gender = 'male'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name, phone_number FROM faculty WHERE gender = 'male';",
            "SELECT Fname, Lname, Phone FROM Faculty WHERE Sex = 'F';"
        ],
        "rule_sql": [
            "SELECT Fname, Lname, Phone FROM Faculty WHERE Sex = 'F'"
        ]
    },
    "5650": {
        "db_id": "railway",
        "question": "Show the distinct countries of managers.",
        "ground_truth": "SELECT DISTINCT Country FROM manager",
        "amends": [
            "Do reference the `Country` column from the `manager` table instead of the `country` column from the `employees` table. Do query the `manager` table instead of the `employees` table. Do remove the `WHERE title = 'Manager'` filter instead of keeping it, as the table itself now contains only manager records. The amended query now correctly selects distinct countries from the manager-specific table rather than filtering employees by title."
        ],
        "rules": [
            "1) When answering about \"distinct countries of managers\": make sure to select from the \"manager\" table instead of the \"employees\" table. 2) When the question mentions \"countries\": \"countries\" actually means \"Country\" column in the \"manager\" table. 3) When selecting distinct values: compute the number of unique values of the exact token \"Country\" from the \"manager\" table. 4) When the question asks about managers: do not apply any title filters since the \"manager\" table contains only manager records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT country FROM employees WHERE title = 'Manager';",
            "SELECT DISTINCT Country FROM manager;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Country FROM manager;"
        ]
    },
    "6730": {
        "db_id": "activity_1",
        "question": "What are the phone, room, and building of the faculty member called Jerry Prince?",
        "ground_truth": "SELECT phone ,  room ,  building FROM Faculty WHERE Fname  =  \"Jerry\" AND Lname  =  \"Prince\"",
        "amends": [
            "Do reference the `Faculty` table instead of `faculty` to match the correct table name. Do use `Fname = \"Jerry\" AND Lname = \"Prince\"` instead of `name = 'Jerry Prince'` to properly split the full name into separate first and last name columns. Do use double quotes `\"` instead of single quotes `'` for string literals to match the correct SQL syntax. The amended query now correctly filters for faculty members with first name Jerry and last name Prince, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about faculty member details: use the exact table name \"Faculty\" with double quotes as shown in the schema. 2) When filtering for a faculty member named Jerry Prince: split the name into separate conditions using Fname = \"Jerry\" AND Lname = \"Prince\" with double quotes for string literals. 3) When selecting phone, room, and building information: maintain the exact output column order as specified in the question (phone, room, building)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT phone, room, building FROM faculty WHERE name = 'Jerry Prince';",
            "SELECT Phone, Room, Building FROM Faculty WHERE Fname = \"Jerry\" AND Lname = \"Prince\""
        ],
        "rule_sql": [
            "SELECT Phone, Room, Building FROM \"Faculty\" WHERE Fname = \"Jerry\" AND Lname = \"Prince\""
        ]
    },
    "3409": {
        "db_id": "hr_1",
        "question": "Display the first name, and department number for all employees whose last name is \"McEwen\".",
        "ground_truth": "SELECT first_name ,  department_id FROM employees WHERE last_name  =  'McEwen'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, department_id FROM employees WHERE last_name = 'McEwen'"
        ],
        "rule_sql": [
            "SELECT FIRST_NAME, DEPARTMENT_ID FROM employees WHERE LAST_NAME = 'McEwen';"
        ]
    },
    "4499": {
        "db_id": "document_management",
        "question": "Find the name and access counts of all documents, in alphabetic order of the document name.",
        "ground_truth": "SELECT document_name ,  access_count FROM documents ORDER BY document_name",
        "amends": [
            "Do use column alias `document_name` instead of `name` in the SELECT list. Do change the ORDER BY clause to sort by `document_name` instead of `access_count DESC`. Do remove the descending sort direction instead of keeping it. The amended query now correctly selects and orders by the document_name column as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for document names: use the exact column token \"document_name\" instead of \"name\" from the Documents table. 2) When ordering documents alphabetically by name: sort by \"document_name\" in ascending order (default direction) rather than descending order. 3) When the output includes both document name and access count: maintain the column order as document_name followed by access_count as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, access_count FROM documents ORDER BY access_count DESC;",
            "SELECT document_name, access_count FROM Documents ORDER BY document_name ASC;"
        ],
        "rule_sql": [
            "SELECT document_name, access_count FROM Documents ORDER BY document_name ASC;"
        ]
    },
    "5452": {
        "db_id": "voter_2",
        "question": "Find the last names of students with major 50.",
        "ground_truth": "SELECT LName FROM STUDENT WHERE Major  =  50",
        "amends": [
            "Do reference the `LName` column instead of `first_name` and use the correct table name `STUDENT` instead of `students`. Do maintain the filter condition `Major = 50` instead of `major = 50` with proper case sensitivity. The amended query now correctly retrieves last names from the STUDENT table for the specified major, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"last names\": use the exact column token \"LName\" from the STUDENT table. 2) When the question mentions \"students\": use the exact table name \"STUDENT\" with proper case sensitivity. 3) When filtering by major \"50\": use the exact literal value 50 with the exact column token \"Major\" and maintain proper case sensitivity. 4) When answering about \"last names of students with major 50\": make sure the output order includes only the \"LName\" column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE major = 50;",
            "SELECT LName FROM Student WHERE Major = 50;"
        ],
        "rule_sql": [
            "SELECT LName FROM Student WHERE Major = 50;"
        ]
    },
    "1334": {
        "db_id": "college_2",
        "question": "How many rooms does the Lamberton building have?",
        "ground_truth": "SELECT count(*) FROM classroom WHERE building  =  'Lamberton'",
        "amends": [
            "Do query the `classroom` table instead of the `buildings` table. Do filter on the `building` column instead of the `building_name` column while keeping the same filter value 'Lamberton'. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` while maintaining the same aggregate function. The amended query now correctly counts classrooms in the Lamberton building instead of incorrectly counting buildings."
        ],
        "rules": [
            "1) When answering about \"how many rooms in a building\": query the classroom table instead of the buildings table. 2) When filtering for a specific building name: use the building column instead of building_name column with the exact literal value 'Lamberton'. 3) When counting entities: use lowercase count(*) to count all rows that match the filter condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM buildings WHERE building_name = 'Lamberton';",
            "SELECT count(*) FROM classroom WHERE building = 'Lamberton'"
        ],
        "rule_sql": [
            "SELECT count(*) FROM classroom WHERE building = 'Lamberton'"
        ]
    },
    "1814": {
        "db_id": "small_bank_1",
        "question": "Find the name and checking balance of the account with the lowest saving balance.",
        "ground_truth": "SELECT T2.balance ,  T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid ORDER BY T3.balance LIMIT 1",
        "amends": [
            "Do join `checking AS T2` and `savings AS T3` tables instead of querying only the `accounts` table. Do select `T2.balance` and `T1.name` instead of `name` and `checking_balance`. Do use `JOIN` conditions `ON T1.custid = T2.custid` and `ON T1.custid = T3.custid` instead of no join conditions. Do order by `T3.balance` instead of `saving_balance DESC`. The amended query now correctly joins multiple tables and orders by the savings balance to match the intended behavior.",
            "Do reverse the column order in the SELECT list to `T2.balance, T1.name` instead of `T1.name, T2.balance`. Do remove the explicit `ASC` keyword from the ORDER BY clause on `T3.balance` instead of keeping it, as ASC is the default ordering. The amended query now correctly matches the RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [
            "1) When answering about \"account with the lowest saving balance\": make sure the output order: T1.name, T2.balance 2) When combining accounts, checking, and savings tables: link rows where T1.custid = T2.custid and T1.custid = T3.custid; keep only matching pairs (inner match). 3) When the question mentions \"lowest saving balance\": order rows by T3.balance in ascending direction and keep the first 1 row. 4) When the question asks for \"checking balance\": \"checking balance\" actually means \"T2.balance in schema\". 5) When the question asks for \"name\": \"name\" actually means \"T1.name in schema\".",
            "1) When answering about \"the name and checking balance of the account with the lowest saving balance\": make sure the output order: T2.balance, T1.name 2) When ordering by T3.balance to find the lowest value: use the default ascending order without specifying ASC explicitly"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, checking_balance FROM accounts ORDER BY saving_balance DESC LIMIT 1;",
            "SELECT T1.name, T2.balance \nFROM ACCOUNTS AS T1\nJOIN CHECKING AS T2 ON T1.custid = T2.custid\nJOIN SAVINGS AS T3 ON T1.custid = T3.custid\nORDER BY T3.balance ASC\nLIMIT 1",
            "SELECT T2.balance, T1.name\nFROM ACCOUNTS AS T1\nJOIN CHECKING AS T2 ON T1.custid = T2.custid\nJOIN SAVINGS AS T3 ON T1.custid = T3.custid\nORDER BY T3.balance\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.name, T2.balance \nFROM ACCOUNTS T1\nINNER JOIN CHECKING T2 ON T1.custid = T2.custid\nINNER JOIN SAVINGS T3 ON T1.custid = T3.custid\nORDER BY T3.balance\nLIMIT 1"
        ]
    },
    "5730": {
        "db_id": "dorm_1",
        "question": "Find the number of students for the cities where have more than one student.",
        "ground_truth": "SELECT count(*) ,  city_code FROM student GROUP BY city_code HAVING count(*)  >  1",
        "amends": [
            "Do select `count(*)` and `city_code` instead of `city` and `COUNT(*)`. Do use table `student` instead of `students`. Do group by `city_code` instead of `city`. The amended query now correctly counts records by city code rather than city name, matching the intended behavior.",
            "Do place `city_code` after `count(*)` in the SELECT list instead of before it, maintaining the same aggregation logic and HAVING condition. The amended query now correctly displays the count first followed by city_code while preserving the identical grouping and filtering behavior, matching the RIGHT_SQL's output structure."
        ],
        "rules": [
            "1) When the question asks for \"number of students\": count all records using the canonical counting method for students. 2) When the question mentions \"cities\": use the exact column token \"city_code\" from table \"student\" instead of \"city\". 3) When grouping by city: group by the exact column \"city_code\" from table \"student\". 4) When filtering for cities with more than one student: apply the condition that the count of students per city_code must be greater than 1. 5) When selecting output columns: include both the count of students and the city_code in the results.",
            "1) When the question asks for \"number of students for the cities where have more than one student\": make sure the output order: count(*) first, then city_code. 2) When grouping by city_code and counting students: use the exact column token \"city_code\" for grouping. 3) When filtering for cities with more than one student: apply the condition COUNT(*) > 1 after grouping."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, COUNT(*) FROM students GROUP BY city HAVING COUNT(*) > 1",
            "SELECT city_code, COUNT(*) FROM Student GROUP BY city_code HAVING COUNT(*) > 1",
            "SELECT COUNT(*), city_code FROM Student GROUP BY city_code HAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS student_count, city_code FROM Student GROUP BY city_code HAVING COUNT(*) > 1"
        ]
    },
    "6425": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "Show all document type codes, document type names, document type descriptions.",
        "ground_truth": "SELECT document_type_code ,  document_type_name ,  document_type_description FROM Ref_document_types",
        "amends": [
            "Do select `document_type_code`, `document_type_name`, and `document_type_description` instead of `document_code` and `document_name`. Do use table `Ref_document_types` instead of `document_types`. The amended query now correctly retrieves all required document type information from the appropriate reference table."
        ],
        "rules": [
            "1) When the question asks for document type codes, document type names, and document type descriptions: use the exact column names \"document_type_code\", \"document_type_name\", and \"document_type_description\" from the appropriate table. 2) When retrieving document type information: use the table \"Ref_document_types\" instead of \"document_types\" as the source table. 3) When selecting all required document type information: ensure the output order is document_type_code, document_type_name, document_type_description as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_code, document_name FROM document_types",
            "SELECT Document_Type_Code, Document_Type_Name, Document_Type_Description FROM Ref_Document_Types;"
        ],
        "rule_sql": [
            "SELECT document_type_code, document_type_name, document_type_description FROM Ref_Document_Types ORDER BY document_type_code, document_type_name, document_type_description;"
        ]
    },
    "3868": {
        "db_id": "insurance_policies",
        "question": "How many settlements were made on the claim with the most recent claim settlement date? List the number and the claim id.",
        "ground_truth": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1",
        "amends": [
            "Do add the `Claims` table with alias `T1` instead of omitting it, and do `JOIN` with `Settlements` as `T2` on `T1.claim_id = T2.claim_id` instead of querying only `settlements`. Do remove the `WHERE` filter with subquery for `MAX(settlement_date)` instead of keeping it. Do add `ORDER BY T1.Date_Claim_Settled DESC` and `LIMIT 1` instead of omitting ordering and limiting. Do change the aggregation to count all joined records per claim instead of counting only the latest settlement records. The amended query now correctly counts settlements per claim and returns the most recently settled claim.",
            "Do add `GROUP BY T1.claim_id` instead of omitting it, which properly groups the count by claim_id rather than producing a single aggregated count across all claims. Do remove the alias `AS settlement_count` instead of keeping it, as the right query uses an unnamed count column. Do maintain the same `JOIN` on `T1.claim_id = T2.claim_id` instead of changing the join logic. Do preserve the `ORDER BY T1.Date_Claim_Settled DESC` and `LIMIT 1` clauses instead of modifying them, as they remain appropriate for retrieving the most recently settled claim. The amended query now correctly counts settlements per claim_id and matches the right SQL's behavior.",
            "Do place `count(*)` first in the SELECT list instead of `T1.Claim_ID` and use lowercase `claim_id` instead of uppercase `Claim_ID` for the column reference. Do maintain the same `JOIN` on `T1.claim_id = T2.claim_id` with consistent lowercase column names instead of mixed case. Do keep the `GROUP BY T1.claim_id` with lowercase instead of uppercase column reference. Do preserve the `ORDER BY T1.Date_Claim_Settled DESC` and `LIMIT 1` unchanged. The amended query now matches RIGHT_SQL's behavior with proper column ordering and consistent casing."
        ],
        "rules": [
            "1) When answering about \"the claim with the most recent claim settlement date\": order claims by T1.Date_Claim_Settled in descending order and keep only the first 1 row. 2) When combining Claims table (T1) and Settlements table (T2): link rows where T1.claim_id = T2.claim_id and keep only matching pairs (inner match). 3) When the question asks for \"how many settlements were made on the claim\": count all joined records per claim using the canonical key T1.claim_id. 4) When producing output: include both the settlement count and the claim_id in the results.",
            "1) When counting settlements per claim: group the results by T1.claim_id to get the count for each individual claim instead of a single aggregate count across all claims. 2) When the question asks for the claim with the most recent settlement date: order the results by T1.Date_Claim_Settled in descending order and keep only the first row to get the most recent claim. 3) When combining Claims (T1) and Settlements (T2) tables: link rows where T1.claim_id = T2.claim_id to match settlements with their corresponding claims. 4) When the question asks for the number of settlements: count the rows using the join relationship between Claims and Settlements tables. 5) When outputting results: include both the count (without alias) and the T1.Claim_ID to match the question's requirement for listing the number and the claim id.",
            "1) When the question asks for \"number and the claim id\": place the count first in the output order before the claim_id. 2) When referring to the claim_id column in both Claims and Settlements tables: use lowercase \"claim_id\" instead of uppercase \"Claim_ID\". 3) When combining Claims (T1) and Settlements (T2) tables: link rows where T1.claim_id = T2.claim_id using exact key equality. 4) When grouping by claim_id: use T1.claim_id as the grouping key with lowercase column name. 5) When ordering by settlement date: use T1.Date_Claim_Settled in descending order to find the most recent claim. 6) When limiting to the top result: keep only the first row after ordering to get the claim with the most recent settlement date."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) as settlement_count, claim_id \nFROM settlements \nWHERE settlement_date = (SELECT MAX(settlement_date) FROM settlements) \nGROUP BY claim_id;",
            "SELECT COUNT(*) AS settlement_count, T1.Claim_ID\nFROM Claims AS T1\nJOIN Settlements AS T2 ON T1.Claim_ID = T2.Claim_ID\nORDER BY T1.Date_Claim_Settled DESC\nLIMIT 1;",
            "SELECT T1.Claim_ID, COUNT(*) \nFROM Claims AS T1 \nJOIN Settlements AS T2 ON T1.Claim_ID = T2.Claim_ID \nGROUP BY T1.Claim_ID \nORDER BY T1.Date_Claim_Settled DESC \nLIMIT 1",
            "SELECT count(*), T1.claim_id\nFROM Claims AS T1\nJOIN Settlements AS T2 ON T1.claim_id = T2.claim_id\nGROUP BY T1.claim_id\nORDER BY T1.Date_Claim_Settled DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS settlement_count, T1.claim_id\nFROM Claims T1\nINNER JOIN Settlements T2 ON T1.claim_id = T2.claim_id\nGROUP BY T1.claim_id\nORDER BY T1.Date_Claim_Settled DESC\nLIMIT 1;"
        ]
    },
    "4258": {
        "db_id": "club_1",
        "question": "Find the last names of the members of the club \"Bootup Baltimore\".",
        "ground_truth": "SELECT t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\"",
        "amends": [
            "Do select `t3.lname` instead of `first_name` to reference the correct column from the student table. Do use a three-table join structure with `club AS t1 JOIN member_of_club AS t2 ON t1.clubid = t2.clubid JOIN student AS t3 ON t2.stuid = t3.stuid` instead of querying a single `members` table to properly navigate the relationship between clubs and students through the membership association table. Do filter on `t1.clubname = \"Bootup Baltimore\"` instead of `club_name = 'Bootup Baltimore'` to use the correct table alias and column name with proper string quoting. The amended query now correctly retrieves student last names from the appropriate tables using proper join relationships to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"last names of members of the club 'Bootup Baltimore'\": make sure the output order: t3.lname 2) When the question mentions \"members\": \"members\" actually means \"students in schema\" through the member_of_club association table 3) When combining tables for club membership relationships: link rows where t1.clubid = t2.clubid and t2.stuid = t3.stuid using inner matches only 4) When filtering for the club \"Bootup Baltimore\": use exact literal \"Bootup Baltimore\" with t1.clubname column 5) When selecting student information: use t3.lname for last names instead of first_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM members WHERE club_name = 'Bootup Baltimore'",
            "SELECT t3.LName \nFROM Club AS t1 \nJOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID \nJOIN Student AS t3 ON t2.StuID = t3.StuID \nWHERE t1.ClubName = 'Bootup Baltimore'"
        ],
        "rule_sql": [
            "SELECT t3.LName \nFROM Club t1 \nINNER JOIN Member_of_club t2 ON t1.ClubID = t2.ClubID \nINNER JOIN Student t3 ON t2.StuID = t3.StuID \nWHERE t1.ClubName = 'Bootup Baltimore' \nORDER BY t3.LName"
        ]
    },
    "6592": {
        "db_id": "wine_1",
        "question": "What are the grapes, appelations, and wines with scores above 93, sorted by Name?",
        "ground_truth": "SELECT Grape ,  Appelation ,  Name FROM WINE WHERE Score  >  93 ORDER BY Name",
        "amends": [
            "Do reference columns as `Grape`, `Appelation`, and `Name` instead of `grapes`, `appelations`, and `wines`. Do reference the table as `WINE` instead of `wine_table`. Do filter on `Score > 93` instead of `score > 93` to match the correct column name. The amended query now correctly selects the intended columns from the proper table with accurate filtering and ordering."
        ],
        "rules": [
            "1) When the question asks for grapes, appelations, and wines: select columns \"Grape\", \"Appelation\", and \"Name\" from table \"WINE\". 2) When filtering for scores above 93: include only rows where \"Score\" > 93. 3) When sorting the results: order the output by \"Name\" in ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT grapes, appelations, wines FROM wine_table WHERE score > 93 ORDER BY Name;",
            "SELECT Grape, Appelation, Name FROM wine WHERE Score > 93 ORDER BY Name;"
        ],
        "rule_sql": [
            "SELECT Grape, Appelation, Name FROM wine WHERE Score > 93 ORDER BY Name ASC;"
        ]
    },
    "6687": {
        "db_id": "driving_school",
        "question": "What is the zip code of the customer Carole Bernhard?",
        "ground_truth": "SELECT T2.zip_postcode FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id WHERE T1.first_name = \"Carole\" AND T1.last_name = \"Bernhard\"",
        "amends": [
            "Do select `T2.zip_postcode` instead of `zip_code` from the wrong table. Do add `JOIN Addresses AS T2` instead of querying only the customers table. Do use the join condition `ON T1.customer_address_id = T2.address_id` instead of missing the table relationship entirely. Do qualify the columns with table aliases as `T1.first_name` and `T1.last_name` instead of unqualified column references. The amended query now correctly retrieves the zip code from the related addresses table instead of attempting to get it directly from customers, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for zip code information about a customer: retrieve the zip code from the Addresses table (T2.zip_postcode) instead of the customers table. 2) When joining customers and addresses tables: link rows where T1.customer_address_id equals T2.address_id to establish the relationship between customers and their addresses. 3) When searching for a customer by name: use the exact column tokens T1.first_name and T1.last_name with the literal values 'Carole' and 'Bernhard' respectively. 4) When selecting output columns: ensure the output order contains only the requested zip code information (T2.zip_postcode)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT zip_code FROM customers WHERE first_name = 'Carole' AND last_name = 'Bernhard';",
            "SELECT T2.zip_postcode \nFROM Customers AS T1\nJOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id\nWHERE T1.first_name = 'Carole' AND T1.last_name = 'Bernhard'"
        ],
        "rule_sql": [
            "SELECT T2.zip_postcode \nFROM Customers T1\nJOIN Addresses T2 ON T1.customer_address_id = T2.address_id\nWHERE T1.first_name = 'Carole' AND T1.last_name = 'Bernhard'"
        ]
    },
    "5449": {
        "db_id": "voter_2",
        "question": "How many distinct president votes are recorded?",
        "ground_truth": "SELECT count(DISTINCT President_Vote) FROM VOTING_RECORD",
        "amends": [
            "Do use `count(DISTINCT President_Vote)` instead of `COUNT(*)` to count distinct vote values rather than all rows. Do reference table `VOTING_RECORD` instead of `president_votes` as the correct data source. The amended query now correctly counts distinct presidential votes from the appropriate voting record table."
        ],
        "rules": [
            "1) When the question asks for \"distinct president votes\": count the number of unique values using the exact column token \"President_Vote\" from the voting record table. 2) When referencing the voting data source: use the exact table name \"VOTING_RECORD\" with the correct case and no quotes as shown in the schema. 3) When counting distinct values: ensure the count operation specifically targets distinct values rather than all rows in the table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM president_votes;",
            "SELECT COUNT(DISTINCT President_Vote) FROM Voting_record;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT President_Vote) FROM Voting_record"
        ]
    },
    "1557": {
        "db_id": "customers_and_invoices",
        "question": "Show the first name and last name for the customer with account name 900.",
        "ground_truth": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  \"900\"",
        "amends": [
            "Do select `T2.customer_first_name` and `T2.customer_last_name` instead of `first_name` and `last_name` without table qualification. Do join `Accounts AS T1` with `Customers AS T2` on `T1.customer_id = T2.customer_id` instead of querying only the `customers` table. Do filter on `T1.account_name = \"900\"` instead of `account_number = 900` to reference the correct table and column with proper string quoting. The amended query now correctly joins the Accounts and Customers tables to retrieve customer information based on account name rather than assuming account_number exists in the customers table."
        ],
        "rules": [
            "1) When answering about customer information for a specific account: make sure the output order: T2.customer_first_name, T2.customer_last_name\n2) When the question mentions \"account name 900\": \"account name\" actually means \"T1.account_name in schema\" and \"900\" must be treated as a string literal with double quotes\n3) When combining Accounts (T1) and Customers (T2) tables: link rows where T1.customer_id = T2.customer_id and keep only matching pairs (inner match)\n4) When filtering for account name: use T1.account_name = \"900\" with exact string literal value and double quotes"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM customers WHERE account_number = 900;",
            "SELECT T2.customer_first_name, T2.customer_last_name\nFROM Accounts AS T1\nJOIN Customers AS T2 ON T1.customer_id = T2.customer_id\nWHERE T1.account_name = '900'"
        ],
        "rule_sql": [
            "SELECT T2.customer_first_name, T2.customer_last_name\nFROM Accounts T1\nINNER JOIN Customers T2 ON T1.customer_id = T2.customer_id\nWHERE T1.account_name = \"900\""
        ]
    },
    "6875": {
        "db_id": "flight_4",
        "question": "Find the number of routes from the United States to Canada.",
        "ground_truth": "SELECT count(*) FROM routes WHERE dst_apid IN (SELECT apid FROM airports WHERE country  =  'Canada') AND src_apid IN (SELECT apid FROM airports WHERE country  =  'United States')",
        "amends": [
            "Do use subqueries to filter routes based on airport country codes instead of directly comparing origin_country and destination_country columns. Do filter routes where `dst_apid` is in airports with country 'Canada' instead of using `destination_country = 'Canada'`. Do filter routes where `src_apid` is in airports with country 'United States' instead of using `origin_country = 'United States'`. Do remove the direct country column references from the routes table instead of keeping them, as the correct logic requires joining through the airports table to validate country information. The amended query now correctly counts routes between US and Canadian airports by properly correlating through the airport identifiers rather than relying on potentially incorrect direct country columns."
        ],
        "rules": [
            "1) When the question asks for routes between countries: use airport country codes from the airports table instead of direct country columns in the routes table. 2) When filtering for routes from the United States: find routes where src_apid corresponds to airports with country 'United States'. 3) When filtering for routes to Canada: find routes where dst_apid corresponds to airports with country 'Canada'. 4) When counting routes between countries: count the number of route records that satisfy both country filter conditions through airport table joins."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM routes WHERE origin_country = 'United States' AND destination_country = 'Canada';",
            "SELECT COUNT(*) AS route_count\nFROM routes r\nWHERE r.src_apid IN (SELECT apid FROM airports WHERE country = 'United States')\nAND r.dst_apid IN (SELECT apid FROM airports WHERE country = 'Canada');"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS route_count\nFROM routes r\nJOIN airports src_ap ON r.src_apid = src_ap.apid\nJOIN airports dst_ap ON r.dst_apid = dst_ap.apid\nWHERE src_ap.country = 'United States'\nAND dst_ap.country = 'Canada';"
        ]
    },
    "3238": {
        "db_id": "college_1",
        "question": "What are the total number of credits offered by each department?",
        "ground_truth": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code",
        "amends": [
            "Do specify table aliases with `T1.dept_code` and `T1.crs_credit` instead of generic `department` and `credits`. Do add `FROM course AS T1 JOIN CLASS AS T2` with an explicit join instead of a single table. Do use the join condition `ON T1.crs_code = T2.crs_code` instead of no join. Do reference the correct column names `crs_credit` and `dept_code` instead of `credits` and `department`. The amended query now correctly joins the course and class tables to calculate the sum of credits by department code, matching the intended behavior.",
            "Do place `T1.dept_code` after the aggregate function instead of listing it first in the SELECT clause. Do use `sum(T1.crs_credit)` without an alias instead of `SUM(T1.crs_credit) AS total_credits`. The amended query now correctly calculates the sum of course credits grouped by department code while maintaining the same logical behavior as the RIGHT_SQL.",
            "Do place `sum(T1.crs_credit)` before `T1.dept_code` in the SELECT list instead of the reverse order. Do maintain the same `JOIN` on `T1.crs_code = T2.crs_code` and identical `GROUP BY T1.dept_code` structure. The amended query now matches RIGHT_SQL's behavior with the correct column ordering while preserving the same logical aggregation."
        ],
        "rules": [
            "1) When answering about \"total number of credits offered by each department\": make sure the output order: dept_code, SUM(crs_credit). 2) When the question mentions \"department\": \"department\" actually means \"dept_code in schema\". 3) When the question mentions \"credits\": \"credits\" actually means \"crs_credit in schema\". 4) When combining T1 and T2 for shared entities: link rows where T1.crs_code = T2.crs_code exactly as shown in the amends; keep only matching pairs (inner match). 5) When the question says \"per department\"/\"by department\": organize results by dept_code and compute SUM(crs_credit) per group.",
            "1) When answering about \"total number of credits offered by each department\": make sure the output order: sum(T1.crs_credit) first, then T1.dept_code. 2) When computing the sum of course credits: use sum(T1.crs_credit) without an alias instead of SUM(T1.crs_credit) AS total_credits. 3) When grouping by department code: place T1.dept_code after the aggregate function in the SELECT clause.",
            "1) When answering about \"total number of credits offered by each department\": make sure the output order: SUM(T1.crs_credit) before T1.dept_code\n2) When combining T1 and T2 for shared entities: link rows where T1.crs_code = T2.crs_code exactly as shown; keep only matching pairs (inner match)\n3) When the question says \"by each department\": organize results by T1.dept_code and compute the sum of T1.crs_credit per group"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT department, SUM(credits) FROM courses GROUP BY department;",
            "SELECT T1.dept_code, SUM(T1.crs_credit) AS total_credits\nFROM course AS T1\nJOIN CLASS AS T2 ON T1.crs_code = T2.crs_code\nGROUP BY T1.dept_code",
            "SELECT T1.dept_code, SUM(T1.crs_credit) \nFROM course AS T1 \nJOIN CLASS AS T2 ON T1.crs_code = T2.crs_code \nGROUP BY T1.dept_code",
            "SELECT sum(T1.crs_credit), T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code = T2.crs_code GROUP BY T1.dept_code"
        ],
        "rule_sql": [
            "SELECT SUM(crs_credit), dept_code FROM COURSE GROUP BY dept_code"
        ]
    },
    "3265": {
        "db_id": "college_1",
        "question": "What is the first, last name, gpa of the youngest one among students whose GPA is above 3?",
        "ground_truth": "SELECT stu_fname ,  stu_lname ,  stu_gpa FROM student WHERE stu_gpa  >  3 ORDER BY stu_dob DESC LIMIT 1",
        "amends": [
            "Do use column names `stu_fname`, `stu_lname`, and `stu_gpa` instead of `first_name`, `last_name`, and `gpa`. Do reference table `student` instead of `students`. Do filter on `stu_gpa > 3` instead of `gpa > 3`. Do order by `stu_dob DESC` instead of `age ASC`. The amended query now correctly retrieves student data with the proper column names, table reference, filter condition, and sorting criteria."
        ],
        "rules": [
            "1) When the question asks for \"first name\": use the exact column token \"stu_fname\" from the student table. 2) When the question asks for \"last name\": use the exact column token \"stu_lname\" from the student table. 3) When the question asks for \"gpa\": use the exact column token \"stu_gpa\" from the student table. 4) When filtering for students with GPA above 3: use the condition \"stu_gpa > 3\" with exact numeric literal 3. 5) When identifying the \"youngest\" student: sort by \"stu_dob DESC\" (most recent date of birth first) instead of age. 6) When retrieving only the top result: take the first row after sorting. 7) When referencing the student table: use the exact table name \"student\" instead of \"students\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name, gpa FROM students WHERE gpa > 3 ORDER BY age ASC LIMIT 1;",
            "SELECT stu_fname, stu_lname, stu_gpa FROM student WHERE stu_gpa > 3 ORDER BY stu_dob DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT stu_fname, stu_lname, stu_gpa FROM student WHERE stu_gpa > 3 ORDER BY stu_dob DESC LIMIT 1;"
        ]
    },
    "6388": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "What are the ids and details of all accounts?",
        "ground_truth": "SELECT account_id ,  account_details FROM Accounts",
        "amends": [
            "Do use `account_id` and `account_details` instead of `id` and `details` for column names. Do reference the `Accounts` table instead of `accounts` for the table name. Do remove the `WHERE id IS NULL` filter instead of keeping it, as the right query selects all records without filtering. The amended query now correctly selects all account records from the Accounts table with the appropriate column names, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"ids and details of all accounts\": use the exact column names \"account_id\" and \"account_details\" from the \"Accounts\" table. 2) When selecting all records without filtering: do not apply any WHERE conditions and include all rows from the \"Accounts\" table. 3) When referencing the table containing account information: use the exact table name \"Accounts\" with proper case and spelling."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, details FROM accounts WHERE id IS NULL;",
            "SELECT account_id, account_details FROM Accounts"
        ],
        "rule_sql": [
            "SELECT Account_ID, Account_Details FROM Accounts;"
        ]
    },
    "6994": {
        "db_id": "culture_company",
        "question": "List all company names with a book published by Alyson.",
        "ground_truth": "SELECT T1.company_name FROM culture_company AS T1 JOIN book_club AS T2 ON T1.book_club_id  =  T2.book_club_id WHERE T2.publisher  =  'Alyson'",
        "amends": [
            "Do select `T1.company_name` from the `culture_company` table instead of `company_name` from the `books` table. Do join `book_club` as `T2` with an `INNER JOIN` on `T1.book_club_id = T2.book_club_id` instead of querying a single table. Do filter on `T2.publisher = 'Alyson'` instead of `author = 'Alyson'`, changing both the column reference and table source for the condition. The amended query now correctly retrieves company names based on publisher relationships rather than direct author matching, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"company names with a book published by Alyson\": make sure the output order: T1.company_name\n2) When the question mentions \"company names\": \"company names\" actually means \"T1.company_name in culture_company table\"\n3) When the question mentions \"published by Alyson\": \"published by Alyson\" actually means \"T2.publisher = 'Alyson' in book_club table\"\n4) When combining T1 (culture_company) and T2 (book_club) for shared entities: link rows where T1.book_club_id = T2.book_club_id; keep only matching pairs (inner match)\n5) When handling text literals: do not change case, spacing, or punctuation - use exactly 'Alyson'"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT company_name FROM books WHERE author = 'Alyson';",
            "SELECT T1.Company_name FROM culture_company AS T1 INNER JOIN book_club AS T2 ON T1.book_club_id = T2.book_club_id WHERE T2.Publisher = 'Alyson'"
        ],
        "rule_sql": [
            "SELECT T1.Company_name\nFROM culture_company T1\nINNER JOIN book_club T2 ON T1.book_club_id = T2.book_club_id\nWHERE T2.Publisher = 'Alyson'"
        ]
    },
    "1695": {
        "db_id": "epinions_1",
        "question": "How many different users wrote some reviews?",
        "ground_truth": "SELECT count(DISTINCT u_id) FROM review",
        "amends": [
            "Do use `count(DISTINCT u_id)` instead of `COUNT(*)` to count distinct user IDs rather than all rows. Do reference the `review` table instead of `reviews` with the correct table name. Do remove the unnecessary asterisk and instead specify the distinct count on the `u_id` column to accurately count unique users rather than total review records. The amended query now correctly counts distinct users from the review table instead of counting all review entries."
        ],
        "rules": [
            "1) When counting distinct users who wrote reviews: count the number of unique values in the \"u_id\" column from the \"review\" table. 2) When the question asks for \"different users\": this means distinct values of the \"u_id\" column. 3) When referencing the table containing user reviews: use the exact table name \"review\" (not \"reviews\"). 4) When counting entities: use the canonical key \"u_id\" for counting distinct users rather than counting all rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM reviews;",
            "SELECT COUNT(DISTINCT u_id) FROM review;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT u_id) FROM review;"
        ]
    },
    "2439": {
        "db_id": "movie_1",
        "question": "How many movies were made before 2000?",
        "ground_truth": "SELECT count(*) FROM Movie WHERE YEAR  <  2000",
        "amends": [
            "Do reference table `Movie` instead of `movies` in the FROM clause. Do use filter condition `YEAR < 2000` instead of `year > 2000` to count movies released before 2000 rather than after 2000. The amended query now correctly counts movies from before the year 2000, matching the intended behavior."
        ],
        "rules": [
            "1) When referencing the movies table: use the exact table name \"Movie\" with double quotes as shown in the schema. 2) When filtering for movies made before 2000: use the condition YEAR < 2000 to include movies released in years less than 2000. 3) When counting movies: count all rows from the Movie table that satisfy the year condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies WHERE year > 2000;",
            "SELECT COUNT(*) FROM Movie WHERE year < 2000"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM \"Movie\" WHERE year < 2000"
        ]
    },
    "6242": {
        "db_id": "ship_1",
        "question": "What is the name of the youngest captain?",
        "ground_truth": "SELECT name FROM captain ORDER BY age LIMIT 1",
        "amends": [
            "Do reference table `captain` instead of `captains` to use the correct table name. Do remove the explicit `ASC` direction from `ORDER BY age` instead of keeping it, as ASC is the default ordering and the explicit specification is unnecessary. The amended query now correctly retrieves the youngest captain's name from the proper table with equivalent sorting behavior."
        ],
        "rules": [
            "1) When the question asks about \"captains\": use the exact table name \"captain\" instead of \"captains\" as shown in the schema. 2) When ordering by age to find the youngest: sort by the \"age\" column in ascending order (default direction) without explicitly specifying ASC. 3) When retrieving the youngest captain: limit results to 1 row after ordering by age to get the single youngest record."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM captains ORDER BY age ASC LIMIT 1;",
            "SELECT Name FROM captain ORDER BY age LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name FROM captain ORDER BY age LIMIT 1;"
        ]
    },
    "6443": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "What is the description for the budget type with code ORG?",
        "ground_truth": "SELECT budget_type_description FROM Ref_budget_codes WHERE budget_type_code  =  \"ORG\"",
        "amends": [
            "Do select `budget_type_description` instead of `description` and use table `Ref_budget_codes` instead of `budget_types`. Do filter on `budget_type_code = \"ORG\"` instead of `code = 'ORG'` with proper double quotes instead of single quotes. The amended query now correctly retrieves the budget type description from the appropriate reference table using the correct column names and syntax."
        ],
        "rules": [
            "1) When the question asks for \"description\" of a budget type: use the exact column \"budget_type_description\" instead of \"description\". 2) When the question refers to \"budget types\": use the exact table \"Ref_budget_codes\" instead of \"budget_types\". 3) When filtering by budget type code \"ORG\": use the exact column \"budget_type_code\" with double quotes around \"ORG\" (i.e., \"budget_type_code = \\\"ORG\\\"\") instead of single quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description FROM budget_types WHERE code = 'ORG';",
            "SELECT budget_type_description FROM Ref_Budget_Codes WHERE budget_type_code = \"ORG\""
        ],
        "rule_sql": [
            "SELECT budget_type_description FROM Ref_budget_codes WHERE budget_type_code = \"ORG\""
        ]
    },
    "6815": {
        "db_id": "flight_4",
        "question": "Find the country of the airlines whose name starts with 'Orbit'.",
        "ground_truth": "SELECT country FROM airlines WHERE name LIKE 'Orbit%'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM airlines WHERE name LIKE 'Orbit%';"
        ],
        "rule_sql": [
            "SELECT DISTINCT country FROM airlines WHERE name LIKE 'Orbit%'"
        ]
    },
    "3618": {
        "db_id": "music_1",
        "question": "What are the ids of all songs that have higher resolution of the average resolution in the modern genre?",
        "ground_truth": "SELECT f_id FROM song WHERE resolution  >  (SELECT avg(resolution) FROM song WHERE genre_is  =  \"modern\")",
        "amends": [
            "Do reference table `song` instead of `songs` and select column `f_id` instead of `song_id`. Do use aggregate function `avg` instead of `AVG` and apply the genre filter `genre_is = \"modern\"` within the subquery instead of in the outer WHERE clause. Do remove the outer `genre = 'modern'` condition instead of keeping it, as the subquery now correctly handles the genre filtering. Do use double quotes around string literal `\"modern\"` instead of single quotes. The amended query now correctly identifies songs with resolution above the average for modern genre songs only, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for song ids: select column \"f_id\" from table \"song\" instead of \"song_id\" from \"songs\". 2) When computing average resolution for a specific genre: apply the genre filter \"genre_is = \\\"modern\\\"\" within the subquery instead of in the outer WHERE clause. 3) When comparing string literals: use double quotes around \"modern\" instead of single quotes. 4) When using aggregate functions: use \"avg\" instead of \"AVG\" for computing averages. 5) When filtering songs by resolution above genre average: remove the outer genre condition since the subquery now correctly handles genre filtering."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT song_id FROM songs WHERE resolution > (SELECT AVG(resolution) FROM songs) AND genre = 'modern';",
            "SELECT f_id FROM song WHERE resolution > (SELECT avg(resolution) FROM song WHERE genre_is = \"modern\")"
        ],
        "rule_sql": [
            "SELECT f_id FROM song WHERE resolution > (SELECT avg(resolution) FROM song WHERE genre_is = \"modern\")"
        ]
    },
    "2421": {
        "db_id": "candidate_poll",
        "question": "Give the names of people who did not participate in the candidate election.",
        "ground_truth": "SELECT name FROM people WHERE people_id NOT IN (SELECT people_id FROM candidate)",
        "amends": [
            "Do reference `people_id` in the main query instead of `id` and use `people_id` in the subquery instead of `candidate_id`. Do query from the `candidate` table instead of `candidate_election` table. The amended query now correctly filters people who are not candidates by matching on the consistent `people_id` field across both tables."
        ],
        "rules": [
            "1) When the question asks about people who did not participate in the candidate election: use the \"people_id\" column from the \"people\" table instead of \"id\" for identification. 2) When checking for candidate participation: reference the \"candidate\" table instead of \"candidate_election\" table. 3) When filtering people who are not candidates: use \"people_id\" as the consistent matching field across both tables in the subquery condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM people WHERE id NOT IN (SELECT candidate_id FROM candidate_election);",
            "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM candidate)"
        ],
        "rule_sql": [
            "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM candidate)"
        ]
    },
    "5649": {
        "db_id": "railway",
        "question": "Show the countries that have both managers of age above 50 and managers of age below 46.",
        "ground_truth": "SELECT Country FROM manager WHERE Age  >  50 INTERSECT SELECT Country FROM manager WHERE Age  <  46",
        "amends": [
            "Do use `INTERSECT` to find common countries instead of incorrectly combining age filters with `AND`. Do reference the table as `manager` instead of `managers`. Do capitalize column names as `Country` and `Age` instead of lowercase `country` and `age`. Do split the query into two separate SELECT statements with `Age > 50` and `Age < 46` conditions instead of the impossible `age > 50 AND age < 46` predicate. The amended query now correctly finds countries that have managers both over 50 and under 46 years old, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for countries that have both managers above 50 and below 46: use INTERSECT to find common countries between the two age groups instead of combining conditions with AND. 2) When referring to the table: use the exact table name \"manager\" instead of \"managers\". 3) When referencing column names: use exact capitalized tokens \"Country\" and \"Age\" instead of lowercase versions. 4) When filtering for managers above 50: create a separate SELECT statement with condition \"Age > 50\". 5) When filtering for managers below 46: create a separate SELECT statement with condition \"Age < 46\". 6) When combining results: use INTERSECT between the two separate SELECT statements to find countries that appear in both result sets."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM managers WHERE age > 50 AND age < 46",
            "SELECT Country FROM manager WHERE Age > 50 INTERSECT SELECT Country FROM manager WHERE Age < 46"
        ],
        "rule_sql": [
            "SELECT Country FROM manager WHERE Age > 50 INTERSECT SELECT Country FROM manager WHERE Age < 46"
        ]
    },
    "490": {
        "db_id": "allergy_1",
        "question": "How many students are there for each major?",
        "ground_truth": "SELECT major ,  count(*) FROM Student GROUP BY major",
        "amends": [
            "Do use `GROUP BY major` instead of `GROUP BY student_id` to correctly aggregate counts by major rather than by individual student identifiers. Do reference table `Student` instead of `students` to match the correct table name in the schema. The amended query now correctly counts students grouped by their major field instead of producing per-student counts, matching the intended behavior of the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for counts per major: group by the \"major\" column instead of student identifiers. 2) When referencing the student table: use the exact table name \"Student\" instead of \"students\". 3) When counting students per major: aggregate counts by the \"major\" column to get the number of students for each major."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT major, COUNT(*) FROM students GROUP BY student_id;",
            "SELECT Major, COUNT(StuID) AS student_count FROM Student GROUP BY Major;"
        ],
        "rule_sql": [
            "SELECT major, COUNT(StuID) AS student_count FROM Student GROUP BY major;"
        ]
    },
    "5880": {
        "db_id": "tracking_share_transactions",
        "question": "Show the ids of the investors who have at least two transactions.",
        "ground_truth": "SELECT T2.investor_id FROM INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id GROUP BY T2.investor_id HAVING COUNT(*)  >=  2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT investor_id FROM transactions GROUP BY investor_id HAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT investor_id FROM Transactions GROUP BY investor_id HAVING COUNT(transaction_id) >= 2"
        ]
    },
    "2461": {
        "db_id": "movie_1",
        "question": "What are the different names of all reviewers whose ratings do not have a date field?",
        "ground_truth": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  \"null\"",
        "amends": [
            "Do add `JOIN Rating AS T2 ON T1.rID = T2.rID` instead of querying only the `reviewers` table. Do change the table reference to `Reviewer AS T1` instead of `reviewers`. Do use the condition `ratingDate = \"null\"` instead of `rating_date IS NULL` to check for string null values rather than SQL NULL values. Do reference the correct column name `ratingDate` instead of `rating_date`. The amended query now correctly joins the Reviewer and Rating tables and properly filters for string \"null\" values in the ratingDate column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about reviewers and their ratings: join table \"Reviewer\" as T1 with table \"Rating\" as T2 using the exact key equality T1.rID = T2.rID to link reviewer records with their ratings. 2) When checking for missing date values in the ratingDate column: use the exact condition ratingDate = \"null\" to match string null values rather than SQL NULL values. 3) When selecting reviewer names: use the exact column name \"name\" from table \"Reviewer\" as T1. 4) When the question asks for different names: ensure the result contains distinct values of the name column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT name FROM reviewers WHERE rating_date IS NULL;",
            "SELECT DISTINCT T1.name\nFROM Reviewer AS T1\nJOIN Rating AS T2 ON T1.rID = T2.rID\nWHERE T2.ratingDate = \"null\""
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID = T2.rID WHERE T2.ratingDate = \"null\""
        ]
    },
    "908": {
        "db_id": "insurance_fnol",
        "question": "Count the total number of policies used by the customer named \"Dayana Robel\".",
        "ground_truth": "SELECT count(*) FROM customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  \"Dayana Robel\"",
        "amends": [
            "Do join `customers AS t1` and `customers_policies AS t2` on `t1.customer_id = t2.customer_id` instead of querying only the `policies` table without proper joins. Do filter on `t1.customer_name = 'Dayana Robel'` instead of filtering directly on a customer_name field in the policies table. Do count records from the joined relationship instead of counting from a single table without the necessary customer-policy association. The amended query now correctly retrieves policy counts for the specified customer by establishing the proper relationship between customers and their policies."
        ],
        "rules": [
            "1) When answering about \"policies used by a customer\": combine tables \"customers AS t1\" and \"customers_policies AS t2\" by linking rows where t1.customer_id equals t2.customer_id, keeping only matching pairs. 2) When the question specifies customer name \"Dayana Robel\": filter on t1.customer_name = 'Dayana Robel' exactly as written. 3) When counting policies for a customer: count the number of rows from the joined relationship between customers and customers_policies tables."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM policies WHERE customer_name = 'Dayana Robel';",
            "SELECT COUNT(*) AS total_policies\nFROM Customers AS t1\nJOIN Customers_Policies AS t2 ON t1.Customer_ID = t2.Customer_ID\nWHERE t1.Customer_name = 'Dayana Robel'"
        ],
        "rule_sql": [
            "SELECT COUNT(t2.Policy_ID) \nFROM Customers AS t1 \nJOIN Customers_Policies AS t2 ON t1.Customer_ID = t2.Customer_ID \nWHERE t1.Customer_name = 'Dayana Robel'"
        ]
    },
    "3475": {
        "db_id": "hr_1",
        "question": "Find the employee id for all employees who earn more than the average salary.",
        "ground_truth": "SELECT employee_id FROM employees WHERE salary  >  (SELECT AVG(salary) FROM employees)",
        "amends": [
            "Do use a scalar subquery without `GROUP BY department_id` instead of a grouped subquery that returns multiple rows, as the comparison operator `>` requires a single value. Do remove the `GROUP BY` clause from the subquery instead of grouping by department, which would cause the subquery to return multiple average values and make the comparison invalid. The amended query now correctly compares each employee's salary against the overall company average salary instead of attempting to compare against multiple department averages simultaneously, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When comparing employee salaries against the average salary: use a scalar subquery that computes the overall average salary without grouping, as the comparison operator requires a single value. 2) When calculating average salary for comparison: remove any GROUP BY clause from the subquery to ensure it returns a single average value instead of multiple department averages. 3) When answering about employees who earn more than average: compare each employee's salary against the overall company average salary rather than department-specific averages."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT employee_id FROM employees WHERE salary > (SELECT AVG(salary) FROM employees GROUP BY department_id);",
            "SELECT EMPLOYEE_ID FROM employees WHERE SALARY > (SELECT AVG(SALARY) FROM employees)"
        ],
        "rule_sql": [
            "SELECT EMPLOYEE_ID FROM employees WHERE SALARY > (SELECT AVG(SALARY) FROM employees)"
        ]
    },
    "4348": {
        "db_id": "tracking_grants_for_research",
        "question": "List the project details of the projects with the research outcome described with the substring 'Published'.",
        "ground_truth": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE '%Published%'",
        "amends": [
            "Do specify `T1.project_details` in the SELECT list instead of using `*` to select all columns. Do add joins to `Project_outcomes AS T2` and `Research_outcomes AS T3` instead of querying only the `projects` table. Do use `JOIN` with `T1.project_id = T2.project_id` and `T2.outcome_code = T3.outcome_code` instead of no joins. Do filter on `T3.outcome_description LIKE '%Published%'` instead of filtering on a non-existent `research_outcome` column. The amended query now correctly joins related tables to filter research outcomes by description and returns only the relevant project details, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"project details of projects with research outcome containing 'Published'\": make sure the output order: T1.project_details. 2) When the question mentions \"research outcome described with the substring 'Published'\": \"research outcome\" actually means \"T3.outcome_description in schema\" and filter using T3.outcome_description LIKE '%Published%'. 3) When combining T1 (projects), T2 (Project_outcomes), and T3 (Research_outcomes): link rows where T1.project_id = T2.project_id and T2.outcome_code = T3.outcome_code; keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM projects WHERE research_outcome LIKE '%Published%';",
            "SELECT T1.project_details \nFROM Projects AS T1\nJOIN Project_Outcomes AS T2 ON T1.project_id = T2.project_id\nJOIN Research_Outcomes AS T3 ON T2.outcome_code = T3.outcome_code\nWHERE T3.outcome_description LIKE '%Published%'"
        ],
        "rule_sql": [
            "SELECT T1.project_details\nFROM Projects T1\nINNER JOIN Project_Outcomes T2 ON T1.project_id = T2.project_id\nINNER JOIN Research_Outcomes T3 ON T2.outcome_code = T3.outcome_code\nWHERE T3.outcome_description LIKE '%Published%'"
        ]
    },
    "4559": {
        "db_id": "company_office",
        "question": "Find the stories of the building with the largest height.",
        "ground_truth": "SELECT Stories FROM buildings ORDER BY Height DESC LIMIT 1",
        "amends": [
            "Do select `Stories` instead of `*` from the `buildings` table instead of the `stories` table. Do remove the WHERE clause and subquery instead of using a correlated subquery to find the building with maximum height. Do use `ORDER BY Height DESC LIMIT 1` to directly get the building with the most stories instead of attempting to find stories for the tallest building. The amended query now correctly retrieves the stories count from the tallest building by directly querying the buildings table with proper ordering and limiting."
        ],
        "rules": [
            "1) When answering about \"stories of the building with the largest height\": make sure the output order: Stories from the buildings table. 2) When the question mentions \"largest height\": use ORDER BY Height DESC LIMIT 1 to get the building with maximum height. 3) When selecting from the buildings table: select Stories instead of all columns (*). 4) When finding the building with maximum height: do not use a subquery or WHERE clause, instead directly query the buildings table with proper ordering and limiting."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM stories WHERE building_id = (SELECT id FROM buildings ORDER BY height DESC LIMIT 1);",
            "SELECT Stories FROM buildings ORDER BY Height DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Stories FROM buildings ORDER BY Height DESC LIMIT 1"
        ]
    },
    "5796": {
        "db_id": "customer_complaints",
        "question": "Which complaint status has more than 3 records on file?",
        "ground_truth": "SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  3",
        "amends": [
            "Do use `complaint_status_code` instead of `status` in both the SELECT list and GROUP BY clause to reference the correct column name. Do maintain the aggregate function `COUNT(*)` and the HAVING condition `COUNT(*) > 3` without changes. The amended query now correctly identifies complaint status codes with more than three occurrences, matching the RIGHT_SQL's behavior.",
            "Do remove the `COUNT(*)` column from the `SELECT` list instead of including it, as the `HAVING` clause already filters groups by count without needing to display the count values. The amended query now matches RIGHT_SQL's behavior by only returning the complaint_status_code values for groups that have more than 3 records."
        ],
        "rules": [
            "1) When the question asks about \"complaint status\": use the exact column name \"complaint_status_code\" instead of \"status\" in both the output and grouping. 2) When counting records for each complaint status: count all rows using COUNT(*) and only include groups where the count is greater than 3. 3) When organizing results by complaint status: group by the exact column \"complaint_status_code\" to show counts per status.",
            "1) When the question asks for complaint status with more than 3 records: only return the complaint_status_code values without including the count values in the output. 2) When filtering groups by count criteria: use HAVING COUNT(*) > 3 to filter groups but do not display the count column in the final results. 3) When answering about complaint status records: ensure the output contains only complaint_status_code values for groups that satisfy the count condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT status, COUNT(*) FROM complaints GROUP BY status HAVING COUNT(*) > 3",
            "SELECT complaint_status_code, COUNT(*) FROM Complaints GROUP BY complaint_status_code HAVING COUNT(*) > 3",
            "SELECT complaint_status_code FROM Complaints GROUP BY complaint_status_code HAVING COUNT(*) > 3"
        ],
        "rule_sql": [
            "SELECT complaint_status_code FROM Complaints GROUP BY complaint_status_code HAVING COUNT(*) > 3;"
        ]
    },
    "6888": {
        "db_id": "tracking_orders",
        "question": "Find the order id and customer id associated with the oldest order.",
        "ground_truth": "SELECT order_id ,  customer_id FROM orders ORDER BY date_order_placed LIMIT 1",
        "amends": [
            "Do reference the column `date_order_placed` in the ORDER BY clause instead of `order_date` to correctly sort by the intended date field, while keeping the same SELECT list columns `order_id` and `customer_id` from the `orders` table with the same LIMIT 1 constraint. The amended query now matches RIGHT_SQL's behavior by using the correct date column for ordering."
        ],
        "rules": [
            "1) When answering about \"the oldest order\": sort by the exact column \"date_order_placed\" in ascending order to find the earliest date. 2) When selecting columns for order information: include both \"order_id\" and \"customer_id\" from the \"orders\" table. 3) When finding the single oldest record: limit the result to only the first row after sorting by date."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT order_id, customer_id FROM orders ORDER BY order_date ASC LIMIT 1;",
            "SELECT order_id, customer_id FROM Orders ORDER BY date_order_placed ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT order_id, customer_id FROM Orders ORDER BY date_order_placed ASC LIMIT 1;"
        ]
    },
    "2281": {
        "db_id": "entrepreneur",
        "question": "What is the total money requested by entrepreneurs with height more than 1.85?",
        "ground_truth": "SELECT sum(T1.Money_Requested) FROM entrepreneur AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T2.Height  >  1.85",
        "amends": [
            "Do add `JOIN people AS T2 ON T1.People_ID = T2.People_ID` instead of querying only the `entrepreneurs` table. Do reference `T2.Height` instead of `height` in the WHERE filter, moving the height condition to the joined people table instead of applying it directly to entrepreneurs. Do use table alias `T1` for the entrepreneur table and reference `T1.Money_Requested` instead of directly using `money_requested`. The amended query now correctly joins to the people table to access height information and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"total money requested by entrepreneurs with height more than 1.85\": make sure the output order: SUM(T1.Money_Requested)\n2) When the question mentions \"entrepreneurs\": use table \"entrepreneurs\" with alias T1\n3) When the question mentions \"height\": \"height\" actually means \"T2.Height in schema\" from the people table\n4) When combining T1 (entrepreneurs) and T2 (people) for shared entities: link rows where T1.People_ID = T2.People_ID; keep only matching pairs (inner match)\n5) When filtering for height more than 1.85: apply the condition T2.Height > 1.85 to the joined people table"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(money_requested) FROM entrepreneurs WHERE height > 1.85",
            "SELECT SUM(T1.Money_Requested) FROM entrepreneur AS T1 JOIN people AS T2 ON T1.People_ID = T2.People_ID WHERE T2.Height > 1.85"
        ],
        "rule_sql": [
            "SELECT SUM(T1.Money_Requested) FROM entrepreneur AS T1 INNER JOIN people AS T2 ON T1.People_ID = T2.People_ID WHERE T2.Height > 1.85"
        ]
    },
    "5677": {
        "db_id": "dorm_1",
        "question": "What is the first name of the students who are in age 20 to 25 and living in PHL city?",
        "ground_truth": "SELECT fname FROM student WHERE city_code  =  'PHL' AND age BETWEEN 20 AND 25",
        "amends": [
            "Do use column `fname` instead of `first_name` and table `student` instead of `students`. Do use filter `city_code = 'PHL'` instead of `city = 'PHL'` while maintaining the `age BETWEEN 20 AND 25` condition in the WHERE clause. The amended query now correctly references the schema and matches the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"first name\": use the exact column token \"fname\" instead of \"first_name\". 2) When the question refers to \"students\": use the exact table token \"student\" instead of \"students\". 3) When the question mentions \"living in PHL city\": use the exact filter condition \"city_code = 'PHL'\" instead of \"city = 'PHL'\". 4) When the question asks for students \"in age 20 to 25\": maintain the exact filter condition \"age BETWEEN 20 AND 25\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE age BETWEEN 20 AND 25 AND city = 'PHL';",
            "SELECT fname FROM Student WHERE age BETWEEN 20 AND 25 AND city_code = 'PHL';"
        ],
        "rule_sql": [
            "SELECT fname FROM student WHERE age BETWEEN 20 AND 25 AND city_code = 'PHL'"
        ]
    },
    "2562": {
        "db_id": "county_public_safety",
        "question": "What is the location shared by most counties?",
        "ground_truth": "SELECT LOCATION FROM county_public_safety GROUP BY LOCATION ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do reference table `county_public_safety` instead of `counties` in the FROM clause. Do remove the explicit `COUNT(*) as county_count` column from the SELECT list instead of including it, as only the `LOCATION` is needed. Do move the aggregate function `COUNT(*)` to the ORDER BY clause instead of including it in the SELECT list. Do use uppercase `LOCATION` instead of lowercase `location` for consistency with the table schema. The amended query now correctly identifies the location with the highest count from the county_public_safety table while matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"location shared by most counties\": make sure the output order: \"LOCATION\" only. 2) When the question mentions \"counties\": \"counties\" actually means \"county_public_safety\" table in schema. 3) When the question asks for \"most counties\" (highest count): rank rows by count of counties in descending order and keep the first 1 row. 4) When counting counties: compute the number of rows using the canonical key from county_public_safety table. 5) When producing output: do not include the count column in the final results, only include \"LOCATION\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location, COUNT(*) as county_count FROM counties GROUP BY location ORDER BY county_count DESC LIMIT 1;",
            "SELECT LOCATION FROM county_public_safety GROUP BY LOCATION ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Location FROM county_public_safety GROUP BY Location ORDER BY COUNT(County_ID) DESC LIMIT 1;"
        ]
    },
    "2450": {
        "db_id": "movie_1",
        "question": "What is the lowest and highest rating star?",
        "ground_truth": "SELECT max(stars) ,  min(stars) FROM Rating",
        "amends": [
            "Do use column name `stars` instead of `rating_star` in both aggregate functions. Do swap the order of aggregates by placing `max(stars)` first instead of `min(rating_star)` first. Do reference table `Rating` instead of `ratings` with proper capitalization. The amended query now correctly calculates maximum and minimum star ratings from the Rating table."
        ],
        "rules": [
            "1) When the question asks for \"rating star\": use the exact column name \"stars\" from the Rating table. 2) When calculating minimum and maximum values: place the maximum function result first in the output order. 3) When referencing the ratings table: use the exact table name \"Rating\" with proper capitalization."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(rating_star), MAX(rating_star) FROM ratings;",
            "SELECT MAX(stars) AS highest_rating, MIN(stars) AS lowest_rating FROM Rating;"
        ],
        "rule_sql": [
            "SELECT MAX(stars) AS highest_rating, MIN(stars) AS lowest_rating FROM Rating;"
        ]
    },
    "5753": {
        "db_id": "dorm_1",
        "question": "What amenities does Smith Hall have in alphabetical order?",
        "ground_truth": "SELECT T3.amenity_name FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid JOIN dorm_amenity AS T3 ON T2.amenid  =  T3.amenid WHERE T1.dorm_name  =  'Smith Hall' ORDER BY T3.amenity_name",
        "amends": [
            "Do use explicit table aliases `T3.amenity_name` instead of bare column `amenity_name`. Do join three tables `dorm AS T1`, `has_amenity AS T2`, and `dorm_amenity AS T3` instead of querying only the `amenities` table. Do perform an `INNER JOIN` between `T1` and `T2` on `T1.dormid = T2.dormid` instead of missing this relationship. Do perform another `INNER JOIN` between `T2` and `T3` on `T2.amenid = T3.amenid` instead of omitting this connection. Do filter on `T1.dorm_name = 'Smith Hall'` instead of `building_name = 'Smith Hall'` to use the correct column name. Do maintain the `ORDER BY T3.amenity_name` clause instead of changing the sorting logic. The amended query now correctly retrieves amenities by joining through the proper relationship tables and matches the intended behavior."
        ],
        "rules": [
            "1) When answering about amenities for a specific dorm: join three tables dorm AS T1, has_amenity AS T2, and dorm_amenity AS T3 using explicit table aliases. 2) When combining T1 and T2: link rows where T1.dormid = T2.dormid and keep only matching pairs (inner match). 3) When combining T2 and T3: link rows where T2.amenid = T3.amenid and keep only matching pairs (inner match). 4) When the question mentions \"Smith Hall\": \"Smith Hall\" actually means T1.dorm_name = 'Smith Hall' in the schema. 5) When the question asks for amenities in alphabetical order: order the results by T3.amenity_name in ascending order. 6) When producing output: include only T3.amenity_name as the output column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT amenity_name FROM amenities WHERE building_name = 'Smith Hall' ORDER BY amenity_name ASC;",
            "SELECT T3.amenity_name\nFROM dorm AS T1\nINNER JOIN has_amenity AS T2 ON T1.dormid = T2.dormid\nINNER JOIN dorm_amenity AS T3 ON T2.amenid = T3.amenid\nWHERE T1.dorm_name = 'Smith Hall'\nORDER BY T3.amenity_name;"
        ],
        "rule_sql": [
            "SELECT T3.amenity_name\nFROM dorm AS T1\nINNER JOIN has_amenity AS T2 ON T1.dormid = T2.dormid\nINNER JOIN dorm_amenity AS T3 ON T2.amenid = T3.amenid\nWHERE T1.dorm_name = 'Smith Hall'\nORDER BY T3.amenity_name ASC;"
        ]
    },
    "1517": {
        "db_id": "insurance_and_eClaims",
        "question": "Find the total amount claimed in the most recently created document.",
        "ground_truth": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)",
        "amends": [
            "Do select `sum(t1.amount_claimed)` from table `claim_headers AS t1` instead of `SUM(amount)` from table `documents`. Do add `JOIN claims_documents AS t2` with join condition `ON t1.claim_header_id = t2.claim_id` instead of no join. Do add `WHERE t2.created_date =` subquery instead of no filter. Do use subquery `(SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)` to get the earliest created date instead of ordering the main result. Do remove `ORDER BY created_at DESC LIMIT 1` from the main query instead of keeping it as the final operation. The amended query now correctly calculates the sum of amount_claimed for claims associated with the earliest document creation date, matching the intended behavior.",
            "Do use `ORDER BY created_date` instead of `ORDER BY Created_Date DESC` in the subquery to get the earliest date rather than the latest date. Do maintain the same column references and join condition between `t1.claim_header_id` and `t2.claim_id` without changes. Do preserve the aggregate function `sum(t1.amount_claimed)` and table aliases `t1` and `t2` as they appear in the original structure. The amended query now correctly retrieves the sum of claimed amounts for claims with the earliest document creation date instead of the latest, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"total amount claimed\": use sum(t1.amount_claimed) from table claim_headers AS t1 instead of SUM(amount) from documents. 2) When combining claim_headers and claims_documents: link rows where t1.claim_header_id = t2.claim_id and keep only matching pairs (inner match). 3) When filtering for the most recently created document: use WHERE t2.created_date = (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1) to get the earliest created date. 4) When the question asks for the most recently created document: use ORDER BY created_date LIMIT 1 in the subquery to get the single most recent date.",
            "1) When the question asks for the most recently created document: use ORDER BY created_date DESC to get the latest date instead of ORDER BY created_date which gets the earliest date. 2) When combining Claim_Headers (T1) and Claims_Documents (T2): link rows where T1.claim_header_id = T2.claim_id and keep only matching pairs. 3) When computing the total amount claimed: use SUM(T1.Amount_Claimed) as the aggregate function. 4) When filtering for the most recent document date: use T2.Created_Date = (subquery that gets the maximum Created_Date) instead of comparing to the earliest date."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(amount) FROM documents ORDER BY created_at DESC LIMIT 1;",
            "SELECT SUM(t1.Amount_Claimed) \nFROM Claim_Headers AS t1\nJOIN Claims_Documents AS t2 ON t1.Claim_Header_ID = t2.Claim_ID\nWHERE t2.Created_Date = (SELECT Created_Date FROM Claims_Documents ORDER BY Created_Date DESC LIMIT 1)",
            "SELECT SUM(t1.Amount_Claimed) \nFROM Claim_Headers AS t1\nJOIN Claims_Documents AS t2 ON t1.Claim_Header_ID = t2.Claim_ID\nWHERE t2.Created_Date = (SELECT Created_Date FROM Claims_Documents ORDER BY Created_Date LIMIT 1)"
        ],
        "rule_sql": [
            "SELECT SUM(t1.Amount_Claimed) \nFROM Claim_Headers AS t1\nINNER JOIN Claims_Documents AS t2 ON t1.Claim_Header_ID = t2.Claim_ID\nWHERE t2.Created_Date = (SELECT MAX(Created_Date) FROM Claims_Documents)"
        ]
    },
    "518": {
        "db_id": "allergy_1",
        "question": "How many students are affected by each allergy type?",
        "ground_truth": "SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype",
        "amends": [
            "Do join `Allergy_type AS T2` instead of omitting it, and do specify `Has_allergy AS T1` as the source table instead of `students`. Do use `ON T1.allergy = T2.allergy` for the join condition instead of no join condition. Do select `T2.allergytype` instead of `allergy_type`, and do group by `T2.allergytype` instead of `allergy_type`. The amended query now correctly joins the necessary tables to count allergies by type rather than assuming the allergy type exists directly in the student table."
        ],
        "rules": [
            "1) When answering about \"students affected by each allergy type\": make sure the output order: T2.allergytype first, then count. 2) When the question mentions \"allergy type\": \"allergy type\" actually means \"T2.allergytype in schema\". 3) When the question asks for \"count of students affected by each allergy type\": compute the number of rows using the canonical key token for students (T1.allergy). 4) When combining T1 (Has_allergy) and T2 (Allergy_type) for shared entities: link rows where T1.allergy = T2.allergy exactly as shown; keep only matching pairs (inner match). 5) When the question says \"per allergy type\"/\"by allergy type\": organize results by T2.allergytype and compute count per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT allergy_type, COUNT(*) FROM students GROUP BY allergy_type;",
            "SELECT T2.AllergyType, COUNT(*) AS student_count\nFROM Has_Allergy AS T1\nJOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy\nGROUP BY T2.AllergyType"
        ],
        "rule_sql": [
            "SELECT T2.AllergyType, COUNT(T1.Allergy) \nFROM Has_Allergy T1\nINNER JOIN Allergy_Type T2 ON T1.Allergy = T2.Allergy\nGROUP BY T2.AllergyType\nORDER BY T2.AllergyType, COUNT(T1.Allergy)"
        ]
    },
    "2758": {
        "db_id": "election",
        "question": "Show the delegates and the names of county they belong to.",
        "ground_truth": "SELECT T2.Delegate ,  T1.County_name FROM county AS T1 JOIN election AS T2 ON T1.County_id  =  T2.District",
        "amends": [
            "Do select `T2.Delegate` and `T1.County_name` instead of `delegate_name` and `county_name`. Do join `county AS T1` with `election AS T2` instead of `delegates` with `counties`. Do use the join condition `T1.County_id = T2.District` instead of `delegates.county_id = counties.state_id`. The amended query now correctly matches the intended table relationships and column selections."
        ],
        "rules": [
            "1) When selecting delegate information: use \"T2.Delegate\" instead of \"delegate_name\" 2) When selecting county information: use \"T1.County_name\" instead of \"county_name\" 3) When combining county and election data: join \"county AS T1\" with \"election AS T2\" instead of delegates with counties 4) When linking county and election tables: use the join condition T1.County_id = T2.District instead of delegates.county_id = counties.state_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT delegate_name, county_name FROM delegates JOIN counties ON delegates.county_id = counties.state_id;",
            "SELECT T2.Delegate, T1.County_name FROM county AS T1 JOIN election AS T2 ON T1.County_Id = T2.District"
        ],
        "rule_sql": [
            "SELECT T2.Delegate, T1.County_name FROM county AS T1 JOIN election AS T2 ON T1.County_Id = T2.District"
        ]
    },
    "6504": {
        "db_id": "scientist_1",
        "question": "What are the names of scientists who are assigned to any project?",
        "ground_truth": "SELECT T2.name FROM assignedto AS T1 JOIN scientists AS T2 ON T1.scientist  =  T2.ssn",
        "amends": [
            "Do add `assignedto AS T1 JOIN scientists AS T2 ON T1.scientist = T2.ssn` as the FROM clause instead of just `scientists`. Do change the SELECT list to `T2.name` instead of `name`. Do remove the `WHERE project_id IS NULL` filter instead of keeping it. The amended query now correctly joins the assignedto and scientists tables to retrieve names of scientists who are assigned to projects, rather than incorrectly filtering for scientists with null project IDs."
        ],
        "rules": [
            "1) When answering about \"scientists who are assigned to any project\": combine tables \"assignedto\" as T1 and \"scientists\" as T2 using the exact join condition T1.scientist = T2.ssn, keeping only matching pairs (inner match). 2) When selecting output columns: use T2.name as the exact column token for scientist names. 3) When filtering for assignment status: do not apply any WHERE project_id IS NULL condition as scientists are assigned through the join relationship rather than a direct project_id column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM scientists WHERE project_id IS NULL;",
            "SELECT T2.Name FROM AssignedTo AS T1 JOIN Scientists AS T2 ON T1.Scientist = T2.SSN"
        ],
        "rule_sql": [
            "SELECT T2.Name FROM AssignedTo AS T1 INNER JOIN Scientists AS T2 ON T1.Scientist = T2.SSN"
        ]
    },
    "2376": {
        "db_id": "csu_1",
        "question": "How many faculty lines are there in \"San Francisco State University\" in year 2004?",
        "ground_truth": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  \"San Francisco State University\"",
        "amends": [
            "Do join `campuses AS T2` on `T1.campus = T2.id` instead of querying only the `faculty` table. Do filter on `T2.campus = \"San Francisco State University\"` instead of filtering directly on `faculty.university`. Do select the `faculty` column instead of `COUNT(*)`. Do use the alias `T1` for the faculty table instead of no alias. Do maintain the `T1.year = 2004` filter but move it to the WHERE clause instead of keeping it in the original position. The amended query now correctly joins the campuses table to resolve university names and returns actual faculty count data instead of just a count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about faculty lines in a specific university: join the faculty table (T1) with the campuses table (T2) where T1.campus = T2.id to resolve university names. 2) When filtering for \"San Francisco State University\": use T2.campus = \"San Francisco State University\" instead of filtering directly on faculty.university. 3) When selecting faculty count data: select the faculty column instead of COUNT(*). 4) When filtering by year 2004: maintain T1.year = 2004 in the WHERE clause. 5) When combining tables: perform an inner match where T1.campus = T2.id to ensure only matching campus records are included."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM faculty WHERE university = 'San Francisco State University' AND year = 2004",
            "SELECT T1.Faculty FROM faculty AS T1 JOIN Campuses AS T2 ON T1.Campus = T2.Id WHERE T2.Campus = 'San Francisco State University' AND T1.Year = 2004"
        ],
        "rule_sql": [
            "SELECT f.Faculty FROM faculty f JOIN Campuses c ON f.Campus = c.Id WHERE c.Campus = 'San Francisco State University' AND f.Year = 2004"
        ]
    },
    "1733": {
        "db_id": "riding_club",
        "question": "Show the residences that have both a player of gender \"M\" and a player of gender \"F\".",
        "ground_truth": "SELECT Residence FROM player WHERE gender  =  \"M\" INTERSECT SELECT Residence FROM player WHERE gender  =  \"F\"",
        "amends": [
            "Do use `INTERSECT` to find common residences instead of `OR` with `DISTINCT`. Do reference table as `player` instead of `players`. Do capitalize column as `Residence` instead of `residence`. Do use double quotes for string literals instead of single quotes. Do remove the `DISTINCT` modifier since `INTERSECT` inherently returns unique values. Do split the query into two separate `SELECT` statements with `INTERSECT` instead of a single query with `OR` condition. The amended query now correctly finds residences that have both male and female players instead of residences that have either male or female players, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for residences that have both male and female players: use INTERSECT to find common residences instead of OR with DISTINCT. 2) When referencing the table: use the exact table name \"player\" instead of \"players\". 3) When selecting the residence column: use the exact column name \"Residence\" with proper capitalization. 4) When specifying gender values: use double quotes for string literals \"M\" and \"F\" instead of single quotes. 5) When using INTERSECT: remove the DISTINCT modifier since INTERSECT inherently returns unique values. 6) When finding residences with both genders: split the query into two separate SELECT statements with INTERSECT instead of a single query with OR condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT residence FROM players WHERE gender = 'M' OR gender = 'F';",
            "SELECT Residence FROM player WHERE Gender = \"M\" INTERSECT SELECT Residence FROM player WHERE Gender = \"F\""
        ],
        "rule_sql": [
            "SELECT Residence FROM player WHERE Gender = \"M\" INTERSECT SELECT Residence FROM player WHERE Gender = \"F\""
        ]
    },
    "6669": {
        "db_id": "driving_school",
        "question": "When did Carole Bernhard first become a customer?",
        "ground_truth": "SELECT date_became_customer FROM Customers WHERE first_name = \"Carole\" AND last_name = \"Bernhard\";",
        "amends": [
            "Do select `date_became_customer` instead of `MIN(order_date)` as the target column. Do reference the table as `Customers` instead of `customers` with proper case sensitivity. Do use double quotes `\"Carole\"` and `\"Bernhard\"` instead of single quotes for string literals. Do remove the `MIN` aggregate function since we're selecting a single column value instead of calculating a minimum. The amended query now correctly retrieves the customer's signup date rather than attempting to find the minimum order date, matching the intended behavior of the right SQL."
        ],
        "rules": [
            "1) When the question asks about when someone became a customer: select the exact column \"date_became_customer\" instead of order-related dates. 2) When referencing the Customers table: use the exact identifier \"Customers\" with proper case sensitivity. 3) When using string literals for names: use double quotes exactly as \"Carole\" and \"Bernhard\" instead of single quotes. 4) When selecting a single date value: do not use aggregate functions like MIN since we're retrieving the actual column value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(order_date) FROM customers WHERE first_name = 'Carole' AND last_name = 'Bernhard';",
            "SELECT date_became_customer FROM Customers WHERE first_name = \"Carole\" AND last_name = \"Bernhard\";"
        ],
        "rule_sql": [
            "SELECT date_became_customer FROM Customers WHERE first_name = \"Carole\" AND last_name = \"Bernhard\";"
        ]
    },
    "6389": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "How many statements do we have?",
        "ground_truth": "SELECT count(*) FROM Statements",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM statements;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Statements;"
        ]
    },
    "3871": {
        "db_id": "insurance_policies",
        "question": "Tell me the the date when the first claim was made.",
        "ground_truth": "SELECT Date_Claim_Made FROM Claims ORDER BY Date_Claim_Made ASC LIMIT 1",
        "amends": [
            "Do select `Date_Claim_Made` instead of `MIN(claim_date)` and do add `ORDER BY Date_Claim_Made ASC LIMIT 1` instead of using the aggregate function. Do reference table `Claims` instead of `claims` and do remove the `WHERE claim_id = 1` filter instead of keeping it. The amended query now correctly retrieves the earliest claim date without filtering by claim_id and matches the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"the date when the first claim was made\": make sure the output order: Date_Claim_Made. 2) When the question mentions \"first claim\": use ORDER BY Date_Claim_Made ASC LIMIT 1 instead of aggregate functions. 3) When referencing the claims table: use the exact table name \"Settlements\" with double quotes as shown in the schema. 4) When filtering claims: do not apply any WHERE clause filtering by claim_id or other conditions unless explicitly specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(claim_date) FROM claims WHERE claim_id = 1;",
            "SELECT Date_Claim_Made FROM Claims ORDER BY Date_Claim_Made ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Date_Claim_Made FROM \"Settlements\" ORDER BY Date_Claim_Made ASC LIMIT 1"
        ]
    },
    "2107": {
        "db_id": "cre_Doc_Control_Systems",
        "question": "What is the role of the employee named Koby?",
        "ground_truth": "SELECT T1.role_description FROM ROLES AS T1 JOIN Employees AS T2 ON T1.role_code = T2.role_code WHERE T2.employee_name = \"Koby\";",
        "amends": [
            "Do select `T1.role_description` from the `ROLES` table instead of `role` from the `employees` table. Do join `ROLES AS T1` with `Employees AS T2` using `ON T1.role_code = T2.role_code` instead of querying only the `employees` table. Do filter on `T2.employee_name = \"Koby\"` instead of `name = 'Koby'` to reference the correct column name and table alias. The amended query now correctly retrieves role descriptions by joining the roles table with employee data using the proper relationship through role codes."
        ],
        "rules": [
            "1) When the question asks about an employee's role: use the \"ROLES\" table as T1 and \"Employees\" table as T2 with an inner join on T1.role_code = T2.role_code. 2) When filtering for an employee named \"Koby\": use the exact condition T2.employee_name = \"Koby\" with double quotes. 3) When selecting the role description: output T1.role_description instead of any role column from the employees table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT role FROM employees WHERE name = 'Koby';",
            "SELECT T1.role_description \nFROM ROLES AS T1 \nJOIN Employees AS T2 ON T1.role_code = T2.role_code \nWHERE T2.employee_name = 'Koby'"
        ],
        "rule_sql": [
            "SELECT T1.role_description FROM Roles AS T1 INNER JOIN Employees AS T2 ON T1.role_code = T2.role_code WHERE T2.employee_name = \"Koby\""
        ]
    },
    "4148": {
        "db_id": "film_rank",
        "question": "Show the studios that have produced films with director \"Nicholas Meyer\" and \"Walter Hill\".",
        "ground_truth": "SELECT Studio FROM film WHERE Director  =  \"Nicholas Meyer\" INTERSECT SELECT Studio FROM film WHERE Director  =  \"Walter Hill\"",
        "amends": [
            "Do use `INTERSECT` to find studios that have worked with both directors instead of `OR` which finds studios that worked with either director. Do reference the table as `film` instead of `films` and use proper column casing `Studio` and `Director` instead of lowercase `studio` and `director`. Do remove `DISTINCT` since `INTERSECT` inherently returns unique results instead of keeping it. Do use double quotes for string literals `\"Nicholas Meyer\"` and `\"Walter Hill\"` instead of single quotes. The amended query now correctly identifies studios that have collaborated with both Nicholas Meyer and Walter Hill, matching the RIGHT_SQL's intersection behavior."
        ],
        "rules": [
            "1) When the question asks for studios that have produced films with both \"Nicholas Meyer\" and \"Walter Hill\": use INTERSECT to find studios that appear in both director groups instead of OR which finds studios in either group. 2) When referencing the film table: use the exact table name \"film\" instead of \"films\". 3) When selecting the studio column: use the exact column name \"Studio\" with proper casing instead of lowercase \"studio\". 4) When filtering by director names: use the exact column name \"Director\" with proper casing instead of lowercase \"director\". 5) When specifying director literals: use double quotes for string values \"Nicholas Meyer\" and \"Walter Hill\" instead of single quotes. 6) When using INTERSECT operation: remove DISTINCT since INTERSECT inherently returns unique results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT studio FROM films WHERE director = 'Nicholas Meyer' OR director = 'Walter Hill'",
            "SELECT Studio FROM film WHERE Director = \"Nicholas Meyer\" INTERSECT SELECT Studio FROM film WHERE Director = \"Walter Hill\""
        ],
        "rule_sql": [
            "SELECT Studio FROM film WHERE Director = \"Nicholas Meyer\" INTERSECT SELECT Studio FROM film WHERE Director = \"Walter Hill\""
        ]
    },
    "921": {
        "db_id": "insurance_fnol",
        "question": "Find the names of customers who have used either the service \"Close a policy\" or the service \"Upgrade a policy\".",
        "ground_truth": "SELECT t1.customer_name FROM customers AS t1 JOIN first_notification_of_loss AS t2 ON t1.customer_id  =  t2.customer_id JOIN services AS t3 ON t2.service_id  =  t3.service_id WHERE t3.service_name  =  \"Close a policy\" OR t3.service_name  =  \"Upgrade a policy\"",
        "amends": [
            "Do select `t1.customer_name` instead of `name` and add table aliases throughout. Do add `JOIN first_notification_of_loss AS t2` and `JOIN services AS t3` instead of querying only the customers table. Do change the join condition to `ON t1.customer_id = t2.customer_id` and `ON t2.service_id = t3.service_id` instead of missing these relationships entirely. Do change the WHERE clause to use `t3.service_name = \"Close a policy\" OR t3.service_name = \"Upgrade a policy\"` instead of the impossible `service = 'Close a policy' AND service = 'Upgrade a policy'` which could never return results. The amended query now correctly joins through the related tables and uses OR logic to find customers with either service type, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about customer names: use the exact column token \"t1.customer_name\" instead of \"name\". 2) When the question mentions services \"Close a policy\" or \"Upgrade a policy\": these correspond to exact literal values \"Close a policy\" and \"Upgrade a policy\" in column \"t3.service_name\". 3) When combining customer and service information: join tables using the exact relationships \"t1.customer_id = t2.customer_id\" and \"t2.service_id = t3.service_id\" to link customers to their services. 4) When finding customers who used either service: use OR logic with the exact conditions \"t3.service_name = \\\"Close a policy\\\" OR t3.service_name = \\\"Upgrade a policy\\\"\" instead of impossible AND logic. 5) When accessing service information: join through the \"first_notification_of_loss\" table as \"t2\" and \"services\" table as \"t3\" instead of querying only the customers table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM customers WHERE service = 'Close a policy' AND service = 'Upgrade a policy';",
            "SELECT t1.Customer_name\nFROM Customers AS t1\nJOIN First_Notification_of_Loss AS t2 ON t1.Customer_ID = t2.Customer_ID\nJOIN Services AS t3 ON t2.Service_ID = t3.Service_ID\nWHERE t3.Service_name = 'Close a policy' OR t3.Service_name = 'Upgrade a policy'"
        ],
        "rule_sql": [
            "SELECT t1.Customer_name\nFROM Customers t1\nJOIN First_Notification_of_Loss t2 ON t1.Customer_ID = t2.Customer_ID\nJOIN Services t3 ON t2.Service_ID = t3.Service_ID\nWHERE t3.Service_name = \"Close a policy\" OR t3.Service_name = \"Upgrade a policy\""
        ]
    },
    "1382": {
        "db_id": "college_2",
        "question": "List the information of all instructors ordered by their salary in ascending order.",
        "ground_truth": "SELECT * FROM instructor ORDER BY salary",
        "amends": [
            "Do reference table `instructor` instead of `instructors` to correct the table name. Do use ascending `ORDER BY salary` instead of descending `ORDER BY salary DESC` to sort by salary in ascending order rather than descending. The amended query now correctly references the intended table and sorts results in ascending salary order, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question mentions \"instructors\": \"instructors\" actually means \"instructor\" in schema. 2) When the question asks for ordering by salary in ascending order: sort rows by salary in ascending direction (lowest to highest)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM instructors ORDER BY salary DESC;",
            "SELECT * FROM instructor ORDER BY salary ASC;"
        ],
        "rule_sql": [
            "SELECT * FROM instructor ORDER BY salary ASC;"
        ]
    },
    "6125": {
        "db_id": "customers_and_addresses",
        "question": "Find the total amount of products ordered before 2018-03-17 07:13:53.",
        "ground_truth": "SELECT sum(t2.order_quantity) FROM customer_orders AS t1 JOIN order_items AS t2 ON t1.order_id  =  t2.order_id WHERE t1.order_date  <  \"2018-03-17 07:13:53\"",
        "amends": [
            "Do use `sum(t2.order_quantity)` instead of `SUM(quantity)` for the aggregate expression. Do join `customer_orders AS t1` with `order_items AS t2` on `t1.order_id = t2.order_id` instead of querying only the `orders` table. Do filter with `t1.order_date < \"2018-03-17 07:13:53\"` instead of `order_date > '2018-03-17 07:13:53'` for the date comparison. The amended query now correctly calculates the sum of order quantities from joined tables with the proper date filter."
        ],
        "rules": [
            "1) When answering about \"total amount of products ordered\": use sum(t2.order_quantity) instead of SUM(quantity) for the aggregate expression. 2) When combining customer_orders and order_items tables: join customer_orders AS t1 with order_items AS t2 on t1.order_id = t2.order_id instead of querying only the orders table. 3) When filtering orders by date before 2018-03-17 07:13:53: use t1.order_date < \"2018-03-17 07:13:53\" instead of order_date > '2018-03-17 07:13:53' for the date comparison."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(quantity) FROM orders WHERE order_date > '2018-03-17 07:13:53'",
            "SELECT SUM(t2.order_quantity) AS total_products_ordered\nFROM Customer_Orders AS t1\nJOIN Order_Items AS t2 ON t1.order_id = t2.order_id\nWHERE t1.order_date < '2018-03-17 07:13:53'"
        ],
        "rule_sql": [
            "SELECT SUM(t2.order_quantity) AS total_products_ordered\nFROM Customer_Orders AS t1\nJOIN Order_Items AS t2 ON t1.order_id = t2.order_id\nWHERE t1.order_date < \"2018-03-17 07:13:53\""
        ]
    },
    "3688": {
        "db_id": "baseball_1",
        "question": "How many parks does Atlanta city have?",
        "ground_truth": "SELECT count(*) FROM park WHERE city = 'Atlanta';",
        "amends": [
            "Do reference the `park` table instead of the `parks` table to ensure the query targets the correct database object. The amended query now correctly counts records from the `park` table where the city is Atlanta, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"parks\": use the exact table name \"park\" instead of \"parks\" as specified in the schema. 2) When counting entities from the park table: count all records where the city is exactly 'Atlanta' (case-sensitive match). 3) When handling text literals: preserve the exact value 'Atlanta' with the exact case and spelling as shown in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM parks WHERE city = 'Atlanta';",
            "SELECT COUNT(*) FROM park WHERE city = 'Atlanta';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM park WHERE city = 'Atlanta';"
        ]
    },
    "370": {
        "db_id": "flight_1",
        "question": "What is the name and salary of the employee with the id 242518965?",
        "ground_truth": "SELECT name ,  salary FROM Employee WHERE eid  =  242518965",
        "amends": [
            "Do reference table `Employee` instead of `employees` in the FROM clause. Do use column `eid` instead of `id` in the WHERE filter condition. Do remove the single quotes around the numeric value `242518965` instead of treating it as a string literal. The amended query now correctly matches RIGHT_SQL's behavior by using the proper table name, column identifier, and numeric comparison without unnecessary string casting."
        ],
        "rules": [
            "1) When the question asks about employee information: use table \"Employee\" instead of \"employees\" as the data source. 2) When filtering by employee identifier: use column \"eid\" instead of \"id\" for the employee ID field. 3) When comparing numeric employee IDs like 242518965: do not use quotes around the numeric value, treat it as a number rather than a string literal."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, salary FROM employees WHERE id = '242518965';",
            "SELECT name, salary FROM employee WHERE eid = 242518965"
        ],
        "rule_sql": [
            "SELECT name, salary FROM employee WHERE eid = 242518965"
        ]
    },
    "4098": {
        "db_id": "company_employee",
        "question": "What are the headquarters and industries of all companies?",
        "ground_truth": "SELECT Headquarters ,  Industry FROM company",
        "amends": [
            "Do reference the table as `company` instead of `companies` and use exact column names `Headquarters` and `Industry` instead of lowercase `headquarters` and `industry`. Do remove the `WHERE headquarters IS NOT NULL` filter instead of keeping it, as the right query returns all records without null filtering. The amended query now correctly selects from the proper table schema with the appropriate column casing and without unnecessary filtering, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"headquarters and industries of all companies\": use the exact table name \"company\" instead of \"companies\". 2) When selecting column values: use the exact column names \"Headquarters\" and \"Industry\" with proper casing instead of lowercase versions. 3) When the question asks for \"all companies\": return all records without applying any null filtering conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT headquarters, industry FROM companies WHERE headquarters IS NOT NULL",
            "SELECT Headquarters, Industry FROM company"
        ],
        "rule_sql": [
            "SELECT Headquarters, Industry FROM company"
        ]
    },
    "2413": {
        "db_id": "candidate_poll",
        "question": "What are the average and minimum weights for people of each sex?",
        "ground_truth": "SELECT avg(weight) ,  min(weight) ,  sex FROM people GROUP BY sex",
        "amends": [
            "Do use `avg(weight)` and `min(weight)` instead of `AVG(weight)` and `MAX(weight)` with incorrect aliases. Do place `sex` at the end of the SELECT list instead of at the beginning. Do remove the `average_weight` and `minimum_weight` aliases instead of keeping them, as the RIGHT_SQL uses unaliased expressions. The amended query now correctly calculates the minimum weight instead of maximum weight and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When calculating aggregates for people by sex: use avg(weight) for average weight and min(weight) for minimum weight instead of AVG(weight) and MAX(weight). 2) When ordering output columns for this question: place sex at the end of the output list instead of at the beginning. 3) When presenting aggregate results: do not use aliases like average_weight and minimum_weight, use unaliased expressions as shown in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT sex, AVG(weight) as average_weight, MAX(weight) as minimum_weight FROM people GROUP BY sex;",
            "SELECT avg(weight), min(weight), sex FROM people GROUP BY sex;"
        ],
        "rule_sql": [
            "SELECT avg(weight), min(weight), Sex FROM people GROUP BY Sex;"
        ]
    },
    "5307": {
        "db_id": "manufactory_1",
        "question": "What is the total revenue of companies started by founder?",
        "ground_truth": "SELECT sum(revenue) ,  founder FROM manufacturers GROUP BY founder",
        "amends": [
            "Do add `founder` to the SELECT list and include it in GROUP BY instead of omitting it and filtering by a specific founder value. Do change the table source from `companies` to `manufacturers` instead of using the wrong table. Do use `GROUP BY founder` instead of applying a WHERE filter for a specific founder, which allows aggregation across all founders rather than filtering to just one. Do remove the WHERE clause condition `founder = 'founder'` instead of keeping it, as the correct logic aggregates revenue by all founders rather than filtering to a specific one. The amended query now correctly aggregates revenue by founder across all manufacturers instead of summing revenue for a single founder from the wrong table.",
            "Do use lowercase `sum(revenue)` without an alias instead of `SUM(Revenue) AS TotalRevenue` to avoid unnecessary column aliasing. Do place `founder` after the aggregate function in the SELECT list instead of listing it first. Do use lowercase `founder` in both SELECT and GROUP BY clauses instead of mixed case `Founder` for consistency. Do use lowercase `manufacturers` in the FROM clause instead of `Manufacturers` to match the table naming convention. The amended query now correctly calculates total revenue grouped by founder while maintaining consistent lowercase syntax throughout.",
            "Do place the `founder` column after the aggregate function `SUM(revenue)` in the SELECT list instead of listing it first. Do maintain the same GROUP BY clause with `founder` to ensure proper aggregation grouping. The amended query now correctly positions the aggregate function first while preserving the same logical grouping and calculation behavior as the RIGHT_SQL."
        ],
        "rules": [
            "1) When answering about \"total revenue of companies started by founder\": make sure the output order: founder, total revenue. 2) When the question mentions \"companies\": \"companies\" actually means \"manufacturers\" in schema. 3) When the question asks for \"total revenue per founder\": organize results by founder and compute the sum of revenue per group. 4) When combining tables: use the manufacturers table as T1 instead of companies table. 5) When producing output: include founder in the output columns and group by founder instead of filtering by a specific founder value.",
            "1) When the question asks for total revenue grouped by founder: use lowercase \"sum(revenue)\" without an alias instead of \"SUM(Revenue) AS TotalRevenue\". 2) When ordering output columns: place \"founder\" after the aggregate function in the SELECT list instead of listing it first. 3) When referring to identifiers: use lowercase \"founder\" in both SELECT and GROUP BY clauses instead of mixed case \"Founder\" for consistency. 4) When referencing the table: use lowercase \"manufacturers\" in the FROM clause instead of \"Manufacturers\" to match the table naming convention.",
            "1) When answering about \"total revenue of companies started by founder\": make sure the output order: SUM(revenue) first, then founder. 2) When the question asks for \"total revenue per founder\": organize results by founder and compute SUM(revenue) per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(revenue) FROM companies WHERE founder = 'founder';",
            "SELECT Founder, SUM(Revenue) AS TotalRevenue FROM Manufacturers GROUP BY Founder;",
            "SELECT founder, SUM(revenue) FROM manufacturers GROUP BY founder",
            "SELECT SUM(revenue), founder FROM manufacturers GROUP BY founder"
        ],
        "rule_sql": [
            "SELECT SUM(revenue), founder FROM manufacturers GROUP BY founder"
        ]
    },
    "3037": {
        "db_id": "loan_1",
        "question": "What are the names of customers who have both savings and checking accounts?",
        "ground_truth": "SELECT cust_name FROM customer WHERE acc_type  =  'saving' INTERSECT SELECT cust_name FROM customer WHERE acc_type  =  'checking'",
        "amends": [
            "Do use `INTERSECT` to find customers with both account types instead of joining the same table twice. Do query from `customer` table instead of `customers` and `accounts` tables. Do use `cust_name` column instead of `c.name`. Do filter for `acc_type = 'saving'` in the first branch instead of `a1.account_type = 'savings'`. Do filter for `acc_type = 'checking'` in the second branch instead of `a2.account_type = 'checking'`. Do remove the JOIN conditions and table aliases entirely instead of maintaining complex self-joins. The amended query now correctly identifies customers who have both saving and checking accounts using set intersection logic."
        ],
        "rules": [
            "1) When answering about customers with both savings and checking accounts: use INTERSECT logic instead of joining the same table twice. 2) When querying customer information: use the exact table name \"customer\" instead of \"customers\". 3) When selecting customer names: use the exact column name \"cust_name\" instead of \"c.name\". 4) When filtering for savings accounts: use the exact condition \"acc_type = 'saving'\" with the literal 'saving'. 5) When filtering for checking accounts: use the exact condition \"acc_type = 'checking'\" with the literal 'checking'. 6) When combining results from multiple account types: remove JOIN conditions and table aliases entirely and use set intersection logic."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name \nFROM customers c\nJOIN accounts a1 ON c.customer_id = a1.customer_id\nJOIN accounts a2 ON c.customer_id = a2.customer_id\nWHERE a1.account_type = 'savings' AND a2.account_type = 'checking'",
            "SELECT cust_name FROM customer WHERE acc_type = 's' INTERSECT SELECT cust_name FROM customer WHERE acc_type = 'c'"
        ],
        "rule_sql": [
            "SELECT cust_name FROM customer WHERE acc_type = 'saving'\nINTERSECT\nSELECT cust_name FROM customer WHERE acc_type = 'checking'"
        ]
    },
    "5633": {
        "db_id": "railway",
        "question": "List the builders of railways in ascending alphabetical order.",
        "ground_truth": "SELECT Builder FROM railway ORDER BY Builder ASC",
        "amends": [
            "Do reference the table as `railway` instead of `railways` and use the column name `Builder` instead of `builder` to match the correct schema. Do change the sort direction to `ASC` instead of `DESC` to produce ascending rather than descending order. The amended query now correctly selects from the proper table with appropriate column casing and sorting direction to match the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"railways\": \"railways\" actually means \"railway\" in schema. 2) When the question mentions \"builders\": \"builders\" actually means \"Builder\" in schema. 3) When the question asks for ascending alphabetical order: sort rows by \"Builder\" in ascending order (A to Z)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT builder FROM railways ORDER BY builder DESC;",
            "SELECT Builder FROM railway ORDER BY Builder ASC;"
        ],
        "rule_sql": [
            "SELECT Builder FROM railway ORDER BY Builder ASC;"
        ]
    },
    "6943": {
        "db_id": "tracking_orders",
        "question": "List the names of customers who have once canceled the purchase of the product \"food\" (the item status is \"Cancel\").",
        "ground_truth": "SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 JOIN order_items AS T3 JOIN products AS T4 ON T1.customer_id = T2.customer_id AND T2.order_id = T3.order_id AND T3.product_id = T4.product_id WHERE T3.order_item_status = \"Cancel\" AND T4.product_name = \"food\" GROUP BY T1.customer_id HAVING count(*)  >=  1",
        "amends": [
            "Do add tables `orders AS T2`, `order_items AS T3`, and `products AS T4` with explicit joins instead of querying only the `customers` table. Do change the join structure to use `JOIN` with multiple `ON` predicates connecting `T1.customer_id = T2.customer_id`, `T2.order_id = T3.order_id`, and `T3.product_id = T4.product_id` instead of no joins. Do change the WHERE filter to use `T3.order_item_status = \"Cancel\"` and `T4.product_name = \"food\"` instead of `product = 'food' AND status = 'Cancel'`. Do add `GROUP BY T1.customer_id` and `HAVING count(*) >= 1` instead of no grouping or aggregation. Do qualify the column as `T1.customer_name` instead of just `customer_name`. The amended query now correctly joins multiple tables to find customers with canceled food orders and ensures they have at least one matching order item."
        ],
        "rules": [
            "1) When answering about customers who canceled food purchases: join tables Customers as T1, orders as T2, order_items as T3, and products as T4 using the exact key equalities T1.customer_id = T2.customer_id, T2.order_id = T3.order_id, and T3.product_id = T4.product_id. 2) When filtering for canceled food orders: use T3.order_item_status = \"Cancel\" and T4.product_name = \"food\" as exact literal matches. 3) When grouping by customer: use T1.customer_id as the grouping key and ensure at least one matching record with count(*) >= 1. 4) When selecting customer names: use T1.customer_name as the output column with the exact table alias. 5) When combining tables for this query: perform inner matches only using the specified key equalities to keep only matching pairs across all four tables."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT customer_name FROM customers WHERE product = 'food' AND status = 'Cancel';",
            "SELECT T1.customer_name\nFROM Customers AS T1\nJOIN Orders AS T2 ON T1.customer_id = T2.customer_id\nJOIN Order_Items AS T3 ON T2.order_id = T3.order_id\nJOIN Products AS T4 ON T3.product_id = T4.product_id\nWHERE T3.order_item_status = 'Cancel' AND T4.product_name = 'food'\nGROUP BY T1.customer_id\nHAVING COUNT(*) >= 1"
        ],
        "rule_sql": [
            "SELECT T1.customer_name\nFROM Customers AS T1\nINNER JOIN Orders AS T2 ON T1.customer_id = T2.customer_id\nINNER JOIN Order_Items AS T3 ON T2.order_id = T3.order_id\nINNER JOIN Products AS T4 ON T3.product_id = T4.product_id\nWHERE T3.order_item_status = 'Cancel'\nAND T4.product_name = 'food'\nGROUP BY T1.customer_id\nHAVING COUNT(*) >= 1"
        ]
    },
    "4753": {
        "db_id": "department_store",
        "question": "Find the ids of all distinct customers who made order after some orders that were Cancelled.",
        "ground_truth": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  \"Cancelled\")",
        "amends": [
            "Do reference table `Customer_Orders` instead of `orders` in both the main query and subquery. Do filter on column `order_status_code` with value `\"Cancelled\"` instead of `status` with value `'Cancelled'`. Do use `MIN(order_date)` instead of `MAX(order_date)` in the subquery to compare against the earliest cancelled order date rather than the most recent. The amended query now correctly identifies customers with orders placed after the first cancelled order, matching the intended logic."
        ],
        "rules": [
            "1) When the question refers to \"orders\": use table \"Customer_Orders\" instead of \"orders\". 2) When filtering for \"Cancelled\" orders: use column \"order_status_code\" with exact value \"Cancelled\" (with double quotes as shown in schema). 3) When finding orders after cancelled orders: use MIN(order_date) to get the earliest cancelled order date rather than MAX(order_date). 4) When answering about \"distinct customers who made order after some orders that were Cancelled\": select distinct customer_id from Customer_Orders where order_date > (SELECT MIN(order_date) FROM Customer_Orders WHERE order_status_code = \"Cancelled\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT customer_id \nFROM orders \nWHERE order_date > (SELECT MAX(order_date) FROM orders WHERE status = 'Cancelled')",
            "SELECT DISTINCT co.customer_id\nFROM Customer_Orders co\nWHERE co.order_date > (\n    SELECT MIN(order_date)\n    FROM Customer_Orders\n    WHERE order_status_code = 'Cancelled'\n)"
        ],
        "rule_sql": [
            "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date > (SELECT MIN(order_date) FROM Customer_Orders WHERE order_status_code = \"Cancelled\")"
        ]
    },
    "6513": {
        "db_id": "scientist_1",
        "question": "List all the scientists' names, their projects' names, and the hours worked by that scientist on each project, in alphabetical order of project name, and then scientist name.",
        "ground_truth": "SELECT T1.Name ,  T3.Name ,  T3.Hours FROM Scientists AS T1 JOIN AssignedTo AS T2 ON T1.SSN = T2.Scientist JOIN Projects AS T3 ON T2.Project = T3.Code ORDER BY T3.Name ,  T1.Name",
        "amends": [
            "Do reference `T1.Name` and `T3.Name` instead of `s.name` and `p.name`, and `T3.Hours` instead of `w.hours`. Do join `Scientists AS T1` to `AssignedTo AS T2` on `T1.SSN = T2.Scientist` instead of joining `scientists s` directly to `projects p` on `s.id = p.id`. Do then join `Projects AS T3` on `T2.Project = T3.Code` instead of joining `work w` on `s.id = w.scientist_id`. Do order by `T3.Name, T1.Name` instead of `s.name, p.name`. The amended query now correctly models the relationship between scientists and projects through the assignment bridge table with proper foreign key relationships."
        ],
        "rules": [
            "1) When answering about scientists and their projects: combine Scientists table as T1 with AssignedTo table as T2 using T1.SSN = T2.Scientist, then combine with Projects table as T3 using T2.Project = T3.Code. 2) When listing output columns: include T1.Name for scientist names, T3.Name for project names, and T3.Hours for hours worked. 3) When ordering results alphabetically: sort by T3.Name first (project name), then by T1.Name (scientist name)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.name, p.name, w.hours FROM scientists s JOIN projects p ON s.id = p.id JOIN work w ON s.id = w.scientist_id ORDER BY s.name, p.name;",
            "SELECT T1.Name, T3.Name, T3.Hours\nFROM Scientists AS T1\nJOIN AssignedTo AS T2 ON T1.SSN = T2.Scientist\nJOIN Projects AS T3 ON T2.Project = T3.Code\nORDER BY T3.Name, T1.Name;"
        ],
        "rule_sql": [
            "SELECT T1.Name, T3.Name, T3.Hours\nFROM Scientists AS T1\nJOIN AssignedTo AS T2 ON T1.SSN = T2.Scientist\nJOIN Projects AS T3 ON T2.Project = T3.Code\nORDER BY T3.Name, T1.Name;"
        ]
    },
    "2561": {
        "db_id": "county_public_safety",
        "question": "How many counties correspond to each police force?",
        "ground_truth": "SELECT Police_force ,  COUNT(*) FROM county_public_safety GROUP BY Police_force",
        "amends": [
            "Do reference the correct table name `county_public_safety` instead of `counties` and use the proper column case `Police_force` instead of `police_force` in both the SELECT list and GROUP BY clause, while maintaining the same aggregate function `COUNT(*)` to ensure accurate counting of records grouped by police force. The amended query now correctly queries the appropriate data source with proper column naming, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"counties per police force\": make sure the output order: Police_force then count. 2) When the question mentions \"counties\": \"counties\" actually means \"records in county_public_safety table\". 3) When the question asks for \"count of counties per police force\": compute the number of rows using the exact column token \"Police_force\" for grouping. 4) When choosing identifier delimiters: use the exact column name \"Police_force\" without quotes as shown in the schema. 5) When handling table references: use the exact table name \"county_public_safety\" instead of \"counties\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT police_force, COUNT(*) FROM counties GROUP BY police_force;",
            "SELECT Police_force, COUNT(*) FROM county_public_safety GROUP BY Police_force;"
        ],
        "rule_sql": [
            "SELECT Police_force, COUNT(*) AS count FROM county_public_safety GROUP BY Police_force ORDER BY Police_force, count;"
        ]
    },
    "846": {
        "db_id": "chinook_1",
        "question": "Find the full name of the customer with the email \"luisg@embraer.com.br\".",
        "ground_truth": "SELECT FirstName ,  LastName FROM CUSTOMER WHERE Email  =  \"luisg@embraer.com.br\"",
        "amends": [
            "Do select `FirstName` and `LastName` columns instead of only `first_name`. Do reference table `CUSTOMER` instead of `customers`. Do use double quotes `\"` around the email value instead of single quotes. The amended query now correctly retrieves both first and last name columns from the proper table with appropriate string quoting."
        ],
        "rules": [
            "1) When the question asks for \"full name\" of a customer: select both \"FirstName\" and \"LastName\" columns from the \"CUSTOMER\" table. 2) When filtering by email address: use double quotes around the exact literal value \"luisg@embraer.com.br\" for the email condition. 3) When referencing table names: use the exact table name \"CUSTOMER\" as shown in the schema, not alternative forms like \"customers\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM customers WHERE email = 'luisg@embraer.com.br';",
            "SELECT FirstName, LastName FROM Customer WHERE Email = \"luisg@embraer.com.br\""
        ],
        "rule_sql": [
            "SELECT FirstName, LastName FROM Customer WHERE Email = \"luisg@embraer.com.br\""
        ]
    },
    "5352": {
        "db_id": "tracking_software_problems",
        "question": "What is the id of the problem log that is created most recently?",
        "ground_truth": "SELECT problem_log_id FROM problem_log ORDER BY log_entry_date DESC LIMIT 1",
        "amends": [
            "Do select `problem_log_id` instead of `id` in the SELECT list. Do order by `log_entry_date` instead of `created_at` in the ORDER BY clause. Do use `DESC` ordering instead of `ASC` ordering. The amended query now correctly retrieves the most recent problem log entry by date instead of the oldest one."
        ],
        "rules": [
            "1) When the question asks for the \"id\" of a problem log: use the exact column token \"problem_log_id\" instead of \"id\". 2) When ordering by creation date to find the most recent entry: use the exact column token \"log_entry_date\" with DESC ordering instead of ASC ordering. 3) When retrieving the most recently created problem log: select only the first row after ordering by \"log_entry_date\" in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM problem_log ORDER BY created_at ASC LIMIT 1;",
            "SELECT problem_log_id FROM Problem_Log ORDER BY log_entry_date DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT problem_log_id FROM Problem_Log ORDER BY log_entry_date DESC LIMIT 1;"
        ]
    },
    "2641": {
        "db_id": "inn_1",
        "question": "What are the names of rooms whose reservation frequency exceeds 60 times?",
        "ground_truth": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room HAVING count(*)  >  60",
        "amends": [
            "Do use `JOIN` between `Reservations` and `Rooms` tables instead of querying only the `rooms` table. Do reference `T2.roomName` in the SELECT list instead of `room_name`. Do add `GROUP BY T1.Room` instead of omitting grouping. Do move the count filter to `HAVING count(*) > 60` instead of using `WHERE reservation_count > 60`. Do use the correct table aliases `T1` and `T2` with proper join condition `ON T1.Room = T2.RoomId` instead of the single table approach. The amended query now correctly calculates reservation counts per room and filters rooms with more than 60 reservations, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"names of rooms whose reservation frequency exceeds 60 times\": make sure the output order: T2.roomName\n2) When combining T1 and T2 for shared entities: link rows where T1.Room = T2.RoomId; keep only matching pairs (inner match).\n3) When the question asks for \"count of reservations per room\": compute the number of rows using T1.Room as the grouping key and count all matching rows per group.\n4) When filtering by reservation frequency exceeding 60: apply the count filter after grouping using count(*) > 60 instead of before grouping.\n5) When the question mentions \"reservation frequency\": this actually means the count of reservations in the Reservations table grouped by room."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT room_name FROM rooms WHERE reservation_count > 60;",
            "SELECT T2.roomName\nFROM Reservations T1\nJOIN Rooms T2 ON T1.Room = T2.RoomId\nGROUP BY T1.Room\nHAVING COUNT(*) > 60"
        ],
        "rule_sql": [
            "SELECT T2.roomName\nFROM Reservations T1\nINNER JOIN Rooms T2 ON T1.Room = T2.RoomId\nGROUP BY T1.Room\nHAVING COUNT(*) > 60\nORDER BY T2.roomName"
        ]
    },
    "6188": {
        "db_id": "music_4",
        "question": "Return the song in the volume that has spent the most weeks on top?",
        "ground_truth": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1",
        "amends": [
            "Do reference column `Song` instead of `song_name` and table `volume` instead of `songs`. Do reference column `Weeks_on_Top` instead of `weeks_on_top` in the ORDER BY clause. The amended query now correctly references the appropriate column and table names to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"song in the volume\": use table \"volume\" and column \"Song\" to identify songs. 2) When the question asks about \"weeks on top\": use column \"Weeks_on_Top\" to determine the number of weeks a song spent at the top position. 3) When the question asks for the song with \"the most weeks on top\": rank songs by \"Weeks_on_Top\" in descending order and take the first row. 4) When producing output: return only the \"Song\" column value for the top-ranked song."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT song_name FROM songs ORDER BY weeks_on_top DESC LIMIT 1;",
            "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1;"
        ]
    },
    "6488": {
        "db_id": "scientist_1",
        "question": "What is the sum of hours for projects that scientists with the name Michael Rogers or Carol Smith are assigned to?",
        "ground_truth": "SELECT sum(T2.hours) FROM assignedto AS T1 JOIN projects AS T2 ON T1.project  =  T2.code JOIN scientists AS T3 ON T1.scientist  =  T3.SSN WHERE T3.name  =  'Michael Rogers' OR T3.name  =  'Carol Smith'",
        "amends": [
            "Do join `assignedto AS T1` with `projects AS T2` on `T1.project = T2.code` and `scientists AS T3` on `T1.scientist = T3.SSN` instead of querying only the `assignments` table. Do filter on `T3.name = 'Michael Rogers' OR T3.name = 'Carol Smith'` in the main query instead of using a subquery. Do select `sum(T2.hours)` from the joined `projects` table instead of `SUM(hours)` from the `assignments` table. The amended query now correctly aggregates hours from projects that the specified scientists are assigned to, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When combining tables for scientists assigned to projects: link assignedto as T1 with projects as T2 where T1.project = T2.code, and link T1 with scientists as T3 where T1.scientist = T3.SSN, keeping only matching pairs (inner match). 2) When filtering for scientists named Michael Rogers or Carol Smith: apply the condition T3.name = 'Michael Rogers' OR T3.name = 'Carol Smith' exactly as specified. 3) When calculating the sum of hours for projects: compute sum(T2.hours) from the projects table instead of hours from assignments. 4) When the question asks about hours for projects that scientists are assigned to: ensure the output includes only the sum of hours from projects table where the specified scientists are assigned."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(hours) FROM assignments WHERE scientist_id IN (SELECT id FROM scientists WHERE name = 'Michael Rogers' OR name = 'Carol Smith')",
            "SELECT SUM(T2.Hours) \nFROM AssignedTo AS T1\nJOIN Projects AS T2 ON T1.Project = T2.Code\nJOIN Scientists AS T3 ON T1.Scientist = T3.SSN\nWHERE T3.Name = 'Michael Rogers' OR T3.Name = 'Carol Smith'"
        ],
        "rule_sql": [
            "SELECT SUM(T2.Hours) \nFROM AssignedTo T1 \nINNER JOIN Projects T2 ON T1.Project = T2.Code \nINNER JOIN Scientists T3 ON T1.Scientist = T3.SSN \nWHERE T3.Name = 'Michael Rogers' OR T3.Name = 'Carol Smith'"
        ]
    },
    "2494": {
        "db_id": "movie_1",
        "question": "How many movie reviews does each director get?",
        "ground_truth": "SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director",
        "amends": [
            "Do add `Rating` table with `JOIN` on `T1.mID = T2.mID` instead of querying only the `movies` table. Do specify `T1.director` with table alias instead of just `director` in both SELECT and GROUP BY clauses. Do move the count aggregation to the first position in the SELECT list instead of second position. Do include the join condition to connect movies with their ratings instead of counting all movies regardless of rating status. The amended query now correctly counts only movies that have ratings while preserving the director grouping structure."
        ],
        "rules": [
            "1) When answering about \"movie reviews per director\": make sure the output order: count first, then director. 2) When combining Movie table (T1) and Rating table (T2): link rows where T1.mID = T2.mID exactly and keep only matching pairs (inner match). 3) When counting movie reviews: compute the number of rows using the canonical key T1.mID. 4) When grouping by director: organize results by T1.director and compute count per group. 5) When referring to director column: use T1.director with table alias instead of just director."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT director, COUNT(*) FROM movies GROUP BY director;",
            "SELECT COUNT(Rating.mID) AS review_count, Movie.director\nFROM Movie\nJOIN Rating ON Movie.mID = Rating.mID\nGROUP BY Movie.director"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.mID) AS review_count, T1.director\nFROM Movie T1\nINNER JOIN Rating T2 ON T1.mID = T2.mID\nGROUP BY T1.director\nORDER BY review_count DESC, T1.director;"
        ]
    },
    "5354": {
        "db_id": "tracking_software_problems",
        "question": "What is the oldest log id and its corresponding problem id?",
        "ground_truth": "SELECT problem_log_id ,  problem_id FROM problem_log ORDER BY log_entry_date LIMIT 1",
        "amends": [
            "Do select `problem_log_id` and `problem_id` instead of `MIN(log_id)` and `problem_id`. Do use `FROM problem_log` instead of `FROM logs`. Do order by `log_entry_date` instead of `log_id DESC`. Do remove the `MIN` aggregate function instead of keeping it. The amended query now correctly retrieves the first problem log entry by date rather than finding the minimum log ID with incorrect table and column references."
        ],
        "rules": [
            "1) When answering about \"oldest log id and its corresponding problem id\": make sure the output order: problem_log_id, problem_id 2) When the question mentions \"oldest\": use the log_entry_date column to determine chronological order instead of log_id 3) When retrieving the oldest entry: order rows by log_entry_date in ascending order and keep the first row 4) When selecting from the problem log table: use FROM problem_log instead of FROM logs 5) When selecting columns: use problem_log_id and problem_id instead of MIN(log_id) and problem_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(log_id), problem_id FROM logs ORDER BY log_id DESC LIMIT 1;",
            "SELECT problem_log_id, problem_id FROM Problem_Log ORDER BY log_entry_date ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT problem_log_id, problem_id FROM Problem_Log ORDER BY log_entry_date ASC LIMIT 1;"
        ]
    },
    "897": {
        "db_id": "insurance_fnol",
        "question": "What are all the customer phone numbers under the most popular policy type?",
        "ground_truth": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)",
        "amends": [
            "Do reference `customer_phone` from the `available_policies` table instead of `phone_number` from `customers`. Do use `policy_type_code` instead of `policy_type` in both the main query filter and subquery. Do query from `available_policies` instead of `customers` as the data source. Do ensure the subquery selects from `available_policies` instead of a separate `policies` table. The amended query now correctly identifies the most frequent policy type from the available policies table and returns corresponding customer phone numbers, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"customer phone numbers\": use the exact column token \"customer_phone\" from the \"available_policies\" table. 2) When the question mentions \"policy type\": \"policy type\" actually means \"policy_type_code\" in the schema. 3) When the question asks for \"most popular policy type\": find the policy_type_code with the highest count of occurrences in the available_policies table. 4) When filtering for the most popular policy type: use a subquery that groups by policy_type_code, orders by count descending, and takes the first result. 5) When querying from the available_policies table: use this table as the data source instead of a separate policies table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT phone_number FROM customers WHERE policy_type = (SELECT policy_type FROM policies GROUP BY policy_type ORDER BY COUNT(*) DESC LIMIT 1);",
            "SELECT ap.Customer_Phone\nFROM Available_Policies ap\nWHERE ap.policy_type_code = (\n    SELECT policy_type_code\n    FROM Available_Policies\n    GROUP BY policy_type_code\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)"
        ],
        "rule_sql": [
            "SELECT customer_phone \nFROM available_policies \nWHERE policy_type_code = (\n    SELECT policy_type_code \n    FROM available_policies \n    GROUP BY policy_type_code \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n)"
        ]
    },
    "3221": {
        "db_id": "college_1",
        "question": "Find the max, average, and minimum gpa of all students in each department.",
        "ground_truth": "SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code",
        "amends": [
            "Do use column name `stu_gpa` instead of `gpa` in all aggregate functions. Do use table name `student` instead of `students` as the data source. Do include `dept_code` in the SELECT list instead of `department`. Do group by `dept_code` instead of `department`. The amended query now correctly aggregates student GPA statistics by department code using the proper column and table names from the schema.",
            "Do place the `dept_code` column at the end of the SELECT list instead of at the beginning, and do remove the aliases `max_gpa`, `avg_gpa`, and `min_gpa` instead of keeping them, while maintaining the same aggregate functions and GROUP BY logic. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"max, average, and minimum gpa of all students in each department\": make sure the output order: dept_code, MAX(stu_gpa), AVG(stu_gpa), MIN(stu_gpa). 2) When the question mentions \"gpa\": \"gpa\" actually means \"stu_gpa in schema\". 3) When the question mentions \"department\": \"department\" actually means \"dept_code in schema\". 4) When the question says \"per department\"/\"by department\": organize results by dept_code and compute requested aggregates per group. 5) When the question asks for statistics about students: use table student as the data source instead of students.",
            "1) When computing aggregate statistics per department: organize results by the exact token \"dept_code\" and compute MAX, AVG, and MIN of \"stu_gpa\" for each group. 2) When producing output columns: place the aggregate columns first in the order MAX(\"stu_gpa\"), AVG(\"stu_gpa\"), MIN(\"stu_gpa\"), followed by the grouping column \"dept_code\" at the end. 3) When naming output columns: do not assign aliases to the aggregate functions, output them without explicit column names."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department, MAX(gpa), AVG(gpa), MIN(gpa) FROM students GROUP BY department",
            "SELECT dept_code, MAX(stu_gpa) AS max_gpa, AVG(stu_gpa) AS avg_gpa, MIN(stu_gpa) AS min_gpa FROM student GROUP BY dept_code;",
            "SELECT MAX(stu_gpa), AVG(stu_gpa), MIN(stu_gpa), dept_code FROM student GROUP BY dept_code"
        ],
        "rule_sql": [
            "SELECT MAX(STU_GPA), AVG(STU_GPA), MIN(STU_GPA), DEPT_CODE FROM STUDENT GROUP BY DEPT_CODE"
        ]
    },
    "4145": {
        "db_id": "film_rank",
        "question": "What are the names of studios that have made two or more films?",
        "ground_truth": "SELECT Studio FROM film GROUP BY Studio HAVING COUNT(*)  >=  2",
        "amends": [
            "Do select `Studio` instead of `name` and use `GROUP BY Studio` instead of omitting grouping. Do move the count condition to `HAVING COUNT(*) >= 2` instead of placing it in `WHERE COUNT(films) >= 2` which is invalid syntax. Do use `COUNT(*)` instead of `COUNT(films)` to count all rows rather than non-null film values. The amended query now correctly groups by studio and filters for those with at least two films using proper HAVING clause syntax."
        ],
        "rules": [
            "1) When the question asks for \"names of studios\": use the exact column token \"Studio\" from the film table. 2) When counting films per studio: group results by \"Studio\" and count all rows using COUNT(*). 3) When filtering for studios with two or more films: apply the condition COUNT(*) >= 2 in a HAVING clause after grouping, not in a WHERE clause."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM studios WHERE COUNT(films) >= 2;",
            "SELECT Studio FROM film GROUP BY Studio HAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT Studio FROM film GROUP BY Studio HAVING COUNT(*) >= 2"
        ]
    },
    "5833": {
        "db_id": "workshop_paper",
        "question": "For each submission, find its author and acceptance result.",
        "ground_truth": "SELECT T2.Author ,  T1.Result FROM acceptance AS T1 JOIN submission AS T2 ON T1.Submission_ID  =  T2.Submission_ID",
        "amends": [
            "Do reference `submission` and `acceptance` tables instead of `submissions` and `users` tables. Do use `T2.Author` and `T1.Result` columns instead of `submission_id`, `author_name`, and `result`. Do perform an `INNER JOIN` on `T1.Submission_ID = T2.Submission_ID` instead of joining `submissions.user_id = users.id`. Do remove the `WHERE result = 'accepted'` filter instead of keeping it, as the result filtering is now handled by joining with the acceptance table. The amended query now correctly retrieves acceptance results by joining the appropriate tables without needing explicit filtering."
        ],
        "rules": [
            "1) When answering about \"submission author and acceptance result\": make sure the output order: T1.Submission_ID, T2.Author, T1.Result\n2) When combining submission and acceptance tables: link rows where T1.Submission_ID = T2.Submission_ID and keep only matching pairs (inner match)\n3) When the question asks for all acceptance results: do not filter by result value, include all results from the acceptance table"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT submission_id, author_name, result FROM submissions JOIN users ON submissions.user_id = users.id WHERE result = 'accepted';",
            "SELECT T2.Author, T1.Result FROM Acceptance T1 INNER JOIN submission T2 ON T1.Submission_ID = T2.Submission_ID"
        ],
        "rule_sql": [
            "SELECT T1.Submission_ID, T2.Author, T1.Result\nFROM Acceptance T1\nINNER JOIN submission T2 ON T1.Submission_ID = T2.Submission_ID\nORDER BY T1.Submission_ID"
        ]
    },
    "3522": {
        "db_id": "hr_1",
        "question": "What are the department names, cities, and state provinces for each department?",
        "ground_truth": "SELECT T1.department_name ,  T2.city ,  T2.state_province FROM departments AS T1 JOIN locations AS T2 ON T2.location_id  =  T1.location_id",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of omitting them. Do reference columns with table aliases as `T1.department_name`, `T2.city`, and `T2.state_province` instead of bare column names. Do correct the JOIN condition to `T2.location_id = T1.location_id` instead of the incorrect `departments.location_id = locations.location_id WHERE departments.department_id = locations.department_id` which mistakenly mixed JOIN condition with WHERE filter. Do remove the erroneous WHERE clause filtering on `department_id` instead of keeping it, as location matching should only use `location_id`. The amended query now correctly joins departments to locations using location_id only and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When joining departments and locations tables: use explicit aliases T1 for departments and T2 for locations instead of omitting table aliases. 2) When referencing columns from joined tables: use qualified column names with table aliases as T1.department_name, T2.city, and T2.state_province instead of bare column names. 3) When combining departments and locations tables: link rows where T2.location_id = T1.location_id using exact key equality and keep only matching pairs (inner match). 4) When the question asks for department information with location details: do not include WHERE clause filtering on department_id as location matching should only use location_id."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department_name, city, state_province FROM departments JOIN locations ON departments.location_id = locations.location_id WHERE departments.department_id = locations.department_id;",
            "SELECT T1.department_name, T2.city, T2.state_province FROM departments T1 JOIN locations T2 ON T2.location_id = T1.location_id"
        ],
        "rule_sql": [
            "SELECT T1.department_name, T2.city, T2.state_province FROM departments T1 JOIN locations T2 ON T2.location_id = T1.location_id"
        ]
    },
    "6778": {
        "db_id": "activity_1",
        "question": "What are the names of the activities Mark Giuliano is involved in",
        "ground_truth": "SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  \"Mark\" AND T1.lname  =  \"Giuliano\"",
        "amends": [
            "Do use `T3.activity_name` instead of `activity_name` for explicit table reference. Do add `Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID = T2.facID JOIN Activity AS T3 ON T3.actid = T2.actid` instead of querying `activities` table directly. Do change filter to `T1.fname = \"Mark\" AND T1.lname = \"Giuliano\"` instead of `person_name = 'Mark Giuliano'` to properly match first and last name separately. The amended query now correctly joins through the faculty participation relationship and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about activities a person is involved in: use Faculty as T1, Faculty_participates_in as T2, and Activity as T3 with joins T1.facID = T2.facID and T3.actid = T2.actid. 2) When the question mentions \"Mark Giuliano\": match using T1.fname = \"Mark\" AND T1.lname = \"Giuliano\" instead of a single person_name field. 3) When selecting activity names: use T3.activity_name as the output column with exact table reference. 4) When combining tables for faculty participation: perform inner matches using the exact key equalities T1.facID = T2.facID and T3.actid = T2.actid to link faculty to their activities."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT activity_name FROM activities WHERE person_name = 'Mark Giuliano'",
            "SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID JOIN Activity AS T3 ON T3.actid = T2.actid WHERE T1.Fname = 'Mark' AND T1.Lname = 'Giuliano'"
        ],
        "rule_sql": [
            "SELECT T3.activity_name \nFROM Faculty AS T1\nINNER JOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID\nINNER JOIN Activity AS T3 ON T3.actid = T2.actid\nWHERE T1.Fname = 'Mark' AND T1.Lname = 'Giuliano'"
        ]
    },
    "1881": {
        "db_id": "wrestler",
        "question": "How many different teams have had eliminated wrestlers?",
        "ground_truth": "SELECT COUNT (DISTINCT team) FROM elimination",
        "amends": [
            "Do select `COUNT(DISTINCT team)` instead of `COUNT(*)`. Do query from `elimination` table instead of `wrestlers` table. Do remove the `WHERE eliminated = 1` filter instead of keeping it. The amended query now correctly counts distinct teams from the elimination table rather than counting all eliminated wrestlers."
        ],
        "rules": [
            "1) When counting different teams from the elimination table: use COUNT(DISTINCT team) instead of COUNT(*) 2) When answering about eliminated wrestlers: query from the elimination table instead of the wrestlers table 3) When the question asks about eliminated wrestlers: do not apply a WHERE eliminated = 1 filter as the elimination table already contains only elimination records"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM wrestlers WHERE eliminated = 1;",
            "SELECT COUNT(DISTINCT Team) FROM Elimination"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Team) FROM Elimination;"
        ]
    },
    "1931": {
        "db_id": "cinema",
        "question": "Show all the locations where some cinemas were opened in both year 2010 and year 2011.",
        "ground_truth": "SELECT LOCATION FROM cinema WHERE openning_year  =  2010 INTERSECT SELECT LOCATION FROM cinema WHERE openning_year  =  2011",
        "amends": [
            "Do remove `DISTINCT` instead of keeping it, and change the table name from `cinemas` to `cinema` instead of using the plural form. Do use `INTERSECT` with two separate queries instead of `OR` in the `WHERE` clause, which changes the logic from finding locations that opened in either 2010 or 2011 to finding locations that opened in both years. Do change the column name from `year_opened` to `openning_year` instead of using the original column name, and do remove the space formatting differences in the equality operators. The amended query now correctly identifies cinema locations that were opened in both 2010 and 2011, matching the RIGHT_SQL's set intersection behavior."
        ],
        "rules": [
            "1) When the question asks for locations where cinemas were opened in both 2010 and 2011: use set intersection logic instead of OR conditions to ensure locations appear in both years. 2) When referring to the cinema table: use the exact table name \"cinema\" instead of the plural form \"cinemas\". 3) When referring to the opening year column: use the exact column name \"openning_year\" instead of \"year_opened\". 4) When checking for specific years: use exact numeric literals 2010 and 2011 without quotes or formatting changes. 5) When producing the final result: return only distinct locations without using the DISTINCT keyword since set intersection inherently removes duplicates."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT location FROM cinemas WHERE year_opened = 2010 OR year_opened = 2011;",
            "SELECT Location FROM cinema WHERE Openning_year = 2010 INTERSECT SELECT Location FROM cinema WHERE Openning_year = 2011"
        ],
        "rule_sql": [
            "SELECT cinema.Location \nFROM cinema \nWHERE cinema.Openning_year = 2010\nINTERSECT\nSELECT cinema.Location \nFROM cinema \nWHERE cinema.Openning_year = 2011"
        ]
    },
    "48": {
        "db_id": "farm",
        "question": "List the official names of cities that have not held any competition.",
        "ground_truth": "SELECT Official_Name FROM city WHERE City_ID NOT IN (SELECT Host_city_ID FROM farm_competition)",
        "amends": [
            "Do reference `Official_Name` instead of `city_name` in the SELECT list. Do query from `city` table instead of `cities` table. Do use `City_ID` instead of `city_id` in the WHERE clause. Do reference `Host_city_ID` instead of `city_id` in the subquery's SELECT list. Do query from `farm_competition` table instead of `competitions` table in the subquery. The amended query now correctly identifies cities that have not hosted farm competitions by using the appropriate table names and column references."
        ],
        "rules": [
            "1) When answering about \"official names of cities\": make sure the output column is \"Official_Name\" from table \"city\". 2) When the question mentions \"cities\": query from table \"city\" instead of \"cities\". 3) When identifying cities that have not held competitions: use \"City_ID\" from table \"city\" in the main query and \"Host_city_ID\" from table \"farm_competition\" in the subquery. 4) When checking for cities without competitions: use a NOT IN condition comparing \"City_ID\" from table \"city\" with \"Host_city_ID\" values from table \"farm_competition\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city_name FROM cities WHERE city_id NOT IN (SELECT city_id FROM competitions)",
            "SELECT Official_Name FROM city WHERE City_ID NOT IN (SELECT Host_city_ID FROM farm_competition)"
        ],
        "rule_sql": [
            "SELECT Official_Name FROM city WHERE City_ID NOT IN (SELECT Host_city_ID FROM farm_competition)"
        ]
    },
    "549": {
        "db_id": "store_1",
        "question": "List the top 5 genres by number of tracks. List genres name and total tracks.",
        "ground_truth": "SELECT T1.name ,  COUNT(*) FROM genres AS T1 JOIN tracks AS T2 ON T2.genre_id  =  T1.id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 5;",
        "amends": [
            "Do use `T1.name` instead of `g.Name` for the genre name column. Do use `COUNT(*)` instead of `COUNT(t.TrackId)` for counting tracks. Do use `JOIN` instead of `LEFT JOIN` for the table relationship. Do reference `T2.genre_id = T1.id` instead of `g.GenreId = t.GenreId` for the join condition, correcting the column references. Do group by `T1.id` instead of `g.GenreId` for proper aggregation. Do order by `count(*)` instead of `TotalTracks` for the sort criteria. The amended query now correctly uses proper column aliases and join conditions to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"top 5 genres by number of tracks\": make sure the output order: genre name first, then total tracks count. 2) When the question mentions \"genres name\": \"genres name\" actually means \"T1.name\" in schema. 3) When the question asks for \"number of tracks\": compute the count using COUNT(*) for all matching track rows. 4) When combining T1 (genres) and T2 (tracks) for shared entities: link rows where T2.genre_id = T1.id exactly as shown; keep only matching pairs (inner match). 5) When the question asks for \"top 5\" by track count: rank rows by count(*) in descending order and keep the first 5 rows. 6) When grouping by genre: organize results by T1.id and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT g.Name, COUNT(t.TrackId) as TotalTracks \nFROM genres g \nLEFT JOIN tracks t ON g.GenreId = t.GenreId \nGROUP BY g.GenreId \nORDER BY TotalTracks DESC \nLIMIT 5;",
            "SELECT g.name AS genre_name, COUNT(*) AS total_tracks\nFROM genres g\nJOIN tracks t ON t.genre_id = g.id\nGROUP BY g.id\nORDER BY total_tracks DESC\nLIMIT 5"
        ],
        "rule_sql": [
            "SELECT g.name AS genre_name, COUNT(*) AS total_tracks\nFROM genres g\nINNER JOIN tracks t ON t.genre_id = g.id\nGROUP BY g.id, g.name\nORDER BY total_tracks DESC\nLIMIT 5"
        ]
    },
    "3620": {
        "db_id": "music_1",
        "question": "What are the top 3 artists with the largest number of songs in the language Bangla?",
        "ground_truth": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  \"bangla\" GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3",
        "amends": [
            "Do join `artist AS T1` and `song AS T2` instead of querying only `songs` table. Do use `JOIN` with `T1.artist_name = T2.artist_name` instead of no join condition. Do filter on `T2.languages = \"bangla\"` instead of `language = 'Bangla'`. Do select only `T1.artist_name` instead of both `artist_name` and `COUNT(*)`. Do group by `T2.artist_name` instead of `artist_name`. Do order by `count(*) DESC` instead of `song_count DESC`. The amended query now correctly counts Bangla songs per artist by properly joining artist and song tables with accurate column references."
        ],
        "rules": [
            "1) When answering about \"top 3 artists with the largest number of songs in the language Bangla\": make sure the output order: T1.artist_name, count(*) as song_count. 2) When the question mentions \"Bangla\": \"Bangla\" actually means \"T2.languages = 'bangla'\" in schema. 3) When the question asks for \"top 3\" by song count: rank rows by count(*) in descending order and keep the first 3 rows. 4) When the question asks for \"count of songs per artist\": compute the number of rows using T2.artist_name as the grouping key. 5) When combining T1 (artist) and T2 (song) for shared entities: link rows where T1.artist_name = T2.artist_name exactly as shown in the amends; keep only matching pairs (inner match). 6) When producing output: select only T1.artist_name instead of both artist_name and COUNT(*). 7) When grouping: group by T2.artist_name instead of artist_name."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT artist_name, COUNT(*) as song_count \nFROM songs \nWHERE language = 'Bangla' \nGROUP BY artist_name \nORDER BY song_count DESC \nLIMIT 3;",
            "SELECT T1.artist_name\nFROM artist AS T1\nJOIN song AS T2 ON T1.artist_name = T2.artist_name\nWHERE T2.languages = 'bangla'\nGROUP BY T2.artist_name\nORDER BY COUNT(*) DESC\nLIMIT 3"
        ],
        "rule_sql": [
            "SELECT T1.artist_name, COUNT(*) as song_count\nFROM artist T1\nJOIN song T2 ON T1.artist_name = T2.artist_name\nWHERE T2.languages = 'bangla'\nGROUP BY T2.artist_name\nORDER BY song_count DESC\nLIMIT 3"
        ]
    },
    "1966": {
        "db_id": "products_for_hire",
        "question": "What are the start date and end date of the booking that has booked the product named 'Book collection A'?",
        "ground_truth": "SELECT T3.booking_start_date ,   T3.booking_end_date FROM Products_for_hire AS T1 JOIN products_booked AS T2 ON T1.product_id  =  T2.product_id JOIN bookings AS T3 ON T2.booking_id  =  T3.booking_id WHERE T1.product_name  =  'Book collection A'",
        "amends": [
            "Do add joins to `Products_for_hire` and `products_booked` tables instead of querying `bookings` directly. Do use `T3.booking_start_date` and `T3.booking_end_date` instead of `start_date` and `end_date` with proper table aliasing. Do join `Products_for_hire AS T1` to `products_booked AS T2` on `T1.product_id = T2.product_id` instead of missing these table relationships. Do join `products_booked AS T2` to `bookings AS T3` on `T2.booking_id = T3.booking_id` instead of omitting this connection. Do filter on `T1.product_name = 'Book collection A'` instead of filtering directly on the bookings table without proper joins. The amended query now correctly retrieves booking dates by following the proper table relationships through product and booking associations."
        ],
        "rules": [
            "1) When answering about booking dates for a specific product: make sure the output order: T3.booking_start_date, T3.booking_end_date. 2) When the question mentions \"product named 'Book collection A'\": \"product named 'Book collection A'\" actually means \"T1.product_name = 'Book collection A'\" in schema. 3) When combining Products_for_hire (T1) and products_booked (T2) for shared products: link rows where T1.product_id = T2.product_id exactly as shown; keep only matching pairs (inner match). 4) When combining products_booked (T2) and bookings (T3) for shared bookings: link rows where T2.booking_id = T3.booking_id exactly as shown; keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 6) When handling text literals: do not change case, spacing, or punctuation of 'Book collection A'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT start_date, end_date FROM bookings WHERE product_name = 'Book collection A';",
            "SELECT T3.booking_start_date, T3.booking_end_date\nFROM Products_for_Hire AS T1\nJOIN Products_Booked AS T2 ON T1.product_id = T2.product_id\nJOIN Bookings AS T3 ON T2.booking_id = T3.booking_id\nWHERE T1.product_name = 'Book collection A'"
        ],
        "rule_sql": [
            "SELECT T3.booking_start_date, T3.booking_end_date\nFROM Products_for_Hire T1\nINNER JOIN Products_Booked T2 ON T1.product_id = T2.product_id\nINNER JOIN Bookings T3 ON T2.booking_id = T3.booking_id\nWHERE T1.product_name = 'Book collection A'"
        ]
    },
    "75": {
        "db_id": "student_assessment",
        "question": "Find id of the candidate who most recently accessed the course?",
        "ground_truth": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1",
        "amends": [
            "Do select from `candidate_assessments` table instead of `course_access` table. Do order by `assessment_date DESC` instead of `access_date ASC`. The amended query now correctly retrieves data from the candidate assessments table with descending date ordering, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"most recently accessed the course\": use the \"candidate_assessments\" table instead of \"course_access\" table. 2) When ordering by date to find the most recent: order by \"assessment_date DESC\" instead of \"access_date ASC\" to get the latest date first. 3) When selecting the candidate identifier: use \"candidate_id\" from the \"candidate_assessments\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT candidate_id FROM course_access ORDER BY access_date ASC LIMIT 1;",
            "SELECT candidate_id \nFROM Candidate_Assessments \nORDER BY assessment_date DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT candidate_id FROM Candidate_Assessments ORDER BY assessment_date DESC LIMIT 1;"
        ]
    },
    "6224": {
        "db_id": "ship_1",
        "question": "How many captains with younger than 50 are in each rank?",
        "ground_truth": "SELECT count(*) ,  rank FROM captain WHERE age  <  50 GROUP BY rank",
        "amends": [
            "Do use the table name `captain` instead of `captains`. Do place the `rank` column after the aggregate function instead of before it in the SELECT list. Do maintain the same `COUNT(*)` aggregate, `WHERE age < 50` filter, and `GROUP BY rank` clause structure. The amended query now correctly references the intended table and presents results with the count first followed by rank grouping."
        ],
        "rules": [
            "1) When the question mentions \"captains\": use the exact table name \"captain\" instead of \"captains\". 2) When answering about \"How many captains with younger than 50 are in each rank\": make sure the output order: count first followed by rank. 3) When the question asks for \"count of captains\": compute the number of rows using COUNT(*) with the condition \"age < 50\". 4) When the question says \"in each rank\": organize results by the \"rank\" column and compute counts per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT rank, COUNT(*) FROM captains WHERE age < 50 GROUP BY rank;",
            "SELECT COUNT(*), rank FROM captain WHERE age < 50 GROUP BY rank"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS count, Rank FROM captain WHERE age < 50 GROUP BY Rank ORDER BY count DESC, Rank;"
        ]
    },
    "90": {
        "db_id": "student_assessment",
        "question": "What are the ids of the students who registered for course 301 most recently?",
        "ground_truth": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1",
        "amends": [
            "Do query the `student_course_attendance` table instead of the `registrations` table. Do use `date_of_attendance DESC` for ordering instead of `registration_date ASC`. The amended query now correctly retrieves attendance data from the appropriate table with the proper date ordering to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks about student registrations for courses: use the \"student_course_attendance\" table instead of \"registrations\" table. 2) When ordering by date to find most recent records: use \"date_of_attendance DESC\" ordering instead of \"registration_date ASC\". 3) When filtering for a specific course: use \"course_id = 301\" condition exactly as specified."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_id FROM registrations WHERE course_id = 301 ORDER BY registration_date ASC LIMIT 1;",
            "SELECT student_id FROM Student_Course_Attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT student_id FROM Student_Course_Attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC;"
        ]
    },
    "1796": {
        "db_id": "small_bank_1",
        "question": "List all customers\u2019 names in the alphabetical order.",
        "ground_truth": "SELECT name FROM accounts ORDER BY name",
        "amends": [
            "Do reference table `accounts` instead of `customers` in the FROM clause. Do use ascending `ORDER BY name` instead of descending `ORDER BY name DESC`. Do remove the DESC modifier instead of keeping it."
        ],
        "rules": [
            "1) When the question asks for customer names: use the \"accounts\" table instead of \"customers\" table. 2) When ordering names alphabetically: use ascending order (A-Z) instead of descending order. 3) When selecting customer names: use the \"name\" column from the \"accounts\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM customers ORDER BY name DESC;",
            "SELECT name FROM ACCOUNTS ORDER BY name ASC"
        ],
        "rule_sql": [
            "SELECT name FROM ACCOUNTS ORDER BY name ASC;"
        ]
    },
    "1911": {
        "db_id": "protein_institute",
        "question": "Show the name, street address, and number of floors for all buildings ordered by the number of floors.",
        "ground_truth": "SELECT name ,  street_address ,  floors FROM building ORDER BY floors",
        "amends": [
            "Do reference table `building` instead of `buildings` in the FROM clause. Do order by `floors` instead of `name` in the ORDER BY clause. The amended query now correctly references the intended table and sorts results by floor count rather than alphabetically by name."
        ],
        "rules": [
            "1) When the question asks for buildings information: use table \"building\" instead of \"buildings\". 2) When ordering results by number of floors: order by column \"floors\" instead of \"name\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, street_address, floors FROM buildings ORDER BY name;",
            "SELECT Name, Street_address, Floors FROM building ORDER BY Floors;"
        ],
        "rule_sql": [
            "SELECT Name, Street_address, Floors FROM building ORDER BY Floors;"
        ]
    },
    "1038": {
        "db_id": "phone_1",
        "question": "List the hardware model name for the phones that have screen mode type \"Text\" or RAM size greater than 32.",
        "ground_truth": "SELECT T2.Hardware_Model_name FROM chip_model AS T1 JOIN phone AS T2 ON T1.Model_name  =  T2.chip_model JOIN screen_mode AS T3 ON T2.screen_mode = T3.Graphics_mode WHERE T3.Type = \"Text\" OR T1.RAM_MiB  >  32;",
        "amends": [
            "Do select `T2.Hardware_Model_name` instead of `model_name`. Do join `chip_model AS T1` instead of omitting it. Do join `phone AS T2` with `ON T1.Model_name = T2.chip_model` instead of querying `phones` directly. Do join `screen_mode AS T3` with `ON T2.screen_mode = T3.Graphics_mode` instead of omitting it. Do filter with `T3.Type = \"Text\"` instead of `screen_mode = 'Text'`. Do filter with `T1.RAM_MiB > 32` instead of `ram_size > 32`. The amended query now correctly joins the necessary tables and references the proper column names to match the intended logic."
        ],
        "rules": [
            "1) When answering about \"hardware model name for phones\": make sure the output order: T2.Hardware_Model_name. 2) When the question mentions \"screen mode type 'Text'\": \"screen mode type 'Text'\" actually means \"T3.Type = 'Text'\" in schema. 3) When the question mentions \"RAM size greater than 32\": \"RAM size greater than 32\" actually means \"T1.RAM_MiB > 32\" in schema. 4) When combining chip_model (T1) and phone (T2): link rows where T1.Model_name = T2.chip_model and keep only matching pairs. 5) When combining phone (T2) and screen_mode (T3): link rows where T2.screen_mode = T3.Graphics_mode and keep only matching pairs. 6) When filtering for phones with screen mode type \"Text\" or RAM size greater than 32: include rows where T3.Type = \"Text\" OR T1.RAM_MiB > 32."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT model_name FROM phones WHERE screen_mode = 'Text' OR ram_size > 32;",
            "SELECT T2.Hardware_Model_name \nFROM chip_model AS T1\nJOIN phone AS T2 ON T1.Model_name = T2.chip_model\nJOIN screen_mode AS T3 ON T2.screen_mode = T3.Graphics_mode\nWHERE T3.Type = \"Text\" OR T1.RAM_MiB > 32"
        ],
        "rule_sql": [
            "SELECT T2.Hardware_Model_name\nFROM phone T2\nJOIN chip_model T1 ON T1.Model_name = T2.chip_model\nJOIN screen_mode T3 ON T2.screen_mode = T3.Graphics_mode\nWHERE T3.Type = 'Text' OR T1.RAM_MiB > 32"
        ]
    },
    "5888": {
        "db_id": "cre_Theme_park",
        "question": "Tell me the price ranges for all the hotels.",
        "ground_truth": "SELECT price_range FROM HOTELS",
        "amends": [
            "Do select `price_range` instead of `hotel_name, price`. Do remove the `WHERE price > 100` filter instead of keeping it. Do remove the `ORDER BY hotel_name` clause instead of including it. The amended query now correctly selects only the price_range column from the HOTELS table without any filtering or sorting, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"price ranges for all the hotels\": make sure the output order: price_range. 2) When the question asks for \"price ranges\": \"price ranges\" actually means \"price_range in schema\". 3) When selecting from the HOTELS table: do not apply any WHERE filters or ORDER BY clauses unless explicitly specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT hotel_name, price FROM hotels WHERE price > 100 ORDER BY hotel_name;",
            "SELECT price_range FROM Hotels;"
        ],
        "rule_sql": [
            "SELECT price_range FROM Hotels;"
        ]
    },
    "2143": {
        "db_id": "local_govt_in_alabama",
        "question": "List the type of the services in alphabetical order.",
        "ground_truth": "SELECT service_type_code FROM services ORDER BY service_type_code",
        "amends": [
            "Do select `service_type_code` instead of `service_name` in the SELECT list. Do order by `service_type_code` instead of `service_name` in the ORDER BY clause. Do use ascending order instead of descending order. The amended query now correctly retrieves service type codes in ascending order instead of service names in descending order, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"type of the services\": use the exact column token \"service_type_code\" instead of \"service_name\". 2) When ordering results alphabetically: use ascending order instead of descending order. 3) When answering about \"List the type of the services in alphabetical order\": make sure the output order is \"service_type_code\" in ascending alphabetical order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT service_name FROM services ORDER BY service_name DESC;",
            "SELECT service_type_code FROM Services ORDER BY service_type_code ASC;"
        ],
        "rule_sql": [
            "SELECT service_type_code FROM Services ORDER BY service_type_code ASC;"
        ]
    },
    "6162": {
        "db_id": "music_4",
        "question": "What are the the songs in volumes, listed in ascending order?",
        "ground_truth": "SELECT Song FROM volume ORDER BY Song",
        "amends": [
            "Do select only the `Song` column instead of selecting all columns with `*`. Do reference the `volume` table instead of the `songs` table. Do order by the `Song` column instead of ordering by `volume DESC`. The amended query now correctly retrieves song names from the volume table ordered alphabetically by song name."
        ],
        "rules": [
            "1) When answering about \"songs in volumes\": make sure the output order: \"Song\" in ascending order. 2) When the question mentions \"songs\": \"songs\" actually means \"Song\" column in the volume table. 3) When selecting from the volume table: select only the \"Song\" column instead of all columns. 4) When ordering results: order by the \"Song\" column in ascending alphabetical order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM songs ORDER BY volume DESC;",
            "SELECT Song FROM volume ORDER BY Song ASC;"
        ],
        "rule_sql": [
            "SELECT Song FROM volume ORDER BY Song ASC;"
        ]
    },
    "4196": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "How many employees do we have?",
        "ground_truth": "SELECT count(*) FROM Employees",
        "amends": [
            "Do select from `Employees` table instead of `customers` table. The amended query now correctly counts records from the Employees table as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When answering about \"how many employees\": make sure to count from the \"Employees\" table instead of the \"customers\" table. 2) When counting employees: use the canonical key for counting records from the \"Employees\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers;",
            "SELECT COUNT(*) FROM Employees;"
        ],
        "rule_sql": [
            "SELECT COUNT(Employee_ID) FROM Employees;"
        ]
    },
    "2244": {
        "db_id": "machine_repair",
        "question": "What is the starting year for the oldest technician?",
        "ground_truth": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT 1",
        "amends": [
            "Do select `Starting_Year` instead of `MAX(start_year)` to retrieve the actual column value rather than an aggregate. Do add `ORDER BY Age DESC` instead of omitting ordering to sort technicians by age descending. Do add `LIMIT 1` instead of omitting limit to return only the top result. Do change the table reference from `technicians` to `technician` to match the correct table name. The amended query now correctly retrieves the starting year of the oldest technician by ordering by age descending and limiting to one result, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the starting year of the oldest technician: select \"Starting_Year\" from table \"technician\" instead of using MAX aggregate. 2) When ordering technicians by age to find the oldest: sort by \"Age\" in descending order. 3) When retrieving only the oldest technician: limit the results to 1 row after ordering by age descending."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(start_year) FROM technicians;",
            "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT 1"
        ]
    },
    "4876": {
        "db_id": "school_player",
        "question": "List the teams of the players with the top 5 largest ages.",
        "ground_truth": "SELECT Team FROM player ORDER BY Age DESC LIMIT 5",
        "amends": [
            "Do reference the table as `player` instead of `players` to match the correct table name. Do use column name `Team` instead of `team` to match the correct column casing. Do use column name `Age` instead of `age` to match the correct column casing. The amended query now correctly retrieves the top 5 teams from the player table ordered by age in descending order."
        ],
        "rules": [
            "1) When the question mentions \"teams\": \"teams\" actually means \"Team\" column in the player table. 2) When the question mentions \"players\": \"players\" actually means \"player\" table in the schema. 3) When the question mentions \"top 5 largest ages\": rank rows by \"Age\" in descending order and keep the first 5 rows. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 5) When handling text literals: do not change case, spacing, or punctuation from the schema specifications."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT team FROM players ORDER BY age DESC LIMIT 5;",
            "SELECT Team FROM player ORDER BY Age DESC LIMIT 5"
        ],
        "rule_sql": [
            "SELECT \"Team\" FROM \"player\" ORDER BY \"Age\" DESC LIMIT 5"
        ]
    },
    "4040": {
        "db_id": "student_1",
        "question": "Find the grade studying in room 105.",
        "ground_truth": "SELECT DISTINCT grade FROM list WHERE classroom  =  105",
        "amends": [
            "Do select `DISTINCT grade` instead of `*` to return unique grade values rather than all columns. Do use table `list` instead of `students` as the correct data source. Do filter on `classroom = 105` instead of `room = 105` using the proper column name for classroom identification. The amended query now correctly returns distinct grade values from the appropriate table with the correct filter condition, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"grade studying in room 105\": make sure the output order: grade. 2) When the question mentions \"grade\": \"grade\" actually means \"grade in schema\". 3) When the question mentions \"room 105\": \"room 105\" actually means \"classroom = 105 in schema\". 4) When selecting from the data source: use table \"list\" instead of \"students\" as the correct data source. 5) When filtering for classroom identification: use column \"classroom\" instead of \"room\" with value 105. 6) When returning results: return distinct grade values rather than all columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM students WHERE room = 105;",
            "SELECT DISTINCT Grade FROM list WHERE Classroom = 105"
        ],
        "rule_sql": [
            "SELECT DISTINCT Grade FROM list WHERE Classroom = 105 ORDER BY Grade;"
        ]
    },
    "6575": {
        "db_id": "wine_1",
        "question": "What are the maximum price and score of wines in each year?",
        "ground_truth": "SELECT max(Price) ,  max(Score) ,  YEAR FROM WINE GROUP BY YEAR",
        "amends": [
            "Do use `max(Price)` and `max(Score)` instead of `MAX(price)` and `MAX(score)` to match the correct column capitalization. Do place `YEAR` at the end of the SELECT list instead of at the beginning to match the output column order. Do reference table `WINE` instead of `wines` to use the correct table name. The amended query now correctly groups by year and returns maximum price and score values for each year."
        ],
        "rules": [
            "1) When the question asks for maximum price and score of wines per year: use \"max(Price)\" and \"max(Score)\" with exact capitalization as shown in the schema. 2) When organizing results by year: group by \"YEAR\" and compute maximum values per group. 3) When producing output columns: place \"YEAR\" at the end of the output order after \"max(Price)\" and \"max(Score)\". 4) When referencing the table containing wine data: use table name \"WINE\" exactly as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, MAX(price), MAX(score) FROM wines GROUP BY year;",
            "SELECT max(Price), max(Score), Year FROM wine GROUP BY Year"
        ],
        "rule_sql": [
            "SELECT max(Price), max(Score), Year FROM WINE GROUP BY Year"
        ]
    },
    "2653": {
        "db_id": "local_govt_mdm",
        "question": "How many different source system code for the cmi cross references are there?",
        "ground_truth": "SELECT count(DISTINCT source_system_code) FROM CMI_cross_references",
        "amends": [
            "Do count `DISTINCT source_system_code` instead of counting all rows with `COUNT(*)`. Do include the specific column `source_system_code` instead of using the wildcard asterisk. The amended query now correctly counts unique source system codes rather than total rows, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"different source system code\" or \"how many different\": count the number of unique values using DISTINCT on the exact column token \"source_system_code\" instead of counting all rows. 2) When counting distinct values from the CMI_Cross_References table: use the specific column \"source_system_code\" rather than the wildcard asterisk to ensure only unique values of that column are counted."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cmi_cross_references;",
            "SELECT COUNT(DISTINCT source_system_code) FROM CMI_Cross_References;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT source_system_code) FROM CMI_Cross_References;"
        ]
    },
    "1705": {
        "db_id": "epinions_1",
        "question": "List the titles of all items in alphabetic order .",
        "ground_truth": "SELECT title FROM item ORDER BY title",
        "amends": [
            "Do reference table `item` instead of `items` in the FROM clause. Do use ascending ORDER BY `title` instead of descending ORDER BY `title DESC`. The amended query now correctly references the proper table name and sorts results in ascending order as intended."
        ],
        "rules": [
            "1) When answering about \"titles of all items in alphabetic order\": make sure the output order: \"title\" in ascending alphabetical order. 2) When the question mentions \"items\": \"items\" actually means \"item\" in schema. 3) When ordering alphabetically: sort by \"title\" in ascending order (A to Z)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM items ORDER BY title DESC;",
            "SELECT title FROM item ORDER BY title ASC;"
        ],
        "rule_sql": [
            "SELECT title FROM item ORDER BY title ASC;"
        ]
    },
    "2940": {
        "db_id": "sakila_1",
        "question": "How many cities are in Australia?",
        "ground_truth": "SELECT count(*) FROM city AS T1 JOIN country AS T2 ON T1.country_id  =  T2.country_id WHERE T2.country  =  'Australia'",
        "amends": [
            "Do join `city AS T1` with `country AS T2` on `T1.country_id = T2.country_id` instead of querying only the `countries` table. Do filter on `T2.country = 'Australia'` instead of `name = 'Australia'` to correctly reference the country column. Do count cities in Australia instead of counting countries, which changes the fundamental purpose of the query from counting countries to counting cities within a specific country. The amended query now correctly returns the count of cities in Australia rather than simply checking if Australia exists in the countries table."
        ],
        "rules": [
            "1) When answering about \"cities in Australia\": make sure the output order: count of cities. 2) When the question mentions \"cities\": \"cities\" actually means \"city AS T1\" in schema. 3) When the question mentions \"Australia\": \"Australia\" actually means \"T2.country = 'Australia'\" in schema. 4) When combining T1 and T2 for shared entities: link rows where T1.country_id = T2.country_id; keep only matching pairs (inner match). 5) When the question asks for \"count of cities\": compute the number of rows using the canonical key token for cities (e.g., T1.city_id or equivalent primary key)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE name = 'Australia';",
            "SELECT COUNT(*) FROM city AS T1 JOIN country AS T2 ON T1.country_id = T2.country_id WHERE T2.country = 'Australia'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.city_id) \nFROM city AS T1\nINNER JOIN country AS T2 ON T1.country_id = T2.country_id\nWHERE T2.country = 'Australia'"
        ]
    },
    "4817": {
        "db_id": "aircraft",
        "question": "Please show the names and descriptions of aircrafts associated with airports that have a total number of passengers bigger than 10000000.",
        "ground_truth": "SELECT T1.Aircraft ,  T1.Description FROM aircraft AS T1 JOIN airport_aircraft AS T2 ON T1.Aircraft_ID  =  T2.Aircraft_ID JOIN airport AS T3 ON T2.Airport_ID  =  T3.Airport_ID WHERE T3.Total_Passengers  >  10000000",
        "amends": [
            "Do reference `aircraft` as `T1` instead of `aircrafts` as `a` and use column aliases `T1.Aircraft` and `T1.Description` instead of `a.name` and `a.description`. Do add a join through junction table `airport_aircraft` as `T2` instead of directly joining to airports, using `ON T1.Aircraft_ID = T2.Aircraft_ID` instead of `ON a.airport_id = ap.id`. Do then join to `airport` as `T3` instead of `airports` as `ap`, using `ON T2.Airport_ID = T3.Airport_ID` instead of the direct relationship. Do keep the filter `T3.Total_Passengers > 10000000` instead of `ap.total_passengers > 10000000` but with corrected table reference. The amended query now correctly handles the many-to-many relationship between aircraft and airports through the junction table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about aircraft names and descriptions: make sure the output order: T1.Aircraft, T1.Description\n2) When the question mentions \"aircrafts\": \"aircrafts\" actually means \"T1.aircraft\" in schema with exact column names T1.Aircraft and T1.Description\n3) When combining aircraft and airport tables: use junction table T2 (airport_aircraft) with exact join conditions T1.Aircraft_ID = T2.Aircraft_ID and T2.Airport_ID = T3.Airport_ID\n4) When filtering for airports with total passengers > 10000000: apply the condition T3.Total_Passengers > 10000000 using exact column name and literal value\n5) When handling the many-to-many relationship: perform inner joins through the junction table to ensure only matching aircraft-airport pairs are included"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.name, a.description FROM aircrafts a JOIN airports ap ON a.airport_id = ap.id WHERE ap.total_passengers > 10000000",
            "SELECT T1.Aircraft, T1.Description\nFROM aircraft AS T1\nJOIN airport_aircraft AS T2 ON T1.Aircraft_ID = T2.Aircraft_ID\nJOIN airport AS T3 ON T2.Airport_ID = T3.Airport_ID\nWHERE T3.Total_Passengers > 10000000"
        ],
        "rule_sql": [
            "SELECT T1.Aircraft, T1.Description\nFROM aircraft T1\nINNER JOIN airport_aircraft T2 ON T1.Aircraft_ID = T2.Aircraft_ID\nINNER JOIN airport T3 ON T2.Airport_ID = T3.Airport_ID\nWHERE T3.Total_Passengers > 10000000\nORDER BY T1.Aircraft, T1.Description"
        ]
    },
    "6180": {
        "db_id": "music_4",
        "question": "Return the famous release date for the oldest artist.",
        "ground_truth": "SELECT Famous_Release_date FROM artist ORDER BY Age DESC LIMIT 1",
        "amends": [
            "Do select `Famous_Release_date` instead of `release_date` and do change the source table to `artist` instead of `artists`. Do remove the WHERE clause with subquery filtering by minimum age instead of keeping it, and do add ORDER BY `Age DESC` instead of omitting ordering. Do add `LIMIT 1` instead of omitting row limiting, and do remove the correlated subquery comparing artist ages instead of using it for filtering. The amended query now correctly retrieves the most recent release date from the oldest artist by ordering by age descending and limiting to one result."
        ],
        "rules": [
            "1) When answering about \"famous release date\": make sure to select \"Famous_Release_date\" instead of \"release_date\". 2) When querying the artist information: use table \"artist\" instead of \"artists\". 3) When finding the oldest artist: order by \"Age DESC\" to rank artists from oldest to youngest. 4) When retrieving only the oldest artist: limit results to 1 row. 5) When the question asks for the oldest artist: do not use subqueries comparing minimum age values, instead use ordering and limiting."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT release_date FROM artists WHERE artist_age = (SELECT MIN(artist_age) FROM artists);",
            "SELECT Famous_Release_date FROM artist ORDER BY Age DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Famous_Release_date FROM artist ORDER BY Age DESC LIMIT 1;"
        ]
    },
    "1994": {
        "db_id": "gas_company",
        "question": "What is the total number of companies?",
        "ground_truth": "SELECT count(*) FROM company",
        "amends": [
            "Do specify the table source as `company` instead of `employees` to query the correct dataset. The amended query now correctly counts records from the company table instead of the employees table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"total number of companies\": use the \"company\" table instead of \"employees\" table to count the correct entities. 2) When counting companies: count using the canonical key from the company table (exact key not specified in schema, but use appropriate primary key for counting companies)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees;",
            "SELECT COUNT(*) FROM company;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS total_companies FROM company;"
        ]
    },
    "6023": {
        "db_id": "game_1",
        "question": "Show student ids who are on scholarship and have major 600.",
        "ground_truth": "SELECT StuID FROM Student WHERE major  =  600 INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'",
        "amends": [
            "Do select `StuID` instead of `student_id` and use `INTERSECT` instead of a single query with `WHERE` filters. Do change the table name to `Student` instead of `students` and remove the `scholarship` filter from the main query. Do add a second query selecting from `Sportsinfo` with condition `onscholarship = 'Y'` instead of checking `scholarship = 'yes'` in the main table. Do use the correct column name `onscholarship` with value `'Y'` instead of `scholarship = 'yes'`. The amended query now correctly identifies students who are both majoring in 600 and on scholarship by intersecting results from two separate tables, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for student ids: use the exact column name \"StuID\" from the Student table instead of \"student_id\". 2) When checking for scholarship status: use the column \"onscholarship\" from the SportsInfo table with the exact literal value 'Y' instead of checking \"scholarship = 'yes'\" in the main table. 3) When identifying students who meet both conditions (major 600 and on scholarship): use INTERSECT to combine results from two separate queries rather than using a single WHERE clause with multiple conditions. 4) When referring to the main student table: use the exact table name \"Student\" instead of \"students\". 5) When filtering for major 600: keep the condition \"major = 600\" in the Student table query. 6) When combining data from Student and SportsInfo tables: ensure both queries select \"StuID\" to enable proper intersection operation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id FROM students WHERE scholarship = 'yes' AND major = 600",
            "SELECT StuID FROM Student WHERE Major = 600\nINTERSECT\nSELECT StuID FROM SportsInfo WHERE OnScholarship = 'Y'"
        ],
        "rule_sql": [
            "SELECT StuID FROM Student WHERE Major = 600\nINTERSECT\nSELECT StuID FROM SportsInfo WHERE OnScholarship = 'Y'"
        ]
    },
    "5258": {
        "db_id": "music_2",
        "question": "Find the first name of the band mate that has performed in most songs.",
        "ground_truth": "SELECT t2.firstname FROM Performance AS t1 JOIN Band AS t2 ON t1.bandmate  =  t2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId GROUP BY firstname ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `t2.firstname` from the `Band` table instead of `first_name` from an unspecified source. Do add `JOIN` clauses to connect `Performance`, `Band`, and `Songs` tables with proper join conditions `ON t1.bandmate = t2.id` and `ON T3.SongId = T1.SongId` instead of querying a single table. Do add `GROUP BY firstname` to aggregate properly instead of attempting to use an aggregate function without grouping. Do use `count(*)` in the ORDER BY clause instead of `COUNT(song_id)` which was incorrectly placed in the SELECT clause. The amended query now correctly joins the necessary tables, groups by bandmate name, and orders by performance count to identify the bandmate with the most song performances."
        ],
        "rules": [
            "1) When answering about \"band mate that has performed in most songs\": make sure the output order: t2.firstname. 2) When the question mentions \"band mate\": \"band mate\" actually means \"t2.firstname in schema\". 3) When combining T1 (Performance), T2 (Band), and T3 (Songs) tables: link rows where T1.bandmate = T2.id and T3.SongId = T1.SongId; keep only matching pairs (inner match). 4) When the question asks for \"count of performances\": compute the number of rows using count(*) per group. 5) When the question asks for \"most songs\": rank rows by count(*) in descending direction and keep the first 1 row. 6) When the question says \"per band mate\": organize results by t2.firstname and compute count(*) per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM band_mates ORDER BY COUNT(song_id) DESC LIMIT 1;",
            "SELECT t2.Firstname\nFROM Performance t1\nJOIN Band t2 ON t1.Bandmate = t2.Id\nGROUP BY t2.Firstname\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT t2.Firstname\nFROM Performance t1\nJOIN Band t2 ON t1.Bandmate = t2.Id\nGROUP BY t2.Firstname\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "33": {
        "db_id": "farm",
        "question": "What is the official name and status of the city with the most residents?",
        "ground_truth": "SELECT Official_Name ,  Status FROM city ORDER BY Population DESC LIMIT 1",
        "amends": [
            "Do use column names `Official_Name` and `Status` instead of `name` and `status`. Do reference table `city` instead of `cities`. Do order by `Population` in descending order instead of ascending order. The amended query now matches the intended behavior with correct column names, table reference, and sorting direction."
        ],
        "rules": [
            "1) When answering about \"the city with the most residents\": make sure the output order: \"Official_Name\", \"Status\". 2) When the question mentions \"official name\": \"official name\" actually means \"Official_Name\" in schema. 3) When the question mentions \"status\": \"status\" actually means \"Status\" in schema. 4) When the question mentions \"most residents\" or \"largest population\": rank rows by \"Population\" in descending order and keep the first 1 row. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, status FROM cities ORDER BY population ASC LIMIT 1;",
            "SELECT Official_Name, Status FROM city ORDER BY Population DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT \"Official_Name\", \"Status\" FROM \"city\" ORDER BY \"Population\" DESC LIMIT 1;"
        ]
    },
    "1607": {
        "db_id": "customers_and_invoices",
        "question": "Show the order ids and the number of invoices for each order.",
        "ground_truth": "SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT order_id, COUNT(*) FROM invoices GROUP BY order_id;"
        ],
        "rule_sql": [
            "SELECT o.order_id, COUNT(i.invoice_number) AS number_of_invoices\nFROM Orders o\nLEFT JOIN Invoices i ON o.order_id = i.order_id\nGROUP BY o.order_id;",
            "SELECT o.order_id, COUNT(i.invoice_number) AS number_of_invoices\nFROM Orders o\nLEFT JOIN Invoices i ON o.order_id = i.order_id\nGROUP BY o.order_id;",
            "SELECT o.order_id, COUNT(i.invoice_number) AS number_of_invoices\nFROM Orders o\nLEFT JOIN Invoices i ON o.order_id = i.order_id\nGROUP BY o.order_id;",
            "SELECT o.order_id, COUNT(i.invoice_number) AS number_of_invoices\nFROM Orders o\nLEFT JOIN Invoices i ON o.order_id = i.order_id\nGROUP BY o.order_id;"
        ]
    },
    "663": {
        "db_id": "journal_committee",
        "question": "Show the names of editors that are on at least two journal committees.",
        "ground_truth": "SELECT T1.Name FROM editor AS T1 JOIN journal_committee AS T2 ON T1.Editor_ID  =  T2.Editor_ID GROUP BY T1.Name HAVING COUNT(*)  >=  2",
        "amends": [
            "Do add table sources `editor AS T1` and `journal_committee AS T2` instead of just `editors`. Do add `JOIN` with predicate `T1.Editor_ID = T2.Editor_ID` instead of no join condition. Do specify `T1.Name` in SELECT instead of just `name`. Do keep `GROUP BY T1.Name` and `HAVING COUNT(*) >= 2` unchanged. The amended query now correctly identifies editors serving on journal committees with multiple assignments rather than just duplicate names in a single table."
        ],
        "rules": [
            "1) When answering about \"editors on journal committees\": use tables \"editor AS T1\" and \"journal_committee AS T2\" with exact aliases T1 and T2. 2) When combining editor and journal_committee tables: link rows where T1.Editor_ID = T2.Editor_ID and keep only matching pairs (inner match). 3) When selecting editor names: use T1.Name instead of just name. 4) When grouping by editor names: use GROUP BY T1.Name to organize results by editor name. 5) When counting journal committee assignments per editor: compute the number of rows using COUNT(*) and filter for editors with at least 2 assignments using HAVING COUNT(*) >= 2."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM editors GROUP BY name HAVING COUNT(*) >= 2;",
            "SELECT T1.Name\nFROM editor AS T1\nJOIN journal_committee AS T2 ON T1.Editor_ID = T2.Editor_ID\nGROUP BY T1.Name\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM editor AS T1 INNER JOIN journal_committee AS T2 ON T1.Editor_ID = T2.Editor_ID GROUP BY T1.Name HAVING COUNT(*) >= 2"
        ]
    },
    "6423": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "Show the statement detail and the corresponding document name for the statement with detail 'Private Project'.",
        "ground_truth": "SELECT T1.statement_details ,  T2.document_name FROM Statements AS T1 JOIN Documents AS T2 ON T1.statement_id  =  T2.document_id WHERE T1.statement_details  =  'Private Project'",
        "amends": [
            "Do join `Documents AS T2` instead of querying only the `statements` table. Do reference `T1.statement_details` and `T2.document_name` instead of `statement_detail` and `document_name` without table aliases. Do use the join condition `T1.statement_id = T2.document_id` instead of missing the table relationship entirely. Do filter on `T1.statement_details = 'Private Project'` instead of `statement_detail = 'Private Project'` without table qualification. The amended query now correctly joins the tables and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"statement detail and document name\": make sure the output order: T1.statement_details, T2.document_name\n2) When combining statements table (T1) and Documents table (T2): link rows where T1.statement_id = T2.document_id and keep only matching pairs (inner match)\n3) When the question mentions filtering for 'Private Project': filter rows where T1.statement_details = 'Private Project' exactly as specified\n4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms\n5) When handling text literals: do not change case, spacing, or punctuation of 'Private Project'"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT statement_detail, document_name FROM statements WHERE statement_detail = 'Private Project'",
            "SELECT T1.Statement_Details, T2.Document_Name \nFROM Statements AS T1 \nJOIN Documents AS T2 ON T1.Statement_ID = T2.Document_ID \nWHERE T1.Statement_Details = 'Private Project'"
        ],
        "rule_sql": [
            "SELECT T1.statement_details, T2.document_name\nFROM Statements T1\nINNER JOIN Documents T2 ON T1.statement_id = T2.document_id\nWHERE T1.statement_details = 'Private Project'"
        ]
    },
    "509": {
        "db_id": "allergy_1",
        "question": "How many female students have milk or egg allergies?",
        "ground_truth": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  \"F\" AND T1.allergy  =  \"Milk\" OR T1.allergy  =  \"Eggs\"",
        "amends": [
            "Do join `has_allergy AS T1` with `Student AS T2` on `T1.StuID = T2.StuID` instead of querying a single `students` table. Do filter on `T2.sex = \"F\"` instead of `gender = 'female'` and use `T1.allergy = \"Milk\" OR T1.allergy = \"Eggs\"` instead of `allergy = 'milk' OR allergy = 'egg'`. Do reference the correct table aliases and column names (`StuID`, `sex`, `allergy`) instead of the original schema assumptions, and use double quotes for string literals instead of single quotes. The amended query now correctly joins the allergy and student tables to count female students with milk or egg allergies, matching the intended behavior.",
            "Do use `count(*)` instead of `COUNT(DISTINCT T1.StuID)` to count all matching rows rather than distinct student IDs. Do change the WHERE clause predicate structure to `T1.allergy = \"Milk\" OR T1.allergy = \"Eggs\"` instead of using parentheses around the OR condition, which alters the logical evaluation. The amended query now correctly counts all female students with either milk or egg allergies rather than counting distinct students with those allergies.",
            "Do use proper parentheses grouping for the allergy conditions with `(T1.allergy = \"Milk\" OR T1.allergy = \"Eggs\")` instead of the incorrect operator precedence that would evaluate as `T2.sex = \"F\" AND T1.allergy = \"Milk\" OR T1.allergy = \"Eggs\"` which could return incorrect results due to OR having lower precedence than AND. The amended query now correctly matches the intended logic by ensuring both sex and allergy conditions are properly grouped.",
            "Do use parentheses around the OR condition `(T1.allergy = \"Milk\" OR T1.allergy = \"Eggs\")` instead of omitting them, as the original query without parentheses would have incorrect operator precedence where the AND would bind more tightly than OR. Do maintain the same `COUNT(*)` aggregation, `JOIN` between `Has_Allergy` and `Student` tables on `T1.StuID = T2.StuID`, and `WHERE T2.sex = \"F\"` filter without changes. The amended query now correctly groups the allergy conditions with parentheses to ensure proper logical evaluation and matches the right SQL's behavior.",
            "Do use proper parentheses grouping for the allergy conditions with `(T1.allergy = \"Milk\" OR T1.allergy = \"Eggs\")` instead of the incorrect logical grouping `T1.allergy = \"Milk\" OR T1.allergy = \"Eggs\"` which would cause the OR condition to apply to the entire WHERE clause rather than just the allergy checks. The amended query now correctly matches the intended logic by ensuring both sex and allergy conditions are properly grouped together."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE gender = 'female' AND (allergy = 'milk' OR allergy = 'egg');",
            "SELECT COUNT(DISTINCT T1.StuID) \nFROM Has_Allergy AS T1 \nJOIN Student AS T2 ON T1.StuID = T2.StuID \nWHERE T2.Sex = \"F\" \nAND (T1.Allergy = \"Milk\" OR T1.Allergy = \"Eggs\")",
            "SELECT COUNT(*) \nFROM Has_Allergy AS T1 \nJOIN Student AS T2 ON T1.StuID = T2.StuID \nWHERE T2.sex = \"F\" \nAND (T1.allergy = \"Milk\" OR T1.allergy = \"Eggs\")",
            "SELECT COUNT(*)\nFROM Has_Allergy AS T1\nJOIN Student AS T2 ON T1.StuID = T2.StuID\nWHERE T2.sex = \"F\" \nAND (T1.allergy = \"Milk\" OR T1.allergy = \"Eggs\")",
            "SELECT COUNT(*)\nFROM Has_Allergy AS T1\nJOIN Student AS T2 ON T1.StuID = T2.StuID\nWHERE T2.sex = \"F\" \nAND (T1.allergy = \"Milk\" OR T1.allergy = \"Eggs\")",
            "SELECT COUNT(*)\nFROM Has_Allergy AS T1\nJOIN Student AS T2 ON T1.StuID = T2.StuID\nWHERE T2.sex = \"F\" \nAND (T1.allergy = \"Milk\" OR T1.allergy = \"Eggs\")"
        ],
        "rule_sql": []
    },
    "20": {
        "db_id": "farm",
        "question": "What are the hosts of competitions whose theme is not \"Aliens\"?",
        "ground_truth": "SELECT Hosts FROM farm_competition WHERE Theme !=  'Aliens'",
        "amends": [
            "Do select `Hosts` from the `farm_competition` table instead of `host` from the `competitions` table. Do use a not equals filter `!= 'Aliens'` for the `Theme` column instead of an equals filter `= 'Aliens'`. The amended query now correctly retrieves hosts from farm competitions where the theme is not Aliens, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"hosts of competitions\": select \"Hosts\" from table \"farm_competition\" instead of \"host\" from \"competitions\". 2) When filtering for theme that is not \"Aliens\": use not equals comparison != 'Aliens' for column \"Theme\" instead of equals comparison = 'Aliens'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT host FROM competitions WHERE theme = 'Aliens';",
            "SELECT Hosts FROM farm_competition WHERE Theme != 'Aliens';"
        ],
        "rule_sql": [
            "SELECT Hosts FROM farm_competition WHERE Theme != 'Aliens';"
        ]
    },
    "3163": {
        "db_id": "station_weather",
        "question": "Find the name of the train whose route runs through greatest number of stations.",
        "ground_truth": "SELECT t1.name FROM train AS t1 JOIN route AS t2 ON t1.id  =  t2.train_id GROUP BY t2.train_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference the table as `train` instead of `trains` and use alias `t1` for it. Do reference the joined table as `route` instead of `routes` and use alias `t2` for it. Do select `t1.name` instead of `train_name` and omit the `station_count` alias. Do join on `t1.id = t2.train_id` instead of `trains.train_id = routes.train_id`. Do group by `t2.train_id` instead of `train_name`. Do order by `count(*)` descending instead of `station_count` descending. The amended query now correctly returns the train name with the most routes by counting route records per train ID rather than station IDs."
        ],
        "rules": [
            "1) When the question asks for the \"name of the train\": select \"t1\".\"name\" as the output column. 2) When combining train and route tables: link rows where \"t1\".\"id\" = \"t2\".\"train_id\" and keep only matching pairs (inner match). 3) When counting the number of stations per train: count all rows using count(*) for each train group. 4) When grouping by train: group by \"t2\".\"train_id\" to organize results per train. 5) When finding the train with the \"greatest number of stations\": order the results by count(*) in descending order and keep only the first row. 6) When referring to table names: use \"train\" as table name with alias \"t1\" and \"route\" as table name with alias \"t2\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT train_name, COUNT(station_id) as station_count \nFROM trains \nJOIN routes ON trains.train_id = routes.train_id \nGROUP BY train_name \nORDER BY station_count DESC \nLIMIT 1;",
            "SELECT t1.name FROM train t1 JOIN route t2 ON t1.id = t2.train_id GROUP BY t2.train_id ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t1.name FROM train t1 INNER JOIN route t2 ON t1.id = t2.train_id GROUP BY t2.train_id ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "4695": {
        "db_id": "college_3",
        "question": "What are the first names and last names of the students that minor in the department with DNO 140.",
        "ground_truth": "SELECT T2.Fname ,  T2.Lname FROM MINOR_IN AS T1 JOIN STUDENT AS T2 ON T1.StuID  =  T2.StuID WHERE T1.DNO  =  140",
        "amends": [
            "Do select `T2.Fname` and `T2.Lname` instead of `first_name` and `last_name`. Do use `FROM MINOR_IN AS T1 JOIN STUDENT AS T2` instead of `FROM students`. Do apply `ON T1.StuID = T2.StuID` instead of no join condition. Do filter with `T1.DNO = 140` instead of `minor_dno = 140`. The amended query now correctly joins the MINOR_IN and STUDENT tables to find students minoring in department 140, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"first names and last names of students\": make sure the output order: T2.Fname, T2.Lname. 2) When the question mentions \"students that minor in the department\": this requires joining MINOR_IN table (as T1) with STUDENT table (as T2) using T1.StuID = T2.StuID. 3) When filtering for department with DNO 140: apply the condition T1.DNO = 140 exactly. 4) When combining T1 and T2 for shared entities: link rows where T1.StuID = T2.StuID exactly and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM students WHERE minor_dno = 140;",
            "SELECT T2.Fname, T2.Lname FROM Minor_in AS T1 JOIN Student AS T2 ON T1.StuID = T2.StuID WHERE T1.DNO = 140"
        ],
        "rule_sql": [
            "SELECT T2.Fname, T2.Lname FROM Minor_in AS T1 JOIN Student AS T2 ON T1.StuID = T2.StuID WHERE T1.DNO = 140"
        ]
    },
    "1544": {
        "db_id": "insurance_and_eClaims",
        "question": "Count the number of distinct claim outcome codes.",
        "ground_truth": "SELECT count(DISTINCT claim_outcome_code) FROM claims_processing",
        "amends": [
            "Do count `DISTINCT claim_outcome_code` instead of counting all occurrences without distinct. Do reference table `claims_processing` instead of `claims`. The amended query now correctly counts unique claim outcome codes from the appropriate table, matching the intended behavior."
        ],
        "rules": [
            "1) When counting distinct values of claim outcome codes: use DISTINCT to count unique values of \"claim_outcome_code\" instead of counting all occurrences. 2) When referencing the claims processing data: use table \"claims_processing\" instead of \"claims\" as the source table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(claim_outcome_code) FROM claims;",
            "SELECT COUNT(DISTINCT Claim_Outcome_Code) FROM Claims_Processing;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Claim_Outcome_Code) FROM Claims_Processing;"
        ]
    },
    "4435": {
        "db_id": "network_2",
        "question": "What are the names and job titles of every person ordered alphabetically by name?",
        "ground_truth": "SELECT name ,  job FROM Person ORDER BY name",
        "amends": [
            "Do select `name` and `job` instead of `name` and `job_title`. Do reference table `Person` instead of `people`. Do order by `name` instead of `job_title`. The amended query now correctly selects from the Person table with the appropriate column names and ordering."
        ],
        "rules": [
            "1) When the question asks for \"names and job titles\": select the exact columns \"name\" and \"job\" from table \"Person\" instead of \"name\" and \"job_title\" from \"people\". 2) When ordering results alphabetically by name: sort the output by the \"name\" column in ascending alphabetical order instead of by \"job_title\". 3) When referencing the person table: use the exact table name \"Person\" with proper capitalization, not \"people\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, job_title FROM people ORDER BY job_title;",
            "SELECT name, job FROM Person ORDER BY name;"
        ],
        "rule_sql": [
            "SELECT name, job FROM Person ORDER BY name ASC;"
        ]
    },
    "1491": {
        "db_id": "college_2",
        "question": "What are the names of all instructors with a higher salary than any of the instructors in the Biology department?",
        "ground_truth": "SELECT name FROM instructor WHERE salary  >  (SELECT max(salary) FROM instructor WHERE dept_name  =  'Biology')",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM instructor WHERE salary > (SELECT MAX(salary) FROM instructor WHERE dept_name = 'Biology')"
        ],
        "rule_sql": [
            "SELECT name FROM instructor WHERE salary > (SELECT MAX(salary) FROM instructor WHERE dept_name = 'Biology')"
        ]
    },
    "5425": {
        "db_id": "shop_membership",
        "question": "What are the names of the members that have never registered at any branch?",
        "ground_truth": "SELECT name FROM member WHERE member_id NOT IN (SELECT member_id FROM membership_register_branch)",
        "amends": [
            "Do query from `member` table instead of `members` table. Do use `member_id NOT IN` subquery filter instead of `branch_id IS NULL` condition. Do add a correlated subquery checking `membership_register_branch` table instead of omitting this relationship validation. The amended query now correctly identifies members without branch membership by checking the membership register instead of relying on a potentially incorrect NULL branch_id field."
        ],
        "rules": [
            "1) When the question asks about \"members\": use the exact table name \"member\" instead of \"members\". 2) When identifying members who have never registered at any branch: use a subquery that checks for member_id values not found in the membership_register_branch table instead of checking for NULL branch_id. 3) When validating branch membership relationships: reference the membership_register_branch table to ensure accurate relationship validation rather than relying on potentially incorrect NULL checks."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM members WHERE branch_id IS NULL;",
            "SELECT Name FROM member WHERE Member_ID NOT IN (SELECT Member_ID FROM membership_register_branch)"
        ],
        "rule_sql": [
            "SELECT Name FROM member WHERE Member_ID NOT IN (SELECT Member_ID FROM membership_register_branch)"
        ]
    },
    "3010": {
        "db_id": "loan_1",
        "question": "Find the number of customers in the banks at New York City.",
        "ground_truth": "SELECT sum(no_of_customers) FROM bank WHERE city  =  'New York City'",
        "amends": [
            "Do use `sum(no_of_customers)` instead of `COUNT(*)` to sum customer counts rather than counting rows. Do query from `bank` instead of `customers` as the source table. Do filter for `city = 'New York City'` instead of `city = 'New York'` to match the correct city name. The amended query now correctly sums customer counts from the bank table for New York City instead of counting rows from a customers table with an incorrect city filter."
        ],
        "rules": [
            "1) When answering about \"number of customers in banks\": use sum(\"no_of_customers\") instead of counting rows to get the total customer count. 2) When the question mentions \"New York City\": use the exact literal 'New York City' for city filtering, not 'New York'. 3) When querying customer data: use the \"bank\" table as the source instead of a \"customers\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE city = 'New York'",
            "SELECT SUM(no_of_customers) FROM bank WHERE city = 'New York City'"
        ],
        "rule_sql": [
            "SELECT SUM(no_of_customers) FROM bank WHERE city = 'New York City';"
        ]
    },
    "1996": {
        "db_id": "gas_company",
        "question": "What is the name and rank of every company ordered by descending number of sales?",
        "ground_truth": "SELECT company ,  rank FROM company ORDER BY Sales_billion DESC",
        "amends": [
            "Do reference the `company` table instead of `companies` and select the `company` column instead of `name`. Do order by `Sales_billion DESC` instead of `sales ASC` to sort by the correct column in descending order rather than ascending. The amended query now correctly retrieves company names and ranks from the appropriate table sorted by sales in billions in descending order."
        ],
        "rules": [
            "1) When the question mentions \"company\": use the table \"company\" instead of \"companies\" and select the column \"company\" instead of \"name\". 2) When ordering by number of sales: use the column \"Sales_billion\" in descending order instead of \"sales\" in ascending order. 3) When answering about \"name and rank of every company ordered by descending number of sales\": make sure the output order: \"company\", \"rank\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, rank FROM companies ORDER BY sales ASC;",
            "SELECT Company, Rank FROM company ORDER BY Sales_billion DESC;"
        ],
        "rule_sql": [
            "SELECT company, Rank FROM company ORDER BY Sales_billion DESC;"
        ]
    },
    "6587": {
        "db_id": "wine_1",
        "question": "Find the top 3 wineries with the greatest number of wines made of white color grapes.",
        "ground_truth": "SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  \"White\" GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT 3",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of no aliases. Do join `GRAPES AS T1` with `WINE AS T2` on `T1.GRAPE = T2.GRAPE` instead of querying only the `wines` table. Do filter on `T1.Color = \"White\"` instead of `color = 'white'`. Do select only `T2.Winery` instead of both `winery` and `wine_count`. Do use `count(*)` in the `ORDER BY` clause instead of ordering by the alias `wine_count`. Do use double quotes around \"White\" instead of single quotes. The amended query now correctly joins the GRAPES and WINE tables to filter by grape color and count wines per winery, matching the RIGHT_SQL's behavior.",
            "Do remove `COUNT(*) AS wine_count` from the SELECT list instead of including it, as only `T2.Winery` is needed. Do keep the same FROM clause with `grapes AS T1 JOIN wine AS T2` instead of changing it. Do maintain the same JOIN condition `ON T1.Grape = T2.Grape` instead of altering it. Do preserve the WHERE filter `T1.Color = \"White\"` instead of modifying it. Do retain the GROUP BY clause `GROUP BY T2.Winery` instead of changing it. Do keep the ORDER BY clause `ORDER BY count(*) DESC` instead of altering it. Do maintain the LIMIT clause `LIMIT 3` instead of modifying it. The amended query now matches RIGHT_SQL's behavior by selecting only the winery names without the count aggregation."
        ],
        "rules": [
            "1) When answering about \"top 3 wineries with greatest number of wines made of white color grapes\": make sure the output order: T2.Winery\n2) When the question mentions \"white color grapes\": \"white\" actually means \"T1.Color = \\\"White\\\"\" in schema\n3) When the question asks for \"top 3\" by number of wines: rank rows by count(*) in descending direction and keep the first 3 rows\n4) When combining GRAPES as T1 and WINE as T2 for shared grape types: link rows where T1.GRAPE = T2.GRAPE exactly as shown; keep only matching pairs (inner match)\n5) When the question asks for \"number of wines\": compute the count of rows using the canonical key relationship between T1 and T2\n6) When handling text literals: do not change case, spacing, or punctuation - use exact literal \\\"White\\\" with double quotes\n7) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for identifiers like T1.Color and T2.Winery",
            "1) When the question asks for \"top 3 wineries with the greatest number of wines\": rank wineries by their count of wines in descending order and keep the first 3 rows. 2) When the question mentions \"wines made of white color grapes\": filter to only include wines where the grape color equals \"White\" exactly. 3) When combining grapes and wine tables: link rows where T1.Grape = T2.Grape and keep only matching pairs (inner match). 4) When counting wines per winery: group results by T2.Winery and compute the count of wines for each group. 5) When answering about top wineries by wine count: make sure the output order is T2.Winery only, without including the count value in the final output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT winery, COUNT(*) as wine_count \nFROM wines \nWHERE color = 'white' \nGROUP BY winery \nORDER BY wine_count DESC \nLIMIT 3;",
            "SELECT T2.Winery, COUNT(*) AS wine_count\nFROM grapes AS T1\nJOIN wine AS T2 ON T1.Grape = T2.Grape\nWHERE T1.Color = \"White\"\nGROUP BY T2.Winery\nORDER BY COUNT(*) DESC\nLIMIT 3",
            "SELECT T2.Winery\nFROM grapes AS T1\nJOIN wine AS T2 ON T1.Grape = T2.Grape\nWHERE T1.Color = \"White\"\nGROUP BY T2.Winery\nORDER BY count(*) DESC\nLIMIT 3"
        ],
        "rule_sql": [
            "SELECT T2.Winery\nFROM grapes AS T1\nINNER JOIN wine AS T2 ON T1.Grape = T2.Grape\nWHERE T1.Color = \"White\"\nGROUP BY T2.Winery\nORDER BY COUNT(*) DESC\nLIMIT 3"
        ]
    },
    "1661": {
        "db_id": "theme_gallery",
        "question": "What is the name of the artist who joined latest?",
        "ground_truth": "SELECT name FROM artist ORDER BY year_join DESC LIMIT 1",
        "amends": [
            "Do reference table `artist` instead of `artists` in the FROM clause. Do order by `year_join DESC` instead of `join_date ASC` in the ORDER BY clause. The amended query now correctly retrieves the most recently joined artist from the proper table."
        ],
        "rules": [
            "1) When answering about \"the artist who joined latest\": make sure the output order: name. 2) When the question mentions \"joined latest\": use \"year_join DESC\" ordering to get the most recent join. 3) When referring to the artists table: use the exact table name \"artist\" (not \"artists\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM artists ORDER BY join_date ASC LIMIT 1;",
            "SELECT Name FROM artist ORDER BY Year_Join DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name FROM artist ORDER BY Year_Join DESC LIMIT 1;"
        ]
    },
    "3393": {
        "db_id": "manufacturer",
        "question": "Find the name and component amount of the least popular furniture.",
        "ground_truth": "SELECT name ,  Num_of_Component FROM furniture ORDER BY market_rate LIMIT 1",
        "amends": [
            "Do select `Num_of_Component` instead of `component_amount` in the SELECT list. Do order by `market_rate` instead of `popularity` in the ORDER BY clause. The amended query now matches the intended behavior of selecting furniture names with their component counts ordered by market rate."
        ],
        "rules": [
            "1) When the question asks for \"component amount\": use the exact column token \"Num_of_Component\" from the furniture table. 2) When the question asks for the \"least popular furniture\" based on market popularity: order by the exact column token \"market_rate\" in ascending order (lowest first) to find the least popular. 3) When selecting output columns: maintain the order of name followed by component amount (Num_of_Component). 4) When limiting results to the single least popular item: return only the first row after ordering by market_rate."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, component_amount FROM furniture ORDER BY popularity DESC LIMIT 1;",
            "SELECT f.Name, f.Num_of_Component \nFROM furniture f \nORDER BY f.Market_Rate ASC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name, Num_of_Component FROM furniture ORDER BY Market_Rate ASC LIMIT 1;"
        ]
    },
    "6312": {
        "db_id": "e_government",
        "question": "Find the name of the most popular party form.",
        "ground_truth": "SELECT t1.form_name FROM forms AS t1 JOIN party_forms AS t2 ON t1.form_id  =  t2.form_id GROUP BY t2.form_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `form_name` from the `forms` table instead of `party_form` from the `parties` table. Do join `forms` with `party_forms` on `form_id` instead of querying only the `parties` table. Do group by `form_id` instead of `party_form`. Do order by `count(*)` descending instead of the alias `count`. The amended query now correctly identifies the most common party form by joining the forms reference table with party associations and counting occurrences per form_id, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"most popular party form\": make sure the output order: form_name. 2) When the question mentions \"party form\": \"party form\" actually means \"form_name in Forms table\". 3) When counting party forms: compute the number of rows using the canonical key form_id from Party_Forms table. 4) When combining Forms and Party_Forms tables: link rows where Forms.form_id = Party_Forms.form_id and keep only matching pairs (inner match). 5) When the question asks for \"most popular\": rank rows by count of form_id in descending order and keep the first 1 row. 6) When grouping by party forms: organize results by form_id from Party_Forms table and compute count per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT party_form, COUNT(*) as count FROM parties GROUP BY party_form ORDER BY count DESC LIMIT 1;",
            "SELECT f.form_name\nFROM Forms f\nJOIN Party_Forms pf ON f.form_id = pf.form_id\nGROUP BY f.form_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT f.form_name\nFROM Forms f\nINNER JOIN Party_Forms pf ON f.form_id = pf.form_id\nGROUP BY pf.form_id\nORDER BY COUNT(pf.form_id) DESC\nLIMIT 1;"
        ]
    },
    "5893": {
        "db_id": "cre_Theme_park",
        "question": "Show details of all visitors.",
        "ground_truth": "SELECT Tourist_Details FROM VISITORS",
        "amends": [
            "Do select `Tourist_Details` instead of `*` to return only specific columns instead of all columns. Do reference table `VISITORS` instead of `visitors` to match the correct table name case. Do remove the `WHERE visitor_id IS NULL` filter instead of keeping it to return all records instead of only those with null visitor IDs. The amended query now correctly selects only the Tourist_Details column from the VISITORS table without any filtering, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"details of all visitors\": make sure the output order: Tourist_Details. 2) When the question mentions \"visitors\": \"visitors\" actually means \"VISITORS\" in schema with exact case. 3) When selecting columns: use only Tourist_Details instead of all columns (*). 4) When filtering records: do not apply any WHERE conditions to return all visitors instead of only those with null visitor IDs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM visitors WHERE visitor_id IS NULL;",
            "SELECT Tourist_Details FROM VISITORS;"
        ],
        "rule_sql": [
            "SELECT Tourist_Details FROM Visitors ORDER BY Tourist_Details;"
        ]
    },
    "2629": {
        "db_id": "inn_1",
        "question": "What are the names of rooms that have either king or queen bed?",
        "ground_truth": "SELECT roomName FROM Rooms WHERE bedType  =  \"King\" OR bedType  =  \"Queen\";",
        "amends": [
            "Do use `roomName` instead of `name` for the column selection. Do reference `Rooms` instead of `rooms` for the table name. Do use `bedType` instead of `bed_type` for the column filter. Do use `\"King\"` and `\"Queen\"` instead of `'king'` and `'queen'` for the string literals to match the correct case sensitivity. The amended query now correctly selects room names from the Rooms table filtering for King or Queen bed types."
        ],
        "rules": [
            "1) When selecting room names from the Rooms table: use the exact column name \"roomName\" instead of \"name\". 2) When referring to the table containing room information: use the exact table name \"Rooms\" instead of \"rooms\". 3) When filtering by bed type: use the exact column name \"bedType\" instead of \"bed_type\". 4) When checking for king or queen bed types: use the exact string literals \"King\" and \"Queen\" with proper case sensitivity instead of lowercase versions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM rooms WHERE bed_type = 'king' OR bed_type = 'queen';",
            "SELECT roomName FROM Rooms WHERE bedType = \"King\" OR bedType = \"Queen\";"
        ],
        "rule_sql": [
            "SELECT roomName FROM Rooms WHERE bedType = 'King' OR bedType = 'Queen';"
        ]
    },
    "2865": {
        "db_id": "icfp_1",
        "question": "Find the titles of all the papers written by \"Jeremy Gibbons\"",
        "ground_truth": "SELECT t3.title FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid WHERE  t1.fname  =  \"Jeremy\" AND t1.lname  =  \"Gibbons\"",
        "amends": [
            "Do join `authors AS t1` instead of omitting it, and do join `authorship AS t2` on `t1.authid = t2.authid` instead of omitting this relationship. Do join `papers AS t3` on `t2.paperid = t3.paperid` instead of querying `papers` directly without proper joins. Do filter on `t1.fname = \"Jeremy\"` and `t1.lname = \"Gibbons\"` instead of filtering on `author = 'Jeremy Gibbons'` which assumes a non-existent combined name column. Do select `t3.title` with proper table qualification instead of selecting `title` without table reference. The amended query now correctly retrieves paper titles by joining through the authorship relationship table rather than relying on a non-existent author column in the papers table."
        ],
        "rules": [
            "1) When the question asks for papers by an author: join authors table as T1, authorship table as T2 on T1.authid = T2.authid, and papers table as T3 on T2.paperid = T3.paperid instead of querying papers directly. 2) When filtering for author \"Jeremy Gibbons\": use separate conditions T1.fname = \"Jeremy\" and T1.lname = \"Gibbons\" instead of a combined author column that doesn't exist. 3) When selecting paper titles: use T3.title with proper table qualification instead of unqualified title. 4) When combining tables for authorship relationships: perform inner joins using the exact key equalities T1.authid = T2.authid and T2.paperid = T3.paperid to ensure proper relationship matching."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM papers WHERE author = 'Jeremy Gibbons';",
            "SELECT t3.title \nFROM authors AS t1 \nJOIN authorship AS t2 ON t1.authID = t2.authID \nJOIN papers AS t3 ON t2.paperID = t3.paperID \nWHERE t1.fname = 'Jeremy' AND t1.lname = 'Gibbons'"
        ],
        "rule_sql": [
            "SELECT T3.title \nFROM Authors AS T1\nINNER JOIN Authorship AS T2 ON T1.authID = T2.authID\nINNER JOIN Papers AS T3 ON T2.paperID = T3.paperID\nWHERE T1.fname = 'Jeremy' AND T1.lname = 'Gibbons'"
        ]
    },
    "2519": {
        "db_id": "movie_1",
        "question": "For each movie that received more than 3 reviews, what is the average rating?",
        "ground_truth": "SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  2",
        "amends": [
            "Do use `mID` instead of `movie_id` for the grouping column and `avg(stars)` instead of `AVG(rating) as average_rating` for the aggregate expression. Do change the HAVING condition to `count(*) >= 2` instead of `COUNT(*) > 3` to include movies with exactly 2 reviews. The amended query now correctly filters for movies with at least 2 ratings using the appropriate column names and aggregation logic."
        ],
        "rules": [
            "1) When answering about \"average rating per movie\": make sure the output order: mID, avg(stars)\n2) When the question mentions \"movie\": \"movie\" actually means \"mID in schema\"\n3) When the question asks for \"average rating\": use avg(stars) as the aggregate expression\n4) When the question asks for \"movies that received more than 3 reviews\": use count(*) >= 2 as the filtering condition to include movies with exactly 2 reviews\n5) When grouping by movie: organize results by mID and compute requested aggregates per group"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT movie_id, AVG(rating) as average_rating\nFROM reviews\nGROUP BY movie_id\nHAVING COUNT(*) > 3;",
            "SELECT mID, AVG(stars) as average_rating FROM Rating GROUP BY mID HAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT mID, AVG(stars) \nFROM Rating \nGROUP BY mID \nHAVING COUNT(*) >= 2"
        ]
    },
    "221": {
        "db_id": "book_2",
        "question": "List the publication dates of publications with 3 lowest prices.",
        "ground_truth": "SELECT Publication_Date FROM publication ORDER BY Price ASC LIMIT 3",
        "amends": [
            "Do reference the table as `publication` instead of `publications` and use the correct column name `Publication_Date` instead of `publication_date` while maintaining the `Price` column in the ORDER BY clause instead of `price` to ensure proper case sensitivity and accurate table/column references."
        ],
        "rules": [
            "1) When answering about \"publication dates of publications with 3 lowest prices\": make sure the output order: \"Publication_Date\" 2) When the question mentions \"publications\": \"publications\" actually means \"publication\" in schema 3) When the question mentions \"lowest prices\" or an explicit 3 by \"Price\": rank rows by \"Price\" in ascending direction and keep the first 3 rows. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for column names like \"Publication_Date\" and \"Price\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT publication_date FROM publications ORDER BY price ASC LIMIT 3;",
            "SELECT Publication_Date FROM publication ORDER BY Price ASC LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT \"Publication_Date\" FROM \"publication\" ORDER BY \"Price\" ASC LIMIT 3"
        ]
    },
    "3085": {
        "db_id": "loan_1",
        "question": "What is the average credit score for customers who have never taken a loan?",
        "ground_truth": "SELECT avg(credit_score) FROM customer WHERE cust_id NOT IN (SELECT cust_id FROM loan)",
        "amends": [
            "Do reference table `customer` instead of `customers` and column `cust_id` instead of `customer_id` in the main query. Do reference table `loan` instead of `loans` and column `cust_id` instead of `customer_id` in the subquery. Do use lowercase `avg` instead of uppercase `AVG` for the aggregate function. The amended query now correctly calculates the average credit score for customers who have not taken any loans using the proper table and column names."
        ],
        "rules": [
            "1) When answering about \"average credit score for customers who have never taken a loan\": make sure the output order: avg(credit_score). 2) When the question mentions \"customers\": \"customers\" actually means table \"customer\" in schema. 3) When the question mentions \"customer_id\": \"customer_id\" actually means column \"cust_id\" in schema. 4) When the question mentions \"loans\": \"loans\" actually means table \"loan\" in schema. 5) When computing average credit score: use lowercase \"avg\" function on \"credit_score\" column. 6) When identifying customers without loans: use condition where \"cust_id\" from customer table is not in the set of \"cust_id\" values from loan table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(credit_score) FROM customers WHERE customer_id NOT IN (SELECT customer_id FROM loans);",
            "SELECT avg(credit_score) FROM customer WHERE cust_id NOT IN (SELECT cust_id FROM loan)"
        ],
        "rule_sql": [
            "SELECT AVG(credit_score) FROM customer WHERE cust_ID NOT IN (SELECT cust_ID FROM loan)"
        ]
    },
    "2697": {
        "db_id": "storm_record",
        "question": "Return the names of all regions other than Denmark.",
        "ground_truth": "SELECT region_name FROM region WHERE region_name != 'Denmark'",
        "amends": [
            "Do select `region_name` instead of `name` and use `region` table instead of `regions`. Do filter with `!= 'Denmark'` instead of `= 'Denmark'` to exclude rather than include Denmark. The amended query now correctly selects from the proper table with the intended exclusion logic."
        ],
        "rules": [
            "1) When the question asks for region names: use the exact column token \"region_name\" from the \"region\" table. 2) When the question specifies excluding Denmark: filter using the exact literal 'Denmark' with the inequality operator (!=) rather than equality. 3) When selecting from the region table: use the exact table name \"region\" (not \"regions\") as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM regions WHERE name = 'Denmark';",
            "SELECT region_name FROM region WHERE region_name != 'Denmark';"
        ],
        "rule_sql": [
            "SELECT region_name FROM region WHERE region_name != 'Denmark';"
        ]
    },
    "5356": {
        "db_id": "tracking_software_problems",
        "question": "Find all the ids and dates of the logs for the problem whose id is 10.",
        "ground_truth": "SELECT problem_log_id ,  log_entry_date FROM problem_log WHERE problem_id = 10",
        "amends": [
            "Do use column names `problem_log_id` and `log_entry_date` instead of `id` and `date`. Do reference table `problem_log` instead of `logs` while keeping the same `WHERE` filter on `problem_id = 10`. The amended query now correctly selects the appropriate columns from the proper table while maintaining the same filtering logic."
        ],
        "rules": [
            "1) When the question asks for \"ids and dates of the logs\": use column names \"problem_log_id\" and \"log_entry_date\" exactly as specified in the schema. 2) When referencing the table containing log information: use table name \"Problem_Log\" instead of \"logs\". 3) When filtering for a specific problem with id 10: apply the condition \"problem_id = 10\" to select only records related to problem id 10."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, date FROM logs WHERE problem_id = 10;",
            "SELECT problem_log_id, log_entry_date FROM Problem_Log WHERE problem_id = 10;"
        ],
        "rule_sql": [
            "SELECT problem_log_id, log_entry_date FROM Problem_Log WHERE problem_id = 10;"
        ]
    },
    "6275": {
        "db_id": "city_record",
        "question": "Find the city that hosted the most events.",
        "ground_truth": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.city` instead of `city` and remove the `event_count` alias instead of keeping it. Do join `city AS T1` with `hosting_city AS T2` on `T1.city_id = T2.host_city` instead of querying `events` table alone. Do group by `T2.host_city` instead of `city` and order by `count(*) DESC` instead of `event_count ASC`. The amended query now correctly identifies cities from the city table joined with hosting data and finds the city with the highest event count instead of the lowest, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"city that hosted the most events\": make sure the output order: T1.city, count(*) 2) When the question mentions \"city\": \"city\" actually means \"T1.city\" in schema 3) When the question mentions \"most events\": rank rows by count(*) in descending direction and keep the first 1 row 4) When combining T1 and T2 for shared entities: link rows where T1.city_id = T2.host_city exactly as shown in the amends; keep only matching pairs (inner match) 5) When the question asks for \"count of events\": compute the number of rows using the canonical key token for events (e.g., T2.host_city) 6) When the question says \"by city\": organize results by T2.host_city and compute requested aggregates per group"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, COUNT(*) as event_count FROM events GROUP BY city ORDER BY event_count ASC LIMIT 1;",
            "SELECT T1.City\nFROM city AS T1\nJOIN hosting_city AS T2 ON T1.City_ID = T2.Host_City\nGROUP BY T2.Host_City\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.City, COUNT(*) \nFROM city T1 \nJOIN hosting_city T2 ON T1.City_ID = T2.Host_City \nGROUP BY T2.Host_City \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ]
    },
    "2702": {
        "db_id": "storm_record",
        "question": "Show the average and maximum damage for all storms with max speed higher than 1000.",
        "ground_truth": "SELECT avg(damage_millions_USD) ,  max(damage_millions_USD) FROM storm WHERE max_speed  >  1000",
        "amends": [
            "Do reference the correct table name `storm` instead of `storms` and use the accurate column name `damage_millions_USD` instead of `damage` for both aggregate functions, while maintaining the same filter condition `max_speed > 1000`. The amended query now correctly calculates averages and maximums from the appropriate damage column in the proper table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"average and maximum damage for storms with max speed higher than 1000\": make sure the output order: AVG(damage_millions_USD), MAX(damage_millions_USD) 2) When the question mentions \"storms\": \"storms\" actually means \"storm\" in schema 3) When the question mentions \"damage\": \"damage\" actually means \"damage_millions_USD\" in schema 4) When filtering for max speed higher than 1000: use the condition max_speed > 1000"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(damage), MAX(damage) FROM storms WHERE max_speed > 1000",
            "SELECT AVG(Damage_millions_USD) AS average_damage, MAX(Damage_millions_USD) AS maximum_damage FROM storm WHERE Max_speed > 1000"
        ],
        "rule_sql": [
            "SELECT AVG(Damage_millions_USD) AS \"AVG(damage_millions_USD)\", MAX(Damage_millions_USD) AS \"MAX(damage_millions_USD)\" FROM storm WHERE Max_speed > 1000"
        ]
    },
    "3023": {
        "db_id": "loan_1",
        "question": "What are the names of the different customers who have taken out a loan, ordered by the total amount that they have taken?",
        "ground_truth": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id GROUP BY T1.cust_name ORDER BY sum(T2.amount)",
        "amends": [
            "Do reference `T1.cust_name` with table alias instead of `customer_name` without qualification. Do join `loan AS T2` instead of querying only the `customers` table. Do add the join condition `ON T1.cust_id = T2.cust_id` instead of omitting any join predicate. Do aggregate `sum(T2.amount)` instead of `SUM(loan_amount)` with different column reference. Do group by `T1.cust_name` instead of omitting GROUP BY clause. Do order by the aggregate expression `sum(T2.amount)` directly instead of ordering by the alias `total_amount`. The amended query now correctly joins customer and loan data, properly aggregates loan amounts per customer, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"names of different customers who have taken out a loan\": make sure the output order: T1.cust_name, sum(T2.amount). 2) When the question mentions \"customers who have taken out a loan\": combine T1 (customers) and T2 (loan) where T1.cust_id = T2.cust_id and keep only matching pairs (inner match). 3) When the question asks for \"total amount that they have taken\": compute sum(T2.amount) per customer instead of SUM(loan_amount). 4) When the question says \"ordered by the total amount\": rank rows by sum(T2.amount) in descending direction. 5) When the question asks for \"different customers\": organize results by T1.cust_name and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name, SUM(loan_amount) as total_amount\nFROM customers\nORDER BY total_amount DESC;",
            "SELECT T1.cust_name\nFROM customer AS T1\nJOIN loan AS T2 ON T1.cust_ID = T2.cust_ID\nGROUP BY T1.cust_name\nORDER BY SUM(T2.amount) DESC;"
        ],
        "rule_sql": [
            "SELECT T1.cust_name, SUM(T2.amount) \nFROM customer T1 \nINNER JOIN loan T2 ON T1.cust_ID = T2.cust_ID \nGROUP BY T1.cust_name \nORDER BY SUM(T2.amount) DESC"
        ]
    },
    "1044": {
        "db_id": "phone_1",
        "question": "Find the accreditation level that more than 3 phones use.",
        "ground_truth": "SELECT Accreditation_level FROM phone GROUP BY Accreditation_level HAVING count(*)  >  3",
        "amends": [
            "Do reference the table as `phone` instead of `phones` to match the correct table name. Do use the column name `Accreditation_level` with proper capitalization instead of `accreditation_level` to maintain case sensitivity. Do maintain the same GROUP BY clause with `Accreditation_level` instead of `accreditation_level` for consistency. Do preserve the HAVING condition `count(*) > 3` exactly as written instead of using different spacing. The amended query now correctly references the intended table and column names while maintaining the same filtering logic."
        ],
        "rules": [
            "1) When the question mentions \"phones\": \"phones\" actually means \"phone\" in schema. 2) When the question mentions \"accreditation level\": \"accreditation level\" actually means \"Accreditation_level\" in schema with exact case sensitivity. 3) When the question asks for \"more than 3 phones use\": group by Accreditation_level and count rows where count is greater than 3."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT accreditation_level FROM phones GROUP BY accreditation_level HAVING COUNT(*) > 3;",
            "SELECT Accreditation_level FROM phone GROUP BY Accreditation_level HAVING COUNT(*) > 3"
        ],
        "rule_sql": [
            "SELECT Accreditation_level FROM phone GROUP BY Accreditation_level HAVING COUNT(*) > 3"
        ]
    },
    "4395": {
        "db_id": "tracking_grants_for_research",
        "question": "List the description of the outcomes for all projects.",
        "ground_truth": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code",
        "amends": [
            "Do specify explicit columns `T1.outcome_description` instead of selecting all columns with `*`. Do add table sources `Research_outcomes AS T1` and `Project_outcomes AS T2` with a `JOIN` instead of querying only `outcomes`. Do add join condition `ON T1.outcome_code = T2.outcome_code` instead of having no join predicate. The amended query now correctly retrieves outcome descriptions by joining the research and project outcomes tables on their matching outcome codes."
        ],
        "rules": [
            "1) When answering about \"description of the outcomes for all projects\": make sure the output order: T1.outcome_description. 2) When combining Research_outcomes as T1 and Project_outcomes as T2: link rows where T1.outcome_code = T2.outcome_code exactly and keep only matching pairs (inner match). 3) When selecting columns: explicitly specify T1.outcome_description instead of using * to select all columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM outcomes;",
            "SELECT T1.outcome_description \nFROM Research_Outcomes AS T1 \nJOIN Project_Outcomes AS T2 ON T1.outcome_code = T2.outcome_code"
        ],
        "rule_sql": [
            "SELECT T1.outcome_description FROM Research_Outcomes AS T1 INNER JOIN Project_Outcomes AS T2 ON T1.outcome_code = T2.outcome_code ORDER BY T1.outcome_description;"
        ]
    },
    "625": {
        "db_id": "store_1",
        "question": "List name of all tracks in Balls to the Wall.",
        "ground_truth": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = \"Balls to the Wall\";",
        "amends": [
            "Do use `JOIN` with `albums AS T1` and `tracks AS T2` instead of a subquery. Do specify the join condition `ON T1.id = T2.genre_id` instead of filtering by `album_id`. Do select `T2.name` from the joined table instead of just `name` from tracks. Do use double quotes for the string literal \"Balls to the Wall\" instead of single quotes. The amended query now correctly joins albums and tracks tables on the appropriate relationship and matches the RIGHT_SQL's behavior.",
            "Do join on `T1.id = T2.genre_id` instead of `T1.id = T2.album_id` to correctly relate albums to tracks by genre rather than album association. The amended query now matches RIGHT_SQL's behavior by fixing the join predicate to use the appropriate foreign key relationship."
        ],
        "rules": [
            "1) When answering about \"tracks in Balls to the Wall\": use albums as T1 and tracks as T2. 2) When combining T1 and T2 for shared entities: link rows where T1.id = T2.genre_id exactly as shown in the amends; keep only matching pairs (inner match). 3) When filtering for the album \"Balls to the Wall\": use the exact string literal \"Balls to the Wall\" with double quotes. 4) When selecting track names: select T2.name from the joined table instead of just name from tracks.",
            "1) When joining albums table (T1) with tracks table (T2): use the join condition T1.id = T2.genre_id instead of T1.id = T2.album_id to correctly relate albums to tracks by genre association. 2) When filtering for the album title \"Balls to the Wall\": use the exact literal \"Balls to the Wall\" with double quotes as shown in the query. 3) When selecting track names from the tracks table: output the name column from T2 as specified in the SELECT clause."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM tracks WHERE album_id = (SELECT album_id FROM albums WHERE title = 'Balls to the Wall');",
            "SELECT T2.name \nFROM albums AS T1 \nJOIN tracks AS T2 ON T1.id = T2.album_id \nWHERE T1.title = \"Balls to the Wall\"",
            "SELECT T2.name \nFROM albums AS T1 \nJOIN tracks AS T2 ON T1.id = T2.genre_id \nWHERE T1.title = \"Balls to the Wall\""
        ],
        "rule_sql": [
            "SELECT T2.name \nFROM albums AS T1 \nINNER JOIN tracks AS T2 ON T1.id = T2.genre_id \nWHERE T1.title = \"Balls to the Wall\""
        ]
    },
    "6415": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "Show the ids for projects with at least 2 documents.",
        "ground_truth": "SELECT project_id FROM Documents GROUP BY project_id HAVING count(*)  >=  2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT project_id FROM documents GROUP BY project_id HAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT Project_ID\nFROM Documents\nGROUP BY Project_ID\nHAVING COUNT(Document_ID) >= 2;"
        ]
    },
    "3989": {
        "db_id": "hospital_1",
        "question": "Which physicians are affiliated with either Surgery or Psychiatry department? Give me their names.",
        "ground_truth": "SELECT T1.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T3.name  =  'Surgery' OR T3.name  =  'Psychiatry'",
        "amends": [
            "Do select `T1.name` from the `physician` table instead of `name` from `physicians`. Do join `affiliated_with AS T2` on `T1.EmployeeID = T2.physician` instead of omitting this table and join condition. Do join `department AS T3` on `T2.department = T3.DepartmentID` instead of omitting this table and join. Do use `WHERE T3.name = 'Surgery' OR T3.name = 'Psychiatry'` instead of `WHERE department = 'Surgery' AND department = 'Psychiatry'` to correctly find physicians affiliated with either department rather than incorrectly requiring both departments simultaneously. The amended query now correctly identifies physicians affiliated with either Surgery or Psychiatry departments through proper table relationships."
        ],
        "rules": [
            "1) When answering about physicians affiliated with departments: select \"T1.name\" from the \"physician\" table as T1. 2) When combining physician and affiliated_with tables: link rows where \"T1.EmployeeID\" equals \"T2.physician\" and keep only matching pairs. 3) When combining affiliated_with and department tables: link rows where \"T2.department\" equals \"T3.DepartmentID\" and keep only matching pairs. 4) When filtering for Surgery or Psychiatry departments: use \"T3.name = 'Surgery' OR T3.name = 'Psychiatry'\" to find physicians affiliated with either department. 5) When the question asks for physician names: output \"T1.name\" as the result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM physicians WHERE department = 'Surgery' AND department = 'Psychiatry';",
            "SELECT T1.Name \nFROM Physician AS T1\nJOIN Affiliated_With AS T2 ON T1.EmployeeID = T2.Physician\nJOIN Department AS T3 ON T2.Department = T3.DepartmentID\nWHERE T3.Name = 'Surgery' OR T3.Name = 'Psychiatry'"
        ],
        "rule_sql": [
            "SELECT T1.Name \nFROM Physician AS T1\nJOIN Affiliated_With AS T2 ON T1.EmployeeID = T2.Physician\nJOIN Department AS T3 ON T2.Department = T3.DepartmentID\nWHERE T3.Name = 'Surgery' OR T3.Name = 'Psychiatry'"
        ]
    },
    "6156": {
        "db_id": "music_4",
        "question": "Return the categories of music festivals that have the result \"Awarded\".",
        "ground_truth": "SELECT Category FROM music_festival WHERE RESULT  =  \"Awarded\"",
        "amends": [
            "Do reference the table as `music_festival` instead of `music_festivals` to match the correct table name. Do use column name `Category` instead of `category` to maintain proper case sensitivity. Do use double quotes `\"Awarded\"` instead of single quotes `'Awarded'` for the string literal. The amended query now correctly selects from the proper table with the appropriate column naming and string formatting to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks about categories of music festivals: use the exact column name \"Category\" from table \"music_festival\" 2) When filtering for festivals with result \"Awarded\": use the exact string literal \"Awarded\" with double quotes 3) When referencing the music festival table: use the exact table name \"music_festival\" (singular) not \"music_festivals\" (plural)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT category FROM music_festivals WHERE result = 'Awarded'",
            "SELECT Category FROM music_festival WHERE Result = \"Awarded\";"
        ],
        "rule_sql": [
            "SELECT Category FROM music_festival WHERE Result = \"Awarded\";"
        ]
    },
    "4658": {
        "db_id": "college_3",
        "question": "What is the name of the department in the Building Mergenthaler?",
        "ground_truth": "SELECT DName FROM DEPARTMENT WHERE Building  =  \"Mergenthaler\"",
        "amends": [
            "Do reference column `DName` instead of `department_name` and table `DEPARTMENT` instead of `departments`. Do use double quotes `\"Mergenthaler\"` instead of single quotes `'Mergenthaler'` for the string literal. The amended query now correctly matches the RIGHT_SQL's behavior with the proper column and table names."
        ],
        "rules": [
            "1) When the question asks for department names: use column \"DName\" from table \"DEPARTMENT\" instead of \"department_name\" from \"departments\". 2) When filtering for building \"Mergenthaler\": use the exact literal \"Mergenthaler\" with double quotes instead of single quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department_name FROM departments WHERE building = 'Mergenthaler';",
            "SELECT DName FROM Department WHERE Building = \"Mergenthaler\";"
        ],
        "rule_sql": [
            "SELECT DName FROM Department WHERE Building = \"Mergenthaler\";"
        ]
    },
    "1366": {
        "db_id": "college_2",
        "question": "Find the id of instructors who taught a class in Fall 2009 but not in Spring 2010.",
        "ground_truth": "SELECT id FROM teaches WHERE semester  =  'Fall' AND YEAR  =  2009 EXCEPT SELECT id FROM teaches WHERE semester  =  'Spring' AND YEAR  =  2010",
        "amends": [
            "Do use `id` instead of `instructor_id` in the SELECT clause and both parts of the set operation. Do use `EXCEPT` instead of `NOT IN` with a subquery for the set difference operation. Do remove the redundant table alias references in the column selections. Do maintain the same filter conditions for semester and year in both query parts, but use the correct column name `id` throughout instead of `instructor_id`. The amended query now correctly identifies instructors who taught in Fall 2009 but not in Spring 2010 using proper set operations."
        ],
        "rules": [
            "1) When the question asks for \"id of instructors\": use the exact column name \"id\" instead of \"instructor_id\" in both SELECT clauses and set operations. 2) When performing set difference operations to find instructors who taught in one semester but not another: use EXCEPT operation instead of NOT IN with subqueries. 3) When filtering for Fall 2009 and Spring 2010 semesters: maintain the exact filter conditions \"semester = 'Fall' AND year = 2009\" and \"semester = 'Spring' AND year = 2010\" in both parts of the set operation. 4) When selecting columns in set operations: do not use redundant table alias references in column selections."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT instructor_id FROM teaches WHERE semester = 'Fall' AND year = 2009 AND instructor_id NOT IN (SELECT instructor_id FROM teaches WHERE semester = 'Spring' AND year = 2010);",
            "SELECT id FROM teaches WHERE semester = 'Fall' AND year = 2009\nEXCEPT\nSELECT id FROM teaches WHERE semester = 'Spring' AND year = 2010"
        ],
        "rule_sql": [
            "SELECT id FROM teaches WHERE semester = 'Fall' AND year = 2009\nEXCEPT\nSELECT id FROM teaches WHERE semester = 'Spring' AND year = 2010"
        ]
    },
    "631": {
        "db_id": "store_1",
        "question": "List the name of tracks belongs to genre Rock or media type is MPEG audio file.",
        "ground_truth": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = \"Rock\" OR T3.name = \"MPEG audio file\";",
        "amends": [
            "Do use explicit table joins with `genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id` and `media_types AS T3 ON T3.id = T2.media_type_id` instead of querying only the `tracks` table. Do reference columns through proper table aliases as `T2.name` instead of just `name`. Do filter on `T1.name = \"Rock\"` instead of `genre = 'Rock'` to use the genre name from the genres table. Do filter on `T3.name = \"MPEG audio file\"` instead of `media_type = 'MPEG audio file'` to use the media type name from the media_types table. The amended query now correctly joins related tables and matches the intended behavior by properly linking tracks to their genre and media type metadata."
        ],
        "rules": [
            "1) When answering about tracks belonging to genres or media types: join tables using genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id and media_types AS T3 ON T3.id = T2.media_type_id to properly link metadata. 2) When the question mentions \"genre Rock\": \"Rock\" actually means T1.name = \"Rock\" in the genres table. 3) When the question mentions \"media type MPEG audio file\": \"MPEG audio file\" actually means T3.name = \"MPEG audio file\" in the media_types table. 4) When selecting track names: use T2.name as the output column with proper table alias. 5) When combining tables for shared entities: perform inner matches using the exact key equalities T1.id = T2.genre_id and T3.id = T2.media_type_id to keep only matching pairs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM tracks WHERE genre = 'Rock' OR media_type = 'MPEG audio file';",
            "SELECT T2.name \nFROM genres AS T1 \nJOIN tracks AS T2 ON T1.id = T2.genre_id \nJOIN media_types AS T3 ON T3.id = T2.media_type_id \nWHERE T1.name = \"Rock\" OR T3.name = \"MPEG audio file\""
        ],
        "rule_sql": [
            "SELECT T2.name \nFROM genres AS T1 \nJOIN tracks AS T2 ON T1.id = T2.genre_id \nJOIN media_types AS T3 ON T3.id = T2.media_type_id \nWHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file'"
        ]
    },
    "3039": {
        "db_id": "loan_1",
        "question": "What are the names of customers who do not have saving accounts?",
        "ground_truth": "SELECT cust_name FROM customer EXCEPT SELECT cust_name FROM customer WHERE acc_type  =  'saving'",
        "amends": [
            "Do select `cust_name` from `customer` instead of `name` from `customers`. Do use `EXCEPT` to exclude records with `acc_type = 'saving'` instead of filtering with `account_type != 'saving'`. Do reference the correct table name `customer` instead of `customers` and column names `cust_name` and `acc_type` instead of `name` and `account_type`. The amended query now correctly uses set operations to exclude saving account customers rather than potentially missing null values with inequality filtering, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for customer names: use the exact column token \"cust_name\" from the \"customer\" table instead of \"name\" from \"customers\". 2) When excluding customers with saving accounts: use set operations (EXCEPT) to exclude records where \"acc_type\" equals 'saving' instead of inequality filtering, to properly handle potential null values. 3) When referencing table and column names: use the exact identifiers \"customer\" (table), \"cust_name\" (column), and \"acc_type\" (column) as shown in the schema, not \"customers\", \"name\", or \"account_type\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM customers WHERE account_type != 'saving'",
            "SELECT cust_name FROM customer EXCEPT SELECT cust_name FROM customer WHERE acc_type = 'saving'"
        ],
        "rule_sql": [
            "SELECT cust_name FROM customer EXCEPT SELECT cust_name FROM customer WHERE acc_type = 'saving'"
        ]
    },
    "2533": {
        "db_id": "county_public_safety",
        "question": "Count the number of countries.",
        "ground_truth": "SELECT count(*) FROM county_public_safety",
        "amends": [
            "Do query the `county_public_safety` table instead of the `cities` table, as the data source has been changed to match the intended dataset. The amended query now correctly counts records from the county public safety data instead of city data, ensuring the results reflect the appropriate domain context."
        ],
        "rules": [
            "1) When counting the number of countries: query the \"county_public_safety\" table instead of the \"cities\" table to match the intended dataset domain context. 2) When the question asks for \"count of countries\": compute the number of rows from the \"county_public_safety\" table using the appropriate counting method for the domain."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities;",
            "SELECT COUNT(*) FROM county_public_safety;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM county_public_safety;"
        ]
    },
    "4665": {
        "db_id": "college_3",
        "question": "Find the last name of female (sex is F) students in the descending order of age.",
        "ground_truth": "SELECT LName FROM STUDENT WHERE Sex  =  \"F\" ORDER BY Age DESC",
        "amends": [
            "Do use column name `LName` instead of `last_name` and table name `STUDENT` instead of `students`. Do filter for `Sex = \"F\"` instead of `sex = 'M'` to select female students rather than male. Do order by `Age DESC` instead of `age ASC` to sort in descending order by age rather than ascending. The amended query now correctly selects female students' last names sorted by age in descending order, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"last name\": use the exact column name \"LName\" from the STUDENT table. 2) When filtering for female students: use the condition Sex = \"F\" exactly as specified. 3) When ordering by age in descending order: sort by Age column in descending direction. 4) When choosing table names: use the exact table name \"STUDENT\" instead of \"students\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM students WHERE sex = 'M' ORDER BY age ASC;",
            "SELECT LName FROM Student WHERE Sex = 'F' ORDER BY Age DESC;"
        ],
        "rule_sql": [
            "SELECT LName FROM Student WHERE Sex = 'F' ORDER BY Age DESC;"
        ]
    },
    "1367": {
        "db_id": "college_2",
        "question": "What are the ids of instructors who taught in the Fall of 2009 but not in the Spring of 2010?",
        "ground_truth": "SELECT id FROM teaches WHERE semester  =  'Fall' AND YEAR  =  2009 EXCEPT SELECT id FROM teaches WHERE semester  =  'Spring' AND YEAR  =  2010",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT i.id \nFROM instructor i \nJOIN teaches t ON i.id = t.id \nWHERE t.semester = 'Fall' AND t.year = 2009 \nAND i.id NOT IN (\n    SELECT i2.id \n    FROM instructor i2 \n    JOIN teaches t2 ON i2.id = t2.id \n    WHERE t2.semester = 'Spring' AND t2.year = 2010\n)"
        ],
        "rule_sql": [
            "SELECT DISTINCT t.ID\nFROM teaches t\nJOIN section s ON t.course_id = s.course_id AND t.sec_id = s.sec_id AND t.semester = s.semester AND t.year = s.year\nWHERE s.semester = 'Fall' AND s.year = 2009\nEXCEPT\nSELECT DISTINCT t.ID\nFROM teaches t\nJOIN section s ON t.course_id = s.course_id AND t.sec_id = s.sec_id AND t.semester = s.semester AND t.year = s.year\nWHERE s.semester = 'Spring' AND s.year = 2010;"
        ]
    },
    "3603": {
        "db_id": "music_1",
        "question": "What are the shortest duration and lowest rating of songs grouped by genre and ordered by genre?",
        "ground_truth": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is",
        "amends": [
            "Do use `MIN(duration)` and `MIN(rating)` instead of `MAX(duration)` and `MAX(rating)` to find the shortest duration and lowest rating. Do join `files AS T1` with `song AS T2` on `T1.f_id = T2.f_id` instead of querying a single `songs` table. Do group by `T2.genre_is` instead of `genre` to match the correct column name. Do select `T2.genre_is` instead of `genre` to include the grouping column in the output. Do order by `T2.genre_is` instead of `genre` to maintain consistency with the grouping column. The amended query now correctly calculates minimum values through proper table joins and matches the RIGHT_SQL's behavior.",
            "Do place the `T2.genre_is` column at the end of the SELECT list instead of at the beginning, and do remove the explicit aliases `shortest_duration` and `lowest_rating` instead of keeping them, while maintaining the same `MIN` aggregate functions and identical FROM clause with JOIN on `T1.f_id = T2.f_id`, GROUP BY `T2.genre_is`, and ORDER BY `T2.genre_is`. The amended query now matches RIGHT_SQL's behavior with equivalent logic and results."
        ],
        "rules": [
            "1) When answering about shortest duration and lowest rating of songs grouped by genre: use MIN(duration) and MIN(rating) instead of MAX(duration) and MAX(rating) to find the minimum values. 2) When combining files and song tables: join files AS T1 with song AS T2 on T1.f_id = T2.f_id instead of querying a single songs table. 3) When grouping by genre: group by T2.genre_is instead of genre to match the correct column name. 4) When selecting output columns: include T2.genre_is instead of genre to show the grouping column. 5) When ordering results: order by T2.genre_is instead of genre to maintain consistency with the grouping column.",
            "1) When answering about \"shortest duration and lowest rating of songs grouped by genre\": make sure the output order: MIN(T1.duration), MIN(T2.rating), T2.genre_is 2) When the question asks for \"shortest duration\": compute the minimum value of T1.duration 3) When the question asks for \"lowest rating\": compute the minimum value of T2.rating 4) When the question says \"grouped by genre\": organize results by T2.genre_is and compute aggregates per group 5) When the question says \"ordered by genre\": sort the final results by T2.genre_is 6) When combining files as T1 and song as T2: link rows where T1.f_id = T2.f_id and keep only matching pairs (inner match)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT genre, MAX(duration) as shortest_duration, MAX(rating) as lowest_rating FROM songs GROUP BY genre ORDER BY genre;",
            "SELECT T2.genre_is, MIN(T1.duration) AS shortest_duration, MIN(T2.rating) AS lowest_rating FROM files AS T1 JOIN song AS T2 ON T1.f_id = T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is",
            "SELECT MIN(T1.duration), MIN(T2.rating), T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id = T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is"
        ],
        "rule_sql": [
            "SELECT MIN(T1.duration) AS shortest_duration, MIN(T2.rating) AS lowest_rating, T2.genre_is\nFROM files AS T1\nJOIN song AS T2 ON T1.f_id = T2.f_id\nGROUP BY T2.genre_is\nORDER BY T2.genre_is;"
        ]
    },
    "4164": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "Show the number of document types.",
        "ground_truth": "SELECT count(*) FROM Ref_document_types",
        "amends": [
            "Do reference the `Ref_document_types` table instead of the `documents` table, as the correct query counts records from the reference table rather than the main documents table. The amended query now matches RIGHT_SQL's behavior by correctly counting document types from the appropriate reference table."
        ],
        "rules": [
            "1) When counting document types: use the \"Ref_document_types\" table instead of the \"documents\" table to count records from the reference table. 2) When the question asks for \"number of document types\": count the records from the \"Ref_document_types\" table using the appropriate counting mechanism."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM documents;",
            "SELECT COUNT(*) AS Number_of_Document_Types FROM Ref_Document_Types;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS Number_of_Document_Types FROM Ref_Document_Types;"
        ]
    },
    "2435": {
        "db_id": "movie_1",
        "question": "What are the names of all movies directed by Steven Spielberg?",
        "ground_truth": "SELECT title FROM Movie WHERE director = 'Steven Spielberg'",
        "amends": [
            "Do reference the table as `Movie` instead of `movies` to match the correct schema naming convention, while keeping the same `SELECT title` column and `WHERE director = 'Steven Spielberg'` filter unchanged. The amended query now correctly references the intended table and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for movie names directed by a specific person: use the exact table name \"Movie\" as shown in the schema, not alternative names like \"movies\". 2) When filtering for movies directed by Steven Spielberg: use the exact literal value 'Steven Spielberg' with proper capitalization and spacing. 3) When selecting movie titles: use the column name \"title\" from the \"Movie\" table to return the requested movie names."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM movies WHERE director = 'Steven Spielberg';",
            "SELECT title FROM Movie WHERE director = 'Steven Spielberg'"
        ],
        "rule_sql": [
            "SELECT title FROM Movie WHERE director = 'Steven Spielberg';"
        ]
    },
    "2297": {
        "db_id": "entrepreneur",
        "question": "Show the investors shared by entrepreneurs that requested more than 140000 and entrepreneurs that requested less than 120000.",
        "ground_truth": "SELECT Investor FROM entrepreneur WHERE Money_Requested  >  140000 INTERSECT SELECT Investor FROM entrepreneur WHERE Money_Requested  <  120000",
        "amends": [
            "Do use `INTERSECT` to find common investors instead of multiple self-joins with complex filtering. Do reference `Investor` and `Money_Requested` columns instead of `investor_name` and `requested_amount`. Do query the `entrepreneur` table directly instead of joining through `investors` and `entrepreneur_investments` tables. Do remove the `DISTINCT` modifier since `INTERSECT` inherently returns unique results instead of keeping it. Do simplify the logic to find investors who funded both high-request (>140000) and low-request (<120000) entrepreneurs instead of the complex join pattern that may produce incorrect cross-relationships. The amended query now correctly identifies investors who appear in both conditions using set intersection logic."
        ],
        "rules": [
            "1) When the question asks for investors shared by entrepreneurs with different funding requests: use set intersection logic instead of multiple self-joins to find common investors. 2) When referencing investor names: use the exact column token \"Investor\" from the entrepreneur table instead of investor_name. 3) When referencing funding amounts: use the exact column token \"Money_Requested\" from the entrepreneur table instead of requested_amount. 4) When querying for entrepreneurs with specific funding amounts: query the entrepreneur table directly instead of joining through intermediary tables. 5) When using set operations like INTERSECT: do not include DISTINCT modifier since set operations inherently return unique results. 6) When filtering for high funding requests: use the exact condition \"Money_Requested\" > 140000. 7) When filtering for low funding requests: use the exact condition \"Money_Requested\" < 120000."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT i.investor_name\nFROM investors i\nJOIN entrepreneur_investments ei1 ON i.investor_id = ei1.investor_id\nJOIN entrepreneurs e1 ON ei1.entrepreneur_id = e1.entrepreneur_id\nJOIN entrepreneur_investments ei2 ON i.investor_id = ei2.investor_id\nJOIN entrepreneurs e2 ON ei2.entrepreneur_id = e2.entrepreneur_id\nWHERE e1.requested_amount > 140000 AND e2.requested_amount < 120000;",
            "SELECT Investor FROM entrepreneur WHERE Money_Requested > 140000\nINTERSECT\nSELECT Investor FROM entrepreneur WHERE Money_Requested < 120000"
        ],
        "rule_sql": [
            "SELECT Investor FROM entrepreneur WHERE Money_Requested > 140000\nINTERSECT\nSELECT Investor FROM entrepreneur WHERE Money_Requested < 120000"
        ]
    },
    "6795": {
        "db_id": "activity_1",
        "question": "Find the first names of the faculty members who are playing Canoeing or Kayaking.",
        "ground_truth": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'",
        "amends": [
            "Do use `DISTINCT T1.lname` instead of `first_name` to select unique last names rather than first names. Do join `Faculty AS T1` with `Faculty_participates_in AS T2` on `T1.facID = T2.facID` instead of querying only the faculty table. Do add a second join to `activity AS T3` on `T2.actid = T3.actid` instead of the incorrect `T2.actid = T2.actid` self-join condition. Do filter on `T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'` instead of directly filtering the faculty table's sport column, properly checking the activity names through the relationship tables. The amended query now correctly retrieves distinct faculty last names who participate in the specified activities through the proper table relationships.",
            "Do use lowercase `lname` instead of uppercase `Lname` in the SELECT list. Do fix the JOIN condition to `T2.actid = T3.actid` instead of the incorrect `T2.actid = T2.actid` which creates a self-join condition. The amended query now correctly joins the activity table and matches the RIGHT_SQL's behavior.",
            "Do use the correct join condition `T2.actid = T3.actid` instead of the incorrect `T2.actid = T2.actid` which creates a self-join condition that doesn't properly connect the activity table. The amended query now correctly links the Faculty_Participates_in table to the Activity table through the actid column, ensuring that faculty members are properly associated with the specified activities. This fixes the logical error where the original join condition would not return the intended results due to the incorrect table reference. The amended query now matches RIGHT_SQL's behavior.",
            "Do use `T2.actid = T2.actid` instead of `T2.actid = T3.actid` in the JOIN condition between Faculty_Participates_in and Activity tables, which creates an incorrect self-join predicate that would prevent proper table correlation. The amended query now correctly matches the intended logic by fixing the join condition to properly relate the activity IDs between the participation and activity tables.",
            "Do use the correct join condition `T2.actid = T3.actid` instead of the incorrect `T2.actid = T2.actid` which creates a self-join condition that doesn't properly connect the Faculty_Participates_in table to the Activity table. This ensures the query correctly links faculty members to their actual activities rather than creating an invalid join that would return incorrect or no results. The amended query now properly filters for faculty participating in either 'Canoeing' or 'Kayaking' activities as intended."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM faculty WHERE sport = 'Canoeing' OR sport = 'Kayaking';",
            "SELECT DISTINCT T1.Lname\nFROM Faculty AS T1\nJOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID\nJOIN Activity AS T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'",
            "SELECT DISTINCT T1.lname \nFROM Faculty AS T1\nJOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID\nJOIN Activity AS T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'",
            "SELECT DISTINCT T1.lname\nFROM Faculty AS T1\nJOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID\nJOIN Activity AS T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'",
            "SELECT DISTINCT T1.lname \nFROM Faculty AS T1\nJOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID\nJOIN Activity AS T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'",
            "SELECT DISTINCT T1.lname \nFROM Faculty AS T1\nJOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID\nJOIN Activity AS T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'"
        ],
        "rule_sql": []
    },
    "3491": {
        "db_id": "hr_1",
        "question": "display the employee ID and job name for all those jobs in department 80.",
        "ground_truth": "SELECT T1.employee_id ,  T2.job_title FROM employees AS T1 JOIN jobs AS T2 ON T1.job_id  =  T2.job_id WHERE T1.department_id = 80",
        "amends": [
            "Do add table `jobs AS T2` with a `JOIN` on `T1.job_id = T2.job_id` instead of querying only the `employees` table. Do select `T2.job_title` instead of `job_name` since the correct column comes from the joined jobs table. Do use table aliases `T1` and `T2` with qualified column names instead of unqualified references. Do keep the `WHERE T1.department_id = 80` filter unchanged as it correctly filters the employees table. The amended query now correctly joins employee data with job information and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"employee ID and job name for jobs in department 80\": make sure the output order: employee_id, job_title. 2) When the question mentions \"job name\": \"job name\" actually means \"T2.job_title in schema\". 3) When combining T1 (employees) and T2 (jobs) for shared entities: link rows where T1.job_id = T2.job_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When filtering for department 80: apply the condition T1.department_id = 80 to filter employees. 5) When using table aliases: use T1 for employees table and T2 for jobs table with qualified column names instead of unqualified references."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT employee_id, job_name FROM employees WHERE department_id = 80",
            "SELECT T1.EMPLOYEE_ID, T2.JOB_TITLE\nFROM employees AS T1\nJOIN jobs AS T2 ON T1.JOB_ID = T2.JOB_ID\nWHERE T1.DEPARTMENT_ID = 80"
        ],
        "rule_sql": [
            "SELECT T1.EMPLOYEE_ID, T2.JOB_TITLE\nFROM employees T1\nINNER JOIN jobs T2 ON T1.JOB_ID = T2.JOB_ID\nWHERE T1.DEPARTMENT_ID = 80"
        ]
    },
    "531": {
        "db_id": "allergy_1",
        "question": "Find the different first names and cities of the students who have allergy to milk or cat.",
        "ground_truth": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  \"Milk\" OR T2.Allergy  =  \"Cat\"",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of direct table names. Do select `T1.fname` and `T1.city_code` instead of `first_name` and `city`. Do add a `JOIN` with `Has_Allergy AS T2` on `T1.stuid = T2.stuid` instead of querying a single table. Do filter on `T2.Allergy` values instead of a non-existent `allergy` column in the students table. Do maintain the `DISTINCT` clause and OR condition structure but apply them to the correct joined tables and columns. The amended query now correctly retrieves student allergy information from the proper relational structure.",
            "Do use lowercase `fname` instead of uppercase `Fname` in the SELECT list. Do use lowercase `stuid` instead of uppercase `StuID` in the JOIN condition. Do use double quotes around \"Milk\" and \"Cat\" instead of single quotes around 'milk' and 'cat' in the WHERE filter to match the case-sensitive values in the database. The amended query now correctly retrieves students with milk or cat allergies using the proper case and column references."
        ],
        "rules": [
            "1) When answering about \"different first names and cities of students with allergies\": make sure the output order: T1.Fname, T1.city_code. 2) When the question mentions \"first names\": \"first names\" actually means \"T1.Fname\" in schema. 3) When the question mentions \"cities\": \"cities\" actually means \"T1.city_code\" in schema. 4) When combining Student as T1 and Has_Allergy as T2 for shared entities: link rows where T1.StuID = T2.StuID; keep only matching pairs (inner match). 5) When filtering for students with allergy to milk or cat: filter rows where T2.Allergy equals 'milk' OR T2.Allergy equals 'cat'. 6) When the question asks for \"different\" values: return only unique combinations of T1.Fname and T1.city_code.",
            "1) When selecting the first name column from the Student table: use lowercase \"fname\" instead of uppercase \"Fname\". 2) When joining Student and Has_Allergy tables: use lowercase \"stuid\" instead of uppercase \"StuID\" for the join condition T1.stuid = T2.stuid. 3) When filtering for milk or cat allergies: use double quotes around \"Milk\" and \"Cat\" instead of single quotes to match the case-sensitive values in the database. 4) When answering about students with allergies to milk or cat: retrieve distinct combinations of first names and city codes from the Student table for students who have either \"Milk\" or \"Cat\" allergy in the Has_Allergy table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT first_name, city FROM students WHERE allergy = 'milk' OR allergy = 'cat';",
            "SELECT DISTINCT T1.Fname, T1.city_code\nFROM Student AS T1\nJOIN Has_Allergy AS T2 ON T1.StuID = T2.StuID\nWHERE T2.Allergy = 'milk' OR T2.Allergy = 'cat'",
            "SELECT DISTINCT T1.fname, T1.city_code\nFROM Student AS T1\nJOIN Has_Allergy AS T2 ON T1.StuID = T2.StuID\nWHERE T2.Allergy = \"Milk\" OR T2.Allergy = \"Cat\""
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.fname, T1.city_code\nFROM Student T1\nINNER JOIN Has_Allergy T2 ON T1.stuid = T2.stuid\nWHERE T2.Allergy = \"Milk\" OR T2.Allergy = \"Cat\""
        ]
    },
    "465": {
        "db_id": "allergy_1",
        "question": "Show all majors.",
        "ground_truth": "SELECT DISTINCT Major FROM Student",
        "amends": [
            "Do select only the `Major` column instead of selecting all columns with `*`. Do use `DISTINCT` to return unique majors instead of potentially duplicate values. Do reference the table as `Student` instead of `students`. Do remove the `IS NOT NULL` filter instead of keeping it, as the DISTINCT operation inherently handles null values appropriately. The amended query now correctly returns only unique major values from the Student table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"Show all majors\": make sure the output order: Major. 2) When the question asks for \"all majors\": return only unique values of the exact token \"Major\" from table \"Student\". 3) When selecting from table \"Student\": use the exact table name \"Student\" (not \"students\"). 4) When returning unique values: do not apply any null filtering as the distinct operation inherently handles null values appropriately."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM students WHERE major IS NOT NULL;",
            "SELECT DISTINCT Major FROM Student"
        ],
        "rule_sql": [
            "SELECT DISTINCT Major FROM Student ORDER BY Major;"
        ]
    },
    "5878": {
        "db_id": "tracking_share_transactions",
        "question": "Show the id and details of the investor that has the largest number of transactions.",
        "ground_truth": "SELECT T2.investor_id ,  T1.Investor_details FROM INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id GROUP BY T2.investor_id ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do add table aliases `T1` and `T2` instead of omitting them, and do specify `T1.Investor_details` instead of just `details`. Do add `FROM INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id = T2.investor_id` instead of omitting the join and using only one table. Do add `GROUP BY T2.investor_id` instead of omitting grouping. Do change `ORDER BY COUNT(transactions)` to `ORDER BY COUNT(*)` instead of referencing a non-aggregated column. Do reference `T2.investor_id` in SELECT instead of just `investor_id` to make the column reference unambiguous. The amended query now correctly joins the tables, groups by investor, and counts transactions properly to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"largest number of transactions\": count the number of rows using the canonical key T2.investor_id for each investor group. 2) When combining tables INVESTORS and TRANSACTIONS: link rows where T1.investor_id = T2.investor_id exactly as shown and keep only matching pairs (inner match). 3) When the question asks for \"id and details\" of investors: select T2.investor_id and T1.Investor_details as the output columns. 4) When the question mentions \"largest number\": rank rows by transaction count in descending order and keep the first 1 row. 5) When grouping by investor: organize results by T2.investor_id and compute COUNT(*) per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT investor_id, details FROM investors ORDER BY COUNT(transactions) DESC LIMIT 1;",
            "SELECT T1.investor_id, T1.Investor_details\nFROM Investors AS T1\nJOIN Transactions AS T2 ON T1.investor_id = T2.investor_id\nGROUP BY T2.investor_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.investor_id, T1.Investor_details\nFROM Investors T1\nINNER JOIN Transactions T2 ON T1.investor_id = T2.investor_id\nGROUP BY T2.investor_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "1096": {
        "db_id": "match_season",
        "question": "Show the most common position of players in match seasons.",
        "ground_truth": "SELECT POSITION FROM match_season GROUP BY POSITION ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference the `match_season` table instead of the `players` table in the FROM clause. Do remove the explicit `COUNT(*) as count` column from the SELECT list instead of including it, as only the `POSITION` is needed. Do use `ORDER BY count(*) DESC` instead of `ORDER BY count DESC` to directly reference the aggregate function in the ordering rather than an alias. The amended query now correctly identifies the most frequent position from the match_season table by counting occurrences per position and ordering by the count directly, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"most common position of players in match seasons\": reference the \"match_season\" table instead of the \"players\" table. 2) When counting occurrences per position: use COUNT(*) to count all rows per position group. 3) When ordering by frequency to find the most common: order by COUNT(*) in descending order. 4) When showing only the most common position: limit the results to the top 1 row. 5) When selecting output columns: include only the \"position\" column in the final results, not the count column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT position, COUNT(*) as count FROM players GROUP BY position ORDER BY count DESC LIMIT 1;",
            "SELECT Position FROM match_season GROUP BY Position ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Position FROM match_season GROUP BY Position ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "2266": {
        "db_id": "entrepreneur",
        "question": "What are the companies of entrepreneurs, ordered descending by amount of money requested?",
        "ground_truth": "SELECT Company FROM entrepreneur ORDER BY Money_Requested DESC",
        "amends": [
            "Do reference the `Company` column instead of `company` and remove `entrepreneur` from the SELECT list instead of including it. Do use `ORDER BY Money_Requested DESC` instead of `ORDER BY money_requested ASC` to sort in descending order. Do reference the `entrepreneur` table instead of `entrepreneurs` as the source table. The amended query now correctly selects only the company names sorted by funding requests in descending order, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for companies of entrepreneurs: select only the \"Company\" column from the \"entrepreneur\" table. 2) When the question specifies ordering by amount of money requested: sort the results by \"Money_Requested\" in descending order. 3) When selecting from the entrepreneur table: use the exact table name \"entrepreneur\" (not \"entrepreneurs\"). 4) When outputting results: do not include the \"entrepreneur\" column in the output list."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT company, entrepreneur, money_requested FROM entrepreneurs ORDER BY money_requested ASC;",
            "SELECT Company FROM entrepreneur ORDER BY Money_Requested DESC;"
        ],
        "rule_sql": [
            "SELECT Company FROM entrepreneur ORDER BY Money_Requested DESC;"
        ]
    },
    "5323": {
        "db_id": "manufactory_1",
        "question": "What are the names of all products?",
        "ground_truth": "SELECT Name FROM Products",
        "amends": [
            "Do select `Name` instead of `product_id` from the `Products` table instead of `products`."
        ],
        "rules": [
            "1) When answering about \"names of all products\": make sure the output column is \"Name\" from table \"Products\". 2) When the question mentions \"products\": \"products\" actually means table \"Products\" in schema. 3) When selecting from table \"Products\": use the exact identifier \"Products\" with double quotes as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT product_id FROM products;",
            "SELECT Name FROM Products;"
        ],
        "rule_sql": [
            "SELECT \"Name\" FROM \"Products\""
        ]
    },
    "464": {
        "db_id": "allergy_1",
        "question": "How many advisors are there?",
        "ground_truth": "SELECT count(DISTINCT advisor) FROM Student",
        "amends": [
            "Do `count(DISTINCT advisor)` in the SELECT list instead of `COUNT(*)` to count distinct advisors rather than all rows. Do reference the `Student` table instead of `students` to use the correct table name. The amended query now correctly counts distinct advisor values from the Student table instead of counting all rows."
        ],
        "rules": [
            "1) When counting advisors: count distinct values of the \"advisor\" column instead of counting all rows. 2) When referencing the Student table: use the exact table name \"Student\" with proper capitalization. 3) When answering about how many advisors there are: make sure to count distinct advisor values from the Student table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;",
            "SELECT COUNT(DISTINCT Advisor) FROM Student;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Advisor) FROM Student;"
        ]
    },
    "3796": {
        "db_id": "e_learning",
        "question": "List all the information about course authors and tutors in alphabetical order of the personal name.",
        "ground_truth": "SELECT * FROM Course_Authors_and_Tutors ORDER BY personal_name",
        "amends": [
            "Do reference the table as `Course_Authors_and_Tutors` instead of `course_authors_tutors` to match the correct table name. Do remove the explicit `ASC` direction from the `ORDER BY` clause instead of keeping it, as ascending order is the default behavior. The amended query now correctly references the intended table and uses standard SQL ordering syntax, matching the behavior of the right SQL."
        ],
        "rules": [
            "1) When the question asks for information about course authors and tutors: use the exact table name \"Course_Authors_and_Tutors\" with double quotes and proper capitalization. 2) When ordering results alphabetically by personal name: sort by the \"personal_name\" column in ascending order without specifying ASC explicitly since it's the default. 3) When selecting all information from the table: use SELECT * to retrieve all columns from the \"Course_Authors_and_Tutors\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM course_authors_tutors ORDER BY personal_name ASC;",
            "SELECT * FROM Course_Authors_and_Tutors ORDER BY personal_name"
        ],
        "rule_sql": [
            "SELECT * FROM \"Course_Authors_and_Tutors\" ORDER BY \"personal_name\""
        ]
    },
    "3476": {
        "db_id": "hr_1",
        "question": "What are the employee ids for employees who make more than the average?",
        "ground_truth": "SELECT employee_id FROM employees WHERE salary  >  (SELECT AVG(salary) FROM employees)",
        "amends": [
            "Do use a scalar subquery without `GROUP BY department_id` instead of a grouped subquery that returns multiple rows, as the comparison operator `>` requires a single value. Do remove the `GROUP BY` clause from the subquery instead of grouping by department, which would cause the subquery to return multiple average values and make the comparison invalid. The amended query now correctly compares each employee's salary against the overall average salary across all departments instead of attempting to compare against multiple department averages simultaneously, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When comparing employee salaries against the average salary: use a scalar subquery that calculates the overall average salary across all employees without grouping by department_id. 2) When the question asks for employees who make more than the average: compare each employee's salary against a single average value rather than multiple department-specific averages. 3) When using comparison operators like > with subqueries: ensure the subquery returns exactly one value (scalar) rather than multiple rows that would cause the comparison to fail."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT employee_id FROM employees WHERE salary > (SELECT AVG(salary) FROM employees GROUP BY department_id)",
            "SELECT EMPLOYEE_ID FROM employees WHERE SALARY > (SELECT AVG(SALARY) FROM employees)"
        ],
        "rule_sql": [
            "SELECT EMPLOYEE_ID FROM employees WHERE SALARY > (SELECT AVG(SALARY) FROM employees)"
        ]
    },
    "4747": {
        "db_id": "department_store",
        "question": "Find the product type whose average price is higher than the average price of all products.",
        "ground_truth": "SELECT product_type_code FROM products GROUP BY product_type_code HAVING avg(product_price)  >  (SELECT avg(product_price) FROM products)",
        "amends": [
            "Do select `product_type_code` instead of `product_type` and `AVG(price)` as `avg_price`. Do use `avg(product_price)` in the HAVING clause instead of `AVG(price)`. Do reference `product_price` in the subquery instead of `price`. Do remove the ORDER BY clause instead of keeping `ORDER BY avg_price DESC`. Do omit the column alias `avg_price` instead of including it. The amended query now correctly filters product types by average price compared to the overall average without unnecessary ordering."
        ],
        "rules": [
            "1) When the question asks about \"product type\": use the exact column token \"product_type_code\" instead of \"product_type\". 2) When computing average price: use the exact column token \"product_price\" instead of \"price\". 3) When filtering product types by average price compared to overall average: compute AVG(product_price) in the HAVING clause and compare it to the subquery result of AVG(product_price) from the Products table. 4) When the question does not specify ordering: do not include any ORDER BY clause in the final output. 5) When selecting columns for output: omit column aliases like \"avg_price\" and only include the raw column names needed to answer the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT product_type, AVG(price) as avg_price\nFROM products\nGROUP BY product_type\nHAVING AVG(price) > (SELECT AVG(price) FROM products)\nORDER BY avg_price DESC;",
            "SELECT product_type_code\nFROM Products\nGROUP BY product_type_code\nHAVING AVG(product_price) > (SELECT AVG(product_price) FROM Products)"
        ],
        "rule_sql": [
            "SELECT product_type_code FROM Products GROUP BY product_type_code HAVING AVG(product_price) > (SELECT AVG(product_price) FROM Products)"
        ]
    },
    "3838": {
        "db_id": "e_learning",
        "question": "Find the student ID and personal name of the student with at least two enrollments.",
        "ground_truth": "SELECT T1.student_id ,  T2.personal_name FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING COUNT(*)  >=  2",
        "amends": [
            "Do use `T1.student_id` and `T2.personal_name` instead of `student_id` and `personal_name` without table aliases. Do join `Student_Course_Enrolment AS T1` with `Students AS T2` on `T1.student_id = T2.student_id` instead of querying only the `students` table. Do add `GROUP BY T1.student_id` instead of omitting grouping. Do move the count filter to `HAVING COUNT(*) >= 2` instead of placing it in the `WHERE` clause where aggregate functions cannot be used. The amended query now correctly identifies students with multiple course enrollments by properly aggregating and filtering the results."
        ],
        "rules": [
            "1) When answering about \"student ID and personal name\": make sure the output order: T1.student_id, T2.personal_name 2) When the question mentions \"student with at least two enrollments\": join Student_Course_Enrolment AS T1 with Students AS T2 on T1.student_id = T2.student_id instead of querying only one table 3) When counting enrollments per student: group by T1.student_id and use HAVING COUNT(*) >= 2 instead of placing aggregate conditions in WHERE clause 4) When combining T1 and T2 for shared entities: link rows where T1.student_id = T2.student_id and keep only matching pairs (inner match)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id, personal_name FROM students WHERE COUNT(enrollment_id) >= 2",
            "SELECT T1.student_id, T2.personal_name\nFROM Student_Course_Enrolment AS T1\nJOIN Students AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T1.student_id, T2.personal_name\nFROM Student_Course_Enrolment AS T1\nINNER JOIN Students AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id, T2.personal_name\nHAVING COUNT(*) >= 2;"
        ]
    },
    "6049": {
        "db_id": "game_1",
        "question": "Find the last and first name of students who are playing Football or Lacrosse.",
        "ground_truth": "SELECT T2.lname ,  T2.fname FROM SportsInfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.SportName  =  \"Football\" OR T1.SportName  =  \"Lacrosse\"",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of direct table references. Do join `SportsInfo AS T1` with `Student AS T2` on `T1.StuID = T2.StuID` instead of querying a single table. Do select `T2.lname` and `T2.fname` instead of `first_name` and `last_name`. Do filter with `T1.SportName = \"Football\" OR T1.SportName = \"Lacrosse\"` instead of the impossible `sport = 'Football' AND sport = 'Lacrosse'` condition. The amended query now correctly retrieves students who play either football or lacrosse by joining the sports information table with the student table and using an OR condition instead of a contradictory AND condition."
        ],
        "rules": [
            "1) When answering about \"students playing Football or Lacrosse\": make sure the output order: T2.lname, T2.fname 2) When the question mentions \"first name\" and \"last name\": \"first name\" actually means \"T2.fname in schema\" and \"last name\" actually means \"T2.lname in schema\" 3) When combining SportsInfo as T1 and Student as T2 for shared entities: link rows where T1.StuID = T2.StuID exactly as shown in the amends; keep only matching pairs (inner match) 4) When filtering for sports \"Football\" or \"Lacrosse\": use T1.SportName = \"Football\" OR T1.SportName = \"Lacrosse\" with exact literals \"Football\" and \"Lacrosse\" 5) When handling text literals: do not change case, spacing, or punctuation for \"Football\" and \"Lacrosse\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM students WHERE sport = 'Football' AND sport = 'Lacrosse';",
            "SELECT T2.LName, T2.Fname FROM SportsInfo AS T1 JOIN Student AS T2 ON T1.StuID = T2.StuID WHERE T1.SportName = 'Football' OR T1.SportName = 'Lacrosse'"
        ],
        "rule_sql": [
            "SELECT T2.LName, T2.Fname FROM SportsInfo AS T1 INNER JOIN Student AS T2 ON T1.StuID = T2.StuID WHERE T1.SportName = 'Football' OR T1.SportName = 'Lacrosse'"
        ]
    },
    "5376": {
        "db_id": "tracking_software_problems",
        "question": "For each product which has problems, what are the number of problems and the product id?",
        "ground_truth": "SELECT count(*) ,  T2.product_id FROM problems AS T1 JOIN product AS T2 ON T1.product_id = T2.product_id GROUP BY T2.product_id",
        "amends": [
            "Do add the `product` table with a `JOIN` on `T1.product_id = T2.product_id` instead of querying only the `problems` table. Do reference `T2.product_id` in both the SELECT list and GROUP BY clause instead of using just `product_id` from the `problems` table. Do remove the alias `problem_count` from the count aggregation instead of keeping it. The amended query now correctly joins to validate product existence and matches RIGHT_SQL's behavior.",
            "Do place `T2.product_id` after `count(*)` in the SELECT list instead of before it. Do add the `AS` keyword for table aliases by specifying `problems AS T1` and `product AS T2` instead of omitting it. The amended query now correctly matches the RIGHT_SQL's behavior with identical logic and output structure."
        ],
        "rules": [
            "1) When answering about \"products which have problems\": combine the \"problems\" table (T1) and \"product\" table (T2) by linking rows where T1.product_id equals T2.product_id, keeping only matching pairs. 2) When the question asks for \"number of problems per product\": count the number of rows using T1.product_id as the counting key and group by T2.product_id. 3) When producing output columns: include T2.product_id first, followed by the count of problems without any alias.",
            "1) When answering about \"number of problems and product id for products with problems\": make sure the output order: count(*) first, then T2.product_id. 2) When using table aliases: always specify them with the AS keyword as \"problems AS T1\" and \"product AS T2\". 3) When combining tables Problems and Product for shared entities: link rows where T1.product_id = T2.product_id and keep only matching pairs (inner match). 4) When counting problems per product: compute the number of rows using the canonical key T1.product_id for counting problems. 5) When grouping by product: organize results by T2.product_id and compute the count of problems per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT product_id, COUNT(*) as problem_count FROM problems GROUP BY product_id",
            "SELECT T2.product_id, COUNT(*) \nFROM Problems T1 \nJOIN Product T2 ON T1.product_id = T2.product_id \nGROUP BY T2.product_id",
            "SELECT count(*), T2.product_id FROM problems AS T1 JOIN product AS T2 ON T1.product_id = T2.product_id GROUP BY T2.product_id"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS count_of_problems, T2.product_id\nFROM Problems AS T1\nINNER JOIN Product AS T2 ON T1.product_id = T2.product_id\nGROUP BY T2.product_id"
        ]
    },
    "4927": {
        "db_id": "store_product",
        "question": "What is the average number of pages per minute color?",
        "ground_truth": "SELECT avg(pages_per_minute_color) FROM product",
        "amends": [
            "Do select `avg(pages_per_minute_color)` instead of `color, AVG(pages) as avg_pages`. Do query from `product` instead of `documents`. Do remove the `GROUP BY color` clause instead of including it. The amended query now correctly calculates the average pages per minute by color from the product table instead of grouping documents by color and averaging pages."
        ],
        "rules": [
            "1) When answering about \"average number of pages per minute color\": make sure the output order: avg(pages_per_minute_color). 2) When the question mentions \"pages per minute color\": \"pages per minute color\" actually means \"pages_per_minute_color in schema\". 3) When querying for average pages per minute color: use table \"product\" instead of \"documents\". 4) When computing an overall average without grouping: do not include any GROUP BY clause."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT color, AVG(pages) as avg_pages FROM documents GROUP BY color;",
            "SELECT AVG(pages_per_minute_color) FROM product;"
        ],
        "rule_sql": [
            "SELECT AVG(pages_per_minute_color) FROM product;"
        ]
    },
    "3229": {
        "db_id": "college_1",
        "question": "How many courses are offered?",
        "ground_truth": "SELECT count(DISTINCT crs_code) FROM CLASS",
        "amends": [
            "Do select `count(DISTINCT crs_code)` instead of `COUNT(*)`. Do query from `CLASS` table instead of `students` table. The amended query now correctly counts distinct course codes from the CLASS table rather than counting all rows from the students table."
        ],
        "rules": [
            "1) When counting courses: count distinct values of \"crs_code\" from the \"CLASS\" table instead of counting all rows. 2) When answering about courses: use the \"CLASS\" table instead of the \"students\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;",
            "SELECT COUNT(DISTINCT CRS_CODE) FROM CLASS;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT CRS_CODE) FROM CLASS;"
        ]
    },
    "3945": {
        "db_id": "hospital_1",
        "question": "How many medications are prescribed for each brand?",
        "ground_truth": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand",
        "amends": [
            "Do add `T1.name` in the SELECT list instead of omitting it. Do change the aggregation to `count(*)` instead of `COUNT(*)`. Do change the FROM source to `medication AS T1 JOIN prescribes AS T2` instead of just `medications`. Do add the join condition `ON T1.code = T2.medication` instead of having no join. Do change the GROUP BY to `T1.brand` instead of `brand`. The amended query now correctly joins medication and prescribes tables to count prescriptions per medication brand.",
            "Do select `count(*)` and `T1.name` instead of `T1.brand` and `count(*) AS medication_count`. Do remove the alias `medication_count` instead of keeping it. Do include `T1.name` in the SELECT list instead of omitting it while maintaining the same GROUP BY clause with `T1.brand`. The amended query now correctly returns both the count and medication name grouped by brand, matching the RIGHT_SQL's behavior.",
            "Do include `T1.name` in the SELECT list instead of omitting it, and do remove `T1.brand` from the SELECT list instead of keeping it, while maintaining the same `count(*)` aggregation. Do keep the same FROM clause with `medication AS T1` JOIN `prescribes AS T2` on `T1.code = T2.medication` instead of changing it, and do maintain the same GROUP BY `T1.brand` instead of modifying it. The amended query now correctly includes the medication name in the results while grouping by brand, matching the RIGHT_SQL's behavior.",
            "Do place `count(*)` before `T1.name` in the SELECT list instead of after it. Do group by `T1.brand` instead of `T1.name` to match the grouping column with the aggregate function. The amended query now correctly counts prescriptions grouped by medication brand rather than by medication name, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"medications prescribed for each brand\": make sure the output order: T1.brand, count(*) 2) When the question mentions \"medications are prescribed\": this requires joining medication table (T1) with prescribes table (T2) using T1.code = T2.medication 3) When grouping by medication brand: use T1.brand as the grouping key instead of just brand 4) When counting prescriptions: use count(*) to count all prescription records 5) When combining medication and prescribes tables: link rows where T1.code equals T2.medication exactly and keep only matching pairs (inner match)",
            "1) When answering about \"medications prescribed for each brand\": make sure the output order: T1.brand, count(*) 2) When the question asks for \"count of medications\": compute the number of rows using count(*) without an alias 3) When the question mentions \"each brand\": organize results by T1.brand and compute requested aggregates per group 4) When producing output: include T1.name in the SELECT list to show medication names alongside brand counts",
            "1) When answering about \"medications prescribed for each brand\": make sure the output order includes T1.name before the count. 2) When grouping by brand: use T1.brand as the grouping key and compute count(*) for each group. 3) When combining medication and prescribes tables: link rows where T1.code = T2.medication using an inner match. 4) When the question asks for \"how many medications are prescribed\": count all prescription records using count(*) while maintaining the medication name in results.",
            "1) When the question asks for \"count of medications prescribed for each brand\": compute the number of rows using the canonical key and place the count before the brand name in the output order. 2) When grouping by medication brand: organize results by the exact token \"T1.brand\" and compute the count per group. 3) When producing output columns: ensure the order is count(*) followed by T1.name (brand name)."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT brand, COUNT(*) FROM medications GROUP BY brand;",
            "SELECT T1.brand, count(*) AS medication_count\nFROM medication AS T1\nJOIN prescribes AS T2 ON T1.code = T2.medication\nGROUP BY T1.brand",
            "SELECT T1.brand, T1.name, count(*) \nFROM medication AS T1 \nJOIN prescribes AS T2 ON T1.code = T2.medication \nGROUP BY T1.brand",
            "SELECT T1.name, count(*) FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand",
            "SELECT count(*), T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand"
        ],
        "rule_sql": [
            "SELECT T1.brand, COUNT(*) \nFROM Medication T1 \nJOIN Prescribes T2 ON T1.Code = T2.Medication \nGROUP BY T1.brand \nORDER BY T1.brand, COUNT(*)"
        ]
    },
    "5155": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "How many drama workshop groups are there in each city? Return both the city and the count.",
        "ground_truth": "SELECT T1.City_Town ,  count(*) FROM Addresses AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Address_ID  =  T2.Address_ID GROUP BY T1.City_Town",
        "amends": [
            "Do select `T1.City_Town` instead of `city` and do join `Addresses AS T1` and `Drama_Workshop_Groups AS T2` with `ON T1.Address_ID = T2.Address_ID` instead of querying only `workshop_groups` with a `WHERE type = 'comedy'` filter. Do group by `T1.City_Town` instead of `city` and completely remove the `WHERE` clause instead of keeping it, as the join condition now properly filters to drama workshop groups through table relationships rather than a direct type filter. The amended query now correctly counts drama workshop groups by city through proper table joins instead of relying on a potentially incorrect type column filter."
        ],
        "rules": [
            "1) When answering about \"drama workshop groups in each city\": make sure the output order: T1.City_Town, count of drama workshop groups. 2) When the question mentions \"city\": \"city\" actually means \"T1.City_Town in schema\". 3) When combining Addresses as T1 and Drama_Workshop_Groups as T2: link rows where T1.Address_ID = T2.Address_ID and keep only matching pairs (inner match). 4) When the question asks for \"count of drama workshop groups\": compute the number of rows using the canonical key from T2 (e.g., T2's primary key). 5) When the question says \"per city\"/\"by city\": organize results by T1.City_Town and compute count per group. 6) When handling table relationships: do not use a WHERE clause filtering by type since drama workshop groups are identified through the Drama_Workshop_Groups table relationship rather than a type column filter."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, COUNT(*) FROM workshop_groups WHERE type = 'comedy' GROUP BY city;",
            "SELECT T1.City_Town, COUNT(*) AS count\nFROM Addresses AS T1\nJOIN Drama_Workshop_Groups AS T2 ON T1.Address_ID = T2.Address_ID\nGROUP BY T1.City_Town"
        ],
        "rule_sql": [
            "SELECT T1.City_Town, COUNT(T2.Workshop_Group_ID) AS count_of_drama_workshop_groups\nFROM Addresses T1\nINNER JOIN Drama_Workshop_Groups T2 ON T1.Address_ID = T2.Address_ID\nGROUP BY T1.City_Town\nORDER BY T1.City_Town, count_of_drama_workshop_groups;"
        ]
    },
    "4660": {
        "db_id": "college_3",
        "question": "What is all the information about courses, ordered by credits ascending?",
        "ground_truth": "SELECT * FROM COURSE ORDER BY Credits",
        "amends": [
            "Do reference table `COURSE` instead of `courses` to match the correct table name. Do order by `Credits` in ascending order instead of `credits DESC` to use the correct column name and remove the descending sort. Do maintain the `SELECT *` instead of changing the column selection. The amended query now correctly selects from the COURSE table and orders by the Credits column in default ascending order, matching the RIGHT_SQL behavior."
        ],
        "rules": [
            "1) When answering about \"all the information about courses\": select all columns from the \"COURSE\" table. 2) When ordering by credits: order the results by the \"Credits\" column in ascending order. 3) When referring to the courses table: use the exact table name \"COURSE\" with double quotes as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM courses ORDER BY credits DESC;",
            "SELECT * FROM Course ORDER BY Credits ASC;"
        ],
        "rule_sql": [
            "SELECT * FROM \"COURSE\" ORDER BY \"Credits\" ASC;"
        ]
    },
    "5641": {
        "db_id": "railway",
        "question": "Show the builder of railways associated with the trains named \"Andaman Exp\".",
        "ground_truth": "SELECT T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID WHERE T2.Name  =  \"Andaman Exp\"",
        "amends": [
            "Do reference `T1.Builder` instead of `builder` to specify the table alias. Do join `railway AS T1` with `train AS T2` instead of querying only `railways`. Do use the join condition `T1.Railway_ID = T2.Railway_ID` instead of no join. Do filter on `T2.Name = \"Andaman Exp\"` instead of `train_name = 'Andaman Exp'` to reference the correct table and column. The amended query now correctly retrieves the builder by joining the railway and train tables with proper relationships."
        ],
        "rules": [
            "1) When answering about \"builder of railways associated with trains\": make sure the output order: T1.Builder. 2) When combining railway table (T1) and train table (T2): link rows where T1.Railway_ID = T2.Railway_ID and keep only matching pairs (inner match). 3) When the question mentions \"trains named 'Andaman Exp'\": filter rows where T2.Name = \"Andaman Exp\" exactly as specified."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT builder FROM railways WHERE train_name = 'Andaman Exp';",
            "SELECT T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID = T2.Railway_ID WHERE T2.Name = \"Andaman Exp\""
        ],
        "rule_sql": [
            "SELECT T1.Builder FROM railway T1 INNER JOIN train T2 ON T1.Railway_ID = T2.Railway_ID WHERE T2.Name = 'Andaman Exp'"
        ]
    },
    "6763": {
        "db_id": "activity_1",
        "question": "Show ids for the faculty members who don't advise any student.",
        "ground_truth": "SELECT FacID FROM Faculty EXCEPT SELECT advisor FROM Student",
        "amends": [
            "Do select `FacID` instead of `id` and use `EXCEPT` to exclude faculty who are advisors instead of filtering for `student_id IS NULL`. Do reference the `Faculty` table correctly as `Faculty` instead of `faculty` and add the `Student` table to compare against advisor relationships. Do remove the `WHERE` clause entirely instead of using incorrect null checking logic, as the right approach identifies faculty who are not listed as advisors in the Student table through set operations rather than null checks. The amended query now correctly identifies faculty members who are not serving as student advisors by using proper set exclusion logic."
        ],
        "rules": [
            "1) When answering about faculty members who don't advise any student: select \"FacID\" from \"Faculty\" instead of \"id\" from \"faculty\". 2) When identifying faculty who are not advisors: use set exclusion (EXCEPT) to remove faculty who appear as advisors in the \"Student\" table rather than checking for NULL values. 3) When combining information about faculty and student advisor relationships: reference both \"Faculty\" and \"Student\" tables to compare advisor relationships. 4) When the question asks for faculty who don't advise any student: this means faculty whose \"FacID\" does not appear as an advisor identifier in the \"Student\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM faculty WHERE student_id IS NULL;",
            "SELECT FacID FROM Faculty\nEXCEPT\nSELECT Advisor FROM Student WHERE Advisor IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT FacID FROM Faculty\nEXCEPT\nSELECT Advisor FROM Student WHERE Advisor IS NOT NULL"
        ]
    },
    "2863": {
        "db_id": "icfp_1",
        "question": "Count the number of total papers.",
        "ground_truth": "SELECT count(*) FROM papers",
        "amends": [
            "Do remove the `WHERE paper_id IS NOT NULL` filter instead of keeping it, as counting all rows in the table should include null values to accurately represent the total record count. The amended query now matches RIGHT_SQL's behavior by returning the complete count of all papers regardless of null values."
        ],
        "rules": [
            "1) When counting the total number of papers: count all rows in the papers table including those with null values in any column. 2) When the question asks for \"total papers\": this means all records in the papers table regardless of data completeness. 3) When counting entities: do not apply filters that exclude null values unless explicitly required by the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM papers WHERE paper_id IS NOT NULL",
            "SELECT COUNT(*) FROM Papers;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Papers;"
        ]
    },
    "2057": {
        "db_id": "party_people",
        "question": "Show all party names and the number of members in each party.",
        "ground_truth": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id",
        "amends": [
            "Do join `party AS T2` on `T1.party_id = T2.party_id` instead of querying only the `members` table. Do select `T2.party_name` instead of `party_name` to ensure the party name comes from the joined party table rather than potentially ambiguous source. Do group by `T1.party_id` instead of `party_name` to maintain proper aggregation integrity when joining tables. The amended query now correctly retrieves party names from the party table while counting members by their party affiliation, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for party names and member counts per party: join the members table (T1) with the party table (T2) where T1.party_id equals T2.party_id to link members to their parties. 2) When selecting party names: use T2.party_name to ensure the party name comes from the party table rather than potentially ambiguous sources. 3) When counting members per party: group by T1.party_id to maintain proper aggregation integrity when joining tables, ensuring each member is counted only once per their party affiliation."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT party_name, COUNT(*) FROM members GROUP BY party_name;",
            "SELECT T2.party_name, COUNT(*) AS number_of_members FROM member AS T1 JOIN party AS T2 ON T1.Party_ID = T2.Party_ID GROUP BY T1.Party_ID"
        ],
        "rule_sql": [
            "SELECT p.Party_name, COUNT(m.Member_ID) AS Number_of_Members FROM party p LEFT JOIN member m ON p.Party_ID = m.Party_ID GROUP BY p.Party_ID, p.Party_name"
        ]
    },
    "2302": {
        "db_id": "entrepreneur",
        "question": "Which company was started by the entrepreneur with the greatest height?",
        "ground_truth": "SELECT T1.Company FROM entrepreneur AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Height DESC LIMIT 1",
        "amends": [
            "Do join `entrepreneur AS T1` with `people AS T2` on `T1.People_ID = T2.People_ID` instead of querying only `entrepreneurs` without any join. Do select `T1.Company` instead of `company_name` as the output column. Do order by `T2.Height DESC` instead of `height DESC` to use the height from the joined people table rather than a non-existent column in the entrepreneurs table. The amended query now correctly retrieves the company associated with the tallest person by joining the necessary tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"company started by entrepreneur with greatest height\": make sure the output order: T1.Company. 2) When combining entrepreneur and people tables: link rows where T1.People_ID = T2.People_ID and keep only matching pairs (inner match). 3) When the question mentions \"greatest height\": use T2.Height from the people table and order by T2.Height DESC to find the maximum value. 4) When selecting the top result: keep only the first row after ordering by T2.Height DESC."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT company_name FROM entrepreneurs ORDER BY height DESC LIMIT 1;",
            "SELECT T1.Company FROM entrepreneur AS T1 JOIN people AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Height DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Company FROM entrepreneur T1 INNER JOIN people T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Height DESC LIMIT 1"
        ]
    },
    "1528": {
        "db_id": "insurance_and_eClaims",
        "question": "Which claim processing stage has the most claims? Show the claim status name.",
        "ground_truth": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `claims_processing` and `claims_processing_stages` on `t1.claim_stage_id = t2.claim_stage_id` instead of querying `claims` table alone. Do select `t2.claim_status_name` instead of `claim_status_name` and `COUNT(*) as claim_count`. Do group by `t1.claim_stage_id` instead of `claim_status_name`. Do order by `count(*)` instead of `claim_count`. The amended query now correctly retrieves the most frequent claim status by joining processing stages and matches the RIGHT_SQL's behavior.",
            "Do remove `COUNT(*) as claim_count` from the SELECT list instead of including it. Do change the GROUP BY clause to use `t1.claim_stage_id` instead of grouping by the same column but omitting the aggregate function from the SELECT list. Do keep `ORDER BY count(*) DESC` and `LIMIT 1` unchanged. The amended query now correctly returns only the claim_status_name for the most frequent claim stage instead of including an invalid aggregate column that would cause a grouping error."
        ],
        "rules": [
            "1) When combining claims_processing and claims_processing_stages tables: link rows where t1.claim_stage_id equals t2.claim_stage_id and keep only matching pairs (inner match). 2) When counting claims per processing stage: count using the canonical key t1.claim_stage_id instead of counting all rows. 3) When selecting the claim status name: use t2.claim_status_name instead of claim_status_name to get the correct column from the joined table. 4) When ordering results by claim count: order by the count(*) value in descending direction to find the stage with most claims. 5) When answering about the claim processing stage with most claims: make sure the output order shows t2.claim_status_name first followed by the count.",
            "1) When answering about \"which claim processing stage has the most claims\": make sure the output order: t2.claim_status_name only. 2) When the question asks for \"most claims\": rank rows by count of claims in descending order and keep the first 1 row. 3) When grouping by claim stage: organize results by t1.claim_stage_id and compute count per group. 4) When counting claims: compute the number of rows using the canonical key for claims (implied by grouping on t1.claim_stage_id). 5) When combining claims_processing and claims_processing_stages tables: link rows where t1.claim_stage_id = t2.claim_stage_id and keep only matching pairs (inner match). 6) When producing output: do not include aggregate columns like COUNT(*) in the SELECT list when grouping by a different column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT claim_status_name, COUNT(*) as claim_count \nFROM claims \nGROUP BY claim_status_name \nORDER BY claim_count DESC \nLIMIT 1;",
            "SELECT t2.claim_status_name, COUNT(*) as claim_count\nFROM claims_processing t1\nJOIN claims_processing_stages t2 ON t1.claim_stage_id = t2.claim_stage_id\nGROUP BY t1.claim_stage_id\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT t2.claim_status_name\nFROM claims_processing t1\nJOIN claims_processing_stages t2 ON t1.claim_stage_id = t2.claim_stage_id\nGROUP BY t1.claim_stage_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT t2.claim_status_name\nFROM claims_processing t1\nINNER JOIN claims_processing_stages t2 ON t1.claim_stage_id = t2.claim_stage_id\nGROUP BY t1.claim_stage_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "481": {
        "db_id": "allergy_1",
        "question": "How many students live in HKG or CHI?",
        "ground_truth": "SELECT count(*) FROM Student WHERE city_code  =  \"HKG\" OR city_code  =  \"CHI\"",
        "amends": [
            "Do use `city_code` column instead of `city` column for filtering. Do use `OR` operator instead of `AND` operator to include records from either city. Do reference the `Student` table instead of `students` table. Do use double quotes around city codes instead of single quotes. The amended query now correctly counts students from either Hong Kong or Chicago instead of incorrectly trying to find students that are simultaneously in both cities."
        ],
        "rules": [
            "1) When the question mentions \"students\": use the exact table name \"Student\" with double quotes as shown in the schema. 2) When filtering by city codes \"HKG\" or \"CHI\": use the exact column name \"city_code\" with double quotes and the exact literal values \"HKG\" and \"CHI\" with double quotes. 3) When combining multiple city code conditions: use OR operator instead of AND to include records matching either condition. 4) When counting students: count all rows that satisfy the city code conditions using the canonical Student table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE city = 'HKG' AND city = 'CHI';",
            "SELECT COUNT(*) FROM Student WHERE city_code = \"HKG\" OR city_code = \"CHI\""
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM \"Student\" WHERE \"city_code\" = \"HKG\" OR \"city_code\" = \"CHI\""
        ]
    },
    "6675": {
        "db_id": "driving_school",
        "question": "What is the status code with the least number of customers?",
        "ground_truth": "SELECT customer_status_code FROM Customers GROUP BY customer_status_code ORDER BY count(*) ASC LIMIT 1;",
        "amends": [
            "Do select `customer_status_code` instead of `status_code` and remove the `customer_count` alias instead of keeping it. Do use `count(*)` directly in the `ORDER BY` clause instead of referencing the alias. Do order by `ASC` instead of `DESC` to get the ascending count order. The amended query now correctly selects the customer status code and orders by ascending count of records per status code."
        ],
        "rules": [
            "1) When the question asks for \"status code\": use the exact column token \"customer_status_code\" from the Customers table. 2) When counting customers: use count(*) to count all records per status code. 3) When ordering by count to find the \"least number\": order by count(*) in ascending (ASC) direction. 4) When selecting output columns: include only \"customer_status_code\" without any aliases for the count. 5) When grouping results: group by \"customer_status_code\" to get counts per status code."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT status_code, COUNT(*) as customer_count FROM customers GROUP BY status_code ORDER BY customer_count DESC LIMIT 1;",
            "SELECT customer_status_code FROM Customers GROUP BY customer_status_code ORDER BY COUNT(*) ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT customer_status_code FROM Customers GROUP BY customer_status_code ORDER BY COUNT(*) ASC LIMIT 1;"
        ]
    },
    "4138": {
        "db_id": "film_rank",
        "question": "Please list the years of film market estimations when the market is in country \"Japan\" in descending order.",
        "ground_truth": "SELECT T1.Year FROM film_market_estimation AS T1 JOIN market AS T2 ON T1.Market_ID  =  T2.Market_ID WHERE T2.Country  =  \"Japan\" ORDER BY T1.Year DESC",
        "amends": [
            "Do use `T1.Year` with table alias instead of `year` without qualification. Do join `market AS T2` on `T1.Market_ID = T2.Market_ID` instead of querying `film_market_estimations` directly without joins. Do filter on `T2.Country = \"Japan\"` instead of `country = 'Japan'` to reference the correct table. Do order by `T1.Year DESC` instead of `year ASC` to sort in descending order. The amended query now correctly joins tables to filter by country and returns results in descending year order, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about film market estimations: use table alias T1 for film_market_estimations and T2 for market table. 2) When combining film_market_estimations and market tables: link rows where T1.Market_ID = T2.Market_ID and keep only matching pairs (inner match). 3) When the question mentions country \"Japan\": filter using T2.Country = \"Japan\" with exact double quotes and case. 4) When selecting year information: use T1.Year with exact table qualification. 5) When ordering by year in descending order: sort results by T1.Year in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year FROM film_market_estimations WHERE country = 'Japan' ORDER BY year ASC;",
            "SELECT DISTINCT T1.Year \nFROM film_market_estimation AS T1\nJOIN market AS T2 ON T1.Market_ID = T2.Market_ID\nWHERE T2.Country = 'Japan'\nORDER BY T1.Year DESC"
        ],
        "rule_sql": [
            "SELECT T1.Year FROM film_market_estimation T1 INNER JOIN market T2 ON T1.Market_ID = T2.Market_ID WHERE T2.Country = \"Japan\" ORDER BY T1.Year DESC"
        ]
    },
    "2878": {
        "db_id": "icfp_1",
        "question": "What are the last names of the author of the paper titled \"Binders Unbound\"?",
        "ground_truth": "SELECT t1.lname FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid WHERE t3.title  =  \"Binders Unbound\"",
        "amends": [
            "Do select `t1.lname` instead of `first_name` and do use explicit table aliases instead of bare column references. Do add joins to `authorship AS t2` and `papers AS t3` instead of querying only the `authors` table. Do use `JOIN` with proper join conditions `t1.authid = t2.authid` and `t2.paperid = t3.paperid` instead of no joins. Do filter on `t3.title = \"Binders Unbound\"` instead of `paper_title = 'Binders Unbound'` to correctly reference the paper title from the papers table rather than assuming it exists in the authors table. The amended query now properly joins the three related tables to find author last names for a specific paper title, matching the correct logic."
        ],
        "rules": [
            "1) When answering about \"last names of the author of a paper\": make sure the output order: t1.lname\n2) When the question mentions \"paper titled\": the paper title actually means \"t3.title\" in schema\n3) When combining tables for author information: link authors (t1) and authorship (t2) where t1.authid = t2.authid and keep only matching pairs (inner match)\n4) When combining tables for paper information: link authorship (t2) and papers (t3) where t2.paperid = t3.paperid and keep only matching pairs (inner match)\n5) When filtering for a specific paper title: use exact literal \"Binders Unbound\" for t3.title comparison\n6) When selecting author information: use t1.lname for last names instead of first_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM authors WHERE paper_title = 'Binders Unbound';",
            "SELECT t1.lname \nFROM Authors AS t1\nJOIN Authorship AS t2 ON t1.authID = t2.authID\nJOIN Papers AS t3 ON t2.paperID = t3.paperID\nWHERE t3.title = 'Binders Unbound'"
        ],
        "rule_sql": [
            "SELECT t1.lname \nFROM Authors t1\nINNER JOIN Authorship t2 ON t1.authID = t2.authID\nINNER JOIN Papers t3 ON t2.paperID = t3.paperID\nWHERE t3.title = 'Binders Unbound'\nORDER BY t1.lname"
        ]
    },
    "4312": {
        "db_id": "club_1",
        "question": "List the clubs that have at least a member with advisor \"1121\".",
        "ground_truth": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.advisor  =  1121",
        "amends": [
            "Do join `club AS t1` with `member_of_club AS t2` on `t1.clubid = t2.clubid` and `student AS t3` on `t2.stuid = t3.stuid` instead of querying `clubs` table directly. Do filter on `t3.advisor = 1121` instead of `advisor_id = '1121'` to use numeric comparison rather than string. Do select `t1.clubname` instead of `club_name` to match the correct column name. The amended query now correctly identifies clubs through student membership relationships rather than direct advisor association, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"clubs that have at least a member with advisor 1121\": make sure the output order: t1.clubname\n2) When the question mentions \"clubs\": \"clubs\" actually means \"club AS t1\" in schema\n3) When the question mentions \"member\": \"member\" actually means \"member_of_club AS t2\" in schema\n4) When the question mentions \"advisor 1121\": \"advisor 1121\" actually means \"t3.advisor = 1121\" using numeric comparison\n5) When combining tables for shared entities: link rows where t1.clubid = t2.clubid and t2.stuid = t3.stuid; keep only matching pairs (inner match)\n6) When selecting club names: use t1.clubname instead of club_name to match the correct column name\n7) When filtering on advisor: use numeric comparison t3.advisor = 1121 rather than string comparison '1121'"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT club_name FROM clubs WHERE advisor_id = '1121';",
            "SELECT DISTINCT t1.ClubName \nFROM Club AS t1 \nJOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID \nJOIN Student AS t3 ON t2.StuID = t3.StuID \nWHERE t3.Advisor = 1121"
        ],
        "rule_sql": [
            "SELECT t1.ClubName\nFROM Club AS t1\nINNER JOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID\nINNER JOIN Student AS t3 ON t2.StuID = t3.StuID\nWHERE t3.Advisor = 1121\nORDER BY t1.ClubName;"
        ]
    },
    "1492": {
        "db_id": "debate",
        "question": "How many debates are there?",
        "ground_truth": "SELECT count(*) FROM debate",
        "amends": [
            "Do reference the `debate` table instead of the `debates` table. Do count all records from the correct table instead of using the wrong table name. The amended query now correctly counts records from the debate table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"debates\": use the exact table name \"debate\" from the schema, not \"debates\". 2) When counting all records from a table: count all rows in the table without any filtering conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM debates WHERE debate_id IS NULL;",
            "SELECT COUNT(*) FROM debate;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM debate;"
        ]
    },
    "1065": {
        "db_id": "match_season",
        "question": "What are the draft pick numbers and draft classes for players who play the Defender position?",
        "ground_truth": "SELECT Draft_Pick_Number ,  Draft_Class FROM match_season WHERE POSITION  =  \"Defender\"",
        "amends": [
            "Do select from `match_season` table instead of `players` table. Do use column names `Draft_Pick_Number` and `Draft_Class` instead of `draft_pick_number` and `draft_class`. Do use double quotes around `\"Defender\"` instead of single quotes. The amended query now correctly retrieves draft information from the match_season table for defenders."
        ],
        "rules": [
            "1) When answering about draft pick numbers and draft classes for players: select from the \"match_season\" table instead of the \"players\" table. 2) When selecting draft pick numbers: use the exact column name \"Draft_Pick_Number\" with proper case and quotes. 3) When selecting draft classes: use the exact column name \"Draft_Class\" with proper case and quotes. 4) When filtering for players in the Defender position: use double quotes around the literal \"Defender\" instead of single quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT draft_pick_number, draft_class FROM players WHERE position = 'Defender';",
            "SELECT Draft_Pick_Number, Draft_Class FROM match_season WHERE Position = \"Defender\""
        ],
        "rule_sql": [
            "SELECT \"Draft_Pick_Number\", \"Draft_Class\" FROM \"match_season\" WHERE \"Position\" = \"Defender\""
        ]
    },
    "1269": {
        "db_id": "apartment_rentals",
        "question": "Find the number of apartments that have no facility.",
        "ground_truth": "SELECT count(*) FROM Apartments WHERE apt_id NOT IN (SELECT apt_id FROM Apartment_Facilities)",
        "amends": [
            "Do use a subquery with `apt_id NOT IN` instead of checking `facility_id IS NOT NULL`. Do reference the `Apartment_Facilities` table in the subquery instead of omitting it. Do filter for apartments without any facilities instead of those with non-null facility IDs. The amended query now correctly identifies apartments that have no associated facilities rather than those with a non-null facility ID field, matching the intended behavior."
        ],
        "rules": [
            "1) When counting apartments that have no facility: use a subquery to find apartments where apt_id is not present in the Apartment_Facilities table instead of checking facility_id IS NOT NULL. 2) When determining if an apartment has facilities: reference the Apartment_Facilities table to check for existence of related facility records. 3) When filtering for apartments without any facilities: use apt_id NOT IN (SELECT apt_id FROM Apartment_Facilities) to correctly identify apartments with no associated facilities."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM apartments WHERE facility_id IS NOT NULL;",
            "SELECT COUNT(*) \nFROM Apartments \nWHERE apt_id NOT IN (SELECT apt_id FROM Apartment_Facilities)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS apartment_count\nFROM Apartments\nWHERE apt_id NOT IN (SELECT apt_id FROM Apartment_Facilities);"
        ]
    },
    "6267": {
        "db_id": "ship_1",
        "question": "What are the names of ships that are commanded by both captains with the rank of Midshipman and captains with the rank of Lieutenant?",
        "ground_truth": "SELECT t1.name FROM ship AS t1 JOIN captain AS t2 ON t1.ship_id  =  t2.ship_id WHERE t2.rank  =  'Midshipman' INTERSECT SELECT t1.name FROM ship AS t1 JOIN captain AS t2 ON t1.ship_id  =  t2.ship_id WHERE t2.rank  =  'Lieutenant'",
        "amends": [
            "Do use table aliases `t1` and `t2` instead of `s` and `c`. Do change the FROM source from `ships` to `ship` and `captains` to `captain` instead of the original table names. Do modify the join condition to `t1.ship_id = t2.ship_id` instead of `s.captain_id = c.id`. Do replace the impossible WHERE condition `c.rank = 'Midshipman' AND c.rank = 'Lieutenant'` with an INTERSECT operation between two separate queries for each rank value instead of trying to match both conditions simultaneously. Do add a second query with the same structure but filtering for `'Lieutenant'` rank and combine them with INTERSECT instead of using a single contradictory filter. The amended query now correctly finds ships that have both a Midshipman and Lieutenant captain by using set intersection logic instead of the impossible simultaneous condition."
        ],
        "rules": [
            "1) When the question asks for ships commanded by captains with different ranks: use two separate queries with INTERSECT instead of trying to match both conditions simultaneously in one WHERE clause. 2) When combining information from ship and captain tables: link rows using t1.ship_id = t2.ship_id instead of captain_id relationships. 3) When filtering for captain ranks: use exact literal values 'Midshipman' and 'Lieutenant' with proper case and spelling. 4) When using table aliases: use t1 for the ship table and t2 for the captain table consistently. 5) When referring to table names: use exact table names ship and captain instead of ships and captains. 6) When selecting ship names: output the name column from the ship table (t1.name)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.name \nFROM ships s\nJOIN captains c ON s.captain_id = c.id\nWHERE c.rank = 'Midshipman' AND c.rank = 'Lieutenant'",
            "SELECT t1.Name FROM Ship t1 JOIN captain t2 ON t1.Ship_ID = t2.Ship_ID WHERE t2.Rank = 'Midshipman' INTERSECT SELECT t1.Name FROM Ship t1 JOIN captain t2 ON t1.Ship_ID = t2.Ship_ID WHERE t2.Rank = 'Lieutenant'"
        ],
        "rule_sql": [
            "SELECT t1.Name FROM ship t1 JOIN captain t2 ON t1.Ship_ID = t2.Ship_ID WHERE t2.Rank = 'Midshipman'\nINTERSECT\nSELECT t1.Name FROM ship t1 JOIN captain t2 ON t1.Ship_ID = t2.Ship_ID WHERE t2.Rank = 'Lieutenant'"
        ]
    },
    "249": {
        "db_id": "musical",
        "question": "Return the different nominees of musicals that have an award that is not the Tony Award.",
        "ground_truth": "SELECT DISTINCT Nominee FROM musical WHERE Award != \"Tony Award\"",
        "amends": [
            "Do reference the `Nominee` column instead of `nominee` to match the correct case. Do query from the `musical` table instead of the `awards` table with a `category` filter. Do remove the `category = 'Musical'` filter condition instead of keeping it since the table change makes this redundant. Do use double quotes around `\"Tony Award\"` instead of single quotes for string literal consistency. The amended query now correctly selects distinct nominees from the musical table excluding Tony Award winners."
        ],
        "rules": [
            "1) When answering about \"different nominees of musicals\": make sure the output order: Nominee. 2) When the question mentions \"nominees\": \"nominees\" actually means \"Nominee in schema\" with exact case. 3) When the question asks for \"different nominees\": compute the number of unique values of the exact token for Nominee. 4) When the question mentions \"award that is not the Tony Award\": use the exact literal \"Tony Award\" with double quotes and proper case. 5) When querying from the musical table: do not apply category filters since the table already contains only musical-related data."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT nominee FROM awards WHERE category = 'Musical' AND award != 'Tony Award';",
            "SELECT DISTINCT \"Nominee\" FROM \"musical\" WHERE \"Award\" != \"Tony Award\";"
        ],
        "rule_sql": [
            "SELECT DISTINCT Nominee FROM musical WHERE Award != 'Tony Award' ORDER BY Nominee;"
        ]
    },
    "4587": {
        "db_id": "solvency_ii",
        "question": "What is the average price for products?",
        "ground_truth": "SELECT avg(Product_Price) FROM Products",
        "amends": [
            "Do reference the correct column name `Product_Price` instead of `price` and use the correct table name `Products` instead of `products` in the FROM clause, while maintaining the same aggregate function and filter logic. The amended query now correctly calculates the average of the Product_Price column from the Products table where values exceed 1000, matching the intended behavior.",
            "Do use lowercase `avg` function instead of uppercase `AVG` for the aggregate function. Do remove the `WHERE Product_Price > 1000` filter instead of keeping it, as the right query calculates the average across all products rather than only those above 1000. The amended query now matches the right SQL's behavior of computing the overall average product price."
        ],
        "rules": [
            "1) When answering about \"average price for products\": make sure the output order: AVG(Product_Price). 2) When the question mentions \"price\": \"price\" actually means \"Product_Price in schema\". 3) When the question mentions \"products\": \"products\" actually means \"Products in schema\". 4) When filtering for products with price over 1000: include only rows where Product_Price > 1000.",
            "1) When using aggregate functions: use lowercase function names like 'avg' instead of uppercase 'AVG'. 2) When calculating average price across all products: do not apply any price filters, include all product prices in the calculation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(price) FROM products WHERE price > 1000;",
            "SELECT AVG(Product_Price) FROM Products WHERE Product_Price > 1000;",
            "SELECT AVG(Product_Price) FROM Products;"
        ],
        "rule_sql": [
            "SELECT avg(Product_Price) FROM Products;"
        ]
    },
    "5647": {
        "db_id": "railway",
        "question": "Show the locations that have more than one railways.",
        "ground_truth": "SELECT LOCATION FROM railway GROUP BY LOCATION HAVING COUNT(*)  >  1",
        "amends": [
            "Do reference the `railway` table instead of `railways` in the FROM clause. Do remove the `COUNT(*)` column from the SELECT list instead of including it, keeping only the `LOCATION` field. Do maintain the GROUP BY on `LOCATION` and the HAVING condition `COUNT(*) > 1` unchanged. The amended query now correctly identifies duplicate locations in the railway table while returning only the location values themselves rather than including the count in the output."
        ],
        "rules": [
            "1) When answering about \"locations that have more than one railways\": make sure the output order: LOCATION. 2) When the question mentions \"railways\": \"railways\" actually means \"railway\" in schema. 3) When the question asks for \"locations that have more than one railways\": organize results by LOCATION and compute count of railways per group, keeping only groups where count is greater than 1. 4) When producing output: do not include the count column in the results, only show the LOCATION field."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location, COUNT(*) FROM railways GROUP BY location HAVING COUNT(*) > 1",
            "SELECT Location FROM railway GROUP BY Location HAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT Location FROM railway GROUP BY Location HAVING COUNT(*) > 1 ORDER BY Location;"
        ]
    },
    "6554": {
        "db_id": "wine_1",
        "question": "How many wines are there for each grape?",
        "ground_truth": "SELECT count(*) ,  Grape FROM WINE GROUP BY Grape",
        "amends": [
            "Do use `count(*)` without an alias instead of `COUNT(*)` without an alias. Do place `Grape` after the aggregate instead of before it in the SELECT list. Do capitalize `Grape` instead of lowercase `grape` in both SELECT and GROUP BY clauses. Do capitalize `WINE` instead of lowercase `wines` as the table name. The amended query now correctly groups and counts wines by grape type with proper casing and column ordering."
        ],
        "rules": [
            "1) When the question asks for count of wines per grape: use the exact table name \"WINE\" instead of \"wines\". 2) When grouping by grape type: use the exact column name \"Grape\" with proper capitalization in both SELECT and GROUP BY clauses. 3) When ordering output columns: place the aggregate count before the grouping column \"Grape\" in the SELECT list. 4) When counting wines: use count(*) without any alias to count all rows in each grape group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT grape, COUNT(*) FROM wines GROUP BY grape;",
            "SELECT COUNT(*), Grape FROM WINE GROUP BY Grape"
        ],
        "rule_sql": [
            "SELECT COUNT(*), Grape FROM WINE GROUP BY Grape"
        ]
    },
    "3754": {
        "db_id": "program_share",
        "question": "find the program owners that have some programs in both morning and night time.",
        "ground_truth": "SELECT t1.owner FROM program AS t1 JOIN broadcast AS t2 ON t1.program_id  =  t2.program_id WHERE t2.Time_of_day  =  \"Morning\" INTERSECT SELECT t1.owner FROM program AS t1 JOIN broadcast AS t2 ON t1.program_id  =  t2.program_id WHERE t2.Time_of_day  =  \"Night\"",
        "amends": [
            "Do use `INTERSECT` with two separate queries instead of `AND` with conflicting conditions. Do change the table structure to use `program` and `broadcast` tables instead of a single `programs` table. Do join `program` and `broadcast` on `program_id` instead of querying a single table. Do reference `Time_of_day` column from `broadcast` table instead of `time_slot` from `programs`. Do use proper case-sensitive values \"Morning\" and \"Night\" instead of lowercase 'morning' and 'night'. Do select `owner` column instead of `owner_name`. Do remove the incorrect `DISTINCT` since `INTERSECT` inherently returns distinct values. The amended query now correctly finds owners who have programs broadcast in both morning and night time slots using proper table relationships."
        ],
        "rules": [
            "1) When the question asks about program owners with programs in both morning and night time: use the INTERSECT operation between two separate queries instead of AND with conflicting conditions. 2) When combining program and broadcast tables: link rows where program.program_id equals broadcast.program_id to establish the proper table relationship. 3) When referencing time of day values: use exact case-sensitive literals \"Morning\" and \"Night\" from the broadcast.Time_of_day column instead of lowercase 'morning' and 'night'. 4) When selecting owner information: use the owner column instead of owner_name. 5) When using INTERSECT operations: do not apply DISTINCT since INTERSECT inherently returns distinct values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT owner_name FROM programs WHERE time_slot = 'morning' AND time_slot = 'night';",
            "SELECT p.Owner\nFROM program p\nJOIN broadcast b ON p.Program_ID = b.Program_ID\nWHERE b.Time_of_day = 'Morning'\nINTERSECT\nSELECT p.Owner\nFROM program p\nJOIN broadcast b ON p.Program_ID = b.Program_ID\nWHERE b.Time_of_day = 'Night'"
        ],
        "rule_sql": [
            "SELECT p.Owner\nFROM program p\nJOIN broadcast b ON p.Program_ID = b.Program_ID\nWHERE b.Time_of_day = 'Morning'\nINTERSECT\nSELECT p.Owner\nFROM program p\nJOIN broadcast b ON p.Program_ID = b.Program_ID\nWHERE b.Time_of_day = 'Night'"
        ]
    },
    "6321": {
        "db_id": "e_government",
        "question": "What is the name of the organization that was formed most recently?",
        "ground_truth": "SELECT organization_name FROM organizations ORDER BY date_formed DESC LIMIT 1",
        "amends": [
            "Do select `organization_name` instead of `name` to use the correct column name. Do order by `date_formed DESC` instead of `formed_date ASC` to use the proper date column name and sort in descending order rather than ascending. The amended query now correctly retrieves the most recently formed organization's name."
        ],
        "rules": [
            "1) When the question asks for the name of an organization: use the exact column token \"organization_name\" instead of \"name\" to match the schema. 2) When the question asks for the most recently formed organization: order by the exact column token \"date_formed\" in descending order (DESC) to get the newest first, not ascending order (ASC). 3) When retrieving a single result for \"most recent\": limit to 1 row after proper ordering."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM organizations ORDER BY formed_date ASC LIMIT 1;",
            "SELECT organization_name FROM Organizations ORDER BY date_formed DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT organization_name FROM Organizations ORDER BY date_formed DESC LIMIT 1;"
        ]
    },
    "5371": {
        "db_id": "tracking_software_problems",
        "question": "Which problems are reported by the staff with last name \"Bosco\"? Show the ids of the problems.",
        "ground_truth": "SELECT T1.problem_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE T2.staff_last_name = \"Bosco\"",
        "amends": [
            "Do add table `staff AS T2` and join on `T1.reported_by_staff_id = T2.staff_id` instead of querying only the `problems` table. Do reference `T1.problem_id` with table alias instead of bare `problem_id`. Do filter on `T2.staff_last_name` instead of directly filtering `problems.staff_last_name` which appears to be a column that shouldn't exist in the problems table. The amended query now correctly joins through the staff relationship to find problems reported by staff with last name Bosco, matching the intended logic."
        ],
        "rules": [
            "1) When the question asks about problems reported by staff with a specific last name: join the Problems table (as T1) with the Staff table (as T2) using T1.reported_by_staff_id = T2.staff_id to connect problems to their reporting staff members. 2) When filtering for staff with last name \"Bosco\": apply the filter condition T2.staff_last_name = 'Bosco' exactly as specified, preserving the exact case and spelling. 3) When selecting problem ids from the Problems table: use the exact column reference T1.problem_id with the table alias to specify which table contains the problem_id column. 4) When combining tables for staff-problem relationships: perform an inner join to keep only matching pairs where problems have corresponding staff records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT problem_id FROM problems WHERE staff_last_name = 'Bosco'",
            "SELECT T1.problem_id \nFROM Problems AS T1\nJOIN Staff AS T2 ON T1.reported_by_staff_id = T2.staff_id\nWHERE T2.staff_last_name = 'Bosco'"
        ],
        "rule_sql": [
            "SELECT T1.problem_id\nFROM Problems AS T1\nINNER JOIN Staff AS T2 ON T1.reported_by_staff_id = T2.staff_id\nWHERE T2.staff_last_name = 'Bosco'"
        ]
    },
    "2210": {
        "db_id": "formula_1",
        "question": "What are the last names and ids of all drivers who had 11 pit stops and participated in more than 5 races?",
        "ground_truth": "SELECT T1.surname ,  T1.driverid FROM drivers AS T1 JOIN pitstops AS T2 ON T1.driverid  =  T2.driverid GROUP BY T1.driverid HAVING count(*)  =  11 INTERSECT SELECT T1.surname ,  T1.driverid FROM drivers AS T1 JOIN results AS T2 ON T1.driverid  =  T2.driverid GROUP BY T1.driverid HAVING count(*)  >  5",
        "amends": [
            "Do use `T1.surname` and `T1.driverid` instead of `last_name` and `driver_id`. Do add explicit table aliases with `AS T1` instead of omitting them. Do add `JOIN pitstops AS T2` with `ON T1.driverid = T2.driverid` instead of filtering on `pit_stops = 11`. Do use `GROUP BY T1.driverid` and `HAVING count(*) = 11` instead of the WHERE filter. Do add a second query with `JOIN results AS T2` and `HAVING count(*) > 5` instead of filtering on `races_participated > 5`. Do combine both result sets with `INTERSECT` instead of using a single WHERE clause. The amended query now correctly finds drivers with exactly 11 pit stops and more than 5 race participations by joining the relevant tables and using set intersection."
        ],
        "rules": [
            "1) When the question asks for \"last names\": use the exact column token \"T1.surname\" instead of \"last_name\". 2) When the question asks for \"ids\": use the exact column token \"T1.driverid\" instead of \"driver_id\". 3) When counting pit stops for drivers: join table \"pitstops AS T2\" with \"T1.driverid = T2.driverid\", group by \"T1.driverid\", and count rows to get exactly 11 pit stops. 4) When counting race participations for drivers: join table \"results AS T2\" with \"T1.driverid = T2.driverid\", group by \"T1.driverid\", and count rows to get more than 5 participations. 5) When combining multiple conditions on the same entity: use INTERSECT to find drivers who satisfy both the pit stop count condition and the race participation count condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name, driver_id FROM drivers WHERE pit_stops = 11 AND races_participated > 5;",
            "SELECT T1.surname, T1.driverId\nFROM drivers AS T1\nJOIN pitStops AS T2 ON T1.driverId = T2.driverId\nGROUP BY T1.driverId\nHAVING COUNT(*) = 11\nINTERSECT\nSELECT T1.surname, T1.driverId\nFROM drivers AS T1\nJOIN results AS T2 ON T1.driverId = T2.driverId\nGROUP BY T1.driverId\nHAVING COUNT(*) > 5"
        ],
        "rule_sql": [
            "SELECT T1.driverId, T1.surname\nFROM drivers AS T1\nWHERE T1.driverId IN (\n    SELECT T1.driverId\n    FROM drivers AS T1\n    JOIN pitStops AS T2 ON T1.driverId = T2.driverId\n    GROUP BY T1.driverId\n    HAVING COUNT(*) = 11\n)\nINTERSECT\nSELECT T1.driverId, T1.surname\nFROM drivers AS T1\nWHERE T1.driverId IN (\n    SELECT T1.driverId\n    FROM drivers AS T1\n    JOIN results AS T2 ON T1.driverId = T2.driverId\n    GROUP BY T1.driverId\n    HAVING COUNT(*) > 5\n)"
        ]
    },
    "6527": {
        "db_id": "wine_1",
        "question": "List the area and county of all appelations.",
        "ground_truth": "SELECT Area ,  County FROM APPELLATIONS",
        "amends": [
            "Do use column alias `County` instead of `country` and table name `APPELLATIONS` instead of `appelations`. Do capitalize `Area` instead of `area` to match the correct column name. The amended query now correctly selects the intended columns from the proper table with accurate casing."
        ],
        "rules": [
            "1) When the question mentions \"appelations\": use the exact table name \"APPELLATIONS\" with proper capitalization. 2) When the question asks for \"area\": use the exact column name \"Area\" with proper capitalization. 3) When the question asks for \"county\": use the exact column name \"County\" with proper capitalization instead of \"country\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT area, country FROM appelations;",
            "SELECT Area, County FROM APPELLATIONS"
        ],
        "rule_sql": [
            "SELECT Area, County FROM APPELLATIONS"
        ]
    },
    "2113": {
        "db_id": "cre_Doc_Control_Systems",
        "question": "List the document type code for the document with the id 2.",
        "ground_truth": "SELECT document_type_code FROM Documents WHERE document_id = 2;",
        "amends": [
            "Do select `document_type_code` instead of `document_type` in the SELECT list. Do reference table `Documents` (capitalized) instead of `documents` in the FROM clause. Do filter on `document_id = 2` instead of `id = 2` in the WHERE condition. The amended query now correctly retrieves the document type code from the Documents table using the appropriate document identifier column."
        ],
        "rules": [
            "1) When selecting the document type code: use the exact column name \"document_type_code\" from the Documents table. 2) When referencing the documents table: use the exact table name \"Documents\" with capital D. 3) When filtering by document identifier: use the exact column name \"document_id\" with value 2 for the condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_type FROM documents WHERE id = 2;",
            "SELECT document_type_code FROM Documents WHERE document_id = 2;"
        ],
        "rule_sql": [
            "SELECT document_type_code FROM Documents WHERE document_id = 2"
        ]
    },
    "4008": {
        "db_id": "ship_mission",
        "question": "What is the name of the ship with the largest tonnage?",
        "ground_truth": "SELECT Name FROM ship ORDER BY Tonnage DESC LIMIT 1",
        "amends": [
            "Do reference table `ship` instead of `ships` and select column `Name` instead of `name` to match the correct table and column naming. Do order by `Tonnage DESC` instead of `tonnage ASC` to sort in descending order by the correct column name. The amended query now correctly retrieves the ship with the highest tonnage from the proper table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about ships: use table \"ship\" instead of \"ships\" to match the correct table name. 2) When selecting the ship name: use column \"Name\" instead of \"name\" to match the correct column naming. 3) When finding the ship with largest tonnage: order by \"Tonnage DESC\" instead of \"tonnage ASC\" to sort in descending order by the correct column name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM ships ORDER BY tonnage ASC LIMIT 1;",
            "SELECT Name FROM ship ORDER BY Tonnage DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name FROM ship ORDER BY Tonnage DESC LIMIT 1;"
        ]
    },
    "1525": {
        "db_id": "insurance_and_eClaims",
        "question": "How many claim processing stages are there in total?",
        "ground_truth": "SELECT count(*) FROM claims_processing_stages",
        "amends": [
            "Do reference the correct table name `claims_processing_stages` instead of the incorrect `claim_processing_stages` to ensure the query counts records from the proper database table. The amended query now correctly matches the intended behavior by accessing the accurate table structure."
        ],
        "rules": [
            "1) When the question asks about \"claim processing stages\": use the exact table name \"claims_processing_stages\" with the correct spelling and plural form. 2) When counting entities from the claims_processing_stages table: count all rows using the COUNT(*) function to get the total number of processing stages."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM claim_processing_stages;",
            "SELECT COUNT(*) FROM Claims_Processing_Stages;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Claims_Processing_Stages;"
        ]
    },
    "5419": {
        "db_id": "shop_membership",
        "question": "What is the membership level with the most people?",
        "ground_truth": "SELECT LEVEL FROM member GROUP BY LEVEL ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `LEVEL` instead of `membership_level` and omit the `COUNT(*) as total_people` column from the SELECT list. Do use table `member` instead of `people` as the FROM source. Do remove the explicit alias `total_people` from the ORDER BY clause and instead order by `count(*)` directly. The amended query now correctly returns only the membership level with the highest count from the member table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"membership level with the most people\": select \"LEVEL\" from the \"member\" table. 2) When counting people: count all rows from the \"member\" table using count(*). 3) When finding the membership level with the highest count: order the results by count(*) in descending order and keep only the first row. 4) When grouping by membership level: group the results by \"LEVEL\" column from the \"member\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT membership_level, COUNT(*) as total_people FROM people GROUP BY membership_level ORDER BY total_people DESC LIMIT 1;",
            "SELECT Level FROM member GROUP BY Level ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Level FROM member GROUP BY Level ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "6144": {
        "db_id": "music_4",
        "question": "Count the number of artists.",
        "ground_truth": "SELECT count(*) FROM artist",
        "amends": [
            "Do query the `artist` table instead of the `albums` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)`. The amended query now correctly counts records from the artist table instead of the albums table."
        ],
        "rules": [
            "1) When counting the number of artists: query the \"artist\" table instead of the \"albums\" table. 2) When counting records: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" to count all rows from the correct table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM albums;",
            "SELECT count(*) FROM artist;"
        ],
        "rule_sql": [
            "select count(*) from artist"
        ]
    },
    "1213": {
        "db_id": "apartment_rentals",
        "question": "Find the average room count of the apartments that have the \"Studio\" type code.",
        "ground_truth": "SELECT avg(room_count) FROM Apartments WHERE apt_type_code  =  \"Studio\"",
        "amends": [
            "Do use `avg(room_count)` instead of `AVG(bedroom_count)` for the aggregate function and column reference. Do reference `apt_type_code` instead of `type_code` in the WHERE filter condition. Do use double quotes `\"Studio\"` instead of single quotes `'Studio'` for the string literal. Do reference table `Apartments` instead of `apartments` with proper case sensitivity. The amended query now correctly calculates the average room count for studio apartments instead of bedroom count."
        ],
        "rules": [
            "1) When answering about \"average room count of apartments with Studio type code\": use avg(room_count) instead of AVG(bedroom_count) for the aggregate function. 2) When filtering apartments by type code: use apt_type_code instead of type_code as the column reference. 3) When specifying the literal value \"Studio\": use double quotes \"Studio\" instead of single quotes 'Studio'. 4) When referencing the apartments table: use table name Apartments with proper case sensitivity instead of apartments."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(bedroom_count) FROM apartments WHERE type_code = 'Studio';",
            "SELECT AVG(room_count) FROM Apartments WHERE apt_type_code = \"Studio\";"
        ],
        "rule_sql": [
            "SELECT AVG(room_count) FROM Apartments WHERE apt_type_code = \"Studio\";"
        ]
    },
    "5772": {
        "db_id": "customer_complaints",
        "question": "Which city has the least number of customers whose type code is \"Good Credit Rating\"?",
        "ground_truth": "SELECT town_city FROM customers WHERE customer_type_code  =  \"Good Credit Rating\" GROUP BY town_city ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do use column `town_city` instead of `city` in both SELECT and GROUP BY clauses. Do use column `customer_type_code` instead of `type_code` in the WHERE filter. Do remove the alias `customer_count` from the COUNT(*) expression instead of keeping it. Do change the ORDER BY to use `count(*)` directly instead of referencing the removed alias `customer_count`. Do remove the DESC ordering direction instead of keeping it, making the sort ascending by default. Do quote the string literal with double quotes \"Good Credit Rating\" instead of single quotes. The amended query now correctly identifies customers by town_city with Good Credit Rating type and returns the town_city with the lowest count first, matching the RIGHT_SQL's behavior.",
            "Do remove the `COUNT(*)` column from the SELECT list instead of including it, since only the town_city is needed in the final result. Do use lowercase `customers` instead of `Customers` for the table name to match the actual schema. Do maintain the same `WHERE` filter on `customer_type_code = \"Good Credit Rating\"` and `GROUP BY town_city` grouping. Do keep the `ORDER BY count(*)` sorting and `LIMIT 1` restriction to find the town with the highest count of customers with good credit rating. The amended query now correctly returns only the town_city value instead of both town_city and the count, while maintaining the same logical behavior to identify the town with the most customers having good credit rating."
        ],
        "rules": [
            "1) When the question mentions \"city\": \"city\" actually means \"town_city\" in the schema. 2) When the question mentions \"type code\": \"type code\" actually means \"customer_type_code\" in the schema. 3) When the question asks for \"count of customers\": compute the number of rows using COUNT(*) without an alias. 4) When the question asks for \"least number\" or \"lowest count\": order results by the count in ascending order (lowest first). 5) When using string literals for comparison: use double quotes exactly as \"Good Credit Rating\" with the exact case and spacing. 6) When grouping by location: organize results by the exact column \"town_city\" and compute counts per group.",
            "1) When the question asks for a city with the least number of customers: use the exact table name \"customers\" (lowercase) as shown in the schema. 2) When filtering for customers with type code \"Good Credit Rating\": use the exact literal \"Good Credit Rating\" with the same case and spacing. 3) When counting customers per city: group by \"town_city\" and count using the canonical customer identifier (implied by COUNT(*)). 4) When finding the city with the least number: order by the count in ascending order and take only the first result using LIMIT 1. 5) When presenting the final result: include only the \"town_city\" column in the output, not the count value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, COUNT(*) as customer_count FROM customers WHERE type_code = 'Good Credit Rating' GROUP BY city ORDER BY customer_count DESC LIMIT 1;",
            "SELECT town_city, COUNT(*) FROM Customers WHERE customer_type_code = \"Good Credit Rating\" GROUP BY town_city ORDER BY COUNT(*) LIMIT 1;",
            "SELECT town_city FROM customers WHERE customer_type_code = \"Good Credit Rating\" GROUP BY town_city ORDER BY count(*) LIMIT 1"
        ],
        "rule_sql": [
            "SELECT town_city FROM customers WHERE customer_type_code = \"Good Credit Rating\" GROUP BY town_city ORDER BY COUNT(*) ASC LIMIT 1;"
        ]
    },
    "3696": {
        "db_id": "baseball_1",
        "question": "Compute the total salary that the player with first name Len and last name Barker received between 1985 to 1990.",
        "ground_truth": "SELECT sum(T1.salary) FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id WHERE T2.name_first  =  'Len' AND T2.name_last = 'Barker' AND T1.year BETWEEN 1985 AND 1990;",
        "amends": [
            "Do join `player AS T2` instead of querying only the `salaries` table. Do use `T1.player_id = T2.player_id` as the join condition instead of missing the table relationship entirely. Do reference `T2.name_first` and `T2.name_last` for the name filter instead of using non-existent `first_name` and `last_name` columns in the salaries table. Do qualify the salary column as `T1.salary` instead of the unqualified `salary`. Do qualify the year column as `T1.year` instead of the unqualified `year`. The amended query now correctly joins the player table to filter by player name attributes and properly references table-qualified columns, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about player salary information: join the salary table (T1) with the player table (T2) using T1.player_id = T2.player_id to link salary records to player information. 2) When the question mentions \"first name Len\": \"first name\" actually means T2.name_first = 'Len' in the schema. 3) When the question mentions \"last name Barker\": \"last name\" actually means T2.name_last = 'Barker' in the schema. 4) When the question asks for salary between 1985 to 1990: filter using T1.year BETWEEN 1985 AND 1990 to include the inclusive range. 5) When computing total salary: sum the T1.salary column for all matching records. 6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for any table or column references."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(salary) FROM salaries WHERE first_name = 'Len' AND last_name = 'Barker' AND year BETWEEN 1985 AND 1990",
            "SELECT SUM(T1.salary) AS total_salary\nFROM salary AS T1\nJOIN player AS T2 ON T1.player_id = T2.player_id\nWHERE T2.name_first = 'Len' AND T2.name_last = 'Barker'\nAND T1.year BETWEEN 1985 AND 1990"
        ],
        "rule_sql": [
            "SELECT SUM(s.salary) AS total_salary\nFROM salary s\nJOIN player p ON s.player_id = p.player_id\nWHERE p.name_first = 'Len'\nAND p.name_last = 'Barker'\nAND s.year BETWEEN 1985 AND 1990"
        ]
    },
    "1499": {
        "db_id": "debate",
        "question": "Show the party that has the most people.",
        "ground_truth": "SELECT Party FROM people GROUP BY Party ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do use `Party` instead of `party` for the column name in both the SELECT list and GROUP BY clause to match the correct case sensitivity. Do change the ORDER BY direction to `DESC` instead of `ASC` to find the party with the highest count rather than the lowest. Do remove the alias `count` from the SELECT list instead of keeping it since the RIGHT_SQL only selects the Party column directly. Do maintain the aggregate function `COUNT(*)` in the ORDER BY clause instead of referencing an alias to ensure proper sorting by the actual count values. The amended query now correctly identifies the party with the highest number of people by counting occurrences per party and sorting in descending order."
        ],
        "rules": [
            "1) When the question asks for \"the party that has the most people\": use the exact column name \"Party\" (with capital P) from the people table in both SELECT and GROUP BY clauses. 2) When counting entities: use COUNT(*) to count all rows per group rather than counting a specific column. 3) When finding the maximum count: sort the results by the count in descending order (DESC) rather than ascending order. 4) When the question asks for only the party name: select only the \"Party\" column without including the count value in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT party, COUNT(*) as count FROM people GROUP BY party ORDER BY count ASC LIMIT 1;",
            "SELECT Party FROM people GROUP BY Party ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Party FROM people GROUP BY Party ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "2925": {
        "db_id": "sakila_1",
        "question": "Count the number of different last names actors have.",
        "ground_truth": "SELECT count(DISTINCT last_name) FROM actor",
        "amends": [
            "Do use table name `actor` instead of `actors` and do count `count(DISTINCT last_name)` instead of `COUNT(*)` to count distinct last names rather than all rows, and do remove the unnecessary semicolon instead of including it. The amended query now correctly counts distinct last names from the actor table."
        ],
        "rules": [
            "1) When the question asks to count different last names: use the exact table name \"actor\" instead of \"actors\". 2) When counting distinct values of last names: count distinct values of the \"last_name\" column rather than counting all rows. 3) When the question asks for number of different last names: compute the count of unique values in the \"last_name\" column from the \"actor\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM actors;",
            "SELECT COUNT(DISTINCT last_name) FROM actor"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT last_name) FROM actor;"
        ]
    },
    "316": {
        "db_id": "product_catalog",
        "question": "Find the entry names of the catalog with the attribute that have the most entries.",
        "ground_truth": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)",
        "amends": [
            "Do use `t1.catalog_entry_name` instead of `entry_name` and add `FROM Catalog_Contents AS t1` instead of `FROM catalog`. Do add `JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id = t2.catalog_entry_id` instead of omitting the join. Do add `WHERE t2.attribute_value = (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)` instead of using `ORDER BY COUNT(attribute) DESC LIMIT 1` directly in the main query. Do remove the `ORDER BY` and `LIMIT` from the main query instead of keeping them, as the limiting logic is now handled in the subquery. The amended query now correctly identifies the catalog entry with the most common attribute value by using a correlated subquery instead of attempting to aggregate directly in the main query's ORDER BY clause."
        ],
        "rules": [
            "1) When answering about \"entry names of the catalog\": use \"t1.catalog_entry_name\" as the output column. 2) When combining Catalog_Contents and Catalog_Contents_Additional_Attributes: link rows where \"t1.catalog_entry_id = t2.catalog_entry_id\" and keep only matching pairs (inner match). 3) When the question asks for entries with the most common attribute: find the \"attribute_value\" that appears most frequently in Catalog_Contents_Additional_Attributes by counting occurrences and taking the top result. 4) When filtering for the most common attribute value: use \"t2.attribute_value = (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)\" as the condition. 5) When counting attribute occurrences: use \"count(*)\" to determine frequency of each \"attribute_value\" in Catalog_Contents_Additional_Attributes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT entry_name FROM catalog ORDER BY COUNT(attribute) DESC LIMIT 1;",
            "SELECT t1.catalog_entry_name\nFROM Catalog_Contents AS t1\nJOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id = t2.catalog_entry_id\nWHERE t2.attribute_value = (\n    SELECT attribute_value \n    FROM Catalog_Contents_Additional_Attributes \n    GROUP BY attribute_value \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n)"
        ],
        "rule_sql": [
            "SELECT t1.catalog_entry_name\nFROM Catalog_Contents t1\nINNER JOIN Catalog_Contents_Additional_Attributes t2 ON t1.catalog_entry_id = t2.catalog_entry_id\nWHERE t2.attribute_value = (\n    SELECT attribute_value \n    FROM Catalog_Contents_Additional_Attributes \n    GROUP BY attribute_value \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n)"
        ]
    },
    "1972": {
        "db_id": "products_for_hire",
        "question": "What are all the distinct payment types?",
        "ground_truth": "SELECT DISTINCT payment_type_code FROM payments",
        "amends": [
            "Do select `payment_type_code` instead of `payment_type` and add `DISTINCT` instead of omitting it, which ensures unique payment type codes are returned rather than potentially duplicate payment types. The amended query now matches RIGHT_SQL's behavior by correctly retrieving distinct payment type codes from the payments table."
        ],
        "rules": [
            "1) When the question asks for \"distinct payment types\": select unique values of the exact column \"payment_type_code\" from the Payments table. 2) When the question mentions \"payment types\": \"payment types\" actually means \"payment_type_code\" in the schema. 3) When choosing identifier delimiters: do not replace the exact column name \"payment_type_code\" with any other identifier."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT payment_type FROM payments",
            "SELECT DISTINCT payment_type_code FROM Payments;"
        ],
        "rule_sql": [
            "SELECT DISTINCT payment_type_code FROM Payments;"
        ]
    },
    "1776": {
        "db_id": "small_bank_1",
        "question": "Find the total savings balance of all accounts except the account with name \u2018Brown\u2019.",
        "ground_truth": "SELECT sum(T2.balance) FROM accounts AS T1 JOIN savings AS T2 ON T1.custid  =  T2.custid WHERE T1.name != 'Brown'",
        "amends": [
            "Do add `JOIN savings AS T2 ON T1.custid = T2.custid` instead of querying only the `accounts` table. Do specify `T2.balance` instead of just `balance` to clarify the source table. Do add table alias `AS T1` to the `accounts` table instead of using it without an alias. Do keep the `WHERE T1.name != 'Brown'` filter but apply it to the joined table structure instead of the original single table. The amended query now correctly joins customer accounts with their savings data and sums only the relevant balances, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"total savings balance\": make sure to join the accounts table (as T1) with the savings table (as T2) using T1.custid = T2.custid to access the correct balance information. 2) When the question mentions \"all accounts except the account with name 'Brown'\": apply the filter T1.name != 'Brown' to exclude the specific account. 3) When computing the total savings balance: sum the values from T2.balance (not just balance) to ensure the correct column from the savings table is used. 4) When combining T1 and T2 for shared entities: link rows where T1.custid = T2.custid exactly as shown in the amends and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(balance) FROM accounts WHERE name != 'Brown';",
            "SELECT SUM(T2.balance) \nFROM ACCOUNTS AS T1 \nJOIN SAVINGS AS T2 ON T1.custid = T2.custid \nWHERE T1.name != 'Brown'"
        ],
        "rule_sql": [
            "SELECT SUM(T2.balance) AS total_savings_balance\nFROM ACCOUNTS AS T1\nINNER JOIN SAVINGS AS T2 ON T1.custid = T2.custid\nWHERE T1.name != 'Brown';"
        ]
    },
    "4985": {
        "db_id": "soccer_2",
        "question": "What was the most popular position at tryouts?",
        "ground_truth": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use column name `pPos` instead of `position` in both SELECT and GROUP BY clauses. Do reference table `tryout` instead of `tryouts` as the data source. Do order by `count(*)` directly in the ORDER BY clause instead of using an alias `count`. Do remove the explicit column alias `as count` since it's not referenced in the ORDER BY. The amended query now correctly aggregates by position and orders by the actual count value to find the most frequent position.",
            "Do reference the table as `tryout` instead of `Tryout` to match the correct case sensitivity. Do remove the `COUNT(*)` column from the SELECT list instead of including it, as only the `pPos` column is needed in the final result. Do maintain the `GROUP BY pPos` clause to group by position. Do keep the `ORDER BY count(*) DESC` to order by the count of players in each position. Do preserve the `LIMIT 1` to return only the position with the highest count. The amended query now correctly returns only the position with the most players, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"most popular position at tryouts\": make sure the output order: pPos first, then count. 2) When the question mentions \"position\": \"position\" actually means \"pPos in schema\". 3) When the question mentions \"most popular\" or asks for the highest frequency: rank rows by count of pPos in descending order and keep the first 1 row. 4) When the question asks for \"count of positions\": compute the number of rows using the column pPos. 5) When the question says \"by position\": organize results by the token for pPos and compute count per group. 6) When choosing identifier delimiters: do not replace the exact column name pPos with any other identifier like position.",
            "1) When the question asks for the most popular position at tryouts: use the table name \"tryout\" exactly as specified in the schema with lowercase spelling. 2) When counting players per position: group by the \"pPos\" column and count the number of rows for each position. 3) When determining the most popular position: order the results by the count in descending order and keep only the top result using LIMIT 1. 4) When presenting the final result: include only the \"pPos\" column in the output, not the count column itself."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT position, COUNT(*) as count FROM tryouts GROUP BY position ORDER BY count DESC LIMIT 1;",
            "SELECT pPos, COUNT(*) FROM Tryout GROUP BY pPos ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT pPos FROM tryout GROUP BY pPos ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT pPos FROM tryout GROUP BY pPos ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "6892": {
        "db_id": "tracking_orders",
        "question": "Find all the order items whose product id is 11. What are the order item ids?",
        "ground_truth": "SELECT order_item_id FROM order_items WHERE product_id = 11",
        "amends": [
            "Do filter on `product_id = 11` instead of `product_id = 12` to correct the product selection criteria. The amended query now matches RIGHT_SQL's behavior by returning order items for the correct product ID."
        ],
        "rules": [
            "1) When filtering order items by product id: use the exact literal value '11' for the product_id condition instead of '12'"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT order_item_id FROM order_items WHERE product_id = 12;",
            "SELECT order_item_id FROM Order_Items WHERE product_id = 11;"
        ],
        "rule_sql": [
            "SELECT order_item_id FROM Order_Items WHERE product_id = 11;"
        ]
    },
    "683": {
        "db_id": "customers_card_transactions",
        "question": "Show the number of all customers without an account.",
        "ground_truth": "SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)",
        "amends": [
            "Do use `count(*)` instead of `COUNT(*)` for consistent function casing. Do filter with `customer_id NOT IN (subquery)` instead of `account_id IS NOT NULL` to exclude customers without accounts. Do add a correlated subquery `SELECT customer_id FROM Accounts` instead of omitting it to properly identify customers with accounts. Do reference the `Customers` table instead of `customers` for correct table name casing. The amended query now correctly counts only customers who do not have associated accounts, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"number of all customers without an account\": use count(*) to count rows. 2) When identifying customers without accounts: filter using customer_id NOT IN (SELECT customer_id FROM Accounts) instead of checking account_id IS NOT NULL. 3) When referencing the customers table: use the exact table name \"Customers\" with proper casing. 4) When counting customers without accounts: ensure the count includes only those customers whose customer_id does not appear in the Accounts table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE account_id IS NOT NULL;",
            "SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)"
        ]
    },
    "2191": {
        "db_id": "formula_1",
        "question": "What are the names of races that were held after 2017 and the circuits were in the country of Spain?",
        "ground_truth": "SELECT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = \"Spain\" AND T1.year > 2017",
        "amends": [
            "Do add `T1.` prefix to `name` instead of using unqualified `name`. Do change the FROM clause to `JOIN circuits AS T2 ON T1.circuitid = T2.circuitid` instead of querying only the `races` table. Do move the country filter to `T2.country = \"Spain\"` instead of `country = 'Spain'` since the country column exists in the circuits table rather than the races table. Do keep the year filter `T1.year > 2017` but with proper table qualification. The amended query now correctly joins the races and circuits tables to properly filter by country and retrieves the intended results matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about race names: make sure the output order: T1.name 2) When the question mentions \"races\": use table \"races\" as T1 3) When the question mentions \"circuits\": use table \"circuits\" as T2 4) When combining races and circuits tables: link rows where T1.circuitid = T2.circuitid and keep only matching pairs (inner match) 5) When filtering by year after 2017: apply T1.year > 2017 6) When filtering by country Spain: apply T2.country = \"Spain\" with exact literal \"Spain\" in double quotes"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM races WHERE year > 2017 AND country = 'Spain';",
            "SELECT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T1.year > 2017 AND T2.country = 'Spain'"
        ],
        "rule_sql": [
            "SELECT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T1.year > 2017 AND T2.country = \"Spain\""
        ]
    },
    "4923": {
        "db_id": "store_product",
        "question": "How many stores are headquarted in each city?",
        "ground_truth": "SELECT t3.headquartered_city ,  count(*) FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city",
        "amends": [
            "Do use `t3.headquartered_city` in the SELECT list instead of `city` and change the GROUP BY to match this column instead of `headquarters`. Do add `store AS t1 JOIN store_district AS t2 ON t1.store_id = t2.store_id JOIN district AS t3 ON t2.district_id = t3.district_id` as the FROM clause with proper joins instead of just `stores` as the source table. Do remove the incorrect table reference and implement the correct three-table join structure to properly relate stores to their districts and headquarters cities. The amended query now correctly counts stores by their headquartered city through the proper table relationships."
        ],
        "rules": [
            "1) When answering about \"stores headquarted in each city\": make sure the output order: t3.headquartered_city, COUNT(t1.store_id) 2) When the question mentions \"city\": \"city\" actually means \"t3.headquartered_city\" in schema 3) When the question asks for \"count of stores\": compute the number of rows using the canonical key token t1.store_id 4) When the question says \"per city\"/\"by city\": organize results by t3.headquartered_city and compute count per group 5) When combining T1, T2, and T3 for shared entities: link rows where t1.store_id = t2.store_id and t2.district_id = t3.district_id; keep only matching pairs (inner match)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, COUNT(*) FROM stores GROUP BY headquarters;",
            "SELECT t3.headquartered_city, COUNT(*) AS store_count\nFROM store AS t1\nJOIN store_district AS t2 ON t1.Store_ID = t2.Store_ID\nJOIN district AS t3 ON t2.District_ID = t3.District_ID\nGROUP BY t3.headquartered_city"
        ],
        "rule_sql": [
            "SELECT t3.headquartered_city, COUNT(t1.store_id) \nFROM store AS t1 \nJOIN store_district AS t2 ON t1.store_id = t2.store_id \nJOIN district AS t3 ON t2.district_id = t3.district_id \nGROUP BY t3.headquartered_city \nORDER BY t3.headquartered_city"
        ]
    },
    "4618": {
        "db_id": "entertainment_awards",
        "question": "What are the total number of the audiences who visited any of the festivals?",
        "ground_truth": "SELECT sum(Num_of_Audience) FROM festival_detail",
        "amends": [
            "Do select `sum(Num_of_Audience)` instead of `COUNT(*)`. Do query from `festival_detail` instead of `audiences`. Do remove the `WHERE festival_id IS NOT NULL` filter instead of keeping it. The amended query now correctly calculates total audience numbers from the appropriate table without unnecessary filtering."
        ],
        "rules": [
            "1) When answering about \"total number of audiences who visited any of the festivals\": make sure to sum the \"Num_of_Audience\" column instead of counting rows. 2) When calculating total audience numbers: use the \"festival_detail\" table instead of the \"audiences\" table. 3) When computing total audience count: do not apply any filtering condition on festival_id being null or not null."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM audiences WHERE festival_id IS NOT NULL;",
            "SELECT SUM(Num_of_Audience) FROM festival_detail;"
        ],
        "rule_sql": [
            "SELECT SUM(Num_of_Audience) AS Total_Audience FROM festival_detail;"
        ]
    },
    "1523": {
        "db_id": "insurance_and_eClaims",
        "question": "Find the names of customers who have no policies associated.",
        "ground_truth": "SELECT customer_details FROM customers EXCEPT SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id",
        "amends": [
            "Do select `customer_details` instead of `name` from the `customers` table. Do use `EXCEPT` to find customers without policies instead of filtering for `policy_id IS NULL`. Do add a join between `policies` and `customers` on `customer_id` to identify customers with existing policies, instead of relying on a potentially missing `policy_id` column. Do remove the `WHERE` clause entirely instead of using an incorrect null check that may not capture the intended business logic of finding customers without any associated policies. The amended query now correctly identifies customers without policies by excluding those that appear in the policies table join."
        ],
        "rules": [
            "1) When selecting customer names from the customers table: use the exact column name \"customer_details\" instead of \"name\". 2) When finding customers without policies: use EXCEPT operation to exclude customers that appear in the policies table rather than checking for NULL policy_id. 3) When combining customers and policies tables: link rows where \"customer_id\" values are equal between both tables. 4) When identifying customers with existing policies: join the policies table to the customers table on customer_id to find customers that have associated policies."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM customers WHERE policy_id IS NULL;",
            "SELECT Customer_Details FROM Customers\nEXCEPT\nSELECT c.Customer_Details \nFROM Customers c\nJOIN Policies p ON c.Customer_ID = p.Customer_ID"
        ],
        "rule_sql": [
            "SELECT customer_details FROM Customers\nEXCEPT\nSELECT c.customer_details FROM Customers c\nJOIN Policies p ON c.Customer_ID = p.Customer_ID;"
        ]
    },
    "318": {
        "db_id": "product_catalog",
        "question": "Find the entry name of the catalog with the highest price (in USD).",
        "ground_truth": "SELECT catalog_entry_name FROM catalog_contents ORDER BY price_in_dollars DESC LIMIT 1",
        "amends": [
            "Do use column `catalog_entry_name` instead of `entry_name` in the SELECT list. Do reference table `catalog_contents` instead of `catalog` in the FROM clause. Do use column `price_in_dollars` instead of `price` in the ORDER BY clause. The amended query now correctly references the appropriate table and columns to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"entry name\": use the exact column \"catalog_entry_name\" from table \"Catalog_Contents\". 2) When the question asks about \"catalog\": use table \"Catalog_Contents\" instead of \"catalog\". 3) When the question mentions \"price (in USD)\": use the exact column \"price_in_dollars\" from table \"Catalog_Contents\". 4) When the question asks for the \"highest price\": order rows by \"price_in_dollars\" in descending order and keep only the first row. 5) When producing output: return only the \"catalog_entry_name\" column for the row with the highest price."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT entry_name FROM catalog ORDER BY price DESC LIMIT 1;",
            "SELECT catalog_entry_name FROM Catalog_Contents ORDER BY price_in_dollars DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT catalog_entry_name FROM Catalog_Contents ORDER BY price_in_dollars DESC LIMIT 1;"
        ]
    },
    "782": {
        "db_id": "race_track",
        "question": "What is the name of the track that has had the greatest number of races?",
        "ground_truth": "SELECT T2.name FROM race AS T1 JOIN track AS T2 ON T1.track_id  =  T2.track_id GROUP BY T1.track_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.name` from the `track` table instead of `track_name` from the `tracks` table. Do join `race AS T1` with `track AS T2` on `T1.track_id = T2.track_id` instead of querying a single table. Do add `GROUP BY T1.track_id` to aggregate by track identifier instead of omitting grouping. Do order by `count(*) DESC` to sort by race count instead of using an undefined `race_count` column. The amended query now correctly identifies the track with the most races by joining race and track tables and counting occurrences per track, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"the name of the track that has had the greatest number of races\": make sure the output order: T2.name 2) When the question mentions \"track name\": \"track name\" actually means \"T2.name in schema\" 3) When combining T1 and T2 for shared entities: link rows where T1.track_id = T2.track_id exactly as shown in the amends; keep only matching pairs (inner match) 4) When the question asks for \"greatest number of races\": rank rows by count(*) in descending direction and keep the first 1 row 5) When the question says \"per track\"/\"by track\": organize results by T1.track_id and compute requested aggregates per group"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT track_name FROM tracks ORDER BY race_count DESC LIMIT 1;",
            "SELECT T2.Name \nFROM race AS T1 \nJOIN track AS T2 ON T1.Track_ID = T2.Track_ID \nGROUP BY T1.Track_ID \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Name\nFROM race T1\nJOIN track T2 ON T1.Track_ID = T2.Track_ID\nGROUP BY T1.Track_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "1030": {
        "db_id": "phone_1",
        "question": "Find all phones that have word 'Full' in their accreditation types. List the Hardware Model name and Company name.",
        "ground_truth": "SELECT Hardware_Model_name ,  Company_name FROM phone WHERE Accreditation_type LIKE 'Full';",
        "amends": [
            "Do select `Hardware_Model_name` and `Company_name` instead of `hw.model_name` and `c.company_name`. Do use a single table `phone` instead of joining `phones`, `hardware_models`, and `companies` tables. Do filter with `Accreditation_type LIKE 'Full'` instead of `p.accreditation_type LIKE '%Full%'` to match exact 'Full' values rather than containing 'Full'. The amended query now correctly retrieves hardware model and company names directly from the phone table with precise accreditation filtering."
        ],
        "rules": [
            "1) When answering about phones with accreditation types containing 'Full': select \"Hardware_Model_name\" and \"Company_name\" from the phone table. 2) When filtering for accreditation types: use \"Accreditation_type LIKE 'Full'\" to match exact 'Full' values rather than containing 'Full'. 3) When the question mentions 'Hardware Model name' and 'Company name': these correspond to the exact column tokens \"Hardware_Model_name\" and \"Company_name\" in the phone table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT hw.model_name, c.company_name \nFROM phones p\nJOIN hardware_models hw ON p.hardware_model_id = hw.id\nJOIN companies c ON p.company_id = c.id\nWHERE p.accreditation_type LIKE '%Full%';",
            "SELECT Hardware_Model_name, Company_name FROM phone WHERE Accreditation_type = 'Full';"
        ],
        "rule_sql": [
            "SELECT Hardware_Model_name, Company_name FROM phone WHERE Accreditation_type LIKE 'Full'"
        ]
    },
    "6599": {
        "db_id": "train_station",
        "question": "How many train stations are there?",
        "ground_truth": "SELECT count(*) FROM station",
        "amends": [
            "Do reference the `station` table instead of the `airports` table in the FROM clause. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the station table instead of the airports table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"How many train stations are there?\": make sure to reference the \"station\" table instead of the \"airports\" table. 2) When counting entities: use lowercase \"count(*)\" for consistency with the schema requirements. 3) When the question asks for \"how many train stations\": count all records from the \"station\" table as each record represents a train station."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM airports;",
            "SELECT count(*) FROM station;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM station;"
        ]
    },
    "794": {
        "db_id": "coffee_shop",
        "question": "Which membership card has more than 5 members?",
        "ground_truth": "SELECT Membership_card FROM member GROUP BY Membership_card HAVING count(*)  >  5",
        "amends": [
            "Do select `Membership_card` instead of `card_id` and use `GROUP BY Membership_card` instead of no grouping. Do use `HAVING count(*) > 5` instead of `WHERE member_count > 5` to filter aggregated results rather than individual rows. Do query from `member` table instead of `memberships` table. The amended query now correctly identifies membership cards with more than 5 members by using proper aggregation and filtering, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"membership card has more than 5 members\": make sure the output order: Membership_card. 2) When the question asks for \"count of members\": compute the number of rows using the canonical key token for members (e.g., count(*) from member table). 3) When the question asks for \"more than 5 members\": filter aggregated results using HAVING count(*) > 5 rather than filtering individual rows. 4) When grouping by membership card: organize results by Membership_card column from member table and compute count per group. 5) When producing output: select Membership_card instead of card_id as the final result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT card_id FROM memberships WHERE member_count > 5;",
            "SELECT Membership_card FROM member GROUP BY Membership_card HAVING COUNT(*) > 5"
        ],
        "rule_sql": [
            "SELECT Membership_card FROM member GROUP BY Membership_card HAVING COUNT(*) > 5 ORDER BY Membership_card;"
        ]
    },
    "205": {
        "db_id": "bike_1",
        "question": "Give me the zip code where the average mean humidity is below 70 and at least 100 trips took place.",
        "ground_truth": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100",
        "amends": [
            "Do use `HAVING avg(mean_humidity) < 70` instead of incorrectly placing the aggregate filter in the `WHERE` clause. Do remove the `JOIN trips ON weather.date = trips.date` instead of attempting to join unrelated tables. Do add a separate `INTERSECT` query with `SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*) >= 100` instead of incorrectly using `COUNT(trips.trip_id)` within the weather table context. Do use `count(*)` instead of `COUNT(trips.trip_id)` since the trips table is now properly separated. Do change the table name from `trips` to `trip` to match the correct schema. The amended query now correctly identifies zip codes that meet both humidity and trip count criteria through set intersection rather than an invalid join approach."
        ],
        "rules": [
            "1) When filtering on aggregate functions like average mean humidity: place the aggregate condition in a HAVING clause instead of the WHERE clause. 2) When combining criteria from unrelated tables like weather and trip: use INTERSECT to find common zip codes that meet both conditions rather than attempting to join on unrelated columns. 3) When counting trips to meet a minimum threshold: use count(*) with the trip table grouped by zip_code instead of trying to count trip_id from an unrelated join. 4) When referring to the trips table: use the exact table name \"trip\" as specified in the schema. 5) When checking for average mean humidity below 70: use the exact literal value 70 without quotes as it's a numeric comparison."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT zip_code FROM weather JOIN trips ON weather.date = trips.date WHERE AVG(mean_humidity) < 70 AND COUNT(trips.trip_id) >= 100 GROUP BY zip_code",
            "SELECT zip_code FROM weather GROUP BY zip_code HAVING AVG(mean_humidity) < 70\nINTERSECT\nSELECT zip_code FROM trip GROUP BY zip_code HAVING COUNT(*) >= 100"
        ],
        "rule_sql": [
            "SELECT zip_code FROM weather GROUP BY zip_code HAVING AVG(mean_humidity) < 70\nINTERSECT\nSELECT zip_code FROM trip GROUP BY zip_code HAVING COUNT(*) >= 100"
        ]
    },
    "6348": {
        "db_id": "school_bus",
        "question": "How many drivers are there?",
        "ground_truth": "SELECT count(*) FROM driver",
        "amends": [
            "Do query the `driver` table instead of the `customers` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the driver table instead of the customers table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"how many drivers\": query the \"driver\" table instead of the \"customers\" table. 2) When counting records: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" for consistency."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers;",
            "SELECT count(*) FROM driver;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM driver;"
        ]
    },
    "4832": {
        "db_id": "aircraft",
        "question": "What are the names of all aicrafts that have never won any match?",
        "ground_truth": "SELECT Aircraft FROM aircraft WHERE Aircraft_ID NOT IN (SELECT Winning_Aircraft FROM MATCH)",
        "amends": [
            "Do reference the `Aircraft` column instead of `name` and use table name `aircraft` instead of `aircrafts`. Do use `Aircraft_ID` instead of `aircraft_id` in the main query's WHERE clause. Do reference `Winning_Aircraft` instead of `winner_aircraft_id` in the subquery and use table name `MATCH` instead of `matches`. The amended query now correctly matches the intended logic by using the proper column and table names from the schema."
        ],
        "rules": [
            "1) When the question asks for aircraft names: use the exact column \"Aircraft\" from table \"aircraft\" (not \"name\"). 2) When referring to the aircraft table: use the exact table name \"aircraft\" (not \"aircrafts\"). 3) When filtering aircraft by ID in the main query: use the exact column \"Aircraft_ID\" from table \"aircraft\". 4) When checking for winning aircraft in matches: use the exact column \"Winning_Aircraft\" from table \"MATCH\" (not \"winner_aircraft_id\"). 5) When checking which aircraft have never won: find aircraft where \"Aircraft_ID\" is not in the set of \"Winning_Aircraft\" values from the \"MATCH\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM aircrafts WHERE aircraft_id NOT IN (SELECT winner_aircraft_id FROM matches);",
            "SELECT Aircraft FROM aircraft WHERE Aircraft_ID NOT IN (SELECT Winning_Aircraft FROM match WHERE Winning_Aircraft IS NOT NULL)"
        ],
        "rule_sql": [
            "SELECT Aircraft FROM aircraft WHERE Aircraft_ID NOT IN (SELECT Winning_Aircraft FROM match WHERE Winning_Aircraft IS NOT NULL)"
        ]
    },
    "2472": {
        "db_id": "movie_1",
        "question": "Return reviewer name, movie title, stars, and ratingDate. And sort the data first by reviewer name, then by movie title, and lastly by number of stars.",
        "ground_truth": "SELECT T3.name ,  T2.title ,  T1.stars ,  T1.ratingDate FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID ORDER BY T3.name ,  T2.title ,  T1.stars",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT reviewer.name, movie.title, rating.stars, rating.ratingDate \nFROM reviewer \nJOIN rating ON reviewer.rID = rating.rID \nJOIN movie ON rating.mID = movie.mID \nORDER BY reviewer.name, movie.title, rating.stars DESC;"
        ],
        "rule_sql": [
            "SELECT r.name AS reviewer_name, m.title AS movie_title, rt.stars, rt.ratingDate\nFROM Reviewer r\nJOIN Rating rt ON r.rID = rt.rID\nJOIN Movie m ON rt.mID = m.mID\nORDER BY r.name, m.title, rt.stars;"
        ]
    },
    "4650": {
        "db_id": "college_3",
        "question": "What are the maximum and minumum grade points?",
        "ground_truth": "SELECT max(gradepoint) ,  min(gradepoint) FROM GRADECONVERSION",
        "amends": [
            "Do reference table `GRADECONVERSION` instead of `students` and use column `gradepoint` instead of `grade` for both aggregate functions. Do remove the aliases `max_grade` and `min_grade` instead of keeping them, and use lowercase function names `max` and `min` instead of uppercase `MAX` and `MIN`. The amended query now correctly calculates aggregates from the GRADECONVERSION table's gradepoint column without unnecessary aliases."
        ],
        "rules": [
            "1) When answering about maximum and minimum grade points: use table \"GRADECONVERSION\" instead of \"students\" and column \"gradepoint\" instead of \"grade\" for both aggregate functions. 2) When computing maximum and minimum values: use lowercase function names \"max\" and \"min\" instead of uppercase \"MAX\" and \"MIN\". 3) When the question asks for maximum and minimum values without specifying output column names: do not add aliases like \"max_grade\" and \"min_grade\" to the output columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(grade) AS max_grade, MIN(grade) AS min_grade FROM students;",
            "SELECT max(gradepoint), min(gradepoint) FROM Gradeconversion"
        ],
        "rule_sql": [
            "SELECT max(gradepoint), min(gradepoint) FROM Gradeconversion"
        ]
    },
    "5539": {
        "db_id": "products_gen_characteristics",
        "question": "What is the code of the category that the product with the name 'flax' belongs to?",
        "ground_truth": "SELECT product_category_code FROM products WHERE product_name  =  \"flax\"",
        "amends": [
            "Do use column `product_category_code` instead of `category_id` in the SELECT list. Do use filter condition `product_name = \"flax\"` instead of `name = 'flax'` in the WHERE clause, changing both the column reference and the string literal quotation style. The amended query now correctly retrieves the category code using the appropriate column names and string formatting to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the category code of a product: select the column \"product_category_code\" instead of \"category_id\". 2) When filtering products by name with the value 'flax': use the column \"product_name\" instead of \"name\" and use double quotes around the literal value \"flax\" instead of single quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT category_id FROM products WHERE name = 'flax';",
            "SELECT product_category_code FROM Products WHERE product_name = 'flax';"
        ],
        "rule_sql": [
            "SELECT product_category_code FROM Products WHERE product_name = \"flax\""
        ]
    },
    "4433": {
        "db_id": "network_2",
        "question": "How many people are older than every engineer?",
        "ground_truth": "SELECT count(*) FROM Person WHERE age  >  (SELECT max(age) FROM person WHERE job  =  'engineer')",
        "amends": [
            "Do reference the `Person` table instead of `people` in the main query. Do add the filter `WHERE job = 'engineer'` in the subquery instead of omitting it, which correctly restricts the maximum age calculation to only engineers. Do reference the `person` table instead of `engineers` in the subquery, as the engineers should be filtered from the main person table rather than using a separate table. The amended query now correctly counts people older than the maximum age of engineers by properly filtering the subquery to only engineer records."
        ],
        "rules": [
            "1) When the question mentions \"people\": use the table \"Person\" as the main data source. 2) When calculating the maximum age of engineers: filter records where job equals 'engineer' exactly. 3) When comparing ages: use the condition that age must be greater than the maximum engineer age. 4) When counting people: count all rows from the Person table that satisfy the age condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM people WHERE age > (SELECT MAX(age) FROM engineers)",
            "SELECT COUNT(*) \nFROM Person \nWHERE age > (SELECT MAX(age) FROM Person WHERE job = 'engineer')"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Person WHERE age > (SELECT MAX(age) FROM Person WHERE job = 'engineer')"
        ]
    },
    "4887": {
        "db_id": "school_player",
        "question": "For each denomination, return the denomination and the count of schools with that denomination.",
        "ground_truth": "SELECT Denomination ,  COUNT(*) FROM school GROUP BY Denomination",
        "amends": [
            "Do use table name `school` instead of `schools` and capitalize column name `Denomination` instead of lowercase `denomination` in both SELECT and GROUP BY clauses, while maintaining the same COUNT(*) aggregation. The amended query now correctly references the singular table name and uses consistent capitalization for the Denomination column throughout the query."
        ],
        "rules": [
            "1) When the question asks for \"denomination\": use the exact column token \"Denomination\" from table \"school\" with proper capitalization. 2) When counting schools per denomination: use COUNT(*) to count all rows in each denomination group. 3) When grouping results by denomination: use GROUP BY \"Denomination\" to organize results by each unique denomination value. 4) When referring to the school table: use the exact table name \"school\" (singular) instead of \"schools\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT denomination, COUNT(*) FROM schools GROUP BY denomination;",
            "SELECT Denomination, COUNT(*) FROM school GROUP BY Denomination;"
        ],
        "rule_sql": [
            "SELECT \"Denomination\", COUNT(*) FROM \"school\" GROUP BY \"Denomination\""
        ]
    },
    "3066": {
        "db_id": "loan_1",
        "question": "Find the name of bank branch that provided the greatest total amount of loans.",
        "ground_truth": "SELECT T1.bname FROM bank AS T1 JOIN loan AS T2 ON T1.branch_id  =  T2.branch_id GROUP BY T1.bname ORDER BY sum(T2.amount) DESC LIMIT 1",
        "amends": [
            "Do select `T1.bname` instead of `branch_name` and add aggregation with `sum(T2.amount)` instead of ordering by raw `amount`. Do join `bank AS T1` to `loan AS T2` on `T1.branch_id = T2.branch_id` instead of querying only `loans` table. Do add `GROUP BY T1.bname` instead of omitting grouping. Do order by `sum(T2.amount) DESC` instead of `amount DESC` to correctly aggregate loan amounts per branch. The amended query now matches RIGHT_SQL's behavior by properly calculating the branch with the highest total loan amount."
        ],
        "rules": [
            "1) When the question asks for the name of a bank branch: use the exact column token \"T1.bname\" instead of \"branch_name\". 2) When calculating total loan amounts per branch: join table \"bank AS T1\" to table \"loan AS T2\" using the condition \"T1.branch_id = T2.branch_id\" and keep only matching pairs (inner match). 3) When aggregating loan amounts by branch: use \"sum(T2.amount)\" to calculate the total amount and group by \"T1.bname\". 4) When finding the branch with the greatest total loan amount: order the results by \"sum(T2.amount) DESC\" and take the first row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT branch_name FROM loans ORDER BY amount DESC LIMIT 1;",
            "SELECT T1.bname\nFROM bank AS T1\nJOIN loan AS T2 ON T1.branch_ID = T2.branch_ID\nGROUP BY T1.bname\nORDER BY SUM(T2.amount) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.bname FROM bank AS T1 INNER JOIN loan AS T2 ON T1.branch_ID = T2.branch_ID GROUP BY T1.bname ORDER BY SUM(T2.amount) DESC LIMIT 1"
        ]
    },
    "2972": {
        "db_id": "sakila_1",
        "question": "What are all the movies rated as R? List the titles.",
        "ground_truth": "SELECT title FROM film WHERE rating  =  'R'",
        "amends": [
            "Do reference table `film` instead of `movies` in the FROM clause. Do filter for rating `'R'` instead of `'PG'` in the WHERE condition. The amended query now correctly selects titles from the film table with an R rating instead of PG-rated movies from a non-existent movies table."
        ],
        "rules": [
            "1) When the question asks about movies: use the table \"film\" instead of \"movies\" as the data source. 2) When filtering for movies rated as R: use the exact literal value 'R' (not 'PG') for the rating condition. 3) When listing movie titles: select the \"title\" column from the \"film\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM movies WHERE rating = 'PG'",
            "SELECT title FROM film WHERE rating = 'R';"
        ],
        "rule_sql": [
            "SELECT title FROM film WHERE rating = 'R';"
        ]
    },
    "5404": {
        "db_id": "shop_membership",
        "question": "What are names for top three branches with most number of membership?",
        "ground_truth": "SELECT name FROM branch ORDER BY membership_amount DESC LIMIT 3",
        "amends": [
            "Do select `name` from the `branch` table instead of `branch_name` from `branches`. Do order by `membership_amount` in descending order instead of `member_count`. The amended query now correctly retrieves the top 3 branches by membership count using the proper table and column names."
        ],
        "rules": [
            "1) When the question asks for \"names\" of branches: use the exact column \"name\" from table \"branch\" instead of \"branch_name\" from \"branches\". 2) When the question asks for \"top three branches with most number of membership\": order by the exact column \"membership_amount\" in descending order instead of \"member_count\". 3) When the question asks for \"top three\": limit the results to exactly 3 rows after ordering by membership amount in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT branch_name FROM branches ORDER BY member_count DESC LIMIT 3;",
            "SELECT name FROM branch ORDER BY membership_amount DESC LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT name FROM branch ORDER BY membership_amount DESC LIMIT 3"
        ]
    },
    "6516": {
        "db_id": "scientist_1",
        "question": "What is the name of the project that requires the fewest number of hours, and the names of the scientists assigned to it?",
        "ground_truth": "SELECT T2.name ,  T3.name FROM assignedto AS T1 JOIN projects AS T2 ON T1.project  =  T2.code JOIN scientists AS T3 ON T1.scientist  =  T3.SSN WHERE T2.hours  =  (SELECT min(hours) FROM projects)",
        "amends": [
            "Do select `T2.name` and `T3.name` instead of `p.name` and `s.name`. Do use `assignedto AS T1` as the primary table instead of `projects p`. Do join `projects AS T2` on `T1.project = T2.code` instead of joining `scientists s` on `p.project_id = s.project_id`. Do add a second join to `scientists AS T3` on `T1.scientist = T3.SSN` instead of omitting it. Do use `WHERE T2.hours = (SELECT min(hours) FROM projects)` instead of `WHERE p.hours = (SELECT MAX(hours) FROM projects)`, changing both the aggregate function from MAX to min and the table reference from p to T2. The amended query now correctly uses the assignedto table as a bridge between projects and scientists and finds projects with minimum hours instead of maximum hours, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"the name of the project that requires the fewest number of hours\": use T2.name from the projects table (aliased as T2) as the project name. 2) When answering about \"the names of the scientists assigned to it\": use T3.name from the scientists table (aliased as T3) as the scientist names. 3) When the question asks for the project with \"fewest number of hours\": find the minimum value of T2.hours using min(hours) from the projects table. 4) When combining tables for this question: use assignedto as T1 as the primary table, join projects as T2 on T1.project = T2.code, and join scientists as T3 on T1.scientist = T3.SSN. 5) When filtering for the project with minimum hours: use WHERE T2.hours = (SELECT min(hours) FROM projects) to match projects with the minimum hours value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.name, s.name FROM projects p JOIN scientists s ON p.project_id = s.project_id WHERE p.hours = (SELECT MAX(hours) FROM projects);",
            "SELECT T2.name, T3.name\nFROM assignedto AS T1\nJOIN projects AS T2 ON T1.project = T2.code\nJOIN scientists AS T3 ON T1.scientist = T3.SSN\nWHERE T2.hours = (SELECT min(hours) FROM projects)"
        ],
        "rule_sql": [
            "SELECT T2.name AS project_name, T3.name AS scientist_name\nFROM AssignedTo AS T1\nJOIN Projects AS T2 ON T1.Project = T2.Code\nJOIN Scientists AS T3 ON T1.Scientist = T3.SSN\nWHERE T2.hours = (SELECT min(hours) FROM Projects)"
        ]
    },
    "2946": {
        "db_id": "sakila_1",
        "question": "How many customers have an active value of 1?",
        "ground_truth": "SELECT count(*) FROM customer WHERE active = '1'",
        "amends": [
            "Do reference table `customer` instead of `customers` and filter on `active = '1'` instead of `active = 0`, changing both the table name and the filter condition to match the correct boolean value representation. The amended query now correctly counts active customers from the proper table with the right filter condition."
        ],
        "rules": [
            "1) When the question asks about customers: use the exact table name \"customer\" instead of \"customers\". 2) When filtering for active customers with value 1: use the exact literal '1' (as a string) instead of 0, since the schema represents boolean values as strings. 3) When counting customers: count rows from the \"customer\" table where the \"active\" column equals '1'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE active = 0;",
            "SELECT COUNT(*) FROM customer WHERE active = '1';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM customer WHERE active = '1';"
        ]
    },
    "808": {
        "db_id": "chinook_1",
        "question": "Find the number of albums.",
        "ground_truth": "SELECT count(*) FROM ALBUM",
        "amends": [
            "Do query the `ALBUM` table instead of the `songs` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)`. The amended query now correctly counts records from the ALBUM table instead of the songs table."
        ],
        "rules": [
            "1) When answering about \"number of albums\": query the \"ALBUM\" table instead of the \"songs\" table. 2) When counting records: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" to count all rows from the specified table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM songs;",
            "SELECT count(*) FROM Album;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM Album"
        ]
    },
    "6793": {
        "db_id": "activity_1",
        "question": "What is the name of the activity with the most students?",
        "ground_truth": "SELECT T1.activity_name FROM Activity AS T1 JOIN Participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `JOIN Participates_in AS T2 ON T1.actID = T2.actID` instead of querying only the activities table. Do change the SELECT list to `T1.activity_name` instead of just `activity_name` and add table aliases. Do add `GROUP BY T1.actID` instead of omitting grouping. Do change the ORDER BY to `count(*) DESC` instead of `student_count DESC` to count actual participants. Do add table alias `Activity AS T1` instead of using the table name directly. The amended query now correctly counts participants per activity and returns the most popular one, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"activity with the most students\": make sure the output order: T1.activity_name. 2) When the question mentions \"most students\": \"students\" actually means \"participants counted from Participates_in table\" in schema. 3) When combining Activity AS T1 and Participates_in AS T2 for shared entities: link rows where T1.actID = T2.actID exactly as shown; keep only matching pairs (inner match). 4) When the question asks for \"count of students per activity\": compute the number of rows using T2.actID as the counting key and group by T1.actID. 5) When the question asks for \"activity with the most students\": rank rows by count(*) in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT activity_name FROM activities ORDER BY student_count DESC LIMIT 1;",
            "SELECT T1.activity_name\nFROM Activity AS T1\nJOIN Participates_in AS T2 ON T1.actid = T2.actid\nGROUP BY T1.actid\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.activity_name\nFROM Activity AS T1\nINNER JOIN Participates_in AS T2 ON T1.actid = T2.actid\nGROUP BY T1.actid, T1.activity_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "2550": {
        "db_id": "county_public_safety",
        "question": "Show names of cities and names of counties they are in.",
        "ground_truth": "SELECT T1.Name ,  T2.Name FROM city AS T1 JOIN county_public_safety AS T2 ON T1.County_ID  =  T2.County_ID",
        "amends": [
            "Do select `T1.Name` and `T2.Name` instead of `city_name` and `county_name`. Do join `city AS T1` with `county_public_safety AS T2` instead of `cities` with `counties`. Do use join condition `T1.County_ID = T2.County_ID` instead of `cities.county_id = counties.id`. The amended query now correctly retrieves city and county public safety names from the appropriate tables with the proper join relationship."
        ],
        "rules": [
            "1) When answering about \"names of cities and names of counties they are in\": make sure the output order: T1.Name, T2.Name 2) When the question mentions \"cities\": \"cities\" actually means \"city AS T1\" in schema 3) When the question mentions \"counties\": \"counties\" actually means \"county_public_safety AS T2\" in schema 4) When combining T1 and T2 for shared entities: link rows where T1.County_ID = T2.County_ID exactly as shown; keep only matching pairs (inner match)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city_name, county_name FROM cities JOIN counties ON cities.county_id = counties.id;",
            "SELECT T1.Name, T2.Name FROM city AS T1 JOIN county_public_safety AS T2 ON T1.County_ID = T2.County_ID"
        ],
        "rule_sql": [
            "SELECT T1.Name, T2.Name FROM city AS T1 INNER JOIN county_public_safety AS T2 ON T1.County_ID = T2.County_ID"
        ]
    },
    "246": {
        "db_id": "musical",
        "question": "What are the names of musicals with nominee \"Bob Fosse\"?",
        "ground_truth": "SELECT Name FROM musical WHERE Nominee  =  \"Bob Fosse\"",
        "amends": [
            "Do reference the `Name` column instead of `musical_name` and use the `musical` table instead of `musals`. Do use double quotes for the string literal `\"Bob Fosse\"` instead of single quotes and reference the `Nominee` column instead of `nominee`. The amended query now correctly retrieves musical names by Bob Fosse from the proper table structure."
        ],
        "rules": [
            "1) When the question asks for musical names: use the \"Name\" column from the musical table instead of \"musical_name\". 2) When the question mentions \"Bob Fosse\": use the exact string literal \"Bob Fosse\" with double quotes. 3) When filtering for nominee \"Bob Fosse\": reference the \"Nominee\" column instead of \"nominee\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT musical_name FROM musicals WHERE nominee = 'Bob Fosse';",
            "SELECT \"Name\" FROM \"musical\" WHERE \"Nominee\" = \"Bob Fosse\""
        ],
        "rule_sql": [
            "SELECT Name FROM musical WHERE Nominee = \"Bob Fosse\";"
        ]
    },
    "84": {
        "db_id": "student_assessment",
        "question": "What are the ids of the candidates that have an outcome code of Pass?",
        "ground_truth": "SELECT candidate_id FROM candidate_assessments WHERE asessment_outcome_code = \"Pass\"",
        "amends": [
            "Do select `candidate_id` instead of `id` and use table `candidate_assessments` instead of `candidates`. Do filter on `asessment_outcome_code` instead of `outcome_code` and use double quotes instead of single quotes for the string literal. The amended query now correctly retrieves candidate assessment records with a pass outcome from the appropriate table."
        ],
        "rules": [
            "1) When answering about candidate ids with pass outcomes: use the exact column name \"candidate_id\" from table \"Candidate_Assessments\" instead of \"id\". 2) When filtering for pass outcomes: use the exact column name \"asessment_outcome_code\" and the exact string literal 'Pass' with single quotes. 3) When the question mentions \"candidates\": the data actually comes from table \"Candidate_Assessments\" rather than \"Candidates\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM candidates WHERE outcome_code = 'Pass';",
            "SELECT candidate_id FROM Candidate_Assessments WHERE asessment_outcome_code = \"Pass\";"
        ],
        "rule_sql": [
            "SELECT candidate_id FROM Candidate_Assessments WHERE asessment_outcome_code = 'Pass'"
        ]
    },
    "637": {
        "db_id": "store_1",
        "question": "List the name of playlist which has number of tracks greater than 100.",
        "ground_truth": "SELECT T2.name FROM playlist_tracks AS T1 JOIN playlists AS T2 ON T2.id = T1.playlist_id GROUP BY T1.playlist_id HAVING count(T1.track_id)  >  100;",
        "amends": [
            "Do use `T2.name` from the joined table instead of `name` directly from the playlists table. Do add a `JOIN` between `playlist_tracks AS T1` and `playlists AS T2` on `T2.id = T1.playlist_id` instead of querying only the playlists table. Do add `GROUP BY T1.playlist_id` to group by playlist identifier instead of no grouping. Do move the count filter to `HAVING count(T1.track_id) > 100` instead of using `WHERE track_count > 100` on a direct column. The amended query now correctly calculates track counts from the junction table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"number of tracks per playlist\": calculate the count using T1.track_id grouped by T1.playlist_id instead of using a direct track_count column. 2) When combining playlist_tracks (T1) and playlists (T2) tables: link rows where T2.id = T1.playlist_id using an inner join. 3) When filtering playlists by track count greater than 100: apply the condition count(T1.track_id) > 100 in the HAVING clause after grouping. 4) When selecting playlist names: use T2.name from the joined playlists table instead of name directly from the playlists table. 5) When grouping results: use GROUP BY T1.playlist_id to organize by playlist identifier."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM playlists WHERE track_count > 100",
            "SELECT T2.name \nFROM playlist_tracks AS T1 \nJOIN playlists AS T2 ON T2.id = T1.playlist_id \nGROUP BY T1.playlist_id \nHAVING COUNT(T1.track_id) > 100"
        ],
        "rule_sql": [
            "SELECT T2.name \nFROM playlist_tracks T1\nINNER JOIN playlists T2 ON T2.id = T1.playlist_id\nGROUP BY T1.playlist_id\nHAVING COUNT(T1.track_id) > 100"
        ]
    },
    "5958": {
        "db_id": "cre_Theme_park",
        "question": "Find the names of the tourist attractions that is either accessible by walk or at address 660 Shea Crescent.",
        "ground_truth": "SELECT T2.Name FROM Locations AS T1 JOIN Tourist_Attractions AS T2 ON T1.Location_ID  =  T2.Location_ID WHERE T1.Address  =  \"660 Shea Crescent\" OR T2.How_to_Get_There  =  \"walk\"",
        "amends": [
            "Do select `T2.Name` from the `Tourist_Attractions` table instead of `name` from a single table. Do join `Locations AS T1` with `Tourist_Attractions AS T2` on `T1.Location_ID = T2.Location_ID` instead of querying only `tourist_attractions` without any joins. Do filter on `T1.Address = \"660 Shea Crescent\"` and `T2.How_to_Get_There = \"walk\"` with an OR condition instead of using `accessible_by_walk = 'yes'` and `address = '660 Shea Crescent'`. The amended query now correctly joins location data with tourist attraction information and uses the proper column names for address and accessibility criteria, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about tourist attractions: make sure the output order: T2.Name\n2) When combining Locations and Tourist_Attractions tables: link rows where T1.Location_ID = T2.Location_ID and keep only matching pairs (inner match)\n3) When the question mentions \"accessible by walk\": \"accessible by walk\" actually means T2.How_to_Get_There = \"walk\" in schema\n4) When the question mentions \"address 660 Shea Crescent\": \"address 660 Shea Crescent\" actually means T1.Address = \"660 Shea Crescent\" in schema\n5) When filtering for either condition: use OR logic between T1.Address = \"660 Shea Crescent\" and T2.How_to_Get_There = \"walk\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM tourist_attractions WHERE accessible_by_walk = 'yes' OR address = '660 Shea Crescent';",
            "SELECT T2.Name \nFROM Locations AS T1\nJOIN Tourist_Attractions AS T2 ON T1.Location_ID = T2.Location_ID\nWHERE T1.Address = '660 Shea Crescent' OR T2.How_to_Get_There = 'walk'"
        ],
        "rule_sql": [
            "SELECT T2.Name \nFROM Locations T1 \nINNER JOIN Tourist_Attractions T2 ON T1.Location_ID = T2.Location_ID \nWHERE T1.Address = '660 Shea Crescent' OR T2.How_to_Get_There = 'walk' \nORDER BY T2.Name"
        ]
    },
    "1719": {
        "db_id": "riding_club",
        "question": "How many players are there?",
        "ground_truth": "SELECT count(*) FROM player",
        "amends": [
            "Do select from `player` table instead of `teams` table. The amended query now correctly counts records from the player table as intended."
        ],
        "rules": [
            "1) When answering about \"how many players\": make sure to select from the \"player\" table instead of the \"teams\" table. 2) When counting players: count records from the \"player\" table using the canonical key for players."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM teams;",
            "SELECT COUNT(*) FROM player;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM player;"
        ]
    },
    "6525": {
        "db_id": "wine_1",
        "question": "List the names and scores of all wines.",
        "ground_truth": "SELECT Name ,  Score FROM WINE",
        "amends": [
            "Do select `Name` and `Score` columns instead of `name` and `price`. Do query from `WINE` table instead of `wines` table. The amended query now correctly retrieves the intended columns from the specified table."
        ],
        "rules": [
            "1) When the question asks for \"names and scores of all wines\": select columns \"Name\" and \"Score\" from table \"WINE\". 2) When referring to the wine table: use the exact table name \"WINE\" instead of \"wines\". 3) When selecting output columns: maintain the order \"Name\" then \"Score\" as implied by the question's phrasing."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, price FROM wines;",
            "SELECT Name, Score FROM wine;"
        ],
        "rule_sql": [
            "SELECT Name, Score FROM WINE"
        ]
    },
    "6652": {
        "db_id": "driving_school",
        "question": "Find out the first name and last name of staff lived in city Damianfort.",
        "ground_truth": "SELECT T2.first_name ,  T2.last_name FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id WHERE T1.city = \"Damianfort\";",
        "amends": [
            "Do add `Addresses AS T1` and `Staff AS T2` as joined tables instead of querying only from `staff`. Do use `JOIN` with `ON T1.address_id = T2.staff_address_id` instead of no join condition. Do reference columns as `T2.first_name` and `T2.last_name` instead of direct column names. Do move the city filter to the `Addresses` table with `T1.city = \"Damianfort\"` instead of filtering on `staff.city`. The amended query now correctly joins staff with their addresses to filter by city and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about staff names and their city: make sure to join Addresses as T1 and Staff as T2 using T1.address_id = T2.staff_address_id to link staff with their addresses. 2) When filtering by city \"Damianfort\": use T1.city = \"Damianfort\" exactly as specified, not staff.city. 3) When selecting staff names: reference them as T2.first_name and T2.last_name with the correct table alias. 4) When combining Addresses and Staff tables: perform an inner match where T1.address_id equals T2.staff_address_id to ensure only staff with matching addresses are included."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM staff WHERE city = 'Damianfort'",
            "SELECT T2.first_name, T2.last_name FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id WHERE T1.city = 'Damianfort'"
        ],
        "rule_sql": [
            "SELECT T2.first_name, T2.last_name\nFROM Addresses AS T1\nINNER JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id\nWHERE T1.city = \"Damianfort\""
        ]
    },
    "1422": {
        "db_id": "college_2",
        "question": "What is the title of the prerequisite class of International Finance course?",
        "ground_truth": "SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.title  =  'International Finance')",
        "amends": [
            "Do reference the `course` table instead of `courses` in the main query. Do use `IN` with a subquery instead of `=` with a scalar subquery. Do add a proper join between `prereq` and `course` tables instead of incorrectly querying the same `courses` table twice. Do reference `prereq_id` from the `prereq` table instead of `prerequisite` from a non-existent column. Do use proper table aliases `T1` and `T2` instead of no aliases. Do join on `T1.course_id = T2.course_id` instead of incorrectly assuming the subquery returns a single course_id value. The amended query now correctly finds course titles that are prerequisites for 'International Finance' by properly navigating the prerequisite relationship through the prereq table."
        ],
        "rules": [
            "1) When the question asks about prerequisites: use the \"prereq\" table instead of the \"courses\" table to find prerequisite relationships. 2) When finding prerequisites for a specific course: use an IN clause with a subquery instead of assuming a single value will be returned. 3) When joining prerequisite information with course details: link the \"prereq\" table (T1) and \"course\" table (T2) using T1.course_id = T2.course_id to properly navigate the prerequisite relationship. 4) When referencing prerequisite identifiers: use \"prereq_id\" from the \"prereq\" table instead of \"prerequisite\" which doesn't exist. 5) When the question mentions \"International Finance\": this refers to the exact literal value 'International Finance' that must be matched exactly in the title column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM courses WHERE course_id = (SELECT prerequisite FROM courses WHERE title = 'International Finance')",
            "SELECT T2.title\nFROM course T1\nJOIN prereq ON T1.course_id = prereq.course_id\nJOIN course T2 ON prereq.prereq_id = T2.course_id\nWHERE T1.title = 'International Finance'"
        ],
        "rule_sql": [
            "SELECT c2.title \nFROM course c1\nJOIN prereq p ON c1.course_id = p.course_id\nJOIN course c2 ON p.prereq_id = c2.course_id\nWHERE c1.title = 'International Finance'"
        ]
    },
    "5345": {
        "db_id": "manufactory_1",
        "question": "What are the names and average prices of products for manufacturers whose products cost on average 150 or more?",
        "ground_truth": "SELECT avg(T1.Price) ,  T2.name FROM products AS T1 JOIN Manufacturers AS T2 ON T1.manufacturer  =  T2.code GROUP BY T2.name HAVING avg(T1.price) >= 150",
        "amends": [
            "Do join `Manufacturers` as `T2` instead of omitting it, and do use `ON T1.manufacturer = T2.code` instead of no join condition. Do select `T2.name` instead of `manufacturer_name` and do use `avg(T1.Price)` without alias instead of `AVG(price) as average_price`. Do move the price filter to `HAVING avg(T1.price) >= 150` instead of `WHERE average_price >= 150` since aggregate filters require HAVING. Do group by `T2.name` instead of `manufacturer_name` to match the selected column. The amended query now correctly calculates average prices per manufacturer and filters results using proper HAVING clause semantics.",
            "Do place the aggregate function `avg(T1.Price)` first in the SELECT list instead of second, and use lowercase `avg` instead of uppercase `AVG`. Do use lowercase `T2.name` instead of uppercase `T2.Name` in the SELECT list. Do use lowercase `products` and `Manufacturers` instead of mixed case in the FROM clause. Do add explicit `AS` aliases for both tables instead of omitting them. Do use lowercase `T1.manufacturer` and `T2.code` in the join condition instead of mixed case. Do use lowercase `avg(T1.price)` in the HAVING clause instead of uppercase `AVG(T1.Price)`. The amended query now matches RIGHT_SQL's behavior with consistent lowercase formatting and proper column ordering.",
            "Do place `avg(T1.Price)` first in the SELECT list instead of `T2.name` first, while keeping the same JOIN condition `ON T1.manufacturer = T2.code`, maintaining the GROUP BY `T2.name`, and preserving the HAVING clause `avg(T1.price) >= 150` unchanged. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [
            "1) When combining products and manufacturers tables: link rows where T1.manufacturer = T2.code and keep only matching pairs (inner match). 2) When calculating average prices per manufacturer: compute avg(T1.Price) for each group of T2.name. 3) When filtering by average price condition: apply the filter avg(T1.price) >= 150 after grouping using HAVING clause semantics. 4) When selecting manufacturer names: use T2.name instead of manufacturer_name from the products table. 5) When answering about products with average prices 150 or more: make sure the output order: manufacturer name followed by average price.",
            "1) When answering about \"names and average prices of products for manufacturers whose products cost on average 150 or more\": make sure the output order: average price first, then manufacturer name. 2) When referring to table names: use lowercase \"products\" and \"manufacturers\" exactly as shown in the amends. 3) When referring to column names: use lowercase \"t2.name\", \"t1.price\", \"t1.manufacturer\", and \"t2.code\" exactly as shown in the amends. 4) When using aggregate functions: use lowercase \"avg\" instead of uppercase \"AVG\" for average calculations. 5) When combining products and manufacturers tables: link rows where \"t1.manufacturer = t2.code\" exactly as shown in the amends and keep only matching pairs (inner match). 6) When grouping by manufacturer: organize results by \"t2.name\" and compute average price per manufacturer. 7) When filtering manufacturers by average price: include only manufacturers where the average price is 150 or more.",
            "1) When answering about \"names and average prices of products for manufacturers whose products cost on average 150 or more\": make sure the output order: avg(T1.Price) first, then T2.name. 2) When combining products table T1 and Manufacturers table T2: link rows where T1.manufacturer = T2.code exactly as shown and keep only matching pairs (inner match). 3) When grouping by manufacturer names: organize results by T2.name and compute requested aggregates per group. 4) When filtering for manufacturers with average price 150 or more: keep only groups where avg(T1.price) >= 150."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT manufacturer_name, AVG(price) as average_price\nFROM products\nWHERE average_price >= 150\nGROUP BY manufacturer_name",
            "SELECT T2.Name, AVG(T1.Price) \nFROM Products T1 \nJOIN Manufacturers T2 ON T1.Manufacturer = T2.Code \nGROUP BY T2.Name \nHAVING AVG(T1.Price) >= 150",
            "SELECT T2.name, avg(T1.Price) \nFROM products AS T1 \nJOIN Manufacturers AS T2 ON T1.manufacturer = T2.code \nGROUP BY T2.name \nHAVING avg(T1.price) >= 150",
            "SELECT avg(T1.Price), T2.name\nFROM products AS T1\nJOIN Manufacturers AS T2 ON T1.manufacturer = T2.code\nGROUP BY T2.name\nHAVING avg(T1.price) >= 150"
        ],
        "rule_sql": [
            "SELECT avg(t1.price), t2.name\nFROM products t1\nINNER JOIN manufacturers t2 ON t1.manufacturer = t2.code\nGROUP BY t2.name\nHAVING avg(t1.price) >= 150\nORDER BY avg(t1.price), t2.name"
        ]
    },
    "6201": {
        "db_id": "music_4",
        "question": "What are the issue dates of volumes associated with the artist aged 23 or younger?",
        "ground_truth": "SELECT Issue_Date FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T1.age  <=  23",
        "amends": [
            "Do select `Issue_Date` from the `volume` table instead of `issue_date` from `volumes`. Do join `artist` and `volume` tables with `INNER JOIN` on `T1.Artist_ID = T2.Artist_ID` instead of querying only the `volumes` table. Do filter on `T1.age <= 23` from the artist table instead of `artist_age <= 23` from the volumes table. The amended query now correctly retrieves issue dates by joining artist information and filtering based on artist age rather than assuming age data exists in the volumes table."
        ],
        "rules": [
            "1) When the question asks for \"issue dates of volumes\": select \"Issue_Date\" from the \"volume\" table instead of \"issue_date\" from \"volumes\". 2) When combining artist and volume information: link rows where \"T1.Artist_ID = T2.Artist_ID\" using an inner join instead of querying only one table. 3) When filtering by artist age 23 or younger: apply the condition \"T1.age <= 23\" from the artist table instead of assuming age data exists in the volumes table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT issue_date FROM volumes WHERE artist_age <= 23;",
            "SELECT v.Issue_Date \nFROM volume v\nINNER JOIN artist a ON v.Artist_ID = a.Artist_ID\nWHERE a.Age <= 23"
        ],
        "rule_sql": [
            "SELECT v.Issue_Date \nFROM volume v\nINNER JOIN artist a ON v.Artist_ID = a.Artist_ID\nWHERE a.Age <= 23"
        ]
    },
    "2442": {
        "db_id": "movie_1",
        "question": "How many reviewers listed?",
        "ground_truth": "SELECT count(*) FROM Reviewer",
        "amends": [
            "Do count from `Reviewer` table instead of `movies` table. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting reviewers: count from the \"Reviewer\" table instead of the \"movies\" table. 2) When answering about \"how many reviewers listed\": compute the count using the canonical key for reviewers from the \"Reviewer\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies;",
            "SELECT COUNT(*) FROM Reviewer;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Reviewer;"
        ]
    },
    "350": {
        "db_id": "flight_1",
        "question": "What is the count of aircrafts that have a distance between 1000 and 5000?",
        "ground_truth": "SELECT count(*) FROM Aircraft WHERE distance BETWEEN 1000 AND 5000",
        "amends": [
            "Do use `BETWEEN` for the distance range filter instead of separate `>=` and `<=` conditions. Do reference the table as `Aircraft` instead of `aircrafts`. The amended query now correctly counts aircraft with distances between 1000 and 5000 inclusive, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for aircraft count with distance between 1000 and 5000: use the table name \"Aircraft\" exactly as specified in the schema. 2) When filtering for a numeric range between 1000 and 5000 inclusive: use the BETWEEN operator to include both endpoints. 3) When counting aircraft entities: count all rows from the \"Aircraft\" table that satisfy the distance condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM aircrafts WHERE distance >= 1000 AND distance <= 5000;",
            "SELECT COUNT(*) FROM aircraft WHERE distance BETWEEN 1000 AND 5000"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM aircraft WHERE distance BETWEEN 1000 AND 5000;"
        ]
    },
    "3392": {
        "db_id": "manufacturer",
        "question": "Find the component amounts and names of all furnitures that have more than 10 components.",
        "ground_truth": "SELECT Num_of_Component ,  name FROM furniture WHERE Num_of_Component  >  10",
        "amends": [
            "Do use column alias `Num_of_Component` instead of `component_amount` in the SELECT list. Do reference table `furniture` instead of `furnitures` in the FROM clause. Do use filter condition `Num_of_Component > 10` instead of `component_amount > 10` in the WHERE clause. The amended query now correctly references the proper table name and column alias to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"component amounts\": use the exact column token \"Num_of_Component\" from the furniture table. 2) When the question mentions \"furnitures\": it actually means the \"furniture\" table in the schema. 3) When filtering for \"more than 10 components\": apply the condition Num_of_Component > 10 using the exact column token. 4) When answering about \"component amounts and names of all furnitures that have more than 10 components\": make sure the output order: Num_of_Component, name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT component_amount, name FROM furnitures WHERE component_amount > 10",
            "SELECT Num_of_Component, Name FROM furniture WHERE Num_of_Component > 10"
        ],
        "rule_sql": [
            "SELECT Num_of_Component, Name FROM furniture WHERE Num_of_Component > 10 ORDER BY Num_of_Component, Name;"
        ]
    },
    "5119": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "Find the payment method that is used the most often in all the invoices. Give me its code.",
        "ground_truth": "SELECT payment_method_code FROM INVOICES GROUP BY payment_method_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT payment_method_code FROM invoices GROUP BY payment_method_code ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT payment_method_code\nFROM Invoices\nGROUP BY payment_method_code\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "5039": {
        "db_id": "soccer_2",
        "question": "What are the states with colleges that have enrollments less than the some other college?",
        "ground_truth": "SELECT DISTINCT state FROM college WHERE enr  <  (SELECT max(enr) FROM college)",
        "amends": [
            "Do reference table `college` instead of `colleges` in both the main query and subquery. Do use column `enr` instead of `enrollment` in both the WHERE filter and subquery aggregate. Do use aggregate function `max` instead of `MAX` in the subquery. The amended query now correctly references the proper table and column names to match the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"colleges\": use table \"college\" instead of \"colleges\". 2) When the question mentions \"enrollments\": use column \"enr\" instead of \"enrollment\". 3) When finding maximum enrollment: use aggregate function \"max\" on column \"enr\" in the subquery. 4) When comparing enrollments: use the exact comparison operator \"<\" to find colleges with enrollment less than the maximum enrollment. 5) When selecting states: use column \"state\" from table \"college\" and apply DISTINCT to get unique state values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT state FROM colleges WHERE enrollment < (SELECT MAX(enrollment) FROM colleges)",
            "SELECT DISTINCT state FROM College c1 WHERE enr < (SELECT max(enr) FROM College c2 WHERE c2.cName != c1.cName)"
        ],
        "rule_sql": [
            "SELECT DISTINCT c.state FROM College c WHERE c.enr < (SELECT MAX(enr) FROM College)"
        ]
    },
    "2762": {
        "db_id": "election",
        "question": "How many distinct delegates are from counties with population larger than 50000?",
        "ground_truth": "SELECT count(DISTINCT T2.Delegate) FROM county AS T1 JOIN election AS T2 ON T1.County_id  =  T2.District WHERE T1.Population  >  50000",
        "amends": [
            "Do use `count(DISTINCT T2.Delegate)` instead of `COUNT(*)` to count unique delegates rather than all rows. Do add `FROM county AS T1 JOIN election AS T2 ON T1.County_id = T2.District` instead of `FROM delegates` to properly join the county and election tables on the correct relationship. Do use `WHERE T1.Population > 50000` instead of `WHERE county_population > 50000` to filter by the actual population column from the county table. The amended query now correctly counts distinct delegates from counties with populations over 50,000 by properly joining the relevant tables and using the correct population filter."
        ],
        "rules": [
            "1) When counting distinct delegates: use count(DISTINCT T2.Delegate) instead of COUNT(*) to count unique delegates rather than all rows. 2) When joining county and election tables: use FROM county AS T1 JOIN election AS T2 ON T1.County_id = T2.District to properly link the tables on the correct relationship. 3) When filtering by population larger than 50000: use WHERE T1.Population > 50000 instead of WHERE county_population > 50000 to filter by the actual population column from the county table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM delegates WHERE county_population > 50000;",
            "SELECT COUNT(DISTINCT T2.Delegate) \nFROM county AS T1 \nJOIN election AS T2 ON T1.County_Id = T2.District \nWHERE T1.Population > 50000"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T2.Delegate) FROM county AS T1 JOIN election AS T2 ON T1.County_Id = T2.District WHERE T1.Population > 50000"
        ]
    },
    "4982": {
        "db_id": "soccer_2",
        "question": "Find the name of different colleges involved in the tryout in alphabetical order.",
        "ground_truth": "SELECT DISTINCT cName FROM tryout ORDER BY cName",
        "amends": [
            "Do select `cName` instead of `college` and use `DISTINCT` instead of omitting it. Do order by `cName` instead of `college DESC` and remove the descending sort. Do reference table `tryout` instead of `tryouts`."
        ],
        "rules": [
            "1) When the question asks for \"colleges\": use the exact column token \"cName\" from table \"tryout\" instead of \"college\". 2) When listing different/unique colleges: use DISTINCT to return only unique values of \"cName\". 3) When ordering alphabetically: sort by \"cName\" in ascending order (default alphabetical order). 4) When referencing the table: use the exact table name \"tryout\" instead of \"tryouts\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT college FROM tryouts ORDER BY college DESC;",
            "SELECT DISTINCT cName FROM Tryout ORDER BY cName;"
        ],
        "rule_sql": [
            "SELECT DISTINCT cName FROM tryout ORDER BY cName;"
        ]
    },
    "4380": {
        "db_id": "tracking_grants_for_research",
        "question": "What are the result description of the project whose detail is 'sint'?",
        "ground_truth": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'",
        "amends": [
            "Do select `T1.outcome_description` from the `Research_outcomes` table instead of `result_description` from the `projects` table. Do add `JOIN Project_outcomes AS T2 ON T1.outcome_code = T2.outcome_code` and `JOIN Projects AS T3 ON T2.project_id = T3.project_id` instead of querying only the `projects` table. Do filter on `T3.project_details = 'sint'` instead of `detail = 'sint'` to properly reference the joined table. The amended query now correctly joins three tables to retrieve outcome descriptions based on project details, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"result description\" of a project: use \"T1.outcome_description\" from the \"Research_outcomes\" table instead of \"result_description\" from the \"projects\" table. 2) When querying about projects with specific details: join \"Research_outcomes\" as T1, \"Project_outcomes\" as T2, and \"Projects\" as T3 using the exact relationships T1.outcome_code = T2.outcome_code and T2.project_id = T3.project_id. 3) When filtering for projects with detail 'sint': use the exact literal 'sint' and filter on T3.project_details = 'sint' to properly reference the joined Projects table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT result_description FROM projects WHERE detail = 'sint';",
            "SELECT T1.outcome_description \nFROM Research_Outcomes AS T1\nJOIN Project_Outcomes AS T2 ON T1.outcome_code = T2.outcome_code\nJOIN Projects AS T3 ON T2.project_id = T3.project_id\nWHERE T3.project_details = 'sint'"
        ],
        "rule_sql": [
            "SELECT T1.outcome_description \nFROM Research_Outcomes AS T1\nJOIN Project_Outcomes AS T2 ON T1.outcome_code = T2.outcome_code\nJOIN Projects AS T3 ON T2.project_id = T3.project_id\nWHERE T3.project_details = 'sint'"
        ]
    },
    "1158": {
        "db_id": "body_builder",
        "question": "What is the name of the body builder with the greatest body weight?",
        "ground_truth": "SELECT T2.Name FROM body_builder AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Weight DESC LIMIT 1",
        "amends": [
            "Do select `T2.Name` from the `people` table instead of `name` from the `body_builders` table. Do join `people AS T2` to `body_builder AS T1` on `T1.People_ID = T2.People_ID` instead of querying only the `body_builders` table. Do order by `T2.Weight DESC` instead of `body_weight ASC` to get the heaviest person rather than the lightest. The amended query now correctly retrieves the name from the people table joined with body builders and returns the heaviest individual, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"body builder with the greatest body weight\": make sure the output order: T2.Name. 2) When the question mentions \"body builder\": combine tables \"body_builders AS T1\" and \"people AS T2\" where T1.People_ID = T2.People_ID and keep only matching pairs (inner match). 3) When the question asks for \"greatest body weight\": rank rows by T2.Weight in descending direction and keep the first 1 row. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM body_builders ORDER BY body_weight ASC LIMIT 1;",
            "SELECT T2.Name \nFROM body_builder AS T1 \nJOIN people AS T2 ON T1.People_ID = T2.People_ID \nORDER BY T2.Weight DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Name FROM body_builder AS T1 INNER JOIN people AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Weight DESC LIMIT 1"
        ]
    },
    "5849": {
        "db_id": "tracking_share_transactions",
        "question": "What is the total share of transactions?",
        "ground_truth": "SELECT sum(share_count) FROM TRANSACTIONS",
        "amends": [
            "Do use the column name `share_count` instead of `amount` in the SUM aggregation function. The amended query now correctly calculates the sum of share counts from the transactions table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"total share of transactions\": use the exact column name \"share_count\" from the Transactions table to calculate the sum. 2) When computing aggregates from the Transactions table: use the column \"share_count\" for sum calculations instead of any other column like \"amount\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(amount) FROM transactions;",
            "SELECT SUM(share_count) AS total_share FROM Transactions;"
        ],
        "rule_sql": [
            "SELECT SUM(CAST(share_count AS DECIMAL)) AS total_share FROM Transactions;"
        ]
    },
    "5718": {
        "db_id": "dorm_1",
        "question": "List name of all amenities which Anonymous Donor Hall has, and sort the results in alphabetic order.",
        "ground_truth": "SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T2.amenid  =  T1.amenid JOIN dorm AS T3 ON T2.dormid  =  T3.dormid WHERE T3.dorm_name  =  'Anonymous Donor Hall' ORDER BY T1.amenity_name",
        "amends": [
            "Do join `dorm_amenity AS T1` instead of querying `amenities` directly. Do add `has_amenity AS T2` join on `T2.amenid = T1.amenid` instead of omitting this relationship table. Do add `dorm AS T3` join on `T2.dormid = T3.dormid` instead of missing the dorm table connection. Do filter on `T3.dorm_name = 'Anonymous Donor Hall'` instead of `hall_name = 'Anonymous Donor Hall'` to correctly reference the dorm name column. Do select `T1.amenity_name` with table alias instead of just `amenity_name` for explicit table reference. The amended query now correctly joins through the relationship tables to find amenities associated with the specific dorm name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about amenities for a specific dorm: join dorm_amenity AS T1, has_amenity AS T2, and dorm AS T3 instead of querying amenities directly. 2) When combining tables for shared entities: link rows where T2.amenid = T1.amenid and T2.dormid = T3.dormid, keeping only matching pairs (inner match). 3) When filtering for dorm name 'Anonymous Donor Hall': use T3.dorm_name = 'Anonymous Donor Hall' instead of hall_name. 4) When selecting amenity names: use T1.amenity_name with explicit table alias instead of just amenity_name. 5) When sorting results alphabetically: order by T1.amenity_name in ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT amenity_name FROM amenities WHERE hall_name = 'Anonymous Donor Hall' ORDER BY amenity_name ASC;",
            "SELECT T1.amenity_name \nFROM dorm_amenity AS T1\nJOIN has_amenity AS T2 ON T2.amenid = T1.amenid\nJOIN dorm AS T3 ON T2.dormid = T3.dormid\nWHERE T3.dorm_name = 'Anonymous Donor Hall'\nORDER BY T1.amenity_name ASC;"
        ],
        "rule_sql": [
            "SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T2.amenid = T1.amenid JOIN dorm AS T3 ON T2.dormid = T3.dormid WHERE T3.dorm_name = 'Anonymous Donor Hall' ORDER BY T1.amenity_name ASC;"
        ]
    },
    "715": {
        "db_id": "customers_card_transactions",
        "question": "Show id, first and last names for all customers with at least two cards.",
        "ground_truth": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  2",
        "amends": [
            "Do use explicit column references `T1.customer_id`, `T2.customer_first_name`, and `T2.customer_last_name` instead of ambiguous `id`, `first_name`, and `last_name`. Do join `Customers_cards AS T1` with `Customers AS T2` on `T1.customer_id = T2.customer_id` instead of querying a single table. Do add `GROUP BY T1.customer_id` instead of omitting grouping. Do move the count filter to `HAVING count(*) >= 2` instead of using `WHERE COUNT(cards.id) >= 2` which is invalid syntax. Do remove the incorrect aggregate function in the WHERE clause instead of keeping it. The amended query now correctly identifies customers with at least two cards by properly joining the related tables and using HAVING for aggregate conditions."
        ],
        "rules": [
            "1) When the question asks for customer information from multiple tables: join \"Customers_cards\" as T1 with \"Customers\" as T2 on T1.customer_id = T2.customer_id using an inner match. 2) When counting cards per customer: group the results by T1.customer_id to organize by each customer. 3) When filtering for customers with at least two cards: apply the condition count(*) >= 2 after grouping instead of before. 4) When selecting customer identification columns: use explicit references T1.customer_id, T2.customer_first_name, and T2.customer_last_name instead of ambiguous column names. 5) When the question asks for \"id, first and last names\": output the columns in the order T1.customer_id, T2.customer_first_name, T2.customer_last_name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, first_name, last_name FROM customers WHERE COUNT(cards.id) >= 2",
            "SELECT T1.customer_id, T2.customer_first_name, T2.customer_last_name\nFROM Customers_Cards AS T1\nJOIN Customers AS T2 ON T1.customer_id = T2.customer_id\nGROUP BY T1.customer_id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T1.customer_id, T2.customer_first_name, T2.customer_last_name\nFROM Customers_Cards AS T1\nINNER JOIN Customers AS T2 ON T1.customer_id = T2.customer_id\nGROUP BY T1.customer_id\nHAVING COUNT(*) >= 2"
        ]
    },
    "542": {
        "db_id": "store_1",
        "question": "What are the names of the countries and average invoice size of the top countries by size?",
        "ground_truth": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;",
        "amends": [
            "Do use `billing_country` instead of `Country` in both the SELECT list and GROUP BY clause. Do remove the alias `AverageInvoiceSize` instead of keeping it. Do change the ORDER BY to use `AVG(total)` in descending order instead of `Country` in descending order. Do reference `total` instead of `Total` for the aggregate function. The amended query now correctly calculates average invoice totals by billing country and orders the results by the average value rather than alphabetically by country name.",
            "Do add `LIMIT 10` to the `ORDER BY` clause instead of omitting it, which restricts the result set to the top 10 countries by average invoice total rather than returning all countries. The amended query now matches RIGHT_SQL's behavior by limiting the output to the highest-ranking results."
        ],
        "rules": [
            "1) When the question asks for country names: use the exact column token \"billing_country\" from the schema instead of \"Country\". 2) When calculating average invoice size: compute the average of the \"total\" column (not \"Total\") and do not assign an alias to this calculation. 3) When grouping by country: use \"billing_country\" as the grouping key. 4) When ordering results to find top countries by size: order by the average of \"total\" in descending order instead of ordering by country name. 5) When limiting to top results: use the limit clause to return the top rows after ordering by average invoice size.",
            "1) When the question asks for \"top countries by size\": rank countries by average invoice size in descending order and keep the first 10 rows. 2) When answering about \"names of the countries and average invoice size\": make sure the output order: billing_country, AVG(total). 3) When the question mentions \"average invoice size\": \"average invoice size\" actually means \"AVG(total) in schema\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Country, AVG(Total) as AverageInvoiceSize \nFROM invoices \nGROUP BY Country \nORDER BY Country DESC \nLIMIT 10;",
            "SELECT billing_country, AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC;",
            "SELECT billing_country, AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10"
        ],
        "rule_sql": [
            "SELECT billing_country, AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10"
        ]
    },
    "3464": {
        "db_id": "hr_1",
        "question": "Give the name of each department and the number of employees in each.",
        "ground_truth": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name",
        "amends": [
            "Do add `JOIN departments AS T2` with `ON T1.department_id = T2.department_id` instead of querying only the employees table. Do reference `T2.department_name` in both SELECT and GROUP BY instead of directly using `department_name` from the employees table. Do maintain the `COUNT(*)` aggregation and `GROUP BY` structure but now correctly counting employees per department by joining to the departments table to resolve department names from department IDs."
        ],
        "rules": [
            "1) When answering about \"number of employees per department\": make sure the output order: department_name, count of employees. 2) When the question mentions \"department\": \"department\" actually means \"T2.department_name\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.department_id = T2.department_id; keep only matching pairs (inner match). 4) When the question asks for \"count of employees\": compute the number of rows using the canonical key from the employees table. 5) When the question says \"per department\"/\"by department\": organize results by T2.department_name and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department_name, COUNT(*) FROM employees GROUP BY department_name;",
            "SELECT T2.department_name, COUNT(*) AS number_of_employees \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nGROUP BY T2.department_name"
        ],
        "rule_sql": [
            "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) \nFROM departments d \nINNER JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID \nGROUP BY d.DEPARTMENT_NAME \nORDER BY d.DEPARTMENT_NAME"
        ]
    },
    "5806": {
        "db_id": "customer_complaints",
        "question": "Find the address line 1 and 2 of the customer with email \"vbogisich@example.org\".",
        "ground_truth": "SELECT address_line_1 ,  address_line_2 FROM customers WHERE email_address  =  \"vbogisich@example.org\"",
        "amends": [
            "Do reference the `email_address` column instead of `email` in the WHERE clause filter. Do use double quotes around the literal value \"vbogisich@example.org\" instead of single quotes. The amended query now correctly filters by the email_address column and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for customer information filtered by email: use the exact column name \"email_address\" from the Customers table instead of \"email\". 2) When filtering by the email value \"vbogisich@example.org\": use double quotes around the literal value exactly as shown in the schema (\"vbogisich@example.org\") instead of single quotes. 3) When selecting address information for a customer: retrieve both \"address_line_1\" and \"address_line_2\" columns from the Customers table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT address_line_1, address_line_2 FROM customers WHERE email = 'vbogisich@example.org';",
            "SELECT address_line_1, address_line_2 FROM Customers WHERE email_address = \"vbogisich@example.org\""
        ],
        "rule_sql": [
            "SELECT address_line_1, address_line_2 FROM Customers WHERE email_address = \"vbogisich@example.org\""
        ]
    },
    "4076": {
        "db_id": "student_1",
        "question": "Find all first-grade students who are NOT taught by OTHA MOYER. Report their first and last names.",
        "ground_truth": "SELECT DISTINCT T1.firstname ,  T1.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.grade  =  1 EXCEPT SELECT T1.firstname ,  T1.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"OTHA\" AND T2.lastname  =  \"MOYER\"",
        "amends": [
            "Do use `DISTINCT` on the result set instead of omitting it. Do select from `list` table instead of `students` table. Do join on `classroom` instead of `teacher_id`. Do use `EXCEPT` operator to exclude records instead of filtering with `!=` conditions. Do filter for teachers named \"OTHA\" and \"MOYER\" in the exclusion subquery instead of using separate inequality conditions. Do use double quotes for string literals instead of single quotes. The amended query now correctly excludes students taught by the specific teacher while handling potential duplicates and matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting from the database: use the \"list\" table as the main table instead of \"students\" table. 2) When joining tables: join on the \"classroom\" column instead of \"teacher_id\" column. 3) When excluding records for a specific teacher: use EXCEPT operator to exclude students taught by \"OTHA MOYER\" instead of filtering with != conditions. 4) When filtering for the exclusion: in the exclusion subquery, filter for teachers with first name \"OTHA\" and last name \"MOYER\" exactly. 5) When handling string literals: use double quotes around string values like \"OTHA\" and \"MOYER\" instead of single quotes. 6) When ensuring unique results: use DISTINCT on the final result set to remove potential duplicates."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.first_name, s.last_name \nFROM students s\nJOIN teachers t ON s.teacher_id = t.teacher_id\nWHERE s.grade = 1 AND t.first_name != 'OTHA' AND t.last_name != 'MOYER';",
            "SELECT DISTINCT FirstName, LastName\nFROM list\nWHERE Grade = 1\nEXCEPT\nSELECT l.FirstName, l.LastName\nFROM list l\nJOIN teachers t ON l.Classroom = t.Classroom\nWHERE t.FirstName = \"OTHA\" AND t.LastName = \"MOYER\""
        ],
        "rule_sql": [
            "SELECT DISTINCT l.FirstName, l.LastName\nFROM list l\nWHERE l.Grade = 1\nEXCEPT\nSELECT l.FirstName, l.LastName\nFROM list l\nJOIN teachers t ON l.Classroom = t.Classroom\nWHERE t.FirstName = \"OTHA\" AND t.LastName = \"MOYER\""
        ]
    },
    "5746": {
        "db_id": "dorm_1",
        "question": "Find the total number of students living in the male dorm (with gender M).",
        "ground_truth": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'",
        "amends": [
            "Do add joins to `student AS T1 JOIN lives_in AS T2 ON T1.stuid = T2.stuid JOIN dorm AS T3 ON T3.dormid = T2.dormid` instead of querying only the `students` table. Do change the filter to `T3.gender = 'M'` instead of `dorm = 'male'` to properly reference the gender column from the dorm table through the correct join relationships. Do remove the direct reference to `dorm` column in the students table instead of incorrectly filtering on it, as the gender information should come from the joined dorm table. The amended query now correctly counts students based on their dorm gender through proper table relationships instead of relying on potentially incorrect or non-existent column references."
        ],
        "rules": [
            "1) When answering about \"students living in the male dorm\": join student AS T1, lives_in AS T2, and dorm AS T3 using T1.stuid = T2.stuid and T3.dormid = T2.dormid to establish proper relationships between students and their dorms. 2) When filtering for male dorm residents: use T3.gender = 'M' to filter based on the gender column from the dorm table, not the students table. 3) When counting students: count the number of rows using the proper join relationships that connect students to their dorm gender information."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE dorm = 'male'",
            "SELECT COUNT(*) \nFROM Student AS T1 \nJOIN Lives_in AS T2 ON T1.StuID = T2.stuid \nJOIN Dorm AS T3 ON T3.dormid = T2.dormid \nWHERE T3.gender = 'M'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Student AS T1\nJOIN Lives_in AS T2 ON T1.StuID = T2.stuid\nJOIN Dorm AS T3 ON T3.dormid = T2.dormid\nWHERE T3.gender = 'M'"
        ]
    },
    "623": {
        "db_id": "store_1",
        "question": "What is title of album which track Balls to the Wall belongs to?",
        "ground_truth": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = \"Balls to the Wall\";",
        "amends": [
            "Do use `JOIN` with explicit table aliases `T1` and `T2` instead of a subquery. Do reference `T1.title` instead of just `title`. Do join on `T1.id = T2.genre_id` instead of using an equality subquery with `album_id`. Do filter directly on `T2.name = \"Balls to the Wall\"` in the WHERE clause instead of nesting the condition in a subquery. The amended query now correctly joins the albums and tracks tables to find album titles matching the track name.",
            "Do join `ON T1.id = T2.genre_id` instead of `ON T1.id = T2.album_id` to correctly relate albums to tracks by genre rather than album, fixing the join condition to match the intended relationship. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"title of album which track Balls to the Wall belongs to\": make sure the output order: T1.title 2) When combining albums and tracks tables: link rows where T1.id = T2.genre_id and keep only matching pairs (inner match). 3) When filtering for track name \"Balls to the Wall\": use exact literal \"Balls to the Wall\" for T2.name comparison. 4) When selecting album title: reference T1.title instead of just title.",
            "1) When joining albums table (T1) with tracks table (T2): use the join condition T1.id = T2.genre_id instead of T1.id = T2.album_id to correctly relate albums to tracks by genre rather than album. 2) When filtering for the track name 'Balls to the Wall': use the exact literal 'Balls to the Wall' with the correct case and spacing in the tracks table (T2.name). 3) When selecting the album title: retrieve the title column from the albums table (T1.title) as the final output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM albums WHERE album_id = (SELECT album_id FROM tracks WHERE name = 'Balls to the Wall');",
            "SELECT T1.title \nFROM albums T1 \nJOIN tracks T2 ON T1.id = T2.album_id \nWHERE T2.name = 'Balls to the Wall';",
            "SELECT T1.title \nFROM albums T1 \nJOIN tracks T2 ON T1.id = T2.genre_id \nWHERE T2.name = \"Balls to the Wall\""
        ],
        "rule_sql": [
            "SELECT T1.title \nFROM albums T1 \nINNER JOIN tracks T2 ON T1.id = T2.genre_id \nWHERE T2.name = 'Balls to the Wall';"
        ]
    },
    "2736": {
        "db_id": "election",
        "question": "Show the county name and population of all counties.",
        "ground_truth": "SELECT County_name ,  Population FROM county",
        "amends": [
            "Do use `County_name` instead of `county` and `Population` instead of `population` in the SELECT list to match the correct column names. Do reference the table as `county` instead of `counties` in the FROM clause to use the correct table name. The amended query now correctly retrieves county names and populations from the county table matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"county name\": use the exact column name \"County_name\" from the county table. 2) When the question asks for \"population\": use the exact column name \"Population\" from the county table. 3) When selecting from the counties table: use the exact table name \"county\" instead of \"counties\". 4) When answering about \"all counties\": do not apply any population filter (remove the WHERE population > 1000000 condition)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT county, population FROM counties WHERE population > 1000000",
            "SELECT County_name, Population FROM county;"
        ],
        "rule_sql": [
            "SELECT County_name, Population FROM county;"
        ]
    },
    "3856": {
        "db_id": "insurance_policies",
        "question": "Among all the claims, what is the settlement amount of the claim with the largest claim amount? List both the settlement amount and claim amount.",
        "ground_truth": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT 1",
        "amends": [
            "Do use column names `Amount_Settled` and `Amount_Claimed` instead of `settlement_amount` and `claim_amount` to match the actual schema. Do order by `Amount_Claimed` instead of `claim_amount` to reference the correct column. The amended query now correctly selects and orders by the proper column names as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks about \"settlement amount\" and \"claim amount\": use the exact column names \"Amount_Settled\" and \"Amount_Claimed\" from the Settlements table. 2) When finding the claim with the largest claim amount: order rows by \"Amount_Claimed\" in descending order and take the first row. 3) When outputting results: include both \"Amount_Settled\" and \"Amount_Claimed\" columns in the output."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT settlement_amount, claim_amount FROM claims ORDER BY claim_amount DESC LIMIT 1;",
            "SELECT Amount_Settled, Amount_Claimed \nFROM Claims \nORDER BY Amount_Claimed DESC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Amount_Settled, Amount_Claimed \nFROM Settlements \nORDER BY Amount_Claimed DESC \nLIMIT 1;"
        ]
    },
    "6422": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "What are the codes corresponding to document types for which there are less than 3 documents?",
        "ground_truth": "SELECT document_type_code FROM Documents GROUP BY document_type_code HAVING count(*)  <  3",
        "amends": [
            "Do select `document_type_code` from the `Documents` table instead of `code` from `document_types`. Do use `GROUP BY document_type_code` instead of omitting grouping. Do place the count condition in `HAVING count(*) < 3` instead of `WHERE COUNT(documents.id) >= 3` with incorrect table reference and inverted logic. Do remove the incorrect table join to `document_types` instead of including it. The amended query now correctly groups documents by type code and filters for groups with fewer than 3 documents, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about document type codes with less than 3 documents: select \"document_type_code\" from the \"Documents\" table instead of \"code\" from \"document_types\". 2) When counting documents per document type: group results by \"document_type_code\" and compute the count of documents in each group. 3) When filtering for groups with fewer than 3 documents: apply the condition count(*) < 3 in the HAVING clause instead of using WHERE with inverted logic. 4) When the question asks for document type codes: use the exact token \"document_type_code\" from the \"Documents\" table rather than joining with the \"document_types\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT code FROM document_types WHERE COUNT(documents.id) >= 3;",
            "SELECT document_type_code FROM Documents GROUP BY document_type_code HAVING COUNT(*) < 3"
        ],
        "rule_sql": [
            "SELECT document_type_code FROM Documents GROUP BY document_type_code HAVING COUNT(*) < 3"
        ]
    },
    "6462": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "Give the ids of documents that have expenses and contain the letter s in their names.",
        "ground_truth": "SELECT T1.document_id FROM Documents AS T1 JOIN Documents_with_expenses AS T2 ON T1.document_id  =  T2.document_id WHERE T1.document_name LIKE '%s%'",
        "amends": [
            "Do select `T1.document_id` instead of `id` and use table alias `T1` instead of no alias. Do join `Documents_with_expenses AS T2` instead of querying only the `documents` table, using `ON T1.document_id = T2.document_id` instead of filtering by `expenses > 0`. Do filter by `T1.document_name LIKE '%s%'` instead of `name LIKE '%s%'` with proper table qualification. The amended query now correctly joins the expense tracking table and matches the intended behavior."
        ],
        "rules": [
            "1) When selecting document identifiers: use \"T1.document_id\" instead of \"id\" and always qualify with table alias \"T1\". 2) When checking for documents with expenses: join \"Documents_with_expenses AS T2\" using \"T1.document_id = T2.document_id\" instead of filtering by \"expenses > 0\". 3) When filtering documents by names containing the letter s: use \"T1.document_name LIKE '%s%'\" instead of \"name LIKE '%s%'\" with proper table qualification."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM documents WHERE expenses > 0 AND name LIKE '%s%';",
            "SELECT T1.Document_ID\nFROM Documents AS T1\nJOIN Documents_with_Expenses AS T2 ON T1.Document_ID = T2.Document_ID\nWHERE T1.Document_Name LIKE '%s%'"
        ],
        "rule_sql": [
            "SELECT T1.document_id \nFROM Documents AS T1\nJOIN Documents_with_Expenses AS T2 ON T1.document_id = T2.document_id\nWHERE T1.document_name LIKE '%s%'"
        ]
    },
    "5105": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "Show me the distinct payment method codes from the invoice record.",
        "ground_truth": "SELECT DISTINCT payment_method_code FROM INVOICES",
        "amends": [
            "Do select `payment_method_code` instead of `payment_method` and use `DISTINCT` instead of omitting it. Do reference table `INVOICES` instead of `invoice_record`. The amended query now correctly retrieves unique payment method codes from the appropriate table."
        ],
        "rules": [
            "1) When the question asks for \"distinct payment method codes\": use DISTINCT to return only unique values of the exact column token \"payment_method_code\". 2) When the question mentions \"payment method codes\": the exact column token is \"payment_method_code\" (not \"payment_method\"). 3) When the question refers to \"invoice record\": the exact table token is \"INVOICES\" (not \"invoice_record\"). 4) When answering about \"payment method codes from the invoice record\": make sure the output order: \"payment_method_code\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT payment_method FROM invoice_record",
            "SELECT DISTINCT payment_method_code FROM Invoices;"
        ],
        "rule_sql": [
            "SELECT DISTINCT payment_method_code FROM Invoices ORDER BY payment_method_code;"
        ]
    },
    "1928": {
        "db_id": "protein_institute",
        "question": "How many proteins are associated with an institution in a building with at least 20 floors?",
        "ground_truth": "SELECT count(*) FROM institution AS T1 JOIN protein AS T2 ON T1.institution_id  =  T2.institution_id JOIN building AS T3 ON T3.building_id  =  T1.building_id WHERE T3.floors  >=  20",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `p`, `i`, and `b`. Do join `institution AS T1` with `protein AS T2` on `T1.institution_id = T2.institution_id` instead of joining `proteins p` with `institutions i` on `p.institution_id = i.id`. Do join `building AS T3` on `T3.building_id = T1.building_id` instead of joining `buildings b` on `i.building_id = b.id`. Do reference `T3.floors` in the WHERE clause instead of `b.floors`. The amended query now correctly matches the intended logic and table relationships."
        ],
        "rules": [
            "1) When answering about \"proteins associated with an institution in a building with at least 20 floors\": make sure the output order: count of proteins\n2) When combining tables for shared entities: link institution AS T1 with protein AS T2 where T1.institution_id = T2.institution_id and keep only matching pairs (inner match)\n3) When combining tables for shared entities: link building AS T3 with T1 where T3.building_id = T1.building_id and keep only matching pairs (inner match)\n4) When filtering for buildings with at least 20 floors: include only rows where T3.floors >= 20\n5) When counting proteins: compute the number of rows using the canonical key for proteins"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM proteins p JOIN institutions i ON p.institution_id = i.id JOIN buildings b ON i.building_id = b.id WHERE b.floors >= 20;",
            "SELECT COUNT(*) \nFROM protein AS T2\nJOIN Institution AS T1 ON T2.Institution_id = T1.Institution_id\nJOIN building AS T3 ON T1.building_id = T3.building_id\nWHERE T3.Floors >= 20"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS count_of_proteins\nFROM protein AS T2\nINNER JOIN Institution AS T1 ON T2.Institution_id = T1.Institution_id\nINNER JOIN building AS T3 ON T1.building_id = T3.building_id\nWHERE T3.Floors >= 20;"
        ]
    },
    "1943": {
        "db_id": "cinema",
        "question": "Show all the locations with at least two cinemas with capacity above 300.",
        "ground_truth": "SELECT LOCATION FROM cinema WHERE capacity  >  300 GROUP BY LOCATION HAVING count(*)  >=  2",
        "amends": [
            "Do use the table name `cinema` instead of `cinemas` to reference the correct database table. Do remove the alias `cinema_count` from the COUNT(*) aggregation instead of keeping it, as the HAVING clause directly references the aggregate function. Do reference the aggregate function `count(*)` directly in the HAVING clause instead of using the alias `cinema_count`. Do maintain the same SELECT list structure by only including `LOCATION` instead of both location and the count alias. The amended query now correctly filters cinema locations with capacity over 300 that have at least 2 such cinemas, matching the intended behavior."
        ],
        "rules": [
            "1) When referencing the cinema table: use the exact table name \"cinema\" instead of \"cinemas\". 2) When counting cinemas: use count(*) without an alias in the HAVING clause instead of referencing an alias. 3) When selecting output columns: only include the \"LOCATION\" column in the final results, not the count value. 4) When filtering for capacity: use the condition \"capacity > 300\" to find cinemas with capacity above 300. 5) When grouping by location: use \"GROUP BY location\" to organize results by each location. 6) When requiring at least two cinemas: use \"HAVING count(*) >= 2\" to filter locations with two or more qualifying cinemas."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location, COUNT(*) as cinema_count FROM cinemas WHERE capacity > 300 GROUP BY location HAVING cinema_count >= 2;",
            "SELECT Location FROM cinema WHERE Capacity > 300 GROUP BY Location HAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT location FROM cinema WHERE capacity > 300 GROUP BY location HAVING count(*) >= 2"
        ]
    },
    "3399": {
        "db_id": "manufacturer",
        "question": "what is the average number of factories and maximum number of shops for manufacturers that opened before 1990.",
        "ground_truth": "SELECT max(num_of_shops) ,  avg(Num_of_Factories) FROM manufacturer WHERE open_year  <  1990",
        "amends": [
            "Do `max(num_of_shops)` and `avg(Num_of_Factories)` instead of `AVG(factories) as avg_factories` and `MAX(shops) as max_shops` for the column names and aggregation functions. Do `manufacturer` instead of `manufacturers` for the table name. Do `open_year < 1990` instead of `opened_year > 1990` for the filter condition, changing both the column name and the comparison operator direction. Do remove the aliases `avg_factories` and `max_shops` instead of keeping them. The amended query now correctly filters for manufacturers opened before 1990 and calculates the appropriate aggregates on the correct column names.",
            "Do swap the order of aggregate functions by placing `max(num_of_shops)` first instead of `AVG(Num_of_Factories)` first, and do use lowercase function names `max` and `avg` instead of uppercase `AVG` and `MAX`. Do use lowercase column names `num_of_shops` and `open_year` instead of mixed case `Num_of_Shops` and `Open_Year` while maintaining the same filtering condition `open_year < 1990` instead of `Open_Year < 1990`. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [
            "1) When the question asks for \"average number of factories\": use avg(\"Num_of_Factories\") instead of AVG(factories) and do not use an alias like avg_factories. 2) When the question asks for \"maximum number of shops\": use max(\"Num_of_Shops\") instead of MAX(shops) and do not use an alias like max_shops. 3) When the question mentions \"manufacturers\": use table \"manufacturer\" instead of manufacturers. 4) When the question specifies \"opened before 1990\": use condition \"Open_Year\" < 1990 instead of opened_year > 1990, changing both the column name and operator direction.",
            "1) When the question asks for average number of factories and maximum number of shops: place max(num_of_shops) first in the output order before avg(num_of_factories). 2) When using aggregate functions: use lowercase function names max and avg instead of uppercase MAX and AVG. 3) When referring to column names: use lowercase column names num_of_shops and open_year instead of mixed case Num_of_Shops and Open_Year. 4) When filtering manufacturers that opened before 1990: use the condition open_year < 1990 with the exact literal value 1990."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(factories) as avg_factories, MAX(shops) as max_shops \nFROM manufacturers \nWHERE opened_year > 1990;",
            "SELECT AVG(Num_of_Factories), MAX(Num_of_Shops) FROM manufacturer WHERE Open_Year < 1990",
            "SELECT max(num_of_shops), avg(Num_of_Factories) FROM manufacturer WHERE open_year < 1990"
        ],
        "rule_sql": [
            "SELECT max(num_of_shops), avg(num_of_factories) FROM manufacturer WHERE open_year < 1990"
        ]
    },
    "1694": {
        "db_id": "epinions_1",
        "question": "Find the highest rank of all reviews.",
        "ground_truth": "SELECT min(rank) FROM review",
        "amends": [
            "Do reference table `review` instead of `reviews` to correctly target the intended data source. The amended query now matches RIGHT_SQL's behavior by querying the proper table name.",
            "Do use `MIN(rank)` instead of `MAX(rank) AS highest_rank` to find the minimum rank value instead of the maximum. Do remove the alias `highest_rank` instead of keeping it since the minimum rank is being selected without an explicit alias. The amended query now correctly returns the minimum rank value from the review table instead of the maximum."
        ],
        "rules": [
            "1) When the question asks about \"reviews\": use the exact table name \"review\" instead of \"reviews\" as specified in the schema. 2) When finding the \"highest rank\": use MAX(rank) instead of MIN(rank) to get the maximum value.",
            "1) When the question asks for the \"highest rank\" of reviews: use MIN(rank) instead of MAX(rank) to find the minimum rank value, since lower rank numbers indicate higher positions. 2) When selecting the minimum rank value: do not use an alias like \"highest_rank\" since the question asks for the rank value itself rather than a labeled result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(rank) FROM reviews;",
            "SELECT MAX(rank) AS highest_rank FROM review;",
            "SELECT MIN(rank) FROM review;"
        ],
        "rule_sql": [
            "SELECT MIN(rank) FROM review;"
        ]
    },
    "1489": {
        "db_id": "college_2",
        "question": "What are the names of instructors who earn more than at least one instructor from the Biology department?",
        "ground_truth": "SELECT name FROM instructor WHERE salary  >  (SELECT min(salary) FROM instructor WHERE dept_name  =  'Biology')",
        "amends": [
            "Do reference table `instructor` instead of `instructors` in both the main query and subquery. Do use column `dept_name` instead of `department` in the subquery's WHERE filter. Do use lowercase `min(salary)` instead of `MIN(salary)` in the aggregate function. The amended query now correctly references the proper table and column names to match the intended logic."
        ],
        "rules": [
            "1) When answering about instructor names who earn more than at least one Biology department instructor: make sure the output order: name\n2) When the question mentions \"instructors\": \"instructors\" actually means \"instructor\" in schema\n3) When the question mentions \"Biology department\": \"department\" actually means \"dept_name\" in schema with literal value 'Biology'\n4) When comparing salaries: use the exact literal 'Biology' with correct case and spacing for the dept_name filter\n5) When using aggregate functions: use lowercase function names like min() instead of uppercase MIN()"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM instructors WHERE salary > (SELECT MIN(salary) FROM instructors WHERE department = 'Biology');",
            "SELECT name FROM instructor WHERE salary > (SELECT min(salary) FROM instructor WHERE dept_name = 'Biology')"
        ],
        "rule_sql": [
            "SELECT name\nFROM instructor\nWHERE salary > (\n    SELECT min(salary)\n    FROM instructor\n    WHERE dept_name = 'Biology'\n)\nORDER BY name;"
        ]
    },
    "814": {
        "db_id": "chinook_1",
        "question": "Find the full names of employees living in the city of Calgary.",
        "ground_truth": "SELECT FirstName ,  LastName FROM EMPLOYEE WHERE City  =  \"Calgary\"",
        "amends": [
            "Do select `FirstName` and `LastName` columns instead of only `first_name`. Do use table name `EMPLOYEE` instead of `employees`. Do use double quotes around `\"Calgary\"` instead of single quotes. The amended query now correctly retrieves both first and last names from the EMPLOYEE table for Calgary residents."
        ],
        "rules": [
            "1) When the question asks for \"full names of employees\": select both \"FirstName\" and \"LastName\" columns from table \"EMPLOYEE\". 2) When filtering for employees living in \"Calgary\": use the exact literal \"Calgary\" with double quotes. 3) When referring to the employee table: use the exact table name \"EMPLOYEE\" instead of any variations."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM employees WHERE city = 'Calgary';",
            "SELECT FirstName, LastName FROM Employee WHERE City = \"Calgary\";"
        ],
        "rule_sql": [
            "SELECT FirstName, LastName FROM EMPLOYEE WHERE City = \"Calgary\""
        ]
    },
    "2727": {
        "db_id": "storm_record",
        "question": "What are the names of the storms that affected Denmark?",
        "ground_truth": "SELECT T3.name FROM affected_region AS T1 JOIN region AS T2 ON T1.region_id  =  T2.region_id JOIN storm AS T3 ON T1.storm_id  =  T3.storm_id WHERE T2.region_name  =  'Denmark'",
        "amends": [
            "Do select `T3.name` from the `storm` table instead of `name` from the `storms` table. Do join `affected_region AS T1` and `region AS T2` on `T1.region_id = T2.region_id` instead of querying a single table. Do add a second join to `storm AS T3` on `T1.storm_id = T3.storm_id` instead of omitting this relationship. Do filter on `T2.region_name = 'Denmark'` instead of `country = 'Denmark'` to correctly reference the region table. The amended query now properly navigates the relationship between storms and regions through the affected_region junction table to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"storms that affected Denmark\": make sure the output order: T3.name. 2) When the question mentions \"Denmark\": \"Denmark\" actually means \"T2.region_name = 'Denmark'\" in schema. 3) When combining T1 and T2 for shared regions: link rows where T1.region_id = T2.region_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When combining T1 and T3 for shared storms: link rows where T1.storm_id = T3.storm_id exactly as shown in the amends; keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 6) When handling text literals: do not change case, spacing, or punctuation for 'Denmark'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM storms WHERE country = 'Denmark';",
            "SELECT T3.Name \nFROM affected_region AS T1\nJOIN region AS T2 ON T1.Region_id = T2.Region_id\nJOIN storm AS T3 ON T1.Storm_ID = T3.Storm_ID\nWHERE T2.Region_name = 'Denmark'"
        ],
        "rule_sql": [
            "SELECT T3.\"Name\"\nFROM \"affected_region\" T1\nJOIN \"region\" T2 ON T1.\"Region_id\" = T2.\"Region_id\"\nJOIN \"storm\" T3 ON T1.\"Storm_ID\" = T3.\"Storm_ID\"\nWHERE T2.\"Region_name\" = 'Denmark'\nORDER BY T3.\"Name\""
        ]
    },
    "5310": {
        "db_id": "manufactory_1",
        "question": "Find the total revenue for each manufacturer.",
        "ground_truth": "SELECT sum(revenue) ,  name FROM manufacturers GROUP BY name",
        "amends": [
            "Do select `sum(revenue)` and `name` instead of `SUM(price)` as `total_revenue` and `manufacturer`. Do use `manufacturers` table instead of `products` table. Do group by `name` instead of `manufacturer`. The amended query now correctly aggregates revenue by manufacturer name rather than attempting to sum prices from a products table.",
            "Do use lowercase `sum(revenue)` instead of uppercase `SUM(m.Revenue)` with table alias. Do place the aggregate function first in the SELECT list instead of the column name. Do use unqualified `name` instead of qualified `m.Name` with table alias. Do remove the column alias `AS total_revenue` instead of keeping it. The amended query now correctly calculates total revenue by manufacturer name without unnecessary aliasing or qualification."
        ],
        "rules": [
            "1) When answering about \"total revenue for each manufacturer\": make sure the output order: manufacturer name, then total revenue. 2) When the question mentions \"manufacturer\": \"manufacturer\" actually means \"name in manufacturers table\". 3) When the question asks for \"total revenue\": compute the sum of the \"revenue\" column. 4) When the question says \"per manufacturer\"/\"by manufacturer\": organize results by the \"name\" column from the manufacturers table and compute sum of revenue per group.",
            "1) When calculating total revenue for each manufacturer: use lowercase sum(revenue) instead of uppercase SUM(m.Revenue) with table alias. 2) When ordering output columns: place the aggregate function sum(revenue) first in the output list before the name column. 3) When referring to manufacturer names: use unqualified name instead of qualified m.Name with table alias. 4) When presenting results: remove column aliases like AS total_revenue and use the raw column expressions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT manufacturer, SUM(price) AS total_revenue FROM products GROUP BY manufacturer",
            "SELECT m.Name, SUM(m.Revenue) AS total_revenue FROM Manufacturers m GROUP BY m.Name",
            "SELECT sum(revenue), name FROM Manufacturers GROUP BY name"
        ],
        "rule_sql": [
            "SELECT sum(revenue), Name FROM Manufacturers GROUP BY Name ORDER BY Name, sum(revenue)"
        ]
    },
    "1545": {
        "db_id": "insurance_and_eClaims",
        "question": "Which customer is associated with the latest policy?",
        "ground_truth": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)",
        "amends": [
            "Do select `t2.customer_details` instead of `customer_id`. Do add `FROM policies AS t1 JOIN customers AS t2` instead of only `FROM policies`. Do add join condition `ON t1.customer_id = t2.customer_id` instead of omitting it. Do add WHERE filter `t1.start_date = (SELECT max(start_date) FROM policies)` instead of using `ORDER BY policy_id DESC LIMIT 1`. Do remove `ORDER BY policy_id DESC LIMIT 1` instead of keeping it. The amended query now correctly retrieves customer details for the most recent policy based on start_date rather than policy_id ordering."
        ],
        "rules": [
            "1) When answering about \"which customer is associated with the latest policy\": make sure the output order: t2.customer_details. 2) When combining policies and customers tables: link rows where t1.customer_id = t2.customer_id and keep only matching pairs (inner match). 3) When the question mentions \"latest policy\": use the maximum start_date value from the policies table to identify the most recent policy. 4) When filtering for the latest policy: use the condition t1.start_date = (SELECT max(start_date) FROM policies) instead of ordering by policy_id."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT customer_id FROM policies ORDER BY policy_id DESC LIMIT 1;",
            "SELECT t2.Customer_Details \nFROM Policies AS t1 \nJOIN Customers AS t2 ON t1.Customer_ID = t2.Customer_ID \nWHERE t1.Start_Date = (SELECT MAX(Start_Date) FROM Policies)"
        ],
        "rule_sql": [
            "SELECT t2.Customer_Details \nFROM Policies t1 \nINNER JOIN Customers t2 ON t1.Customer_ID = t2.Customer_ID \nWHERE t1.Start_Date = (SELECT MAX(Start_Date) FROM Policies)"
        ]
    },
    "3659": {
        "db_id": "baseball_1",
        "question": "What are the name and id of the team offering the lowest average salary?",
        "ground_truth": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT 1;",
        "amends": [
            "Do select `T1.name` and `T1.team_id` instead of `team_id`, `team_name`, and `AVG(salary) as avg_salary`. Do join `team AS T1` with `salary AS T2` on `T1.team_id = T2.team_id` instead of selecting from only `employees`. Do group by `T1.team_id` instead of `team_id, team_name`. Do order by `avg(T2.salary)` instead of the alias `avg_salary`. The amended query now correctly joins the team and salary tables to calculate average salaries per team and returns the team with the lowest average salary, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"name and id of the team offering the lowest average salary\": make sure the output order: T1.name, T1.team_id. 2) When combining team and salary tables: link rows where T1.team_id = T2.team_id and keep only matching pairs (inner match). 3) When the question asks for \"average salary per team\": organize results by T1.team_id and compute the average of T2.salary per group. 4) When the question mentions \"lowest average salary\": rank rows by average of T2.salary in ascending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT team_id, team_name, AVG(salary) as avg_salary FROM employees GROUP BY team_id, team_name ORDER BY avg_salary ASC LIMIT 1;",
            "SELECT T1.name, T1.team_id\nFROM team AS T1\nJOIN salary AS T2 ON T1.team_id = T2.team_id\nGROUP BY T1.team_id\nORDER BY AVG(T2.salary) ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.name, T1.team_id\nFROM team T1\nINNER JOIN salary T2 ON T1.team_id = T2.team_id\nGROUP BY T1.team_id\nORDER BY AVG(T2.salary) ASC\nLIMIT 1;"
        ]
    },
    "3793": {
        "db_id": "e_learning",
        "question": "Find the number of students who have the word \"son\" in their personal names.",
        "ground_truth": "SELECT COUNT(*) FROM Students WHERE personal_name LIKE \"%son%\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE personal_name LIKE '%son%';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Students WHERE personal_name LIKE '%son%'"
        ]
    },
    "4643": {
        "db_id": "college_3",
        "question": "What is the number of departments in Division \"AS\"?",
        "ground_truth": "SELECT count(*) FROM DEPARTMENT WHERE Division  =  \"AS\"",
        "amends": [
            "Do reference the table as `DEPARTMENT` instead of `departments` to match the correct schema name. Do use the column name `Division` instead of `division` to match the correct column casing. Do use double quotes `\"AS\"` instead of single quotes `'AS'` for the string literal value. The amended query now correctly counts records from the DEPARTMENT table where Division equals \"AS\", matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"number of departments in Division 'AS'\": make sure the output order: COUNT(*) 2) When the question mentions \"departments\": \"departments\" actually means \"DEPARTMENT\" in schema 3) When the question mentions \"Division\": \"Division\" actually means \"Division\" in schema with exact casing 4) When using string literals for comparison: use double quotes \"AS\" instead of single quotes 'AS' for exact value matching 5) When counting departments: compute the number of rows using the DEPARTMENT table where Division equals \"AS\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM departments WHERE division = 'AS';",
            "SELECT COUNT(*) FROM Department WHERE Division = \"AS\";"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Department WHERE Division = \"AS\";"
        ]
    },
    "6662": {
        "db_id": "driving_school",
        "question": "List phone number and email address of customer with more than 2000 outstanding balance.",
        "ground_truth": "SELECT phone_number ,  email_address FROM Customers WHERE amount_outstanding  >  2000;",
        "amends": [
            "Do select `phone_number` and `email_address` instead of `phone` and `email`. Do use table name `Customers` instead of `customers`. Do filter on `amount_outstanding > 2000` instead of `outstanding_balance > 2000`. The amended query now correctly references the actual column and table names to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"phone number\": use the exact column name \"phone_number\" from the Customers table. 2) When the question asks for \"email address\": use the exact column name \"email_address\" from the Customers table. 3) When filtering for customers with more than 2000 outstanding balance: use the exact column name \"amount_outstanding\" and filter for values greater than 2000. 4) When referencing the customer table: use the exact table name \"Customers\" (with capital C)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT phone, email FROM customers WHERE outstanding_balance > 2000",
            "SELECT phone_number, email_address FROM Customers WHERE amount_outstanding > 2000"
        ],
        "rule_sql": [
            "SELECT phone_number, email_address FROM Customers WHERE amount_outstanding > 2000;"
        ]
    },
    "5971": {
        "db_id": "game_1",
        "question": "How many video game types exist?",
        "ground_truth": "SELECT count(DISTINCT gtype) FROM Video_games",
        "amends": [
            "Do select `count(DISTINCT gtype)` instead of `COUNT(*)` to count distinct game types rather than all rows. Do use table `Video_games` instead of `games` to query from the correct data source. The amended query now correctly counts distinct game types from the Video_games table instead of counting all rows from an incorrect table."
        ],
        "rules": [
            "1) When the question asks for \"count of video game types\": count distinct values of the exact token \"gtype\" from the table \"Video_games\". 2) When choosing data source for video game information: use table \"Video_games\" instead of \"games\" to query from the correct data source. 3) When counting distinct types of entities: use count distinct on the specific type column rather than counting all rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM games;",
            "SELECT COUNT(DISTINCT GType) FROM Video_Games;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT GType) FROM Video_Games;"
        ]
    },
    "5377": {
        "db_id": "tracking_software_problems",
        "question": "For each product with some problems, list the count of problems and the product id.",
        "ground_truth": "SELECT count(*) ,  T2.product_id FROM problems AS T1 JOIN product AS T2 ON T1.product_id = T2.product_id GROUP BY T2.product_id",
        "amends": [
            "Do add the `product` table via `JOIN` instead of querying only the `problems` table. Do reference `T2.product_id` in both the SELECT list and GROUP BY clause instead of using `product_id` directly from the `problems` table. Do use the alias `T2` for the product table instead of omitting table aliases. Do specify the join condition `ON T1.product_id = T2.product_id` instead of missing the table relationship entirely. The amended query now correctly joins the tables and groups by the product_id from the product table, matching the RIGHT_SQL's behavior.",
            "Do place `T2.product_id` after the aggregate function instead of listing it first in the SELECT clause. Do use `count(*)` without an alias instead of `COUNT(*) AS problem_count`. Do maintain the same FROM clause with `JOIN product AS T2 ON T1.product_id = T2.product_id` instead of `JOIN Product T2 ON T1.product_id = T2.product_id`, keeping the same join logic and table relationships. Do preserve the identical GROUP BY `T2.product_id` clause. The amended query now correctly returns the count of problems per product ID without an unnecessary alias, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"count of problems per product\": make sure the output order: product_id, count of problems. 2) When combining the problems table (T1) and product table (T2): link rows where T1.product_id = T2.product_id and keep only matching pairs (inner match). 3) When the question asks for \"count of problems\": compute the number of rows using the canonical key from the problems table. 4) When the question says \"per product\" or \"by product\": organize results by T2.product_id and compute the count of problems per group. 5) When producing output: use T2.product_id as the product identifier instead of T1.product_id.",
            "1) When answering about \"count of problems per product\": make sure the output order: count of problems first, then product id. 2) When counting problems: use count(*) without an alias instead of COUNT(*) AS problem_count. 3) When combining Problems and Product tables: link rows where T1.product_id = T2.product_id and keep only matching pairs (inner match). 4) When grouping by product: organize results by T2.product_id and compute the count per group. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT product_id, COUNT(*) FROM problems GROUP BY product_id",
            "SELECT T2.product_id, COUNT(*) AS problem_count\nFROM Problems T1\nJOIN Product T2 ON T1.product_id = T2.product_id\nGROUP BY T2.product_id",
            "SELECT count(*), T2.product_id\nFROM Problems AS T1\nJOIN Product AS T2 ON T1.product_id = T2.product_id\nGROUP BY T2.product_id"
        ],
        "rule_sql": [
            "SELECT COUNT(*), Product.product_id FROM Problems JOIN Product ON Problems.product_id = Product.product_id GROUP BY Product.product_id"
        ]
    },
    "183": {
        "db_id": "bike_1",
        "question": "List all the cities in a decreasing order of each city's stations' highest latitude.",
        "ground_truth": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC",
        "amends": [
            "Do select only `city` instead of including `MAX(latitude)` and aliasing it as `highest_latitude`. Do use table name `station` instead of `stations`. Do reference column `lat` instead of `latitude` in the aggregate function. Do order by `max(lat)` instead of the alias `highest_latitude`. Do use `DESC` ordering instead of `ASC`. The amended query now correctly returns only city names ordered by maximum latitude in descending order, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for cities ordered by their stations' highest latitude: select only the \"city\" column from table \"station\". 2) When computing the highest latitude per city: use the MAX function on column \"lat\" instead of \"latitude\". 3) When ordering results by maximum latitude: order by the computed max(lat) value directly rather than an alias. 4) When the question specifies \"decreasing order\": use DESC ordering direction instead of ASC. 5) When grouping by city to compute maximum latitude: group by the \"city\" column from table \"station\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, MAX(latitude) as highest_latitude FROM stations GROUP BY city ORDER BY highest_latitude ASC;",
            "SELECT city FROM station GROUP BY city ORDER BY MAX(lat) DESC;"
        ],
        "rule_sql": [
            "SELECT city FROM station GROUP BY city ORDER BY MAX(lat) DESC;"
        ]
    },
    "54": {
        "db_id": "farm",
        "question": "Show the census ranking of cities whose status are not \"Village\".",
        "ground_truth": "SELECT Census_Ranking FROM city WHERE Status !=  \"Village\"",
        "amends": [
            "Do reference the table as `city` instead of `cities` and use column names `Census_Ranking` and `Status` instead of `census_ranking` and `status` to match the correct schema. Do use double quotes `\"Village\"` instead of single quotes `'Village'` for the string literal comparison. The amended query now correctly references the proper table and column names with the appropriate string quoting format."
        ],
        "rules": [
            "1) When referencing the table containing city information: use the exact table name \"city\" instead of \"cities\". 2) When selecting census ranking data: use the exact column name \"Census_Ranking\" with proper case and double quotes if needed. 3) When filtering by city status: use the exact column name \"Status\" with proper case and double quotes if needed. 4) When comparing against the literal value \"Village\": use double quotes around the literal as \"Village\" instead of single quotes. 5) When the question asks to show census ranking of cities with status not equal to \"Village\": filter rows where \"Status\" is not equal to \"Village\" and select the \"Census_Ranking\" column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT census_ranking FROM cities WHERE status != 'Village' ORDER BY census_ranking;",
            "SELECT \"Census_Ranking\" FROM \"city\" WHERE \"Status\" != \"Village\";"
        ],
        "rule_sql": [
            "SELECT \"Census_Ranking\" FROM \"city\" WHERE \"Status\" != \"Village\";"
        ]
    },
    "6364": {
        "db_id": "school_bus",
        "question": "List names for drivers from Hartford city and younger than 40.",
        "ground_truth": "SELECT name FROM driver WHERE home_city  =  'Hartford' AND age  <  40",
        "amends": [
            "Do reference table `driver` instead of `drivers`. Do filter on column `home_city` instead of `city`. Do use comparison `age < 40` instead of `age > 40`. The amended query now correctly filters for drivers from Hartford under 40 years old."
        ],
        "rules": [
            "1) When the question mentions \"drivers\": use the exact table name \"driver\" instead of \"drivers\". 2) When the question mentions \"city\": use the exact column name \"home_city\" instead of \"city\". 3) When the question specifies \"younger than 40\": use the comparison operator \"<\" with the value 40 instead of \">\" 40."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM drivers WHERE city = 'Hartford' AND age > 40;",
            "SELECT Name FROM driver WHERE Home_city = 'Hartford' AND Age < 40"
        ],
        "rule_sql": [
            "SELECT Name FROM driver WHERE Home_city = 'Hartford' AND Age < 40"
        ]
    },
    "6577": {
        "db_id": "wine_1",
        "question": "What are the average price and score of wines grouped by appelation?",
        "ground_truth": "SELECT avg(Price) ,  avg(Score) ,  Appelation FROM WINE GROUP BY Appelation",
        "amends": [
            "Do use `avg(Price)` and `avg(Score)` without aliases instead of `AVG(price) as avg_price` and `AVG(score) as avg_score`. Do place `Appelation` at the end of the SELECT list instead of at the beginning. Do reference the table as `WINE` instead of `wines`. The amended query now correctly calculates average price and score grouped by appelation without unnecessary aliases."
        ],
        "rules": [
            "1) When answering about average price and score of wines grouped by appelation: make sure the output order is avg(Price), avg(Score), Appelation. 2) When the question mentions \"wines\": \"wines\" actually means \"WINE\" in schema. 3) When the question asks for \"average price and score grouped by appelation\": compute average of Price and average of Score without aliases, organized by Appelation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT appelation, AVG(price) as avg_price, AVG(score) as avg_score FROM wines GROUP BY appelation;",
            "SELECT avg(Price), avg(Score), Appelation FROM WINE GROUP BY Appelation"
        ],
        "rule_sql": [
            "SELECT AVG(Price), AVG(Score), Appelation FROM wine GROUP BY Appelation"
        ]
    },
    "4857": {
        "db_id": "local_govt_and_lot",
        "question": "List the customer event id and the corresponding move in date and property id.",
        "ground_truth": "SELECT customer_event_id ,  date_moved_in ,  property_id FROM customer_events",
        "amends": [
            "Do select `customer_event_id`, `date_moved_in`, and `property_id` instead of `customer_id`, `event_date`, and `property_name`. The amended query now correctly retrieves the specific event identifier, move-in date, and property reference instead of customer identifiers and property names, matching the intended data structure."
        ],
        "rules": [
            "1) When the question asks for \"customer event id\": select the exact column \"customer_event_id\" from the Customer_Events table. 2) When the question asks for \"move in date\": select the exact column \"date_moved_in\" from the Customer_Event_Notes table. 3) When the question asks for \"property id\": select the exact column \"property_id\" from the Customer_Event_Notes table. 4) When combining data from Customer_Events and Customer_Event_Notes tables: ensure proper joining is performed to link the related records between these tables."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_id, event_date, property_name FROM customer_events",
            "SELECT customer_event_id, date_moved_in, property_id FROM Customer_Events;"
        ],
        "rule_sql": [
            "SELECT ce.customer_event_id, cen.date_moved_in, cen.property_id\nFROM Customer_Events ce\nJOIN Customer_Event_Notes cen ON ce.Customer_Event_ID = cen.Customer_Event_ID;"
        ]
    },
    "1389": {
        "db_id": "college_2",
        "question": "What are the names of instructors who advise more than one student?",
        "ground_truth": "SELECT T1.name FROM instructor AS T1 JOIN advisor AS T2 ON T1.id  =  T2.i_id GROUP BY T2.i_id HAVING count(*)  >  1",
        "amends": [
            "Do select `T1.name` instead of `instructor_name` and use table alias `T1` instead of bare table name. Do join `advisor AS T2` instead of querying only the `instructors` table, using `ON T1.id = T2.i_id` instead of no join condition. Do add `GROUP BY T2.i_id` instead of omitting grouping. Do move the count filter to `HAVING count(*) > 1` instead of `WHERE student_count > 1` using an aggregate count instead of a direct column comparison. The amended query now correctly identifies instructors with multiple advisees by joining the advisor relationship table and counting associations."
        ],
        "rules": [
            "1) When answering about \"names of instructors who advise more than one student\": make sure the output order: T1.name. 2) When the question mentions \"instructors\": \"instructors\" actually means \"T1\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.id = T2.i_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"count of students advised per instructor\": compute the number of rows using the relationship in T2 per T2.i_id. 5) When filtering for instructors with more than one student: apply the condition count(*) > 1 after grouping instead of before grouping."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT instructor_name FROM instructors WHERE student_count > 1;",
            "SELECT T1.name\nFROM instructor AS T1\nJOIN advisor AS T2 ON T1.ID = T2.i_ID\nGROUP BY T2.i_ID\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T1.name\nFROM instructor T1\nJOIN advisor T2 ON T1.ID = T2.i_ID\nGROUP BY T1.ID, T1.name\nHAVING COUNT(*) > 1\nORDER BY T1.name;"
        ]
    },
    "3581": {
        "db_id": "music_1",
        "question": "What are the ids of songs that are available in either mp4 format or have resolution above 720?",
        "ground_truth": "SELECT f_id FROM files WHERE formats  =  \"mp4\" UNION SELECT f_id FROM song WHERE resolution  >  720",
        "amends": [
            "Do select `f_id` instead of `id` and use `UNION` to combine results from two separate queries instead of a single query with `OR`. Do query from `files` table with filter `formats = \"mp4\"` instead of `songs` table with `format = 'mp4'`, and do query from `song` table with filter `resolution > 720` instead of including it in the same `WHERE` clause. Do use proper table names `files` and `song` instead of `songs`, and do use correct column names `formats` and `f_id` instead of `format` and `id`. The amended query now correctly retrieves file IDs from two different tables based on distinct conditions using UNION instead of incorrectly querying a single table with mixed conditions."
        ],
        "rules": [
            "1) When the question asks for song ids that meet either of two conditions: use UNION to combine results from separate queries instead of OR in a single query. 2) When the question mentions \"mp4 format\": query the \"files\" table with filter \"formats = \\\"mp4\\\"\" instead of using \"songs\" table with \"format = 'mp4'\". 3) When the question mentions \"resolution above 720\": query the \"song\" table with filter \"resolution > 720\" instead of including it in the same WHERE clause. 4) When selecting identifiers: use \"f_id\" instead of \"id\" as the output column. 5) When combining results from different tables: ensure proper table names \"files\" and \"song\" are used instead of \"songs\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM songs WHERE format = 'mp4' OR resolution > 720;",
            "SELECT f_id FROM files WHERE formats = 'mp4'\nUNION\nSELECT f_id FROM song WHERE resolution > 720"
        ],
        "rule_sql": [
            "SELECT f_id FROM files WHERE formats = \"mp4\" UNION SELECT f_id FROM song WHERE resolution > 720"
        ]
    },
    "1393": {
        "db_id": "college_2",
        "question": "How many rooms in each building have a capacity of over 50?",
        "ground_truth": "SELECT count(*) ,  building FROM classroom WHERE capacity  >  50 GROUP BY building",
        "amends": [
            "Do reference the `classroom` table instead of the `rooms` table. Do place the `building` column after the aggregate function instead of before it in the SELECT list. Do use the correct table name `classroom` in the FROM clause instead of `rooms`. The amended query now correctly counts rooms with capacity over 50 per building using the appropriate table reference.",
            "Do use `count(*)` without an alias instead of `COUNT(*) AS room_count`. Do place `building` after the aggregate function instead of before it in the SELECT list. Do maintain the same `WHERE capacity > 50` filter and `GROUP BY building` clause. The amended query now correctly returns the count of rooms per building with capacity over 50, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"rooms in each building\": make sure the output order: count of rooms first, then building name. 2) When the question mentions \"rooms\": \"rooms\" actually means \"classroom\" table in schema. 3) When the question asks for \"count of rooms\" per building: compute the number of rows using the classroom table. 4) When filtering for capacity over 50: include only rows where classroom.capacity > 50. 5) When grouping by building: organize results by the building column from classroom table.",
            "1) When counting rooms per building with capacity over 50: use count(*) without an alias instead of COUNT(*) AS room_count. 2) When organizing output columns: place building after the aggregate function in the SELECT list instead of before it. 3) When filtering for capacity over 50: maintain the exact condition WHERE capacity > 50. 4) When grouping results by building: maintain the exact GROUP BY building clause."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT building, COUNT(*) FROM rooms WHERE capacity > 50 GROUP BY building;",
            "SELECT building, COUNT(*) AS room_count FROM classroom WHERE capacity > 50 GROUP BY building;",
            "SELECT COUNT(*), building FROM classroom WHERE capacity > 50 GROUP BY building"
        ],
        "rule_sql": [
            "SELECT COUNT(*), building FROM classroom WHERE capacity > 50 GROUP BY building"
        ]
    },
    "2220": {
        "db_id": "formula_1",
        "question": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?",
        "ground_truth": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = \"Monaco Grand Prix\"",
        "amends": [
            "Do join `results AS T2` on `T1.raceid = T2.raceid` instead of querying only the `races` table. Do reference `T2.fastestlapspeed` instead of `fastest_lap_speed` from the wrong table. Do filter on `T1.name` instead of `race_name` and use double quotes for the string literal. Do use table aliases `T1` and `T2` for clarity instead of no aliases. The amended query now correctly joins to access the fastest lap speed data from the results table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about average fastest lap speed for a specific race: join races table (T1) with results table (T2) using T1.raceid = T2.raceid to access the speed data. 2) When the question mentions \"fastest lap speed\": use T2.fastestlapspeed column from the results table, not fastest_lap_speed from races table. 3) When filtering for race name: use T1.name column with exact string literal 'Monaco Grand Prix' (including double quotes). 4) When filtering for year: use T1.year = 2008 condition. 5) When computing average: calculate AVG(T2.fastestlapspeed) for the filtered and joined results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(fastest_lap_speed) FROM races WHERE race_name = 'Monaco Grand Prix' AND year = 2008;",
            "SELECT AVG(T2.fastestLapSpeed) \nFROM races AS T1\nJOIN results AS T2 ON T1.raceId = T2.raceId\nWHERE T1.name = \"Monaco Grand Prix\" AND T1.year = 2008"
        ],
        "rule_sql": [
            "SELECT AVG(T2.fastestLapSpeed) \nFROM races T1 \nJOIN results T2 ON T1.raceId = T2.raceId \nWHERE T1.name = 'Monaco Grand Prix' \nAND T1.year = 2008"
        ]
    },
    "6121": {
        "db_id": "customers_and_addresses",
        "question": "Find the customer name and date of the orders that have the status \"Delivered\".",
        "ground_truth": "SELECT t1.customer_name ,  t2.order_date FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id WHERE order_status  =  \"Delivered\"",
        "amends": [
            "Do specify table aliases `t1.customer_name` and `t2.order_date` instead of unqualified column names. Do join `customers AS t1` and `customer_orders AS t2` with an `INNER JOIN` on `t1.customer_id = t2.customer_id` instead of querying only the `orders` table. Do filter on `order_status = \"Delivered\"` instead of `status = 'Delivered'` to use the correct column name and quotation style. The amended query now correctly joins customer and order data while filtering on the appropriate status column."
        ],
        "rules": [
            "1) When answering about customer name and date of delivered orders: make sure the output order: customer_name, order_date. 2) When combining customer and order data: link rows where t1.customer_id = t2.customer_id and keep only matching pairs (inner match). 3) When filtering for delivered orders: use the exact condition order_status = \"Delivered\" with double quotes. 4) When selecting customer name: use t1.customer_name from the customers table. 5) When selecting order date: use t2.order_date from the customer_orders table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT customer_name, order_date FROM orders WHERE status = 'Delivered';",
            "SELECT t1.customer_name, t2.order_date\nFROM Customers AS t1\nINNER JOIN Customer_Orders AS t2 ON t1.customer_id = t2.customer_id\nWHERE t2.order_status = \"Delivered\""
        ],
        "rule_sql": [
            "SELECT t1.customer_name, t2.order_date\nFROM Customers t1\nINNER JOIN Customer_Orders t2 ON t1.customer_id = t2.customer_id\nWHERE t2.order_status = \"Delivered\""
        ]
    },
    "6238": {
        "db_id": "ship_1",
        "question": "Find the captain rank that has some captains in both Cutter and Armed schooner classes.",
        "ground_truth": "SELECT rank FROM captain WHERE CLASS  =  'Cutter' INTERSECT SELECT rank FROM captain WHERE CLASS  =  'Armed schooner'",
        "amends": [
            "Do use `INTERSECT` to find common ranks instead of `OR` with `DISTINCT` which would return all ranks from either class. Do query the `captain` table directly instead of joining with `ships` table through `captains`. Do remove the table aliases `c` and `s` instead of keeping them. Do use separate queries for each class condition with `INTERSECT` instead of combining them in a single `WHERE` clause with `OR`. Do remove the `ship_id` join condition entirely instead of maintaining the incorrect table relationship. The amended query now correctly returns only ranks that appear in both 'Cutter' and 'Armed schooner' classes, matching the RIGHT_SQL's intersection behavior."
        ],
        "rules": [
            "1) When the question asks for ranks that appear in both 'Cutter' and 'Armed schooner' classes: use INTERSECT to find common ranks instead of OR with DISTINCT. 2) When querying for captain ranks by ship class: query the captain table directly instead of joining with ships table. 3) When handling table references: do not use table aliases c and s. 4) When checking for multiple class conditions: use separate queries for each class condition with INTERSECT instead of combining them in a single WHERE clause with OR. 5) When dealing with table relationships: remove the ship_id join condition entirely as it represents an incorrect table relationship."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT c.rank \nFROM captains c\nJOIN ships s ON c.ship_id = s.id\nWHERE s.class = 'Cutter' \nOR s.class = 'Armed schooner';",
            "SELECT Rank FROM captain WHERE Class = 'Cutter' INTERSECT SELECT Rank FROM captain WHERE Class = 'Armed schooner'"
        ],
        "rule_sql": [
            "SELECT Rank FROM captain WHERE Class = 'Cutter' INTERSECT SELECT Rank FROM captain WHERE Class = 'Armed schooner'"
        ]
    },
    "6413": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "What is the id of the project with least number of documents?",
        "ground_truth": "SELECT project_id FROM Documents GROUP BY project_id ORDER BY count(*) ASC LIMIT 1",
        "amends": [
            "Do select `project_id` instead of `id` from the `Documents` table instead of the `projects` table. Do add `GROUP BY project_id` instead of omitting it to aggregate documents per project. Do use `count(*)` instead of `COUNT(documents)` to count all documents rather than non-null values in a specific column. Do move the aggregate function from the `ORDER BY` clause to the `SELECT` list instead of using it directly in ordering. The amended query now correctly identifies the project with the fewest documents by grouping and counting documents per project.",
            "Do remove the explicit `COUNT(*) AS document_count` column from the SELECT list instead of including it, as the RIGHT_SQL only needs the `project_id` for output. Do keep the `GROUP BY project_id` clause unchanged since both queries group by the same column. Do change the ORDER BY clause to use the raw aggregate expression `count(*)` instead of referencing the alias `document_count`, since the alias is no longer available in the SELECT list. Do maintain the `ASC` ordering direction and `LIMIT 1` unchanged as they serve the same purpose in both queries. The amended query now correctly returns only the project_id with the smallest document count while matching RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"project with least number of documents\": select \"project_id\" from the \"Documents\" table instead of \"id\" from the \"projects\" table. 2) When counting documents per project: group by \"project_id\" to aggregate documents for each project. 3) When counting the number of documents: use count(*) to count all documents rather than non-null values in a specific column. 4) When ordering by document count: include the count in the SELECT list and order by that count in ascending order to find the project with the fewest documents.",
            "1) When answering about \"the project with least number of documents\": make sure the output order includes only \"project_id\" and excludes the count column. 2) When grouping by \"project_id\": organize results by \"project_id\" and compute the count of documents per group. 3) When ordering by document count to find the smallest: rank rows by the raw count(*) expression in ascending order and keep the first 1 row. 4) When counting documents: compute the number of rows using the count(*) function without an alias reference in the ORDER BY clause."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM projects ORDER BY COUNT(documents) ASC LIMIT 1;",
            "SELECT project_id, COUNT(*) AS document_count FROM Documents GROUP BY project_id ORDER BY document_count ASC LIMIT 1;",
            "SELECT project_id FROM Documents GROUP BY project_id ORDER BY count(*) ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT project_id FROM Documents GROUP BY project_id ORDER BY COUNT(*) ASC LIMIT 1"
        ]
    },
    "4678": {
        "db_id": "college_3",
        "question": "What is the least common faculty rank?",
        "ground_truth": "SELECT Rank FROM FACULTY GROUP BY Rank ORDER BY count(*) ASC LIMIT 1",
        "amends": [
            "Do select `Rank` instead of `rank, COUNT(*) as count` to return only the grouped column instead of both the group and an aggregate count. Do order by `count(*) ASC` instead of `count DESC` to sort by the ascending count of faculty members per rank rather than descending. Do remove the explicit column alias `count` since it's not needed when ordering by the aggregate function directly. The amended query now correctly identifies the faculty rank with the smallest count by using ascending order on the count aggregation."
        ],
        "rules": [
            "1) When answering about \"least common faculty rank\": make sure the output order: Rank. 2) When the question asks for \"least common\": rank rows by count of faculty members per rank in ascending order and keep the first 1 row. 3) When the question asks for \"count of faculty members per rank\": compute the number of rows using the canonical key for faculty members (Faculty.Rank) grouped by Rank. 4) When ordering by count: use the exact aggregate function count(*) in ascending order without column aliases."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT rank, COUNT(*) as count FROM faculty GROUP BY rank ORDER BY count DESC LIMIT 1;",
            "SELECT Rank FROM Faculty GROUP BY Rank ORDER BY COUNT(*) ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Rank FROM Faculty GROUP BY Rank ORDER BY COUNT(*) ASC LIMIT 1;"
        ]
    },
    "3173": {
        "db_id": "college_1",
        "question": "Find the number of professors in accounting department.",
        "ground_truth": "SELECT count(*) FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE DEPT_NAME  =  \"Accounting\"",
        "amends": [
            "Do add `JOIN department AS T2` instead of querying only the `professors` table. Do use `ON T1.dept_code = T2.dept_code` instead of directly filtering by department name. Do filter with `WHERE DEPT_NAME = \"Accounting\"` instead of `WHERE department = 'accounting'` to reference the correct column from the joined table. Do use proper table aliasing with `professor AS T1` instead of the original table name. The amended query now correctly joins tables to filter by department name rather than relying on a potentially incorrect department column in the professors table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"number of professors in accounting department\": make sure the output order:COUNT(*) 2) When the question mentions \"accounting department\": \"accounting department\" actually means \"DEPT_NAME = 'Accounting' in schema\" 3) When combining professor and department tables for shared entities: link rows where T1.dept_code = T2.dept_code; keep only matching pairs (inner match) 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for \"Accounting\" 5) When handling text literals: do not change case, spacing, or punctuation for 'Accounting'"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM professors WHERE department = 'accounting';",
            "SELECT COUNT(*) \nFROM PROFESSOR AS T1\nJOIN DEPARTMENT AS T2 ON T1.DEPT_CODE = T2.DEPT_CODE\nWHERE T2.DEPT_NAME = 'Accounting'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM PROFESSOR p\nJOIN DEPARTMENT d ON p.DEPT_CODE = d.DEPT_CODE\nWHERE d.DEPT_NAME = 'Accounting'"
        ]
    },
    "3814": {
        "db_id": "e_learning",
        "question": "Find the subject ID, subject name, and the corresponding number of available courses for each subject.",
        "ground_truth": "SELECT T1.subject_id ,  T2.subject_name ,  COUNT(*) FROM Courses AS T1 JOIN Subjects AS T2 ON T1.subject_id  =  T2.subject_id GROUP BY T1.subject_id",
        "amends": [
            "Do join `Courses AS T1` with `Subjects AS T2` on `T1.subject_id = T2.subject_id` instead of querying only the `subjects` table. Do count all rows with `COUNT(*)` instead of counting `course_id` specifically. Do group by only `T1.subject_id` instead of grouping by both `subject_id` and `subject_name`. Do include `T2.subject_name` in the SELECT list without an alias instead of using `subject_name` with an alias. The amended query now correctly counts courses per subject by joining the Courses and Subjects tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"subject ID, subject name, and number of available courses for each subject\": make sure the output order: subject_id, subject_name, available_courses. 2) When counting courses per subject: join table \"Courses\" as T1 with table \"Subjects\" as T2 where T1.subject_id = T2.subject_id and keep only matching pairs (inner match). 3) When counting available courses: count all rows using COUNT(*) instead of counting specific columns. 4) When grouping results: group by only T1.subject_id instead of grouping by both subject_id and subject_name. 5) When including subject name in output: use T2.subject_name without an alias."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT subject_id, subject_name, COUNT(course_id) as available_courses FROM subjects GROUP BY subject_id, subject_name",
            "SELECT T1.subject_id, T2.subject_name, COUNT(*) AS number_of_courses\nFROM Courses AS T1\nJOIN Subjects AS T2 ON T1.subject_id = T2.subject_id\nGROUP BY T1.subject_id"
        ],
        "rule_sql": [
            "SELECT T1.subject_id, T2.subject_name, COUNT(*) AS available_courses\nFROM Courses AS T1\nINNER JOIN Subjects AS T2 ON T1.subject_id = T2.subject_id\nGROUP BY T1.subject_id\nORDER BY T1.subject_id;"
        ]
    },
    "6990": {
        "db_id": "culture_company",
        "question": "Show all director names who have a movie in the year 1999 or 2000.",
        "ground_truth": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000",
        "amends": [
            "Do reference the `director` column instead of `director_name` and use the `movie` table instead of `movies`. Do maintain the same filter condition `YEAR = 1999 OR YEAR = 2000` without changes. The amended query now correctly references the schema elements and matches the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"director names\": use the exact column token \"director\" from the movie table. 2) When the question asks about movies from specific years 1999 or 2000: filter rows where YEAR equals 1999 OR YEAR equals 2000 using exact numeric literals. 3) When referencing the movie data: use the exact table name \"movie\" (not \"movies\") as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT director_name FROM movies WHERE year = 1999 OR year = 2000;",
            "SELECT DISTINCT Director FROM movie WHERE Year = 1999 OR Year = 2000"
        ],
        "rule_sql": [
            "SELECT director FROM movie WHERE Year = 1999 OR Year = 2000"
        ]
    },
    "1697": {
        "db_id": "epinions_1",
        "question": "Find the number of items that did not receive any review.",
        "ground_truth": "SELECT count(*) FROM item WHERE i_id NOT IN (SELECT i_id FROM review)",
        "amends": [
            "Do use table name `item` instead of `items` and change the WHERE condition to `i_id NOT IN (SELECT i_id FROM review)` instead of `review_id IS NULL`. Do add a subquery `(SELECT i_id FROM review)` to properly identify items without reviews instead of checking for NULL values in a potentially incorrect column. The amended query now correctly counts items that have no corresponding reviews by checking against the review table's i_id values rather than relying on a nullable review_id column that may not exist or function as intended."
        ],
        "rules": [
            "1) When the question asks for \"number of items that did not receive any review\": use the exact table name \"item\" instead of \"items\". 2) When identifying items without reviews: check for items where \"i_id\" is not in the set of \"i_id\" values from the \"review\" table, rather than checking for NULL values in a review_id column. 3) When counting items without reviews: use the canonical key \"i_id\" from the \"item\" table to count the number of items that have no corresponding entries in the \"review\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM items WHERE review_id IS NULL;",
            "SELECT COUNT(*) FROM item WHERE i_id NOT IN (SELECT i_id FROM review)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM item WHERE i_id NOT IN (SELECT DISTINCT i_id FROM review)"
        ]
    },
    "2014": {
        "db_id": "gas_company",
        "question": "What are the gas station ids, locations, and manager names for the gas stations ordered by opening year?",
        "ground_truth": "SELECT station_id ,  LOCATION ,  manager_name FROM gas_station ORDER BY open_year",
        "amends": [
            "Do reference `station_id` instead of `gas_station_id` and use `open_year` for ordering instead of `closing_year`. Do use table `gas_station` instead of `gas_stations` while keeping the same column selection of `LOCATION` and `manager_name`. The amended query now correctly references the appropriate table and ordering column to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for gas station ids: use the exact column token \"station_id\" instead of \"gas_station_id\". 2) When ordering gas stations by opening year: use the exact column token \"open_year\" instead of \"closing_year\". 3) When referencing the gas stations table: use the exact table name \"gas_station\" instead of \"gas_stations\". 4) When selecting output columns: maintain the exact column order and tokens \"station_id\", \"LOCATION\", and \"manager_name\" as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT gas_station_id, location, manager_name FROM gas_stations ORDER BY closing_year;",
            "SELECT Station_ID, Location, Manager_Name FROM gas_station ORDER BY Open_Year;"
        ],
        "rule_sql": [
            "SELECT station_id, Location, Manager_Name FROM gas_station ORDER BY Open_Year;"
        ]
    },
    "366": {
        "db_id": "flight_1",
        "question": "What is the id of every employee who has at least a salary of  100000?",
        "ground_truth": "SELECT eid FROM Employee WHERE salary  >  100000",
        "amends": [
            "Do select `eid` instead of `id` and use `>` comparison instead of `<=` for the salary filter. Do reference table `Employee` instead of `employees` while maintaining the same filter structure. The amended query now correctly selects employee IDs from the Employee table where salary exceeds 100000 instead of those earning 100000 or less."
        ],
        "rules": [
            "1) When the question asks for employee id: use the exact column token \"eid\" from the Employee table instead of \"id\". 2) When filtering for employees with at least a salary of 100000: use the comparison operator > (greater than) instead of <= (less than or equal to) with the literal value 100000. 3) When referencing the employee table: use the exact table name \"Employee\" instead of \"employees\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM employees WHERE salary <= 100000;",
            "SELECT eid FROM employee WHERE salary > 100000"
        ],
        "rule_sql": [
            "SELECT eid FROM Employee WHERE salary > 100000"
        ]
    },
    "5466": {
        "db_id": "voter_2",
        "question": "What are the distinct president votes on 08/30/2015?",
        "ground_truth": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  \"08/30/2015\"",
        "amends": [
            "Do reference `PRESIDENT_Vote` instead of `president` in the SELECT list. Do reference `VOTING_RECORD` instead of `votes` as the FROM source. Do reference `Registration_Date` instead of `date` in the WHERE filter. Do use double quotes `\"08/30/2015\"` instead of single quotes `'08/30/2015'` for the date literal. The amended query now correctly references the appropriate column and table names while maintaining the same filtering logic and distinct selection behavior."
        ],
        "rules": [
            "1) When the question asks for distinct president votes: use \"PRESIDENT_Vote\" as the exact column name to select distinct values from. 2) When the question refers to votes: use \"VOTING_RECORD\" as the exact table name instead of \"votes\". 3) When filtering by date '08/30/2015': use \"Registration_Date\" as the exact column name for the date filter. 4) When using date literals in this schema: use double quotes \"08/30/2015\" instead of single quotes for the exact date value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT president FROM votes WHERE date = '08/30/2015';",
            "SELECT DISTINCT President_Vote FROM Voting_record WHERE Registration_Date = \"08/30/2015\""
        ],
        "rule_sql": [
            "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date = \"08/30/2015\";"
        ]
    },
    "6832": {
        "db_id": "flight_4",
        "question": "What is the name, city, and country of the airport with the highest elevation?",
        "ground_truth": "SELECT name ,  city ,  country FROM airports ORDER BY elevation DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, city, country FROM airports ORDER BY elevation DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT name, city, country FROM airports ORDER BY elevation DESC LIMIT 1;"
        ]
    },
    "4463": {
        "db_id": "network_2",
        "question": "What are the names of all friends who are from New York?",
        "ground_truth": "SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.city  =  'new york city'",
        "amends": [
            "Do use `T2.name` from the `PersonFriend` table instead of `name` from a non-existent `friends` table. Do join `Person AS T1` with `PersonFriend AS T2` on `T1.name = T2.friend` instead of querying a single table. Do filter on `T1.city = 'new york city'` instead of `city = 'Los Angeles'` to find friends of people from New York City rather than friends from Los Angeles. The amended query now correctly identifies friends by joining the Person and PersonFriend tables with the proper relationship condition and location filter."
        ],
        "rules": [
            "1) When the question asks for \"names of all friends who are from New York\": use \"T2.name\" from the \"PersonFriend\" table as the output column. 2) When combining \"Person AS T1\" and \"PersonFriend AS T2\": link rows where \"T1.name = T2.friend\" exactly as shown in the amends and keep only matching pairs (inner match). 3) When filtering for friends of people from New York City: use the exact literal \"new york city\" (lowercase) in the condition \"T1.city = 'new york city'\" to find friends of people from that location. 4) When the question mentions \"friends\": this refers to the \"friend\" column in \"PersonFriend\" table that connects to \"name\" in \"Person\" table through the relationship \"T1.name = T2.friend\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM friends WHERE city = 'Los Angeles';",
            "SELECT T2.name \nFROM Person AS T1 \nJOIN PersonFriend AS T2 ON T1.name = T2.friend \nWHERE T1.city = 'new york city'"
        ],
        "rule_sql": [
            "SELECT T2.name \nFROM Person AS T1 \nINNER JOIN PersonFriend AS T2 ON T1.name = T2.friend \nWHERE T1.city = 'new york city'"
        ]
    },
    "5825": {
        "db_id": "workshop_paper",
        "question": "Find the author who achieved the highest score in a submission.",
        "ground_truth": "SELECT Author FROM submission ORDER BY Scores DESC LIMIT 1",
        "amends": [
            "Do reference the `Author` column instead of `author` and the `Scores` column instead of `score`. Do use `DESC` ordering instead of `ASC` ordering. Do query from the `submission` table instead of `submissions`. The amended query now correctly retrieves the author with the highest score from the submission table."
        ],
        "rules": [
            "1) When the question asks for \"author\": use the exact column token \"Author\" from the submission table. 2) When the question asks for \"score\": use the exact column token \"Scores\" from the submission table. 3) When the question asks about the \"highest score\": order by \"Scores\" in descending order (DESC) to get the maximum value. 4) When the question asks to find the author with the highest score: query from the \"submission\" table (not \"submissions\"). 5) When retrieving the top result: use LIMIT 1 to get only the first row after ordering by score descending."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT author FROM submissions ORDER BY score ASC LIMIT 1;",
            "SELECT Author FROM submission ORDER BY Scores DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Author FROM submission ORDER BY Scores DESC LIMIT 1;"
        ]
    },
    "2414": {
        "db_id": "candidate_poll",
        "question": "Find the name and gender of the candidate who got the highest support rate.",
        "ground_truth": "SELECT t1.name ,  t1.sex FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id ORDER BY t2.support_rate DESC LIMIT 1",
        "amends": [
            "Do select `t1.name` and `t1.sex` instead of `name` and `gender`. Do use `FROM people AS t1 JOIN candidate AS t2` instead of `FROM candidates`. Do add join condition `ON t1.people_id = t2.people_id` instead of omitting it. Do order by `t2.support_rate DESC` instead of `support_rate DESC`. The amended query now correctly joins the people and candidate tables to retrieve candidate information with proper column references and join conditions."
        ],
        "rules": [
            "1) When answering about \"name and gender of the candidate\": select \"t1.name\" and \"t1.sex\" as the output columns. 2) When combining people and candidate tables: link rows where \"t1.people_id\" equals \"t2.people_id\" and keep only matching pairs (inner join). 3) When the question mentions \"highest support rate\": rank rows by \"t2.support_rate\" in descending order and keep the first 1 row. 4) When the question asks for \"gender\": \"gender\" actually means \"t1.sex\" in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, gender FROM candidates ORDER BY support_rate DESC LIMIT 1;",
            "SELECT t1.Name, t1.Sex\nFROM people AS t1\nJOIN candidate AS t2 ON t1.People_ID = t2.People_ID\nORDER BY t2.Support_rate DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t1.Name, t1.Sex\nFROM people t1\nINNER JOIN candidate t2 ON t1.People_ID = t2.People_ID\nORDER BY t2.Support_rate DESC\nLIMIT 1"
        ]
    },
    "2464": {
        "db_id": "movie_1",
        "question": "What is the name of the most recent movie?",
        "ground_truth": "SELECT title FROM Movie WHERE YEAR  =  (SELECT max(YEAR) FROM Movie)",
        "amends": [
            "Do add a `WHERE` clause with a subquery filter `YEAR = (SELECT max(YEAR) FROM Movie)` instead of ordering by `release_date ASC` and limiting to one row. Do remove the `ORDER BY release_date ASC LIMIT 1` clause instead of keeping it, as the right query finds movies from the maximum year rather than the earliest release date. The amended query now correctly selects titles from the maximum year in the Movie table instead of the oldest release date, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"the most recent movie\": find movies where YEAR equals the maximum YEAR value from the Movie table. 2) When the question mentions \"most recent\": \"most recent\" actually means \"maximum YEAR value\" in the schema. 3) When filtering for maximum year: use a subquery to get the maximum YEAR value from the Movie table and match movies where YEAR equals that value. 4) When producing output: return only the title column from the matching movies."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM movies ORDER BY release_date ASC LIMIT 1;",
            "SELECT title FROM Movie WHERE year = (SELECT MAX(year) FROM Movie)"
        ],
        "rule_sql": [
            "SELECT title FROM Movie WHERE year = (SELECT MAX(year) FROM Movie)"
        ]
    },
    "6461": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "What are the ids of documents with letter 's' in the name with any expense budgets.",
        "ground_truth": "SELECT T1.document_id FROM Documents AS T1 JOIN Documents_with_expenses AS T2 ON T1.document_id  =  T2.document_id WHERE T1.document_name LIKE '%s%'",
        "amends": [
            "Do select `T1.document_id` instead of `id` and change the source table to `Documents AS T1` instead of `documents`. Do add a `JOIN` with `Documents_with_expenses AS T2` on `T1.document_id = T2.document_id` instead of omitting it. Do filter on `T1.document_name LIKE '%s%'` instead of `name LIKE '%s%'` and remove the `budget IS NOT NULL` condition instead of keeping it. The amended query now correctly joins the two tables and filters on the appropriate document name field."
        ],
        "rules": [
            "1) When selecting document identifiers: use \"T1.document_id\" instead of \"id\" and ensure the source table is referenced as \"Documents AS T1\". 2) When combining document information with expense data: join \"Documents AS T1\" with \"Documents_with_expenses AS T2\" where \"T1.document_id = T2.document_id\" using an inner match. 3) When filtering for documents containing the letter 's' in the name: use \"T1.document_name LIKE '%s%'\" instead of filtering on a \"name\" column. 4) When the question asks about documents \"with any expense budgets\": do not filter on a \"budget IS NOT NULL\" condition as this is handled by the join with \"Documents_with_expenses\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM documents WHERE name LIKE '%s%' AND budget IS NOT NULL;",
            "SELECT T1.Document_ID\nFROM Documents AS T1\nJOIN Documents_with_Expenses AS T2 ON T1.Document_ID = T2.Document_ID\nWHERE T1.Document_Name LIKE '%s%'"
        ],
        "rule_sql": [
            "SELECT T1.Document_ID \nFROM Documents AS T1 \nINNER JOIN Documents_with_Expenses AS T2 ON T1.Document_ID = T2.Document_ID \nWHERE T1.Document_Name LIKE '%s%'"
        ]
    },
    "254": {
        "db_id": "musical",
        "question": "Show names of actors in descending order of the year their musical is awarded.",
        "ground_truth": "SELECT T1.Name FROM actor AS T1 JOIN musical AS T2 ON T1.Musical_ID  =  T2.Musical_ID ORDER BY T2.Year DESC",
        "amends": [
            "Do select `T1.Name` from the `actor` table instead of `actor_name` from `actors`. Do join with `musical AS T2` on `T1.Musical_ID = T2.Musical_ID` instead of querying a single table without joins. Do order by `T2.Year DESC` instead of `award_year ASC`, changing both the column reference and sort direction. The amended query now correctly retrieves actor names joined with musical information and ordered by musical year descending, matching the intended behavior."
        ],
        "rules": [
            "1) When selecting actor names: use \"T1.Name\" from the \"actor\" table instead of \"actor_name\" from \"actors\". 2) When answering about actors and their musical awards: join \"actor\" as T1 with \"musical\" as T2 on \"T1.Musical_ID = T2.Musical_ID\" to combine actor and musical information. 3) When ordering by musical award year: use \"T2.Year\" in descending order instead of \"award_year\" in ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT actor_name FROM actors ORDER BY award_year ASC;",
            "SELECT T1.Name \nFROM actor AS T1 \nJOIN musical AS T2 ON T1.Musical_ID = T2.Musical_ID \nORDER BY T2.Year DESC"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM actor AS T1 JOIN musical AS T2 ON T1.Musical_ID = T2.Musical_ID ORDER BY T2.Year DESC;"
        ]
    },
    "5036": {
        "db_id": "soccer_2",
        "question": "How many states that have some college students playing in the mid position but not in the goalie position.",
        "ground_truth": "SELECT COUNT(*) FROM (SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid' EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie')",
        "amends": [
            "Do use a subquery with `EXCEPT` to find states with mid-position players but no goalie-position players instead of counting distinct states from a single table. Do join `college` and `tryout` tables on `cName` instead of querying only the `players` table. Do filter for `pPos = 'mid'` in the first part and `pPos = 'goalie'` in the second part instead of using `position` and `college_student` filters. Do remove the `DISTINCT` modifier and `college_student` condition instead of including them. Do use `COUNT(*)` on the subquery result instead of `COUNT(DISTINCT state)`. The amended query now correctly identifies states with mid-position players excluding those that also have goalie-position players, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about states with some college students playing in mid position but not goalie position: use a subquery with EXCEPT to find states that have mid-position players but exclude states that have goalie-position players instead of counting distinct states from a single table. 2) When combining college and tryout tables: join them on cName instead of querying only a players table. 3) When filtering for mid position players: use pPos = 'mid' instead of position = 'mid'. 4) When filtering for goalie position players: use pPos = 'goalie' instead of position = 'goalie'. 5) When counting the result: use COUNT(*) on the subquery result instead of COUNT(DISTINCT state). 6) When handling college student status: do not include a college_student condition as it's not needed for this query."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT state) \nFROM players \nWHERE position = 'mid' \nAND college_student = 1 \nAND position != 'goalie';",
            "SELECT COUNT(*) FROM (\n    SELECT c.state\n    FROM College c\n    JOIN Tryout t ON c.cName = t.cName\n    WHERE t.pPos = 'mid'\n    EXCEPT\n    SELECT c.state\n    FROM College c\n    JOIN Tryout t ON c.cName = t.cName\n    WHERE t.pPos = 'goalie'\n)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM (\n    SELECT DISTINCT c.state\n    FROM College c\n    JOIN Tryout t ON c.cName = t.cName\n    WHERE t.pPos = 'mid'\n    EXCEPT\n    SELECT DISTINCT c.state\n    FROM College c\n    JOIN Tryout t ON c.cName = t.cName\n    WHERE t.pPos = 'goalie'\n) AS states_with_mid_not_goalie;"
        ]
    },
    "594": {
        "db_id": "store_1",
        "question": "What is the full name of the employee who has the most customers?",
        "ground_truth": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `employees` with `customers` on `T1.id = T2.support_rep_id` instead of on `e.employee_id = c.customer_id`. Do group by `T1.id` instead of `e.employee_id`. Do order by `count(*)` instead of `COUNT(c.customer_id)`. Do use table aliases `T1` and `T2` instead of `e` and `c`. The amended query now correctly identifies employees by their ID and links them to customers through the support representative relationship rather than incorrectly matching employee IDs to customer IDs, ensuring the query returns the employee with the most customers assigned to them.",
            "Do select `T1.first_name` and `T1.last_name` as separate columns instead of concatenating them into `full_name`. Do remove the alias `AS full_name` instead of keeping it. Do use `JOIN` on `T1.id = T2.support_rep_id` instead of any other join condition. Do group by `T1.id` instead of any other grouping. Do order by `count(*) DESC` instead of any other ordering. Do limit to `1` result instead of any other limit. The amended query now correctly returns separate first and last name columns without concatenation while maintaining the same join logic, grouping, ordering, and limit behavior."
        ],
        "rules": [
            "1) When joining employees and customers tables: link rows where T1.id equals T2.support_rep_id exactly as specified, not using employee_id = customer_id. 2) When grouping employees: use T1.id as the grouping key to identify each employee uniquely. 3) When counting customers per employee: use count(*) to count all customer rows associated with each employee through the support_rep_id relationship. 4) When ordering results to find the employee with most customers: sort by the customer count in descending order and take only the top result. 5) When using table aliases: refer to employees as T1 and customers as T2 consistently throughout the query.",
            "1) When answering about \"the employee who has the most customers\": make sure the output order: T1.first_name, T1.last_name as separate columns without concatenation. 2) When combining employees T1 and customers T2: link rows where T1.id = T2.support_rep_id and keep only matching pairs (inner match). 3) When grouping by employee: organize results by T1.id and compute count of customers per employee. 4) When the question mentions \"most customers\": rank employees by count of customers in descending order and keep the first 1 row. 5) When counting customers: compute the number of rows using the canonical key T2.support_rep_id (implied by the join condition)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.first_name, e.last_name \nFROM employees e\nJOIN customers c ON e.employee_id = c.customer_id\nGROUP BY e.employee_id\nORDER BY COUNT(c.customer_id) DESC\nLIMIT 1;",
            "SELECT T1.first_name || ' ' || T1.last_name AS full_name\nFROM employees T1\nJOIN customers T2 ON T1.id = T2.support_rep_id\nGROUP BY T1.id\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT T1.first_name, T1.last_name\nFROM employees T1\nJOIN customers T2 ON T1.id = T2.support_rep_id\nGROUP BY T1.id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.last_name\nFROM employees T1\nJOIN customers T2 ON T1.id = T2.support_rep_id\nGROUP BY T1.id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "1306": {
        "db_id": "soccer_1",
        "question": "List the names and birthdays of the top five players in terms of potential.",
        "ground_truth": "SELECT DISTINCT T1.player_name ,  T1.birthday FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY potential DESC LIMIT 5",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do use `T1.player_name` and `T1.birthday` instead of `name` and `birthday`. Do add `Player_Attributes AS T2` table with `JOIN` instead of querying only the `players` table. Do specify `ON T1.player_api_id = T2.player_api_id` join condition instead of having no join. Do use table alias `Player AS T1` instead of just `players`. The amended query now correctly joins player data with attributes and returns distinct results ordered by potential."
        ],
        "rules": [
            "1) When answering about \"top five players in terms of potential\": make sure the output order: T1.player_name, T1.birthday 2) When the question mentions \"top five\": rank rows by T2.potential in descending direction and keep the first 5 rows 3) When combining Player as T1 and Player_Attributes as T2: link rows where T1.player_api_id = T2.player_api_id exactly as shown; keep only matching pairs (inner match) 4) When selecting player information: use T1.player_name and T1.birthday instead of generic name and birthday 5) When retrieving distinct results: ensure only unique combinations of T1.player_name and T1.birthday are returned"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, birthday FROM players ORDER BY potential DESC LIMIT 5;",
            "SELECT DISTINCT T1.player_name, T1.birthday\nFROM Player AS T1\nJOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id\nORDER BY T2.potential DESC\nLIMIT 5"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.player_name, T1.birthday\nFROM Player AS T1\nINNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id\nORDER BY T2.potential DESC\nLIMIT 5"
        ]
    },
    "1563": {
        "db_id": "customers_and_invoices",
        "question": "Show customer ids who don't have an account.",
        "ground_truth": "SELECT customer_id FROM Customers EXCEPT SELECT customer_id FROM Accounts",
        "amends": [
            "Do use `EXCEPT` set operation to find customers without accounts instead of filtering for `account_id IS NULL` which incorrectly assumes a direct relationship. Do reference the `Customers` table with proper capitalization instead of lowercase `customers`. Do remove the `WHERE` clause entirely instead of using an incorrect filter condition that doesn't properly identify customers without associated accounts. The amended query now correctly identifies customers who exist in the Customers table but not in the Accounts table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"customer ids who don't have an account\": use the exact table name \"Customers\" with proper capitalization instead of lowercase \"customers\". 2) When identifying customers without accounts: use a set operation (EXCEPT) to find customers who exist in the Customers table but not in the Accounts table, rather than filtering for account_id IS NULL. 3) When combining data from multiple tables for this question: do not use a WHERE clause with account_id IS NULL as this incorrectly assumes a direct relationship between tables that doesn't properly identify customers without associated accounts."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT customer_id FROM customers WHERE account_id IS NULL;",
            "SELECT customer_id FROM Customers\nEXCEPT\nSELECT customer_id FROM Accounts"
        ],
        "rule_sql": [
            "SELECT customer_id FROM Customers\nEXCEPT\nSELECT customer_id FROM Accounts;"
        ]
    },
    "751": {
        "db_id": "race_track",
        "question": "Show names and seatings, ordered by seating for all tracks opened after 2000.",
        "ground_truth": "SELECT name ,  seating FROM track WHERE year_opened  >  2000 ORDER BY seating",
        "amends": [
            "Do reference table `track` instead of `tracks` in the FROM clause. Do use column `year_opened` instead of `opened` in the WHERE filter condition. Do order by `seating` instead of `name` in the ORDER BY clause. The amended query now correctly filters tracks opened after 2000 using the proper column name and orders results by seating capacity instead of name."
        ],
        "rules": [
            "1) When the question asks about tracks: use the exact table name \"track\" instead of \"tracks\". 2) When filtering for tracks opened after 2000: use the exact column name \"year_opened\" instead of \"opened\" and compare with the literal value 2000. 3) When ordering results by seating: use the exact column name \"seating\" for ordering instead of \"name\". 4) When answering about track names and seatings: make sure the output order is \"name\" followed by \"seating\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, seating FROM tracks WHERE opened > 2000 ORDER BY name;",
            "SELECT Name, Seating FROM track WHERE Year_Opened > 2000 ORDER BY Seating;"
        ],
        "rule_sql": [
            "SELECT name, seating FROM track WHERE year_opened > 2000 ORDER BY seating;"
        ]
    },
    "6347": {
        "db_id": "e_government",
        "question": "What are the last names of individuals who have been contact individuals for an organization?",
        "ground_truth": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id",
        "amends": [
            "Do use `DISTINCT t1.individual_last_name` instead of `first_name` without distinct. Do add `JOIN organization_contact_individuals AS t2` instead of omitting this table. Do use join condition `ON t1.individual_id = t2.individual_id` instead of filter `WHERE contact_individual = 'yes'`. Do remove the WHERE clause filter entirely instead of keeping it. The amended query now correctly joins to the contact individuals table to identify organization contacts rather than relying on a potentially incorrect flag column."
        ],
        "rules": [
            "1) When answering about \"last names of individuals who have been contact individuals for an organization\": make sure the output order: t1.individual_last_name. 2) When the question asks for distinct last names: compute the number of unique values of the exact token t1.individual_last_name. 3) When combining individuals and organization_contact_individuals tables: link rows where t1.individual_id = t2.individual_id exactly as shown; keep only matching pairs (inner match). 4) When the question mentions \"contact individuals for an organization\": this means individuals must be found in the organization_contact_individuals table (t2) rather than using a contact_individual flag column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM individuals WHERE contact_individual = 'yes'",
            "SELECT DISTINCT t1.individual_last_name\nFROM Individuals AS t1\nJOIN Organization_Contact_Individuals AS t2 ON t1.individual_id = t2.individual_id"
        ],
        "rule_sql": [
            "SELECT DISTINCT t1.individual_last_name\nFROM Individuals t1\nINNER JOIN Organization_Contact_Individuals t2 ON t1.individual_id = t2.individual_id\nORDER BY t1.individual_last_name"
        ]
    },
    "3934": {
        "db_id": "hospital_1",
        "question": "Find the number of rooms for different block code?",
        "ground_truth": "SELECT count(*) ,  T1.blockcode FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockcode",
        "amends": [
            "Do `COUNT(*)` and `T1.blockcode` in the SELECT list instead of `block_code` and `COUNT(*)`. Do add `BLOCK AS T1` and `JOIN room AS T2` with join conditions `ON T1.blockfloor = T2.blockfloor AND T1.blockcode = T2.blockcode` instead of only `FROM rooms`. Do change the GROUP BY to `T1.blockcode` instead of `room_id`. The amended query now correctly joins the BLOCK and room tables on both blockfloor and blockcode before counting and grouping by blockcode, matching the intended behavior.",
            "Do place the `count(*)` column first instead of second in the SELECT list. Do use lowercase `blockcode` instead of uppercase `BlockCode` for the column alias. Do use lowercase `blockfloor` instead of uppercase `BlockFloor` in the JOIN condition. Do use lowercase `blockcode` instead of uppercase `BlockCode` in the JOIN condition. The amended query now correctly counts rooms per block while maintaining the same join logic and grouping behavior.",
            "Do place `T1.blockcode` after `count(*)` in the SELECT list instead of before it. Do use uppercase `BLOCK` for the table alias instead of lowercase `Block`. Do use lowercase `room` for the table name instead of uppercase `Room`. Do add extra spaces around the equals operators in the JOIN condition instead of minimal spacing. The amended query now correctly matches the RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [
            "1) When answering about \"number of rooms for different block code\": make sure the output order: T1.blockcode, COUNT(*) 2) When the question mentions \"block code\": \"block code\" actually means \"T1.blockcode in schema\" 3) When combining T1 and T2 for shared entities: link rows where T1.blockfloor = T2.blockfloor AND T1.blockcode = T2.blockcode; keep only matching pairs (inner match) 4) When the question asks for \"number of rooms\": compute the count of rows using the canonical key from the join 5) When the question says \"per different block code\"/\"by block code\": organize results by T1.blockcode and compute requested aggregates per group",
            "1) When answering about \"number of rooms for different block code\": make sure the output order: count(*) first, then blockcode. 2) When referring to column identifiers: use lowercase \"blockcode\" instead of uppercase \"BlockCode\" for both selection and grouping. 3) When referring to join condition columns: use lowercase \"blockfloor\" and lowercase \"blockcode\" instead of uppercase versions in the join condition. 4) When combining Block and Room tables for shared entities: link rows where Block.blockfloor = Room.blockfloor and Block.blockcode = Room.blockcode exactly as shown; keep only matching pairs (inner match). 5) When the question asks for \"number of rooms per block code\": compute the count of rows using the canonical counting method per blockcode group.",
            "1) When the question asks for \"number of rooms for different block code\": make sure the output order: count(*) first, then T1.blockcode. 2) When referring to the Block table: use uppercase \"BLOCK\" as the table alias instead of lowercase \"Block\". 3) When referring to the Room table: use lowercase \"room\" for the table name instead of uppercase \"Room\". 4) When writing equality conditions in JOIN clauses: add extra spaces around the equals operators instead of minimal spacing."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT block_code, COUNT(*) FROM rooms GROUP BY room_id;",
            "SELECT T1.BlockCode, COUNT(*) \nFROM Block AS T1 \nJOIN Room AS T2 ON T1.BlockFloor = T2.BlockFloor AND T1.BlockCode = T2.BlockCode \nGROUP BY T1.BlockCode",
            "SELECT T1.blockcode, COUNT(*) \nFROM Block AS T1 \nJOIN Room AS T2 ON T1.blockfloor = T2.blockfloor AND T1.blockcode = T2.blockcode \nGROUP BY T1.blockcode",
            "SELECT COUNT(*), T1.blockcode\nFROM BLOCK AS T1\nJOIN room AS T2 ON T1.blockfloor = T2.blockfloor AND T1.blockcode = T2.blockcode\nGROUP BY T1.blockcode"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS count, blockcode FROM room GROUP BY blockcode ORDER BY count(*), blockcode"
        ]
    },
    "4885": {
        "db_id": "school_player",
        "question": "What are the location and nickname of each school?",
        "ground_truth": "SELECT T1.Location ,  T2.Nickname FROM school AS T1 JOIN school_details AS T2 ON T1.School_ID  =  T2.School_ID",
        "amends": [
            "Do join `school AS T1` with `school_details AS T2` on `T1.School_ID = T2.School_ID` instead of querying only the `schools` table without any join. Do select `T1.Location` and `T2.Nickname` from the joined tables instead of selecting `location` and `nickname` from a single table. Do remove the `WHERE location IS NULL` filter instead of keeping it, as the right query retrieves all records from the joined relationship rather than filtering for null locations. The amended query now correctly joins the school and school_details tables to retrieve location and nickname data from their respective sources, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"location and nickname of each school\": make sure the output order: T1.Location, T2.Nickname\n2) When combining school and school_details tables: link rows where T1.School_ID = T2.School_ID exactly as shown and keep only matching pairs (inner match)\n3) When selecting data from multiple tables: use T1.Location from the school table and T2.Nickname from the school_details table instead of selecting from a single table\n4) When retrieving all records without filtering: do not apply any WHERE clause that would filter for null locations or other conditions"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location, nickname FROM schools WHERE location IS NULL;",
            "SELECT T1.Location, T2.Nickname FROM school AS T1 JOIN school_details AS T2 ON T1.School_ID = T2.School_ID"
        ],
        "rule_sql": [
            "SELECT T1.Location, T2.Nickname FROM school T1 INNER JOIN school_details T2 ON T1.School_ID = T2.School_ID"
        ]
    },
    "5708": {
        "db_id": "dorm_1",
        "question": "Find the name of the dorm with the largest capacity.",
        "ground_truth": "SELECT dorm_name FROM dorm ORDER BY student_capacity DESC LIMIT 1",
        "amends": [
            "Do select `dorm_name` instead of `name` and use table `dorm` instead of `dorms`. Do order by `student_capacity DESC` instead of `capacity ASC` to find the dorm with the highest capacity rather than the lowest. The amended query now correctly identifies the dorm with the maximum student capacity as intended."
        ],
        "rules": [
            "1) When the question asks for the name of a dorm: use the exact column token \"dorm_name\" from the Dorm table instead of \"name\". 2) When the question asks for the dorm with the largest capacity: order by \"student_capacity\" in descending order (DESC) instead of ascending order (ASC) to find the highest capacity. 3) When referring to the dorm table: use the exact table name \"dorm\" instead of \"dorms\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM dorms ORDER BY capacity ASC LIMIT 1;",
            "SELECT dorm_name FROM Dorm ORDER BY student_capacity DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT dorm_name FROM dorm ORDER BY student_capacity DESC LIMIT 1;"
        ]
    },
    "775": {
        "db_id": "race_track",
        "question": "Show all track names that have had no races.",
        "ground_truth": "SELECT name FROM track WHERE track_id NOT IN (SELECT track_id FROM race)",
        "amends": [
            "Do query from `track` table instead of `tracks` table. Do use `track_id NOT IN` subquery condition instead of `race_id IS NULL` filter. Do remove the incorrect `race_id` column reference and instead use a correlated subquery that checks for existence in the `race` table. The amended query now correctly identifies tracks that have never been used in any race by checking for non-existence in the race table rather than relying on a potentially missing or null foreign key column, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When querying about tracks: use the exact table name \"track\" instead of \"tracks\". 2) When identifying tracks with no races: use a subquery condition with \"track_id NOT IN\" instead of checking for NULL values in race_id. 3) When checking for non-existence of races: use a correlated subquery that verifies absence from the \"race\" table rather than relying on foreign key columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM tracks WHERE race_id IS NULL;",
            "SELECT Name FROM track WHERE Track_ID NOT IN (SELECT Track_ID FROM race)"
        ],
        "rule_sql": [
            "SELECT Name FROM track WHERE Track_ID NOT IN (SELECT Track_ID FROM race)"
        ]
    },
    "3429": {
        "db_id": "hr_1",
        "question": "Find job id and date of hire for those employees who was hired between November 5th, 2007 and July 5th, 2009.",
        "ground_truth": "SELECT job_id ,  hire_date FROM employees WHERE hire_date BETWEEN '2007-11-05' AND '2009-07-05'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT job_id, hire_date FROM employees WHERE hire_date BETWEEN '2009-07-05' AND '2007-11-05';"
        ],
        "rule_sql": [
            "SELECT JOB_ID, HIRE_DATE FROM employees WHERE HIRE_DATE BETWEEN '2007-11-05' AND '2009-07-05';"
        ]
    },
    "5051": {
        "db_id": "device",
        "question": "Count the number of devices.",
        "ground_truth": "SELECT count(*) FROM device",
        "amends": [
            "Do query the `device` table instead of the `users` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the device table instead of the users table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks to count devices: query the \"device\" table instead of the \"users\" table. 2) When counting records: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" for consistency."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users;",
            "SELECT count(*) FROM device;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM device;"
        ]
    },
    "1842": {
        "db_id": "browser_web",
        "question": "Find the number of web accelerators used for each Operating system.",
        "ground_truth": "SELECT Operating_system ,  count(*) FROM web_client_accelerator GROUP BY Operating_system",
        "amends": [
            "Do reference the `web_client_accelerator` table instead of the `devices` table. Do use `count(*)` instead of `COUNT(web_accelerator)` to count all rows rather than counting non-null values in a specific column. Do place `Operating_system` first in the SELECT list instead of second, and maintain consistent capitalization with `Operating_system` instead of `operating_system`. The amended query now correctly counts all records in the web_client_accelerator table grouped by operating system, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"number of web accelerators used for each Operating system\": make sure the output order: Operating_system first, then count. 2) When the question mentions \"web accelerators\": \"web accelerators\" actually means \"all records in the Web_client_accelerator table\". 3) When counting web accelerators: count all rows using count(*) rather than counting non-null values in a specific column. 4) When the question says \"per Operating system\"/\"by Operating system\": organize results by Operating_system and compute count per group. 5) When handling identifier capitalization: use exact token \"Operating_system\" with consistent capitalization as shown in the schema, not \"operating_system\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(web_accelerator), operating_system FROM devices GROUP BY operating_system;",
            "SELECT Operating_system, COUNT(*) FROM Web_client_accelerator GROUP BY Operating_system"
        ],
        "rule_sql": [
            "SELECT Operating_system, COUNT(*) FROM Web_client_accelerator GROUP BY Operating_system ORDER BY Operating_system, COUNT(*)"
        ]
    },
    "1309": {
        "db_id": "performance_attendance",
        "question": "What are the dates and locations of performances?",
        "ground_truth": "SELECT Date ,  LOCATION FROM performance",
        "amends": [
            "Do use `Date` instead of `performance_date` for the column name and `LOCATION` instead of `location` for proper case sensitivity. Do reference the table as `performance` instead of `performances` for the correct table name. Do remove the `WHERE performance_id > 0` filter instead of keeping it, as the right query does not include any filtering condition. The amended query now correctly selects from the performance table without unnecessary filtering."
        ],
        "rules": [
            "1) When the question asks for dates of performances: use the exact column name \"Date\" from the performance table. 2) When the question asks for locations of performances: use the exact column name \"LOCATION\" from the performance table. 3) When referencing the performance table: use the exact table name \"performance\" (not \"performances\"). 4) When selecting all performance records: do not apply any filtering condition unless explicitly specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT performance_date, location FROM performances WHERE performance_id > 0",
            "SELECT Date, Location FROM performance;"
        ],
        "rule_sql": [
            "SELECT Date, Location FROM performance;"
        ]
    },
    "5552": {
        "db_id": "products_gen_characteristics",
        "question": "What are the name and typical buying and selling prices of the products that have color described as \"yellow\"?",
        "ground_truth": "SELECT t1.product_name ,  t1.typical_buying_price ,  t1.typical_selling_price FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code WHERE t2.color_description  =  \"yellow\"",
        "amends": [
            "Do reference `t1.product_name`, `t1.typical_buying_price`, and `t1.typical_selling_price` instead of `name`, `buying_price`, and `selling_price`. Do add `JOIN ref_colors AS t2` instead of omitting it. Do use `ON t1.color_code = t2.color_code` instead of no join condition. Do filter on `t2.color_description = \"yellow\"` instead of `color = 'red'`. The amended query now correctly joins to a color reference table and filters by color description rather than directly on color values, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for product name and typical buying/selling prices: use exact column tokens \"t1.product_name\", \"t1.typical_buying_price\", and \"t1.typical_selling_price\" in the output. 2) When the question mentions products with color \"yellow\": join table \"ref_colors\" as \"t2\" using \"ON t1.color_code = t2.color_code\" to link products to their color descriptions. 3) When filtering for yellow products: use exact literal filter \"t2.color_description = \\\"yellow\\\"\" instead of direct color code filtering. 4) When combining products and color reference tables: perform an inner match where \"t1.color_code = t2.color_code\" to keep only products with valid color references."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, buying_price, selling_price FROM products WHERE color = 'red';",
            "SELECT t1.product_name, t1.typical_buying_price, t1.typical_selling_price\nFROM Products AS t1\nJOIN Ref_Colors AS t2 ON t1.color_code = t2.color_code\nWHERE t2.color_description = \"yellow\""
        ],
        "rule_sql": [
            "SELECT t1.product_name, t1.typical_buying_price, t1.typical_selling_price\nFROM Products t1\nINNER JOIN Ref_Colors t2 ON t1.color_code = t2.color_code\nWHERE t2.color_description = \"yellow\""
        ]
    },
    "6021": {
        "db_id": "game_1",
        "question": "Show student ids who don't have any sports.",
        "ground_truth": "SELECT StuID FROM Student EXCEPT SELECT StuID FROM Sportsinfo",
        "amends": [
            "Do select `StuID` from `Student` instead of `student_id` from `students`. Do use `EXCEPT` to exclude students with sports information instead of filtering for `IS NULL` on a `sports` column. Do reference the `Sportsinfo` table instead of omitting it. The amended query now correctly identifies students without sports records by set exclusion rather than null checking, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"student ids who don't have any sports\": select \"StuID\" from \"Student\" table. 2) When identifying students without sports records: use set exclusion (EXCEPT) to exclude students who appear in the \"SportsInfo\" table's \"StuID\" column rather than checking for NULL values. 3) When combining student and sports information: reference both \"Student\" and \"SportsInfo\" tables, where \"SportsInfo.StuID\" is a foreign key referencing \"Student.StuID\". 4) When handling student identifiers: use exact token \"StuID\" (case-sensitive) from the \"Student\" table, not \"student_id\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id FROM students WHERE sports IS NULL;",
            "SELECT StuID FROM Student\nEXCEPT\nSELECT StuID FROM SportsInfo"
        ],
        "rule_sql": [
            "SELECT StuID FROM Student\nEXCEPT\nSELECT StuID FROM SportsInfo"
        ]
    },
    "6110": {
        "db_id": "customers_and_addresses",
        "question": "Give me the name of the customer who ordered the most items in total.",
        "ground_truth": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id GROUP BY t1.customer_name ORDER BY sum(t3.order_quantity) DESC LIMIT 1",
        "amends": [
            "Do add `JOIN customer_orders AS t2 ON t1.customer_id = t2.customer_id` and `JOIN order_items AS t3 ON t2.order_id = t3.order_id` instead of querying only the `customers` table. Do add `GROUP BY t1.customer_name` instead of selecting individual rows. Do change the `ORDER BY` to `sum(t3.order_quantity) DESC` instead of `customer_id DESC` to order by total order quantity rather than customer ID. Do keep `LIMIT 1` to return the top result. The amended query now correctly identifies the customer with the highest total order quantity across all their orders."
        ],
        "rules": [
            "1) When answering about \"customer who ordered the most items\": make sure the output order: customer_name. 2) When combining tables for customer order information: link rows where t1.customer_id = t2.customer_id and t2.order_id = t3.order_id; keep only matching pairs (inner match). 3) When the question asks for \"most items in total\": organize results by t1.customer_name and compute sum(t3.order_quantity) per group. 4) When the question mentions \"most\" or \"highest\": rank rows by sum(t3.order_quantity) in descending order and keep the first 1 row. 5) When producing output: do not reorder columns beyond what the question requires - only return customer_name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT customer_name FROM customers ORDER BY customer_id DESC LIMIT 1;",
            "SELECT c.customer_name\nFROM Customers c\nJOIN Customer_Orders co ON c.customer_id = co.customer_id\nJOIN Order_Items oi ON co.order_id = oi.order_id\nGROUP BY c.customer_name\nORDER BY SUM(oi.order_quantity) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT c.customer_name\nFROM Customers c\nINNER JOIN Customer_Orders co ON c.customer_id = co.customer_id\nINNER JOIN Order_Items oi ON co.order_id = oi.order_id\nGROUP BY c.customer_name\nORDER BY SUM(CAST(oi.order_quantity AS INTEGER)) DESC\nLIMIT 1;"
        ]
    },
    "1588": {
        "db_id": "customers_and_invoices",
        "question": "What are total transaction amounts for each transaction type?",
        "ground_truth": "SELECT transaction_type ,  sum(transaction_amount) FROM Financial_transactions GROUP BY transaction_type",
        "amends": [
            "Do reference the correct table `Financial_transactions` instead of `transactions`. Do use the correct column `transaction_amount` for aggregation instead of `amount`. Do group by `transaction_type` instead of `transaction_id` to properly categorize the sum amounts by type rather than by individual transaction identifiers. The amended query now correctly aggregates transaction amounts by their type categories."
        ],
        "rules": [
            "1) When answering about \"total transaction amounts for each transaction type\": make sure the output order: transaction_type, SUM(transaction_amount). 2) When the question mentions \"transaction amounts\": \"amounts\" actually means \"transaction_amount\" in schema. 3) When the question asks for \"total transaction amounts per transaction type\": organize results by transaction_type and compute SUM(transaction_amount) per group. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table name \"Financial_Transactions\". 5) When the question asks for aggregation by transaction type: group by transaction_type instead of transaction_id to categorize by type categories rather than individual identifiers."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT transaction_type, SUM(amount) FROM transactions GROUP BY transaction_id;",
            "SELECT transaction_type, SUM(transaction_amount) AS total_transaction_amount FROM Financial_Transactions GROUP BY transaction_type;"
        ],
        "rule_sql": [
            "SELECT transaction_type, SUM(transaction_amount) AS total_transaction_amount FROM Financial_Transactions GROUP BY transaction_type ORDER BY transaction_type;"
        ]
    },
    "2486": {
        "db_id": "movie_1",
        "question": "For all directors who directed more than one movie, return the titles of all movies directed by them, along with the director name. Sort by director name, then movie title.",
        "ground_truth": "SELECT T1.title ,  T1.director FROM Movie AS T1 JOIN Movie AS T2 ON T1.director  =  T2.director WHERE T1.title != T2.title ORDER BY T1.director ,  T1.title",
        "amends": [
            "Do select `title` and `director` columns instead of `title` and `name`. Do join `Movie` table as `T1` with `Movie` table as `T2` on `T1.director = T2.director` instead of joining `movies` with `directors` on `m.director_id = d.id`. Do filter with `T1.title != T2.title` instead of using a subquery to count movies per director. Do order by `T1.director` and `T1.title` instead of `d.name` and `m.title`. The amended query now correctly identifies movies by the same director without relying on a separate directors table or subquery, matching the RIGHT_SQL's behavior.",
            "Do remove the `GROUP BY T1.director, T1.title` clause instead of keeping it, and do remove the `HAVING COUNT(DISTINCT T2.title) > 1` condition instead of including it, as the correct logic only requires finding movies by the same director with different titles without needing aggregation. The amended query now matches RIGHT_SQL's behavior by returning all movie-director pairs where the same director has different movie titles."
        ],
        "rules": [
            "1) When the question asks for director names and movie titles: use \"director\" and \"title\" columns from the Movie table instead of separate \"name\" and \"title\" columns from different tables. 2) When identifying directors who directed more than one movie: join the Movie table with itself on T1.director = T2.director and filter where T1.title != T2.title instead of using a subquery count. 3) When ordering results: sort by T1.director first, then by T1.title instead of d.name and m.title from separate tables. 4) When combining tables for this query: use the Movie table aliased as T1 and T2 with an inner join on director equality, not joining with a separate directors table.",
            "1) When answering about directors who directed more than one movie: find all movie-director pairs where the same director has different movie titles without using aggregation. 2) When combining Movie tables for the same director: link rows where T1.director = T2.director and T1.title != T2.title to identify directors with multiple movies. 3) When the question asks to return movie titles and director names: output T1.title and T1.director in the result. 4) When the question requires sorting: order results by T1.director first, then by T1.title."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.title, d.name \nFROM movies m \nJOIN directors d ON m.director_id = d.id \nWHERE (SELECT COUNT(*) FROM movies m2 WHERE m2.director_id = d.id) > 1 \nORDER BY d.name, m.title;",
            "SELECT T1.title, T1.director\nFROM Movie T1\nJOIN Movie T2 ON T1.director = T2.director\nWHERE T1.title != T2.title\nGROUP BY T1.director, T1.title\nHAVING COUNT(DISTINCT T2.title) > 1\nORDER BY T1.director, T1.title;",
            "SELECT T1.title, T1.director\nFROM Movie T1\nJOIN Movie T2 ON T1.director = T2.director\nWHERE T1.title != T2.title\nORDER BY T1.director, T1.title;"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.title, T1.director\nFROM Movie T1\nINNER JOIN Movie T2 ON T1.director = T2.director AND T1.title != T2.title\nORDER BY T1.director, T1.title;"
        ]
    },
    "5911": {
        "db_id": "cre_Theme_park",
        "question": "What are the names and opening hours of the tourist attractions that can be accessed by bus or walk?",
        "ground_truth": "SELECT Name ,  Opening_Hours FROM TOURIST_ATTRACTIONS WHERE How_to_Get_There  =  \"bus\" OR How_to_Get_There  =  \"walk\"",
        "amends": [
            "Do reference column `Name` instead of `name` and `Opening_Hours` instead of `opening_hours` in the SELECT list. Do reference table `TOURIST_ATTRACTIONS` instead of `tourist_attractions` in the FROM clause. Do filter on column `How_to_Get_There` with values \"bus\" and \"walk\" instead of filtering on `access_type` with values 'bus' and 'walk' in the WHERE clause. The amended query now correctly matches the intended logic by using the appropriate column names and table reference from the schema."
        ],
        "rules": [
            "1) When selecting attraction names and opening hours: use column \"Name\" and \"Opening_Hours\" from table \"TOURIST_ATTRACTIONS\" 2) When filtering attractions by transportation access: check column \"How_to_Get_There\" for exact values \"bus\" or \"walk\" 3) When the question asks about tourist attractions: use table \"TOURIST_ATTRACTIONS\" as the primary data source"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, opening_hours FROM tourist_attractions WHERE access_type = 'bus' OR access_type = 'walk';",
            "SELECT Name, Opening_Hours FROM Tourist_Attractions WHERE How_to_Get_There IN ('bus', 'walk');"
        ],
        "rule_sql": [
            "SELECT Name, Opening_Hours FROM Tourist_Attractions WHERE How_to_Get_There = 'bus' OR How_to_Get_There = 'walk';"
        ]
    },
    "175": {
        "db_id": "bike_1",
        "question": "What are the date, mean temperature and mean humidity for the top 3 days with the largest max gust speeds?",
        "ground_truth": "SELECT date ,  mean_temperature_f ,  mean_humidity FROM weather ORDER BY max_gust_speed_mph DESC LIMIT 3",
        "amends": [
            "Do select columns `date`, `mean_temperature_f`, and `mean_humidity` instead of calculating aggregates `AVG(temperature)` and `AVG(humidity)` with aliases. Do source from table `weather` instead of `weather_data`. Do order by column `max_gust_speed_mph` instead of `max_gust_speed`. The amended query now correctly retrieves pre-calculated metrics from the appropriate table while maintaining the same sorting and limiting behavior."
        ],
        "rules": [
            "1) When answering about \"top 3 days with the largest max gust speeds\": rank rows by max_gust_speed_mph in descending order and keep the first 3 rows. 2) When the question mentions \"mean temperature\": \"mean temperature\" actually means \"mean_temperature_f in schema\". 3) When the question mentions \"mean humidity\": \"mean humidity\" actually means \"mean_humidity in schema\". 4) When selecting output columns: make sure the output order is date, mean_temperature_f, mean_humidity. 5) When sourcing data: use table weather instead of weather_data. 6) When ordering by gust speed: use column max_gust_speed_mph instead of max_gust_speed."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT date, AVG(temperature) as mean_temperature, AVG(humidity) as mean_humidity \nFROM weather_data \nORDER BY max_gust_speed DESC \nLIMIT 3;",
            "SELECT date, mean_temperature_f, mean_humidity FROM weather ORDER BY max_gust_speed_mph DESC LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT date, mean_temperature_f, mean_humidity FROM weather ORDER BY max_gust_speed_mph DESC LIMIT 3"
        ]
    },
    "2087": {
        "db_id": "pilot_record",
        "question": "Show the names of pilots from team \"Bradley\" or \"Fordham\".",
        "ground_truth": "SELECT Pilot_name FROM pilot WHERE Team  =  \"Bradley\" OR Team  =  \"Fordham\"",
        "amends": [
            "Do reference the `Pilot_name` column instead of `name`, and use the `pilot` table instead of `pilots`. Do use `OR` logic between team conditions instead of `AND`, which would return no results since a team cannot be both 'Bradley' and 'Fordham' simultaneously. Do use double quotes for string literals instead of single quotes to match the right SQL's formatting. The amended query now correctly returns pilots from either the Bradley or Fordham teams instead of incorrectly requiring both conditions to be true."
        ],
        "rules": [
            "1) When the question asks for pilot names: use the exact column \"Pilot_name\" from table \"pilot\" instead of \"name\" from \"pilots\". 2) When the question specifies teams \"Bradley\" or \"Fordham\": use OR logic between team conditions instead of AND logic. 3) When using string literals for team names: use double quotes as in \"Bradley\" and \"Fordham\" instead of single quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM pilots WHERE team = 'Bradley' AND team = 'Fordham';",
            "SELECT \"Pilot_name\" FROM \"pilot\" WHERE \"Team\" = \"Bradley\" OR \"Team\" = \"Fordham\""
        ],
        "rule_sql": [
            "SELECT Pilot_name FROM pilot WHERE Team = \"Bradley\" OR Team = \"Fordham\""
        ]
    },
    "427": {
        "db_id": "flight_1",
        "question": "Show names for all employees who have certificates on both Boeing 737-800 and Airbus A340-300.",
        "ground_truth": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  \"Boeing 737-800\" INTERSECT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  \"Airbus A340-300\"",
        "amends": [
            "Do use `INTERSECT` to find employees certified on both aircraft types instead of joining the same `certificates` table twice with different filters. Do join through an `Aircraft` table using `aid` instead of filtering directly on `aircraft_type` values. Do reference `Employee.eid` and `Certificate.eid` for the join condition instead of `employees.id` and `certificates.employee_id`. Do use table aliases `T1`, `T2`, and `T3` consistently instead of `e`, `c1`, and `c2`. Do filter on `T3.name` values with double quotes instead of single quotes for the aircraft names. Do structure the query as two separate SELECT statements combined with INTERSECT instead of a single query with multiple joins to the same table. The amended query now correctly identifies employees certified on both specified aircraft types using proper table relationships and set operations."
        ],
        "rules": [
            "1) When answering about employees with certificates on multiple aircraft types: use INTERSECT operation to find employees who appear in both sets instead of joining the same table multiple times. 2) When combining Employee and Certificate tables: link rows where T1.eid = T2.eid using the exact key equality shown in the amends. 3) When filtering for specific aircraft types: join through the Aircraft table using T2.aid = T3.aid instead of filtering directly on aircraft_type values. 4) When referencing aircraft names: use double quotes for exact string literals as \"Boeing 737-800\" and \"Airbus A340-300\" with the exact case and spacing shown. 5) When structuring the query: create two separate SELECT statements for each aircraft type and combine them with INTERSECT instead of a single query with multiple joins to the same table. 6) When using table aliases: consistently use T1 for Employee table, T2 for Certificate table, and T3 for Aircraft table as specified in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.name \nFROM employees e\nJOIN certificates c1 ON e.id = c1.employee_id\nJOIN certificates c2 ON e.id = c2.employee_id\nWHERE c1.aircraft_type = 'Boeing 737-800' \nAND c2.aircraft_type = 'Airbus A340-300';",
            "SELECT T1.name\nFROM employee T1\nJOIN certificate T2 ON T1.eid = T2.eid\nJOIN aircraft T3 ON T2.aid = T3.aid\nWHERE T3.name = \"Boeing 737-800\"\nINTERSECT\nSELECT T1.name\nFROM employee T1\nJOIN certificate T2 ON T1.eid = T2.eid\nJOIN aircraft T3 ON T2.aid = T3.aid\nWHERE T3.name = \"Airbus A340-300\""
        ],
        "rule_sql": [
            "SELECT T1.name\nFROM employee T1\nJOIN certificate T2 ON T1.eid = T2.eid\nJOIN aircraft T3 ON T2.aid = T3.aid\nWHERE T3.name = \"Boeing 737-800\"\nINTERSECT\nSELECT T1.name\nFROM employee T1\nJOIN certificate T2 ON T1.eid = T2.eid\nJOIN aircraft T3 ON T2.aid = T3.aid\nWHERE T3.name = \"Airbus A340-300\""
        ]
    },
    "1063": {
        "db_id": "match_season",
        "question": "What are the different positions of players from UCLA or Duke colleges?",
        "ground_truth": "SELECT DISTINCT POSITION FROM match_season WHERE College  =  \"UCLA\" OR College  =  \"Duke\"",
        "amends": [
            "Do reference table `match_season` instead of `players` and use column `POSITION` instead of `position`. Do use column `College` instead of `college` and maintain the same filter logic with `College = \"UCLA\" OR College = \"Duke\"` instead of `college = 'UCLA' OR college = 'Duke'`. The amended query now correctly references the intended table and columns while preserving the DISTINCT selection of positions from the specified colleges, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"different positions of players from UCLA or Duke colleges\": make sure the output order: POSITION. 2) When the question mentions \"positions\": \"positions\" actually means \"POSITION in schema\". 3) When the question mentions \"UCLA or Duke colleges\": use exact literals \"UCLA\" and \"Duke\" for College column filtering. 4) When the question asks for \"different positions\": compute the distinct values of POSITION column. 5) When selecting from the database: use table match_season instead of players and column College instead of college."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT position FROM players WHERE college = 'UCLA' OR college = 'Duke';",
            "SELECT DISTINCT \"Position\" FROM \"match_season\" WHERE \"College\" = 'UCLA' OR \"College\" = 'Duke';"
        ],
        "rule_sql": [
            "SELECT DISTINCT \"Position\" FROM \"match_season\" WHERE \"College\" = 'UCLA' OR \"College\" = 'Duke' ORDER BY \"Position\";"
        ]
    },
    "2551": {
        "db_id": "county_public_safety",
        "question": "What are the names of cities, as well as the names of the counties they correspond to?",
        "ground_truth": "SELECT T1.Name ,  T2.Name FROM city AS T1 JOIN county_public_safety AS T2 ON T1.County_ID  =  T2.County_ID",
        "amends": [
            "Do select `T1.Name` and `T2.Name` instead of `city_name` and `county_name`. Do join `city AS T1` with `county_public_safety AS T2` instead of `cities` with `counties`. Do use join condition `T1.County_ID = T2.County_ID` instead of `cities.county_id = counties.id`. The amended query now correctly joins the city table with the county_public_safety table using County_ID as the join key and selects the appropriate name columns from both tables."
        ],
        "rules": [
            "1) When answering about city and county names: select T1.Name and T2.Name as output columns. 2) When combining city and county_public_safety tables: link rows where T1.County_ID equals T2.County_ID exactly and keep only matching pairs (inner match). 3) When referring to table roles: use T1 for city table and T2 for county_public_safety table as specified in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city_name, county_name FROM cities JOIN counties ON cities.county_id = counties.id;",
            "SELECT T1.Name, T2.Name FROM city AS T1 JOIN county_public_safety AS T2 ON T1.County_ID = T2.County_ID"
        ],
        "rule_sql": [
            "SELECT T1.Name, T2.Name FROM city T1 INNER JOIN county_public_safety T2 ON T1.County_ID = T2.County_ID"
        ]
    },
    "5586": {
        "db_id": "products_gen_characteristics",
        "question": "Find the unit of measurement and product category code of product named \"chervil\".",
        "ground_truth": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  \"chervil\"",
        "amends": [
            "Do join `ref_product_categories AS t2` instead of querying only the `products` table. Do reference columns `t2.unit_of_measure` and `t2.product_category_code` instead of `unit_of_measurement` and `product_category`. Do use the join condition `ON t1.product_category_code = t2.product_category_code` instead of omitting the table relationship. Do qualify the filter as `t1.product_name = \"chervil\"` instead of the unqualified `product_name = 'chervil'`. The amended query now correctly retrieves category information from the reference table instead of attempting to get it directly from the products table."
        ],
        "rules": [
            "1) When answering about \"unit of measurement and product category code of product named 'chervil'\": make sure the output order: t2.unit_of_measure, t2.product_category_code\n2) When the question mentions \"product named 'chervil'\": use the exact literal \"chervil\" with double quotes and filter on t1.product_name = \"chervil\"\n3) When combining products table (T1) and ref_product_categories table (T2): link rows where t1.product_category_code = t2.product_category_code and keep only matching pairs (inner match)\n4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for the literal \"chervil\"\n5) When handling text literals: do not change case, spacing, or punctuation for the literal \"chervil\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT unit_of_measurement, product_category FROM products WHERE product_name = 'chervil';",
            "SELECT t2.unit_of_measure, t2.product_category_code \nFROM Products AS t1 \nJOIN Ref_Product_Categories AS t2 ON t1.product_category_code = t2.product_category_code \nWHERE t1.product_name = 'chervil'"
        ],
        "rule_sql": [
            "SELECT t2.unit_of_measure, t2.product_category_code\nFROM Products t1\nINNER JOIN Ref_Product_Categories t2 ON t1.product_category_code = t2.product_category_code\nWHERE t1.product_name = \"chervil\""
        ]
    },
    "3822": {
        "db_id": "e_learning",
        "question": "What are the names of the courses that have exactly 1 student enrollment?",
        "ground_truth": "SELECT T1.course_name FROM Courses AS T1 JOIN Student_Course_Enrolment AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name HAVING COUNT(*)  =  1",
        "amends": [
            "Do use `T1.course_name` with table alias instead of bare `course_name`. Do add `JOIN Student_Course_Enrolment AS T2 ON T1.course_id = T2.course_id` instead of querying only the courses table. Do remove the `WHERE` clause filter on `student_count = 1` instead of keeping it. Do add `GROUP BY T1.course_name` to aggregate by course instead of omitting grouping. Do move the count condition to `HAVING COUNT(*) = 1` instead of using a direct column filter in WHERE. The amended query now correctly identifies courses with exactly one student enrollment by joining the enrollment table and counting actual enrollments rather than relying on a potentially incorrect student_count column."
        ],
        "rules": [
            "1) When answering about course names with exactly 1 student enrollment: use table alias T1 for the Courses table and T2 for the Student_Course_Enrolment table. 2) When combining Courses and Student_Course_Enrolment tables: link rows where T1.course_id = T2.course_id using an inner join. 3) When counting student enrollments per course: group by T1.course_name and count using COUNT(*). 4) When filtering for exactly 1 enrollment: apply the condition HAVING COUNT(*) = 1 after grouping. 5) When selecting output: return T1.course_name as the result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_name FROM courses WHERE student_count = 1;",
            "SELECT T1.course_name\nFROM Courses AS T1\nJOIN Student_Course_Enrolment AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_name\nHAVING COUNT(*) = 1"
        ],
        "rule_sql": [
            "SELECT T1.course_name\nFROM Courses T1\nINNER JOIN Student_Course_Enrolment T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_name\nHAVING COUNT(*) = 1"
        ]
    },
    "3519": {
        "db_id": "hr_1",
        "question": "display those employees who contain a letter z to their first name and also display their last name, city.",
        "ground_truth": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'",
        "amends": [
            "Do add `T3.city` instead of `city` and specify table aliases for all columns. Do add `FROM employees AS T1 JOIN departments AS T2 ON T1.department_id = T2.department_id JOIN locations AS T3 ON T2.location_id = T3.location_id` instead of just `FROM employees`, introducing two additional joins to properly access the city data through the department and location relationships. Do keep the `WHERE T1.first_name LIKE '%z%'` filter unchanged. The amended query now correctly joins through the department and location tables to retrieve the city information instead of attempting to access it directly from the employees table where it doesn't exist, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"city\" information about employees: use \"T3.city\" instead of just \"city\" because city data is stored in the locations table, not the employees table. 2) When combining employee data with city information: join employees AS T1 with departments AS T2 using T1.department_id = T2.department_id, then join departments AS T2 with locations AS T3 using T2.location_id = T3.location_id to properly access the city data. 3) When filtering for employees whose first name contains the letter 'z': use T1.first_name LIKE '%z%' with exact case and wildcard pattern as specified. 4) When selecting output columns: display T1.first_name, T1.last_name, and T3.city in that order to match the question's request for first name, last name, and city information."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name, city FROM employees WHERE first_name LIKE '%z%'",
            "SELECT T1.first_name, T1.last_name, T3.city \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nJOIN locations AS T3 ON T2.location_id = T3.location_id \nWHERE T1.first_name LIKE '%z%'"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.last_name, T3.city\nFROM employees AS T1\nJOIN departments AS T2 ON T1.department_id = T2.department_id\nJOIN locations AS T3 ON T2.location_id = T3.location_id\nWHERE T1.first_name LIKE '%z%';"
        ]
    },
    "4739": {
        "db_id": "department_store",
        "question": "What is the id and name of the department store that has both marketing and managing department?",
        "ground_truth": "SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  \"marketing\" INTERSECT SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  \"managing\"",
        "amends": [
            "Do use `T2.dept_store_id` and `T2.store_name` instead of `id` and `name`. Do join `departments AS T1` with `department_stores AS T2` on `T1.dept_store_id = T2.dept_store_id` instead of querying a single table. Do filter on `T1.department_name = \"marketing\"` and `T1.department_name = \"managing\"` in separate queries instead of using conflicting `AND` conditions on the same column. Do use `INTERSECT` to find stores that have both departments instead of the impossible `AND` condition. Do remove the incorrect table reference `department_store` and add proper table aliases. The amended query now correctly identifies stores containing both marketing and managing departments through set intersection."
        ],
        "rules": [
            "1) When answering about department stores with both marketing and managing departments: use T2.dept_store_id and T2.store_name for the id and name output columns. 2) When combining departments and department_stores tables: link rows where T1.dept_store_id = T2.dept_store_id and keep only matching pairs (inner match). 3) When filtering for marketing department: use T1.department_name = \"marketing\" as the exact condition. 4) When filtering for managing department: use T1.department_name = \"managing\" as the exact condition. 5) When finding stores with both departments: use INTERSECT operation between the marketing department results and managing department results instead of AND conditions on the same column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, name FROM department_store WHERE department = 'marketing' AND department = 'managing'",
            "SELECT T2.dept_store_id, T2.store_name\nFROM departments AS T1\nJOIN department_stores AS T2 ON T1.dept_store_id = T2.dept_store_id\nWHERE T1.department_name = 'marketing'\nINTERSECT\nSELECT T2.dept_store_id, T2.store_name\nFROM departments AS T1\nJOIN department_stores AS T2 ON T1.dept_store_id = T2.dept_store_id\nWHERE T1.department_name = 'managing'"
        ],
        "rule_sql": [
            "SELECT T2.dept_store_id, T2.store_name\nFROM Departments T1\nINNER JOIN Department_Stores T2 ON T1.dept_store_id = T2.dept_store_id\nWHERE T1.department_name = 'marketing'\nINTERSECT\nSELECT T2.dept_store_id, T2.store_name\nFROM Departments T1\nINNER JOIN Department_Stores T2 ON T1.dept_store_id = T2.dept_store_id\nWHERE T1.department_name = 'managing'"
        ]
    },
    "327": {
        "db_id": "product_catalog",
        "question": "Find the names of all the products whose stock number starts with \"2\".",
        "ground_truth": "SELECT catalog_entry_name FROM catalog_contents WHERE product_stock_number LIKE \"2%\"",
        "amends": [
            "Do reference `catalog_entry_name` instead of `name` in the SELECT list. Do use `catalog_contents` instead of `products` as the FROM source table. Do filter on `product_stock_number` instead of `stock` in the WHERE clause. Do use double quotes for the string pattern instead of single quotes. The amended query now correctly retrieves catalog entry names where product stock numbers begin with '2'."
        ],
        "rules": [
            "1) When the question asks for product names: use \"catalog_entry_name\" from the \"Catalog_Contents\" table instead of \"name\" from \"products\". 2) When filtering by stock number: use \"product_stock_number\" column instead of \"stock\" column. 3) When using string patterns in conditions: use double quotes for string literals instead of single quotes. 4) When the question mentions \"stock number starts with '2'\": filter where \"product_stock_number\" begins with the exact pattern \"2\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM products WHERE stock LIKE '2%';",
            "SELECT catalog_entry_name FROM Catalog_Contents WHERE product_stock_number LIKE \"2%\""
        ],
        "rule_sql": [
            "SELECT catalog_entry_name FROM Catalog_Contents WHERE product_stock_number LIKE \"2%\";"
        ]
    },
    "4411": {
        "db_id": "network_2",
        "question": "What is the name of the oldest student?",
        "ground_truth": "SELECT name FROM Person WHERE job  =  'student' AND age  =  (SELECT max(age) FROM person WHERE job  =  'student' )",
        "amends": [
            "Do add `WHERE job = 'student'` filter instead of omitting it, and do change the ordering logic to use `age = (SELECT max(age) FROM person WHERE job = 'student')` instead of `ORDER BY age ASC LIMIT 1`. Do change the table reference from `students` to `Person` instead of keeping the original table name. Do remove the `LIMIT 1` clause instead of keeping it, as the subquery approach ensures only the oldest student is returned. The amended query now correctly identifies students by their job field and finds the oldest student using a maximum age subquery instead of simple ordering with limit."
        ],
        "rules": [
            "1) When the question asks about \"student\": filter rows where \"job\" equals exactly 'student' to identify students. 2) When finding the oldest student: use the maximum value of \"age\" from the filtered student records to identify the oldest age. 3) When retrieving the name of the oldest student: match the student's \"age\" to the maximum age value found among students. 4) When referring to the person table: use the exact table name \"Person\" instead of any other table reference."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM students ORDER BY age ASC LIMIT 1;",
            "SELECT name FROM Person WHERE job = 'student' AND age = (SELECT MAX(age) FROM Person WHERE job = 'student')"
        ],
        "rule_sql": [
            "SELECT name FROM Person WHERE job = 'student' AND age = (SELECT MAX(age) FROM Person WHERE job = 'student')"
        ]
    },
    "1792": {
        "db_id": "small_bank_1",
        "question": "Find the names of accounts whose checking balance is above the average checking balance, but savings balance is below the average savings balance.",
        "ground_truth": "SELECT T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  >  (SELECT avg(balance) FROM checking) INTERSECT SELECT T1.name FROM accounts AS T1 JOIN savings AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  <  (SELECT avg(balance) FROM savings)",
        "amends": [
            "Do use `T1.name` with table alias instead of `name` without alias. Do join `checking AS T2` on `T1.custid = T2.custid` instead of querying only the `accounts` table. Do filter on `T2.balance > (SELECT avg(balance) FROM checking)` instead of `checking_balance > (SELECT AVG(checking_balance) FROM accounts)`. Do use `INTERSECT` to combine results with a second query instead of using multiple AND conditions in WHERE. Do add a second query joining `savings AS T2` on `T1.custid = T2.custid` with filter `T2.balance < (SELECT avg(balance) FROM savings)` instead of `savings_balance < (SELECT AVG(savings_balance) FROM accounts)`. Do reference separate `checking` and `savings` tables instead of assuming both balances exist in the `accounts` table. The amended query now correctly identifies customers with above-average checking balances and below-average savings balances by properly joining to the respective balance tables and using INTERSECT for the logical AND condition."
        ],
        "rules": [
            "1) When answering about account names with specific balance conditions: use T1.name from the ACCOUNTS table as the output column. 2) When the question mentions \"checking balance\": this refers to the balance column in the checking table, which must be joined to ACCOUNTS using T1.custid = T2.custid. 3) When the question mentions \"savings balance\": this refers to the balance column in the savings table, which must be joined to ACCOUNTS using T1.custid = T2.custid. 4) When filtering for accounts with checking balance above average: use T2.balance > (SELECT avg(balance) FROM checking) after joining checking as T2. 5) When filtering for accounts with savings balance below average: use T2.balance < (SELECT avg(balance) FROM savings) after joining savings as T2. 6) When combining both conditions: use INTERSECT to find accounts that satisfy both the checking balance condition and savings balance condition, rather than using AND in a single WHERE clause. 7) When joining tables: always perform inner matches using the exact key equality T1.custid = T2.custid for both checking and savings tables."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM accounts WHERE checking_balance > (SELECT AVG(checking_balance) FROM accounts) AND savings_balance < (SELECT AVG(savings_balance) FROM accounts);",
            "SELECT T1.name\nFROM accounts AS T1\nJOIN checking AS T2 ON T1.custid = T2.custid\nWHERE T2.balance > (SELECT AVG(balance) FROM checking)\nINTERSECT\nSELECT T1.name\nFROM accounts AS T1\nJOIN savings AS T2 ON T1.custid = T2.custid\nWHERE T2.balance < (SELECT AVG(balance) FROM savings)"
        ],
        "rule_sql": [
            "SELECT T1.name FROM ACCOUNTS T1\nJOIN CHECKING T2 ON T1.custid = T2.custid\nWHERE T2.balance > (SELECT avg(balance) FROM checking)\nINTERSECT\nSELECT T1.name FROM ACCOUNTS T1\nJOIN SAVINGS T2 ON T1.custid = T2.custid\nWHERE T2.balance < (SELECT avg(balance) FROM savings)"
        ]
    },
    "6333": {
        "db_id": "e_government",
        "question": "Count the number of cities in the state of Colorado.",
        "ground_truth": "SELECT count(*) FROM addresses WHERE state_province_county  =  \"Colorado\"",
        "amends": [
            "Do query the `addresses` table instead of the `cities` table. Do use the column `state_province_county` instead of `state` for filtering. Do use double quotes `\"Colorado\"` instead of single quotes `'Colorado'` for the string literal. The amended query now correctly counts addresses in Colorado rather than attempting to count cities."
        ],
        "rules": [
            "1) When answering about \"number of cities in Colorado\": query the \"addresses\" table instead of the \"cities\" table. 2) When filtering for the state of Colorado: use the column \"state_province_county\" instead of \"state\" for filtering. 3) When specifying the literal value for Colorado: use double quotes \"Colorado\" instead of single quotes 'Colorado' for the string literal."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities WHERE state = 'Colorado';",
            "SELECT COUNT(DISTINCT town_city) FROM Addresses WHERE state_province_county = \"Colorado\";"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT town_city) FROM Addresses WHERE state_province_county = \"Colorado\";"
        ]
    },
    "952": {
        "db_id": "medicine_enzyme_interaction",
        "question": "What are the ids, names, and FDA approval status for medicines ordered by descending number of possible enzyme interactions?",
        "ground_truth": "SELECT T1.id ,  T1.Name ,  T1.FDA_approved FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id GROUP BY T1.id ORDER BY count(*) DESC",
        "amends": [
            "Do select `T1.id`, `T1.Name`, and `T1.FDA_approved` instead of `medicine_id`, `name`, `fda_approval_status`, and `interaction_count`. Do use `JOIN` instead of `LEFT JOIN` and join on `T2.medicine_id = T1.id` instead of `medicines.medicine_id = medicine_enzyme_interactions.medicine_id`. Do group by only `T1.id` instead of grouping by `medicine_id`, `name`, and `fda_approval_status`. Do order by `count(*) DESC` instead of `interaction_count ASC`. Do remove the explicit count alias instead of keeping it. The amended query now correctly returns medicine details with interaction counts in descending order."
        ],
        "rules": [
            "1) When selecting medicine details: use T1.id, T1.Name, and T1.FDA_approved instead of medicine_id, name, and fda_approval_status. 2) When combining medicine and interaction tables: use JOIN (not LEFT JOIN) and link rows where T2.medicine_id = T1.id. 3) When grouping by medicine: group by only T1.id instead of multiple columns. 4) When ordering by interaction count: order by count(*) DESC instead of interaction_count ASC. 5) When counting interactions: do not include an explicit count alias in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT medicine_id, name, fda_approval_status, COUNT(enzyme_id) as interaction_count \nFROM medicines \nLEFT JOIN medicine_enzyme_interactions ON medicines.medicine_id = medicine_enzyme_interactions.medicine_id \nGROUP BY medicine_id, name, fda_approval_status \nORDER BY interaction_count ASC;",
            "SELECT T1.id, T1.name, T1.FDA_approved\nFROM medicine T1\nJOIN medicine_enzyme_interaction T2 ON T2.medicine_id = T1.id\nGROUP BY T1.id\nORDER BY COUNT(*) DESC;"
        ],
        "rule_sql": [
            "SELECT T1.id, T1.name, T1.FDA_approved\nFROM medicine T1\nJOIN medicine_enzyme_interaction T2 ON T2.medicine_id = T1.id\nGROUP BY T1.id\nORDER BY COUNT(*) DESC"
        ]
    },
    "6095": {
        "db_id": "customers_and_addresses",
        "question": "List all the contact channel codes that were used less than 5 times.",
        "ground_truth": "SELECT channel_code FROM customer_contact_channels GROUP BY channel_code HAVING count(customer_id)  <  5",
        "amends": [
            "Do use table `customer_contact_channels` instead of `contact_channels`. Do change the aggregate function to `count(customer_id)` instead of `COUNT(*)`. Do reverse the filter condition to `< 5` instead of `> 5`. Do remove the alias `usage_count` from the SELECT list instead of including it. The amended query now correctly identifies channel codes with fewer than 5 customer contacts rather than those with more than 5 total records."
        ],
        "rules": [
            "1) When answering about \"contact channel codes used less than 5 times\": use table \"customer_contact_channels\" instead of \"contact_channels\". 2) When counting customer contacts per channel code: count distinct \"customer_id\" values instead of counting all rows. 3) When filtering for channel codes with fewer than 5 uses: apply the condition count(customer_id) < 5 instead of count(customer_id) > 5. 4) When selecting output columns: include only \"channel_code\" and remove any usage count alias from the final output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT channel_code, COUNT(*) as usage_count FROM contact_channels GROUP BY channel_code HAVING usage_count > 5;",
            "SELECT channel_code FROM Customer_Contact_Channels GROUP BY channel_code HAVING COUNT(customer_id) < 5"
        ],
        "rule_sql": [
            "SELECT channel_code FROM Customer_Contact_Channels GROUP BY channel_code HAVING COUNT(DISTINCT customer_id) < 5"
        ]
    },
    "2516": {
        "db_id": "movie_1",
        "question": "What are the ids of the movies that are not reviewed by Brittany Harris.",
        "ground_truth": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  \"Brittany Harris\"",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` subquery for better null handling and performance. Do reference table `Rating` instead of `movies` and `reviews` to match the correct schema. Do join `Rating AS T1` with `Reviewer AS T2` on `T1.rID = T2.rID` instead of directly filtering by reviewer name in a subquery. Do filter by `T2.name = \"Brittany Harris\"` instead of `reviewer_name = 'Brittany Harris'` to use the proper column name and table structure. Do select `mID` instead of `movie_id` to use the correct column identifier. The amended query now correctly identifies movies not reviewed by Brittany Harris using proper table relationships and avoids null-related issues with the NOT IN approach.",
            "Do select `mID` from `Rating` instead of from `Movie` as the base table. Do keep the `EXCEPT` operation and the subquery structure unchanged, maintaining the same join condition `T1.rID = T2.rID` and filter `T2.name = \"Brittany Harris\"` to identify ratings by the specific reviewer. The amendment correctly queries the Rating table directly for movie IDs rather than the Movie table, ensuring the result set contains only movies that have been rated before applying the exception logic. The amended query now matches RIGHT_SQL's behavior by properly identifying movies that have ratings excluding those rated by Brittany Harris."
        ],
        "rules": [
            "1) When answering about movies not reviewed by a specific reviewer: use the exact identifier \"mID\" from the Rating table instead of \"movie_id\". 2) When combining Rating and Reviewer tables: link rows where T1.rID = T2.rID to establish the proper relationship between ratings and reviewers. 3) When filtering for reviewer \"Brittany Harris\": use the exact literal \"Brittany Harris\" with the column name \"name\" from the Reviewer table (T2.name = \"Brittany Harris\"). 4) When finding movies not reviewed by a specific person: use the EXCEPT set operation instead of NOT IN subquery for better null handling and performance. 5) When selecting movie identifiers: ensure the output column is \"mID\" from the Rating table (T1.mID).",
            "1) When answering about \"movies not reviewed by Brittany Harris\": make sure the output order: mID\n2) When the question mentions \"movies that are not reviewed by Brittany Harris\": use the Rating table as the base table for selecting mID values\n3) When identifying movies reviewed by Brittany Harris: join Rating as T1 and Reviewer as T2 where T1.rID = T2.rID and filter for T2.name = \"Brittany Harris\" exactly\n4) When computing the final result: use EXCEPT operation to remove movies reviewed by Brittany Harris from all movies that have been reviewed (from Rating table)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT movie_id FROM movies WHERE movie_id NOT IN (SELECT movie_id FROM reviews WHERE reviewer_name = 'Brittany Harris')",
            "SELECT mID FROM Movie\nEXCEPT\nSELECT T1.mID FROM Rating AS T1\nJOIN Reviewer AS T2 ON T1.rID = T2.rID\nWHERE T2.name = \"Brittany Harris\"",
            "SELECT mID FROM Rating\nEXCEPT\nSELECT T1.mID FROM Rating AS T1\nJOIN Reviewer AS T2 ON T1.rID = T2.rID\nWHERE T2.name = \"Brittany Harris\""
        ],
        "rule_sql": [
            "SELECT mID FROM Rating\nEXCEPT\nSELECT T1.mID FROM Rating T1\nJOIN Reviewer T2 ON T1.rID = T2.rID\nWHERE T2.name = \"Brittany Harris\"\nORDER BY mID"
        ]
    },
    "2584": {
        "db_id": "inn_1",
        "question": "How many adults stay in the room CONRAD SELBIG checked in on Oct 23, 2010?",
        "ground_truth": "SELECT Adults FROM Reservations WHERE CheckIn  =  \"2010-10-23\" AND FirstName  =  \"CONRAD\" AND LastName  =  \"SELBIG\";",
        "amends": [
            "Do select `Adults` instead of `COUNT(*)`. Do query from `Reservations` instead of `guests`. Do filter on `CheckIn = \"2010-10-23\"` instead of `check_in_date = '2010-10-23'`. Do filter on `FirstName = \"CONRAD\"` and `LastName = \"SELBIG\"` instead of `name = 'CONRAD SELBIG'`. Do remove the `age >= 18` filter instead of keeping it. The amended query now correctly retrieves the number of adults from the Reservations table for the specified guest and check-in date."
        ],
        "rules": [
            "1) When answering about \"how many adults stay in the room\": select the exact column \"Adults\" from the Reservations table instead of counting all rows. 2) When the question mentions \"CONRAD SELBIG\": split this into two separate conditions using \"FirstName = \\\"CONRAD\\\"\" and \"LastName = \\\"SELBIG\\\"\" exactly as specified. 3) When the question mentions \"checked in on Oct 23, 2010\": use the exact date format \"2010-10-23\" with the column name \"CheckIn\" instead of \"check_in_date\". 4) When querying from the database: use the \"Reservations\" table instead of a \"guests\" table. 5) When filtering for adults: do not apply an age-based filter since the \"Adults\" column already contains the count of adults for each reservation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM guests WHERE name = 'CONRAD SELBIG' AND check_in_date = '2010-10-23' AND age >= 18",
            "SELECT Adults FROM Reservations WHERE FirstName = 'CONRAD' AND LastName = 'SELBIG' AND CheckIn = '2010-10-23';"
        ],
        "rule_sql": [
            "SELECT Adults FROM Reservations WHERE FirstName = \"CONRAD\" AND LastName = \"SELBIG\" AND CheckIn = \"2010-10-23\";"
        ]
    },
    "1791": {
        "db_id": "small_bank_1",
        "question": "What are the checking and savings balances in accounts belonging to Brown?",
        "ground_truth": "SELECT T2.balance ,  T3.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid WHERE T1.name  =  'Brown'",
        "amends": [
            "Do select `T2.balance` and `T3.balance` instead of `checking_balance` and `savings_balance`. Do use `accounts AS T1` joined with `checking AS T2` on `T1.custid = T2.custid` and `savings AS T3` on `T1.custid = T3.custid` instead of querying only the `accounts` table. Do filter on `T1.name = 'Brown'` instead of `last_name = 'Brown'`. The amended query now correctly joins related tables to retrieve checking and savings balances for the specified customer name."
        ],
        "rules": [
            "1) When answering about checking and savings balances: select T2.balance and T3.balance as output columns. 2) When the question mentions \"accounts belonging to Brown\": filter rows where T1.name equals 'Brown' exactly. 3) When combining accounts, checking, and savings tables: link accounts AS T1 with checking AS T2 where T1.custid = T2.custid, and link accounts AS T1 with savings AS T3 where T1.custid = T3.custid, keeping only matching pairs (inner matches)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT checking_balance, savings_balance FROM accounts WHERE last_name = 'Brown';",
            "SELECT T2.balance, T3.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid = T2.custid JOIN savings AS T3 ON T1.custid = T3.custid WHERE T1.name = 'Brown'"
        ],
        "rule_sql": [
            "SELECT T2.balance, T3.balance \nFROM ACCOUNTS AS T1\nINNER JOIN CHECKING AS T2 ON T1.custid = T2.custid\nINNER JOIN SAVINGS AS T3 ON T1.custid = T3.custid\nWHERE T1.name = 'Brown'"
        ]
    },
    "2114": {
        "db_id": "cre_Doc_Control_Systems",
        "question": "List the document ids for any documents with the status code done and the type code paper.",
        "ground_truth": "SELECT document_id FROM Documents WHERE document_status_code = \"done\" AND document_type_code = \"Paper\";",
        "amends": [
            "Do reference table `Documents` instead of `documents` to match the correct case. Do use column `document_status_code` instead of `status` to reference the proper status column name. Do use column `document_type_code` instead of `type` to reference the proper type column name. Do use double quotes around string literals `\"done\"` and `\"Paper\"` instead of single quotes to match the correct string formatting. The amended query now correctly filters documents by status and type using the proper column names and string formatting.",
            "Do use `\"Paper\"` instead of `\"paper\"` for the document_type_code filter to ensure case-sensitive matching with the correct value in the database. This change ensures the query returns documents with the exact document_type_code value 'Paper' rather than 'paper', which may not exist in the data."
        ],
        "rules": [
            "1) When referencing the documents table: use \"Documents\" with exact case instead of \"documents\". 2) When filtering by status: use column \"document_status_code\" instead of \"status\" to reference the proper status column. 3) When filtering by type: use column \"document_type_code\" instead of \"type\" to reference the proper type column. 4) When using string literals for status and type codes: use double quotes around \"done\" and \"Paper\" instead of single quotes to match the correct string formatting.",
            "1) When filtering for document_type_code: use the exact literal value \"Paper\" (with capital P) instead of \"paper\" to ensure case-sensitive matching with the database values. 2) When the question asks for documents with status code \"done\" and type code \"paper\": recognize that \"paper\" should be mapped to the exact database value \"Paper\" with proper capitalization."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id FROM documents WHERE status = 'done' AND type = 'paper';",
            "SELECT document_id FROM Documents WHERE document_status_code = \"done\" AND document_type_code = \"paper\"",
            "SELECT document_id FROM Documents WHERE document_status_code = \"done\" AND document_type_code = \"Paper\""
        ],
        "rule_sql": [
            "SELECT document_id FROM Documents WHERE document_status_code = \"done\" AND document_type_code = \"Paper\""
        ]
    },
    "3413": {
        "db_id": "hr_1",
        "question": "Display all the information about the department Marketing.",
        "ground_truth": "SELECT * FROM  departments WHERE department_name  =  'Marketing'",
        "amends": [
            "Do query the `departments` table instead of the `employees` table. Do filter on `department_name = 'Marketing'` instead of `department = 'Marketing'`. The amended query now correctly retrieves data from the departments table matching the specified department name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"department Marketing\": query the \"departments\" table instead of the \"employees\" table. 2) When filtering for department Marketing: use the exact literal 'Marketing' and match it against \"department_name\" column instead of \"department\" column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM employees WHERE department = 'Marketing';",
            "SELECT * FROM departments WHERE department_name = 'Marketing';"
        ],
        "rule_sql": [
            "SELECT * FROM departments WHERE DEPARTMENT_NAME = 'Marketing';"
        ]
    },
    "3654": {
        "db_id": "baseball_1",
        "question": "Count the number of players who were born in USA and have bats information 'R'.",
        "ground_truth": "SELECT count(*) FROM player WHERE birth_country = 'USA' AND bats  =  'R';",
        "amends": [
            "Do reference table `player` instead of `players`. Do filter on `birth_country = 'USA'` instead of `country = 'USA'`. Do filter on `bats = 'R'` instead of `bats = 'L'`. The amended query now correctly counts players born in the USA who bat right-handed."
        ],
        "rules": [
            "1) When the question asks about \"players\": use the table \"player\" instead of \"players\". 2) When the question mentions \"born in USA\": filter using \"birth_country = 'USA'\" instead of \"country = 'USA'\". 3) When the question mentions \"bats information 'R'\": filter using \"bats = 'R'\" instead of \"bats = 'L'\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE country = 'USA' AND bats = 'L';",
            "SELECT COUNT(*) FROM player WHERE birth_country = 'USA' AND bats = 'R';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM player WHERE birth_country = 'USA' AND bats = 'R'"
        ]
    },
    "6721": {
        "db_id": "activity_1",
        "question": "Show the rank, first name, and last name for all the faculty.",
        "ground_truth": "SELECT rank ,  Fname ,  Lname FROM Faculty",
        "amends": [
            "Do select columns `Fname` and `Lname` instead of `first_name` and `last_name`, and do query from table `Faculty` instead of `students`, while also changing the column `rank` to be selected from the correct table context. The amended query now correctly retrieves faculty information rather than student data, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about faculty information: query from table \"Faculty\" instead of \"students\". 2) When selecting first name and last name for faculty: use columns \"Fname\" and \"Lname\" instead of \"first_name\" and \"last_name\". 3) When selecting rank information for faculty: ensure the \"rank\" column is selected from the correct table context (Faculty table)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT rank, first_name, last_name FROM students",
            "SELECT Rank, Fname, Lname FROM Faculty;"
        ],
        "rule_sql": [
            "SELECT Rank, Fname, Lname FROM Faculty;"
        ]
    },
    "604": {
        "db_id": "store_1",
        "question": "How many employees who are IT staff are from each city?",
        "ground_truth": "SELECT count(*) ,  city FROM employees WHERE title  =  'IT Staff' GROUP BY city",
        "amends": [
            "Do select `count(*)` and `city` instead of `city` and `COUNT(*)`. Do filter on `title = 'IT Staff'` instead of `department = 'IT'`. Do group by `city` instead of `department`. The amended query now correctly counts employees by city with IT Staff titles rather than grouping by department.",
            "Do place `city` after `count(*)` in the SELECT list instead of before it, maintaining the same aggregation logic and filtering condition. Do keep the `COUNT(*)` aggregation and `GROUP BY city` clause unchanged, as they correctly count IT Staff employees per city. Do preserve the `WHERE title = 'IT Staff'` filter without modification. The amended query now matches the right SQL's behavior with identical output structure and results."
        ],
        "rules": [
            "1) When the question asks for \"count of employees who are IT staff per city\": compute the number of rows using the canonical key for employees and group by the exact token \"city\". 2) When the question mentions \"IT staff\": \"IT staff\" actually means \"title = 'IT Staff'\" in the schema. 3) When producing output columns: make sure the output order is \"city\" followed by the count. 4) When grouping by city: organize results by the exact token \"city\" and compute the count per group.",
            "1) When the question asks for \"count of employees who are IT staff per city\": compute the number of rows using COUNT(*) aggregation grouped by the exact token \"city\". 2) When filtering for employees who are IT staff: apply the condition WHERE title = 'IT Staff' exactly as specified with the literal 'IT Staff'. 3) When ordering output columns for \"how many employees per city\": place the count result before the city name in the output, maintaining COUNT(*) then city order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, COUNT(*) FROM employees WHERE department = 'IT' GROUP BY department;",
            "SELECT city, COUNT(*) FROM employees WHERE title = 'IT Staff' GROUP BY city;",
            "SELECT COUNT(*), city FROM employees WHERE title = 'IT Staff' GROUP BY city;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS employee_count, city FROM employees WHERE title = 'IT Staff' GROUP BY city ORDER BY employee_count DESC, city;"
        ]
    },
    "5333": {
        "db_id": "manufactory_1",
        "question": "What is the average price of products with manufacturer codes equal to 2?",
        "ground_truth": "SELECT avg(price) FROM products WHERE Manufacturer  =  2",
        "amends": [
            "Do filter on `Manufacturer = 2` instead of `manufacturer_code = 1` in the WHERE clause, changing both the column reference from `manufacturer_code` to `Manufacturer` and the filter value from `1` to `2`. Do use lowercase `avg(price)` instead of uppercase `AVG(price)` for the aggregate function, though this is a cosmetic change that does not affect functionality. The amended query now correctly filters for manufacturer 2 using the proper column name and matches the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about products with manufacturer codes equal to 2: filter rows where \"Manufacturer\" equals 2 exactly. 2) When computing average price: use the avg(price) function to calculate the average value of the price column. 3) When referring to manufacturer codes in the question: map \"manufacturer codes\" to the exact column token \"Manufacturer\" in the Products table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(price) FROM products WHERE manufacturer_code = 1;",
            "SELECT AVG(Price) FROM Products WHERE Manufacturer = 2;"
        ],
        "rule_sql": [
            "SELECT AVG(Price) FROM Products WHERE Manufacturer = 2;"
        ]
    },
    "1708": {
        "db_id": "epinions_1",
        "question": "Find the name and id of the good with the highest average rank.",
        "ground_truth": "SELECT T1.title ,  T1.i_id FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id GROUP BY T2.i_id ORDER BY avg(T2.rank) DESC LIMIT 1",
        "amends": [
            "Do select `T1.title` and `T1.i_id` instead of `name` and `id`. Do use `FROM item AS T1 JOIN review AS T2` instead of `FROM goods`. Do add `ON T1.i_id = T2.i_id` join condition instead of omitting it. Do add `GROUP BY T2.i_id` instead of omitting grouping. Do order by `avg(T2.rank) DESC` instead of `rank DESC`. The amended query now correctly joins item and review tables, groups by review item ID, and orders by average rank instead of individual rank, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"name and id of the good with the highest average rank\": make sure the output order: T1.title, T1.i_id. 2) When the question mentions \"name\": \"name\" actually means \"T1.title\" in schema. 3) When the question mentions \"id\": \"id\" actually means \"T1.i_id\" in schema. 4) When combining T1 (item) and T2 (review) for shared entities: link rows where T1.i_id = T2.i_id exactly as shown; keep only matching pairs (inner match). 5) When the question asks for \"highest average rank\": rank rows by avg(T2.rank) in descending direction and keep the first 1 row. 6) When the question asks for \"average rank per good\": organize results by T2.i_id and compute average rank per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, id FROM goods ORDER BY rank DESC LIMIT 1;",
            "SELECT T1.title, T1.i_id\nFROM item AS T1\nJOIN review AS T2 ON T1.i_id = T2.i_id\nGROUP BY T2.i_id\nORDER BY AVG(T2.rank) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.title, T1.i_id\nFROM item T1\nJOIN review T2 ON T1.i_id = T2.i_id\nGROUP BY T2.i_id\nORDER BY AVG(T2.rank) DESC\nLIMIT 1"
        ]
    },
    "563": {
        "db_id": "store_1",
        "question": "List the number of invoices from the US, grouped by state.",
        "ground_truth": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  \"USA\" GROUP BY billing_state;",
        "amends": [
            "Do reference `billing_state` in the SELECT list and GROUP BY clause instead of `state`. Do reference `billing_country` in the WHERE filter instead of `country`. Do use the literal value \"USA\" instead of 'US' for the country filter. Do group by `billing_state` instead of `country` to get counts per state rather than a single count for the entire country. The amended query now correctly counts invoices per billing state for USA customers instead of providing an incorrect single count for US customers."
        ],
        "rules": [
            "1) When the question asks for invoices grouped by state: use \"billing_state\" from the invoices table instead of \"state\" from the customers table. 2) When filtering for US invoices: use \"billing_country\" = \"USA\" instead of \"country\" = 'US'. 3) When counting invoices per state: group by \"billing_state\" to get counts per billing state rather than a single count for the entire country."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT state, COUNT(*) FROM invoices WHERE country = 'US' GROUP BY country;",
            "SELECT billing_state, COUNT(*) AS number_of_invoices FROM invoices WHERE billing_country = 'USA' GROUP BY billing_state"
        ],
        "rule_sql": [
            "SELECT billing_state, COUNT(*) AS number_of_invoices FROM invoices WHERE billing_country = 'USA' GROUP BY billing_state;"
        ]
    },
    "3983": {
        "db_id": "hospital_1",
        "question": "Among the procedures that cost more than 1000, which were not specialized in by physician John Wen?",
        "ground_truth": "SELECT name FROM procedures WHERE cost  >  1000 EXCEPT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  \"John Wen\"",
        "amends": [
            "Do select `name` instead of `procedure_name` and use a single table `procedures` instead of joining multiple tables. Do use an `EXCEPT` clause to filter out procedures performed by physicians named \"John Wen\" instead of using joins with `physician_specializations` and `physicians` tables. Do remove the explicit join conditions `p.procedure_id = ps.procedure_id` and `ps.physician_id = ph.physician_id` instead of keeping them. Do change the physician name filter to use a single `name` column with value \"John Wen\" instead of separate `first_name` and `last_name` columns with values 'John' and 'Wen'. Do reference `employeeid` and `physician` columns for joining instead of `physician_id`. Do use `code` and `treatment` columns for joining procedures instead of `procedure_id`. The amended query now correctly excludes procedures performed by John Wen while maintaining the cost filter, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about procedures that cost more than 1000: filter rows where \"cost\" > 1000. 2) When the question mentions \"physician John Wen\": \"John Wen\" means the exact literal value 'John Wen' in the \"name\" column. 3) When excluding procedures specialized in by a specific physician: use an EXCEPT operation to remove procedures where \"name\" = 'John Wen' from the result set. 4) When selecting procedure names: use the exact column name \"name\" instead of \"procedure_name\" for output. 5) When handling physician identification: use the single column \"name\" with value \"John Wen\" instead of separate first_name and last_name columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.procedure_name \nFROM procedures p\nJOIN physician_specializations ps ON p.procedure_id = ps.procedure_id\nJOIN physicians ph ON ps.physician_id = ph.physician_id\nWHERE p.cost > 1000\nAND ph.first_name = 'John' AND ph.last_name = 'Wen';",
            "SELECT Name FROM Procedures WHERE Cost > 1000\nEXCEPT\nSELECT p.Name FROM Procedures p\nJOIN Trained_In ti ON p.Code = ti.Treatment\nJOIN Physician ph ON ti.Physician = ph.EmployeeID\nWHERE ph.Name = 'John Wen'"
        ],
        "rule_sql": [
            "SELECT Name FROM Procedures WHERE Cost > 1000\nEXCEPT\nSELECT p.Name \nFROM Procedures p\nJOIN Trained_In ti ON p.Code = ti.Treatment\nJOIN Physician ph ON ti.Physician = ph.EmployeeID\nWHERE ph.Name = 'John Wen'"
        ]
    },
    "5817": {
        "db_id": "workshop_paper",
        "question": "Find the author for each submission and list them in ascending order of submission score.",
        "ground_truth": "SELECT Author FROM submission ORDER BY Scores ASC",
        "amends": [
            "Do select only `Author` instead of both `author` and `submission_score`. Do order by `Scores ASC` instead of `submission_score DESC`. Do reference table `submission` instead of `submissions`. The amended query now matches the intended behavior of selecting authors ordered by their scores in ascending order."
        ],
        "rules": [
            "1) When answering about \"author for each submission\": select only the \"Author\" column from the submission table. 2) When ordering by submission score in ascending order: order the results by the \"Scores\" column in ascending direction. 3) When referencing the submission table: use the exact table name \"submission\" instead of \"submissions\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT author, submission_score FROM submissions ORDER BY submission_score DESC;",
            "SELECT Author FROM submission ORDER BY Scores ASC;"
        ],
        "rule_sql": [
            "SELECT Author FROM submission ORDER BY Scores ASC;"
        ]
    },
    "2818": {
        "db_id": "news_report",
        "question": "Find the average age and experience working length of journalists working on different role type.",
        "ground_truth": "SELECT avg(t1.age) ,  avg(Years_working) ,  t2.work_type FROM journalist AS t1 JOIN news_report AS t2 ON t1.journalist_id  =  t2.journalist_id GROUP BY t2.work_type",
        "amends": [
            "Do use `avg(t1.age)` and `avg(Years_working)` instead of `AVG(age)` and `AVG(experience)` for the aggregate expressions. Do specify `t2.work_type` instead of `role_type` in the SELECT list and GROUP BY clause. Do join `journalist AS t1` with `news_report AS t2` using `ON t1.journalist_id = t2.journalist_id` instead of querying only the `journalists` table. Do reference the joined table aliases `t1` and `t2` instead of using unqualified column names. The amended query now correctly calculates averages from joined tables and groups by the appropriate work type column.",
            "Do use lowercase `avg(t1.age)` and `avg(Years_working)` without aliases instead of uppercase `AVG(t1.Age)` with `AS average_age` and `AVG(t1.Years_working)` with `AS average_experience`. Do place `t2.work_type` at the end of the SELECT list instead of beginning with `t2.Work_Type`. Do use lowercase `work_type` in GROUP BY instead of uppercase `Work_Type`. Do use lowercase `journalist_id` in the join condition instead of uppercase `journalist_ID`. The amended query now matches RIGHT_SQL's behavior with proper lowercase column references and reordered SELECT list elements."
        ],
        "rules": [
            "1) When answering about \"average age and experience working length of journalists working on different role type\": make sure the output order: work_type, avg_age, avg_experience. 2) When the question mentions \"role type\": \"role type\" actually means \"Work_Type in schema\". 3) When the question mentions \"experience working length\": \"experience working length\" actually means \"Years_working in schema\". 4) When combining journalist AS t1 and news_report AS t2 for shared entities: link rows where t1.journalist_id = t2.journalist_id; keep only matching pairs (inner match). 5) When the question asks for \"average age\": compute the average of t1.age. 6) When the question asks for \"average experience working length\": compute the average of Years_working. 7) When the question says \"per role type\"/\"by role type\": organize results by t2.Work_Type and compute requested aggregates per group.",
            "1) When the question asks for average age and experience working length: compute avg(t1.age) and avg(Years_working) without using uppercase AVG or AS aliases like average_age and average_experience. 2) When organizing results by role type: group by t2.work_type using lowercase instead of uppercase Work_Type. 3) When combining journalist and news_report tables: link rows where t1.journalist_id = t2.journalist_id using lowercase journalist_id instead of uppercase journalist_ID. 4) When ordering output columns: place t2.work_type at the end of the result columns instead of at the beginning."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT role_type, AVG(age) as avg_age, AVG(experience) as avg_experience FROM journalists GROUP BY role_type;",
            "SELECT t2.Work_Type, AVG(t1.Age) AS average_age, AVG(t1.Years_working) AS average_experience FROM journalist AS t1 JOIN news_report AS t2 ON t1.journalist_ID = t2.journalist_ID GROUP BY t2.Work_Type;",
            "SELECT avg(t1.age), avg(Years_working), t2.work_type FROM journalist AS t1 JOIN news_report AS t2 ON t1.journalist_id = t2.journalist_id GROUP BY t2.work_type"
        ],
        "rule_sql": [
            "SELECT avg(t1.age), avg(t1.Years_working), t2.work_type FROM journalist t1 JOIN news_report t2 ON t1.journalist_id = t2.journalist_id GROUP BY t2.work_type"
        ]
    },
    "6204": {
        "db_id": "roller_coaster",
        "question": "List the names of roller coasters by ascending order of length.",
        "ground_truth": "SELECT Name FROM roller_coaster ORDER BY LENGTH ASC",
        "amends": [
            "Do reference the table as `roller_coaster` instead of `roller_coasters`. Do use column name `Name` instead of `name`. Do order by `LENGTH ASC` instead of `length DESC`, changing both the column reference case and sort direction. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about roller coasters: use the exact table name \"roller_coaster\" instead of \"roller_coasters\". 2) When referring to coaster names: use the exact column name \"Name\" instead of \"name\". 3) When ordering by length in ascending order: use the exact column name \"LENGTH\" and sort direction ASC instead of DESC."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM roller_coasters ORDER BY length DESC;",
            "SELECT Name FROM roller_coaster ORDER BY Length ASC;"
        ],
        "rule_sql": [
            "SELECT Name FROM roller_coaster ORDER BY Length ASC;"
        ]
    },
    "455": {
        "db_id": "allergy_1",
        "question": "Which allergy type has most number of allergies?",
        "ground_truth": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference table `Allergy_type` instead of `allergies` and column `allergytype` instead of `allergy_type`. Do use `ORDER BY count(*) DESC` instead of `ORDER BY allergy_count ASC` to sort by descending count rather than ascending. Do select only `allergytype` instead of both `allergy_type` and `allergy_count` since the count is only needed for ordering. The amended query now correctly identifies the most common allergy type by counting occurrences in descending order."
        ],
        "rules": [
            "1) When answering about \"which allergy type has most number of allergies\": make sure the output order: only show the allergytype column. 2) When counting allergy occurrences: count all rows in the Allergy_type table to determine frequency. 3) When ranking by count to find the most common: sort the results by count in descending order and keep only the top result. 4) When referring to the allergy type column: use the exact identifier \"allergytype\" from the Allergy_type table. 5) When selecting output: only include the allergytype value, not the count (which is only used for ordering)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT allergy_type, COUNT(*) as allergy_count FROM allergies GROUP BY allergy_type ORDER BY allergy_count ASC LIMIT 1;",
            "SELECT AllergyType FROM Allergy_Type GROUP BY AllergyType ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT allergytype FROM Allergy_Type GROUP BY allergytype ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "6757": {
        "db_id": "activity_1",
        "question": "Show all the faculty ranks and the number of students advised by each rank.",
        "ground_truth": "SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank",
        "amends": [
            "Do add `JOIN Faculty AS T1` and `Student AS T2` with join condition `ON T1.FacID = T2.advisor` instead of querying only the `students` table. Do select `T1.rank` instead of `faculty_rank` from the students table. Do group by `T1.rank` instead of `faculty_rank` to properly aggregate by faculty rank from the joined Faculty table. The amended query now correctly counts students per faculty rank by joining the Faculty and Student tables on the advisor relationship instead of attempting to use a non-existent faculty_rank column in the students table."
        ],
        "rules": [
            "1) When answering about \"faculty ranks and number of students advised by each rank\": make sure the output order: T1.rank, count of students\n2) When the question mentions \"faculty ranks\": \"faculty ranks\" actually means \"T1.rank in schema\"\n3) When combining Faculty as T1 and Student as T2 for shared entities: link rows where T1.FacID = T2.advisor exactly as shown in the amends; keep only matching pairs (inner match)\n4) When the question asks for \"number of students advised by each rank\": compute the count of students using the relationship T1.FacID = T2.advisor per T1.rank group\n5) When the question says \"by each rank\": organize results by T1.rank and compute requested aggregates per group"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT faculty_rank, COUNT(*) FROM students GROUP BY faculty_rank;",
            "SELECT T1.rank, COUNT(T2.StuID) AS number_of_students\nFROM Faculty AS T1\nJOIN Student AS T2 ON T1.FacID = T2.Advisor\nGROUP BY T1.rank"
        ],
        "rule_sql": [
            "SELECT f.Rank, COUNT(s.StuID) AS student_count\nFROM Faculty f\nINNER JOIN Student s ON f.FacID = s.Advisor\nGROUP BY f.Rank\nORDER BY f.Rank;"
        ]
    },
    "5513": {
        "db_id": "voter_2",
        "question": "Return the code of the city that has the most students.",
        "ground_truth": "SELECT city_code FROM STUDENT GROUP BY city_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference `city_code` instead of `city` in the SELECT list and GROUP BY clause. Do use the correct table name `STUDENT` instead of `students` in the FROM clause. The amended query now correctly references the appropriate column and table names to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for the \"code of the city\": use the exact column token \"city_code\" from the STUDENT table. 2) When counting students per city: count using the canonical key (each student row) and group by \"city_code\". 3) When finding the city with the most students: rank cities by student count in descending order and keep only the top result. 4) When referencing the student table: use the exact table name \"STUDENT\" (not \"students\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city FROM students GROUP BY city ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT city_code FROM Student GROUP BY city_code ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT city_code FROM STUDENT GROUP BY city_code ORDER BY COUNT(StuID) DESC LIMIT 1;"
        ]
    },
    "5448": {
        "db_id": "voter_2",
        "question": "Find the distinct number of president votes.",
        "ground_truth": "SELECT count(DISTINCT President_Vote) FROM VOTING_RECORD",
        "amends": [
            "Do use `count(DISTINCT President_Vote)` instead of `COUNT(*)` to count distinct vote values rather than all rows. Do reference table `VOTING_RECORD` instead of `president_votes` as the correct data source. The amended query now correctly counts unique presidential votes from the appropriate voting record table."
        ],
        "rules": [
            "1) When counting distinct president votes: use count(DISTINCT \"President_Vote\") instead of COUNT(*) to count unique vote values. 2) When referencing the voting data: use table \"VOTING_RECORD\" instead of president_votes as the correct data source."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM president_votes;",
            "SELECT COUNT(DISTINCT President_Vote) FROM Voting_record;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT President_Vote) FROM Voting_record"
        ]
    },
    "529": {
        "db_id": "allergy_1",
        "question": "Find the number of male (sex is 'M') students who have some food type allery.",
        "ground_truth": "SELECT count(*) FROM Student WHERE sex  =  \"M\" AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  \"food\")",
        "amends": [
            "Do reference the `Student` table instead of `students` and use a subquery to filter by food allergies instead of checking `allergy IS NOT NULL`. Do add a subquery with `StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.allergytype = \"food\")` instead of the simple `allergy IS NOT NULL` condition, which incorrectly counts all students with any allergy rather than specifically food allergies. Do join `Has_allergy` with `Allergy_Type` on `T1.Allergy = T2.Allergy` and filter for `T2.allergytype = \"food\"` instead of the non-specific null check. The amended query now correctly counts only male students with food allergies, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"number of male students with food allergies\": make sure the output order: count of students\n2) When the question mentions \"male (sex is 'M')\": use the exact literal 'M' for the sex condition in the Student table\n3) When the question mentions \"food type allergy\": use the exact literal \"food\" for the allergytype condition in the Allergy_Type table\n4) When combining Student and Has_allergy tables: link rows where Student.StuID = Has_allergy.StuID to find students with allergies\n5) When combining Has_allergy and Allergy_Type tables: link rows where T1.Allergy = T2.Allergy and filter for T2.allergytype = \"food\" to identify food allergies specifically\n6) When counting students: use Student.StuID as the counting key to ensure each student is counted only once\n7) When filtering for food allergies: use a subquery with StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.allergytype = \"food\") instead of checking for any non-null allergy"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE sex = 'M' AND allergy IS NOT NULL",
            "SELECT COUNT(*) \nFROM Student \nWHERE Sex = 'M' \nAND StuID IN (\n    SELECT T1.StuID \n    FROM Has_Allergy AS T1 \n    JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy \n    WHERE T2.AllergyType = 'food'\n)"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Student.StuID) \nFROM Student \nWHERE Student.Sex = 'M' \nAND Student.StuID IN (\n    SELECT T1.StuID \n    FROM Has_Allergy AS T1 \n    JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy \n    WHERE T2.AllergyType = 'food'\n)"
        ]
    },
    "348": {
        "db_id": "flight_1",
        "question": "What are the ids of all aircrafts that can cover a distance of more than 1000?",
        "ground_truth": "SELECT aid FROM Aircraft WHERE distance  >  1000",
        "amends": [
            "Do reference the table as `Aircraft` instead of `aircrafts` and use column `aid` instead of `aircraft_id` in the SELECT list. Do use the filter condition `distance > 1000` instead of `distance <= 1000` to select aircraft with distances greater than 1000 rather than less than or equal to 1000. The amended query now correctly selects aircraft IDs from the Aircraft table where the distance exceeds 1000, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for aircraft IDs: use column \"aid\" from table \"Aircraft\" instead of \"aircraft_id\" from \"aircrafts\". 2) When filtering for aircraft that can cover more than 1000 distance: use condition distance > 1000 instead of distance <= 1000. 3) When referencing the aircraft table: use table name \"Aircraft\" instead of \"aircrafts\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT aircraft_id FROM aircrafts WHERE distance <= 1000;",
            "SELECT aid FROM aircraft WHERE distance > 1000;"
        ],
        "rule_sql": [
            "SELECT aid FROM Aircraft WHERE distance > 1000"
        ]
    },
    "5813": {
        "db_id": "customer_complaints",
        "question": "Give the state that has the most customers.",
        "ground_truth": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do remove the explicit column alias `customer_count` from the SELECT list instead of including it, and do reference the aggregate function `count(*)` directly in the ORDER BY clause instead of using the alias. Do omit the redundant column `customer_count` from the SELECT list instead of including it, since only the `state` column is needed in the final result. The amended query now correctly returns only the state with the lowest customer count while maintaining the same logical behavior.",
            "Do remove the `WHERE state IS NOT NULL` filter instead of keeping it, as the GROUP BY operation inherently excludes NULL values. Do change the ORDER BY clause to use `count(*)` without DESC instead of `COUNT(*) DESC`, making it ascending order by default. Do use lowercase `customers` instead of `Customers` for table name consistency. The amended query now correctly identifies the state with the fewest customers by removing the unnecessary NULL filter and changing to ascending order count.",
            "Do use `ORDER BY count(*)` without the `DESC` modifier instead of `ORDER BY count(*) DESC` to sort states by ascending customer count rather than descending. This change ensures the query returns the state with the fewest customers instead of the state with the most customers, matching the intended behavior of the corrected query.",
            "Do use `ORDER BY count(*)` without the `DESC` modifier instead of `ORDER BY count(*) DESC` to sort states by ascending count rather than descending count. This change ensures the query returns the state with the smallest number of customers instead of the largest, matching the intended behavior of the corrected query.",
            "Do remove the `DESC` keyword from the `ORDER BY` clause instead of keeping it, changing the sort direction from descending to ascending to correctly identify the state with the minimum count rather than the maximum count."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT state, COUNT(*) as customer_count FROM customers GROUP BY state ORDER BY customer_count ASC LIMIT 1;",
            "SELECT state FROM Customers WHERE state IS NOT NULL GROUP BY state ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT state FROM customers GROUP BY state ORDER BY count(*) DESC LIMIT 1",
            "SELECT state FROM customers GROUP BY state ORDER BY count(*) DESC LIMIT 1",
            "SELECT state FROM customers GROUP BY state ORDER BY count(*) DESC LIMIT 1",
            "SELECT state FROM customers GROUP BY state ORDER BY count(*) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "1292": {
        "db_id": "game_injury",
        "question": "For each injury accident, find the date of the game and the name of the injured player in the game, and sort the results in descending order of game season.",
        "ground_truth": "SELECT T1.date ,  T2.player FROM game AS T1 JOIN injury_accident AS T2 ON T1.id  =  T2.game_id ORDER BY T1.season DESC",
        "amends": [
            "Do select `date` and `player` instead of `game_date` and `player_name`. Do use table aliases `T1` and `T2` instead of full table names. Do join `game AS T1` instead of `games` and `injury_accident AS T2` instead of `injuries`. Do remove the `players` table join instead of including it. Do use `ON T1.id = T2.game_id` instead of `ON injuries.game_id = games.game_id` and remove the player join condition. Do order by `T1.season DESC` instead of `game_season ASC`. The amended query now correctly joins only the necessary tables with proper column references and ordering direction."
        ],
        "rules": [
            "1) When answering about injury accidents: use table \"injury_accident\" as T2 and table \"game\" as T1. 2) When combining injury accidents with games: link rows where T1.id equals T2.game_id and keep only matching pairs (inner match). 3) When selecting date information: use column \"date\" from T1 instead of \"game_date\". 4) When selecting player information: use column \"player\" from T2 instead of \"player_name\". 5) When ordering by game season: use column \"season\" from T1 in descending order instead of ascending order. 6) When the question mentions \"injury accident\": this refers to table \"injury_accident\" (T2) and not a separate \"injuries\" table. 7) When the question mentions \"game\": this refers to table \"game\" (T1) and not a separate \"games\" table. 8) When handling player information: do not join a separate \"players\" table as player information is contained in T2.\"player\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT game_date, player_name \nFROM injuries \nJOIN games ON injuries.game_id = games.game_id \nJOIN players ON injuries.player_id = players.player_id \nORDER BY game_season ASC;",
            "SELECT T1.Date, T2.Player\nFROM game AS T1\nJOIN injury_accident AS T2 ON T1.id = T2.game_id\nORDER BY T1.Season DESC;"
        ],
        "rule_sql": [
            "SELECT T1.Date, T2.Player FROM game AS T1 INNER JOIN injury_accident AS T2 ON T1.id = T2.game_id ORDER BY T1.Season DESC;"
        ]
    },
    "6792": {
        "db_id": "activity_1",
        "question": "Tell me the first and last name of the student who has the most activities.",
        "ground_truth": "SELECT T1.fname ,  T1.lname FROM Student AS T1 JOIN Participates_in AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `fname` and `lname` instead of `first_name` and `last_name`. Do use `JOIN` on `T1.StuID = T2.StuID` instead of a correlated subquery with `activities.student_id = students.id`. Do add `GROUP BY T1.StuID` instead of omitting it. Do move the count aggregation to the main query's `ORDER BY count(*) DESC` instead of using a subquery in the ORDER BY clause. Do reference tables as `Student AS T1` and `Participates_in AS T2` instead of `students` and `activities`. The amended query now correctly groups by student ID and orders by participation count, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"first and last name\": use the exact column tokens \"fname\" and \"lname\" instead of \"first_name\" and \"last_name\". 2) When combining Student and Participates_in tables: link rows where T1.StuID = T2.StuID and keep only matching pairs (inner join). 3) When counting activities per student: group by T1.StuID and count the number of activities for each student. 4) When finding the student with the most activities: order the results by the activity count in descending order and keep only the top row. 5) When referencing tables: use the aliases Student AS T1 and Participates_in AS T2 as specified."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM students ORDER BY (SELECT COUNT(*) FROM activities WHERE activities.student_id = students.id) DESC LIMIT 1;",
            "SELECT T1.Fname, T1.LName\nFROM Student AS T1\nJOIN Participates_in AS T2 ON T1.StuID = T2.StuID\nGROUP BY T1.StuID\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Fname, T1.LName \nFROM Student AS T1 \nINNER JOIN Participates_in AS T2 ON T1.StuID = T2.StuID \nGROUP BY T1.StuID \nORDER BY COUNT(T2.actid) DESC \nLIMIT 1"
        ]
    },
    "2037": {
        "db_id": "gas_company",
        "question": "find the location and Representative name of the gas stations owned by the companies with top 3 Asset amounts.",
        "ground_truth": "SELECT T3.location ,  T3.Representative_Name FROM station_company AS T1 JOIN company AS T2 ON T1.company_id  =  T2.company_id JOIN gas_station AS T3 ON T1.station_id  =  T3.station_id ORDER BY T2.Assets_billion DESC LIMIT 3",
        "amends": [
            "Do join `station_company AS T1` with `company AS T2` on `T1.company_id = T2.company_id` and then join `gas_station AS T3` on `T1.station_id = T3.station_id` instead of querying `gas_stations` directly without any joins. Do select `T3.location` and `T3.Representative_Name` instead of `location` and `representative_name` from the wrong table. Do order by `T2.Assets_billion DESC` instead of `asset_amount DESC` to use the correct column from the joined company table. The amended query now correctly retrieves gas station locations and representative names ordered by company assets instead of station-level asset amounts, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about gas stations owned by companies: combine station_company as T1 with company as T2 where T1.company_id equals T2.company_id, then combine with gas_station as T3 where T1.station_id equals T3.station_id. 2) When selecting location and representative name: use T3.location and T3.Representative_Name from the gas_station table. 3) When ordering by company asset amounts: use T2.Assets_billion in descending order to find top companies. 4) When the question asks for top 3 companies by asset amount: keep only the first 3 rows after ordering by T2.Assets_billion DESC."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location, representative_name \nFROM gas_stations \nORDER BY asset_amount DESC \nLIMIT 3;",
            "SELECT T3.Location, T3.Representative_Name \nFROM station_company AS T1 \nJOIN company AS T2 ON T1.Company_ID = T2.Company_ID \nJOIN gas_station AS T3 ON T1.Station_ID = T3.Station_ID \nORDER BY T2.Assets_billion DESC \nLIMIT 3"
        ],
        "rule_sql": [
            "SELECT T3.Location, T3.Representative_Name\nFROM station_company AS T1\nJOIN company AS T2 ON T1.Company_ID = T2.Company_ID\nJOIN gas_station AS T3 ON T1.Station_ID = T3.Station_ID\nORDER BY T2.Assets_billion DESC\nLIMIT 3;"
        ]
    },
    "5693": {
        "db_id": "dorm_1",
        "question": "What are the names of all the dorms that don't have any amenities?",
        "ground_truth": "SELECT dorm_name FROM dorm WHERE dormid NOT IN (SELECT dormid FROM has_amenity)",
        "amends": [
            "Do select `dorm_name` from the `dorm` table instead of `d.name` from `dorms`. Do use a `NOT IN` subquery against `has_amenity` table instead of a `LEFT JOIN` with `amenities` table and `IS NOT NULL` filter. Do remove the join condition `d.id = a.dorm_id` and instead correlate through `dormid` in the subquery. Do change the filter logic to find dorms without amenities using `NOT IN` instead of finding dorms with amenities using `IS NOT NULL`. The amended query now correctly identifies dorms that lack amenities by checking absence from the has_amenity table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"names of all the dorms that don't have any amenities\": make sure the output order: dorm_name from the Dorm table. 2) When the question mentions \"dorms\": \"dorms\" actually means \"dorm_name in Dorm table\". 3) When checking for dorms without amenities: use a NOT IN subquery against the has_amenity table where dormid in the subquery matches dormid from the Dorm table. 4) When combining dorm information with amenity data: correlate through dormid between Dorm table and has_amenity table to find dorms that are absent from the has_amenity table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.name FROM dorms d LEFT JOIN amenities a ON d.id = a.dorm_id WHERE a.amenity_id IS NOT NULL;",
            "SELECT dorm_name FROM Dorm WHERE dormid NOT IN (SELECT dormid FROM Has_amenity)"
        ],
        "rule_sql": [
            "SELECT dorm_name FROM Dorm WHERE dormid NOT IN (SELECT dormid FROM Has_amenity) ORDER BY dorm_name;"
        ]
    },
    "6699": {
        "db_id": "driving_school",
        "question": "How many lessons have been cancelled?",
        "ground_truth": "SELECT count(*) FROM Lessons WHERE lesson_status_code = \"Cancelled\";",
        "amends": [
            "Do reference the `Lessons` table instead of `lessons` to match the correct table name. Do filter on `lesson_status_code = \"Cancelled\"` instead of `status = 'completed'` to query for cancelled rather than completed lessons. Do use double quotes around \"Cancelled\" instead of single quotes around 'completed' to match the correct string literal format. The amended query now correctly counts cancelled lessons from the Lessons table as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When answering about \"How many lessons have been cancelled\": make sure the output order: count of cancelled lessons. 2) When the question mentions \"cancelled\": \"cancelled\" actually means \"lesson_status_code = \\\"Cancelled\\\"\" in schema. 3) When counting lessons: compute the number of rows using the canonical table \"Lessons\" with the condition lesson_status_code = \\\"Cancelled\\\". 4) When handling text literals: do not change case, spacing, or punctuation - use exactly \\\"Cancelled\\\" with double quotes. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms - use \"Lessons\" exactly as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM lessons WHERE status = 'completed';",
            "SELECT COUNT(*) FROM Lessons WHERE lesson_status_code = \"Cancelled\""
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM \"Lessons\" WHERE \"lesson_status_code\" = \"Cancelled\""
        ]
    },
    "1202": {
        "db_id": "apartment_rentals",
        "question": "Show the addresses and phones of all the buildings managed by \"Brenden\".",
        "ground_truth": "SELECT building_address ,  building_phone FROM Apartment_Buildings WHERE building_manager\t =  \"Brenden\"",
        "amends": [
            "Do use column names `building_address` and `building_phone` instead of `address` and `phone`. Do reference table `Apartment_Buildings` instead of `buildings`. Do use filter condition `building_manager = \"Brenden\"` instead of `manager = 'Brenden'` with proper column name and quote style. The amended query now correctly references the actual schema elements and matches the intended behavior."
        ],
        "rules": [
            "1) When answering about \"addresses and phones of buildings managed by Brenden\": make sure the output order: building_address, building_phone. 2) When the question mentions \"addresses\": \"addresses\" actually means \"building_address in schema\". 3) When the question mentions \"phones\": \"phones\" actually means \"building_phone in schema\". 4) When the question mentions \"buildings\": \"buildings\" actually means \"Apartment_Buildings table in schema\". 5) When filtering for buildings managed by \"Brenden\": use exact literal \"Brenden\" with double quotes and column building_manager = \"Brenden\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT address, phone FROM buildings WHERE manager = 'Brenden';",
            "SELECT building_address, building_phone FROM Apartment_Buildings WHERE building_manager = 'Brenden';"
        ],
        "rule_sql": [
            "SELECT building_address, building_phone FROM Apartment_Buildings WHERE building_manager = \"Brenden\";"
        ]
    },
    "2644": {
        "db_id": "inn_1",
        "question": "Find the name of rooms booked by some customers whose first name contains ROY.",
        "ground_truth": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE firstname LIKE '%ROY%'",
        "amends": [
            "Do select `T2.roomName` instead of `r.name` and use table aliases `T1` and `T2` instead of `r`, `b`, and `c`. Do join `Reservations AS T1` to `Rooms AS T2` on `T1.Room = T2.RoomId` instead of joining `rooms r` to `bookings b` on `r.id = b.room_id` and then to `customers c` on `b.customer_id = c.id`. Do filter with `firstname LIKE '%ROY%'` instead of `c.first_name = 'ROY'` to allow partial matches rather than exact equality. Do remove the unnecessary join to the customers table and the explicit customer filtering condition, instead filtering directly on the reservation's firstname field. The amended query now correctly matches the RIGHT_SQL's behavior by selecting room names for reservations where the firstname contains 'ROY'."
        ],
        "rules": [
            "1) When selecting room names from the schema: use the exact column token \"T2.roomName\" instead of \"r.name\". 2) When joining tables for room bookings: link \"Reservations AS T1\" to \"Rooms AS T2\" using the exact key equality \"T1.Room = T2.RoomId\". 3) When filtering for customers whose first name contains ROY: use the condition \"firstname LIKE '%ROY%'\" to allow partial matches instead of exact equality. 4) When the question asks about rooms booked by customers: filter directly on the reservation's firstname field instead of joining to a separate customers table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.name FROM rooms r JOIN bookings b ON r.id = b.room_id JOIN customers c ON b.customer_id = c.id WHERE c.first_name = 'ROY';",
            "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room = T2.RoomId WHERE T1.FirstName LIKE '%ROY%'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room = T2.RoomId WHERE T1.FirstName LIKE '%ROY%'"
        ]
    },
    "4823": {
        "db_id": "aircraft",
        "question": "List the name of the aircraft that has been named winning aircraft the most number of times.",
        "ground_truth": "SELECT T1.Aircraft FROM aircraft AS T1 JOIN MATCH AS T2 ON T1.Aircraft_ID  =  T2.Winning_Aircraft GROUP BY T2.Winning_Aircraft ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.Aircraft` instead of `aircraft_name` and use `COUNT(*)` without an alias instead of aliasing as `win_count`. Do join `aircraft AS T1` with `MATCH AS T2` on `T1.Aircraft_ID = T2.Winning_Aircraft` instead of querying `winning_aircrafts` directly without joins. Do group by `T2.Winning_Aircraft` instead of `aircraft_name` to properly count wins per aircraft. Do order by `COUNT(*) DESC` instead of `win_count DESC` since the alias was removed. The amended query now correctly counts match wins by joining aircraft and match tables instead of using a potentially incorrect summary table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"winning aircraft the most number of times\": make sure the output order: T1.Aircraft, COUNT(*) 2) When the question mentions \"aircraft name\": \"aircraft name\" actually means \"T1.Aircraft in schema\" 3) When combining aircraft AS T1 and MATCH AS T2 for shared entities: link rows where T1.Aircraft_ID = T2.Winning_Aircraft exactly as shown in the amends; keep only matching pairs (inner match) 4) When the question asks for \"count of winning aircraft\": compute the number of rows using the grouping key T2.Winning_Aircraft 5) When the question asks for \"most number of times\": rank rows by COUNT(*) in descending direction and keep the first 1 row"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT aircraft_name, COUNT(*) as win_count \nFROM winning_aircrafts \nGROUP BY aircraft_name \nORDER BY win_count DESC \nLIMIT 1;",
            "SELECT T1.Aircraft\nFROM aircraft AS T1\nJOIN match AS T2 ON T1.Aircraft_ID = T2.Winning_Aircraft\nGROUP BY T2.Winning_Aircraft\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Aircraft, COUNT(*) \nFROM aircraft AS T1 \nINNER JOIN match AS T2 ON T1.Aircraft_ID = T2.Winning_Aircraft \nGROUP BY T2.Winning_Aircraft \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ]
    },
    "2444": {
        "db_id": "movie_1",
        "question": "What is the id of the reviewer whose name has substring \u201cMike\u201d?",
        "ground_truth": "SELECT rID FROM Reviewer WHERE name LIKE \"%Mike%\"",
        "amends": [
            "Do use column alias `rID` instead of `id` in the SELECT list. Do use table name `Reviewer` instead of `reviewers` in the FROM clause. Do use double quotes for the string pattern instead of single quotes around \"%Mike%\" instead of '%Mike%'. The amended query now correctly references the intended column and table with proper string quoting to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"id\" of a reviewer: use the exact column name \"rID\" instead of \"id\" in the output. 2) When referencing the reviewers table: use the exact table name \"Reviewer\" instead of \"reviewers\". 3) When using string patterns with LIKE operator: wrap the pattern in double quotes exactly as \"%Mike%\" instead of single quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM reviewers WHERE name LIKE '%Mike%';",
            "SELECT rID FROM Reviewer WHERE name LIKE \"%Mike%\""
        ],
        "rule_sql": [
            "SELECT rID FROM Reviewer WHERE name LIKE \"%Mike%\";"
        ]
    },
    "2638": {
        "db_id": "inn_1",
        "question": "Return the name and number of reservations made for each of the rooms.",
        "ground_truth": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room",
        "amends": [
            "Do select `T2.roomName` and `T1.Room` instead of `room_name` and omitting the room identifier. Do join `Rooms AS T2` on `T1.Room = T2.RoomId` instead of missing the table join entirely. Do group by `T1.Room` instead of `room_id` which was not properly referenced. The amended query now correctly joins the Reservations and Rooms tables to retrieve the room name while properly grouping by the room identifier from the Reservations table, matching the intended behavior.",
            "Do include `T2.roomName` in the SELECT list instead of omitting it, and do include `T1.Room` in the SELECT list instead of omitting it, but do remove the alias `reservation_count` from the COUNT(*) expression instead of keeping it. The amended query now matches RIGHT_SQL's behavior.",
            "Do include `T1.Room` in the SELECT list instead of omitting it, and do reorder the columns to place `T2.roomName` first followed by the count and then `T1.Room` instead of the original column sequence. The amended query now correctly includes all necessary columns in the SELECT list while maintaining the same grouping logic and join conditions, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"name and number of reservations for each room\": make sure the output order: T2.roomName first, then count of reservations. 2) When the question mentions \"name\": \"name\" actually means \"T2.roomName\" in schema. 3) When the question asks for \"number of reservations\": compute the count using the canonical key from T1 (reservation identifier). 4) When combining Reservations as T1 and Rooms as T2: link rows where T1.Room = T2.RoomId exactly as shown; keep only matching pairs (inner match). 5) When the question says \"for each of the rooms\": organize results by T1.Room and compute the count per room group.",
            "1) When answering about \"name and number of reservations made for each of the rooms\": make sure the output order: T2.roomName, T1.Room, COUNT(*) 2) When the question asks for \"number of reservations made for each room\": compute the count of reservations using the canonical key from Reservations table 3) When combining Reservations (T1) and Rooms (T2) for shared room entities: link rows where T1.Room = T2.RoomId and keep only matching pairs (inner match) 4) When grouping results by room: organize results by both T2.roomName and T1.Room to ensure proper grouping and counting 5) When producing output columns: do not add aliases to aggregate functions like COUNT(*)",
            "1) When answering about \"name and number of reservations made for each of the rooms\": make sure the output order: T2.roomName first, then the count, then T1.Room. 2) When the question asks for \"number of reservations made for each room\": compute the count using the canonical key for reservations (T1.Room) per room group. 3) When combining Reservations (T1) and Rooms (T2) for shared entities: link rows where T1.Room = T2.RoomId and keep only matching pairs (inner match). 4) When the question says \"for each of the rooms\": organize results by T1.Room and compute the count per room group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT room_name, COUNT(*) FROM reservations GROUP BY room_id;",
            "SELECT T2.roomName, T1.Room, COUNT(*) AS reservation_count\nFROM Reservations AS T1\nJOIN Rooms AS T2 ON T1.Room = T2.RoomId\nGROUP BY T1.Room;",
            "SELECT T2.roomName, T1.Room, COUNT(*) \nFROM Reservations AS T1 \nJOIN Rooms AS T2 ON T1.Room = T2.RoomId \nGROUP BY T1.Room",
            "SELECT T2.roomName, COUNT(*) AS reservation_count, T1.Room\nFROM Reservations AS T1\nJOIN Rooms AS T2 ON T1.Room = T2.RoomId\nGROUP BY T1.Room\nORDER BY T2.roomName;"
        ],
        "rule_sql": [
            "SELECT T2.roomName, COUNT(*), T1.Room FROM Reservations T1 INNER JOIN Rooms T2 ON T1.Room = T2.RoomId GROUP BY T1.Room, T2.roomName ORDER BY T2.roomName, COUNT(*), T1.Room"
        ]
    },
    "57": {
        "db_id": "student_assessment",
        "question": "What is the name of the course with the most registered students?",
        "ground_truth": "SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `T1.` alias prefix to `course_name` instead of using the bare column name. Do add `JOIN student_course_registrations AS T2` with `ON T1.course_id = T2.course_Id` instead of querying only the `courses` table. Do add `GROUP BY T1.course_id` instead of omitting grouping. Do change `ORDER BY count(*) DESC` instead of `ORDER BY student_count ASC` to order by registration count rather than student count. Do keep `LIMIT 1` but now it returns the course with the highest registration count instead of the lowest student count. The amended query now correctly identifies the most popular course by registration count rather than relying on a potentially incorrect student_count field."
        ],
        "rules": [
            "1) When answering about \"course with the most registered students\": make sure the output order: T1.course_name. 2) When the question mentions \"most registered students\": \"registered students\" actually means \"count of registrations in student_course_registrations table\". 3) When combining T1 (courses) and T2 (student_course_registrations) for shared entities: link rows where T1.course_id = T2.course_Id exactly as shown; keep only matching pairs (inner match). 4) When the question asks for \"count of registrations\": compute the number of rows using the canonical key from T2 (student_course_registrations). 5) When the question asks for \"course with the most\": rank rows by count(*) in descending direction and keep the first 1 row. 6) When grouping by course: organize results by T1.course_id and compute count(*) per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_name FROM courses ORDER BY student_count ASC LIMIT 1;",
            "SELECT T1.course_name\nFROM Courses AS T1\nJOIN Student_Course_Registrations AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.course_name\nFROM Courses T1\nINNER JOIN Student_Course_Registrations T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "1696": {
        "db_id": "epinions_1",
        "question": "How many different items were reviewed by some users?",
        "ground_truth": "SELECT count(DISTINCT i_id) FROM review",
        "amends": [
            "Do use `count(DISTINCT i_id)` instead of `COUNT(*)` to count distinct review identifiers rather than all rows. Do reference the correct table name `review` instead of `reviews` to ensure proper data source access. The amended query now correctly counts unique review items instead of total rows, matching the intended behavior."
        ],
        "rules": [
            "1) When counting different items reviewed by users: use count(DISTINCT i_id) instead of COUNT(*) to count distinct review identifiers. 2) When referencing the review data: use the exact table name \"review\" instead of \"reviews\" to ensure proper data source access."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM reviews;",
            "SELECT COUNT(DISTINCT i_id) FROM review;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT i_id) FROM review;"
        ]
    },
    "979": {
        "db_id": "university_basketball",
        "question": "List all public schools and their locations.",
        "ground_truth": "SELECT school ,  LOCATION FROM university WHERE affiliation  =  'Public'",
        "amends": [
            "Do select `school` and `LOCATION` instead of `school_name` and `city`. Do query from `university` instead of `schools`. Do filter on `affiliation = 'Public'` instead of `type = 'private'`. The amended query now correctly retrieves public universities with their names and locations."
        ],
        "rules": [
            "1) When answering about \"public schools and their locations\": make sure the output order: school, LOCATION\n2) When the question mentions \"public schools\": \"public\" actually means \"affiliation = 'Public'\" in schema\n3) When the question mentions \"schools\": \"schools\" actually means \"university\" in schema\n4) When the question mentions \"school name\": \"school name\" actually means \"school\" in schema\n5) When the question mentions \"location\": \"location\" actually means \"LOCATION\" in schema"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT school_name, city FROM schools WHERE type = 'private';",
            "SELECT School, Location FROM university WHERE Affiliation = 'Public';"
        ],
        "rule_sql": [
            "SELECT School, LOCATION FROM university WHERE Affiliation = 'Public' ORDER BY School, LOCATION;"
        ]
    },
    "6915": {
        "db_id": "tracking_orders",
        "question": "What is the placement date of the order whose invoice number is 10?",
        "ground_truth": "SELECT T1.date_order_placed FROM orders AS T1 JOIN shipments AS T2 ON T1.order_id = T2.order_id WHERE T2.invoice_number = 10",
        "amends": [
            "Do add `shipments AS T2` as a joined table instead of querying only the `orders` table. Do use `JOIN` with `T1.order_id = T2.order_id` instead of no join condition. Do select `T1.date_order_placed` instead of `order_date`. Do move the filter to `T2.invoice_number = 10` instead of applying it to `orders.invoice_number`. The amended query now correctly retrieves order dates by joining orders with shipments and filtering on the shipment invoice number, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"placement date of the order whose invoice number is 10\": make sure the output order: T1.date_order_placed. 2) When the question mentions \"invoice number is 10\": \"invoice number\" actually means \"T2.invoice_number = 10\" in schema. 3) When combining orders and shipments tables: link rows where T1.order_id = T2.order_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question mentions \"order\": use the orders table as T1 and shipments table as T2 as specified in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT order_date FROM orders WHERE invoice_number = 10;",
            "SELECT T1.date_order_placed \nFROM Orders AS T1 \nJOIN Shipments AS T2 ON T1.order_id = T2.order_id \nWHERE T2.invoice_number = 10"
        ],
        "rule_sql": [
            "SELECT T1.date_order_placed \nFROM Orders AS T1\nINNER JOIN Shipments AS T2 ON T1.order_id = T2.order_id\nWHERE T2.invoice_number = 10"
        ]
    },
    "2262": {
        "db_id": "machine_repair",
        "question": "What are the starting years shared by the technicians from the team \"CLE\" or \"CWS\"?",
        "ground_truth": "SELECT Starting_Year FROM technician WHERE Team  =  \"CLE\" INTERSECT SELECT Starting_Year FROM technician WHERE Team  =  \"CWS\"",
        "amends": [
            "Do use `INTERSECT` to find common starting years instead of incorrectly using `AND` with conflicting team conditions. Do reference the correct table name `technician` instead of `technicians`. Do use proper column names `Starting_Year` and `Team` with correct capitalization instead of lowercase versions. Do use double quotes for string literals `\"CLE\"` and `\"CWS\"` instead of single quotes. Do remove the logically impossible `AND` condition that required a team to be both 'CLE' and 'CWS' simultaneously, replacing it with separate queries for each team value combined with `INTERSECT` to find years where technicians played for both teams. The amended query now correctly identifies starting years common to both Cleveland and Chicago White Sox teams."
        ],
        "rules": [
            "1) When the question asks for starting years shared by technicians from multiple teams: use INTERSECT to find common values instead of AND with conflicting conditions. 2) When referring to the technicians table: use the exact table name \"technician\" instead of \"technicians\". 3) When selecting starting years: use the exact column name \"Starting_Year\" with proper capitalization. 4) When filtering by team values: use the exact column name \"Team\" with proper capitalization and double quotes for string literals \"CLE\" and \"CWS\". 5) When combining results for multiple teams: create separate queries for each team value (\"CLE\" and \"CWS\") and intersect them to find common starting years."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT starting_year FROM technicians WHERE team = 'CLE' AND team = 'CWS';",
            "SELECT Starting_Year FROM technician WHERE Team = \"CLE\" INTERSECT SELECT Starting_Year FROM technician WHERE Team = \"CWS\""
        ],
        "rule_sql": [
            "SELECT \"Starting_Year\" FROM \"technician\" WHERE \"Team\" = \"CLE\"\nINTERSECT\nSELECT \"Starting_Year\" FROM \"technician\" WHERE \"Team\" = \"CWS\""
        ]
    },
    "1255": {
        "db_id": "apartment_rentals",
        "question": "Return each apartment type code with the number of apartments having that apartment type, in ascending order of the number of apartments.",
        "ground_truth": "SELECT apt_type_code ,  COUNT(*) FROM Apartments GROUP BY apt_type_code ORDER BY COUNT(*) ASC",
        "amends": [
            "Do use column name `apt_type_code` instead of `apartment_type_code` and remove the alias `apartment_count` instead of keeping it. Do reference table `Apartments` instead of `apartments` to match the correct case. Do order by `COUNT(*)` directly instead of using the alias `apartment_count` in the ORDER BY clause. The amended query now correctly counts apartments by type code and orders by the count in ascending order, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"apartment type code\": use the exact column name \"apt_type_code\" from table \"Apartments\". 2) When counting apartments: count all rows using COUNT(*) without creating an alias for the count. 3) When ordering by the number of apartments: order directly by COUNT(*) in ascending order instead of using an alias. 4) When grouping by apartment type: group by the exact column \"apt_type_code\". 5) When referencing the table: use the exact table name \"Apartments\" with proper case."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT apartment_type_code, COUNT(*) as apartment_count FROM apartments GROUP BY apartment_type_code ORDER BY apartment_count ASC;",
            "SELECT apt_type_code, COUNT(*) FROM Apartments GROUP BY apt_type_code ORDER BY COUNT(*) ASC;"
        ],
        "rule_sql": [
            "SELECT apt_type_code, COUNT(*) FROM Apartments GROUP BY apt_type_code ORDER BY COUNT(*) ASC;"
        ]
    },
    "86": {
        "db_id": "student_assessment",
        "question": "What are the cell phone numbers of the candidates that received an assessment code of \"Fail\"?",
        "ground_truth": "SELECT T3.cell_mobile_number FROM candidates AS T1 JOIN candidate_assessments AS T2 ON T1.candidate_id = T2.candidate_id JOIN people AS T3 ON T1.candidate_id = T3.person_id WHERE T2.asessment_outcome_code = \"Fail\"",
        "amends": [
            "Do select `T3.cell_mobile_number` instead of `phone_number`. Do add joins to `candidate_assessments AS T2` and `people AS T3` instead of querying only the `candidates` table. Do use `LEFT JOIN` on `T1.candidate_id = T2.candidate_id` and `LEFT JOIN` on `T1.candidate_id = T3.person_id` instead of no joins. Do filter on `T2.asessment_outcome_code = \"Fail\"` instead of `assessment_code = 'Pass'`. The amended query now correctly retrieves mobile numbers from the people table for candidates with failed assessments rather than using a direct phone field with incorrect filter logic."
        ],
        "rules": [
            "1) When answering about \"cell phone numbers of candidates\": make sure the output column is T3.cell_mobile_number instead of phone_number. 2) When the question mentions \"candidates that received an assessment code\": join candidate_assessments AS T2 using LEFT JOIN on T1.candidate_id = T2.candidate_id. 3) When retrieving phone numbers: join people AS T3 using LEFT JOIN on T1.candidate_id = T3.person_id. 4) When filtering for assessment outcome: use T2.asessment_outcome_code = \"Fail\" instead of assessment_code = 'Pass'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT phone_number FROM candidates WHERE assessment_code = 'Pass';",
            "SELECT T3.cell_mobile_number\nFROM Candidates AS T1\nLEFT JOIN Candidate_Assessments AS T2 ON T1.candidate_id = T2.candidate_id\nLEFT JOIN People AS T3 ON T1.candidate_id = T3.person_id\nWHERE T2.asessment_outcome_code = 'Fail'"
        ],
        "rule_sql": [
            "SELECT T3.cell_mobile_number\nFROM Candidates AS T1\nLEFT JOIN Candidate_Assessments AS T2 ON T1.candidate_id = T2.candidate_id\nLEFT JOIN People AS T3 ON T1.candidate_id = T3.person_id\nWHERE T2.asessment_outcome_code = 'Fail'"
        ]
    },
    "1679": {
        "db_id": "theme_gallery",
        "question": "What is the theme, date, and attendance for the exhibition in year 2004?",
        "ground_truth": "SELECT T2.theme ,  T1.date ,  T1.attendance FROM exhibition_record AS T1 JOIN exhibition AS T2 ON T1.exhibition_id  =  T2.exhibition_id WHERE T2.year  =  2004",
        "amends": [
            "Do specify table aliases `T2.theme`, `T1.date`, and `T1.attendance` instead of unqualified column names. Do join `exhibition_record AS T1` and `exhibition AS T2` with `ON T1.exhibition_id = T2.exhibition_id` instead of querying a single table. Do filter on `T2.year = 2004` instead of `year = 2004` to reference the correct table. The amended query now correctly joins related tables and matches the intended behavior."
        ],
        "rules": [
            "1) When answering about exhibition theme, date, and attendance: make sure the output order: T2.theme, T1.date, T1.attendance 2) When combining exhibition_record (T1) and exhibition (T2) tables: link rows where T1.exhibition_id = T2.exhibition_id and keep only matching pairs (inner match) 3) When filtering for exhibitions in year 2004: use T2.year = 2004 to reference the correct table column 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms 5) When handling text literals: do not change case, spacing, or punctuation for the year value 2004"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT theme, date, attendance FROM exhibitions WHERE year = 2004;",
            "SELECT T2.Theme, T1.Date, T1.Attendance\nFROM exhibition_record AS T1\nJOIN exhibition AS T2 ON T1.Exhibition_ID = T2.Exhibition_ID\nWHERE T2.Year = 2004"
        ],
        "rule_sql": [
            "SELECT T2.\"Theme\", T1.\"Date\", T1.\"Attendance\" FROM \"exhibition_record\" T1 INNER JOIN \"exhibition\" T2 ON T1.\"Exhibition_ID\" = T2.\"Exhibition_ID\" WHERE T2.\"Year\" = 2004"
        ]
    },
    "444": {
        "db_id": "allergy_1",
        "question": "What are the different allergy types?",
        "ground_truth": "SELECT DISTINCT allergytype FROM Allergy_type",
        "amends": [
            "Do select only `allergytype` instead of all columns with `*`. Do add `DISTINCT` instead of omitting it to return unique values. Do reference the correct table `Allergy_type` instead of `allergies`. The amended query now correctly returns distinct allergy types from the appropriate table."
        ],
        "rules": [
            "1) When answering about \"different allergy types\": make sure the output order: \"allergytype\". 2) When the question asks for \"different\" types: return only unique values of \"allergytype\" using DISTINCT. 3) When referencing the allergy types table: use the exact table name \"Allergy_type\" instead of \"allergies\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM allergies;",
            "SELECT DISTINCT AllergyType FROM Allergy_Type;"
        ],
        "rule_sql": [
            "SELECT DISTINCT AllergyType FROM Allergy_Type ORDER BY AllergyType;"
        ]
    },
    "3236": {
        "db_id": "college_1",
        "question": "What is the number of different class sections offered in the course ACCT-211?",
        "ground_truth": "SELECT count(DISTINCT class_section) FROM CLASS WHERE crs_code  =  'ACCT-211'",
        "amends": [
            "Do select `count(DISTINCT class_section)` instead of `COUNT(*)` to count distinct class sections rather than all rows. Do query from `CLASS` table instead of `sections` table to access the correct data source. Do filter on `crs_code = 'ACCT-211'` instead of `course_id = 'ACCT-211'` to use the proper column name for course identification. The amended query now correctly counts distinct class sections for the specified course code as intended."
        ],
        "rules": [
            "1) When counting different class sections: count distinct values of \"class_section\" instead of counting all rows. 2) When querying about course sections: use the \"CLASS\" table instead of \"sections\" table to access the correct data source. 3) When filtering by course code: use \"crs_code = 'ACCT-211'\" instead of \"course_id = 'ACCT-211'\" to use the proper column name for course identification."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM sections WHERE course_id = 'ACCT-211';",
            "SELECT COUNT(DISTINCT CLASS_SECTION) FROM CLASS WHERE CRS_CODE = 'ACCT-211'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT CLASS_SECTION) FROM CLASS WHERE CRS_CODE = 'ACCT-211'"
        ]
    },
    "463": {
        "db_id": "allergy_1",
        "question": "How many different advisors are listed?",
        "ground_truth": "SELECT count(DISTINCT advisor) FROM Student",
        "amends": [
            "Do use `count(DISTINCT advisor)` instead of `COUNT(*)` to count unique advisors rather than all rows. Do query from `Student` table instead of `advisors` table to access the correct data source. The amended query now correctly counts distinct advisor values from the Student table rather than counting all rows from an incorrect table."
        ],
        "rules": [
            "1) When counting different advisors: use count(DISTINCT advisor) instead of COUNT(*) to count unique advisor values rather than all rows. 2) When accessing advisor data: query from the Student table instead of the advisors table to use the correct data source."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM advisors;",
            "SELECT COUNT(DISTINCT Advisor) FROM Student;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Advisor) FROM Student;"
        ]
    },
    "1192": {
        "db_id": "election_representative",
        "question": "Show the parties that have both representatives in New York state and representatives in Pennsylvania state.",
        "ground_truth": "SELECT Party FROM representative WHERE State  =  \"New York\" INTERSECT SELECT Party FROM representative WHERE State  =  \"Pennsylvania\"",
        "amends": [
            "Do use `INTERSECT` to find common parties instead of `GROUP BY` with `OR` conditions. Do query the `representative` table instead of `representatives`. Do use double quotes around state names instead of single quotes. Do capitalize `Party` and `State` column names instead of lowercase. Do remove the `GROUP BY` clause instead of keeping it. Do use two separate `SELECT` statements with `INTERSECT` instead of a single query with `OR` conditions. The amended query now correctly finds parties that have representatives in both New York and Pennsylvania states, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for parties that have representatives in both New York and Pennsylvania states: use INTERSECT to find common parties instead of GROUP BY with OR conditions. 2) When querying the representative table: use the exact table name \"representative\" instead of \"representatives\". 3) When filtering by state values: use double quotes around \"New York\" and \"Pennsylvania\" instead of single quotes. 4) When selecting columns: use the exact column names \"Party\" and \"State\" with proper capitalization instead of lowercase. 5) When combining results from multiple conditions: use two separate SELECT statements with INTERSECT instead of a single query with OR conditions. 6) When finding common entities across different conditions: remove GROUP BY clauses and use set operations like INTERSECT."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT party FROM representatives WHERE state = 'New York' OR state = 'Pennsylvania' GROUP BY party;",
            "SELECT Party FROM representative WHERE State = \"New York\" INTERSECT SELECT Party FROM representative WHERE State = \"Pennsylvania\""
        ],
        "rule_sql": [
            "SELECT Party FROM representative WHERE State = \"New York\" INTERSECT SELECT Party FROM representative WHERE State = \"Pennsylvania\""
        ]
    },
    "131": {
        "db_id": "bike_1",
        "question": "Return the unique name for stations that have ever had 7 bikes available.",
        "ground_truth": "SELECT DISTINCT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  =  7",
        "amends": [
            "Do add `T1.` prefix to `name` instead of using unqualified `name`. Do change the FROM clause to use `station AS T1 JOIN status AS T2` instead of just `stations`. Do add the join condition `ON T1.id = T2.station_id` instead of omitting any join. Do change the WHERE filter to reference `T2.bikes_available = 7` instead of `bikes_available = 7` to correctly filter on the status table rather than the station table. The amended query now correctly joins the station and status tables and filters on the appropriate bikes_available column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"stations that have ever had 7 bikes available\": make sure the output order: T1.name. 2) When the question mentions \"stations\": use table \"station AS T1\" as the base table. 3) When the question mentions \"bikes available\": \"bikes_available\" actually means \"T2.bikes_available\" in the status table. 4) When combining T1 and T2 for shared entities: link rows where T1.id = T2.station_id exactly as shown in the amends; keep only matching pairs (inner match). 5) When filtering for stations with 7 bikes available: use the condition T2.bikes_available = 7. 6) When the question asks for \"unique name\": compute the distinct values of T1.name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT name FROM stations WHERE bikes_available = 7;",
            "SELECT DISTINCT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id = T2.station_id WHERE T2.bikes_available = 7"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.name\nFROM station AS T1\nINNER JOIN status AS T2 ON T1.id = T2.station_id\nWHERE T2.bikes_available = 7\nORDER BY T1.name;"
        ]
    },
    "3322": {
        "db_id": "college_1",
        "question": "What are the first names of all Accounting professors who teach and what are the classrooms of the courses they teach?",
        "ground_truth": "SELECT T2.emp_fname ,  T1.class_room FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Accounting'",
        "amends": [
            "Do select `emp_fname` and `class_room` instead of `first_name` and `classroom`. Do join `CLASS` as `T1` instead of `courses` as `c`. Do join `employee` as `T2` on `T1.prof_num = T2.emp_num` instead of joining `professors` as `p` on `p.professor_id = c.professor_id`. Do add joins to `professor` as `T3` on `T2.emp_num = T3.emp_num` and `department` as `T4` on `T4.dept_code = T3.dept_code` instead of omitting these tables. Do filter on `T4.dept_name = 'Accounting'` instead of `p.department = 'Accounting'`. The amended query now correctly navigates the relationship hierarchy through employee to professor to department to filter accounting classes."
        ],
        "rules": [
            "1) When the question asks for \"first names\": use the exact column token \"emp_fname\" from the employee table (T2) instead of \"first_name\". 2) When the question asks for \"classrooms\": use the exact column token \"class_room\" from the CLASS table (T1) instead of \"classroom\". 3) When combining tables for professors who teach: link CLASS (T1) and employee (T2) where T1.prof_num = T2.emp_num. 4) When identifying professors: join professor table (T3) on T2.emp_num = T3.emp_num to access professor information. 5) When filtering by department: join department table (T4) on T4.dept_code = T3.dept_code and filter where T4.dept_name = 'Accounting' (exact literal). 6) When answering about accounting professors who teach: make sure the output order is emp_fname followed by class_room."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.first_name, c.classroom\nFROM professors p\nJOIN courses c ON p.professor_id = c.professor_id\nWHERE p.department = 'Accounting'",
            "SELECT T2.EMP_FNAME, T1.CLASS_ROOM\nFROM CLASS T1\nJOIN EMPLOYEE T2 ON T1.PROF_NUM = T2.EMP_NUM\nJOIN PROFESSOR T3 ON T2.EMP_NUM = T3.EMP_NUM\nJOIN DEPARTMENT T4 ON T3.DEPT_CODE = T4.DEPT_CODE\nWHERE T4.DEPT_NAME = 'Accounting';"
        ],
        "rule_sql": [
            "SELECT e.emp_fname, c.class_room\nFROM CLASS c\nJOIN EMPLOYEE e ON c.prof_num = e.emp_num\nJOIN PROFESSOR p ON e.emp_num = p.emp_num\nJOIN DEPARTMENT d ON p.dept_code = d.dept_code\nWHERE d.dept_name = 'Accounting'\nORDER BY e.emp_fname, c.class_room;"
        ]
    },
    "2116": {
        "db_id": "cre_Doc_Control_Systems",
        "question": "How many documents were shipped by USPS?",
        "ground_truth": "SELECT count(*) FROM Ref_Shipping_Agents JOIN Documents ON Documents.shipping_agent_code = Ref_Shipping_Agents.shipping_agent_code WHERE Ref_Shipping_Agents.shipping_agent_name = \"USPS\";",
        "amends": [
            "Do join `Ref_Shipping_Agents` instead of querying only `documents`. Do filter on `shipping_agent_name = \"USPS\"` instead of `shipping_method = 'UPS'`. Do use the join condition `Documents.shipping_agent_code = Ref_Shipping_Agents.shipping_agent_code` instead of no join condition. The amended query now correctly counts documents shipped via USPS by joining to the reference table and filtering on the agent name rather than relying on a potentially incorrect shipping method field."
        ],
        "rules": [
            "1) When answering about \"documents shipped by USPS\": join Documents table (T1) with Ref_Shipping_Agents table (T2) using the condition T1.shipping_agent_code = T2.shipping_agent_code. 2) When filtering for USPS shipments: use T2.shipping_agent_name = \"USPS\" instead of shipping_method field. 3) When counting documents: count the number of rows using the canonical key from Documents table after applying the join and filter conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM documents WHERE shipping_method = 'UPS';",
            "SELECT COUNT(*) \nFROM Documents d\nJOIN Ref_Shipping_Agents rsa ON d.shipping_agent_code = rsa.shipping_agent_code\nWHERE rsa.shipping_agent_name = 'USPS'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Documents d\nJOIN Ref_Shipping_Agents rsa ON d.shipping_agent_code = rsa.shipping_agent_code\nWHERE rsa.shipping_agent_name = 'USPS'"
        ]
    },
    "5365": {
        "db_id": "tracking_software_problems",
        "question": "How many problems did the product called \"voluptatem\" have in record?",
        "ground_truth": "SELECT count(*) FROM product AS T1 JOIN problems AS T2 ON T1.product_id = T2.product_id WHERE T1.product_name = \"voluptatem\"",
        "amends": [
            "Do add `JOIN product AS T1` instead of omitting the product table entirely. Do change the join condition to `ON T1.product_id = T2.product_id` instead of filtering directly on problems table. Do move the `product_name` filter to the joined product table instead of applying it directly to the problems table. Do maintain the `COUNT(*)` aggregate function but now counting from the properly joined dataset instead of the incomplete source. The amended query now correctly counts problems associated with the specified product name by properly joining the tables through their relationship."
        ],
        "rules": [
            "1) When answering about \"problems for product called 'voluptatem'\": make sure to join the product table (T1) with the problems table using T1.product_id = T2.product_id to establish the relationship between products and their problems. 2) When the question mentions \"product called 'voluptatem'\": filter on T1.product_name = 'voluptatem' exactly as specified, including the exact case and quotes. 3) When counting problems: use COUNT(*) to count all problem records associated with the specified product after the proper join is established."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM problems WHERE product_name = 'voluptatem';",
            "SELECT COUNT(*) \nFROM Problems AS T2\nJOIN Product AS T1 ON T1.product_id = T2.product_id\nWHERE T1.product_name = 'voluptatem'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Product p\nJOIN Problems pr ON p.product_id = pr.product_id\nWHERE p.product_name = 'voluptatem';"
        ]
    },
    "5789": {
        "db_id": "customer_complaints",
        "question": "What is the name and category code of the product with the highest price?",
        "ground_truth": "SELECT product_name ,  product_category_code FROM products ORDER BY product_price DESC LIMIT 1",
        "amends": [
            "Do select `product_name` and `product_category_code` instead of `name` and `category_code`. Do order by `product_price DESC` instead of `price ASC`. The amended query now correctly retrieves the highest-priced product's details with accurate column names and descending price ordering."
        ],
        "rules": [
            "1) When the question asks for \"name\" of a product: use the exact column token \"product_name\" from the Products table. 2) When the question asks for \"category code\" of a product: use the exact column token \"product_category_code\" from the Products table. 3) When the question asks for the product with the \"highest price\": order by \"product_price\" in descending order (DESC) and take the first row. 4) When selecting output columns: present them in the order \"product_name\" followed by \"product_category_code\" as implied by the question structure."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, category_code FROM products ORDER BY price ASC LIMIT 1;",
            "SELECT product_name, product_category_code FROM Products ORDER BY product_price DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT product_name, product_category_code FROM Products ORDER BY product_price DESC LIMIT 1;"
        ]
    },
    "4110": {
        "db_id": "company_employee",
        "question": "List the names of people that are not employed by any company",
        "ground_truth": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM employment)",
        "amends": [
            "Do select `Name` instead of `name` to match the correct column case. Do change the WHERE filter to use `People_ID NOT IN` with a subquery checking the employment table instead of filtering on `company_id IS NOT NULL`. Do add a correlated subquery `(SELECT People_ID FROM employment)` instead of omitting it, which properly identifies people without employment records rather than relying on a potentially incorrect NULL check. The amended query now correctly matches the RIGHT_SQL's behavior of finding people not present in the employment table."
        ],
        "rules": [
            "1) When selecting names from the people table: use the exact column name \"Name\" instead of \"name\" to match the correct case. 2) When finding people not employed by any company: use People_ID NOT IN (SELECT People_ID FROM employment) instead of checking company_id IS NOT NULL, as this properly identifies people without employment records. 3) When combining data from multiple tables: use the exact identifier People_ID as the linking key between tables."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM people WHERE company_id IS NOT NULL;",
            "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM employment)"
        ],
        "rule_sql": [
            "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM employment)"
        ]
    },
    "5741": {
        "db_id": "dorm_1",
        "question": "How many students are older than 20 in each dorm?",
        "ground_truth": "SELECT count(*) ,  T3.dorm_name FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T1.age  >  20 GROUP BY T3.dorm_name",
        "amends": [
            "Do use explicit table aliases `T1`, `T2`, and `T3` instead of implicit table references. Do join three tables `student`, `lives_in`, and `dorm` instead of querying only the `students` table. Do specify join conditions `T1.stuid = T2.stuid` and `T3.dormid = T2.dormid` instead of missing the necessary relationships. Do select `T3.dorm_name` instead of just `dorm` to get the proper dormitory name. Do use the correct table name `student` instead of `students`. Do qualify the column reference as `T1.age` instead of just `age` for clarity. The amended query now correctly counts students over age 20 grouped by dormitory name through proper table relationships.",
            "Do place `count(*)` before `T3.dorm_name` in the SELECT list instead of listing `T3.dorm_name` first. Do use lowercase `stuid` and `age` column references instead of uppercase `StuID` and `Age`. Do reverse the join condition to `T3.dormid = T2.dormid` instead of `T2.dormid = T3.dormid` for consistency with the right SQL's join direction. Do remove the alias `AS student_count` from the count aggregation instead of keeping it. The amended query now correctly matches the right SQL's behavior with proper column ordering, case sensitivity, and join predicate direction."
        ],
        "rules": [
            "1) When answering about \"students older than 20 in each dorm\": make sure the output order: T3.dorm_name, COUNT(T1.StuID) 2) When the question mentions \"dorm\": \"dorm\" actually means \"T3.dorm_name in schema\" 3) When the question asks for \"count of students\": compute the number of rows using the canonical key token T1.StuID 4) When combining T1 (Student), T2 (Lives_in), and T3 (dorm) for shared entities: link rows where T1.StuID = T2.stuid and T3.dormid = T2.dormid; keep only matching pairs (inner match) 5) When filtering for students older than 20: include only rows where T1.Age > 20 6) When grouping by dormitory: organize results by T3.dorm_name and compute the count per group",
            "1) When the question asks for \"count of students\" per dorm: use the canonical key \"stuid\" from table \"Student\" for counting instead of counting all columns. 2) When combining tables \"Student\", \"Lives_in\", and \"dorm\": link rows where \"Student\".\"stuid\" = \"Lives_in\".\"stuid\" and \"dorm\".\"dormid\" = \"Lives_in\".\"dormid\" using inner matches. 3) When filtering for students older than 20: use the exact condition \"Student\".\"age\" > 20 with lowercase \"age\" column reference. 4) When organizing results by dorm: group by \"dorm\".\"dorm_name\" to get counts per dorm. 5) When producing output columns: place the count result before the dorm name in the output order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT dorm, COUNT(*) FROM students WHERE age > 20 GROUP BY dorm;",
            "SELECT T3.dorm_name, COUNT(*) AS student_count\nFROM student T1\nJOIN lives_in T2 ON T1.StuID = T2.stuid\nJOIN dorm T3 ON T2.dormid = T3.dormid\nWHERE T1.Age > 20\nGROUP BY T3.dorm_name",
            "SELECT COUNT(*), T3.dorm_name FROM Student T1 JOIN Lives_in T2 ON T1.stuid = T2.stuid JOIN Dorm T3 ON T3.dormid = T2.dormid WHERE T1.age > 20 GROUP BY T3.dorm_name"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.StuID), T3.dorm_name \nFROM Student T1\nINNER JOIN Lives_in T2 ON T1.StuID = T2.stuid\nINNER JOIN Dorm T3 ON T3.dormid = T2.dormid\nWHERE T1.Age > 20\nGROUP BY T3.dorm_name"
        ]
    },
    "5455": {
        "db_id": "voter_2",
        "question": "What are the first names of all the students aged above 22?",
        "ground_truth": "SELECT Fname FROM STUDENT WHERE Age  >  22",
        "amends": [
            "Do use column name `Fname` instead of `first_name` and table name `STUDENT` instead of `students`. Do change the filter condition to `Age > 22` instead of `age < 22`, reversing both the column reference and the comparison operator. The amended query now correctly selects students older than 22 rather than younger than 22, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"first names\": use the exact column token \"Fname\" from the STUDENT table. 2) When the question refers to \"students\": use the exact table name \"STUDENT\" instead of \"students\". 3) When filtering for students \"aged above 22\": use the condition \"Age > 22\" to select only records where the age is greater than 22."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE age < 22;",
            "SELECT Fname FROM Student WHERE Age > 22;"
        ],
        "rule_sql": [
            "SELECT Fname FROM Student WHERE Age > 22;"
        ]
    },
    "4547": {
        "db_id": "company_office",
        "question": "What are the names of companies whose headquarters are not \"USA\"?",
        "ground_truth": "SELECT name FROM Companies WHERE Headquarters != 'USA'",
        "amends": [
            "Do filter with `Headquarters != 'USA'` instead of `headquarters = 'USA'` to select companies not headquartered in the USA rather than those that are. Do use proper table name capitalization `Companies` instead of `companies` to match the correct schema. The amended query now correctly excludes USA-headquartered companies and uses the proper table name, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for companies not headquartered in \"USA\": filter rows where \"Headquarters\" is not equal to 'USA' exactly. 2) When referring to the companies table: use the exact table name \"Companies\" with proper capitalization as shown in the schema. 3) When selecting company names: output the \"name\" column from the \"Companies\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM companies WHERE headquarters = 'USA';",
            "SELECT name FROM Companies WHERE Headquarters != 'USA';"
        ],
        "rule_sql": [
            "SELECT name FROM Companies WHERE Headquarters != 'USA';"
        ]
    },
    "4007": {
        "db_id": "ship_mission",
        "question": "What are the names of the ships  that are from either the US or the UK?",
        "ground_truth": "SELECT Name FROM ship WHERE Nationality  =  \"United States\" OR Nationality  =  \"United Kingdom\"",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the correct table name `ship` instead of `ships`. Do filter on `Nationality` column with values \"United States\" and \"United Kingdom\" instead of `country` column with values 'US' and 'UK'. The amended query now correctly selects ship names based on nationality criteria using the proper table and column names."
        ],
        "rules": [
            "1) When the question asks for ship names: select the \"Name\" column from the \"ship\" table. 2) When the question mentions ships from \"US\" or \"UK\": filter using the \"Nationality\" column with exact values \"United States\" and \"United Kingdom\" instead of 'US' and 'UK'. 3) When choosing identifier delimiters: use double quotes for table and column names as shown in the schema (\"ship\", \"Name\", \"Nationality\"). 4) When handling text literals: preserve exact case, spacing and punctuation as \"United States\" and \"United Kingdom\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM ships WHERE country = 'US' OR country = 'UK';",
            "SELECT Name FROM ship WHERE Nationality = 'United States' OR Nationality = 'United Kingdom'"
        ],
        "rule_sql": [
            "SELECT \"Name\" FROM \"ship\" WHERE \"Nationality\" = 'United States' OR \"Nationality\" = 'United Kingdom'"
        ]
    },
    "1888": {
        "db_id": "school_finance",
        "question": "What are the total and average enrollment of all schools?",
        "ground_truth": "SELECT sum(enrollment) ,  avg(enrollment) FROM school",
        "amends": [
            "Do use lowercase function names `sum` and `avg` instead of uppercase `SUM` and `AVG`. Do remove the column aliases `total_enrollment` and `average_enrollment` instead of keeping them. Do reference the table as `school` instead of `schools`. The amended query now matches the right SQL's behavior with identical aggregation results."
        ],
        "rules": [
            "1) When answering about \"total and average enrollment of all schools\": make sure the output order: sum(enrollment), avg(enrollment). 2) When using aggregation functions: use lowercase function names \"sum\" and \"avg\" instead of uppercase \"SUM\" and \"AVG\". 3) When producing output columns: do not use column aliases like \"total_enrollment\" and \"average_enrollment\". 4) When referencing the school table: use the exact table name \"school\" instead of \"schools\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(enrollment) AS total_enrollment, AVG(enrollment) AS average_enrollment FROM schools;",
            "SELECT sum(Enrollment), avg(Enrollment) FROM school"
        ],
        "rule_sql": [
            "SELECT sum(Enrollment), avg(Enrollment) FROM School;"
        ]
    },
    "6293": {
        "db_id": "city_record",
        "question": "Which cities have lower temperature in March than in Dec and have never served as host cities?",
        "ground_truth": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of direct table references. Do join `city AS T1` with `temperature AS T2` on `T1.city_id = T2.city_id` instead of querying a single `weather_data` table. Do filter with `T2.Mar < T2.Dec` instead of `march_temperature < december_temperature`. Do add an `EXCEPT` clause to exclude cities from `hosting_city` table joined on `T3.city_id = T4.host_city` instead of filtering with `host_city = 'No'`. The amended query now correctly handles the data model with separate tables and properly excludes hosting cities using set operations instead of string comparison."
        ],
        "rules": [
            "1) When combining city and temperature tables: link rows where T1.city_id equals T2.city_id and keep only matching pairs (inner match). 2) When comparing March and December temperatures: filter rows where T2.Mar is less than T2.Dec. 3) When excluding host cities: use an EXCEPT operation to remove cities that appear in the hosting_city table, linking on T3.city_id = T4.host_city. 4) When answering about cities with temperature conditions: output only the city column from T1."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city \nFROM weather_data \nWHERE march_temperature < december_temperature \nAND host_city = 'No'",
            "SELECT T1.City\nFROM city AS T1\nJOIN temperature AS T2 ON T1.City_ID = T2.City_ID\nWHERE T2.Mar < T2.Dec\nEXCEPT\nSELECT T3.City\nFROM city AS T3\nJOIN hosting_city AS T4 ON T3.City_ID = T4.Host_City"
        ],
        "rule_sql": [
            "SELECT T1.City\nFROM city T1\nINNER JOIN temperature T2 ON T1.City_ID = T2.City_ID\nWHERE T2.Mar < T2.Dec\nEXCEPT\nSELECT T1.City\nFROM city T1\nINNER JOIN hosting_city T3 ON T1.City_ID = T3.Host_City"
        ]
    },
    "1933": {
        "db_id": "cinema",
        "question": "Count the number of cinemas.",
        "ground_truth": "SELECT count(*) FROM cinema",
        "amends": [
            "Do reference the `cinema` table instead of the `movies` table in the FROM clause. The amended query now correctly counts records from the intended cinema table rather than the movies table."
        ],
        "rules": [
            "1) When counting the number of cinemas: use the \"cinema\" table instead of the \"movies\" table to count records from the intended cinema table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies;",
            "SELECT COUNT(*) FROM cinema;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM cinema;"
        ]
    },
    "5731": {
        "db_id": "dorm_1",
        "question": "How many students are from each city, and which cities have more than one cities?",
        "ground_truth": "SELECT count(*) ,  city_code FROM student GROUP BY city_code HAVING count(*)  >  1",
        "amends": [
            "Do use `count(*)` without an alias instead of `COUNT(*) as student_count` in the SELECT list. Do reference `city_code` instead of `city` as the grouping column. Do remove the table name qualifier `students` from the FROM clause and use `student` instead. Do change the HAVING condition to use `count(*) > 1` instead of `COUNT(city) > 1` to properly count all rows rather than counting non-null city values. The amended query now correctly groups by city_code and counts all students per group while filtering for groups with more than one student.",
            "Do place `city_code` after `count(*)` in the SELECT list instead of before it, maintaining the same GROUP BY and HAVING clauses with identical aggregation logic and filtering conditions. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"students from each city\": use \"city_code\" as the grouping column instead of \"city\". 2) When counting students per city: count all rows using \"count(*)\" without an alias. 3) When filtering for cities with more than one student: use the condition \"count(*) > 1\" to count all rows rather than counting non-null city values. 4) When referencing the student table: use the table name \"student\" instead of \"students\".",
            "1) When answering about \"how many students are from each city\": make sure the output order: count(*) first, then city_code. 2) When the question asks for \"cities have more than one cities\": filter groups where the count of students is greater than 1 using the exact literal value 1. 3) When grouping by city: use the exact column token \"city_code\" for grouping. 4) When counting students: count all rows in the Student table per city group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, COUNT(*) as student_count FROM students GROUP BY city HAVING COUNT(city) > 1",
            "SELECT city_code, COUNT(*) FROM Student GROUP BY city_code HAVING COUNT(*) > 1",
            "SELECT count(*), city_code FROM Student GROUP BY city_code HAVING count(*) > 1"
        ],
        "rule_sql": [
            "SELECT COUNT(*), city_code FROM Student GROUP BY city_code HAVING COUNT(*) > 1"
        ]
    },
    "3018": {
        "db_id": "loan_1",
        "question": "Find the branch names of banks in the New York state.",
        "ground_truth": "SELECT bname FROM bank WHERE state  =  'New York'",
        "amends": [
            "Do reference the table as `bank` instead of `banks` and use the correct column name `bname` instead of `branch_name`. Do use the filter condition `state = 'New York'` instead of `state = 'NY'` to match the correct state name format. The amended query now correctly retrieves branch names from the bank table for New York state, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"branch names\": use the exact column token \"bname\" from the bank table instead of \"branch_name\". 2) When the question mentions \"New York state\": use the exact literal value 'New York' instead of 'NY' for the state filter condition. 3) When referring to the table containing bank information: use the exact table name \"bank\" instead of \"banks\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT branch_name FROM banks WHERE state = 'NY';",
            "SELECT bname FROM bank WHERE state = 'New York';"
        ],
        "rule_sql": [
            "SELECT bname FROM bank WHERE state = 'New York';"
        ]
    },
    "3528": {
        "db_id": "hr_1",
        "question": "What are full names and salaries of employees working in the city of London?",
        "ground_truth": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'",
        "amends": [
            "Do add `JOIN departments AS T2 ON T1.department_id = T2.department_id` and `JOIN locations AS T3 ON T2.location_id = T3.location_id` instead of querying only the `employees` table. Do change the filter to `T3.city = 'London'` instead of `city = 'London'` since the city column exists in the locations table rather than the employees table. The amended query now correctly joins through the department and location relationships to filter employees based on their office location city, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"employees working in the city of London\": make sure to join the employees table (T1) with departments table (T2) using T1.department_id = T2.department_id. 2) When joining departments table (T2) with locations table (T3): use T2.location_id = T3.location_id to link through the location relationship. 3) When filtering for employees in London: use T3.city = 'London' instead of filtering on the employees table since the city column exists in the locations table. 4) When selecting employee information: include both first_name and last_name to get full names along with salary from the employees table (T1)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name, salary FROM employees WHERE city = 'London';",
            "SELECT T1.FIRST_NAME, T1.LAST_NAME, T1.SALARY \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID \nJOIN locations AS T3 ON T2.LOCATION_ID = T3.LOCATION_ID \nWHERE T3.CITY = 'London'"
        ],
        "rule_sql": [
            "SELECT T1.FIRST_NAME, T1.LAST_NAME, T1.SALARY \nFROM employees T1\nJOIN departments T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID\nJOIN locations T3 ON T2.LOCATION_ID = T3.LOCATION_ID\nWHERE T3.CITY = 'London'"
        ]
    },
    "4651": {
        "db_id": "college_3",
        "question": "Find the first names of students whose first names contain letter \"a\".",
        "ground_truth": "SELECT DISTINCT Fname FROM STUDENT WHERE Fname LIKE '%a%'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to return unique values. Do reference column `Fname` instead of `first_name` to match the correct schema. Do use table name `STUDENT` instead of `students` to reference the correct data source. Do use lowercase pattern matching `'%a%'` instead of `'%A%'` for case-insensitive searching. The amended query now correctly returns distinct first names containing lowercase 'a' from the STUDENT table."
        ],
        "rules": [
            "1) When the question asks for \"first names of students\": use table \"STUDENT\" instead of \"students\" to reference the correct data source. 2) When the question asks for \"first names\": use column \"Fname\" instead of \"first_name\" to match the correct schema. 3) When the question asks for names \"containing letter 'a'\": use lowercase pattern matching '%a%' instead of '%A%' for case-insensitive searching. 4) When the question asks for \"first names of students\": use DISTINCT to return unique values instead of omitting it."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE first_name LIKE '%A%';",
            "SELECT DISTINCT Fname FROM Student WHERE Fname LIKE '%a%'"
        ],
        "rule_sql": [
            "SELECT DISTINCT Fname FROM Student WHERE Fname LIKE '%a%'"
        ]
    },
    "3095": {
        "db_id": "behavior_monitoring",
        "question": "How many distinct students have been in detention?",
        "ground_truth": "SELECT count(DISTINCT student_id) FROM Students_in_Detention",
        "amends": [
            "Do select `count(DISTINCT student_id)` instead of `COUNT(*)` to count unique students rather than all records. Do query from `Students_in_Detention` instead of `students` to use the appropriate table containing detention information. Do remove the `WHERE detention = 'yes'` filter instead of keeping it since the dedicated detention table inherently contains only relevant records. The amended query now correctly counts distinct students in detention rather than counting all detention occurrences, matching the intended behavior."
        ],
        "rules": [
            "1) When counting distinct students: use count(DISTINCT student_id) instead of COUNT(*) to count unique students rather than all records. 2) When querying about detention information: use the Students_in_Detention table instead of students to access the appropriate table containing detention records. 3) When working with the dedicated detention table: do not apply a WHERE detention = 'yes' filter since the table inherently contains only relevant detention records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE detention = 'yes';",
            "SELECT COUNT(DISTINCT student_id) FROM Students_in_Detention"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT student_id) FROM Students_in_Detention;"
        ]
    },
    "4438": {
        "db_id": "network_2",
        "question": "Find the name and age of all males in order of their age.",
        "ground_truth": "SELECT name FROM Person WHERE gender  =  'male' ORDER BY age",
        "amends": [
            "Do select only `name` instead of `name, age` and use table `Person` instead of `people`. Do filter for `gender = 'male'` instead of `gender = 'female'` and use ascending `ORDER BY age` instead of descending `ORDER BY age DESC`. The amended query now correctly selects male names from the Person table ordered by age."
        ],
        "rules": [
            "1) When the question asks for \"name and age\": select only the \"name\" column from the \"Person\" table. 2) When filtering for males: use the condition \"gender = 'male'\" exactly as specified. 3) When ordering by age: use ascending order (lowest to highest) on the \"age\" column. 4) When referring to the person table: use the exact table name \"Person\" instead of \"people\"."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, age FROM people WHERE gender = 'female' ORDER BY age DESC;",
            "SELECT name FROM Person WHERE gender = 'male' ORDER BY age"
        ],
        "rule_sql": [
            "SELECT name, age FROM Person WHERE gender = 'male' ORDER BY age ASC;"
        ]
    },
    "4896": {
        "db_id": "school_player",
        "question": "Show the nicknames of schools that are not in division 1.",
        "ground_truth": "SELECT Nickname FROM school_details WHERE Division != \"Division 1\"",
        "amends": [
            "Do reference table `school_details` instead of `schools` in the FROM clause. Do use column `Nickname` instead of `nickname` in the SELECT list. Do use filter condition `Division != \"Division 1\"` instead of `division = 1` in the WHERE clause, changing both the column name and the comparison logic. The amended query now correctly filters for schools not in Division 1 rather than those in division 1, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"school nicknames not in division 1\": make sure the output order: Nickname. 2) When the question mentions \"nicknames\": \"nicknames\" actually means \"Nickname in schema\". 3) When the question mentions \"not in division 1\": use filter condition Division != \"Division 1\" with exact literal \"Division 1\". 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for literal \"Division 1\". 5) When handling text literals: do not change case, spacing, or punctuation for \"Division 1\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT nickname FROM schools WHERE division = 1;",
            "SELECT Nickname FROM school_details WHERE Division != \"Division 1\";"
        ],
        "rule_sql": [
            "SELECT Nickname FROM school_details WHERE Division != \"Division 1\" ORDER BY Nickname;"
        ]
    },
    "5328": {
        "db_id": "manufactory_1",
        "question": "Find all information of all the products with a price between $60 and $120.",
        "ground_truth": "SELECT * FROM products WHERE price BETWEEN 60 AND 120",
        "amends": [
            "Do use `BETWEEN 60 AND 120` instead of `price > 120 OR price < 60` to correctly select products within the price range rather than excluding them. This amendment changes the logic from selecting products outside the range to selecting products inside the specified price boundaries, ensuring the query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for products with a price between $60 and $120: use the exact price range boundaries 60 and 120 with inclusive bounds (BETWEEN 60 AND 120) to include products at both endpoints. 2) When filtering by a numeric range: do not use separate greater-than and less-than conditions that would exclude the range (price > 120 OR price < 60) but instead use a single inclusive range condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM products WHERE price > 120 OR price < 60;",
            "SELECT * FROM Products WHERE Price BETWEEN 60 AND 120;"
        ],
        "rule_sql": [
            "SELECT * FROM Products WHERE Price BETWEEN 60 AND 120;"
        ]
    },
    "4959": {
        "db_id": "soccer_2",
        "question": "How many different colleges were represented at tryouts?",
        "ground_truth": "SELECT count(DISTINCT cName) FROM tryout",
        "amends": [
            "Do `count(DISTINCT cName)` instead of `COUNT(*)` to count distinct names rather than all rows. Do reference table `tryout` instead of `tryouts` to use the correct table name. The amended query now correctly counts distinct names from the tryout table instead of counting all rows from the incorrect table name."
        ],
        "rules": [
            "1) When the question asks for \"different colleges\": count distinct values of the exact token \"cName\" from the tryout table. 2) When choosing table names: use the exact table name \"tryout\" instead of \"tryouts\" as specified in the schema. 3) When counting distinct entities: use count(DISTINCT column) rather than COUNT(*) to count unique values instead of all rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM tryouts;",
            "SELECT COUNT(DISTINCT cName) FROM Tryout;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT cName) FROM Tryout;"
        ]
    },
    "6331": {
        "db_id": "e_government",
        "question": "What are the names of all cities and states?",
        "ground_truth": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses",
        "amends": [
            "Do select `town_city` and `state_province_county` from the `addresses` table instead of selecting `city_name` and `state_name` from the `cities_states_table`. Do use `UNION` to combine results from two separate selections instead of selecting multiple columns from a single table. Do remove the `cities_states_table` source and instead use only the `addresses` table. The amended query now correctly retrieves distinct city and state values from the addresses table using UNION, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for city and state names: select \"town_city\" and \"state_province_county\" from the \"addresses\" table instead of using a non-existent \"cities_states_table\". 2) When retrieving distinct city and state values: use UNION to combine separate selections of \"town_city\" and \"state_province_county\" rather than selecting multiple columns from a single table. 3) When the schema shows identifiers with double quotes: use double quotes exactly as shown for \"town_city\" and \"state_province_county\" identifiers."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city_name, state_name FROM cities_states_table",
            "SELECT town_city AS name FROM Addresses\nUNION\nSELECT state_province_county AS name FROM Addresses;"
        ],
        "rule_sql": [
            "SELECT \"town_city\" FROM \"Addresses\" UNION SELECT \"state_province_county\" FROM \"Addresses\""
        ]
    },
    "6761": {
        "db_id": "activity_1",
        "question": "Show the ids for all the faculty members who have at least 2 students.",
        "ground_truth": "SELECT T1.FacID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID HAVING count(*)  >=  2",
        "amends": [
            "Do select `T1.FacID` instead of `faculty_id` and use a table alias. Do add a `JOIN` with `Student AS T2` instead of querying only the `faculty` table. Do specify the join condition `ON T1.FacID = T2.advisor` instead of filtering by `student_count > 1`. Do add `GROUP BY T1.FacID` instead of omitting grouping. Do use `HAVING count(*) >= 2` instead of `WHERE student_count > 1` to filter groups by count rather than a direct column comparison. The amended query now correctly identifies faculty members who advise at least two students by joining tables and counting actual student relationships instead of relying on a potentially incorrect student_count column."
        ],
        "rules": [
            "1) When answering about faculty members with at least 2 students: select T1.FacID as the output column. 2) When combining faculty and student data: join tables using T1.FacID = T2.advisor to link faculty with their advised students. 3) When counting students per faculty: group results by T1.FacID to organize students by their advisor. 4) When filtering for faculty with minimum student count: use having count(*) >= 2 to ensure each faculty member has at least 2 students. 5) When the question asks for faculty ids: output T1.FacID in the result set."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT faculty_id FROM faculty WHERE student_count > 1",
            "SELECT T1.FacID\nFROM Faculty AS T1\nJOIN Student AS T2 ON T1.FacID = T2.Advisor\nGROUP BY T1.FacID\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T1.FacID\nFROM Faculty T1\nJOIN Student T2 ON T1.FacID = T2.Advisor\nGROUP BY T1.FacID\nHAVING COUNT(*) >= 2"
        ]
    },
    "2012": {
        "db_id": "gas_company",
        "question": "What are the headquarters with at least two companies in the banking industry?",
        "ground_truth": "SELECT headquarters FROM company WHERE main_industry  =  'Banking' GROUP BY headquarters HAVING count(*)  >=  2",
        "amends": [
            "Do reference the table as `company` instead of `companies` and use the column `main_industry` instead of `industry`. Do filter for `'Banking'` instead of `'banking'` to match case sensitivity requirements. Do remove the `COUNT(*) as company_count` column from the SELECT list instead of including it, as only the headquarters column is needed in the output. The GROUP BY and HAVING clauses remain unchanged with `GROUP BY headquarters` and `HAVING count(*) >= 2`. The amended query now correctly identifies banking companies by their case-sensitive industry classification and returns only the headquarters locations meeting the count threshold."
        ],
        "rules": [
            "1) When the question asks about companies: use the table name \"company\" instead of \"companies\". 2) When filtering by industry type: use the column \"main_industry\" instead of \"industry\" and match the exact literal value 'Banking' with proper case sensitivity. 3) When counting companies per headquarters: use count(*) to determine the number of companies but do not include the count column in the final output, only include the headquarters column. 4) When grouping results by headquarters: use GROUP BY headquarters and apply HAVING count(*) >= 2 to filter for headquarters with at least two companies."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT headquarters, COUNT(*) as company_count \nFROM companies \nWHERE industry = 'banking' \nGROUP BY headquarters \nHAVING COUNT(*) >= 2;",
            "SELECT headquarters FROM company WHERE Main_Industry = 'Banking' GROUP BY headquarters HAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT Headquarters FROM company WHERE Main_Industry = 'Banking' GROUP BY Headquarters HAVING COUNT(*) >= 2;"
        ]
    },
    "6222": {
        "db_id": "ship_1",
        "question": "How many captains are in each rank?",
        "ground_truth": "SELECT count(*) ,  rank FROM captain GROUP BY rank",
        "amends": [
            "Do use `count(*)` without an alias instead of `COUNT(*)` with function capitalization. Do place `rank` after the aggregate instead of before it in the SELECT list. Do reference table `captain` instead of `captains` in the FROM clause. The amended query now correctly counts records by rank from the captain table.",
            "Do place the `count(*)` column before `rank` in the SELECT list instead of having `rank` first, maintaining the same GROUP BY clause structure. The amended query now matches RIGHT_SQL's behavior by preserving identical aggregation logic while reordering the output columns."
        ],
        "rules": [
            "1) When the question asks for count of entities per group: use count(*) without capitalization and place the grouping column after the aggregate in the output order. 2) When referring to the table containing captain information: use the exact table name \"captain\" instead of any pluralized form like \"captains\". 3) When grouping by rank to count captains per rank: organize results by the \"rank\" column and compute the count of records for each rank group.",
            "1) When answering about \"how many captains are in each rank\": make sure the output order: count of captains first, then rank. 2) When the question asks for \"count of captains\": compute the number of rows using the canonical key for captains. 3) When the question says \"per rank\"/\"by rank\": organize results by rank and compute the count of captains per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT rank, COUNT(*) FROM captains GROUP BY rank;",
            "SELECT rank, count(*) FROM captain GROUP BY rank",
            "SELECT count(*), Rank FROM captain GROUP BY Rank"
        ],
        "rule_sql": [
            "SELECT count(*), Rank FROM captain GROUP BY Rank"
        ]
    },
    "4176": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "What is the day Number and date of all the documents?",
        "ground_truth": "SELECT T2.day_Number ,  T1.Date_Stored FROM All_documents AS T1 JOIN Ref_calendar AS T2 ON T1.date_stored  =  T2.calendar_date",
        "amends": [
            "Do select `T2.day_Number` and `T1.Date_Stored` instead of `day_number` and `date`. Do join `All_documents AS T1` with `Ref_calendar AS T2` on `T1.date_stored = T2.calendar_date` instead of querying only the `documents` table. Do remove the `WHERE` filters `day_number IS NOT NULL` and `date IS NOT NULL` instead of keeping them, as the join condition now handles data integrity. The amended query now correctly matches the RIGHT_SQL's behavior by properly relating document dates to calendar information through the join."
        ],
        "rules": [
            "1) When answering about \"day Number and date of all the documents\": make sure the output order: T2.day_Number, T1.Date_Stored. 2) When the question mentions \"documents\": \"documents\" actually means \"All_documents AS T1\" in schema. 3) When the question mentions \"day Number\": \"day Number\" actually means \"T2.day_Number\" in schema. 4) When the question mentions \"date\": \"date\" actually means \"T1.Date_Stored\" in schema. 5) When combining T1 and T2 for shared entities: link rows where T1.date_stored = T2.calendar_date exactly as shown in the amends; keep only matching pairs (inner match). 6) When handling text literals: do not change case, spacing, or punctuation for identifiers like \"T2.day_Number\" and \"T1.Date_Stored\". 7) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for identifiers like \"All_documents\" and \"Ref_calendar\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT day_number, date FROM documents WHERE day_number IS NOT NULL AND date IS NOT NULL",
            "SELECT T2.Day_Number, T1.Date_Stored\nFROM All_Documents AS T1\nJOIN Ref_Calendar AS T2 ON T1.Date_Stored = T2.Calendar_Date;"
        ],
        "rule_sql": [
            "SELECT T2.Day_Number, T1.Date_Stored FROM All_Documents AS T1 INNER JOIN Ref_Calendar AS T2 ON T1.Date_Stored = T2.Calendar_Date"
        ]
    },
    "862": {
        "db_id": "chinook_1",
        "question": "What are the addresses of customers living in Germany who have had an invoice?",
        "ground_truth": "SELECT DISTINCT T1.Address FROM CUSTOMER AS T1 JOIN INVOICE AS T2 ON T1.CustomerId  =  T2.CustomerId WHERE T1.country  =  \"Germany\"",
        "amends": [
            "Do use `DISTINCT` to eliminate duplicate addresses instead of omitting it. Do use table aliases `T1` and `T2` instead of `c` and `i`. Do reference `T1.Address` instead of `c.Address`. Do join `CUSTOMER AS T1` with `INVOICE AS T2` instead of `Customers c` with `Invoices i`. Do use double quotes around `\"Germany\"` instead of single quotes. The amended query now correctly returns unique customer addresses from Germany without duplicates, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"addresses of customers living in Germany who have had an invoice\": make sure the output order: T1.Address. 2) When the question mentions \"customers living in Germany\": \"Germany\" actually means \"T1.Country = \\\"Germany\\\"\" in schema. 3) When combining T1 and T2 for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (T1.CustomerId = T2.CustomerId); keep only matching pairs (inner match). 4) When the question asks for addresses of customers who have had an invoice: use DISTINCT to eliminate duplicate addresses instead of omitting it. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for literal values like \\\"Germany\\\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.Address FROM Customers c JOIN Invoices i ON c.CustomerId = i.CustomerId WHERE c.Country = 'Germany'",
            "SELECT DISTINCT T1.Address FROM Customer AS T1 JOIN Invoice AS T2 ON T1.CustomerId = T2.CustomerId WHERE T1.Country = \"Germany\""
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Address\nFROM Customer T1\nINNER JOIN Invoice T2 ON T1.CustomerId = T2.CustomerId\nWHERE T1.Country = \"Germany\""
        ]
    },
    "788": {
        "db_id": "race_track",
        "question": "What are the locations that have both tracks with more than 90000 seats, and tracks with fewer than 70000 seats?",
        "ground_truth": "SELECT LOCATION FROM track WHERE seating  >  90000 INTERSECT SELECT LOCATION FROM track WHERE seating  <  70000",
        "amends": [
            "Do use `INTERSECT` to find locations that meet both conditions instead of using `AND` with contradictory filters. Do reference the correct table name `track` instead of `tracks`. Do use the correct column name `seating` instead of `seats` for both conditions. Do split the query into two separate SELECT statements with `INTERSECT` instead of trying to combine contradictory range conditions in a single WHERE clause. The amended query now correctly finds locations where seating is both greater than 90000 and less than 70000 using set intersection logic."
        ],
        "rules": [
            "1) When the question asks for locations that meet two contradictory range conditions (seating > 90000 and seating < 70000): use INTERSECT to combine results from two separate queries instead of using AND in a single WHERE clause. 2) When referring to the table containing track information: use the exact table name \"track\" instead of \"tracks\". 3) When referring to seating capacity: use the exact column name \"seating\" instead of \"seats\". 4) When filtering for seating capacity greater than 90000: use the condition seating > 90000. 5) When filtering for seating capacity less than 70000: use the condition seating < 70000."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location FROM tracks WHERE seats > 90000 AND seats < 70000;",
            "SELECT Location FROM track WHERE Seating > 90000\nINTERSECT\nSELECT Location FROM track WHERE Seating < 70000"
        ],
        "rule_sql": [
            "SELECT Location FROM track WHERE seating > 90000\nINTERSECT\nSELECT Location FROM track WHERE seating < 70000"
        ]
    },
    "236": {
        "db_id": "musical",
        "question": "List the name of actors in ascending alphabetical order.",
        "ground_truth": "SELECT Name FROM actor ORDER BY Name ASC",
        "amends": [
            "Do use column name `Name` instead of `name` to match the correct case sensitivity. Do reference table `actor` instead of `actors` to use the correct table name. Do use `ASC` ordering instead of `DESC` to sort in ascending order instead of descending. The amended query now correctly selects from the proper table with appropriate column naming and sorting direction."
        ],
        "rules": [
            "1) When the question asks for actor names: use column \"Name\" from table \"actor\" to match exact case sensitivity. 2) When ordering alphabetically in ascending order: sort the results by \"Name\" in ascending order (A to Z). 3) When selecting from the actors table: use the exact table name \"actor\" instead of \"actors\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM actors ORDER BY name DESC;",
            "SELECT Name FROM actor ORDER BY Name ASC;"
        ],
        "rule_sql": [
            "SELECT Name FROM actor ORDER BY Name ASC;"
        ]
    },
    "5580": {
        "db_id": "products_gen_characteristics",
        "question": "Find the product category description of the product category with code \"Spices\".",
        "ground_truth": "SELECT product_category_description FROM ref_product_categories WHERE product_category_code  =  \"Spices\"",
        "amends": [
            "Do reference `product_category_description` instead of `product_description` in the SELECT list. Do query from `ref_product_categories` instead of `product_categories` as the source table. Do filter on `product_category_code` instead of `category_code` in the WHERE clause. Do use double quotes `\"Spices\"` instead of single quotes `'Spices'` for the string literal. The amended query now correctly retrieves category descriptions from the reference table using the appropriate column names and syntax."
        ],
        "rules": [
            "1) When the question asks for \"product category description\": use the exact column name \"product_category_description\" from the \"Ref_Product_Categories\" table. 2) When querying product category information: use the \"ref_product_categories\" table instead of \"product_categories\" as the source table. 3) When filtering by product category code: use the exact column name \"product_category_code\" in the WHERE clause. 4) When matching the literal value \"Spices\": use double quotes \"Spices\" instead of single quotes to preserve exact string formatting."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT product_description FROM product_categories WHERE category_code = 'Spices';",
            "SELECT product_category_description FROM Ref_Product_Categories WHERE product_category_code = \"Spices\";"
        ],
        "rule_sql": [
            "SELECT product_category_description FROM Ref_Product_Categories WHERE product_category_code = \"Spices\";"
        ]
    },
    "729": {
        "db_id": "customers_card_transactions",
        "question": "Show all card type codes.",
        "ground_truth": "SELECT DISTINCT card_type_code FROM Customers_Cards",
        "amends": [
            "Do select only `card_type_code` instead of all columns with `*`, and do add `DISTINCT` instead of omitting it to return unique values. Do change the table source to `Customers_Cards` instead of `cards` to reference the correct table. The amended query now correctly returns distinct card type codes from the Customers_Cards table as intended."
        ],
        "rules": [
            "1) When answering about \"card type codes\": make sure the output order: card_type_code. 2) When the question asks for \"all card type codes\": return only distinct values of card_type_code. 3) When selecting from the Customers_Cards table: use the exact table name \"Customers_Cards\" with double quotes as shown in the schema. 4) When the question mentions \"card type codes\": \"card type codes\" actually means \"card_type_code in schema\". 5) When producing output: do not include any columns other than card_type_code."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM cards;",
            "SELECT DISTINCT card_type_code FROM Customers_Cards"
        ],
        "rule_sql": [
            "SELECT DISTINCT card_type_code FROM \"Customers_Cards\" ORDER BY card_type_code;"
        ]
    },
    "817": {
        "db_id": "chinook_1",
        "question": "Find the names of all artists that have \"a\" in their names.",
        "ground_truth": "SELECT Name FROM ARTIST WHERE Name LIKE \"%a%\"",
        "amends": [
            "Do reference the table as `ARTIST` instead of `artists` and use column name `Name` instead of `name` to match the correct schema. Do use double quotes for the pattern string `\"%a%\"` instead of single quotes `'%A%'` and make the pattern case-insensitive with lowercase `a` instead of uppercase `A` to ensure proper string matching. The amended query now correctly searches for names containing lowercase 'a' in the ARTIST table."
        ],
        "rules": [
            "1) When the question asks about artist names: use table \"ARTIST\" instead of \"artists\" and column \"Name\" instead of \"name\" to match the schema. 2) When searching for names containing the letter \"a\": use the pattern string \"%a%\" with double quotes and lowercase \"a\" for case-insensitive matching. 3) When producing output: return only the \"Name\" column from the \"ARTIST\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM artists WHERE name LIKE '%A%';",
            "SELECT Name FROM ARTIST WHERE Name LIKE \"%a%\""
        ],
        "rule_sql": [
            "SELECT Name FROM Artist WHERE Name LIKE \"%a%\";"
        ]
    },
    "1774": {
        "db_id": "gymnast",
        "question": "Show the ages of gymnasts in descending order of total points.",
        "ground_truth": "SELECT T2.Age FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID ORDER BY T1.Total_Points DESC",
        "amends": [
            "Do select `T2.Age` from the `people` table instead of `age` from the `gymnasts` table. Do join `gymnast AS T1` with `people AS T2` on `T1.Gymnast_ID = T2.People_ID` instead of querying only the `gymnasts` table. Do order by `T1.Total_Points DESC` instead of `age DESC`. The amended query now correctly retrieves age information from the people table while ordering by total points from the gymnast table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"ages of gymnasts\": select \"T2.Age\" from the \"people\" table instead of \"age\" from the \"gymnasts\" table. 2) When combining gymnast and people tables: link rows where \"T1.Gymnast_ID\" equals \"T2.People_ID\" and keep only matching pairs (inner match). 3) When ordering by total points in descending order: order by \"T1.Total_Points DESC\" instead of age. 4) When the question mentions \"gymnasts\": the gymnast information is stored in table \"gymnast\" with alias T1. 5) When the question mentions \"ages\": the age information is stored in table \"people\" with alias T2."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT age FROM gymnasts ORDER BY age DESC;",
            "SELECT T2.Age FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID = T2.People_ID ORDER BY T1.Total_Points DESC"
        ],
        "rule_sql": [
            "SELECT T2.Age FROM gymnast T1 INNER JOIN people T2 ON T1.Gymnast_ID = T2.People_ID ORDER BY T1.Total_Points DESC"
        ]
    },
    "528": {
        "db_id": "allergy_1",
        "question": "What is the full name of each student who is not allergic to any type of food.",
        "ground_truth": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  \"food\")",
        "amends": [
            "Do select `fname` and `lname` instead of `full_name`. Do change the source table to `Student` instead of `students`. Do remove the `WHERE allergy IS NULL` filter instead of keeping it. Do add a subquery with `NOT IN` instead of omitting it, where the subquery uses `JOIN` between `Has_allergy` and `Allergy_Type` tables on `T1.Allergy = T2.Allergy` instead of no join, and filters for `T2.allergytype = \"food\"` instead of no specific allergy type condition. The amended query now correctly identifies students without food allergies by checking against a joined allergy table instead of relying on a simple null check."
        ],
        "rules": [
            "1) When the question asks for \"full name\" of students: use \"fname\" and \"lname\" columns instead of \"full_name\". 2) When referring to the student table: use \"Student\" instead of \"students\". 3) When identifying students without food allergies: do not use a simple NULL check on allergy field; instead use a subquery with NOT IN condition. 4) When checking for food allergies: join \"Has_allergy\" (T1) and \"Allergy_Type\" (T2) tables where T1.Allergy = T2.Allergy and filter for T2.allergytype = \"food\". 5) When the question specifies \"allergic to any type of food\": ensure the condition uses exact literal \"food\" (case-sensitive) for allergytype."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT full_name FROM students WHERE allergy IS NULL;",
            "SELECT fname, lname FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Allergy JOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy WHERE AllergyType = 'food')"
        ],
        "rule_sql": [
            "SELECT fname, lname FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Allergy JOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy WHERE Allergy_Type.AllergyType = 'food')"
        ]
    },
    "781": {
        "db_id": "race_track",
        "question": "Show the name of track with most number of races.",
        "ground_truth": "SELECT T2.name FROM race AS T1 JOIN track AS T2 ON T1.track_id  =  T2.track_id GROUP BY T1.track_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.name` from the `track` table instead of selecting `name` directly from `tracks`. Do join `race AS T1` with `track AS T2` on `T1.track_id = T2.track_id` instead of querying only the `tracks` table. Do add `GROUP BY T1.track_id` to aggregate by track identifier instead of missing grouping. Do use `count(*)` to count all races per track instead of `COUNT(races)` which incorrectly references a column. Do order by the aggregate count instead of ordering without proper grouping. The amended query now correctly counts races per track and returns the track name with the most races, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"track with most number of races\": make sure the output order: T2.name. 2) When the question mentions \"track\": \"track\" actually means \"T2\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.track_id = T2.track_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"count of races\": compute the number of rows using count(*) per track group. 5) When the question says \"per track\"/\"by track\": organize results by T1.track_id and compute requested aggregates per group. 6) When the question mentions \"most\", \"highest\", or an explicit top by count: rank rows by count(*) in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM tracks ORDER BY COUNT(races) DESC LIMIT 1;",
            "SELECT T2.Name\nFROM race AS T1\nJOIN track AS T2 ON T1.Track_ID = T2.Track_ID\nGROUP BY T1.Track_ID\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Name\nFROM race T1\nINNER JOIN track T2 ON T1.Track_ID = T2.Track_ID\nGROUP BY T1.Track_ID\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "3058": {
        "db_id": "loan_1",
        "question": "For each state, find the total account balance of customers whose credit score is above 100.",
        "ground_truth": "SELECT sum(acc_bal) ,  state FROM customer WHERE credit_score  >  100 GROUP BY state",
        "amends": [
            "Do use `sum(acc_bal)` instead of `SUM(balance)` for the aggregate function and column reference. Do place the `state` column after the aggregate instead of before it in the SELECT list. Do reference table `customer` instead of `customers` in the FROM clause. The amended query now correctly calculates account balances by state for customers with credit scores above 100, matching the intended behavior.",
            "Do place `state` after the aggregate function in the SELECT list instead of listing it first. Do use the same aggregate expression `SUM(acc_bal)` without an alias instead of adding the `AS total_account_balance` alias. The GROUP BY clause and WHERE filter remain unchanged, maintaining the same grouping by state and credit score filtering. The amended query now correctly returns the sum of account balances grouped by state without the unnecessary alias, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"total account balance\": use \"sum(acc_bal)\" instead of \"SUM(balance)\" for the aggregate function and column reference. 2) When organizing results by state: place the \"state\" column after the aggregate function in the output order. 3) When referencing the customer table: use table name \"customer\" instead of \"customers\" in the FROM clause. 4) When filtering customers by credit score: use condition \"credit_score > 100\" to include only customers with credit scores above 100. 5) When grouping results by state: organize the output by the \"state\" column and compute the requested aggregate per state group.",
            "1) When answering about \"total account balance of customers by state\": make sure the output order: SUM(acc_bal) first, then state. 2) When the question asks for \"total account balance\": compute the sum of acc_bal values. 3) When the question says \"per state\"/\"by state\": organize results by the state column and compute the sum per group. 4) When the question mentions \"credit score is above 100\": filter rows where credit_score > 100. 5) When producing output: do not add aliases like AS total_account_balance to aggregate functions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT state, SUM(balance) FROM customers WHERE credit_score > 100 GROUP BY state;",
            "SELECT state, SUM(acc_bal) AS total_account_balance FROM customer WHERE credit_score > 100 GROUP BY state;",
            "SELECT SUM(acc_bal), state FROM customer WHERE credit_score > 100 GROUP BY state"
        ],
        "rule_sql": [
            "SELECT SUM(acc_bal), state FROM customer WHERE credit_score > 100 GROUP BY state"
        ]
    },
    "67": {
        "db_id": "student_assessment",
        "question": "What is detail of the student who most recently registered course?",
        "ground_truth": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT 1",
        "amends": [
            "Do select `T2.student_details` instead of `*` to retrieve specific column data. Do join `student_course_registrations AS T1` and `students AS T2` with `ON T1.student_id = T2.student_id` instead of querying only the `students` table. Do order by `T1.registration_date` instead of `registration_date` to use the registration date from the correct table. The amended query now correctly retrieves student details based on the most recent course registration date instead of just the latest student record."
        ],
        "rules": [
            "1) When answering about \"detail of the student who most recently registered course\": make sure the output order: T2.student_details. 2) When combining T1 and T2 for shared entities: link rows where T1.student_id = T2.student_id exactly as shown; keep only matching pairs (inner match). 3) When the question mentions \"most recently registered course\": order rows by T1.registration_date in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM students ORDER BY registration_date DESC LIMIT 1;",
            "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.student_details\nFROM Student_Course_Registrations T1\nINNER JOIN Students T2 ON T1.student_id = T2.student_id\nORDER BY T1.registration_date DESC\nLIMIT 1;"
        ]
    },
    "1568": {
        "db_id": "customers_and_invoices",
        "question": "Return the id and full name of the customer with the most accounts.",
        "ground_truth": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.customer_id`, `T2.customer_first_name`, and `T2.customer_last_name` as separate columns instead of concatenating `first_name || ' ' || last_name` as `full_name`. Do use `JOIN` between `Accounts AS T1` and `Customers AS T2` on `T1.customer_id = T2.customer_id` instead of querying only from `customers` with a subquery. Do move the `GROUP BY T1.customer_id` and `ORDER BY count(*) DESC LIMIT 1` to the main query instead of using a subquery to find the customer with the most accounts. Do remove the `WHERE` filter with subquery entirely instead of keeping it, as the grouping and ordering now handle the logic in the main query. The amended query now correctly joins the tables and aggregates to find the customer with the most accounts while selecting their details."
        ],
        "rules": [
            "1) When answering about \"customer with the most accounts\": use Accounts as T1 and Customers as T2 with T1.customer_id = T2.customer_id to link the tables. 2) When counting accounts per customer: group by T1.customer_id and count using the canonical key. 3) When finding the customer with the highest count: order by count(*) in descending direction and keep only the first row. 4) When selecting customer details: output T1.customer_id, T2.customer_first_name, and T2.customer_last_name as separate columns instead of concatenating them."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT customer_id, first_name || ' ' || last_name AS full_name \nFROM customers \nWHERE customer_id = (SELECT customer_id FROM accounts GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
            "SELECT T1.customer_id, T2.customer_first_name, T2.customer_last_name\nFROM Accounts AS T1\nJOIN Customers AS T2 ON T1.customer_id = T2.customer_id\nGROUP BY T1.customer_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT c.customer_id, c.customer_first_name, c.customer_last_name\nFROM Accounts a\nJOIN Customers c ON a.customer_id = c.customer_id\nGROUP BY a.customer_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "4219": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "Give me all the distinct location codes for documents.",
        "ground_truth": "SELECT DISTINCT location_code FROM Document_locations",
        "amends": [
            "Do select `location_code` instead of `location` and use `DISTINCT` instead of omitting it. Do query from `Document_locations` table instead of `documents` table. The amended query now correctly retrieves unique location codes from the appropriate table."
        ],
        "rules": [
            "1) When the question asks for \"location codes\": use the exact column token \"location_code\" instead of \"location\". 2) When the question asks for \"distinct\" values: include DISTINCT to return only unique values. 3) When the question refers to \"documents\": query from the \"Document_locations\" table instead of the \"documents\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location FROM documents;",
            "SELECT DISTINCT Location_Code FROM Document_Locations;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Location_Code FROM Document_Locations;"
        ]
    },
    "5681": {
        "db_id": "dorm_1",
        "question": "How many diffrent dorm amenities are there?",
        "ground_truth": "SELECT count(*) FROM dorm_amenity",
        "amends": [
            "Do reference the correct table name `dorm_amenity` instead of the incorrect pluralized form `dorm_amenities` in the FROM clause. The amended query now correctly counts records from the proper dorm_amenity table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"dorm amenities\": use the exact table name \"dorm_amenity\" (singular form) instead of pluralized forms like \"dorm_amenities\". 2) When counting different dorm amenities: count the number of rows in the \"dorm_amenity\" table using the table's canonical structure."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM dorm_amenities;",
            "SELECT COUNT(*) FROM dorm_amenity;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM dorm_amenity;"
        ]
    },
    "4522": {
        "db_id": "document_management",
        "question": "What are the usernames and passwords of users that have the most common role?",
        "ground_truth": "SELECT user_name ,  password FROM users GROUP BY role_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `user_name` and `password` instead of `username` and `password`. Do group by `role_code` instead of filtering with a subquery that groups by `role`. Do order by `count(*)` descending instead of using a subquery with the same ordering. Do remove the WHERE clause with the subquery instead of keeping it. The amended query now correctly groups by role_code and selects the top group by count rather than attempting to filter for a specific role value through subquery comparison.",
            "Do use `GROUP BY role_code` instead of joining with a subquery to find the most common role. Do remove the table alias `u` and explicit join condition `u.role_code = most_common.role_code` instead of keeping them. Do move the aggregate function `count(*)` to the `ORDER BY` clause instead of using it in a subquery's SELECT list. Do omit the subquery entirely and perform the grouping directly on the main query instead of using a derived table. Do remove the `role_count` alias from the subquery since it's not needed in the simplified approach. The amended query now correctly identifies users from the most common role group by directly grouping and ordering by the count."
        ],
        "rules": [
            "1) When the question asks for usernames and passwords: select \"user_name\" and \"password\" columns instead of \"username\" and \"password\". 2) When grouping users by role to find the most common role: group by \"role_code\" instead of \"role\". 3) When finding the group with the highest count: order by count(*) descending and take the first group. 4) When using grouping to find the most common role: remove any WHERE clause with subquery comparison and instead use grouping with ordering by count.",
            "1) When answering about \"users that have the most common role\": make sure the output order: user_name, password. 2) When the question asks for \"most common role\": group by role_code and order by count(*) in descending direction to find the role with highest frequency. 3) When counting users per role: use count(*) to determine the frequency of each role_code value. 4) When producing the final result: include only users from the role group with the maximum count value."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT username, password FROM users WHERE role = (SELECT role FROM users GROUP BY role ORDER BY COUNT(*) DESC LIMIT 1);",
            "SELECT u.user_name, u.password\nFROM Users u\nJOIN (\n    SELECT role_code, COUNT(*) as role_count\n    FROM Users\n    GROUP BY role_code\n    ORDER BY role_count DESC\n    LIMIT 1\n) most_common ON u.role_code = most_common.role_code;",
            "SELECT user_name, password FROM Users GROUP BY role_code ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT user_name, password\nFROM Users\nWHERE role_code = (\n    SELECT role_code\n    FROM Users\n    GROUP BY role_code\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)\nORDER BY user_name, password;"
        ]
    },
    "5224": {
        "db_id": "music_2",
        "question": "What are the vocal types used in song \"Le Pop\"?",
        "ground_truth": "SELECT TYPE FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Le Pop\"",
        "amends": [
            "Do select `TYPE` from the `vocals` table instead of `vocal_type` from the `songs` table. Do join `vocals AS T1` with `songs AS T2` on `T1.songid = T2.songid` instead of querying only the `songs` table. Do use double quotes around `\"Le Pop\"` instead of single quotes for the string literal. The amended query now correctly retrieves vocal types by joining the vocals and songs tables on their songid relationship, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"vocal types used in a song\": select \"TYPE\" from the vocals table (T1) instead of vocal_type from the songs table. 2) When the question mentions a specific song title \"Le Pop\": use double quotes around \"Le Pop\" for the string literal. 3) When combining vocals (T1) and songs (T2) tables: link rows where T1.songid = T2.songid and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT vocal_type FROM songs WHERE title = 'Le Pop';",
            "SELECT T1.Type FROM Vocals AS T1 JOIN Songs AS T2 ON T1.SongId = T2.SongId WHERE T2.Title = \"Le Pop\""
        ],
        "rule_sql": [
            "SELECT DISTINCT v.Type FROM Vocals v JOIN Songs s ON v.SongId = s.SongId WHERE s.Title = \"Le Pop\""
        ]
    },
    "4654": {
        "db_id": "college_3",
        "question": "What are the full names of faculties with sex M and who live in building NEB?",
        "ground_truth": "SELECT Fname ,  Lname FROM FACULTY WHERE sex  =  \"M\" AND Building  =  \"NEB\"",
        "amends": [
            "Do use column aliases `Fname` and `Lname` instead of `first_name` and `last_name`. Do reference table `FACULTY` instead of `faculties`. Do use filter condition `sex = \"M\"` instead of `gender = 'M'`. Do use double quotes around string literals `\"M\"` and `\"NEB\"` instead of single quotes. The amended query now correctly matches the RIGHT_SQL's behavior with proper column names, table reference, and string formatting."
        ],
        "rules": [
            "1) When the question asks for \"full names of faculties\": output columns should be \"Fname\" and \"Lname\" in that order. 2) When the question mentions \"faculties\": use table \"FACULTY\" instead of \"faculties\". 3) When filtering for sex \"M\": use condition sex = \"M\" with double quotes around the literal. 4) When filtering for building \"NEB\": use condition building = \"NEB\" with double quotes around the literal."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM faculties WHERE gender = 'M' AND building = 'NEB';",
            "SELECT Fname, Lname FROM Faculty WHERE Sex = \"M\" AND Building = \"NEB\";"
        ],
        "rule_sql": [
            "SELECT Fname, Lname FROM Faculty WHERE Sex = \"M\" AND Building = \"NEB\""
        ]
    },
    "1090": {
        "db_id": "match_season",
        "question": "Show the position of players and the corresponding number of players.",
        "ground_truth": "SELECT POSITION ,  COUNT(*) FROM match_season GROUP BY POSITION",
        "amends": [
            "Do reference table `match_season` instead of `players` in the FROM clause. Do group by column `POSITION` instead of `player_id` in the GROUP BY clause. Do select column `POSITION` instead of `position` in the SELECT list. The amended query now correctly aggregates player counts by position from the match_season table instead of incorrectly grouping by player_id from the players table."
        ],
        "rules": [
            "1) When answering about \"position of players and the corresponding number of players\": make sure the output order: POSITION, COUNT(*) 2) When the question mentions \"position\": \"position\" actually means \"POSITION in schema\" 3) When the question asks for \"number of players per position\": organize results by POSITION and compute count of players per group 4) When the question asks for \"count of players\": compute the number of rows using the canonical key from match_season table 5) When choosing identifier delimiters: do not replace uppercase identifiers with lowercase forms"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT position, COUNT(*) FROM players GROUP BY player_id;",
            "SELECT \"Position\", COUNT(*) AS Number_of_Players FROM match_season GROUP BY \"Position\";"
        ],
        "rule_sql": [
            "SELECT \"Position\", COUNT(*) FROM \"match_season\" GROUP BY \"Position\" ORDER BY \"Position\", COUNT(*)"
        ]
    },
    "1231": {
        "db_id": "apartment_rentals",
        "question": "What is the average room count of the apartments whose booking status code is \"Provisional\"?",
        "ground_truth": "SELECT avg(room_count) FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.booking_status_code  =  \"Provisional\"",
        "amends": [
            "Do join `Apartment_Bookings AS T1` and `Apartments AS T2` on `T1.apt_id = T2.apt_id` instead of querying only the `apartments` table without any join. Do filter on `T1.booking_status_code = \"Provisional\"` instead of `booking_status = 'Confirmed'` to use the correct table reference and status value. Do use the correct table alias `T2` for `room_count` instead of accessing it directly from the original table. The amended query now correctly joins the booking and apartment tables and filters by the proper provisional status code."
        ],
        "rules": [
            "1) When answering about average room count of apartments with booking status \"Provisional\": join tables Apartment_Bookings AS T1 and Apartments AS T2 on T1.apt_id = T2.apt_id to combine booking and apartment information. 2) When filtering for booking status: use T1.booking_status_code = \"Provisional\" instead of 'Confirmed' to match the exact status value with correct table reference. 3) When accessing room count: use T2.room_count from the Apartments table instead of the original table reference. 4) When computing the average: calculate the average of T2.room_count values for apartments that meet the booking status condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(room_count) FROM apartments WHERE booking_status = 'Confirmed';",
            "SELECT AVG(CAST(T2.room_count AS REAL)) AS average_room_count\nFROM Apartment_Bookings AS T1\nJOIN Apartments AS T2 ON T1.apt_id = T2.apt_id\nWHERE T1.booking_status_code = 'Provisional'"
        ],
        "rule_sql": [
            "SELECT AVG(CAST(T2.room_count AS REAL)) AS average_room_count\nFROM Apartment_Bookings AS T1\nJOIN Apartments AS T2 ON T1.apt_id = T2.apt_id\nWHERE T1.booking_status_code = 'Provisional';"
        ]
    },
    "855": {
        "db_id": "chinook_1",
        "question": "Find all invoice dates corresponding to customers with first name Astrid and last name Gruber.",
        "ground_truth": "SELECT T2.InvoiceDate FROM CUSTOMER AS T1 JOIN INVOICE AS T2 ON T1.CustomerId  =  T2.CustomerId WHERE T1.FirstName  =  \"Astrid\" AND LastName  =  \"Gruber\"",
        "amends": [
            "Do select `T2.InvoiceDate` instead of `invoice_date` and specify the table alias. Do add `FROM CUSTOMER AS T1 JOIN INVOICE AS T2` instead of just `FROM invoices`, introducing a proper join between customer and invoice tables. Do add `ON T1.CustomerId = T2.CustomerId` instead of omitting the join condition, establishing the correct relationship between customer and invoice records. Do change the WHERE clause to reference `T1.FirstName` and `T1.LastName` instead of directly filtering on invoice table columns, ensuring the customer name filter is applied to the correct table. The amended query now correctly joins customer and invoice tables to find invoices for the specific customer instead of incorrectly assuming invoice records contain customer name fields directly."
        ],
        "rules": [
            "1) When answering about \"invoice dates for customers with specific names\": make sure the output order: T2.InvoiceDate. 2) When the question mentions \"customers with first name Astrid and last name Gruber\": \"first name\" actually means \"T1.FirstName in schema\" and \"last name\" actually means \"T1.LastName in schema\". 3) When combining T1 (CUSTOMER) and T2 (INVOICE) for shared entities: link rows where T1.CustomerId = T2.CustomerId exactly as shown; keep only matching pairs (inner match). 4) When handling text literals: do not change case, spacing, or punctuation - use 'Astrid' and 'Gruber' exactly as specified."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT invoice_date FROM invoices WHERE first_name = 'Astrid' AND last_name = 'Gruber'",
            "SELECT T2.InvoiceDate \nFROM Customer AS T1 \nJOIN Invoice AS T2 ON T1.CustomerId = T2.CustomerId \nWHERE T1.FirstName = 'Astrid' AND T1.LastName = 'Gruber'"
        ],
        "rule_sql": [
            "SELECT T2.InvoiceDate \nFROM Customer T1 \nINNER JOIN Invoice T2 ON T1.CustomerId = T2.CustomerId \nWHERE T1.FirstName = 'Astrid' AND T1.LastName = 'Gruber'"
        ]
    },
    "3054": {
        "db_id": "loan_1",
        "question": "Find the state which has the most number of customers.",
        "ground_truth": "SELECT state FROM bank GROUP BY state ORDER BY sum(no_of_customers) DESC LIMIT 1",
        "amends": [
            "Do select `state` instead of `state, COUNT(*)` and change the source table to `bank` instead of `customers`. Do use `sum(no_of_customers)` in the ORDER BY instead of `COUNT(*)` while keeping the GROUP BY on `state` and maintaining the DESC ordering with LIMIT 1. The amended query now correctly calculates the state with the highest total number of customers by summing the pre-aggregated customer counts rather than counting individual records."
        ],
        "rules": [
            "1) When the question asks about \"state which has the most number of customers\": use the \"state\" column from the \"bank\" table instead of the \"customers\" table. 2) When calculating the number of customers per state: use sum(\"no_of_customers\") instead of COUNT(*) to aggregate pre-aggregated customer counts. 3) When ranking states by customer count: order by sum(\"no_of_customers\") in descending direction and keep only the top result with LIMIT 1. 4) When grouping results by state: maintain the GROUP BY on \"state\" column. 5) When selecting output columns: include only \"state\" in the final result, not the aggregate count."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT state, COUNT(*) FROM customers GROUP BY state ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT state FROM bank GROUP BY state ORDER BY SUM(no_of_customers) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT state FROM bank GROUP BY state ORDER BY SUM(no_of_customers) DESC LIMIT 1;"
        ]
    },
    "5556": {
        "db_id": "products_gen_characteristics",
        "question": "How many distinct characteristic names does the product \"cumin\" have?",
        "ground_truth": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  \"sesame\"",
        "amends": [
            "Do use `count(DISTINCT t3.characteristic_name)` instead of `COUNT(*)` to count distinct characteristics rather than all rows. Do join `products AS t1` instead of querying only the characteristics table to properly relate products to their characteristics. Do add `JOIN product_characteristics AS t2 ON t1.product_id = t2.product_id` instead of omitting this intermediate relationship table. Do add `JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id = t3.characteristic_id` instead of directly querying the characteristics table without proper joins. Do filter on `t1.product_name = \"sesame\"` instead of `product_name = 'cumin'` to query for the correct product. The amended query now correctly counts distinct characteristics for the specified product by properly navigating the relationship tables."
        ],
        "rules": [
            "1) When answering about distinct characteristic names for a product: use count(DISTINCT t3.characteristic_name) instead of COUNT(*) to count distinct characteristics rather than all rows. 2) When the question mentions a product name: join products AS t1 instead of querying only the characteristics table to properly relate products to their characteristics. 3) When combining products and characteristics tables: add JOIN product_characteristics AS t2 ON t1.product_id = t2.product_id to include the intermediate relationship table. 4) When linking characteristics to products: add JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id = t3.characteristic_id to properly connect through the relationship table. 5) When filtering for a specific product: use t1.product_name = \"sesame\" instead of product_name = 'cumin' to query for the correct product."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM characteristics WHERE product_name = 'cumin';",
            "SELECT COUNT(DISTINCT t3.characteristic_name) \nFROM products AS t1\nJOIN product_characteristics AS t2 ON t1.product_id = t2.product_id\nJOIN characteristics AS t3 ON t2.characteristic_id = t3.characteristic_id\nWHERE t1.product_name = 'sesame'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT t3.characteristic_name) \nFROM products AS t1\nJOIN product_characteristics AS t2 ON t1.product_id = t2.product_id\nJOIN characteristics AS t3 ON t2.characteristic_id = t3.characteristic_id\nWHERE t1.product_name = \"sesame\""
        ]
    },
    "2549": {
        "db_id": "county_public_safety",
        "question": "What are the names of the five cities with the greatest proportion of white people?",
        "ground_truth": "SELECT Name FROM city ORDER BY White DESC LIMIT 5",
        "amends": [
            "Do select `Name` instead of `city` and `white_population / total_population AS proportion`. Do use `White` column directly instead of calculating a proportion from separate population columns. Do remove the alias `proportion` and the division calculation. Do change the ORDER BY to use `White DESC` instead of the calculated `proportion DESC`. Do maintain the same `LIMIT 5` clause. The amended query now correctly selects city names ordered by white population values directly instead of calculating proportions from separate columns."
        ],
        "rules": [
            "1) When the question asks for city names: select the \"Name\" column from the city table. 2) When the question asks about proportion of white people: use the \"White\" column directly instead of calculating proportions from separate population columns. 3) When the question asks for the five cities with the greatest proportion: order by \"White\" in descending order and limit to 5 rows. 4) When producing output: return only the \"Name\" column without any calculated proportion column or alias."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, white_population / total_population AS proportion FROM demographics ORDER BY proportion DESC LIMIT 5;",
            "SELECT Name FROM city ORDER BY White DESC LIMIT 5;"
        ],
        "rule_sql": [
            "SELECT Name FROM city ORDER BY White DESC LIMIT 5"
        ]
    },
    "1508": {
        "db_id": "insurance_and_eClaims",
        "question": "Sort the customer names in alphabetical order.",
        "ground_truth": "SELECT customer_details FROM customers ORDER BY customer_details",
        "amends": [
            "Do select `customer_details` instead of `*` to return only specific columns instead of all columns. Do order by `customer_details` instead of `customer_name DESC` to sort by the correct column without descending order. The amended query now correctly returns only customer details sorted alphabetically by those details."
        ],
        "rules": [
            "1) When selecting columns for output: return only the \"customer_details\" column instead of all columns. 2) When sorting alphabetically: order by \"customer_details\" in ascending order (not descending)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM customers ORDER BY customer_name DESC;",
            "SELECT Customer_Details FROM Customers ORDER BY Customer_Details;"
        ],
        "rule_sql": [
            "SELECT customer_details FROM Customers ORDER BY customer_details ASC;"
        ]
    },
    "2872": {
        "db_id": "icfp_1",
        "question": "Which institution does \"Katsuhiro Ueno\" belong to?",
        "ground_truth": "SELECT DISTINCT t3.name FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN inst AS t3 ON t2.instid  =  t3.instid WHERE t1.fname  =  \"Katsuhiro\" AND t1.lname  =  \"Ueno\"",
        "amends": [
            "Do select `DISTINCT t3.name` instead of `institution` from the SELECT list. Do add joins to `authors AS t1`, `authorship AS t2`, and `inst AS t3` instead of querying only the `people` table. Do use `JOIN authorship AS t2 ON t1.authid = t2.authid` and `JOIN inst AS t3 ON t2.instid = t3.instid` instead of no joins. Do change the WHERE clause to `t1.fname = \"Katsuhiro\" AND t1.lname = \"Ueno\"` instead of `name = 'Katsuhiro Ueno'` to properly match first and last names separately. The amended query now correctly retrieves distinct institution names by joining through the proper relationship tables and matching the author's first and last name components separately, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about an institution for a person: select distinct institution names from the inst table (t3.name) instead of a generic institution field. 2) When joining tables for author-institution relationships: link authors (t1) to authorship (t2) using t1.authid = t2.authid, then link authorship (t2) to institutions (t3) using t2.instid = t3.instid. 3) When matching author names: use separate first name (t1.fname = \"Katsuhiro\") and last name (t1.lname = \"Ueno\") conditions instead of a single name field. 4) When the schema requires joining through relationship tables: do not query the people table directly, but use the proper chain authors \u2192 authorship \u2192 inst."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT institution FROM people WHERE name = 'Katsuhiro Ueno';",
            "SELECT DISTINCT t3.name\nFROM Authors AS t1\nJOIN Authorship AS t2 ON t1.authID = t2.authID\nJOIN Inst AS t3 ON t2.instID = t3.instID\nWHERE t1.fname = 'Katsuhiro' AND t1.lname = 'Ueno'"
        ],
        "rule_sql": [
            "SELECT DISTINCT t3.name \nFROM Authors t1\nJOIN Authorship t2 ON t1.authID = t2.authID\nJOIN Inst t3 ON t2.instID = t3.instID\nWHERE t1.fname = 'Katsuhiro' AND t1.lname = 'Ueno'"
        ]
    },
    "4211": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "What is the role with the smallest number of employees? Find the role codes.",
        "ground_truth": "SELECT role_code FROM Employees GROUP BY role_code ORDER BY count(*) ASC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT role_code FROM employees GROUP BY role_code ORDER BY COUNT(*) ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT r.Role_Code\nFROM Roles r\nJOIN Employees e ON r.Role_Code = e.Role_Code\nGROUP BY r.Role_Code\nHAVING COUNT(e.Employee_ID) = (\n    SELECT MIN(emp_count)\n    FROM (\n        SELECT COUNT(Employee_ID) as emp_count\n        FROM Employees\n        GROUP BY Role_Code\n    )\n)",
            "SELECT r.Role_Code\nFROM Roles r\nJOIN Employees e ON r.Role_Code = e.Role_Code\nGROUP BY r.Role_Code\nHAVING COUNT(e.Employee_ID) = (\n    SELECT MIN(emp_count)\n    FROM (\n        SELECT COUNT(Employee_ID) as emp_count\n        FROM Employees\n        GROUP BY Role_Code\n    )\n);",
            "SELECT r.Role_Code\nFROM Roles r\nLEFT JOIN Employees e ON r.Role_Code = e.Role_Code\nGROUP BY r.Role_Code\nORDER BY COUNT(e.Employee_ID) ASC\nLIMIT 1;"
        ]
    },
    "5157": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "Which marketing region has the most drama workshop groups? Give me the region code.",
        "ground_truth": "SELECT Marketing_Region_Code FROM Drama_Workshop_Groups GROUP BY Marketing_Region_Code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `Marketing_Region_Code` instead of `region_code` and do use `GROUP BY Marketing_Region_Code` instead of omitting it. Do use `Drama_Workshop_Groups` as the FROM source instead of `marketing_regions` and do remove the `WHERE workshop_type = 'drama'` filter instead of keeping it since the table name already implies the workshop type. The amended query now correctly groups by marketing region code and counts workshop groups per region to find the region with the most drama workshops, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"marketing region with the most drama workshop groups\": make sure the output order: Marketing_Region_Code. 2) When the question mentions \"region code\": \"region code\" actually means \"Marketing_Region_Code\" in schema. 3) When the question asks for \"most drama workshop groups\": rank rows by count of workshop groups in descending direction and keep the first 1 row. 4) When the question asks for \"count of drama workshop groups\": compute the number of rows using the canonical key from Drama_Workshop_Groups table. 5) When the question says \"per marketing region\"/\"by region\": organize results by Marketing_Region_Code and compute count per group. 6) When choosing identifier delimiters: do not replace Marketing_Region_Code with region_code or other variations."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT region_code FROM marketing_regions WHERE workshop_type = 'drama' ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT Marketing_Region_Code\nFROM Drama_Workshop_Groups\nGROUP BY Marketing_Region_Code\nORDER BY COUNT(Workshop_Group_ID) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Marketing_Region_Code\nFROM Drama_Workshop_Groups\nGROUP BY Marketing_Region_Code\nORDER BY COUNT(Workshop_Group_ID) DESC\nLIMIT 1;"
        ]
    },
    "150": {
        "db_id": "bike_1",
        "question": "What is the average bike availablility for stations not in Palo Alto?",
        "ground_truth": "SELECT avg(bikes_available) FROM status WHERE station_id NOT IN (SELECT id FROM station WHERE city  =  \"Palo Alto\")",
        "amends": [
            "Do reference the `status` table instead of `station_status` in the FROM clause. Do use a subquery to filter by station city instead of a direct WHERE condition on city. Do filter with `station_id NOT IN` a subquery selecting `id` from the `station` table where `city = 'Palo Alto'` instead of directly filtering `city != 'Palo Alto'`. Do use lowercase `avg` instead of uppercase `AVG` for the aggregate function. The amended query now correctly excludes stations from Palo Alto by joining through the station table relationship rather than assuming city data exists in the status table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about bike availability: use the \"status\" table instead of \"station_status\" table. 2) When filtering stations by city: use a subquery to select station \"id\" from the \"station\" table where \"city\" = 'Palo Alto' instead of filtering directly on city. 3) When excluding stations from a specific city: filter using \"station_id NOT IN\" the subquery result rather than direct city comparison. 4) When computing average bike availability: use lowercase \"avg\" function instead of uppercase \"AVG\". 5) When combining station information: link through the station table relationship using station IDs rather than assuming city data exists in the status table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(bikes_available) FROM station_status WHERE city != 'Palo Alto';",
            "SELECT AVG(bikes_available) FROM status WHERE station_id NOT IN (SELECT id FROM station WHERE city = 'Palo Alto')"
        ],
        "rule_sql": [
            "SELECT avg(bikes_available) \nFROM status \nWHERE station_id NOT IN (\n    SELECT id \n    FROM station \n    WHERE city = 'Palo Alto'\n)"
        ]
    },
    "3999": {
        "db_id": "ship_mission",
        "question": "What is the number of ships?",
        "ground_truth": "SELECT count(*) FROM ship",
        "amends": [
            "Do reference the table `ship` instead of `ships` while keeping the same `COUNT(*)` aggregation and `name = 'Titanic'` filter condition, as the correct table name is singular rather than plural. The amended query now correctly counts records from the intended table with the specified filter condition.",
            "Do use lowercase `count(*)` instead of uppercase `COUNT(*)` to maintain consistent function casing. The amended query now matches the right SQL's behavior with identical functionality.",
            "Do remove the `WHERE name = 'Titanic'` filter instead of keeping it, as the correct query should count all ships in the table rather than only those named 'Titanic'. The amended query now matches the right SQL's behavior by returning the total count of all ships."
        ],
        "rules": [
            "1) When the question asks for \"number of ships\": count all rows from the table \"ship\" using COUNT(*). 2) When the question mentions \"ships\": the correct table name is \"ship\" (singular form). 3) When filtering for specific ships by name: use the exact literal 'Titanic' with the column \"name\" to match records exactly.",
            "1) When counting entities in a database: use lowercase count(*) function instead of uppercase COUNT(*) to maintain consistent function casing",
            "1) When counting all ships in the database: count all rows in the ship table without any filters. 2) When the question asks for \"number of ships\": compute the count using all rows from the ship table, not just those matching specific criteria like name = 'Titanic'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM ships WHERE name = 'Titanic';",
            "SELECT COUNT(*) FROM ship WHERE name = 'Titanic';",
            "SELECT count(*) FROM ship WHERE name = 'Titanic'",
            "SELECT count(*) FROM ship;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM ship;"
        ]
    },
    "4299": {
        "db_id": "club_1",
        "question": "Count the number of different positions in the club \"Bootup Baltimore\".",
        "ground_truth": "SELECT count(DISTINCT t2.position) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid WHERE t1.clubname  =  \"Bootup Baltimore\"",
        "amends": [
            "Do select `count(DISTINCT t2.position)` instead of `COUNT(*)` to count distinct positions rather than all rows. Do join `club AS t1` with `member_of_club AS t2` on `t1.clubid = t2.clubid` instead of querying only the `players` table to properly relate clubs with their members. Do filter on `t1.clubname = \"Bootup Baltimore\"` instead of `club = 'Bootup Baltimore'` to use the correct table and column name for club identification. The amended query now correctly counts distinct player positions for the specified club instead of counting all players, matching the intended behavior."
        ],
        "rules": [
            "1) When counting different positions for a specific club: count distinct values of t2.position instead of counting all rows. 2) When relating clubs with their members: join club AS t1 with member_of_club AS t2 on t1.clubid = t2.clubid to properly connect club and member data. 3) When filtering for a specific club name: use t1.clubname = \"Bootup Baltimore\" with exact case and double quotes as shown in the schema. 4) When the question asks for \"different positions\": ensure the count operation uses DISTINCT on the position column to count unique values only."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE club = 'Bootup Baltimore';",
            "SELECT COUNT(DISTINCT t2.Position) FROM Club AS t1 JOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID WHERE t1.ClubName = 'Bootup Baltimore'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT t2.Position) \nFROM Club AS t1 \nJOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID \nWHERE t1.ClubName = \"Bootup Baltimore\""
        ]
    },
    "1968": {
        "db_id": "products_for_hire",
        "question": "How many different product types are there?",
        "ground_truth": "SELECT count(DISTINCT product_type_code) FROM products_for_hire",
        "amends": [
            "Do count `DISTINCT product_type_code` instead of counting all rows with `COUNT(*)`. Do query from `products_for_hire` table instead of `products` table. The amended query now correctly counts distinct product types from the specified table, matching the intended behavior."
        ],
        "rules": [
            "1) When counting different product types: count distinct values of \"product_type_code\" instead of counting all rows. 2) When querying for product information: use the \"products_for_hire\" table instead of the \"products\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM products;",
            "SELECT COUNT(DISTINCT product_type_code) FROM Products_for_Hire;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT product_type_code) FROM Products_for_Hire;"
        ]
    },
    "6568": {
        "db_id": "wine_1",
        "question": "Give the distinct names of wines made before 2000 or after 2010.",
        "ground_truth": "SELECT DISTINCT Name FROM WINE WHERE YEAR  <  2000 OR YEAR  >  2010",
        "amends": [
            "Do reference table `WINE` instead of `wines` and use column `Name` instead of `name`. Do change the WHERE clause to use `OR` between the year conditions instead of `AND`, allowing selection of wines from before 2000 OR after 2010 rather than the impossible condition of both simultaneously. Do maintain `DISTINCT` and the year range filters but correct the logical operator to properly include records outside the 2000-2010 range. The amended query now matches RIGHT_SQL's behavior by correctly selecting distinct wine names from outside the specified year range."
        ],
        "rules": [
            "1) When the question asks for distinct names of wines: use DISTINCT on the exact column token \"Name\" from table \"WINE\". 2) When the question specifies wines made before 2000 or after 2010: use OR between the year conditions (year < 2000 OR year > 2010) instead of AND. 3) When referencing the wine table: use the exact table name \"WINE\" instead of \"wines\". 4) When selecting the name column: use the exact column token \"Name\" instead of \"name\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT name FROM wines WHERE year < 2000 AND year > 2010;",
            "SELECT DISTINCT Name FROM wine WHERE Year < 2000 OR Year > 2010"
        ],
        "rule_sql": [
            "SELECT DISTINCT Name FROM WINE WHERE Year < 2000 OR Year > 2010"
        ]
    },
    "6393": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "Show statement id, statement detail, account detail for accounts.",
        "ground_truth": "SELECT T1.statement_id ,  T2.statement_details ,  T1.account_details FROM Accounts AS T1 JOIN Statements AS T2 ON T1.statement_id  =  T2.statement_id",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of no aliases. Do join `Accounts AS T1` with `Statements AS T2` instead of querying only the `statements` table. Do reference columns with table prefixes `T1.statement_id`, `T2.statement_details`, and `T1.account_details` instead of unqualified `statement_id`, `account_detail`, and `statement_detail`. Do use the correct column name `statement_details` instead of `statement_detail`. Do use the correct column name `account_details` instead of `account_detail`. Do add an `INNER JOIN` condition `ON T1.statement_id = T2.statement_id` instead of omitting any join condition. The amended query now correctly retrieves data from both tables with proper joins and column references."
        ],
        "rules": [
            "1) When answering about \"statement id, statement detail, account detail for accounts\": make sure the output order: T1.statement_id, T2.statement_details, T1.account_details. 2) When the question mentions \"accounts\" and \"statements\": use Accounts as T1 and Statements as T2. 3) When combining T1 and T2 for shared entities: link rows where T1.statement_id = T2.statement_id and keep only matching pairs (inner match). 4) When referring to columns: use exact column names T1.statement_id, T2.statement_details, and T1.account_details instead of statement_id, statement_detail, and account_detail."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT statement_id, account_detail, statement_detail FROM statements",
            "SELECT T1.statement_id, T2.statement_details, T1.account_details FROM Accounts AS T1 INNER JOIN Statements AS T2 ON T1.statement_id = T2.statement_id"
        ],
        "rule_sql": [
            "SELECT T1.statement_id, T2.statement_details, T1.account_details FROM Accounts AS T1 INNER JOIN Statements AS T2 ON T1.statement_id = T2.statement_id"
        ]
    },
    "5531": {
        "db_id": "products_gen_characteristics",
        "question": "What are the names, color descriptions, and product descriptions for products in the 'Herbs' category?",
        "ground_truth": "SELECT T1.product_name ,  T2.color_description ,  T1.product_description FROM products AS T1 JOIN Ref_colors AS T2 ON T1.color_code  =  T2.color_code WHERE product_category_code  =  \"Herbs\"",
        "amends": [
            "Do reference columns with table aliases `T1.product_name`, `T2.color_description`, and `T1.product_description` instead of unqualified `name`, `color_description`, and `product_description`. Do add `JOIN Ref_colors AS T2 ON T1.color_code = T2.color_code` instead of omitting the join to the colors reference table. Do use table alias `products AS T1` instead of the unaliased table name. Do filter on `product_category_code = \"Herbs\"` instead of `category = 'Herbs'` to use the correct column name and consistent quoting. The amended query now correctly joins product data with color reference information and uses proper table qualification."
        ],
        "rules": [
            "1) When answering about product names, color descriptions, and product descriptions: make sure the output order: T1.product_name, T2.color_description, T1.product_description. 2) When the question mentions \"Herbs\" category: \"Herbs\" actually means \"product_category_code = \\\"Herbs\\\"\" in schema. 3) When combining T1 (Products) and T2 (Ref_colors) for shared entities: link rows where T1.color_code = T2.color_code exactly as shown in the amends; keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for literal values like \\\"Herbs\\\". 5) When handling text literals: do not change case, spacing, or punctuation for the value \\\"Herbs\\\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, color_description, product_description FROM products WHERE category = 'Herbs';",
            "SELECT T1.product_name, T2.color_description, T1.product_description \nFROM Products AS T1\nJOIN Ref_Colors AS T2 ON T1.color_code = T2.color_code\nWHERE T1.product_category_code = 'Herbs'"
        ],
        "rule_sql": [
            "SELECT T1.product_name, T2.color_description, T1.product_description\nFROM Products T1\nINNER JOIN Ref_Colors T2 ON T1.color_code = T2.color_code\nWHERE T1.product_category_code = \"Herbs\""
        ]
    },
    "2229": {
        "db_id": "formula_1",
        "question": "Find the driver id and number of races of all drivers who have at most participated in 30 races?",
        "ground_truth": "SELECT T1.driverid ,  count(*) FROM drivers AS T1 JOIN results AS T2 ON T1.driverid = T2.driverid JOIN races AS T3 ON T2.raceid = T3.raceid GROUP BY T1.driverid HAVING count(*)  <=  30",
        "amends": [
            "Do use `drivers AS T1` joined with `results AS T2` on `T1.driverid = T2.driverid` and `races AS T3` on `T2.raceid = T3.raceid` instead of querying only `driver_races` table. Do select `T1.driverid` instead of `driver_id` and use `count(*)` instead of `COUNT(race_id)`. Do change the HAVING condition to `count(*) <= 30` instead of `num_races > 30` and reference the aggregate directly instead of using an alias. The amended query now correctly joins the necessary tables to count races per driver and filters for drivers with 30 or fewer races, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"driver id and number of races\": make sure the output order: T1.driverid, count(*) as num_races\n2) When the question mentions \"driver id\": \"driver id\" actually means \"T1.driverid in schema\"\n3) When the question asks for \"number of races\": compute the count of all rows using count(*) after joining the necessary tables\n4) When combining T1 (drivers) and T2 (results) for shared entities: link rows where T1.driverid = T2.driverid exactly as shown; keep only matching pairs (inner match)\n5) When combining T2 (results) and T3 (races) for shared entities: link rows where T2.raceid = T3.raceid exactly as shown; keep only matching pairs (inner match)\n6) When the question asks for drivers with \"at most participated in 30 races\": filter results to include only groups where count(*) <= 30\n7) When grouping by driver: organize results by T1.driverid and compute count(*) per group"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT driver_id, COUNT(race_id) as num_races FROM driver_races GROUP BY driver_id HAVING num_races > 30;",
            "SELECT T1.driverId, COUNT(*) AS num_races\nFROM drivers AS T1\nJOIN results AS T2 ON T1.driverId = T2.driverId\nJOIN races AS T3 ON T2.raceId = T3.raceId\nGROUP BY T1.driverId\nHAVING COUNT(*) <= 30"
        ],
        "rule_sql": [
            "SELECT T1.driverId, COUNT(*) as num_races\nFROM drivers T1\nINNER JOIN results T2 ON T1.driverId = T2.driverId\nINNER JOIN races T3 ON T2.raceId = T3.raceId\nGROUP BY T1.driverId\nHAVING COUNT(*) <= 30\nORDER BY T1.driverId;"
        ]
    },
    "3091": {
        "db_id": "behavior_monitoring",
        "question": "What are the start and end dates for incidents with incident type code \"NOISE\"?",
        "ground_truth": "SELECT date_incident_start ,  date_incident_end FROM Behavior_Incident WHERE incident_type_code  =  \"NOISE\"",
        "amends": [
            "Do use column names `date_incident_start` and `date_incident_end` instead of `start_date` and `end_date`. Do reference table `Behavior_Incident` instead of `incidents`. Do use column `incident_type_code` instead of `incident_type` for the filter condition. Do use double quotes `\"NOISE\"` instead of single quotes `'NOISE'` for the string literal. The amended query now correctly retrieves noise incident start and end dates from the appropriate table with the correct column references and filter condition."
        ],
        "rules": [
            "1) When answering about \"start and end dates for incidents with incident type code 'NOISE'\": make sure the output order: date_incident_start, date_incident_end. 2) When the question mentions \"incidents\": \"incidents\" actually means \"Behavior_Incident\" in schema. 3) When the question mentions \"incident type code\": \"incident type code\" actually means \"incident_type_code\" in schema. 4) When the question mentions \"NOISE\": use the exact literal \"NOISE\" with double quotes. 5) When filtering for incident type code: use the condition incident_type_code = \"NOISE\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT start_date, end_date FROM incidents WHERE incident_type = 'NOISE';",
            "SELECT date_incident_start, date_incident_end FROM Behavior_Incident WHERE incident_type_code = \"NOISE\";"
        ],
        "rule_sql": [
            "SELECT date_incident_start, date_incident_end FROM Behavior_Incident WHERE incident_type_code = \"NOISE\""
        ]
    },
    "6644": {
        "db_id": "driving_school",
        "question": "Which country and state does staff with first name as Janessa and last name as Sawayn lived?",
        "ground_truth": "SELECT T1.country ,  T1.state_province_county FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id WHERE T2.first_name = \"Janessa\" AND T2.last_name = \"Sawayn\";",
        "amends": [
            "Do select `country` and `state_province_county` from the `Addresses` table instead of `country` and `state` from the `Staff` table. Do join `Addresses AS T1` with `Staff AS T2` on `T1.address_id = T2.staff_address_id` instead of querying only the `staff` table. Do filter on `T2.first_name` and `T2.last_name` in the `WHERE` clause instead of filtering directly on the staff table columns without proper table qualification. Do use double quotes around string literals `\"Janessa\"` and `\"Sawayn\"` instead of single quotes. The amended query now correctly retrieves address information by joining the staff and addresses tables through their relationship, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about staff address information: select \"country\" and \"state_province_county\" from the Addresses table instead of country and state from the Staff table. 2) When joining Addresses and Staff tables: link rows where T1.address_id = T2.staff_address_id and keep only matching pairs (inner match). 3) When filtering by staff name: filter on T2.first_name = \"Janessa\" and T2.last_name = \"Sawayn\" using exact string literals with double quotes. 4) When the question mentions \"country\" and \"state\": \"country\" means \"country\" in Addresses table and \"state\" means \"state_province_county\" in Addresses table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country, state FROM staff WHERE first_name = 'Janessa' AND last_name = 'Sawayn';",
            "SELECT T1.country, T1.state_province_county FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id WHERE T2.first_name = \"Janessa\" AND T2.last_name = \"Sawayn\""
        ],
        "rule_sql": [
            "SELECT a.country, a.state_province_county \nFROM Addresses a\nINNER JOIN Staff s ON a.address_id = s.staff_address_id\nWHERE s.first_name = \"Janessa\" AND s.last_name = \"Sawayn\""
        ]
    },
    "4957": {
        "db_id": "soccer_2",
        "question": "What are the names and number of hours spent training for each player who trains for less than 1500 hours?",
        "ground_truth": "SELECT pName ,  HS FROM Player WHERE HS  <  1500",
        "amends": [
            "Do select `pName` and `HS` instead of `name` and `hours`. Do use table `Player` instead of `players`. Do apply filter `HS < 1500` instead of `hours > 1500`. The amended query now correctly retrieves player names and hours played from the Player table where hours are less than 1500, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for player names and training hours: select \"pName\" and \"HS\" from table \"Player\" instead of \"name\" and \"hours\" from \"players\". 2) When filtering for players who train for less than 1500 hours: apply the condition \"HS\" < 1500 instead of \"hours\" > 1500. 3) When the question mentions \"number of hours spent training\": this refers to column \"HS\" in table \"Player\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, hours FROM players WHERE hours > 1500;",
            "SELECT pName, HS FROM Player WHERE HS < 1500"
        ],
        "rule_sql": [
            "SELECT pName, HS FROM Player WHERE HS < 1500"
        ]
    },
    "3628": {
        "db_id": "music_1",
        "question": "What are the names of the different artists from Bangladesh who never received a rating higher than a 7?",
        "ground_truth": "SELECT DISTINCT artist_name FROM artist WHERE country  =  \"Bangladesh\" EXCEPT SELECT DISTINCT artist_name FROM song WHERE rating  >  7",
        "amends": [
            "Do select `artist_name` instead of `name` and add `DISTINCT` instead of omitting it. Do reference table `artist` instead of `artists` and use double quotes around `\"Bangladesh\"` instead of single quotes. Do remove the `rating > 7` filter from the WHERE clause instead of keeping it and instead add an EXCEPT clause with a subquery that selects `DISTINCT artist_name` from table `song` with filter `rating > 7` instead of applying the rating filter directly to the artist table. The amended query now correctly excludes artists who have songs with ratings above 7 while keeping those from Bangladesh without such songs, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for artist names from a specific country: use the exact literal \"Bangladesh\" with double quotes as shown in the schema. 2) When selecting artist names: use the exact column name \"artist_name\" instead of generic \"name\". 3) When the question asks for \"different artists\": apply DISTINCT to eliminate duplicate artist names. 4) When the question mentions artists who \"never received a rating higher than a 7\": exclude artists who have any songs with rating > 7 by using an EXCEPT clause with a subquery that selects DISTINCT artist_name from the song table where rating > 7. 5) When referencing tables: use the exact table name \"artist\" instead of pluralized forms like \"artists\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM artists WHERE country = 'Bangladesh' AND rating > 7;",
            "SELECT DISTINCT artist_name FROM artist WHERE country = \"Bangladesh\"\nEXCEPT\nSELECT DISTINCT artist_name FROM song WHERE rating > 7"
        ],
        "rule_sql": [
            "SELECT DISTINCT artist_name FROM artist WHERE country = \"Bangladesh\" EXCEPT SELECT DISTINCT artist_name FROM song WHERE rating > 7"
        ]
    },
    "805": {
        "db_id": "coffee_shop",
        "question": "Which month has the most happy hours?",
        "ground_truth": "SELECT MONTH FROM happy_hour GROUP BY MONTH ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference table `happy_hour` instead of `happy_hours` in the FROM clause. Do use `MONTH` in the SELECT list instead of `month` and omit the alias `happy_hours_count`. Do move the aggregate function `count(*)` to the ORDER BY clause instead of including it in the SELECT list. The amended query now correctly identifies the month with the highest count by ordering by the count directly in the ORDER BY clause, matching the behavior of the right SQL."
        ],
        "rules": [
            "1) When referencing the table for happy hours: use the exact table name \"happy_hour\" instead of \"happy_hours\". 2) When selecting the month column: use the exact column name \"MONTH\" with the correct case. 3) When counting happy hours: use count(*) but do not include it in the SELECT list with an alias. 4) When ordering results to find the month with most happy hours: order by count(*) in descending order and limit to 1 result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT month, COUNT(*) as happy_hours_count FROM happy_hours GROUP BY month ORDER BY happy_hours_count DESC LIMIT 1;",
            "SELECT Month FROM happy_hour GROUP BY Month ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Month FROM happy_hour GROUP BY Month ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "5005": {
        "db_id": "soccer_2",
        "question": "What are the states of the colleges where students who tried out for the striker position attend?",
        "ground_truth": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'striker'",
        "amends": [
            "Do use `T1.state` instead of `c.state` for the column selection. Do reference `college AS T1` instead of `colleges c` as the primary table source. Do join `tryout AS T2` instead of joining both `students` and `tryouts` tables, removing the intermediate students table entirely. Do use the join condition `T1.cName = T2.cName` instead of `c.college_id = s.college_id` and `s.student_id = t.student_id`. Do filter with `T2.pPos = 'striker'` instead of `t.position = 'striker'` for the position condition. Do remove `DISTINCT` instead of keeping it since the join logic now ensures uniqueness. The amended query now correctly matches the right SQL's behavior by directly linking colleges to tryouts through the college name rather than through the student intermediary table."
        ],
        "rules": [
            "1) When answering about states of colleges: make sure the output order: T1.state\n2) When the question mentions \"colleges\": use table \"college AS T1\" as the primary table source\n3) When the question mentions \"students who tried out for the striker position\": join with table \"tryout AS T2\" using the condition T1.cName = T2.cName\n4) When filtering for the striker position: use the exact literal 'striker' with column T2.pPos\n5) When combining T1 and T2: link rows where T1.cName = T2.cName exactly and keep only matching pairs (inner match)\n6) When the question asks for states of colleges: do not use DISTINCT since the join logic ensures uniqueness"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT c.state \nFROM colleges c \nJOIN students s ON c.college_id = s.college_id \nJOIN tryouts t ON s.student_id = t.student_id \nWHERE t.position = 'striker';",
            "SELECT T1.state FROM College AS T1 JOIN Tryout AS T2 ON T1.cName = T2.cName WHERE T2.pPos = 'striker'"
        ],
        "rule_sql": [
            "SELECT T1.state \nFROM College AS T1\nINNER JOIN Tryout AS T2 ON T1.cName = T2.cName\nWHERE T2.pPos = 'striker'"
        ]
    },
    "1301": {
        "db_id": "soccer_1",
        "question": "What is the average rating for right-footed players and left-footed players?",
        "ground_truth": "SELECT preferred_foot ,  avg(overall_rating) FROM Player_Attributes GROUP BY preferred_foot",
        "amends": [
            "Do use `preferred_foot` instead of `foot` for the grouping column. Do use `overall_rating` instead of `rating` for the average calculation. Do reference the correct table `Player_Attributes` instead of `players`. Do remove the alias `average_rating` instead of keeping it. The amended query now correctly calculates average ratings by preferred foot from the appropriate table."
        ],
        "rules": [
            "1) When the question asks for average rating by foot preference: use \"preferred_foot\" instead of \"foot\" for grouping. 2) When calculating average rating: use \"overall_rating\" instead of \"rating\" for the average calculation. 3) When referencing player attributes data: use table \"Player_Attributes\" instead of \"players\". 4) When presenting results: do not include column aliases like \"average_rating\" in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT foot, AVG(rating) as average_rating FROM players GROUP BY foot;",
            "SELECT preferred_foot, AVG(overall_rating) FROM Player_Attributes GROUP BY preferred_foot;"
        ],
        "rule_sql": [
            "SELECT preferred_foot, AVG(overall_rating) FROM Player_Attributes GROUP BY preferred_foot;"
        ]
    },
    "5061": {
        "db_id": "device",
        "question": "Return the names and locations of shops, ordered by name in alphabetical order.",
        "ground_truth": "SELECT Shop_Name ,  LOCATION FROM shop ORDER BY Shop_Name ASC",
        "amends": [
            "Do use table alias `shop` instead of `shops` and select columns `Shop_Name` and `LOCATION` instead of `name` and `location`. Do apply `ASC` ordering on `Shop_Name` instead of `DESC` ordering on `name`. The amended query now correctly references the actual table structure and sorts in ascending order as intended."
        ],
        "rules": [
            "1) When answering about \"names and locations of shops\": make sure the output order: Shop_Name, LOCATION. 2) When the question mentions \"shops\": \"shops\" actually means \"shop\" in schema. 3) When the question mentions \"name\": \"name\" actually means \"Shop_Name\" in schema. 4) When the question mentions \"location\": \"location\" actually means \"LOCATION\" in schema. 5) When the question says \"ordered by name in alphabetical order\": order rows by Shop_Name in ascending direction (A to Z)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, location FROM shops ORDER BY name DESC;",
            "SELECT Shop_Name, Location FROM shop ORDER BY Shop_Name ASC;"
        ],
        "rule_sql": [
            "SELECT Shop_Name, Location FROM shop ORDER BY Shop_Name ASC;"
        ]
    },
    "5052": {
        "db_id": "device",
        "question": "List the carriers of devices in ascending alphabetical order.",
        "ground_truth": "SELECT Carrier FROM device ORDER BY Carrier ASC",
        "amends": [
            "Do reference the table as `device` instead of `devices` and use the column name `Carrier` instead of `carrier` to match the correct schema. Do use `ASC` ordering instead of `DESC` ordering to produce the correct sort sequence. The amended query now correctly selects from the proper table with accurate column naming and ascending sort order, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"carriers of devices\": make sure to reference the table as \"device\" instead of \"devices\". 2) When the question mentions \"carriers\": \"carriers\" actually means \"Carrier\" in schema (with exact case). 3) When the question asks for \"ascending alphabetical order\": use ASC ordering instead of DESC ordering to produce the correct sort sequence."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT carrier FROM devices ORDER BY carrier DESC;",
            "SELECT Carrier FROM device ORDER BY Carrier ASC;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Carrier FROM device ORDER BY Carrier ASC;"
        ]
    },
    "1062": {
        "db_id": "match_season",
        "question": "Show the distinct position of players from college UCLA or Duke.",
        "ground_truth": "SELECT DISTINCT POSITION FROM match_season WHERE College  =  \"UCLA\" OR College  =  \"Duke\"",
        "amends": [
            "Do select `DISTINCT POSITION` from the `match_season` table instead of `position` from the `players` table. Do use the column name `College` with double quotes around string values instead of `college` with single quotes. Do query the `match_season` table instead of the `players` table. The amended query now correctly returns distinct positions from the match_season table for players from UCLA or Duke universities."
        ],
        "rules": [
            "1) When answering about \"distinct position of players from college UCLA or Duke\": select distinct \"POSITION\" from the \"match_season\" table. 2) When the question mentions \"college UCLA or Duke\": filter rows where \"College\" equals 'UCLA' or \"College\" equals 'Duke'. 3) When choosing identifier delimiters: use double quotes around column names like \"POSITION\" and \"College\" as shown in the schema. 4) When handling text literals: use exact string values 'UCLA' and 'Duke' with single quotes as shown in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT position FROM players WHERE college = 'UCLA' OR college = 'Duke';",
            "SELECT DISTINCT \"Position\" FROM \"match_season\" WHERE \"College\" = \"UCLA\" OR \"College\" = \"Duke\""
        ],
        "rule_sql": [
            "SELECT DISTINCT \"Position\" FROM \"match_season\" WHERE \"College\" = 'UCLA' OR \"College\" = 'Duke'"
        ]
    },
    "2974": {
        "db_id": "sakila_1",
        "question": "Where is store 1 located?",
        "ground_truth": "SELECT T2.address FROM store AS T1 JOIN address AS T2 ON T1.address_id  =  T2.address_id WHERE store_id  =  1",
        "amends": [
            "Do select `T2.address` instead of `name` and change the source to `store AS T1 JOIN address AS T2` instead of just `stores`. Do add the join condition `ON T1.address_id = T2.address_id` instead of omitting it. Do change the filter to `store_id = 1` instead of `store_id = 2`. The amended query now correctly retrieves the address from the joined address table for the specified store ID."
        ],
        "rules": [
            "1) When answering about \"Where is store 1 located\": make sure the output order: T2.address 2) When the question mentions \"store 1\": \"store 1\" actually means \"T1.store_id = 1\" in schema 3) When combining T1 and T2 for shared entities: link rows where T1.address_id = T2.address_id; keep only matching pairs (inner match) 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM stores WHERE store_id = 2;",
            "SELECT T2.address FROM store AS T1 JOIN address AS T2 ON T1.address_id = T2.address_id WHERE T1.store_id = 1"
        ],
        "rule_sql": [
            "SELECT address.address FROM store JOIN address ON store.address_id = address.address_id WHERE store.store_id = 1"
        ]
    },
    "5873": {
        "db_id": "tracking_share_transactions",
        "question": "Show the number of transactions with transaction type code \"SALE\" for different investors if it is larger than 0.",
        "ground_truth": "SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  \"SALE\" GROUP BY investor_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT investor_id, COUNT(*) as transaction_count \nFROM transactions \nWHERE transaction_type_code = 'SALE' \nGROUP BY investor_id \nHAVING transaction_count > 0;"
        ],
        "rule_sql": [
            "SELECT i.investor_id, COUNT(t.transaction_id) AS transaction_count\nFROM Investors i\nJOIN Transactions t ON i.investor_id = t.investor_id\nWHERE t.transaction_type_code = 'SALE'\nGROUP BY i.investor_id\nHAVING COUNT(t.transaction_id) > 0\nORDER BY i.investor_id;"
        ]
    },
    "424": {
        "db_id": "flight_1",
        "question": "What are the names of all aircrafts that John Williams have certificates to be able to fly?",
        "ground_truth": "SELECT T3.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T1.name  =  \"John Williams\"",
        "amends": [
            "Do reference `T3.name` instead of `a.name` for the aircraft name. Do use table aliases `Employee AS T1`, `Certificate AS T2`, and `Aircraft AS T3` instead of `aircrafts a`, `certificates c`, and `pilots p`. Do join on `T1.eid = T2.eid` and `T3.aid = T2.aid` instead of `a.id = c.aircraft_id` and `c.pilot_id = p.id` using the correct column relationships. Do filter on `T1.name = \"John Williams\"` instead of separate `p.first_name = 'John' AND p.last_name = 'Williams'` conditions. The amended query now correctly joins employee, certificate, and aircraft tables using proper column relationships and filters for the employee name as a single field."
        ],
        "rules": [
            "1) When answering about aircraft names that John Williams can fly: make sure the output order: T3.name. 2) When the question mentions \"John Williams\": \"John Williams\" actually means T1.name = \"John Williams\" in schema. 3) When combining Employee (T1), Certificate (T2), and Aircraft (T3) tables: link rows where T1.eid = T2.eid and T3.aid = T2.aid exactly as shown in the amends; keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for the literal \"John Williams\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.name FROM aircrafts a JOIN certificates c ON a.id = c.aircraft_id JOIN pilots p ON c.pilot_id = p.id WHERE p.first_name = 'John' AND p.last_name = 'Williams';",
            "SELECT T3.name \nFROM Employee AS T1\nJOIN Certificate AS T2 ON T1.eid = T2.eid\nJOIN Aircraft AS T3 ON T3.aid = T2.aid\nWHERE T1.name = 'John Williams'"
        ],
        "rule_sql": [
            "SELECT T3.name \nFROM employee T1\nJOIN certificate T2 ON T1.eid = T2.eid\nJOIN aircraft T3 ON T3.aid = T2.aid\nWHERE T1.name = \"John Williams\"\nORDER BY T3.name"
        ]
    },
    "3853": {
        "db_id": "insurance_policies",
        "question": "Give me the the customer details and id for the customers who had two or more policies but did not file any claims.",
        "ground_truth": "SELECT T1.customer_details ,  T1.customer_id FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.Customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  2 EXCEPT SELECT T1.customer_details ,  T1.customer_id FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.Customer_id  =  T2.customer_id JOIN Claims AS T3 ON T2.policy_id  =  T3.policy_id",
        "amends": [
            "Do join `Customers AS T1` with `Customer_Policies AS T2` on `T1.Customer_id = T2.customer_id` instead of querying only the `customers` table. Do use `GROUP BY T1.customer_id` with `HAVING count(*) >= 2` instead of filtering `policy_count >= 2` directly. Do add an `EXCEPT` clause with a subquery joining `Claims AS T3` on `T2.policy_id = T3.policy_id` instead of filtering `claims_count > 0` directly. Do include both `T1.customer_details` and `T1.customer_id` in the SELECT list instead of just `customer_id` and `customer_details`. The amended query now correctly identifies customers with at least two policies while excluding those with any claims, matching the RIGHT_SQL's behavior.",
            "Do reverse the column order in both SELECT lists to `customer_details, customer_id` instead of `Customer_ID, Customer_Details`. Do use lowercase column names `customer_id` and `customer_details` instead of mixed case. Do fix the join condition in the second query to use `T2.policy_id = T3.policy_id` instead of `T2.Policy_ID = T3.Policy_ID`. Do maintain the same GROUP BY and HAVING logic with `COUNT(*) >= 2` to identify customers with multiple policies. Do preserve the EXCEPT operation to find customers with policies but no claims. The amended query now correctly returns customers who have at least two policies but no associated claims, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about customers with two or more policies: group by T1.customer_id and keep only groups having count(*) >= 2. 2) When excluding customers who filed any claims: use an EXCEPT clause with a subquery that joins Customer_Policies AS T2 with Claims AS T3 on T2.policy_id = T3.policy_id to identify customers with claims. 3) When combining customer information with policies: join Customers AS T1 with Customer_Policies AS T2 on T1.Customer_id = T2.customer_id using exact key equality. 4) When selecting customer details: include both T1.customer_details and T1.customer_id in the output columns. 5) When handling identifier delimiters: do not replace the exact table and column names as shown in the schema (e.g., Customer_id, customer_id, policy_id).",
            "1) When the question asks for customer details and id: output the columns in the order customer_details, customer_id. 2) When referring to customer identifiers: use lowercase column names customer_id and customer_details instead of mixed case. 3) When joining Customer_Policies and Claims tables: use the join condition T2.policy_id = T3.policy_id with lowercase column names. 4) When identifying customers with two or more policies: use GROUP BY T1.customer_id with HAVING COUNT(*) >= 2. 5) When finding customers without claims: use EXCEPT operation to exclude customers who have claims associated with their policies. 6) When combining tables for the claims check: perform an inner join between Customer_Policies and Claims using policy_id as the linking key."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT customer_id, customer_details FROM customers WHERE policy_count >= 2 AND claims_count > 0;",
            "SELECT T1.Customer_ID, T1.Customer_Details\nFROM Customers AS T1\nJOIN Customer_Policies AS T2 ON T1.Customer_ID = T2.Customer_ID\nGROUP BY T1.Customer_ID\nHAVING COUNT(*) >= 2\nEXCEPT\nSELECT T1.Customer_ID, T1.Customer_Details\nFROM Customers AS T1\nJOIN Customer_Policies AS T2 ON T1.Customer_ID = T2.Customer_ID\nJOIN Claims AS T3 ON T2.Policy_ID = T3.Policy_ID",
            "SELECT T1.customer_details, T1.customer_id\nFROM Customers AS T1\nJOIN Customer_Policies AS T2 ON T1.customer_id = T2.customer_id\nGROUP BY T1.customer_id\nHAVING COUNT(*) >= 2\nEXCEPT\nSELECT T1.customer_details, T1.customer_id\nFROM Customers AS T1\nJOIN Customer_Policies AS T2 ON T1.customer_id = T2.customer_id\nJOIN Claims AS T3 ON T2.policy_id = T3.policy_id"
        ],
        "rule_sql": [
            "SELECT T1.customer_details, T1.customer_id\nFROM Customers AS T1\nJOIN Customer_Policies AS T2 ON T1.customer_id = T2.customer_id\nGROUP BY T1.customer_id\nHAVING COUNT(*) >= 2\nEXCEPT\nSELECT T1.customer_details, T1.customer_id\nFROM Customers AS T1\nJOIN Customer_Policies AS T2 ON T1.customer_id = T2.customer_id\nJOIN Claims AS T3 ON T2.policy_id = T3.policy_id"
        ]
    },
    "4649": {
        "db_id": "college_3",
        "question": "Find the max and min grade point for all letter grade.",
        "ground_truth": "SELECT max(gradepoint) ,  min(gradepoint) FROM GRADECONVERSION",
        "amends": [
            "Do reference table `GRADECONVERSION` instead of `grades` and use column `gradepoint` instead of `grade_point`. Do remove the `letter_grade` column and grouping instead of including them. Do use aggregate functions `max(gradepoint)` and `min(gradepoint)` without aliases instead of aliasing them as `max_grade` and `min_grade`. The amended query now correctly calculates the maximum and minimum grade points from the GRADECONVERSION table without unnecessary grouping."
        ],
        "rules": [
            "1) When the question asks for maximum and minimum grade points: use the table \"GRADECONVERSION\" instead of \"grades\" and the column \"gradepoint\" instead of \"grade_point\". 2) When calculating aggregate values without grouping requirements: do not include the \"letter_grade\" column and do not use GROUP BY. 3) When computing maximum and minimum values: use aggregate functions max(gradepoint) and min(gradepoint) without aliases instead of aliasing them as \"max_grade\" and \"min_grade\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT letter_grade, MAX(grade_point) as max_grade, MIN(grade_point) as min_grade FROM grades GROUP BY letter_grade;",
            "SELECT MAX(gradepoint), MIN(gradepoint) FROM Gradeconversion;"
        ],
        "rule_sql": [
            "SELECT MAX(gradepoint), MIN(gradepoint) FROM Gradeconversion;"
        ]
    },
    "1164": {
        "db_id": "body_builder",
        "question": "What is the most common birth place of people?",
        "ground_truth": "SELECT Birth_Place FROM people GROUP BY Birth_Place ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select only `Birth_Place` instead of including both `birthplace` and `COUNT(*) as count` in the SELECT list. Do use the correct column name `Birth_Place` instead of `birthplace` for both the SELECT and GROUP BY clauses. Do move the aggregate function `COUNT(*)` to the ORDER BY clause instead of including it in the SELECT list. Do maintain the same DESC ordering and LIMIT 1 constraint to return the most common birth place. The amended query now correctly returns only the Birth_Place value with the highest count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the most common birth place: select only the exact column \"Birth_Place\" from the people table. 2) When counting occurrences to find the most common value: count all rows using COUNT(*) but do not include the count in the output columns. 3) When grouping by birth place: group by the exact column \"Birth_Place\" to organize results by each unique birth place value. 4) When determining the most common value: order the results by the count of occurrences in descending order (DESC) to put the highest count first. 5) When returning only the single most common value: limit the results to 1 row to return only the birth place with the highest count."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT birthplace, COUNT(*) as count FROM people GROUP BY birthplace ORDER BY count DESC LIMIT 1;",
            "SELECT Birth_Place FROM people GROUP BY Birth_Place ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Birth_Place FROM people GROUP BY Birth_Place ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "4949": {
        "db_id": "soccer_2",
        "question": "How many different colleges are there?",
        "ground_truth": "SELECT count(*) FROM College",
        "amends": [
            "Do reference the table as `College` instead of `colleges` to match the correct table name. The amended query now correctly counts records from the College table."
        ],
        "rules": [
            "1) When answering about \"how many different colleges\": make sure to reference the exact table name \"College\" instead of \"colleges\" 2) When counting entities from the College table: count using the canonical key for colleges (typically the primary key column) to get the number of different colleges"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM colleges;",
            "SELECT COUNT(DISTINCT cName) FROM College;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT cName) FROM College;"
        ]
    },
    "129": {
        "db_id": "bike_1",
        "question": "How many stations does Mountain View city has?",
        "ground_truth": "SELECT COUNT(*) FROM station WHERE city  =  \"Mountain View\"",
        "amends": [
            "Do reference table `station` instead of `stations` in the FROM clause. Do use double quotes `\"Mountain View\"` instead of single quotes `'Mountain View'` for the string literal in the WHERE filter. The amended query now correctly counts records from the station table where city equals Mountain View, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"How many stations does Mountain View city has?\": make sure the output order: count of stations\n2) When the question mentions \"stations\": \"stations\" actually means \"station\" in schema\n3) When the question mentions \"Mountain View\": use the exact literal \"Mountain View\" with double quotes\n4) When the question asks for \"count of stations\": compute the number of rows using the canonical key from the station table"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM stations WHERE city = 'Mountain View';",
            "SELECT COUNT(*) FROM station WHERE city = \"Mountain View\";"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS \"count of stations\" FROM station WHERE city = \"Mountain View\";"
        ]
    },
    "4763": {
        "db_id": "department_store",
        "question": "List the name and phone number of all suppliers in the alphabetical order of their addresses.",
        "ground_truth": "SELECT T1.supplier_name ,  T1.supplier_phone FROM Suppliers AS T1 JOIN supplier_addresses AS T2 ON T1.supplier_id  =  T2.supplier_id JOIN addresses AS T3 ON T2.address_id  =  T3.address_id ORDER BY T3.address_details",
        "amends": [
            "Do select `T1.supplier_name` and `T1.supplier_phone` instead of `name` and `phone`. Do add `FROM Suppliers AS T1` with two additional joins to `supplier_addresses AS T2` on `T1.supplier_id = T2.supplier_id` and `addresses AS T3` on `T2.address_id = T3.address_id` instead of the single table `suppliers`. Do change the `ORDER BY` to `T3.address_details` instead of `name ASC`. The amended query now correctly joins related tables to access address details for ordering and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting supplier information: use T1.supplier_name and T1.supplier_phone instead of generic name and phone columns. 2) When accessing supplier address information: join Suppliers AS T1 to supplier_addresses AS T2 on T1.supplier_id = T2.supplier_id, then join to addresses AS T3 on T2.address_id = T3.address_id. 3) When ordering suppliers alphabetically by address: use T3.address_details for ordering instead of supplier name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, phone FROM suppliers ORDER BY name ASC;",
            "SELECT T1.supplier_name, T1.supplier_phone\nFROM Suppliers AS T1\nJOIN Supplier_Addresses AS T2 ON T1.supplier_id = T2.supplier_id\nJOIN Addresses AS T3 ON T2.address_id = T3.address_id\nORDER BY T3.address_details ASC;"
        ],
        "rule_sql": [
            "SELECT T1.supplier_name, T1.supplier_phone\nFROM Suppliers AS T1\nJOIN Supplier_Addresses AS T2 ON T1.supplier_id = T2.supplier_id\nJOIN Addresses AS T3 ON T2.address_id = T3.address_id\nORDER BY T3.address_details ASC;"
        ]
    },
    "4005": {
        "db_id": "ship_mission",
        "question": "What are the names of the ships that are not from the United States?",
        "ground_truth": "SELECT Name FROM ship WHERE Nationality != \"United States\"",
        "amends": [
            "Do reference the table as `ship` instead of `ships` and use column `Name` instead of `name`. Do use the inequality filter `Nationality != \"United States\"` instead of the equality filter `country = 'United States'` to exclude rather than include records. The amended query now correctly selects from the appropriate table with the proper column names and filtering logic to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks about ships: use the table name \"ship\" exactly as specified in the schema, not \"ships\". 2) When selecting ship names: use the column \"Name\" exactly as shown in the schema, not \"name\". 3) When filtering by nationality: use the column \"Nationality\" with the exact literal value \"United States\" in double quotes. 4) When excluding ships from a specific country: use the inequality operator (!=) to filter out records where Nationality equals \"United States\", rather than using equality to include them."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM ships WHERE country = 'United States';",
            "SELECT Name FROM ship WHERE Nationality != \"United States\""
        ],
        "rule_sql": [
            "SELECT Name FROM ship WHERE Nationality != \"United States\";"
        ]
    },
    "3461": {
        "db_id": "hr_1",
        "question": "Find employee with ID and name of the country presently where (s)he is working.",
        "ground_truth": "SELECT T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id",
        "amends": [
            "Do join `departments AS T2` on `T1.department_id = T2.department_id` instead of omitting it, then join `locations AS T3` on `T2.location_id = T3.location_id` instead of omitting it, and do join `countries AS T4` on `T3.country_id = T4.country_id` instead of directly joining `countries` on `employees.country_id = countries.country_id`. Do remove the WHERE condition `employees.current_location = countries.country_name` instead of keeping it, and do use table aliases `T1` and `T4` for column references instead of direct table names. The amended query now correctly navigates the employee-department-location-country hierarchy to retrieve country names."
        ],
        "rules": [
            "1) When answering about \"employee with ID and name of the country where they are working\": make sure the output order: employee_id, country_name\n2) When combining tables for employee location information: link T1 (employees) to T2 (departments) where T1.department_id = T2.department_id, then link T2 to T3 (locations) where T2.location_id = T3.location_id, then link T3 to T4 (countries) where T3.country_id = T4.country_id, keeping only matching pairs (inner match)\n3) When the question asks for country name: use T4.country_name as the exact token for country name\n4) When the question asks for employee ID: use T1.employee_id as the exact token for employee identification\n5) When the question mentions \"presently where (s)he is working\": do not use any WHERE condition involving current_location or country_name comparison, as the location is determined through the department-location-country hierarchy"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT employee_id, country_name FROM employees JOIN countries ON employees.country_id = countries.country_id WHERE employees.current_location = countries.country_name;",
            "SELECT T1.EMPLOYEE_ID, T4.COUNTRY_NAME\nFROM employees AS T1\nJOIN departments AS T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID\nJOIN locations AS T3 ON T2.LOCATION_ID = T3.LOCATION_ID\nJOIN countries AS T4 ON T3.COUNTRY_ID = T4.COUNTRY_ID"
        ],
        "rule_sql": [
            "SELECT e.EMPLOYEE_ID, c.COUNTRY_NAME\nFROM employees e\nINNER JOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nINNER JOIN locations l ON d.LOCATION_ID = l.LOCATION_ID\nINNER JOIN countries c ON l.COUNTRY_ID = c.COUNTRY_ID\nORDER BY e.EMPLOYEE_ID, c.COUNTRY_NAME"
        ]
    },
    "4234": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "What are the names of the employees who authorised the destruction and the employees who destroyed the corresponding documents?",
        "ground_truth": "SELECT T2.employee_name ,  T3.employee_name FROM Documents_to_be_destroyed AS T1 JOIN Employees AS T2 ON T1.Destruction_Authorised_by_Employee_ID = T2.employee_id JOIN Employees AS T3 ON T1.Destroyed_by_Employee_ID = T3.employee_id;",
        "amends": [
            "Do use explicit `JOIN` syntax instead of comma-separated `FROM` clauses. Do join `Documents_to_be_destroyed` table instead of omitting it. Do join `Employees` as `T2` on `Destruction_Authorised_by_Employee_ID = T2.employee_id` instead of incorrectly joining two employee instances on the same `employee_id`. Do add a second join to `Employees` as `T3` on `Destroyed_by_Employee_ID = T3.employee_id` instead of the incorrect self-join. Do select `T2.employee_name` and `T3.employee_name` instead of `authorizer.name` and `destroyer.name` which don't exist in the schema. The amended query now correctly retrieves authorized and destroyer employee names from the proper relationships in the document destruction process."
        ],
        "rules": [
            "1) When joining tables for document destruction relationships: use explicit JOIN syntax instead of comma-separated FROM clauses. 2) When answering about employees who authorized destruction and destroyed documents: include the Documents_to_be_destroyed table to establish the relationship between authorization and destruction actions. 3) When linking employees to authorization actions: join Employees as T2 on Documents_to_be_destroyed.Destruction_Authorised_by_Employee_ID = T2.employee_id to find the authorizing employee. 4) When linking employees to destruction actions: join Employees as T3 on Documents_to_be_destroyed.Destroyed_by_Employee_ID = T3.employee_id to find the destroying employee. 5) When selecting employee names: use T2.employee_name for the authorizer and T3.employee_name for the destroyer instead of non-existent authorizer.name and destroyer.name columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT authorizer.name AS authorizer_name, destroyer.name AS destroyer_name \nFROM employees authorizer, employees destroyer \nWHERE authorizer.employee_id = destroyer.employee_id",
            "SELECT \n    T2.Employee_Name AS Authorising_Employee_Name,\n    T3.Employee_Name AS Destroying_Employee_Name\nFROM \n    Documents_to_be_Destroyed DTD\nJOIN \n    Employees T2 ON DTD.Destruction_Authorised_by_Employee_ID = T2.Employee_ID\nJOIN \n    Employees T3 ON DTD.Destroyed_by_Employee_ID = T3.Employee_ID;"
        ],
        "rule_sql": [
            "SELECT \n    T2.Employee_Name AS Authorizing_Employee_Name,\n    T3.Employee_Name AS Destroying_Employee_Name\nFROM \n    Documents_to_be_Destroyed D\nJOIN \n    Employees T2 ON D.Destruction_Authorised_by_Employee_ID = T2.Employee_ID\nJOIN \n    Employees T3 ON D.Destroyed_by_Employee_ID = T3.Employee_ID;"
        ]
    },
    "6032": {
        "db_id": "game_1",
        "question": "What is the total number of hours per week and number of games played by students under 20?",
        "ground_truth": "SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.age  <  20",
        "amends": [
            "Do select `sum(hoursperweek)` and `sum(gamesplayed)` instead of `SUM(hours_per_week)` as `total_hours` and `COUNT(*)` as `games_played`. Do join `Sportsinfo AS T1` with `Student AS T2` on `T1.StuID = T2.StuID` instead of querying only the `students` table. Do filter with `T2.age < 20` instead of `age > 20`. Do remove the column aliases instead of keeping them. The amended query now correctly aggregates sports data from joined tables with the proper age filter."
        ],
        "rules": [
            "1) When answering about \"total number of hours per week and number of games played by students under 20\": make sure the output order: sum(hoursperweek), sum(gamesplayed) 2) When combining Sportsinfo AS T1 and Student AS T2 for shared entities: link rows where T1.StuID = T2.StuID exactly as shown; keep only matching pairs (inner match) 3) When filtering for students under 20: use T2.age < 20 instead of age > 20 4) When the question asks for \"total number of hours per week\": compute sum(hoursperweek) instead of SUM(hours_per_week) 5) When the question asks for \"number of games played\": compute sum(gamesplayed) instead of COUNT(*) 6) When producing output: do not use column aliases like total_hours or games_played"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(hours_per_week) as total_hours, COUNT(*) as games_played FROM students WHERE age > 20;",
            "SELECT SUM(T1.HoursPerWeek), SUM(T1.GamesPlayed) FROM SportsInfo AS T1 JOIN Student AS T2 ON T1.StuID = T2.StuID WHERE T2.Age < 20"
        ],
        "rule_sql": [
            "SELECT SUM(T1.HoursPerWeek), SUM(T1.GamesPlayed) FROM SportsInfo AS T1 INNER JOIN Student AS T2 ON T1.StuID = T2.StuID WHERE T2.Age < 20"
        ]
    },
    "4002": {
        "db_id": "ship_mission",
        "question": "What are the type and nationality of ships?",
        "ground_truth": "SELECT TYPE ,  Nationality FROM ship",
        "amends": [
            "Do select `TYPE` and `Nationality` instead of `name` and `type`. Do use table `ship` instead of `ships`. The amended query now correctly retrieves the specified columns from the appropriate table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"type and nationality of ships\": select columns \"TYPE\" and \"Nationality\" from table \"ship\" instead of \"name\" and \"type\" from \"ships\". 2) When referring to the ships table: use the exact table name \"ship\" (singular) rather than \"ships\" (plural). 3) When outputting results: maintain the column order as \"TYPE\" followed by \"Nationality\" as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, type FROM ships;",
            "SELECT Type, Nationality FROM ship;"
        ],
        "rule_sql": [
            "SELECT Type, Nationality FROM ship;"
        ]
    },
    "5209": {
        "db_id": "music_2",
        "question": "How many songs use drums as an instrument?",
        "ground_truth": "SELECT count(*) FROM instruments WHERE instrument  =  \"drums\"",
        "amends": [
            "Do query the `instruments` table instead of the `songs` table. Do use double quotes `\"drums\"` instead of single quotes `'drums'` for the string literal. The amended query now correctly counts records from the instruments table where the instrument is drums, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"songs use drums as an instrument\": query the \"instruments\" table instead of the \"songs\" table. 2) When the question mentions \"drums\" as an instrument: use the exact string literal \"drums\" with double quotes. 3) When counting records where instrument is drums: count records from the \"instruments\" table where the instrument column equals \"drums\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM songs WHERE instrument = 'drums';",
            "SELECT COUNT(*) FROM Instruments WHERE Instrument = \"drums\";"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT SongId) FROM Instruments WHERE Instrument = \"drums\";"
        ]
    },
    "5600": {
        "db_id": "products_gen_characteristics",
        "question": "How many colors are never used by any product?",
        "ground_truth": "SELECT count(*) FROM Ref_colors WHERE color_code NOT IN ( SELECT color_code FROM products )",
        "amends": [
            "Do use table `Ref_colors` instead of `products` for the main query source. Do reference column `color_code` instead of `color` in both the SELECT list and subquery. Do remove the `DISTINCT` aggregation and use `count(*)` instead of `COUNT(DISTINCT color)`. Do change the subquery to select from `products` table instead of the same table as the outer query. Do maintain the `NOT IN` predicate structure but with corrected column references. The amended query now correctly counts distinct color codes from the reference table that don't exist in the products table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about colors never used by any product: use table \"Ref_colors\" as the main source instead of \"products\" table. 2) When referencing color codes in queries: use column \"color_code\" instead of \"color\" for both selection and filtering operations. 3) When counting unused colors: use count(*) instead of COUNT(DISTINCT color) and remove DISTINCT aggregation. 4) When checking for unused colors: use a subquery that selects from \"products\" table while the outer query selects from \"Ref_colors\" table. 5) When filtering for colors not present in products: maintain the NOT IN predicate structure with corrected column references between \"Ref_colors.color_code\" and the subquery selecting \"products.color_code\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT color) FROM products WHERE color NOT IN (SELECT color FROM products);",
            "SELECT COUNT(*) \nFROM Ref_Colors \nWHERE color_code NOT IN (SELECT color_code FROM Products)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Ref_Colors WHERE color_code NOT IN (SELECT color_code FROM Products)"
        ]
    },
    "4502": {
        "db_id": "document_management",
        "question": "What is the name of the document which has been accessed the most times, as well as the number of times it has been accessed?",
        "ground_truth": "SELECT document_name ,  access_count FROM documents ORDER BY access_count DESC LIMIT 1",
        "amends": [
            "Do select `document_name` and `access_count` directly from the `documents` table instead of selecting `document_name` and calculating `COUNT(*) as access_count` from the `document_access` table. Do remove the `GROUP BY document_name` clause instead of grouping by document name. Do remove the aggregation function `COUNT(*)` instead of using it to calculate access counts. Do query from the `documents` table instead of the `document_access` table, as the right query assumes access counts are pre-calculated and stored directly. The amended query now matches the right SQL's behavior of retrieving pre-calculated access counts from the documents table rather than dynamically counting access events."
        ],
        "rules": [
            "1) When answering about \"the document which has been accessed the most times\": select the document with the highest access_count value from the Documents table. 2) When the question asks for \"the name of the document\" and \"the number of times it has been accessed\": output both document_name and access_count columns from the Documents table. 3) When finding the most accessed document: order rows by access_count in descending order and keep only the first row. 4) When selecting from the Documents table: use the exact column names document_name and access_count as they appear in the schema. 5) When handling access counts: retrieve the pre-calculated access_count values directly from the Documents table instead of counting access events dynamically."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_name, COUNT(*) as access_count FROM document_access GROUP BY document_name ORDER BY access_count DESC LIMIT 1;",
            "SELECT document_name, access_count FROM Documents ORDER BY access_count DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT document_name, access_count FROM Documents ORDER BY access_count DESC LIMIT 1;"
        ]
    },
    "791": {
        "db_id": "coffee_shop",
        "question": "Give me the names of members whose address is in Harford or Waterbury.",
        "ground_truth": "SELECT name FROM member WHERE address  =  'Harford' OR address  =  'Waterbury'",
        "amends": [
            "Do reference table `member` instead of `members` in the FROM clause, correcting the table name to match the actual schema. The amended query now correctly selects from the `member` table instead of the non-existent `members` table, ensuring it returns names from members with addresses in either Harford or Waterbury as intended."
        ],
        "rules": [
            "1) When the question asks for member names from a specific table: use the exact table name \"member\" instead of \"members\" as shown in the schema. 2) When filtering by address values \"Harford\" or \"Waterbury\": use the exact string literals 'Harford' and 'Waterbury' with proper case and spelling. 3) When selecting member names: ensure the output column is \"name\" from the \"member\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM members WHERE address = 'Harford' OR address = 'Waterbury';",
            "SELECT Name FROM member WHERE Address = 'Harford' OR Address = 'Waterbury'"
        ],
        "rule_sql": [
            "SELECT name FROM member WHERE Address = 'Harford' OR Address = 'Waterbury'"
        ]
    },
    "487": {
        "db_id": "allergy_1",
        "question": "Show the student id of the oldest student.",
        "ground_truth": "SELECT StuID FROM Student WHERE age  =  (SELECT max(age) FROM Student)",
        "amends": [
            "Do select `StuID` instead of `student_id` and use a subquery to find the maximum age instead of ordering by age ascending with limit. Do change the table name to `Student` instead of `students` and add a WHERE filter comparing age to the maximum age instead of using ORDER BY with LIMIT. Do remove the ORDER BY and LIMIT clauses entirely instead of keeping them, as the subquery approach correctly identifies students with the maximum age rather than just the youngest student. The amended query now matches the right SQL's behavior of finding all students with the maximum age value."
        ],
        "rules": [
            "1) When the question asks for \"student id\": use the exact column token \"StuID\" from the Student table instead of \"student_id\". 2) When the question asks for the \"oldest student\": find students with the maximum age value using a subquery approach instead of ordering by age ascending with limit. 3) When referring to the student table: use the exact table name \"Student\" instead of \"students\". 4) When filtering for oldest students: use a WHERE clause comparing age to the maximum age from a subquery instead of using ORDER BY with LIMIT. 5) When the question asks for all oldest students: ensure the query returns all students with the maximum age value rather than just one student."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id FROM students ORDER BY age ASC LIMIT 1;",
            "SELECT StuID FROM Student WHERE Age = (SELECT MAX(Age) FROM Student)"
        ],
        "rule_sql": [
            "SELECT StuID FROM Student WHERE Age = (SELECT MAX(Age) FROM Student)"
        ]
    },
    "1432": {
        "db_id": "college_2",
        "question": "Find the name and salary of instructors who are advisors of the students from the Math department.",
        "ground_truth": "SELECT T2.name ,  T2.salary FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id WHERE T3.dept_name  =  'Math'",
        "amends": [
            "Do use `advisor` table as `T1` instead of omitting it, and join `instructor` as `T2` on `T1.i_id = T2.id` instead of directly joining `instructor` to `student` on `i.id = s.advisor_id`. Do add a second join to `student` as `T3` on `T1.s_id = T3.id` instead of joining directly, and filter on `T3.dept_name = 'Math'` instead of `s.department = 'Math'`. Do reference columns as `T2.name` and `T2.salary` instead of `i.name` and `i.salary`. The amended query now correctly uses the advisor relationship table to connect instructors to students and filters by department name, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about instructors who are advisors of students from a specific department: use the advisor table as T1 to connect instructors and students instead of direct joins. 2) When joining instructor table: join as T2 on T1.i_id = T2.id to link advisors to their instructor records. 3) When joining student table: join as T3 on T1.s_id = T3.id to link advisors to their student records. 4) When filtering by Math department: use T3.dept_name = 'Math' with exact literal 'Math'. 5) When selecting instructor name and salary: reference columns as T2.name and T2.salary from the instructor table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT i.name, i.salary FROM instructor i JOIN student s ON i.id = s.advisor_id WHERE s.department = 'Math';",
            "SELECT T2.name, T2.salary\nFROM advisor AS T1\nJOIN instructor AS T2 ON T1.i_ID = T2.ID\nJOIN student AS T3 ON T1.s_ID = T3.ID\nWHERE T3.dept_name = 'Math'"
        ],
        "rule_sql": [
            "SELECT T2.name, T2.salary\nFROM advisor AS T1\nJOIN instructor AS T2 ON T1.i_ID = T2.ID\nJOIN student AS T3 ON T1.s_ID = T3.ID\nWHERE T3.dept_name = 'Math'"
        ]
    },
    "2202": {
        "db_id": "formula_1",
        "question": "What are the different names of all the races in reverse alphabetical order?",
        "ground_truth": "SELECT DISTINCT name FROM races ORDER BY name DESC",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM races ORDER BY name ASC;"
        ],
        "rule_sql": [
            "SELECT name FROM races ORDER BY name DESC;"
        ]
    },
    "2291": {
        "db_id": "entrepreneur",
        "question": "What are the investors that have invested in at least two entrepreneurs?",
        "ground_truth": "SELECT Investor FROM entrepreneur GROUP BY Investor HAVING COUNT(*)  >=  2",
        "amends": [
            "Do reference table `entrepreneur` instead of `investments` and column `Investor` instead of `investor_name` in the SELECT and GROUP BY clauses. Do use `COUNT(*) >= 2` instead of `COUNT(entrepreneur_id) >= 1` in the HAVING clause to count all rows with a higher threshold. The amended query now correctly filters for investors with at least two entrepreneur relationships in the entrepreneur table."
        ],
        "rules": [
            "1) When answering about \"investors that have invested in at least two entrepreneurs\": use table \"entrepreneur\" instead of \"investments\" and column \"Investor\" instead of \"investor_name\" in both SELECT and GROUP BY clauses. 2) When counting entrepreneurs per investor: use COUNT(*) >= 2 instead of COUNT(entrepreneur_id) >= 1 to count all rows with the correct threshold. 3) When the question asks for \"investors that have invested in at least two entrepreneurs\": filter for investors with at least two entrepreneur relationships in the entrepreneur table using the exact column \"Investor\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT investor_name FROM investments GROUP BY investor_name HAVING COUNT(entrepreneur_id) >= 1;",
            "SELECT Investor FROM entrepreneur GROUP BY Investor HAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT Investor FROM entrepreneur GROUP BY Investor HAVING COUNT(*) >= 2"
        ]
    },
    "3566": {
        "db_id": "music_1",
        "question": "What is the gender and name of the artist who sang the song with the smallest resolution?",
        "ground_truth": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT 1",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of no aliases. Do select `T1.artist_name` instead of `name` and join `artist AS T1` with `song AS T2` instead of querying only from `artists`. Do perform a `JOIN` on `T1.artist_name = T2.artist_name` instead of using a subquery with `artist_id` comparison. Do remove the `WHERE` clause with subquery entirely instead of keeping it. Do add `ORDER BY T2.resolution` instead of ordering within the subquery. Do add `LIMIT 1` at the main query level instead of within a subquery. The amended query now correctly joins artist and song tables to find the artist with the highest resolution song."
        ],
        "rules": [
            "1) When answering about the artist who sang the song with the smallest resolution: make sure the output order includes T1.gender and T1.artist_name. 2) When combining artist table as T1 and song table as T2: link rows where T1.artist_name = T2.artist_name exactly as shown and keep only matching pairs (inner match). 3) When the question asks for the song with the smallest resolution: order rows by T2.resolution in ascending direction and keep only the first 1 row. 4) When the question mentions \"name\": \"name\" actually means \"T1.artist_name\" in schema. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT gender, name FROM artists WHERE artist_id = (SELECT artist_id FROM songs ORDER BY resolution ASC LIMIT 1);",
            "SELECT T1.gender, T1.artist_name \nFROM artist AS T1 \nJOIN song AS T2 ON T1.artist_name = T2.artist_name \nORDER BY T2.resolution ASC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.gender, T1.artist_name FROM artist T1 INNER JOIN song T2 ON T1.artist_name = T2.artist_name ORDER BY T2.resolution ASC LIMIT 1"
        ]
    },
    "1282": {
        "db_id": "game_injury",
        "question": "What are the id and name of the stadium where the most injury accidents happened?",
        "ground_truth": "SELECT T1.id ,  T1.name FROM stadium AS T1 JOIN game AS T2 ON T1.id  =  T2.stadium_id JOIN injury_accident AS T3 ON T2.id  =  T3.game_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.id` and `T1.name` with table aliases instead of `stadium_id` and `name` without aliases. Do join `stadium AS T1` with `game AS T2` on `T1.id = T2.stadium_id` and then join `injury_accident AS T3` on `T2.id = T3.game_id` instead of querying only the `stadiums` table. Do add `GROUP BY T1.id` and aggregate with `count(*)` instead of using the raw `injury_count` column. Do order by `count(*) DESC` instead of `injury_count DESC` to properly count injury accidents per stadium. The amended query now correctly identifies the stadium with the most injury accidents by joining related tables and counting incidents."
        ],
        "rules": [
            "1) When answering about \"id and name of the stadium where the most injury accidents happened\": make sure the output order: T1.id, T1.name\n2) When the question mentions \"stadium\": use table \"stadium AS T1\" with columns T1.id and T1.name\n3) When combining stadium (T1) and game (T2) for shared entities: link rows where T1.id = T2.stadium_id and keep only matching pairs (inner match)\n4) When combining game (T2) and injury_accident (T3) for shared entities: link rows where T2.id = T3.game_id and keep only matching pairs (inner match)\n5) When the question asks for \"count of injury accidents per stadium\": compute the number of rows using count(*) grouped by T1.id\n6) When the question mentions \"most\" injury accidents: rank stadiums by count(*) in descending order and keep the first 1 row\n7) When grouping by stadium: organize results by T1.id and compute count(*) per group"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT stadium_id, name FROM stadiums ORDER BY injury_count DESC LIMIT 1;",
            "SELECT T1.id, T1.name\nFROM stadium AS T1\nJOIN game AS T2 ON T1.id = T2.stadium_id\nJOIN injury_accident AS T3 ON T2.id = T3.game_id\nGROUP BY T1.id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.id, T1.name\nFROM stadium AS T1\nINNER JOIN game AS T2 ON T1.id = T2.stadium_id\nINNER JOIN injury_accident AS T3 ON T2.id = T3.game_id\nGROUP BY T1.id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "5009": {
        "db_id": "soccer_2",
        "question": "In which state is the college that Charles attends?",
        "ground_truth": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  'Charles'",
        "amends": [
            "Do add tables `college AS T1`, `tryout AS T2`, and `player AS T3` instead of querying only `colleges`. Do use `JOIN` operations with `ON T1.cName = T2.cName` and `ON T2.pID = T3.pID` instead of a single table query. Do change the filter to `T3.pName = 'Charles'` instead of `student_name = 'Charles'`. Do select `T1.state` instead of just `state`. The amended query now correctly joins multiple tables to find the state where a player named Charles attended college, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"which state is the college that Charles attends\": make sure the output order: T1.state. 2) When the question mentions \"Charles\": \"Charles\" actually means T3.pName = 'Charles' in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.cName = T2.cName exactly as shown in the amends; keep only matching pairs (inner match). 4) When combining T2 and T3 for shared entities: link rows where T2.pID = T3.pID exactly as shown in the amends; keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT state FROM colleges WHERE student_name = 'Charles';",
            "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName = T2.cName JOIN player AS T3 ON T2.pID = T3.pID WHERE T3.pName = 'Charles'"
        ],
        "rule_sql": [
            "SELECT T1.state\nFROM College T1\nINNER JOIN Tryout T2 ON T1.cName = T2.cName\nINNER JOIN Player T3 ON T2.pID = T3.pID\nWHERE T3.pName = 'Charles'"
        ]
    },
    "2961": {
        "db_id": "sakila_1",
        "question": "What is the full name and id of the customer who has the lowest total amount of payment?",
        "ground_truth": "SELECT T1.first_name ,  T1.last_name ,  T1.customer_id FROM customer AS T1 JOIN payment AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY sum(amount) ASC LIMIT 1",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of direct table names. Do add a `JOIN` with the `payment` table on `T1.customer_id = T2.customer_id` instead of using a correlated subquery in the ORDER BY clause. Do include `GROUP BY T1.customer_id` to aggregate payments per customer instead of ordering by a subquery result. Do move the `SUM(amount)` calculation from the subquery to the main query's ORDER BY clause instead of embedding it in a subquery. Do remove the correlated subquery entirely instead of keeping it for ordering. The amended query now correctly aggregates payment amounts per customer and orders by the total sum, matching the RIGHT_SQL's behavior.",
            "Do include `first_name` and `last_name` in the SELECT list instead of omitting them from the GROUP BY clause, which would cause an error. Do reference `sum(amount)` without table alias instead of `SUM(T2.amount)` with table alias in the ORDER BY clause. The amended query now correctly includes all non-aggregated columns in GROUP BY and uses consistent column references, matching the RIGHT_SQL's behavior.",
            "Do select only `T1.first_name`, `T1.last_name`, and `T1.customer_id` instead of including `SUM(T2.amount)` with an alias. Do remove `T1.first_name` and `T1.last_name` from the `GROUP BY` clause instead of grouping by all three columns. Do use `ORDER BY sum(amount)` directly instead of ordering by the alias `total_payment`. The amended query now correctly identifies customers with minimal payments while maintaining proper aggregation semantics."
        ],
        "rules": [
            "1) When answering about \"customer with lowest total payment amount\": make sure to combine customer and payment information by linking rows where T1.customer_id = T2.customer_id and keep only matching pairs (inner match). 2) When computing total payment amount per customer: organize results by T1.customer_id and calculate the sum of T2.amount for each group. 3) When finding the customer with the lowest total payment: rank rows by the sum of T2.amount in ascending order and keep the first 1 row. 4) When outputting customer information: include T1.customer_id, T1.first_name, and T1.last_name in the results.",
            "1) When answering about \"customer who has the lowest total amount of payment\": make sure the output order includes customer_id, first_name, and last_name. 2) When grouping by customer_id: include all non-aggregated columns (first_name and last_name) in the GROUP BY clause to avoid errors. 3) When ordering by the sum of payment amounts: reference the amount column without table alias (sum(amount)) instead of with table alias (SUM(T2.amount)) for consistent column references.",
            "1) When answering about \"the customer who has the lowest total amount of payment\": make sure the output order includes only T1.first_name, T1.last_name, and T1.customer_id without including the sum amount in the final output. 2) When grouping by customer_id for aggregation: group only by T1.customer_id instead of including T1.first_name and T1.last_name in the GROUP BY clause. 3) When ordering by the sum of payment amounts: use ORDER BY sum(amount) directly instead of ordering by an alias for the sum."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_id, first_name, last_name FROM customers ORDER BY (SELECT SUM(amount) FROM payments WHERE payments.customer_id = customers.customer_id) ASC LIMIT 1;",
            "SELECT T1.customer_id, T1.first_name, T1.last_name\nFROM customer T1\nJOIN payment T2 ON T1.customer_id = T2.customer_id\nGROUP BY T1.customer_id\nORDER BY SUM(T2.amount) ASC\nLIMIT 1",
            "SELECT T1.customer_id, T1.first_name, T1.last_name, SUM(T2.amount) AS total_payment\nFROM customer T1\nJOIN payment T2 ON T1.customer_id = T2.customer_id\nGROUP BY T1.customer_id, T1.first_name, T1.last_name\nORDER BY total_payment ASC\nLIMIT 1",
            "SELECT T1.first_name, T1.last_name, T1.customer_id\nFROM customer T1\nJOIN payment T2 ON T1.customer_id = T2.customer_id\nGROUP BY T1.customer_id\nORDER BY SUM(T2.amount) ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT c.customer_id, c.first_name, c.last_name\nFROM customer c\nINNER JOIN payment p ON c.customer_id = p.customer_id\nGROUP BY c.customer_id\nORDER BY SUM(p.amount) ASC\nLIMIT 1;"
        ]
    },
    "6968": {
        "db_id": "culture_company",
        "question": "Show the years, book titles, and publishers for all books, in descending order by year.",
        "ground_truth": "SELECT YEAR ,  book_title ,  publisher FROM book_club ORDER BY YEAR DESC",
        "amends": [
            "Do reference table `book_club` instead of `books` in the FROM clause. Do select column `book_title` instead of `title` in the SELECT list. Do use `YEAR DESC` ordering instead of `year ASC` in the ORDER BY clause. The amended query now correctly retrieves data from the book_club table with the specified column names and descending year ordering."
        ],
        "rules": [
            "1) When the question asks about books: use table \"book_club\" instead of \"books\". 2) When the question asks for book titles: use column \"book_title\" instead of \"title\". 3) When the question specifies descending order by year: order by \"YEAR\" in descending direction instead of ascending."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, title, publisher FROM books ORDER BY year ASC;",
            "SELECT Year, Book_Title, Publisher FROM book_club ORDER BY Year DESC;"
        ],
        "rule_sql": [
            "SELECT Year, Book_Title, Publisher FROM book_club ORDER BY Year DESC;"
        ]
    },
    "1717": {
        "db_id": "epinions_1",
        "question": "Find the number of users who did not write any review.",
        "ground_truth": "SELECT count(*) FROM useracct WHERE u_id NOT IN (SELECT u_id FROM review)",
        "amends": [
            "Do reference table `useracct` instead of `users` and column `u_id` instead of `user_id` in the main query. Do reference table `review` instead of `reviews` and column `u_id` instead of `user_id` in the subquery. The amended query now correctly counts records from the useracct table where users have not submitted any reviews, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"number of users who did not write any review\": use table \"useracct\" as T1 and column \"u_id\" as the counting key. 2) When checking for users without reviews: use table \"review\" as T2 and column \"u_id\" as the matching key. 3) When combining T1 and T2 for shared entities: link rows where T1.\"u_id\" = T2.\"u_id\" and keep only users without matching reviews (using NOT IN condition). 4) When counting users: compute the number of rows using T1.\"u_id\" as the counting key."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE user_id NOT IN (SELECT user_id FROM reviews)",
            "SELECT COUNT(*) \nFROM useracct u \nWHERE u.u_id NOT IN (SELECT r.u_id FROM review r)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM useracct \nWHERE u_id NOT IN (SELECT u_id FROM review)"
        ]
    },
    "2201": {
        "db_id": "formula_1",
        "question": "List the names of all distinct races in reversed  lexicographic order?",
        "ground_truth": "SELECT DISTINCT name FROM races ORDER BY name DESC",
        "amends": [
            "Do select `name` from the `races` table instead of `race` from `table_name`. Do order by `name DESC` instead of `race ASC`. Do remove the incorrect table reference `table_name` and use the correct table `races` instead. The amended query now correctly selects distinct names from the races table in descending order, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"distinct races\": select unique values from the \"name\" column of the \"races\" table. 2) When the question specifies \"reversed lexicographic order\": order the results by \"name\" in descending alphabetical order. 3) When selecting from the \"races\" table: use the exact table name \"races\" with double quotes as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT race FROM table_name ORDER BY race ASC;",
            "SELECT DISTINCT name FROM races ORDER BY name DESC;"
        ],
        "rule_sql": [
            "SELECT DISTINCT \"name\" FROM \"races\" ORDER BY \"name\" DESC;"
        ]
    },
    "5722": {
        "db_id": "dorm_1",
        "question": "Find the average and oldest age for students with different sex.",
        "ground_truth": "SELECT avg(age) ,  max(age) ,  sex FROM student GROUP BY sex",
        "amends": [
            "Do use `avg(age)` without an alias instead of `AVG(age) as average_age`, and do use `max(age)` instead of `MIN(age) as oldest_age` to correctly calculate maximum age. Do place `sex` at the end of the SELECT list instead of at the beginning. Do reference table `student` instead of `students` to match the correct table name. The amended query now correctly calculates maximum age instead of minimum age and uses the proper table reference."
        ],
        "rules": [
            "1) When calculating the average age: use avg(age) without an alias instead of AVG(age) as average_age. 2) When calculating the oldest age: use max(age) instead of MIN(age) as oldest_age to correctly calculate maximum age. 3) When ordering output columns: place sex at the end of the SELECT list instead of at the beginning. 4) When referencing the table: use student instead of students to match the correct table name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT sex, AVG(age) as average_age, MIN(age) as oldest_age FROM students GROUP BY sex;",
            "SELECT avg(age), max(age), Sex FROM Student GROUP BY Sex"
        ],
        "rule_sql": [
            "SELECT avg(age), max(age), Sex FROM Student GROUP BY Sex"
        ]
    },
    "6046": {
        "db_id": "game_1",
        "question": "What are the names of all the games that have been played for at least 1000 hours?",
        "ground_truth": "SELECT gname FROM Plays_games AS T1 JOIN Video_games AS T2 ON T1.gameid  =  T2.gameid GROUP BY T1.gameid HAVING sum(hours_played)  >=  1000",
        "amends": [
            "Do select `gname` from the `Video_games` table instead of `name` from the `games` table. Do join `Plays_games` and `Video_games` tables on `gameid` instead of querying a single table. Do use `GROUP BY` on `gameid` and `HAVING` with `sum(hours_played) >= 1000` instead of filtering individual records with `WHERE hours_played > 1000`. Do aggregate the total hours played per game instead of checking individual play sessions. The amended query now correctly calculates total play time per game across multiple sessions and matches the intended behavior."
        ],
        "rules": [
            "1) When the question asks for game names: use \"gname\" from the \"Video_games\" table instead of \"name\" from a \"games\" table. 2) When calculating total hours played per game: combine data from \"Plays_games\" and \"Video_games\" tables by linking rows where \"gameid\" values are equal (inner match). 3) When determining games with at least 1000 hours played: group results by \"gameid\" and only include groups where the sum of \"hours_played\" is greater than or equal to 1000. 4) When the question asks for \"games that have been played for at least 1000 hours\": this means total accumulated play time across all sessions, not individual session durations."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM games WHERE hours_played > 1000;",
            "SELECT vg.GName \nFROM Video_Games vg\nJOIN Plays_Games pg ON vg.GameID = pg.GameID\nGROUP BY vg.GameID, vg.GName\nHAVING SUM(pg.Hours_Played) >= 1000"
        ],
        "rule_sql": [
            "SELECT vg.GName \nFROM Video_Games vg\nINNER JOIN Plays_Games pg ON vg.GameID = pg.GameID\nGROUP BY vg.GameID, vg.GName\nHAVING SUM(pg.Hours_Played) >= 1000"
        ]
    },
    "3086": {
        "db_id": "behavior_monitoring",
        "question": "How many assessment notes are there in total?",
        "ground_truth": "SELECT count(*) FROM ASSESSMENT_NOTES",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM assessment_notes;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS total_assessment_notes FROM Assessment_Notes;"
        ]
    },
    "3315": {
        "db_id": "college_1",
        "question": "Find the first names and offices of all instructors who have taught some course and the course description and the department name.",
        "ground_truth": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code",
        "amends": [
            "Do use explicit `JOIN` syntax instead of comma-separated `FROM` clauses. Do reference tables as `employee AS T2`, `course AS T3`, `professor AS T4`, and `department AS T5` instead of `instructors i`, `courses c`, and `departments d`. Do select columns `emp_fname`, `prof_office`, `crs_description`, and `dept_name` instead of `first_name`, `office`, `description`, and `name`. Do join through the `CLASS AS T1` table instead of omitting it. Do use join conditions `T1.prof_num = T2.emp_num`, `T1.crs_code = T3.crs_code`, `T2.emp_num = T4.emp_num`, and `T4.dept_code = T5.dept_code` instead of `i.id = c.instructor_id` and `c.department_id = d.id`. The amended query now correctly navigates the relationship hierarchy through all required tables to match RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about instructors who have taught courses: use explicit JOIN syntax instead of comma-separated FROM clauses. 2) When referring to the instructors table: use alias T2 for employee table instead of instructors i. 3) When referring to the courses table: use alias T3 for course table instead of courses c. 4) When referring to the departments table: use alias T5 for department table instead of departments d. 5) When selecting first names: use column emp_fname instead of first_name. 6) When selecting offices: use column prof_office instead of office. 7) When selecting course descriptions: use column crs_description instead of description. 8) When selecting department names: use column dept_name instead of name. 9) When joining tables: include CLASS table as T1 and use join conditions T1.prof_num = T2.emp_num, T1.crs_code = T3.crs_code, T2.emp_num = T4.emp_num, and T4.dept_code = T5.dept_code instead of i.id = c.instructor_id and c.department_id = d.id. 10) When navigating relationships: join through the CLASS table T1 to correctly connect professors to courses and departments."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT i.first_name, i.office, c.description, d.name \nFROM instructors i, courses c, departments d \nWHERE i.id = c.instructor_id AND c.department_id = d.id",
            "SELECT T2.emp_fname, T4.prof_office, T3.crs_description, T5.dept_name\nFROM CLASS AS T1\nJOIN EMPLOYEE AS T2 ON T1.prof_num = T2.emp_num\nJOIN COURSE AS T3 ON T1.crs_code = T3.crs_code\nJOIN PROFESSOR AS T4 ON T2.emp_num = T4.emp_num\nJOIN DEPARTMENT AS T5 ON T4.dept_code = T5.dept_code\nGROUP BY T2.emp_fname, T4.prof_office, T3.crs_description, T5.dept_name"
        ],
        "rule_sql": [
            "SELECT T2.emp_fname, T4.prof_office, T3.crs_description, T5.dept_name\nFROM CLASS T1\nJOIN EMPLOYEE T2 ON T1.prof_num = T2.emp_num\nJOIN COURSE T3 ON T1.crs_code = T3.crs_code\nJOIN PROFESSOR T4 ON T2.emp_num = T4.emp_num\nJOIN DEPARTMENT T5 ON T4.dept_code = T5.dept_code;"
        ]
    },
    "4304": {
        "db_id": "club_1",
        "question": "Find the names of all the clubs that have at least a member from the city with city code \"BAL\".",
        "ground_truth": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.city_code  =  \"BAL\"",
        "amends": [
            "Do select `DISTINCT t1.clubname` instead of `name` from a single table. Do join three tables `club AS t1`, `member_of_club AS t2`, and `student AS t3` instead of querying only `clubs`. Do use `JOIN` with `t1.clubid = t2.clubid` and `t2.stuid = t3.stuid` instead of no joins. Do filter on `t3.city_code = \"BAL\"` instead of `city_code = 'BAL'` from the wrong table. The amended query now correctly finds distinct club names by joining through member relationships to filter students by city code, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"clubs that have at least a member from the city with city code 'BAL'\": make sure the output order: t1.clubname\n2) When the question mentions \"clubs\": \"clubs\" actually means \"club AS t1\" in schema\n3) When the question mentions \"member\": \"member\" actually means \"member_of_club AS t2\" in schema\n4) When the question mentions \"city code\": \"city code\" actually means \"student AS t3.city_code\" in schema\n5) When combining t1, t2, and t3 for shared entities: link rows where t1.clubid = t2.clubid and t2.stuid = t3.stuid; keep only matching pairs (inner match)\n6) When filtering for city code \"BAL\": use exact literal \"BAL\" with t3.city_code = \"BAL\"\n7) When selecting distinct club names: compute the number of unique values of t1.clubname"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM clubs WHERE city_code = 'BAL';",
            "SELECT DISTINCT t1.ClubName FROM Club AS t1 JOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID JOIN Student AS t3 ON t2.StuID = t3.StuID WHERE t3.city_code = 'BAL'"
        ],
        "rule_sql": [
            "SELECT DISTINCT t1.ClubName\nFROM Club AS t1\nINNER JOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID\nINNER JOIN Student AS t3 ON t2.StuID = t3.StuID\nWHERE t3.city_code = 'BAL'\nORDER BY t1.ClubName"
        ]
    },
    "3133": {
        "db_id": "assets_maintenance",
        "question": "List all every engineer's first name, last name, details and coresponding skill description.",
        "ground_truth": "SELECT T1.first_name ,  T1.last_name ,  T1.other_details ,  T3.skill_description FROM Maintenance_Engineers AS T1 JOIN Engineer_Skills AS T2 ON T1.engineer_id  =  T2.engineer_id JOIN Skills AS T3 ON T2.skill_id  =  T3.skill_id",
        "amends": [
            "Do reference table `Maintenance_Engineers` as `T1` instead of `engineers` as `e`. Do select column `other_details` instead of `details`. Do reference table `Skills` as `T3` instead of `skills` as `s`. Do select column `skill_description` instead of `description`. Do add a join through bridge table `Engineer_Skills` as `T2` instead of directly joining engineers to skills. Do use join condition `T1.engineer_id = T2.engineer_id` instead of `e.engineer_id = s.skill_id`. Do use join condition `T2.skill_id = T3.skill_id` instead of the incorrect direct engineer-to-skill join. The amended query now correctly models the many-to-many relationship between engineers and skills through the bridge table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"engineer's first name, last name, details and corresponding skill description\": make sure the output order: T1.first_name, T1.last_name, T1.other_details, T3.skill_description\n2) When the question mentions \"details\": \"details\" actually means \"other_details in schema\"\n3) When the question mentions \"skill description\": \"skill description\" actually means \"skill_description in schema\"\n4) When combining T1 and T3 for shared entities: link rows through bridge table T2 using T1.engineer_id = T2.engineer_id and T2.skill_id = T3.skill_id; keep only matching pairs (inner match)\n5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table names like \"Maintenance_Engineers\" and \"Skills\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.first_name, e.last_name, e.details, s.description FROM engineers e JOIN skills s ON e.engineer_id = s.skill_id;",
            "SELECT T1.first_name, T1.last_name, T1.other_details, T3.skill_description\nFROM Maintenance_Engineers AS T1\nJOIN Engineer_Skills AS T2 ON T1.engineer_id = T2.engineer_id\nJOIN Skills AS T3 ON T2.skill_id = T3.skill_id"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.last_name, T1.other_details, T3.skill_description\nFROM \"Maintenance_Engineers\" T1\nINNER JOIN \"Engineer_Skills\" T2 ON T1.engineer_id = T2.engineer_id\nINNER JOIN \"Skills\" T3 ON T2.skill_id = T3.skill_id"
        ]
    },
    "1978": {
        "db_id": "phone_market",
        "question": "How many phones are there?",
        "ground_truth": "SELECT count(*) FROM phone",
        "amends": [
            "Do query the `phone` table instead of the `computers` table. The amended query now correctly counts records from the intended phone table."
        ],
        "rules": [
            "1) When the question asks about \"phones\": query the \"phone\" table instead of the \"computers\" table. 2) When counting phones: count all records from the \"phone\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM computers;",
            "SELECT COUNT(*) FROM phone;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM phone;"
        ]
    },
    "6051": {
        "db_id": "game_1",
        "question": "Find the first name and age of the students who are playing both Football and Lacrosse.",
        "ground_truth": "SELECT fname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Sportsinfo WHERE SportName  =  \"Football\" INTERSECT SELECT StuID FROM Sportsinfo WHERE SportName  =  \"Lacrosse\")",
        "amends": [
            "Do select `fname` and `age` from `Student` instead of `first_name` and `age` from `students`. Do use a subquery with `INTERSECT` to find students who play both sports instead of the impossible `WHERE` condition requiring `sport` to equal both 'Football' and 'Lacrosse' simultaneously. Do reference the `Sportsinfo` table with proper `SportName` filtering instead of the incorrect direct `sport` column in the main table. Do use `StuID` as the correlation key between tables instead of missing the necessary table relationship. The amended query now correctly identifies students who participate in both football and lacrosse by intersecting their StuIDs from the Sportsinfo table."
        ],
        "rules": [
            "1) When the question asks for \"first name\" and \"age\" of students: use the exact column tokens \"fname\" and \"age\" from the \"Student\" table instead of \"first_name\" and \"age\" from \"students\". 2) When finding students who play both Football and Lacrosse: use a subquery with INTERSECT to find StuIDs that appear in both sports instead of requiring a single sport column to equal both values simultaneously. 3) When filtering for specific sports: use the \"SportName\" column from the \"SportsInfo\" table with exact literals 'Football' and 'Lacrosse' instead of a direct sport column in the main table. 4) When combining Student and SportsInfo tables: use \"StuID\" as the correlation key between tables to properly relate student information with their sports participation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, age FROM students WHERE sport = 'Football' AND sport = 'Lacrosse';",
            "SELECT s.Fname, s.Age\nFROM Student s\nWHERE s.StuID IN (\n    SELECT StuID FROM SportsInfo WHERE SportName = 'Football'\n    INTERSECT\n    SELECT StuID FROM SportsInfo WHERE SportName = 'Lacrosse'\n)"
        ],
        "rule_sql": [
            "SELECT s.fname, s.age\nFROM Student s\nWHERE s.StuID IN (\n    SELECT StuID FROM SportsInfo WHERE SportName = 'Football'\n    INTERSECT\n    SELECT StuID FROM SportsInfo WHERE SportName = 'Lacrosse'\n)"
        ]
    },
    "6411": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "Show project ids and the number of documents in each project.",
        "ground_truth": "SELECT project_id ,  count(*) FROM Documents GROUP BY project_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT project_id, COUNT(*) FROM documents GROUP BY project_id;"
        ],
        "rule_sql": [
            "SELECT Project_ID, COUNT(Document_ID) AS Number_of_Documents FROM Documents GROUP BY Project_ID"
        ]
    },
    "3273": {
        "db_id": "college_1",
        "question": "What are the first names of the professors who do not teach a class.",
        "ground_truth": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num",
        "amends": [
            "Do select `emp_fname` from the `employee` table instead of `first_name` from `professors`. Do use a `WHERE emp_jobcode = 'PROF'` filter to identify professors instead of assuming a separate professors table. Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do join `employee AS T1` with `CLASS AS T2` on `T1.emp_num = T2.prof_num` instead of the incorrect correlation between professor_id columns. The amended query now correctly identifies professors by job code and finds those not teaching any classes using proper table relationships and set operations, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"first names of professors\": select \"emp_fname\" from the \"employee\" table instead of \"first_name\" from \"professors\". 2) When identifying professors: filter \"employee\" table rows where \"emp_jobcode\" equals 'PROF' exactly. 3) When finding professors who do not teach a class: use EXCEPT set operation instead of NOT IN with a subquery. 4) When combining employee and CLASS tables: link rows where \"employee\".\"emp_num\" equals \"CLASS\".\"prof_num\" for proper table relationships. 5) When handling text literals: preserve the exact case and quotes for 'PROF' as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM professors WHERE professor_id NOT IN (SELECT professor_id FROM classes)",
            "SELECT emp_fname FROM employee WHERE emp_jobcode = 'PROF' EXCEPT SELECT e.emp_fname FROM employee e JOIN CLASS c ON e.emp_num = c.prof_num WHERE e.emp_jobcode = 'PROF'"
        ],
        "rule_sql": [
            "SELECT emp_fname FROM EMPLOYEE WHERE emp_jobcode = 'PROF' EXCEPT SELECT e.emp_fname FROM EMPLOYEE e JOIN CLASS c ON e.emp_num = c.prof_num WHERE e.emp_jobcode = 'PROF'"
        ]
    },
    "3033": {
        "db_id": "loan_1",
        "question": "What are the names and account balances of customers with the letter a in their names?",
        "ground_truth": "SELECT cust_name ,  acc_bal FROM customer WHERE cust_name LIKE '%a%'",
        "amends": [
            "Do use column aliases `cust_name` and `acc_bal` instead of `name` and `balance`. Do reference table `customer` instead of `customers` while keeping the same `LIKE '%a%'` filter condition. The amended query now correctly matches the intended table structure and column names while preserving the filtering logic."
        ],
        "rules": [
            "1) When the question asks for customer names and account balances: use column aliases \"cust_name\" and \"acc_bal\" instead of \"name\" and \"balance\". 2) When referencing the customer table: use table name \"customer\" instead of \"customers\". 3) When filtering for customers with the letter 'a' in their names: apply the condition \"cust_name\" LIKE '%a%' to find names containing the letter 'a'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, balance FROM customers WHERE name LIKE '%a%';",
            "SELECT cust_name, acc_bal FROM customer WHERE cust_name LIKE '%a%'"
        ],
        "rule_sql": [
            "SELECT cust_name, acc_bal FROM customer WHERE cust_name LIKE '%a%'"
        ]
    },
    "1324": {
        "db_id": "college_2",
        "question": "Count the number of rooms that are not in the Lamberton building.",
        "ground_truth": "SELECT count(*) FROM classroom WHERE building != 'Lamberton'",
        "amends": [
            "Do reference the `classroom` table instead of the `rooms` table. Do use the inequality condition `building != 'Lamberton'` instead of the equality condition `building = 'Lamberton'`. The amended query now correctly counts records from the classroom table where the building is not Lamberton, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"number of rooms\": use the \"classroom\" table instead of \"rooms\" table. 2) When the question mentions \"not in the Lamberton building\": use the inequality condition building != 'Lamberton' instead of building = 'Lamberton'. 3) When counting records: count all rows from the classroom table where building is not equal to 'Lamberton'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM rooms WHERE building = 'Lamberton';",
            "SELECT COUNT(*) FROM classroom WHERE building != 'Lamberton';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM classroom WHERE building != 'Lamberton';"
        ]
    },
    "4103": {
        "db_id": "company_employee",
        "question": "Show the most common headquarter for companies.",
        "ground_truth": "SELECT Headquarters FROM company GROUP BY Headquarters ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do use `Headquarters` instead of `headquarter` for the column name in both SELECT and GROUP BY clauses. Do order by `COUNT(*) DESC` instead of `count ASC` to get the highest count rather than the lowest. Do reference the table as `company` instead of `companies` to match the correct table name. The amended query now correctly identifies the headquarters with the most companies by counting in descending order.",
            "Do remove the `COUNT(*) AS count` column from the SELECT list instead of including it, as the query only needs to return the Headquarters value with the highest count rather than displaying both the Headquarters and its count. The amended query now correctly returns just the Headquarters field while maintaining the same grouping, ordering, and limiting logic to identify the most frequent headquarters location, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"headquarter\": use the exact column name \"Headquarters\" from the company table. 2) When counting companies per headquarters: group by \"Headquarters\" and count using the canonical key for companies. 3) When finding the \"most common\" headquarters: order the counts in descending order to get the highest count first. 4) When showing the most common headquarters: return only the top result (limit 1).",
            "1) When answering about \"most common headquarter for companies\": make sure the output order: only show the Headquarters value without the count column. 2) When the question asks for \"most common headquarter\": rank rows by count of Headquarters in descending order and keep the first 1 row. 3) When counting companies per headquarters: compute the number of rows using the canonical counting method (COUNT(*)) for each Headquarters group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT headquarter, COUNT(*) as count FROM companies GROUP BY headquarter ORDER BY count ASC LIMIT 1;",
            "SELECT Headquarters, COUNT(*) AS count FROM company GROUP BY Headquarters ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT Headquarters FROM company GROUP BY Headquarters ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Headquarters FROM company GROUP BY Headquarters ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "6600": {
        "db_id": "train_station",
        "question": "Show the name, location, and number of platforms for all stations.",
        "ground_truth": "SELECT name ,  LOCATION ,  number_of_platforms FROM station",
        "amends": [
            "Do add `number_of_platforms` to the SELECT list instead of omitting it. Do use the correct table name `station` instead of `stations`. The amended query now correctly includes all required columns from the proper table."
        ],
        "rules": [
            "1) When the question asks for \"number of platforms\": include the exact column \"number_of_platforms\" in the output. 2) When referring to the stations table: use the exact table name \"station\" instead of \"stations\". 3) When answering about station information: make sure the output order: name, location, number_of_platforms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, location FROM stations;",
            "SELECT Name, Location, Number_of_Platforms FROM station;"
        ],
        "rule_sql": [
            "SELECT Name, Location, Number_of_Platforms FROM station ORDER BY Name, Location, Number_of_Platforms;"
        ]
    },
    "3065": {
        "db_id": "loan_1",
        "question": "What are the names and account balances for customers who have taken a total amount of more than 5000 in loans?",
        "ground_truth": "SELECT T1.cust_name ,  T1.acc_type FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id GROUP BY T1.cust_name HAVING sum(T2.amount)  >  5000",
        "amends": [
            "Do select `cust_name` and `acc_type` instead of `name` and `account_balance`. Do use table aliases `T1` and `T2` instead of `c` and `l`. Do reference `customer` and `loan` tables instead of `customers` and `loans`. Do add `GROUP BY T1.cust_name` instead of omitting grouping. Do move the amount filter to `HAVING sum(T2.amount) > 5000` instead of `WHERE l.amount > 5000` to aggregate loan amounts per customer. The amended query now correctly sums loan amounts per customer and filters those with total loans exceeding 5000, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for customer names and account balances: select \"cust_name\" and \"acc_type\" from table \"customer\" (aliased as T1) instead of \"name\" and \"account_balance\". 2) When combining customer and loan information: use table aliases T1 for \"customer\" table and T2 for \"loan\" table instead of c and l. 3) When calculating total loan amounts per customer: group results by T1.\"cust_name\" to aggregate loan amounts for each customer. 4) When filtering for customers with total loans exceeding 5000: use HAVING sum(T2.\"amount\") > 5000 instead of WHERE condition on individual loan amounts to filter based on aggregated totals per customer."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.name, c.account_balance \nFROM customers c\nJOIN loans l ON c.customer_id = l.customer_id\nWHERE l.amount > 5000;",
            "SELECT T1.cust_name, T1.acc_type\nFROM customer T1\nJOIN loan T2 ON T1.cust_ID = T2.cust_ID\nGROUP BY T1.cust_name\nHAVING SUM(T2.amount) > 5000"
        ],
        "rule_sql": [
            "SELECT T1.cust_name, T1.acc_bal FROM customer T1 JOIN loan T2 ON T1.cust_ID = T2.cust_ID GROUP BY T1.cust_name HAVING SUM(T2.amount) > 5000"
        ]
    },
    "1362": {
        "db_id": "college_2",
        "question": "Find the title of course that is provided by both Statistics and Psychology departments.",
        "ground_truth": "SELECT title FROM course WHERE dept_name  =  'Statistics' INTERSECT SELECT title FROM course WHERE dept_name  =  'Psychology'",
        "amends": [
            "Do use `INTERSECT` to find common titles instead of incorrectly using `AND` with the same column. Do reference the correct table name `course` instead of `courses`. Do use the correct column name `dept_name` instead of `department` for both conditions. Do structure the query as two separate SELECT statements with `INTERSECT` instead of a single WHERE clause with conflicting conditions. The amended query now correctly finds course titles that exist in both Statistics and Psychology departments, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for courses provided by multiple departments: use INTERSECT to find common titles instead of AND conditions on the same column. 2) When referencing the course table: use the exact table name \"course\" instead of \"courses\". 3) When filtering by department: use the exact column name \"dept_name\" instead of \"department\". 4) When finding courses in both Statistics and Psychology departments: structure the query as two separate SELECT statements with INTERSECT, one for 'Statistics' and one for 'Psychology'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM courses WHERE department = 'Statistics' AND department = 'Psychology'",
            "SELECT title FROM course WHERE dept_name = 'Statistics' INTERSECT SELECT title FROM course WHERE dept_name = 'Psychology'"
        ],
        "rule_sql": [
            "SELECT title FROM course WHERE dept_name = 'Statistics' INTERSECT SELECT title FROM course WHERE dept_name = 'Psychology'"
        ]
    },
    "4187": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "Show the location code of the country \"Canada\".",
        "ground_truth": "SELECT location_code FROM Ref_locations WHERE location_name  =  \"Canada\"",
        "amends": [
            "Do select `location_code` instead of `location` and use table `Ref_locations` instead of `countries`. Do filter on `location_name = 'Canada'` instead of `country_name = 'Canada'` to correctly reference the location name column. The amended query now matches the intended behavior by selecting the location code from the appropriate reference table using the correct location name filter."
        ],
        "rules": [
            "1) When the question asks for \"location code\": select the exact column \"location_code\" from the appropriate table. 2) When the question mentions a country name like \"Canada\": use the exact literal 'Canada' with the correct case and quotes. 3) When filtering by location name: use the column \"location_name\" instead of \"country_name\" to match the schema. 4) When querying location information: use the table \"Ref_locations\" instead of \"countries\" as the correct source table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location FROM countries WHERE country_name = 'Canada';",
            "SELECT Location_Code FROM Ref_Locations WHERE Location_Name = 'Canada';"
        ],
        "rule_sql": [
            "SELECT Location_Code FROM Ref_Locations WHERE Location_Name = 'Canada';"
        ]
    },
    "3159": {
        "db_id": "station_weather",
        "question": "Give me the times and numbers of all trains that go to Chennai, ordered by time.",
        "ground_truth": "SELECT TIME ,  train_number FROM train WHERE destination  =  'Chennai' ORDER BY TIME",
        "amends": [
            "Do select `TIME` and `train_number` instead of `train_number` and `departure_time`. Do reference table `train` instead of `trains`. Do order by `TIME` instead of `train_number`. The amended query now correctly retrieves the time and train number from the train table for Chennai destinations, ordered by departure time."
        ],
        "rules": [
            "1) When answering about \"times and numbers of all trains that go to Chennai\": make sure the output order: TIME, train_number. 2) When the question mentions \"trains\": \"trains\" actually means \"train\" in schema. 3) When the question mentions \"ordered by time\": order rows by TIME in ascending order. 4) When the question asks for trains that go to Chennai: filter rows where destination equals 'Chennai' exactly."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT train_number, departure_time FROM trains WHERE destination = 'Chennai' ORDER BY train_number;",
            "SELECT time, train_number FROM train WHERE destination = 'Chennai' ORDER BY time;"
        ],
        "rule_sql": [
            "SELECT time, train_number FROM train WHERE destination = 'Chennai' ORDER BY time ASC;"
        ]
    },
    "4663": {
        "db_id": "college_3",
        "question": "Find the first name of students in the descending order of age.",
        "ground_truth": "SELECT Fname FROM STUDENT ORDER BY Age DESC",
        "amends": [
            "Do use column name `Fname` instead of `first_name` and table name `STUDENT` instead of `students`. Do change the sort direction to `DESC` instead of `ASC` and use column name `Age` instead of `age`. The amended query now correctly selects from the STUDENT table with the proper column names and descending age order."
        ],
        "rules": [
            "1) When the question asks for \"first name of students\": use column \"Fname\" from table \"STUDENT\" instead of \"first_name\" from \"students\". 2) When ordering by age in descending order: sort by column \"Age\" in descending direction instead of ascending. 3) When selecting from the student table: use table name \"STUDENT\" instead of \"students\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students ORDER BY age ASC;",
            "SELECT Fname FROM Student ORDER BY Age DESC;"
        ],
        "rule_sql": [
            "SELECT Fname FROM Student ORDER BY Age DESC;"
        ]
    },
    "4725": {
        "db_id": "department_store",
        "question": "What is the average price for each type of product?",
        "ground_truth": "SELECT product_type_code ,  avg(product_price) FROM products GROUP BY product_type_code",
        "amends": [
            "Do use `product_type_code` instead of `type` for the grouping column and in the SELECT list. Do use `avg(product_price)` instead of `AVG(price)` for the average calculation. The amended query now correctly references the actual column names and matches the intended behavior of calculating average product prices by product type code."
        ],
        "rules": [
            "1) When the question asks for average price by product type: use \"product_type_code\" for grouping and in the output instead of \"type\". 2) When calculating average price: use \"avg(product_price)\" instead of \"AVG(price)\" for the average calculation. 3) When organizing results by product type: group by the exact column \"product_type_code\" and compute average product prices per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type, AVG(price) FROM products GROUP BY type;",
            "SELECT product_type_code, AVG(product_price) AS average_price FROM Products GROUP BY product_type_code;"
        ],
        "rule_sql": [
            "SELECT product_type_code, AVG(product_price) AS average_price FROM Products GROUP BY product_type_code;"
        ]
    },
    "3965": {
        "db_id": "hospital_1",
        "question": "Find the ids of the nurses who are on call in block floor 1 and block code 1.",
        "ground_truth": "SELECT nurse FROM on_call WHERE blockfloor  =  1 AND blockcode  =  1",
        "amends": [
            "Do reference column `nurse` instead of `nurse_id` in the SELECT list. Do use filter condition `blockfloor = 1 AND blockcode = 1` instead of `block_floor = 1 OR block_code = 1`, changing both the column names from underscore-separated to camelCase and the logical operator from OR to AND to ensure both conditions must be satisfied. The amended query now correctly selects from the specified columns with the proper conjunction logic."
        ],
        "rules": [
            "1) When the question asks for \"ids of the nurses\": select the exact column \"nurse\" instead of \"nurse_id\". 2) When filtering for nurses on call in block floor 1 and block code 1: use the condition \"blockfloor = 1 AND blockcode = 1\" with exact camelCase column names and AND operator to require both conditions be satisfied. 3) When handling column names: use exact camelCase identifiers \"blockfloor\" and \"blockcode\" instead of underscore-separated versions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT nurse_id FROM on_call WHERE block_floor = 1 OR block_code = 1;",
            "SELECT Nurse FROM On_Call WHERE BlockFloor = 1 AND BlockCode = 1;"
        ],
        "rule_sql": [
            "SELECT Nurse FROM On_Call WHERE blockfloor = 1 AND blockcode = 1;"
        ]
    },
    "5932": {
        "db_id": "cre_Theme_park",
        "question": "Show the tourist attractions visited by the tourist whose detail is 'Vincent'.",
        "ground_truth": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  \"Vincent\"",
        "amends": [
            "Do specify `T1.Name` in the SELECT list instead of using `*` to select all columns. Do add joins to `VISITS AS T2` and `VISITORS AS T3` instead of querying only from `tourist_attractions`. Do use `JOIN` with `T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID` and `T2.Tourist_ID = T3.Tourist_ID` instead of no join conditions. Do filter on `T3.Tourist_Details = \"Vincent\"` instead of `tourist_name = 'Vincent'` to correctly reference the visitor's details table. The amended query now properly joins the necessary tables to find attractions visited by Vincent and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"tourist attractions visited by a tourist\": make sure the output order: T1.Name. 2) When combining tables for shared entities: link rows where T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID and T2.Tourist_ID = T3.Tourist_ID; keep only matching pairs (inner match). 3) When the question mentions \"tourist whose detail is 'Vincent'\": \"Vincent\" actually means T3.Tourist_Details = \"Vincent\" in schema. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for literal \"Vincent\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM tourist_attractions WHERE tourist_name = 'Vincent';",
            "SELECT T1.Name \nFROM Tourist_Attractions AS T1\nJOIN Visits AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID\nJOIN Visitors AS T3 ON T2.Tourist_ID = T3.Tourist_ID\nWHERE T3.Tourist_Details = 'Vincent'"
        ],
        "rule_sql": [
            "SELECT ta.Name \nFROM Tourist_Attractions ta\nINNER JOIN Visits v ON ta.Tourist_Attraction_ID = v.Tourist_Attraction_ID\nINNER JOIN Visitors vi ON v.Tourist_ID = vi.Tourist_ID\nWHERE vi.Tourist_Details = 'Vincent'\nORDER BY ta.Name"
        ]
    },
    "2734": {
        "db_id": "election",
        "question": "How many counties are there in total?",
        "ground_truth": "SELECT count(*) FROM county",
        "amends": [
            "Do query the `county` table instead of the `states` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the county table rather than the states table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"how many counties\": query the \"county\" table instead of the \"states\" table. 2) When counting entities: use lowercase \"count(*)\" for consistency in function naming. 3) When counting counties: count all records from the \"county\" table to get the total number of counties."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM states;",
            "SELECT count(*) FROM county;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM county;"
        ]
    },
    "4167": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "What are all the document type codes and document type names?",
        "ground_truth": "SELECT document_type_code ,  document_type_name FROM Ref_document_types",
        "amends": [
            "Do select `document_type_code` and `document_type_name` instead of `document_code` and `type_name`. Do reference table `Ref_document_types` instead of `document_types`. The amended query now correctly retrieves the document type code and name from the appropriate reference table."
        ],
        "rules": [
            "1) When answering about document type codes and document type names: make sure to select \"document_type_code\" and \"document_type_name\" as output columns. 2) When referencing the document types table: use the exact table name \"Ref_document_types\" instead of any other table name. 3) When the question asks for all document type codes and names: retrieve all rows from the \"Ref_document_types\" table without any filtering conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_code, type_name FROM document_types",
            "SELECT Document_Type_Code, Document_Type_Name FROM Ref_Document_Types;"
        ],
        "rule_sql": [
            "SELECT document_type_code, document_type_name FROM Ref_document_types;"
        ]
    },
    "1311": {
        "db_id": "performance_attendance",
        "question": "What is the average number of attendees for performances?",
        "ground_truth": "SELECT avg(Attendance) FROM performance",
        "amends": [
            "Do select `avg(Attendance)` instead of `AVG(performance_id)` to calculate the average attendance metric. Do reference the `performance` table instead of the `attendees` table to access the correct data source. Do use the lowercase `avg` function instead of uppercase `AVG` for consistency, though this is purely cosmetic. The amended query now correctly calculates average attendance from the performance table instead of incorrectly averaging performance IDs from an unrelated attendees table."
        ],
        "rules": [
            "1) When answering about \"average number of attendees for performances\": make sure the output order: avg(Attendance) 2) When calculating average attendance: use the \"Attendance\" column from the \"performance\" table instead of performance_id from attendees table 3) When accessing attendance data: reference the \"performance\" table as the correct data source for attendance information"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(performance_id) FROM attendees;",
            "SELECT avg(Attendance) FROM performance"
        ],
        "rule_sql": [
            "SELECT AVG(Attendance) FROM performance;"
        ]
    },
    "3953": {
        "db_id": "hospital_1",
        "question": "What is the alphabetically ordered list of all the distinct names of nurses?",
        "ground_truth": "SELECT DISTINCT name FROM nurse ORDER BY name",
        "amends": [
            "Do add `DISTINCT` instead of omitting it to eliminate duplicate name values. Do change the table reference from `nurses` to `nurse` to match the correct table name. Do remove the explicit `ASC` direction from the `ORDER BY` clause since ascending is the default ordering. The amended query now correctly returns unique nurse names from the nurse table in alphabetical order, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for distinct names: use DISTINCT to eliminate duplicate values from the name column. 2) When referring to the table containing nurse information: use the exact table name \"nurse\" instead of \"nurses\". 3) When ordering alphabetically: use ORDER BY name without explicit ASC direction since ascending is the default ordering."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM nurses ORDER BY name ASC",
            "SELECT DISTINCT Name FROM Nurse ORDER BY Name;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Name FROM Nurse ORDER BY Name;"
        ]
    },
    "2501": {
        "db_id": "movie_1",
        "question": "What are the names and years released for the movies with the top 3 highest ratings?",
        "ground_truth": "SELECT T2.title ,  T2.year FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID ORDER BY T1.stars DESC LIMIT 3",
        "amends": [
            "Do select `title` and `year` instead of `name` and `year_released`. Do join `Rating` and `Movie` tables on `mID` instead of querying only the `movies` table. Do order by `stars DESC` instead of `rating ASC`. Do use proper table aliases `T1` and `T2` instead of no aliases. The amended query now correctly retrieves the top 3 movies by rating stars from the joined Rating and Movie tables."
        ],
        "rules": [
            "1) When the question asks for movie names and years released: select \"title\" and \"year\" columns instead of \"name\" and \"year_released\". 2) When combining Rating and Movie tables: link rows where T1.\"mID\" = T2.\"mID\" and keep only matching pairs (inner match). 3) When the question asks for top 3 highest ratings: order by \"stars\" in descending direction and keep the first 3 rows. 4) When choosing identifier delimiters: use double quotes for column names like \"title\", \"year\", and \"mID\" as shown in the schema. 5) When handling table aliases: use T1 for Rating table and T2 for Movie table as specified in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, year_released FROM movies ORDER BY rating ASC LIMIT 3;",
            "SELECT T1.title, T1.year\nFROM Movie T1\nJOIN Rating T2 ON T1.mID = T2.mID\nORDER BY T2.stars DESC\nLIMIT 3;"
        ],
        "rule_sql": [
            "SELECT T2.\"title\", T2.\"year\" FROM Rating T1 INNER JOIN Movie T2 ON T1.\"mID\" = T2.\"mID\" ORDER BY T1.\"stars\" DESC LIMIT 3"
        ]
    },
    "3280": {
        "db_id": "college_1",
        "question": "What is the name of the department and office location for the professor with the last name of Heffington?",
        "ground_truth": "SELECT T3.dept_name  ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T2.dept_code  =  T3.dept_code WHERE T1.emp_lname  =  'Heffington'",
        "amends": [
            "Do select `T3.dept_name` and `T2.prof_office` instead of `department_name` and `office_location`. Do join `employee AS T1` with `professor AS T2` on `T1.emp_num = T2.emp_num` instead of querying only the `professors` table. Do add a second join to `department AS T3` on `T2.dept_code = T3.dept_code` instead of omitting department table access. Do filter on `T1.emp_lname = 'Heffington'` instead of `first_name = 'Heffington'` to correctly match by last name rather than first name. The amended query now properly joins across three tables to retrieve department and office information based on employee last name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for department name and office location for a professor: select T3.dept_name and T2.prof_office as the output columns. 2) When querying professor information: join employee AS T1 with professor AS T2 on T1.emp_num = T2.emp_num to access professor data through employee records. 3) When department information is needed: join department AS T3 on T2.dept_code = T3.dept_code to retrieve department details. 4) When filtering by last name: use T1.emp_lname = 'Heffington' to match by employee last name rather than first name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department_name, office_location FROM professors WHERE first_name = 'Heffington';",
            "SELECT T3.dept_name, T2.prof_office\nFROM employee AS T1\nJOIN professor AS T2 ON T1.emp_num = T2.emp_num\nJOIN department AS T3 ON T2.dept_code = T3.dept_code\nWHERE T1.emp_lname = 'Heffington'"
        ],
        "rule_sql": [
            "SELECT T3.DEPT_NAME, T2.PROF_OFFICE\nFROM EMPLOYEE AS T1\nJOIN PROFESSOR AS T2 ON T1.EMP_NUM = T2.EMP_NUM\nJOIN DEPARTMENT AS T3 ON T2.DEPT_CODE = T3.DEPT_CODE\nWHERE T1.EMP_LNAME = 'Heffington'"
        ]
    },
    "5216": {
        "db_id": "music_2",
        "question": "Find all the instruments ever used by the musician with last name \"Heilo\"?",
        "ground_truth": "SELECT instrument FROM instruments AS T1 JOIN Band AS T2 ON T1.bandmateid  =  T2.id WHERE T2.lastname  =  \"Heilo\"",
        "amends": [
            "Do select only `instrument` instead of all columns with `*`. Do join `Band AS T2` instead of querying only the `instruments` table. Do use `ON T1.bandmateid = T2.id` to establish the correct relationship between instruments and band members instead of filtering directly on `musician_last_name`. Do filter on `T2.lastname = \"Heilo\"` instead of the non-existent `musician_last_name` column. The amended query now correctly retrieves instruments by joining through the band member relationship and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"instruments used by musician with last name 'Heilo'\": select only the \"instrument\" column instead of all columns. 2) When combining instruments and band tables: join \"instruments\" as T1 with \"Band\" as T2 using the relationship T1.bandmateid = T2.id to establish the correct connection between instruments and band members. 3) When filtering for musician last name: use T2.lastname = \"Heilo\" instead of the non-existent musician_last_name column. 4) When the question mentions \"musician with last name\": this refers to the \"lastname\" column in the \"Band\" table (T2)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM instruments WHERE musician_last_name = 'Heilo';",
            "SELECT instrument FROM Instruments AS T1 JOIN Band AS T2 ON T1.BandmateId = T2.Id WHERE T2.Lastname = 'Heilo'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Instrument FROM Instruments AS T1 JOIN Band AS T2 ON T1.BandmateId = T2.Id WHERE T2.Lastname = 'Heilo'"
        ]
    },
    "2890": {
        "db_id": "icfp_1",
        "question": "Find the papers which have \"Olin Shivers\" as an author.",
        "ground_truth": "SELECT t3.title FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid WHERE t1.fname  =  \"Olin\" AND t1.lname  =  \"Shivers\"",
        "amends": [
            "Do select only `t3.title` instead of all columns with `*`. Do join `authors AS t1` and `authorship AS t2` on `t1.authid = t2.authid` instead of querying only the `papers` table. Do join `papers AS t3` on `t2.paperid = t3.paperid` instead of missing these table relationships. Do filter by `t1.fname = \"Olin\" AND t1.lname = \"Shivers\"` instead of using `author = 'Olin Shivers'` which doesn't match the schema structure. The amended query now correctly retrieves paper titles by joining through the authorship relationship and using proper name filters."
        ],
        "rules": [
            "1) When answering about papers by \"Olin Shivers\": make sure the output order: t3.title. 2) When the question mentions \"Olin Shivers\" as an author: \"Olin Shivers\" actually means t1.fname = \"Olin\" AND t1.lname = \"Shivers\" in schema. 3) When combining authors AS t1 and authorship AS t2 for shared entities: link rows where t1.authid = t2.authid exactly as shown in the amends; keep only matching pairs (inner match). 4) When combining authorship AS t2 and papers AS t3 for shared entities: link rows where t2.paperid = t3.paperid exactly as shown in the amends; keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for literals like \"Olin\" and \"Shivers\". 6) When handling text literals: do not change case, spacing, or punctuation for \"Olin\" and \"Shivers\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM papers WHERE author = 'Olin Shivers';",
            "SELECT t3.title FROM Authors AS t1 JOIN Authorship AS t2 ON t1.authID = t2.authID JOIN Papers AS t3 ON t2.paperID = t3.paperID WHERE t1.fname = 'Olin' AND t1.lname = 'Shivers'"
        ],
        "rule_sql": [
            "SELECT t3.title\nFROM Authors AS t1\nINNER JOIN Authorship AS t2 ON t1.authID = t2.authID\nINNER JOIN Papers AS t3 ON t2.paperID = t3.paperID\nWHERE t1.fname = \"Olin\" AND t1.lname = \"Shivers\"\nORDER BY t3.title"
        ]
    },
    "2023": {
        "db_id": "gas_company",
        "question": "Show the company name with the number of gas station.",
        "ground_truth": "SELECT T2.company ,  count(*) FROM station_company AS T1 JOIN company AS T2 ON T1.company_id  =  T2.company_id GROUP BY T1.company_id",
        "amends": [
            "Do reference `company` table as `T2` and `station_company` as `T1` instead of directly querying `gas_stations`. Do join `T1.company_id = T2.company_id` instead of grouping by `company_name` from a single table. Do select `T2.company` instead of `company_name` to get the proper company name from the joined table. Do group by `T1.company_id` instead of `company_name` to ensure correct aggregation by the foreign key relationship. Do remove the `ORDER BY COUNT(*) DESC` clause instead of keeping it since the right query focuses on aggregation without explicit ordering. The amended query now correctly joins the relationship tables and aggregates by the proper foreign key to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"company name with number of gas stations\": make sure the output order: company name first, then count of stations. 2) When the question mentions \"company name\": \"company name\" actually means \"T2.company\" in schema. 3) When the question asks for \"number of gas station\": compute the count using the canonical key token T1.company_id. 4) When combining T1 (station_company) and T2 (company) for shared entities: link rows where T1.company_id = T2.company_id exactly as shown; keep only matching pairs (inner match). 5) When the question asks for count per company: organize results by T1.company_id and compute the count of stations per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT company_name, COUNT(*) FROM gas_stations GROUP BY company_name ORDER BY COUNT(*) DESC;",
            "SELECT T2.Company, COUNT(*) AS number_of_gas_stations FROM station_company T1 JOIN company T2 ON T1.Company_ID = T2.Company_ID GROUP BY T1.Company_ID"
        ],
        "rule_sql": [
            "SELECT T2.Company, COUNT(T1.Company_ID) AS Number_of_Gas_Stations\nFROM station_company T1\nINNER JOIN company T2 ON T1.Company_ID = T2.Company_ID\nGROUP BY T1.Company_ID\nORDER BY T2.Company, Number_of_Gas_Stations;"
        ]
    },
    "5245": {
        "db_id": "music_2",
        "question": "How many different instruments are used in the song \"Badlands\"?",
        "ground_truth": "SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Badlands\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM songs WHERE title = 'Badlands';"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Instrument) FROM Instruments WHERE SongId = (SELECT SongId FROM Songs WHERE Title = 'Badlands');"
        ]
    },
    "5410": {
        "db_id": "shop_membership",
        "question": "Show minimum and maximum amount of memberships for all branches opened in 2011 or located at city London.",
        "ground_truth": "SELECT min(membership_amount) ,  max(membership_amount) FROM branch WHERE open_year  =  2011 OR city  =  'London'",
        "amends": [
            "Do use `membership_amount` instead of `membership_count` in both aggregate functions. Do reference table `branch` instead of `branches` as the data source. Do use column `open_year` instead of `opened_year` in the WHERE filter condition. Do remove the column aliases `min_memberships` and `max_memberships` instead of keeping them. The amended query now correctly calculates minimum and maximum membership amounts from the branch table filtered by open year or city."
        ],
        "rules": [
            "1) When the question asks for minimum and maximum membership amounts: use MIN(membership_amount) and MAX(membership_amount) instead of membership_count. 2) When referencing the branch data source: use table \"branch\" instead of \"branches\". 3) When filtering by year opened: use column \"open_year\" instead of \"opened_year\". 4) When outputting aggregate results: do not use column aliases like min_memberships and max_memberships."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(membership_count) as min_memberships, MAX(membership_count) as max_memberships \nFROM branches \nWHERE opened_year = 2011 OR city = 'London';",
            "SELECT MIN(membership_amount) AS min_memberships, MAX(membership_amount) AS max_memberships FROM branch WHERE Open_year = '2011' OR City = 'London';"
        ],
        "rule_sql": [
            "SELECT MIN(membership_amount), MAX(membership_amount) FROM branch WHERE Open_year = '2011' OR City = 'London';"
        ]
    },
    "1058": {
        "db_id": "match_season",
        "question": "Show all distinct positions of matches.",
        "ground_truth": "SELECT DISTINCT POSITION FROM match_season",
        "amends": [
            "Do select only `POSITION` instead of all columns with `*`. Do add `DISTINCT` instead of omitting it to return unique position values. Do change the table source to `match_season` instead of `matches` to access the correct data. The amended query now correctly returns distinct position values from the match_season table as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for \"distinct positions\": select only the \"POSITION\" column and return unique values using DISTINCT. 2) When accessing match position data: use the \"match_season\" table instead of \"matches\" to get the correct data source. 3) When selecting columns: use only the specific column \"POSITION\" instead of all columns with *."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM matches;",
            "SELECT DISTINCT Position FROM match_season"
        ],
        "rule_sql": [
            "SELECT DISTINCT Position FROM match_season;"
        ]
    },
    "4295": {
        "db_id": "club_1",
        "question": "Who is the president of the club \"Bootup Baltimore\"? Give me the first and last name.",
        "ground_truth": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t2.position  =  \"President\"",
        "amends": [
            "Do select `t3.fname` and `t3.lname` instead of `first_name` and `last_name`. Do use a three-table join structure with `club AS t1 JOIN member_of_club AS t2 ON t1.clubid = t2.clubid JOIN student AS t3 ON t2.stuid = t3.stuid` instead of querying a single `members` table. Do filter on `t1.clubname = \"Bootup Baltimore\"` instead of `club_name = 'Bootup Baltimore'` and `t2.position = \"President\"` instead of `role = 'president'`. The amended query now correctly joins through the proper relationship tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"president of the club 'Bootup Baltimore'\": make sure the output order: t3.fname, t3.lname. 2) When the question mentions \"Bootup Baltimore\": \"Bootup Baltimore\" actually means t1.clubname = \"Bootup Baltimore\" in schema. 3) When the question mentions \"president\": \"president\" actually means t2.position = \"President\" in schema. 4) When combining tables for club information: link rows where t1.clubid = t2.clubid and t2.stuid = t3.stuid; keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM members WHERE club_name = 'Bootup Baltimore' AND role = 'president';",
            "SELECT t3.fname, t3.lname \nFROM club AS t1 \nJOIN member_of_club AS t2 ON t1.clubid = t2.clubid \nJOIN student AS t3 ON t2.stuid = t3.stuid \nWHERE t1.clubname = 'Bootup Baltimore' AND t2.position = 'President'"
        ],
        "rule_sql": [
            "SELECT t3.Fname, t3.Lname\nFROM Club t1\nINNER JOIN Member_of_club t2 ON t1.ClubID = t2.ClubID\nINNER JOIN Student t3 ON t2.StuID = t3.StuID\nWHERE t1.ClubName = 'Bootup Baltimore'\nAND t2.Position = 'President'"
        ]
    },
    "6966": {
        "db_id": "culture_company",
        "question": "Show all distinct publishers for books.",
        "ground_truth": "SELECT DISTINCT publisher FROM book_club",
        "amends": [
            "Do use `DISTINCT` to return unique publishers instead of potentially returning duplicate values. Do reference the `book_club` table instead of the `books` table to ensure the correct data source is queried. The amended query now correctly returns only distinct publisher values from the appropriate table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"distinct publishers for books\": use DISTINCT to return unique values only. 2) When the question mentions \"publishers\": \"publishers\" actually means \"publisher in schema\". 3) When the question mentions \"books\": reference the \"book_club\" table instead of the \"books\" table to ensure the correct data source is queried."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT publisher FROM books;",
            "SELECT DISTINCT Publisher FROM book_club;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Publisher FROM book_club;"
        ]
    },
    "4828": {
        "db_id": "aircraft",
        "question": "What are the names of all pilots listed by descending age?",
        "ground_truth": "SELECT Name FROM pilot ORDER BY Age DESC",
        "amends": [
            "Do use column name `Name` instead of `name` and table name `pilot` instead of `pilots`. Do change the sort direction to `DESC` instead of `ASC` and use column name `Age` instead of `age`. The amended query now correctly references the proper table and column names with the intended descending sort order."
        ],
        "rules": [
            "1) When the question asks for pilot names: use column \"Name\" from table \"pilot\" exactly as shown in the schema. 2) When the question specifies descending age order: sort by column \"Age\" in descending order (highest to lowest). 3) When referencing table and column identifiers: use exact case-sensitive tokens \"pilot\", \"Name\", and \"Age\" with proper capitalization as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM pilots ORDER BY age ASC;",
            "SELECT Name FROM pilot ORDER BY Age DESC;"
        ],
        "rule_sql": [
            "SELECT Name FROM pilot ORDER BY Age DESC;"
        ]
    },
    "5326": {
        "db_id": "manufactory_1",
        "question": "Select the name of the products with a price less than or equal to $200.",
        "ground_truth": "SELECT name FROM products WHERE price  <=  200",
        "amends": [
            "Do use `price <= 200` instead of `price > 200` in the WHERE filter, changing the comparison operator from greater than to less than or equal to. This amendment reverses the filtering logic to select products with prices at or below 200 instead of above 200. The amended query now matches RIGHT_SQL's behavior by correctly implementing the intended price threshold condition."
        ],
        "rules": [
            "1) When the question asks for products with price less than or equal to $200: use price <= 200 as the filtering condition instead of price > 200"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM products WHERE price > 200;",
            "SELECT Name FROM Products WHERE Price <= 200;"
        ],
        "rule_sql": [
            "SELECT Name FROM Products WHERE Price <= 200;"
        ]
    },
    "3326": {
        "db_id": "college_1",
        "question": "What is the last name of the student who received an A in the class with the code 10018?",
        "ground_truth": "SELECT T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  'A' AND T2.class_code  =  10018",
        "amends": [
            "Do use `T1.stu_lname` instead of `last_name` for the column selection. Do join `student AS T1` with `enroll AS T2` instead of querying only the `students` table. Do use the join condition `T1.stu_num = T2.stu_num` instead of no join. Do filter on `T2.enroll_grade = 'A'` instead of `grade = 'A'` and use `T2.class_code = 10018` instead of `class_code = 10018` to reference the correct table. Do remove the `ORDER BY student_id DESC LIMIT 1` clause instead of keeping it since the right query returns all matching records without ordering or limiting. The amended query now correctly joins the student and enroll tables to find students with grade A in class 10018 and matches the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"last name of the student who received an A in class code 10018\": use T1.stu_lname for the output column instead of last_name. 2) When combining student and enroll tables: link rows where T1.stu_num = T2.stu_num and keep only matching pairs (inner match). 3) When filtering for grade A in class code 10018: use T2.enroll_grade = 'A' and T2.class_code = 10018 instead of filtering on the student table. 4) When the question asks for students with specific grade and class: do not apply ordering by student_id or limit to 1 row since all matching records should be returned."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM students WHERE grade = 'A' AND class_code = 10018 ORDER BY student_id DESC LIMIT 1;",
            "SELECT T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num = T2.stu_num WHERE T2.enroll_grade = 'A' AND T2.class_code = '10018'"
        ],
        "rule_sql": [
            "SELECT T1.STU_LNAME \nFROM STUDENT T1 \nINNER JOIN ENROLL T2 ON T1.STU_NUM = T2.STU_NUM \nWHERE T2.ENROLL_GRADE = 'A' AND T2.CLASS_CODE = '10018'"
        ]
    },
    "4682": {
        "db_id": "college_3",
        "question": "Give the building that the instructor who teaches the greatest number of courses lives in.",
        "ground_truth": "SELECT T2.Building FROM COURSE AS T1 JOIN FACULTY AS T2 ON T1.Instructor  =  T2.FacID GROUP BY T1.Instructor ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `FACULTY AS T2` on `T1.Instructor = T2.FacID` instead of querying `instructor` table directly. Do group by `T1.Instructor` instead of ordering by aggregate without grouping. Do count all rows with `count(*)` instead of counting `course_id` specifically. Do select `T2.Building` from the joined faculty table instead of selecting `building` from instructor. The amended query now correctly joins course and faculty tables to find the building with the most courses taught by instructors."
        ],
        "rules": [
            "1) When answering about \"the instructor who teaches the greatest number of courses\": make sure to group by T1.Instructor and count all rows with count(*) to determine the instructor with the most courses. 2) When combining course and faculty tables for shared entities: link rows where T1.Instructor = T2.FacID exactly as shown in the amends; keep only matching pairs (inner match). 3) When selecting the building where the instructor lives: select T2.Building from the joined faculty table instead of building from the instructor table. 4) When the question asks for \"the greatest number of courses\": rank rows by the course count in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT building FROM instructor ORDER BY COUNT(course_id) DESC LIMIT 1;",
            "SELECT T2.Building\nFROM Course AS T1\nJOIN Faculty AS T2 ON T1.Instructor = T2.FacID\nGROUP BY T1.Instructor\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.Building\nFROM (\n    SELECT Instructor, COUNT(*) as course_count\n    FROM Course\n    GROUP BY Instructor\n    ORDER BY course_count DESC\n    LIMIT 1\n) AS max_courses\nJOIN Faculty AS T2 ON max_courses.Instructor = T2.FacID;"
        ]
    },
    "1490": {
        "db_id": "college_2",
        "question": "Find the names of all instructors whose salary is greater than the salary of all instructors in the Biology department.",
        "ground_truth": "SELECT name FROM instructor WHERE salary  >  (SELECT max(salary) FROM instructor WHERE dept_name  =  'Biology')",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM instructor WHERE salary > (SELECT MAX(salary) FROM instructor WHERE dept_name = 'Biology');"
        ],
        "rule_sql": [
            "SELECT name FROM instructor WHERE salary > (SELECT MAX(salary) FROM instructor WHERE dept_name = 'Biology')"
        ]
    },
    "2785": {
        "db_id": "election",
        "question": "What are the 3 counties that have the smallest population? Give me the county names.",
        "ground_truth": "SELECT County_name FROM county ORDER BY Population ASC LIMIT 3",
        "amends": [
            "Do reference the `County_name` column instead of `county_name` to match the correct column name casing. Do use the `county` table instead of `counties` to reference the correct table name. Do order by `Population` in ascending order instead of descending to reverse the sort direction. The amended query now correctly selects from the proper table with accurate column names and returns the three counties with the smallest populations instead of the largest."
        ],
        "rules": [
            "1) When the question asks for county names: use the exact column name \"County_name\" from the county table. 2) When the question asks for the smallest population: order by the \"Population\" column in ascending order. 3) When the question asks for the top 3 results: limit the output to exactly 3 rows. 4) When referencing the county table: use the exact table name \"county\" (not \"counties\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT county_name FROM counties ORDER BY population DESC LIMIT 3;",
            "SELECT County_name FROM county ORDER BY Population ASC LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT County_name FROM county ORDER BY Population ASC LIMIT 3"
        ]
    },
    "2422": {
        "db_id": "candidate_poll",
        "question": "Find the names of the candidates whose support percentage is lower than their oppose rate.",
        "ground_truth": "SELECT t1.name FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id WHERE t2.support_rate  <  t2.oppose_rate",
        "amends": [
            "Do select `t1.name` from the `people` table instead of `name` from the `candidates` table. Do join `candidate AS t2` on `t1.people_id = t2.people_id` instead of querying a single table. Do use `t2.support_rate < t2.oppose_rate` as the filter condition instead of `support_percentage > oppose_rate`. The amended query now correctly joins the people and candidate tables and uses the proper comparison logic to identify candidates where support rate is less than oppose rate."
        ],
        "rules": [
            "1) When answering about candidate names: select \"t1.name\" from the \"people\" table instead of \"name\" from the \"candidates\" table. 2) When combining people and candidate tables: link rows where \"t1.people_id = t2.people_id\" and keep only matching pairs (inner match). 3) When filtering for candidates with support rate lower than oppose rate: use the condition \"t2.support_rate < t2.oppose_rate\" instead of \"support_percentage > oppose_rate\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM candidates WHERE support_percentage > oppose_rate;",
            "SELECT t1.Name FROM people AS t1 JOIN candidate AS t2 ON t1.People_ID = t2.People_ID WHERE t2.Support_rate < t2.Oppose_rate"
        ],
        "rule_sql": [
            "SELECT t1.Name FROM people t1 INNER JOIN candidate t2 ON t1.People_ID = t2.People_ID WHERE t2.Support_rate < t2.Oppose_rate"
        ]
    },
    "5925": {
        "db_id": "cre_Theme_park",
        "question": "What is the name of the staff that is in charge of the attraction named \"US museum\"?",
        "ground_truth": "SELECT T1.Name FROM STAFF AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID WHERE T2.Name  =  \"US museum\"",
        "amends": [
            "Do specify the table alias `T1` for the `Name` column instead of using the bare column name. Do join the `TOURIST_ATTRACTIONS` table as `T2` instead of omitting it entirely. Do use the join condition `T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID` instead of filtering directly on the `attraction` column. Do filter on `T2.Name = \"US museum\"` instead of `attraction = 'US museum'` to properly reference the joined table. The amended query now correctly joins the necessary tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about staff in charge of an attraction: join the Staff table as T1 and TOURIST_ATTRACTIONS table as T2 using the condition T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID. 2) When the question mentions \"attraction named 'US museum'\": filter on T2.Name = \"US museum\" exactly as written. 3) When selecting the staff name: use T1.Name as the output column with table alias T1. 4) When combining Staff and TOURIST_ATTRACTIONS tables: perform an inner match where T1.Tourist_Attraction_ID equals T2.Tourist_Attraction_ID."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM staff WHERE attraction = 'US museum';",
            "SELECT T1.Name \nFROM Staff T1\nJOIN Tourist_Attractions T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID\nWHERE T2.Name = 'US museum'"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM Staff AS T1 INNER JOIN Tourist_Attractions AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID WHERE T2.Name = 'US museum'"
        ]
    },
    "3101": {
        "db_id": "behavior_monitoring",
        "question": "List all cities of addresses in alphabetical order.",
        "ground_truth": "SELECT city FROM Addresses ORDER BY city",
        "amends": [
            "Do select only `city` instead of `*` to return all columns. Do remove `DESC` ordering instead of keeping descending sort to use default ascending order. The amended query now correctly returns only city names in ascending alphabetical order."
        ],
        "rules": [
            "1) When answering about \"List all cities of addresses in alphabetical order\": make sure the output order: city in ascending alphabetical order. 2) When the question asks for \"all cities\": select only the exact column token \"city\" instead of all columns. 3) When the question specifies \"alphabetical order\": use default ascending sort instead of descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM addresses ORDER BY city DESC;",
            "SELECT city FROM Addresses ORDER BY city;"
        ],
        "rule_sql": [
            "SELECT city FROM Addresses ORDER BY city ASC;"
        ]
    },
    "4679": {
        "db_id": "college_3",
        "question": "What are the first and last names of the instructors who teach the top 3 number of courses?",
        "ground_truth": "SELECT T2.Fname ,  T2.Lname FROM COURSE AS T1 JOIN FACULTY AS T2 ON T1.Instructor  =  T2.FacID GROUP BY T1.Instructor ORDER BY count(*) DESC LIMIT 3",
        "amends": [
            "Do select `T2.Fname` and `T2.Lname` instead of `i.first_name` and `i.last_name`. Do use `FACULTY` as `T2` instead of `instructors` as `i`. Do use `COURSE` as `T1` instead of `courses` as `c`. Do join on `T1.Instructor = T2.FacID` instead of `i.instructor_id = c.instructor_id`. Do group by `T1.Instructor` instead of `i.instructor_id`. Do order by `count(*) DESC` instead of `course_count DESC` while keeping the same `LIMIT 3`. The amended query now correctly counts courses per instructor using the proper table and column names from the schema."
        ],
        "rules": [
            "1) When answering about \"first and last names of instructors\": select T2.Fname and T2.Lname as the output columns. 2) When counting courses per instructor: use T1.Instructor as the grouping key and count all rows in each group. 3) When the question asks for \"top 3 number of courses\": rank instructors by course count in descending order and keep the first 3 rows. 4) When combining COURSE and FACULTY tables: link rows where T1.Instructor equals T2.FacID and keep only matching pairs (inner match). 5) When organizing results: group by T1.Instructor to compute aggregates per instructor."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT i.first_name, i.last_name, COUNT(c.course_id) as course_count\nFROM instructors i\nJOIN courses c ON i.instructor_id = c.instructor_id\nGROUP BY i.instructor_id\nORDER BY course_count DESC\nLIMIT 3;",
            "SELECT T2.Fname, T2.Lname\nFROM COURSE AS T1\nJOIN FACULTY AS T2 ON T1.Instructor = T2.FacID\nGROUP BY T1.Instructor\nORDER BY COUNT(*) DESC\nLIMIT 3"
        ],
        "rule_sql": [
            "SELECT T2.Fname, T2.Lname\nFROM Course T1\nJOIN Faculty T2 ON T1.Instructor = T2.FacID\nGROUP BY T1.Instructor\nORDER BY COUNT(*) DESC\nLIMIT 3"
        ]
    },
    "96": {
        "db_id": "student_assessment",
        "question": "What are the names of the courses in alphabetical order?",
        "ground_truth": "SELECT course_name FROM courses ORDER BY course_name",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_name FROM courses ORDER BY course_name DESC;"
        ],
        "rule_sql": [
            "SELECT course_name FROM Courses ORDER BY course_name ASC;"
        ]
    },
    "2789": {
        "db_id": "election",
        "question": "Which party has two or more records?",
        "ground_truth": "SELECT Party FROM party GROUP BY Party HAVING COUNT(*)  >=  2",
        "amends": [
            "Do reference the `Party` column from the `party` table instead of the `party` column from the `records` table. Do use the table alias `party` instead of `records` as the data source. Do change the threshold condition to `>= 2` instead of `> 1` to properly identify parties with two or more records. Do remove the `COUNT(*)` from the SELECT list instead of including it, focusing only on returning the party names. The amended query now correctly identifies parties with at least two entries in the party table."
        ],
        "rules": [
            "1) When the question asks about \"party\" records: use the \"Party\" column from the \"party\" table instead of any \"party\" column from other tables. 2) When counting records for parties: use the table alias \"party\" as the data source. 3) When identifying parties with two or more records: use a threshold condition of >= 2 instead of > 1 to properly include parties with exactly two records. 4) When selecting output columns: only return the party names and remove any count aggregates from the SELECT list."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT party, COUNT(*) FROM records GROUP BY party HAVING COUNT(*) > 1",
            "SELECT Party FROM party GROUP BY Party HAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT Party FROM party GROUP BY Party HAVING COUNT(*) >= 2;"
        ]
    },
    "5363": {
        "db_id": "tracking_software_problems",
        "question": "Which problem id and log id are assigned to the staff named Rylan Homenick?",
        "ground_truth": "SELECT DISTINCT T2.problem_id ,  T2.problem_log_id FROM staff AS T1 JOIN problem_log AS T2 ON T1.staff_id = T2.assigned_to_staff_id WHERE T1.staff_first_name = \"Rylan\" AND T1.staff_last_name = \"Homenick\"",
        "amends": [
            "Do select `T2.problem_id` and `T2.problem_log_id` instead of `problem_id` and `log_id`. Do add `DISTINCT` instead of omitting it. Do change the FROM source to `staff AS T1 JOIN problem_log AS T2` instead of just `staff`. Do add the join condition `ON T1.staff_id = T2.assigned_to_staff_id` instead of omitting it. Do change the WHERE filter to `T1.staff_first_name = \"Rylan\" AND T1.staff_last_name = \"Homenick\"` instead of `name = 'Rylan Homenick'`. The amended query now correctly joins staff with problem_log and filters by first and last name separately to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"problem id\" and \"log id\": select \"T2.problem_id\" and \"T2.problem_log_id\" instead of generic \"problem_id\" and \"log_id\". 2) When selecting from multiple tables to avoid duplicate results: use DISTINCT to return only unique combinations of the selected columns. 3) When combining staff and problem_log information: join \"staff AS T1\" with \"problem_log AS T2\" using the condition \"T1.staff_id = T2.assigned_to_staff_id\" to match staff members with their assigned problem logs. 4) When filtering by staff name \"Rylan Homenick\": use separate conditions \"T1.staff_first_name = 'Rylan'\" AND \"T1.staff_last_name = 'Homenick'\" instead of a single name field, matching the exact case and spelling."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT problem_id, log_id FROM staff WHERE name = 'Rylan Homenick';",
            "SELECT DISTINCT T2.problem_id, T2.problem_log_id FROM staff AS T1 JOIN problem_log AS T2 ON T1.staff_id = T2.assigned_to_staff_id WHERE T1.staff_first_name = \"Rylan\" AND T1.staff_last_name = \"Homenick\""
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.problem_id, T2.problem_log_id\nFROM Staff AS T1\nJOIN Problem_Log AS T2 ON T1.staff_id = T2.assigned_to_staff_id\nWHERE T1.staff_first_name = 'Rylan' AND T1.staff_last_name = 'Homenick'"
        ]
    },
    "5317": {
        "db_id": "manufactory_1",
        "question": "How many products are not made by Sony?",
        "ground_truth": "SELECT count(DISTINCT name) FROM products WHERE name NOT IN (SELECT T1.name FROM products AS T1 JOIN manufacturers AS T2 ON T1.Manufacturer  =  T2.code WHERE T2.name  =  'Sony')",
        "amends": [
            "Do use `count(DISTINCT name)` instead of `COUNT(*)` to count distinct product names rather than all rows. Do add a subquery filter with `name NOT IN (SELECT T1.name FROM products AS T1 JOIN manufacturers AS T2 ON T1.Manufacturer = T2.code WHERE T2.name = 'Sony')` instead of the simple `manufacturer = 'Sony'` condition to exclude products from Sony manufacturers by joining through the manufacturers table. Do remove the direct manufacturer filter and instead implement a correlated exclusion through the manufacturers join. The amended query now correctly counts distinct product names excluding those from Sony manufacturers, matching the intended behavior."
        ],
        "rules": [
            "1) When counting products: use count(DISTINCT name) to count distinct product names rather than all rows. 2) When excluding products made by Sony: use a subquery filter with name NOT IN (SELECT T1.name FROM products AS T1 JOIN manufacturers AS T2 ON T1.Manufacturer = T2.code WHERE T2.name = 'Sony') to exclude products from Sony manufacturers by joining through the manufacturers table. 3) When combining products and manufacturers tables: link rows where T1.Manufacturer = T2.code to correctly identify Sony manufacturers."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM products WHERE manufacturer = 'Sony';",
            "SELECT COUNT(DISTINCT name) FROM products WHERE name NOT IN (SELECT T1.name FROM products AS T1 JOIN manufacturers AS T2 ON T1.Manufacturer = T2.code WHERE T2.name = 'Sony')"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT name) FROM products WHERE name NOT IN (SELECT T1.name FROM products AS T1 JOIN manufacturers AS T2 ON T1.Manufacturer = T2.code WHERE T2.name = 'Sony')"
        ]
    },
    "646": {
        "db_id": "store_1",
        "question": "What are the names of all the tracks that are in both the Movies and music playlists?",
        "ground_truth": "SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  'Movies' INTERSECT SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  'Music'",
        "amends": [
            "Do use `INTERSECT` with two separate queries instead of multiple joins to find tracks in both playlists. Do reference `tracks AS T1` instead of `tracks t` and use consistent table aliasing. Do join `playlist_tracks AS T2` instead of `playlist_track pt1/pt2` with correct column references `T1.id = T2.track_id` instead of `t.TrackId = pt1.TrackId`. Do join `playlists AS T3` instead of `playlists p1/p2` with correct column references `T2.playlist_id = T3.id` instead of `pt1.PlaylistId = p1.PlaylistId`. Do move playlist name filters to `WHERE T3.name = 'Movies'` and `WHERE T3.name = 'Music'` instead of including them in join conditions. Do select `T1.name` instead of `t.Name` with proper casing. The amended query now correctly identifies tracks that appear in both the 'Movies' and 'Music' playlists using set intersection logic."
        ],
        "rules": [
            "1) When finding tracks that appear in multiple playlists: use INTERSECT to combine results from separate queries for each playlist instead of multiple joins. 2) When referencing the tracks table: use alias T1 and select T1.name with exact casing. 3) When joining playlist_tracks: use alias T2 and link using T1.id = T2.track_id. 4) When joining playlists: use alias T3 and link using T2.playlist_id = T3.id. 5) When filtering for the 'Movies' playlist: use WHERE T3.name = 'Movies' with exact casing and quotes. 6) When filtering for the 'Music' playlist: use WHERE T3.name = 'Music' with exact casing and quotes (note: 'music' should be 'Music'). 7) When combining results for both playlists: ensure both queries select T1.name to maintain compatible column structure for INTERSECT."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.Name \nFROM tracks t\nJOIN playlist_track pt1 ON t.TrackId = pt1.TrackId\nJOIN playlists p1 ON pt1.PlaylistId = p1.PlaylistId AND p1.Name = 'Movies'\nJOIN playlist_track pt2 ON t.TrackId = pt2.TrackId\nJOIN playlists p2 ON pt2.PlaylistId = p2.PlaylistId AND p2.Name = 'music';",
            "SELECT T1.name\nFROM tracks AS T1\nJOIN playlist_tracks AS T2 ON T1.id = T2.track_id\nJOIN playlists AS T3 ON T2.playlist_id = T3.id\nWHERE T3.name = 'Movies'\nINTERSECT\nSELECT T1.name\nFROM tracks AS T1\nJOIN playlist_tracks AS T2 ON T1.id = T2.track_id\nJOIN playlists AS T3 ON T2.playlist_id = T3.id\nWHERE T3.name = 'Music'"
        ],
        "rule_sql": [
            "SELECT T1.name FROM tracks T1\nJOIN playlist_tracks T2 ON T1.id = T2.track_id\nJOIN playlists T3 ON T2.playlist_id = T3.id\nWHERE T3.name = 'Movies'\nINTERSECT\nSELECT T1.name FROM tracks T1\nJOIN playlist_tracks T2 ON T1.id = T2.track_id\nJOIN playlists T3 ON T2.playlist_id = T3.id\nWHERE T3.name = 'Music'"
        ]
    },
    "812": {
        "db_id": "chinook_1",
        "question": "What is all the customer information for customers in NY state?",
        "ground_truth": "SELECT * FROM CUSTOMER WHERE State  =  \"NY\"",
        "amends": [
            "Do reference table `CUSTOMER` instead of `customers`. Do filter on state value `\"NY\"` instead of `'California'`. The amended query now correctly filters for New York customers from the appropriate table."
        ],
        "rules": [
            "1) When answering about customer information: use table \"CUSTOMER\" as the base table T1. 2) When the question mentions \"NY state\": filter rows where the state column equals \"NY\" exactly. 3) When selecting all customer information: return all columns from table \"CUSTOMER\" for matching rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM customers WHERE state = 'California';",
            "SELECT * FROM Customer WHERE State = 'NY';"
        ],
        "rule_sql": [
            "SELECT * FROM Customer WHERE State = 'NY';"
        ]
    },
    "11": {
        "db_id": "department_management",
        "question": "How many departments are led by heads who are not mentioned?",
        "ground_truth": "SELECT count(*) FROM department WHERE department_id NOT IN (SELECT department_id FROM management);",
        "amends": [
            "Do reference the `department` table instead of `departments` and use `department_id` instead of `head_id` as the column name. Do use `NOT IN` with a subquery selecting `department_id` from the `management` table instead of checking for NULL values or comparing against an `id` from an `employees` table. Do remove the `OR head_id IS NULL` condition and instead rely solely on the `NOT IN` predicate to identify departments without management records. The amended query now correctly counts departments that are not present in the management table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"departments\": use the exact table name \"department\" with double quotes as shown in the amends. 2) When identifying departments without management records: use the column \"department_id\" with double quotes from the \"department\" table in a NOT IN condition against the \"department_id\" column from the \"management\" table. 3) When counting departments: count using the canonical key \"department_id\" from the \"department\" table. 4) When combining department and management data: do not perform explicit joins but use a subquery to check for department_id presence in the management table. 5) When checking for departments without heads: do not check for NULL values on head_id; instead rely solely on the NOT IN condition against the management table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM departments WHERE head_id IS NULL OR head_id NOT IN (SELECT id FROM employees);",
            "SELECT COUNT(*) FROM department WHERE Department_ID NOT IN (SELECT department_ID FROM management)"
        ],
        "rule_sql": [
            "SELECT COUNT(\"Department_ID\") FROM \"department\" WHERE \"Department_ID\" NOT IN (SELECT \"Department_ID\" FROM \"management\")"
        ]
    },
    "2339": {
        "db_id": "csu_1",
        "question": "What is the campus fee for San Francisco State University in 1996?",
        "ground_truth": "SELECT campusfee FROM campuses AS T1 JOIN csu_fees AS T2 ON T1.id  =  t2.campus WHERE t1.campus  =  \"San Francisco State University\" AND T2.year  =  1996",
        "amends": [
            "Do select `campusfee` from the `campuses` table instead of `campus_fee` from `universities`. Do join `csu_fees` as `T2` on `T1.id = T2.campus` instead of querying a single table. Do filter on `t1.campus = \"San Francisco State University\"` instead of `name = 'San Francisco State University'`. Do filter on `T2.year = 1996` instead of `year = 1996`. The amended query now correctly retrieves the campus fee by joining the appropriate tables and using the correct column names and relationships."
        ],
        "rules": [
            "1) When the question asks about campus fee: select \"campusfee\" from the \"campuses\" table instead of \"campus_fee\" from \"universities\". 2) When combining campus and fee data: join \"csu_fees\" as T2 on T1.id = T2.campus to link the appropriate tables. 3) When filtering for a specific university: use T1.campus = \"San Francisco State University\" instead of name = 'San Francisco State University'. 4) When filtering for a specific year: use T2.year = 1996 instead of year = 1996."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT campus_fee FROM universities WHERE name = 'San Francisco State University' AND year = 1996;",
            "SELECT csu_fees.CampusFee \nFROM Campuses \nJOIN csu_fees ON Campuses.Id = csu_fees.Campus \nWHERE Campuses.Campus = 'San Francisco State University' \nAND csu_fees.Year = 1996"
        ],
        "rule_sql": [
            "SELECT csu_fees.CampusFee \nFROM csu_fees \nJOIN Campuses ON csu_fees.Campus = Campuses.Id \nWHERE Campuses.Campus = 'San Francisco State University' \nAND csu_fees.Year = 1996"
        ]
    },
    "2128": {
        "db_id": "cre_Doc_Control_Systems",
        "question": "List the employees who have not showed up in any circulation history of documents. List the employee's name.",
        "ground_truth": "SELECT employee_name FROM Employees EXCEPT SELECT Employees.employee_name FROM Employees JOIN Circulation_History ON Circulation_History.employee_id = Employees.employee_id",
        "amends": [
            "Do select `employee_name` from `Employees` instead of `name` from `employees`. Do use `EXCEPT` set operation instead of `NOT IN` subquery. Do add explicit table join between `Employees` and `Circulation_History` on `employee_id` instead of relying on implicit correlation. Do reference `Employees.employee_name` in the second SELECT clause instead of omitting table qualification. The amended query now correctly identifies employees without circulation history using proper set operations and explicit joins."
        ],
        "rules": [
            "1) When selecting employee names from the Employees table: use the exact column name \"employee_name\" instead of \"name\". 2) When finding employees who have not appeared in circulation history: use EXCEPT set operation instead of NOT IN subquery. 3) When combining Employees and Circulation_History tables: perform an explicit join on employee_id column equality. 4) When referencing columns in set operations: always qualify with table names using exact identifiers like \"Employees.employee_name\". 5) When identifying employees without circulation history: ensure the query properly handles the relationship between Employees.employee_id and Circulation_History.employee_id as foreign key reference."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM employees WHERE employee_id NOT IN (SELECT employee_id FROM circulation_history);",
            "SELECT employee_name FROM Employees\nEXCEPT\nSELECT Employees.employee_name FROM Employees\nJOIN Circulation_History ON Employees.employee_id = Circulation_History.employee_id"
        ],
        "rule_sql": [
            "SELECT Employees.employee_name\nFROM Employees\nEXCEPT\nSELECT Employees.employee_name\nFROM Employees\nJOIN Circulation_History ON Employees.employee_id = Circulation_History.employee_id"
        ]
    },
    "593": {
        "db_id": "store_1",
        "question": "Find the full name of employee who supported the most number of customers.",
        "ground_truth": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `employees` with `customers` on `T1.id = T2.support_rep_id` instead of on `e.employee_id = c.customer_id`. Do group by `T1.id` instead of `e.employee_id`. Do order by `count(*)` instead of `COUNT(c.customer_id)`. Do use table aliases `T1` and `T2` instead of `e` and `c`. The amended query now correctly identifies customer support representatives by joining on the support relationship rather than incorrectly matching employee IDs to customer IDs, and it properly counts all records in the group rather than counting customer IDs specifically.",
            "Do select `T1.first_name` and `T1.last_name` as separate columns instead of concatenating them into `full_name`. Do remove the alias `AS full_name` instead of keeping it. Do use `JOIN` on `T1.id = T2.support_rep_id` instead of any other join condition. Do group by `T1.id` instead of any other grouping. Do order by `count(*) DESC` instead of any other ordering. Do limit to `1` row instead of any other limit. The amended query now correctly returns separate first and last name columns without concatenation while maintaining the same join logic, grouping, ordering, and limit behavior."
        ],
        "rules": [
            "1) When joining employees and customers tables: link rows where T1.id equals T2.support_rep_id instead of employee_id to customer_id. 2) When grouping employee data: group by T1.id to organize results by employee identifier. 3) When counting supported customers: count all records in each group using count(*) instead of counting specific customer IDs. 4) When ordering results to find the employee with most customers: order by the count in descending direction and keep only the top result. 5) When using table aliases: use T1 for employees table and T2 for customers table as specified in the amends.",
            "1) When the question asks for the \"full name\" of an employee: return \"T1.first_name\" and \"T1.last_name\" as separate columns instead of concatenating them into a single column. 2) When combining employees (T1) and customers (T2) tables: link rows where \"T1.id = T2.support_rep_id\" using an inner join. 3) When grouping results by employee: group by \"T1.id\" to organize results per employee. 4) When counting the number of customers supported: use \"count(*)\" to count all rows in each group. 5) When finding the employee who supported the most customers: order by \"count(*) DESC\" to rank employees from highest to lowest customer count. 6) When only the top result is needed: limit to \"1\" row to return only the employee with the highest customer count."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.first_name, e.last_name \nFROM employees e \nJOIN customers c ON e.employee_id = c.customer_id \nGROUP BY e.employee_id \nORDER BY COUNT(c.customer_id) DESC \nLIMIT 1;",
            "SELECT T1.first_name || ' ' || T1.last_name AS full_name\nFROM employees T1\nJOIN customers T2 ON T1.id = T2.support_rep_id\nGROUP BY T1.id\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT T1.first_name, T1.last_name\nFROM employees T1\nJOIN customers T2 ON T1.id = T2.support_rep_id\nGROUP BY T1.id\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.last_name\nFROM employees T1\nINNER JOIN customers T2 ON T1.id = T2.support_rep_id\nGROUP BY T1.id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "158": {
        "db_id": "bike_1",
        "question": "For each zip code, how many times has the maximum wind speed reached 25 mph?",
        "ground_truth": "SELECT zip_code , count(*) FROM weather WHERE max_wind_Speed_mph  >=  25 GROUP BY zip_code",
        "amends": [
            "Do reference table `weather` instead of `weather_data` and use column `max_wind_Speed_mph` instead of `wind_speed`. Do apply filter `>= 25` instead of `= 25` to capture all records meeting or exceeding the threshold rather than exact matches only. Do remove the alias `count_max_wind_speed` instead of keeping it for simpler output. The amended query now correctly identifies zip codes with maximum wind speeds of at least 25 mph and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about wind speed data: use table \"weather\" instead of \"weather_data\" and column \"max_wind_Speed_mph\" instead of \"wind_speed\". 2) When filtering for maximum wind speed reaching 25 mph: apply condition >= 25 instead of = 25 to capture all records meeting or exceeding the threshold. 3) When counting occurrences per zip code: count all rows where the condition is met, grouped by zip_code. 4) When producing output: show zip_code and the count without any alias for the count column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT zip_code, COUNT(*) AS count_max_wind_speed\nFROM weather_data\nWHERE wind_speed = 25\nGROUP BY zip_code;",
            "SELECT zip_code, COUNT(*) \nFROM weather \nWHERE max_wind_Speed_mph >= 25 \nGROUP BY zip_code"
        ],
        "rule_sql": [
            "SELECT zip_code, COUNT(*) FROM weather WHERE max_wind_Speed_mph >= 25 GROUP BY zip_code"
        ]
    },
    "5262": {
        "db_id": "music_2",
        "question": "Who is performing in the back stage position for the song \"Der Kapitan\"? Show the first name and last name.",
        "ground_truth": "SELECT T2.firstname ,  T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId WHERE T3.Title  =  \"Der Kapitan\" AND T1.StagePosition  =  \"back\"",
        "amends": [
            "Do use explicit table aliases `T2.firstname` and `T2.lastname` instead of unqualified `first_name` and `last_name`. Do join `Performance AS T1` instead of querying only a `performers` table. Do add `JOIN Band AS T2 ON T1.bandmate = T2.id` to connect performance to band members instead of assuming performers exist independently. Do add `JOIN Songs AS T3 ON T3.SongId = T1.SongId` to properly reference songs by ID instead of directly filtering on song name. Do filter on `T3.Title = \"Der Kapitan\"` through the song table join instead of directly on `song_name` in a performers table. Do filter on `T1.StagePosition = \"back\"` through the performance table instead of `position = 'back stage'` in a performers table. The amended query now correctly joins performance, band, and song tables to find band members who performed \"Der Kapitan\" in the back stage position, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about performers for a specific song: join Performance AS T1, Band AS T2, and Songs AS T3 tables using T1.bandmate = T2.id and T3.SongId = T1.SongId. 2) When filtering by song title \"Der Kapitan\": use T3.Title = \"Der Kapitan\" through the Songs table join. 3) When filtering for back stage position: use T1.StagePosition = \"back\" through the Performance table. 4) When selecting first and last names: use T2.firstname and T2.lastname with explicit table aliases. 5) When combining tables for this query: perform inner joins using the exact key equalities T1.bandmate = T2.id and T3.SongId = T1.SongId."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM performers WHERE song_name = 'Der Kapitan' AND position = 'back stage';",
            "SELECT T2.Firstname, T2.Lastname\nFROM Performance AS T1\nJOIN Band AS T2 ON T1.Bandmate = T2.Id\nJOIN Songs AS T3 ON T3.SongId = T1.SongId\nWHERE T3.Title = 'Der Kapitan'\nAND T1.StagePosition = 'back'"
        ],
        "rule_sql": [
            "SELECT T2.Firstname, T2.Lastname\nFROM Performance AS T1\nINNER JOIN Band AS T2 ON T1.Bandmate = T2.Id\nINNER JOIN Songs AS T3 ON T1.SongId = T3.SongId\nWHERE T3.Title = \"Der Kapitan\" AND T1.StagePosition = \"back\""
        ]
    },
    "6326": {
        "db_id": "e_government",
        "question": "How many services are there?",
        "ground_truth": "SELECT count(*) FROM services",
        "amends": [
            "Do use lowercase `count(*)` instead of uppercase `COUNT(*)` to maintain consistent function casing. Do remove the `WHERE service_id IS NULL` filter instead of keeping it, as the correct query counts all rows in the services table without any filtering conditions. The amended query now matches the right SQL's behavior of returning the total count of all records in the services table."
        ],
        "rules": [
            "1) When counting all services: count all rows in the services table without any filtering conditions. 2) When using aggregate functions: use lowercase function names like count(*) to maintain consistent casing."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM services WHERE service_id IS NULL;",
            "SELECT count(*) FROM Services;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM Services;"
        ]
    },
    "5151": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "Return the the names of the drama workshop groups that are located in Feliciaberg city.",
        "ground_truth": "SELECT T2.Store_Name FROM Addresses AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Address_ID  =  T2.Address_ID WHERE T1.City_Town  =  \"Feliciaberg\"",
        "amends": [
            "Do select `T2.Store_Name` instead of `name`. Do join `Addresses AS T1` and `Drama_Workshop_Groups AS T2` instead of querying only `workshop_groups`. Do use `LEFT JOIN` on `T1.Address_ID = T2.Address_ID` instead of no join condition. Do filter on `T1.City_Town = \"Feliciaberg\"` instead of `city = 'Feliciaberg' AND type = 'comedy'`. The amended query now correctly retrieves store names from drama workshop groups located in Feliciaberg by properly joining address tables."
        ],
        "rules": [
            "1) When answering about drama workshop groups in Feliciaberg city: select T2.Store_Name instead of name. 2) When combining address and drama workshop group information: join Addresses AS T1 and Drama_Workshop_Groups AS T2 using LEFT JOIN on T1.Address_ID = T2.Address_ID. 3) When filtering for location in Feliciaberg: use T1.City_Town = \"Feliciaberg\" instead of city = 'Feliciaberg' AND type = 'comedy'. 4) When the question asks for drama workshop groups: do not include type = 'comedy' filter as the question specifically asks for drama groups."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM workshop_groups WHERE city = 'Feliciaberg' AND type = 'comedy';",
            "SELECT T2.Store_Name \nFROM Addresses AS T1 \nLEFT JOIN Drama_Workshop_Groups AS T2 ON T1.Address_ID = T2.Address_ID \nWHERE T1.City_Town = 'Feliciaberg'"
        ],
        "rule_sql": [
            "SELECT T2.Store_Name \nFROM Addresses AS T1 \nLEFT JOIN Drama_Workshop_Groups AS T2 ON T1.Address_ID = T2.Address_ID \nWHERE T1.City_Town = \"Feliciaberg\""
        ]
    },
    "2505": {
        "db_id": "movie_1",
        "question": "For each reviewer id, what is the title and rating for the movie with the smallest rating?",
        "ground_truth": "SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do include `T1.stars` in the SELECT list instead of omitting it. Do reference `T1.rID` instead of `reviewer_id` and `T1.stars` instead of `rating`. Do reference `T2.title` instead of `title` and ensure it's properly qualified. Do use `T1.mID = T2.mID` as the join condition instead of `movies.movie_id = ratings.movie_id`. Do group by `T1.rID` instead of `reviewer_id`. The amended query now correctly includes all necessary columns in the SELECT list, uses proper table aliasing, and maintains the correct grouping logic to match the RIGHT_SQL's behavior.",
            "Do add `min(T1.stars)` to the SELECT list instead of omitting it. Do change the join from `JOIN Movie T2` to `JOIN Movie AS T2` with explicit aliasing. Do remove the WHERE clause with subquery filtering instead of keeping it. Do add `GROUP BY T1.rID` instead of omitting grouping. Do remove the ORDER BY clause instead of keeping it. The amended query now correctly aggregates minimum stars per reviewer while including all necessary columns without redundant filtering.",
            "Do include `T2.title` and `T1.stars` in the SELECT list instead of omitting them from the GROUP BY clause, which would cause aggregation errors. Do maintain the same join condition `T1.mID = T2.mID` and GROUP BY `T1.rID` to correctly compute the minimum stars per reviewer. The amended query now properly handles the non-aggregated columns in the SELECT clause while preserving the same logical behavior.",
            "Do include `T2.title` in the SELECT list instead of omitting it, and do add `min(T1.stars)` as an aggregate function instead of not including it. Do remove the WHERE clause with the subquery checking for minimum stars instead of keeping it, and do move the minimum stars logic to the GROUP BY clause instead of using a subquery filter. Do remove the unnecessary GROUP BY clause at the end instead of keeping it, as the grouping is already handled by the main query structure. The amended query now correctly aggregates minimum stars per rID while including all necessary columns without redundant filtering.",
            "Do include `T2.title`, `T1.rID`, `T1.stars`, and `min(T1.stars)` in the SELECT list instead of only `T1.rID`, `T2.title`, and `T1.stars`. Do use a simple GROUP BY `T1.rID` instead of a subquery with `WHERE (T1.rID, T1.stars) IN` that finds minimum stars per rID. Do remove the subquery entirely instead of keeping it, as the aggregation can be handled directly in the main query. The amended query now correctly aggregates minimum stars per reviewer while including all necessary columns and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT reviewer_id, title, MIN(rating) FROM movies JOIN ratings ON movies.movie_id = ratings.movie_id GROUP BY reviewer_id;",
            "SELECT T1.rID, T2.title, T1.stars\nFROM Rating T1\nJOIN Movie T2 ON T1.mID = T2.mID\nWHERE (T1.rID, T1.stars) IN (\n    SELECT rID, MIN(stars)\n    FROM Rating\n    GROUP BY rID\n)\nORDER BY T1.rID;",
            "SELECT T1.rID, T2.title, T1.stars, min(T1.stars)\nFROM Rating T1\nJOIN Movie AS T2 ON T1.mID = T2.mID\nGROUP BY T1.rID",
            "SELECT T1.rID, T2.title, T1.stars\nFROM Rating T1\nJOIN Movie AS T2 ON T1.mID = T2.mID\nWHERE (T1.rID, T1.stars) IN (\n    SELECT rID, MIN(stars)\n    FROM Rating\n    GROUP BY rID\n)\nGROUP BY T1.rID",
            "SELECT T1.rID, T2.title, T1.stars\nFROM Rating T1\nJOIN Movie AS T2 ON T1.mID = T2.mID\nWHERE (T1.rID, T1.stars) IN (\n    SELECT rID, MIN(stars)\n    FROM Rating\n    GROUP BY rID\n)",
            "SELECT T1.rID, T2.title, T1.stars, min(T1.stars)\nFROM Rating T1\nJOIN Movie AS T2 ON T1.mID = T2.mID\nGROUP BY T1.rID"
        ],
        "rule_sql": []
    },
    "2587": {
        "db_id": "inn_1",
        "question": "Return the number of kids for the room reserved and checked in by DAMIEN TRACHSEL on  Sep 21, 2010.",
        "ground_truth": "SELECT Kids FROM Reservations WHERE CheckIn  =  \"2010-09-21\" AND FirstName  =  \"DAMIEN\" AND LastName  =  \"TRACHSEL\";",
        "amends": [
            "Do select `Kids` column instead of `COUNT(*)` aggregate. Do query from `Reservations` table instead of `kids` table with subquery. Do use `CheckIn = \"2010-09-21\"` filter instead of `check_in_date = '2010-09-21'`. Do use `FirstName = \"DAMIEN\" AND LastName = \"TRACHSEL\"` filters instead of `guest_name = 'DAMIEN TRACHSEL'`. Do remove `status = 'checked_in'` filter instead of keeping it. Do remove the subquery structure instead of using `IN` clause with subquery. The amended query now correctly retrieves the Kids count directly from Reservations with proper name field matching."
        ],
        "rules": [
            "1) When the question asks for \"number of kids\": select the \"Kids\" column instead of using COUNT(*) aggregate. 2) When the question mentions \"DAMIEN TRACHSEL\": use exact name matching with \"FirstName = 'DAMIEN'\" AND \"LastName = 'TRACHSEL'\" filters instead of a single guest_name field. 3) When the question specifies date \"Sep 21, 2010\": use exact date filter \"CheckIn = '2010-09-21'\" instead of check_in_date. 4) When the question asks about \"checked in\": do not include status = 'checked_in' filter as it is not needed. 5) When querying from the Reservations table: retrieve data directly from the main table instead of using subqueries with IN clauses."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM kids WHERE room_id IN (SELECT room_id FROM reservations WHERE guest_name = 'DAMIEN TRACHSEL' AND check_in_date = '2010-09-21' AND status = 'checked_in')",
            "SELECT Kids FROM Reservations WHERE FirstName = \"DAMIEN\" AND LastName = \"TRACHSEL\" AND CheckIn = \"2010-09-21\""
        ],
        "rule_sql": [
            "SELECT Kids FROM Reservations WHERE FirstName = 'DAMIEN' AND LastName = 'TRACHSEL' AND CheckIn = '2010-09-21';"
        ]
    },
    "1552": {
        "db_id": "customers_and_invoices",
        "question": "What are the ids, date opened, name, and other details for all accounts?",
        "ground_truth": "SELECT account_id ,  date_account_opened ,  account_name ,  other_account_details FROM Accounts",
        "amends": [
            "Do select `account_id`, `date_account_opened`, `account_name`, and `other_account_details` instead of `id`, `date_opened`, and `name`. Do reference the `Accounts` table instead of `accounts`. Do remove the `WHERE status = 'closed'` filter instead of keeping it. The amended query now correctly selects all columns from the Accounts table without filtering."
        ],
        "rules": [
            "1) When selecting account details from the Accounts table: use the exact column names \"account_id\", \"date_account_opened\", \"account_name\", and \"other_account_details\" instead of generic names like id, date_opened, or name. 2) When referencing the Accounts table: use the exact table name \"Accounts\" with proper capitalization, not lowercase \"accounts\". 3) When the question asks for \"all accounts\": do not apply any status filters and include all records from the Accounts table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, date_opened, name FROM accounts WHERE status = 'closed';",
            "SELECT account_id, date_account_opened, account_name, other_account_details FROM Accounts;"
        ],
        "rule_sql": [
            "SELECT account_id, date_account_opened, account_name, other_account_details FROM Accounts;"
        ]
    },
    "818": {
        "db_id": "chinook_1",
        "question": "What are the names of artist who have the letter 'a' in their names?",
        "ground_truth": "SELECT Name FROM ARTIST WHERE Name LIKE \"%a%\"",
        "amends": [
            "Do reference the table as `ARTIST` instead of `artists` and use the column name `Name` instead of `name` to match the correct schema. Do use double quotes for the pattern string `\"%a%\"` instead of single quotes `'%A%'` and make the pattern case-insensitive with lowercase `a` instead of uppercase `A` to ensure proper string matching. The amended query now correctly searches for names containing lowercase 'a' in the ARTIST table."
        ],
        "rules": [
            "1) When the question asks about artist names: use table \"ARTIST\" instead of \"artists\" to match the schema. 2) When referencing the name column: use column \"Name\" instead of \"name\" to match the schema. 3) When searching for patterns containing the letter 'a': use the pattern string \"%a%\" with double quotes instead of single quotes and lowercase 'a' instead of uppercase 'A' for case-insensitive matching."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM artists WHERE name LIKE '%A%';",
            "SELECT Name FROM Artist WHERE Name LIKE \"%a%\";"
        ],
        "rule_sql": [
            "SELECT Name FROM Artist WHERE Name LIKE \"%a%\";"
        ]
    },
    "1900": {
        "db_id": "school_finance",
        "question": "How many budgets are above 3000 in year 2001 or before?",
        "ground_truth": "SELECT count(*) FROM budget WHERE budgeted  >  3000 AND YEAR  <=  2001",
        "amends": [
            "Do reference the `budget` table instead of the non-existent `budgets` table. Do use the correct column name `budgeted` instead of the incorrect `budget` column. Do maintain the same filter conditions `> 3000` and `YEAR <= 2001` without changes. The amended query now correctly counts records from the existing table with the proper column reference, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"budgets\": use the exact table name \"budget\" instead of \"budgets\". 2) When the question mentions \"budgets are above 3000\": use the exact column name \"budgeted\" instead of \"budget\" with the condition > 3000. 3) When the question mentions \"in year 2001 or before\": use the condition YEAR <= 2001 with the exact literal value 2001."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM budgets WHERE budget > 3000 AND year <= 2001",
            "SELECT COUNT(*) FROM budget WHERE Budgeted > 3000 AND Year <= 2001"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM budget WHERE Budgeted > 3000 AND Year <= 2001"
        ]
    },
    "5193": {
        "db_id": "music_2",
        "question": "What are the unique labels for the albums?",
        "ground_truth": "SELECT count(DISTINCT label) FROM albums",
        "amends": [
            "Do use `count(DISTINCT label)` instead of `title` to aggregate distinct label counts rather than selecting distinct titles. Do remove the `DISTINCT` modifier from the SELECT clause instead of keeping it, as the aggregation function already handles uniqueness. Do change the selected column from `title` to `label` instead of keeping the original column, focusing on label distribution rather than album titles. The amended query now correctly counts distinct labels in the albums table, matching the intended analytical behavior."
        ],
        "rules": [
            "1) When the question asks for \"unique labels for the albums\": use the exact column token \"label\" from the albums table to identify labels. 2) When counting distinct values of a column: use count(DISTINCT column) instead of SELECT DISTINCT column to properly aggregate distinct counts. 3) When the question focuses on label distribution rather than individual titles: ensure the output column is \"label\" count instead of \"title\" values."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT title FROM albums;",
            "SELECT COUNT(DISTINCT Label) FROM Albums;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Label FROM Albums;"
        ]
    },
    "5091": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "Count the total number of bookings made.",
        "ground_truth": "SELECT count(*) FROM BOOKINGS",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS total_bookings FROM Bookings;"
        ]
    },
    "4309": {
        "db_id": "club_1",
        "question": "Count the number of clubs for which the student named \"Eric Tai\" is a member.",
        "ground_truth": "SELECT count(DISTINCT t1.clubname) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  \"Eric\" AND t3.lname  =  \"Tai\"",
        "amends": [
            "Do select `count(DISTINCT t1.clubname)` instead of `COUNT(*)` to count distinct club names rather than all rows. Do join `club AS t1` with `member_of_club AS t2` on `t1.clubid = t2.clubid` instead of querying only the `clubs` table. Do add a second join to `student AS t3` on `t2.stuid = t3.stuid` instead of omitting the student table relationship. Do filter with `t3.fname = \"Eric\" AND t3.lname = \"Tai\"` instead of `student_name = 'Eric Tai'` to properly match first and last name fields separately. The amended query now correctly counts distinct clubs that Eric Tai is a member of by properly traversing the relationship through the member_of_club junction table."
        ],
        "rules": [
            "1) When counting clubs for a specific student: join club AS t1 with member_of_club AS t2 on t1.clubid = t2.clubid to link clubs with their members. 2) When joining member_of_club with student information: join member_of_club AS t2 with student AS t3 on t2.stuid = t3.stuid to access student details. 3) When filtering for student \"Eric Tai\": use t3.fname = \"Eric\" AND t3.lname = \"Tai\" to match first and last name fields separately instead of a single student_name field. 4) When counting distinct clubs: use count(DISTINCT t1.clubname) to count unique club names rather than all rows. 5) When combining tables for this query: perform inner joins using the exact key equalities t1.clubid = t2.clubid and t2.stuid = t3.stuid to keep only matching pairs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM clubs WHERE student_name = 'Eric Tai';",
            "SELECT COUNT(DISTINCT t1.ClubName) \nFROM Club AS t1\nJOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID\nJOIN Student AS t3 ON t2.StuID = t3.StuID\nWHERE t3.Fname = 'Eric' AND t3.Lname = 'Tai'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT t1.ClubName) \nFROM Club AS t1 \nINNER JOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID \nINNER JOIN Student AS t3 ON t2.StuID = t3.StuID \nWHERE t3.Fname = 'Eric' AND t3.LName = 'Tai'"
        ]
    },
    "1612": {
        "db_id": "customers_and_invoices",
        "question": "Return the last name, id and phone number of the customer who has made the greatest number of orders.",
        "ground_truth": "SELECT T2.customer_last_name ,  T1.customer_id ,  T2.phone_number FROM Orders AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of no aliases. Do join `Orders AS T1` with `Customers AS T2` on `T1.customer_id = T2.customer_id` instead of querying only the `customers` table. Do select `T2.customer_last_name` and `T1.customer_id` instead of `last_name` and `id` without table qualification. Do add `GROUP BY T1.customer_id` to aggregate orders per customer instead of omitting grouping. Do use `count(*)` in the `ORDER BY` instead of `COUNT(orders.id)` without proper table reference. The amended query now correctly aggregates order counts per customer and returns the customer with the most orders, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"customer who has made the greatest number of orders\": join Orders AS T1 with Customers AS T2 on T1.customer_id = T2.customer_id using inner match. 2) When counting orders per customer: group by T1.customer_id and count using count(*). 3) When selecting customer information: output T2.customer_last_name, T1.customer_id, and phone_number (exact column names from schema). 4) When finding the customer with greatest number of orders: order by the count in descending direction and keep only the first row. 5) When handling column references: use exact column names T2.customer_last_name and T1.customer_id instead of unqualified last_name and id."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name, id, phone_number FROM customers ORDER BY COUNT(orders.id) DESC LIMIT 1;",
            "SELECT T2.customer_last_name, T1.customer_id, T2.phone_number\nFROM Orders AS T1\nJOIN Customers AS T2 ON T1.customer_id = T2.customer_id\nGROUP BY T1.customer_id\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.customer_last_name, T1.customer_id, T2.phone_number\nFROM Orders AS T1\nINNER JOIN Customers AS T2 ON T1.customer_id = T2.customer_id\nGROUP BY T1.customer_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "6914": {
        "db_id": "tracking_orders",
        "question": "On which day was the order placed whose shipment tracking number is 3452?",
        "ground_truth": "SELECT T1.date_order_placed FROM orders AS T1 JOIN shipments AS T2 ON T1.order_id = T2.order_id WHERE T2.shipment_tracking_number = 3452",
        "amends": [
            "Do select `T1.date_order_placed` instead of `order_date` and add table alias `T1`. Do add `JOIN shipments AS T2` instead of omitting the shipments table. Do use join condition `ON T1.order_id = T2.order_id` instead of no join condition. Do filter on `T2.shipment_tracking_number = 3452` instead of `tracking_number = 3452` to reference the correct table and column. The amended query now correctly retrieves order dates by joining orders with shipments and filtering on the shipment tracking number, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"order placed date for shipment tracking number 3452\": make sure the output order: T1.date_order_placed\n2) When the question mentions \"order placed\": \"order placed\" actually means \"T1.date_order_placed\" in schema\n3) When the question mentions \"shipment tracking number\": \"shipment tracking number\" actually means \"T2.shipment_tracking_number\" in schema\n4) When combining T1 (orders) and T2 (shipments) for shared entities: link rows where T1.order_id = T2.order_id; keep only matching pairs (inner match)\n5) When filtering for shipment tracking number 3452: use exact literal value 3452 with T2.shipment_tracking_number = 3452"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT order_date FROM orders WHERE tracking_number = 3452",
            "SELECT T1.date_order_placed \nFROM Orders AS T1\nJOIN Shipments AS T2 ON T1.order_id = T2.order_id\nWHERE T2.shipment_tracking_number = '3452'"
        ],
        "rule_sql": [
            "SELECT T1.date_order_placed \nFROM Orders T1\nINNER JOIN Shipments T2 ON T1.order_id = T2.order_id\nWHERE T2.shipment_tracking_number = '3452'"
        ]
    },
    "1147": {
        "db_id": "climbing",
        "question": "Which range contains the most mountains?",
        "ground_truth": "SELECT Range FROM mountain GROUP BY Range ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select only `Range` instead of both `range` and `COUNT(*) as mountain_count`. Do use table name `mountain` instead of `mountains`. Do move the aggregate function `COUNT(*)` to the `ORDER BY` clause instead of including it in the `SELECT` list. Do maintain the `GROUP BY Range` and `ORDER BY COUNT(*) DESC LIMIT 1` structure. The amended query now correctly returns only the Range with the highest count of mountains rather than both the range and count values."
        ],
        "rules": [
            "1) When answering about \"which range contains the most mountains\": make sure the output order: only show the Range value. 2) When the question mentions \"mountains\": use table name \"mountain\" exactly as shown in the schema. 3) When counting mountains: use COUNT(*) to count all rows in the mountain table. 4) When grouping by range: organize results by the \"Range\" column from the mountain table. 5) When finding the range with the highest count: order the groups by COUNT(*) in descending order and keep only the first result. 6) When producing output: do not include the count value in the final results, only show the Range value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT range, COUNT(*) as mountain_count FROM mountains GROUP BY range ORDER BY mountain_count DESC LIMIT 1;",
            "SELECT Range FROM mountain GROUP BY Range ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Range FROM mountain GROUP BY Range ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "6187": {
        "db_id": "music_4",
        "question": "What is the song in the volume with the maximum weeks on top?",
        "ground_truth": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1",
        "amends": [
            "Do reference the `Song` column instead of `song` to match the correct case sensitivity. Do reference the `volume` table instead of `volumes` to use the proper table name. Do reference the `Weeks_on_Top` column instead of `weeks_on_top` to match the correct case sensitivity. The amended query now correctly references the proper table and column names to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"song\": use the exact column name \"Song\" from the volume table. 2) When the question asks about \"weeks on top\": use the exact column name \"Weeks_on_Top\" from the volume table. 3) When the question asks for the maximum value: order rows by \"Weeks_on_Top\" in descending order and take the first row. 4) When the question refers to the \"volume\" table: use the exact table name \"volume\" (not \"volumes\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT song FROM volumes ORDER BY weeks_on_top DESC LIMIT 1;",
            "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1;"
        ]
    },
    "357": {
        "db_id": "flight_1",
        "question": "Show the name of aircrafts with top three lowest distances.",
        "ground_truth": "SELECT name FROM Aircraft ORDER BY distance LIMIT 3",
        "amends": [
            "Do remove the `ASC` keyword from the `ORDER BY` clause instead of including it, as the default ascending order is implied. Do reference the table as `Aircraft` instead of `aircrafts` to match the correct table name. The amended query now correctly selects aircraft names ordered by distance and limits to 3 results, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"top three lowest distances\": rank rows by \"distance\" in ascending order and keep the first 3 rows. 2) When the question mentions \"aircrafts\": \"aircrafts\" actually means \"Aircraft\" in schema. 3) When ordering by distance: use the default ascending order without explicitly specifying ASC."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM aircrafts ORDER BY distance ASC LIMIT 3;",
            "SELECT name FROM aircraft ORDER BY distance LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT name FROM aircraft ORDER BY distance LIMIT 3;"
        ]
    },
    "1440": {
        "db_id": "college_2",
        "question": "Find the name of instructors who didn't teach any courses?",
        "ground_truth": "SELECT name FROM instructor WHERE id NOT IN (SELECT id FROM teaches)",
        "amends": [
            "Do reference table `instructor` instead of `instructors` in the FROM clause. Do use a subquery with `NOT IN` condition instead of checking `course_id IS NULL` in the WHERE clause. Do filter by `id NOT IN (SELECT id FROM teaches)` instead of `course_id IS NULL` to correctly identify instructors who are not teaching any courses. The amended query now matches RIGHT_SQL's behavior by properly identifying instructors without teaching assignments."
        ],
        "rules": [
            "1) When the question asks about instructors who didn't teach any courses: use table \"instructor\" instead of \"instructors\" as the main data source. 2) When identifying instructors without teaching assignments: use a subquery with NOT IN condition where \"id\" from \"instructor\" is not in the \"id\" values from \"teaches\" table. 3) When checking for instructors not teaching courses: do not check for course_id IS NULL in the instructor table, as this may not correctly identify the relationship between instructors and courses."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM instructors WHERE course_id IS NULL;",
            "SELECT name FROM instructor WHERE id NOT IN (SELECT id FROM teaches)"
        ],
        "rule_sql": [
            "SELECT name FROM instructor WHERE ID NOT IN (SELECT DISTINCT ID FROM teaches)"
        ]
    },
    "534": {
        "db_id": "allergy_1",
        "question": "How many students are over 18 and do not have allergy to food type or animal type?",
        "ground_truth": "SELECT count(*) FROM Student WHERE age  >  18 AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  \"food\" OR T2.allergytype  =  \"animal\")",
        "amends": [
            "Do use table name `Student` instead of `students` and add a subquery to exclude students with specific allergies instead of directly filtering on a non-existent `allergy_type` column. Do replace the incorrect condition `allergy_type != 'food' OR allergy_type != 'animal'` with a `NOT IN` subquery that joins `Has_allergy` and `Allergy_Type` tables on `Allergy` to identify students with food or animal allergies. Do add the required table joins `Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy` instead of attempting to filter on a single table. Do use proper column references `StuID`, `Allergy`, and `allergytype` instead of the non-existent `allergy_type`. The amended query now correctly excludes students with food or animal allergies by using a correlated subquery approach instead of the flawed direct filtering logic, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about students over 18 without food or animal allergies: use table name \"Student\" instead of \"students\". 2) When filtering for students over 18: use condition age > 18. 3) When excluding students with food or animal allergies: use a subquery that joins \"Has_allergy\" AS T1 and \"Allergy_Type\" AS T2 on T1.Allergy = T2.Allergy to identify students with these allergies. 4) When referencing student identifiers: use column \"StuID\" as the canonical key for counting students. 5) When checking for allergy types: use column \"allergytype\" from \"Allergy_Type\" table to identify 'food' and 'animal' allergy types. 6) When counting students: count distinct \"StuID\" values to avoid duplicate counts of students with multiple allergies."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE age > 18 AND (allergy_type != 'food' OR allergy_type != 'animal');",
            "SELECT COUNT(*) \nFROM Student \nWHERE Age > 18 \nAND StuID NOT IN (\n    SELECT DISTINCT StuID \n    FROM Has_Allergy \n    JOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy \n    WHERE AllergyType IN ('food', 'animal')\n)"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Student.StuID) \nFROM Student \nWHERE Student.Age > 18 \nAND Student.StuID NOT IN (\n    SELECT T1.StuID \n    FROM Has_Allergy AS T1 \n    JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy \n    WHERE T2.AllergyType IN ('food', 'animal')\n)"
        ]
    },
    "2971": {
        "db_id": "sakila_1",
        "question": "Count the number of different languages in these films.",
        "ground_truth": "SELECT count(DISTINCT language_id) FROM film",
        "amends": [
            "Do `count(DISTINCT language_id)` instead of `COUNT(*)` to count distinct language identifiers rather than all rows. Do reference table `film` instead of `films` to use the correct table name. The amended query now correctly counts distinct language IDs from the film table."
        ],
        "rules": [
            "1) When counting different languages in films: count distinct values of \"language_id\" from table \"film\" instead of counting all rows. 2) When referencing the films table: use the exact table name \"film\" instead of \"films\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM films;",
            "SELECT COUNT(DISTINCT language_id) FROM film;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT language_id) FROM film;"
        ]
    },
    "4702": {
        "db_id": "college_3",
        "question": "Give the maximum and minimum gradepoints for students living in NYC?",
        "ground_truth": "SELECT max(T2.gradepoint) ,  min(T2.gradepoint) FROM ENROLLED_IN AS T1 JOIN GRADECONVERSION AS T2 JOIN STUDENT AS T3 ON T1.Grade  =  T2.lettergrade AND T1.StuID  =  T3.StuID WHERE T3.city_code  =  \"NYC\"",
        "amends": [
            "Do use `max(T2.gradepoint)` and `min(T2.gradepoint)` instead of `MAX(grade)` and `MIN(grade)` to reference the correct numeric grade values. Do join `ENROLLED_IN AS T1`, `GRADECONVERSION AS T2`, and `STUDENT AS T3` instead of querying only `students` to properly relate enrollment records with grade conversions and student data. Do apply join conditions `T1.Grade = T2.lettergrade` and `T1.StuID = T3.StuID` instead of no joins to correctly map letter grades to numeric values and link enrollments to students. Do filter on `T3.city_code = \"NYC\"` instead of `city = 'NYC'` to use the correct column name and table reference for the city filter. The amended query now correctly aggregates numeric grade points for NYC students by properly joining the necessary tables and converting letter grades to their numeric equivalents."
        ],
        "rules": [
            "1) When answering about maximum and minimum gradepoints for students: use max(T2.gradepoint) and min(T2.gradepoint) instead of MAX(grade) and MIN(grade) to reference the correct numeric grade values. 2) When combining enrollment, grade conversion, and student data: join ENROLLED_IN AS T1, GRADECONVERSION AS T2, and STUDENT AS T3 instead of querying only students to properly relate enrollment records with grade conversions and student data. 3) When linking enrollment records to grade conversions: apply join condition T1.Grade = T2.lettergrade to correctly map letter grades to numeric values. 4) When linking enrollment records to students: apply join condition T1.StuID = T3.StuID to connect enrollments to student data. 5) When filtering for students living in NYC: use T3.city_code = \"NYC\" instead of city = 'NYC' to use the correct column name and table reference for the city filter."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(grade), MIN(grade) FROM students WHERE city = 'NYC';",
            "SELECT MAX(T2.gradepoint) AS max_gradepoint, MIN(T2.gradepoint) AS min_gradepoint\nFROM Enrolled_in AS T1\nJOIN Gradeconversion AS T2 ON T1.Grade = T2.lettergrade\nJOIN Student AS T3 ON T1.StuID = T3.StuID\nWHERE T3.city_code = 'NYC'"
        ],
        "rule_sql": [
            "SELECT MAX(T2.gradepoint) AS max_gradepoint, MIN(T2.gradepoint) AS min_gradepoint\nFROM Enrolled_in AS T1\nJOIN Gradeconversion AS T2 ON T1.Grade = T2.lettergrade\nJOIN Student AS T3 ON T1.StuID = T3.StuID\nWHERE T3.city_code = 'NYC'"
        ]
    },
    "477": {
        "db_id": "allergy_1",
        "question": "Which city does the student whose last name is \"Kim\" live in?",
        "ground_truth": "SELECT city_code FROM Student WHERE LName  =  \"Kim\"",
        "amends": [
            "Do select `city_code` instead of `city` in the SELECT list. Do reference table `Student` instead of `students` in the FROM clause. Do filter on `LName = \"Kim\"` instead of `first_name = 'Kim'` in the WHERE clause, changing both the column reference and the string literal quotation style. The amended query now correctly retrieves city codes from the Student table for records with last name Kim, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"city\": use the exact column token \"city_code\" from the Student table instead of \"city\". 2) When referencing the student table: use the exact table name \"Student\" instead of \"students\". 3) When filtering by last name \"Kim\": use the exact column token \"LName\" with double quotes around the literal value \"Kim\" instead of filtering by first_name with single quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city FROM students WHERE first_name = 'Kim';",
            "SELECT city_code FROM Student WHERE LName = \"Kim\";"
        ],
        "rule_sql": [
            "SELECT city_code FROM Student WHERE LName = \"Kim\";"
        ]
    },
    "4819": {
        "db_id": "aircraft",
        "question": "What is the average total number of passengers of airports that are associated with aircraft \"Robinson R-22\"?",
        "ground_truth": "SELECT avg(T3.Total_Passengers) FROM aircraft AS T1 JOIN airport_aircraft AS T2 ON T1.Aircraft_ID  =  T2.Aircraft_ID JOIN airport AS T3 ON T2.Airport_ID  =  T3.Airport_ID WHERE T1.Aircraft  =  \"Robinson R-22\"",
        "amends": [
            "Do join `aircraft AS T1` and `airport_aircraft AS T2` on `T1.Aircraft_ID = T2.Aircraft_ID` instead of querying only the `airports` table. Do join `airport AS T3` on `T2.Airport_ID = T3.Airport_ID` instead of missing the necessary table relationships. Do filter on `T1.Aircraft = \"Robinson R-22\"` instead of filtering on `aircraft_type` which doesn't exist in the correct table structure. Do select `avg(T3.Total_Passengers)` from the joined `airport` table instead of selecting `AVG(total_passengers)` from a single table. The amended query now correctly calculates the average passengers for Robinson R-22 aircraft across all associated airports."
        ],
        "rules": [
            "1) When answering about airports associated with a specific aircraft: join aircraft AS T1 and airport_aircraft AS T2 on T1.Aircraft_ID = T2.Aircraft_ID to link aircraft to their airport associations. 2) When joining airport information: join airport AS T3 on T2.Airport_ID = T3.Airport_ID to access airport passenger data. 3) When filtering for aircraft \"Robinson R-22\": use T1.Aircraft = \"Robinson R-22\" as the exact filter condition with proper case and quotes. 4) When calculating average total passengers: compute avg(T3.Total_Passengers) from the airport table after proper joins and filtering."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(total_passengers) \nFROM airports \nWHERE aircraft_type = 'Robinson R-22';",
            "SELECT AVG(T3.Total_Passengers) \nFROM aircraft AS T1\nJOIN airport_aircraft AS T2 ON T1.Aircraft_ID = T2.Aircraft_ID\nJOIN airport AS T3 ON T2.Airport_ID = T3.Airport_ID\nWHERE T1.Aircraft = 'Robinson R-22'"
        ],
        "rule_sql": [
            "SELECT AVG(T3.Total_Passengers) \nFROM aircraft AS T1 \nJOIN airport_aircraft AS T2 ON T1.Aircraft_ID = T2.Aircraft_ID \nJOIN airport AS T3 ON T2.Airport_ID = T3.Airport_ID \nWHERE T1.Aircraft = \"Robinson R-22\""
        ]
    },
    "1479": {
        "db_id": "college_2",
        "question": "What are the ids for courses that were offered in both Fall of 2009 and Spring of 2010?",
        "ground_truth": "SELECT course_id FROM SECTION WHERE semester  =  'Fall' AND YEAR  =  2009 INTERSECT SELECT course_id FROM SECTION WHERE semester  =  'Spring' AND YEAR  =  2010",
        "amends": [
            "Do query from `SECTION` table instead of `course_offerings` table. Do use `INTERSECT` to find courses offered in both semesters instead of using `AND` conditions that would never match. Do split into two separate queries for Fall 2009 and Spring 2010 instead of combining both conditions in a single WHERE clause that creates an impossible filter. Do remove the contradictory `semester = 'Fall' AND semester = 'Spring'` condition that would return no results. The amended query now correctly identifies courses offered in both specified semesters by using set intersection."
        ],
        "rules": [
            "1) When answering about courses offered in both Fall 2009 and Spring 2010: use the SECTION table instead of course_offerings table. 2) When finding courses offered in multiple semesters: use INTERSECT operation to combine results from separate semester queries instead of using AND conditions that create impossible filters. 3) When querying for Fall 2009 courses: create a separate query for semester = 'Fall' AND year = 2009. 4) When querying for Spring 2010 courses: create a separate query for semester = 'Spring' AND year = 2010. 5) When combining results from multiple semester queries: use exact string literals 'Fall' and 'Spring' with exact case and spacing as shown."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_id FROM course_offerings WHERE semester = 'Fall' AND year = 2009 AND semester = 'Spring' AND year = 2010",
            "SELECT course_id FROM section WHERE semester = 'Fall' AND year = 2009\nINTERSECT\nSELECT course_id FROM section WHERE semester = 'Spring' AND year = 2010"
        ],
        "rule_sql": [
            "SELECT course_id FROM section WHERE semester = 'Fall' AND year = 2009\nINTERSECT\nSELECT course_id FROM section WHERE semester = 'Spring' AND year = 2010"
        ]
    },
    "1703": {
        "db_id": "epinions_1",
        "question": "Find the names of items whose rank is higher than 3 and whose average rating is above 5.",
        "ground_truth": "SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id WHERE T2.rank  >  3 INTERSECT SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id GROUP BY T2.i_id HAVING avg(T2.rating)  >  5",
        "amends": [
            "Do select `T1.title` instead of `name` and change the source to `item AS T1` instead of `items`. Do add `JOIN review AS T2 ON T1.i_id = T2.i_id` instead of a single table query. Do change the filter to use `T2.rank > 3` instead of `rank > 3 AND rating > 5` and split the logic using `INTERSECT` instead of a single WHERE clause. Do add a second query with `GROUP BY T2.i_id HAVING avg(T2.rating) > 5` instead of filtering individual ratings, ensuring the average rating condition is properly applied per item. The amended query now correctly finds items with rank > 3 that also have an average rating greater than 5, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"names of items\": use \"T1.title\" instead of \"name\" as the output column. 2) When combining item and review data: link rows where \"T1.i_id = T2.i_id\" and keep only matching pairs (inner match). 3) When filtering by rank higher than 3: use \"T2.rank > 3\" as the condition. 4) When filtering by average rating above 5: group by \"T2.i_id\" and compute the average of \"T2.rating\", then keep only groups where \"avg(T2.rating) > 5\". 5) When both rank and average rating conditions must be satisfied: use INTERSECT to combine the results of the two separate filtering conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM items WHERE rank > 3 AND rating > 5;",
            "SELECT T1.title\nFROM item AS T1\nJOIN review AS T2 ON T1.i_id = T2.i_id\nWHERE T2.rank > 3\nINTERSECT\nSELECT T1.title\nFROM item AS T1\nJOIN review AS T2 ON T1.i_id = T2.i_id\nGROUP BY T2.i_id\nHAVING AVG(T2.rating) > 5"
        ],
        "rule_sql": [
            "SELECT T1.title FROM item T1 INNER JOIN review T2 ON T1.i_id = T2.i_id WHERE T2.rank > 3 INTERSECT SELECT T1.title FROM item T1 INNER JOIN review T2 ON T1.i_id = T2.i_id GROUP BY T2.i_id HAVING AVG(T2.rating) > 5"
        ]
    },
    "6111": {
        "db_id": "customers_and_addresses",
        "question": "What is the payment method of the customer that has purchased the least quantity of items?",
        "ground_truth": "SELECT t1.payment_method FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id GROUP BY t1.customer_name ORDER BY sum(t3.order_quantity) LIMIT 1",
        "amends": [
            "Do add `t1.payment_method` with explicit table alias instead of `payment_method` without qualification. Do add `FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id = t2.customer_id JOIN order_items AS t3 ON t2.order_id = t3.order_id` with two additional joined tables instead of just `FROM customers`. Do add `GROUP BY t1.customer_name` instead of omitting grouping. Do change `ORDER BY sum(t3.order_quantity)` with aggregate function instead of `ORDER BY quantity_purchased ASC` with simple column reference. Do remove the `ASC` direction specification instead of keeping it explicit. The amended query now correctly joins related tables, aggregates order quantities, and returns the payment method for the customer with the smallest total order quantity."
        ],
        "rules": [
            "1) When answering about payment method of a customer: use the exact column token \"t1.payment_method\" with table alias qualification. 2) When combining customer and order information: link tables using exact key equality \"t1.customer_id = t2.customer_id\" and \"t2.order_id = t3.order_id\" to keep only matching pairs (inner match). 3) When grouping by customer: use \"t1.customer_name\" as the grouping key to organize results per customer. 4) When calculating total quantity purchased: compute sum of \"t3.order_quantity\" per customer instead of using simple column reference. 5) When finding the customer with least quantity: order by the aggregate sum in ascending direction (smallest first) and take the first row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT payment_method FROM customers ORDER BY quantity_purchased ASC LIMIT 1;",
            "SELECT t1.payment_method\nFROM customers AS t1\nJOIN customer_orders AS t2 ON t1.customer_id = t2.customer_id\nJOIN order_items AS t3 ON t2.order_id = t3.order_id\nGROUP BY t1.customer_name\nORDER BY SUM(t3.order_quantity)\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t1.payment_method\nFROM Customers t1\nINNER JOIN Customer_Orders t2 ON t1.customer_id = t2.customer_id\nINNER JOIN Order_Items t3 ON t2.order_id = t3.order_id\nGROUP BY t1.customer_name\nORDER BY SUM(CAST(t3.order_quantity AS INTEGER)) ASC\nLIMIT 1;"
        ]
    },
    "4260": {
        "db_id": "club_1",
        "question": "Who are the members of the club named \"Hopkins Student Enterprises\"? Show the last name.",
        "ground_truth": "SELECT t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Hopkins Student Enterprises\"",
        "amends": [
            "Do select `t3.lname` instead of `first_name` to retrieve the correct column from the student table. Do join three tables (`club`, `member_of_club`, and `student`) with explicit `JOIN` conditions instead of querying a single `members` table. Do use proper join predicates `t1.clubid = t2.clubid` and `t2.stuid = t3.stuid` instead of a simple WHERE filter to establish the correct relationships between club membership and student data. Do filter on `t1.clubname` instead of `club_name` to use the correct column name from the club table. The amended query now correctly retrieves student last names for members of the specified club by properly joining the normalized database tables."
        ],
        "rules": [
            "1) When answering about members of a club: join three tables club (T1), member_of_club (T2), and student (T3) using the exact join conditions T1.clubid = T2.clubid and T2.stuid = T3.stuid to establish proper relationships. 2) When filtering for a specific club name: use T1.clubname = 'Hopkins Student Enterprises' with exact case and spacing as shown. 3) When retrieving student last names: select T3.lname instead of first_name to get the correct column from the student table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM members WHERE club_name = 'Hopkins Student Enterprises';",
            "SELECT t3.LName \nFROM Club t1 \nJOIN Member_of_club t2 ON t1.ClubID = t2.ClubID \nJOIN Student t3 ON t2.StuID = t3.StuID \nWHERE t1.ClubName = 'Hopkins Student Enterprises'"
        ],
        "rule_sql": [
            "SELECT T3.LName \nFROM Club T1\nJOIN Member_of_club T2 ON T1.ClubID = T2.ClubID\nJOIN Student T3 ON T2.StuID = T3.StuID\nWHERE T1.ClubName = 'Hopkins Student Enterprises'"
        ]
    },
    "4240": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "Show the ids of the employees who don't authorize destruction for any document.",
        "ground_truth": "SELECT employee_id FROM Employees EXCEPT SELECT Destruction_Authorised_by_Employee_ID FROM Documents_to_be_destroyed",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` subquery. Do select from `Employees` table instead of `employees` table. Do reference `Destruction_Authorised_by_Employee_ID` from `Documents_to_be_destroyed` table instead of `employee_id` from `document_destruction_authorizations` table. The amended query now correctly identifies employees without document destruction authorizations using proper set operations and table/column references."
        ],
        "rules": [
            "1) When answering about employees who don't authorize destruction: use the Employees table as T1 and Documents_to_be_Destroyed table as T2. 2) When checking for employees without authorizations: use EXCEPT set operation instead of NOT IN subquery. 3) When referencing destruction authorization records: use Destruction_Authorised_by_Employee_ID column from Documents_to_be_Destroyed table. 4) When selecting employee identifiers: use Employee_ID column from Employees table. 5) When combining employee and authorization data: ensure the Employee_ID from Employees matches Destruction_Authorised_by_Employee_ID from Documents_to_be_Destroyed for proper set comparison."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT employee_id FROM employees WHERE employee_id NOT IN (SELECT employee_id FROM document_destruction_authorizations)",
            "SELECT Employee_ID FROM Employees\nEXCEPT\nSELECT Destruction_Authorised_by_Employee_ID FROM Documents_to_be_Destroyed WHERE Destruction_Authorised_by_Employee_ID IS NOT NULL;"
        ],
        "rule_sql": [
            "SELECT Employee_ID FROM Employees\nEXCEPT\nSELECT Destruction_Authorised_by_Employee_ID FROM Documents_to_be_Destroyed WHERE Destruction_Authorised_by_Employee_ID IS NOT NULL"
        ]
    },
    "5667": {
        "db_id": "customers_and_products_contacts",
        "question": "Show the product type and name for the products with price higher than 1000 or lower than 500.",
        "ground_truth": "SELECT product_type_code ,  product_name FROM products WHERE product_price  >  1000 OR product_price  <  500",
        "amends": [
            "Do select `product_type_code` instead of `product_type` and use `product_price` instead of `price` in the WHERE clause. Do use `OR` instead of `AND` between the price conditions, changing the logic from finding products with prices between 1000 and 500 to finding products with prices either above 1000 or below 500. The amended query now correctly references the actual column names and uses the appropriate logical operator to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"product type\": use the exact column \"product_type_code\" from the Products table instead of \"product_type\". 2) When the question mentions \"price\": use the exact column \"product_price\" from the Products table instead of \"price\". 3) When the question asks for products with price higher than 1000 or lower than 500: use OR logic between the conditions \"product_price > 1000\" and \"product_price < 500\" instead of AND logic."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT product_type, product_name FROM products WHERE price > 1000 AND price < 500;",
            "SELECT product_type_code, product_name FROM Products WHERE product_price > 1000 OR product_price < 500;"
        ],
        "rule_sql": [
            "SELECT product_type_code, product_name FROM Products WHERE product_price > 1000 OR product_price < 500;"
        ]
    },
    "6700": {
        "db_id": "driving_school",
        "question": "List lesson id of all lessons taught by staff with first name as Janessa, last name as Sawayn and nickname containing letter 's'.",
        "ground_truth": "SELECT T1.lesson_id FROM Lessons AS T1 JOIN Staff AS T2 ON T1.staff_id = T2.staff_id WHERE T2.first_name = \"Janessa\" AND T2.last_name = \"Sawayn\" AND nickname LIKE \"%s%\";",
        "amends": [
            "Do join `Lessons AS T1` with `Staff AS T2` on `T1.staff_id = T2.staff_id` instead of querying only the `lessons` table without proper joins. Do reference columns `T2.first_name`, `T2.last_name`, and `nickname` from the Staff table instead of incorrectly using `staff_first_name`, `staff_last_name`, and `staff_nickname` from the Lessons table. Do use double quotes for string literals instead of single quotes. The amended query now correctly joins tables to access staff information and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about lessons taught by specific staff: join table \"Lessons\" as T1 with table \"Staff\" as T2 on T1.staff_id = T2.staff_id to access staff information. 2) When the question mentions \"first name as Janessa\": use column T2.first_name with exact literal value \"Janessa\" (double quotes). 3) When the question mentions \"last name as Sawayn\": use column T2.last_name with exact literal value \"Sawayn\" (double quotes). 4) When the question mentions \"nickname containing letter 's'\": use column T2.nickname with pattern matching condition containing lowercase 's'. 5) When selecting output: return lesson_id from T1 table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT lesson_id FROM lessons WHERE staff_first_name = 'Janessa' AND staff_last_name = 'Sawayn' AND staff_nickname LIKE '%s%';",
            "SELECT T1.lesson_id FROM Lessons AS T1 JOIN Staff AS T2 ON T1.staff_id = T2.staff_id WHERE T2.first_name = \"Janessa\" AND T2.last_name = \"Sawayn\" AND T2.nickname LIKE \"%s%\""
        ],
        "rule_sql": [
            "SELECT T1.lesson_id\nFROM Lessons AS T1\nJOIN Staff AS T2 ON T1.staff_id = T2.staff_id\nWHERE T2.first_name = \"Janessa\"\nAND T2.last_name = \"Sawayn\"\nAND T2.nickname LIKE '%s%'"
        ]
    },
    "5113": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "Sort the names of products in ascending order of their price.",
        "ground_truth": "SELECT Product_Name FROM Products ORDER BY Product_Price ASC",
        "amends": [
            "Do use `Product_Name` instead of `name` in the SELECT list. Do use `Product_Price` instead of `price` in the ORDER BY clause. Do use `ASC` ordering instead of `DESC` ordering. Do reference `Products` instead of `products` as the table name. The amended query now correctly selects the product name column, orders by product price in ascending order, and uses the proper table name to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for product names: use \"Product_Name\" from table \"Services\" instead of \"name\". 2) When ordering products by price: use \"Product_Price\" from table \"Services\" instead of \"price\". 3) When sorting in ascending order: use ASC ordering instead of DESC ordering. 4) When referencing the products table: use \"Services\" instead of \"products\" as the table name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM products ORDER BY price DESC;",
            "SELECT Product_Name FROM Products ORDER BY Product_Price ASC;"
        ],
        "rule_sql": [
            "SELECT Product_Name FROM Services ORDER BY Product_Price ASC;"
        ]
    },
    "3760": {
        "db_id": "program_share",
        "question": "find the names of programs whose origin is not in Beijing.",
        "ground_truth": "SELECT name FROM program WHERE origin != 'Beijing'",
        "amends": [
            "Do filter with `origin != 'Beijing'` instead of `origin = 'Beijing'` to exclude rather than include Beijing records, and do reference table `program` instead of `programs` to use the correct table name. The amended query now correctly selects program names from all origins except Beijing."
        ],
        "rules": [
            "1) When the question asks for programs whose origin is not in Beijing: filter records where the \"origin\" column is not equal to 'Beijing'. 2) When referencing the programs table: use the exact table name \"program\" instead of \"programs\". 3) When selecting program names: output the \"name\" column from the filtered results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM programs WHERE origin = 'Beijing'",
            "SELECT Name FROM program WHERE Origin != 'Beijing';"
        ],
        "rule_sql": [
            "SELECT Name FROM program WHERE Origin != 'Beijing'"
        ]
    },
    "2011": {
        "db_id": "gas_company",
        "question": "Show headquarters with at least two companies in the banking industry.",
        "ground_truth": "SELECT headquarters FROM company WHERE main_industry  =  'Banking' GROUP BY headquarters HAVING count(*)  >=  2",
        "amends": [
            "Do reference table `company` instead of `companies` in the FROM clause. Do use column `main_industry` instead of `industry` in the WHERE filter. Do use literal value `'Banking'` instead of `'banking'` for case-sensitive matching. Do maintain the same GROUP BY clause on `headquarters` and HAVING condition `COUNT(*) >= 2`. The amended query now correctly filters banking companies by their proper industry designation and table reference."
        ],
        "rules": [
            "1) When the question mentions \"companies\": use table \"company\" instead of \"companies\". 2) When the question mentions \"banking industry\": use column \"main_industry\" and literal value \"Banking\" for case-sensitive matching. 3) When counting companies per headquarters: group by \"headquarters\" and count all rows where COUNT(*) >= 2. 4) When producing output: show only the \"headquarters\" column in results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT headquarters FROM companies WHERE industry = 'banking' GROUP BY headquarters HAVING COUNT(*) >= 2",
            "SELECT Headquarters FROM company WHERE Main_Industry = 'Banking' GROUP BY Headquarters HAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT Headquarters FROM company WHERE Main_Industry = 'Banking' GROUP BY Headquarters HAVING COUNT(*) >= 2"
        ]
    },
    "5461": {
        "db_id": "voter_2",
        "question": "Tell me the ages of the oldest and youngest students studying major 600.",
        "ground_truth": "SELECT max(Age) ,  min(Age) FROM STUDENT WHERE Major  =  600",
        "amends": [
            "Do use column name `Age` instead of `age` in both aggregate functions. Do remove the aliases `oldest_age` and `youngest_age` instead of keeping them. Do use table name `STUDENT` instead of `students`. Do maintain the same filter condition `Major = 600` instead of changing it. The amended query now correctly calculates the maximum and minimum age for students with major 600 without unnecessary aliases."
        ],
        "rules": [
            "1) When the question asks for ages of students: use column name \"Age\" exactly as shown in the schema instead of lowercase \"age\". 2) When calculating maximum and minimum values: do not use output column aliases like \"oldest_age\" or \"youngest_age\" if the question doesn't specify them. 3) When referring to the student table: use table name \"STUDENT\" exactly as specified in the amends instead of \"students\". 4) When filtering by major: maintain the exact filter condition \"Major = 600\" as specified in both the question and amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(age) AS oldest_age, MIN(age) AS youngest_age FROM students WHERE major = 600",
            "SELECT MAX(Age), MIN(Age) FROM Student WHERE Major = 600"
        ],
        "rule_sql": [
            "SELECT MAX(Age), MIN(Age) FROM Student WHERE Major = 600;"
        ]
    },
    "1171": {
        "db_id": "body_builder",
        "question": "List the weight of the body builders who have snatch score higher than 140 or have the height greater than 200.",
        "ground_truth": "SELECT T2.weight FROM body_builder AS T1 JOIN people AS T2 ON T1.people_id  =  T2.people_id WHERE T1.snatch  >  140 OR T2.height  >  200;",
        "amends": [
            "Do reference `T2.weight` from the joined `people` table instead of directly selecting `weight` from a single table. Do join `body_builder AS T1` with `people AS T2` on `T1.people_id = T2.people_id` instead of querying only the `body_builders` table. Do use `OR` between the conditions `T1.snatch > 140` and `T2.height > 200` instead of `AND` to broaden the result set. Do filter on `T1.snatch` instead of `snatch_score` and `T2.height` instead of `height` to use the correct column names from their respective tables. The amended query now correctly joins related tables and uses appropriate filtering logic to match the intended behavior."
        ],
        "rules": [
            "1) When answering about body builders' weight: make sure the output order: T2.weight\n2) When the question mentions \"weight\": \"weight\" actually means \"T2.weight\" in schema from the people table\n3) When combining T1 (body_builders) and T2 (people) for shared entities: link rows where T1.people_id = T2.people_id and keep only matching pairs (inner match)\n4) When filtering for snatch score higher than 140: use T1.snatch > 140 instead of snatch_score\n5) When filtering for height greater than 200: use T2.height > 200 instead of height\n6) When the question uses \"or\" between conditions: use OR between T1.snatch > 140 and T2.height > 200 instead of AND to broaden the result set"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT weight FROM body_builders WHERE snatch_score > 140 AND height > 200;",
            "SELECT T2.Weight \nFROM body_builder AS T1 \nJOIN people AS T2 ON T1.People_ID = T2.People_ID \nWHERE T1.Snatch > 140 OR T2.Height > 200"
        ],
        "rule_sql": [
            "SELECT T2.Weight FROM body_builder T1 INNER JOIN people T2 ON T1.People_ID = T2.People_ID WHERE T1.Snatch > 140 OR T2.Height > 200 ORDER BY T2.Weight"
        ]
    },
    "3063": {
        "db_id": "loan_1",
        "question": "What are the names of customers who have taken out more than one loan?",
        "ground_truth": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id GROUP BY T1.cust_name HAVING count(*)  >  1",
        "amends": [
            "Do select `T1.cust_name` instead of `customer_name` and use explicit table aliases. Do join `loan AS T2` instead of omitting the join and add the join condition `ON T1.cust_id = T2.cust_id` instead of missing table relationships. Do add `GROUP BY T1.cust_name` instead of omitting grouping. Do move the count filter to `HAVING count(*) > 1` instead of using `WHERE loan_count > 1` which incorrectly assumes a direct column rather than counting related loan records. The amended query now correctly identifies customers with multiple loans by counting actual loan records instead of relying on a potentially incorrect loan_count column."
        ],
        "rules": [
            "1) When answering about \"names of customers who have taken out more than one loan\": make sure the output order: T1.cust_name. 2) When the question mentions \"customers\": use table \"customers\" as T1 with column \"cust_name\" for customer names. 3) When the question mentions \"loan\": use table \"loan\" as T2 and join with T1 using condition T1.cust_id = T2.cust_id to link customer and loan records. 4) When counting loans per customer: group by T1.cust_name and count using count(*) to determine the number of loans per customer. 5) When filtering for customers with more than one loan: apply the condition count(*) > 1 in the HAVING clause instead of WHERE to filter after aggregation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT customer_name FROM customers WHERE loan_count > 1;",
            "SELECT T1.cust_name\nFROM customer AS T1\nJOIN loan AS T2 ON T1.cust_ID = T2.cust_ID\nGROUP BY T1.cust_name\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T1.cust_name\nFROM customer AS T1\nJOIN loan AS T2 ON T1.cust_ID = T2.cust_ID\nGROUP BY T1.cust_name\nHAVING COUNT(*) > 1\nORDER BY T1.cust_name"
        ]
    },
    "1799": {
        "db_id": "small_bank_1",
        "question": "What is the name corresponding to the accoung with the lowest sum of checking and savings balances?",
        "ground_truth": "SELECT T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid ORDER BY T2.balance + T3.balance LIMIT 1",
        "amends": [
            "Do add explicit table aliases `T1`, `T2`, and `T3` instead of omitting them. Do join `checking AS T2` on `T1.custid = T2.custid` instead of referencing non-existent `checking_balance` column. Do join `savings AS T3` on `T1.custid = T3.custid` instead of referencing non-existent `savings_balance` column. Do reference actual column names `T2.balance` and `T3.balance` in the ORDER BY expression instead of non-existent `checking_balance + savings_balance`. The amended query now correctly joins the necessary tables and references existing columns to match the intended behavior."
        ],
        "rules": [
            "1) When answering about accounts with checking and savings balances: combine tables accounts as T1, checking as T2, and savings as T3 using inner matches where T1.custid = T2.custid and T1.custid = T3.custid. 2) When computing the sum of checking and savings balances: use the expression T2.balance + T3.balance instead of non-existent checking_balance and savings_balance columns. 3) When finding the account with the lowest sum: order by (T2.balance + T3.balance) in ascending direction and keep only the first row. 4) When selecting the output: return the name column from T1 (accounts table)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM accounts ORDER BY (checking_balance + savings_balance) DESC LIMIT 1;",
            "SELECT T1.name\nFROM ACCOUNTS AS T1\nJOIN CHECKING AS T2 ON T1.custid = T2.custid\nJOIN SAVINGS AS T3 ON T1.custid = T3.custid\nORDER BY (T2.balance + T3.balance) ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.name FROM ACCOUNTS AS T1 INNER JOIN CHECKING AS T2 ON T1.custid = T2.custid INNER JOIN SAVINGS AS T3 ON T1.custid = T3.custid ORDER BY (T2.balance + T3.balance) ASC LIMIT 1"
        ]
    },
    "5840": {
        "db_id": "workshop_paper",
        "question": "Show the date and venue of each workshop in ascending alphabetical order of the venue.",
        "ground_truth": "SELECT Date ,  Venue FROM workshop ORDER BY Venue",
        "amends": [
            "Do reference the correct table name `workshop` instead of the incorrect plural `workshops`. Do use proper column names `Date` and `Venue` with correct capitalization instead of lowercase `date` and `venue`. Do remove the unnecessary `DESC` modifier from the `ORDER BY` clause instead of keeping it, as ascending order is the default and intended behavior. The amended query now correctly selects from the workshop table with proper column references and sorting."
        ],
        "rules": [
            "1) When the question asks about workshops: use the exact table name \"workshop\" instead of any pluralized or alternative forms. 2) When selecting date and venue information: use the exact column names \"Date\" and \"Venue\" with proper capitalization as shown in the schema. 3) When ordering venues alphabetically in ascending order: use the default ascending order without any DESC modifier, as ascending is the intended behavior for alphabetical sorting."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT date, venue FROM workshops ORDER BY venue DESC;",
            "SELECT Date, Venue FROM workshop ORDER BY Venue ASC;"
        ],
        "rule_sql": [
            "SELECT Date, Venue FROM workshop ORDER BY Venue ASC;"
        ]
    },
    "4914": {
        "db_id": "store_product",
        "question": "Find all types of store and number of them.",
        "ground_truth": "SELECT TYPE ,  count(*) FROM store GROUP BY TYPE",
        "amends": [
            "Do reference the `TYPE` column instead of `store_type` and use `store` table instead of `stores`. Do group by `TYPE` instead of `store_id` to correctly count records by store type rather than by individual store identifiers. The amended query now properly aggregates store counts by their type classification rather than by unique store IDs, matching the intended behavior of counting how many stores exist for each type category."
        ],
        "rules": [
            "1) When the question asks for \"types of store\": use the exact column token \"TYPE\" from the store table to represent store types. 2) When counting stores by type: group by the \"TYPE\" column and count using the canonical key for stores. 3) When the question asks for \"number of them\" per type: compute the count of stores for each distinct \"TYPE\" value. 4) When producing output: return results in the order of store type followed by count of stores."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT store_type, COUNT(*) FROM stores GROUP BY store_id;",
            "SELECT Type, COUNT(*) AS NumberOfStores FROM store GROUP BY Type;"
        ],
        "rule_sql": [
            "SELECT Type, COUNT(Store_ID) AS NumberOfStores FROM store GROUP BY Type ORDER BY Type, NumberOfStores;"
        ]
    },
    "3721": {
        "db_id": "mountain_photos",
        "question": "How many different kinds of lens brands are there?",
        "ground_truth": "SELECT count(DISTINCT brand) FROM camera_lens",
        "amends": [
            "Do select `count(DISTINCT brand)` instead of `COUNT(*)` to count unique brands rather than all rows. Do reference table `camera_lens` instead of `lens` to use the correct table name. Do remove the `WHERE brand IS NOT NULL` filter instead of keeping it since `count(DISTINCT)` inherently handles null values by excluding them from the distinct count. The amended query now correctly counts distinct brand values from the camera_lens table."
        ],
        "rules": [
            "1) When counting different kinds of lens brands: count distinct values of the \"brand\" column from the \"camera_lens\" table. 2) When the question asks about \"lens brands\": use the exact table name \"camera_lens\" instead of \"lens\". 3) When counting distinct values: do not add explicit null filtering since count(distinct) inherently excludes null values from the distinct count."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM lens WHERE brand IS NOT NULL;",
            "SELECT COUNT(DISTINCT brand) FROM camera_lens"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT brand) FROM camera_lens;"
        ]
    },
    "5974": {
        "db_id": "game_1",
        "question": "What are the different types of video games?",
        "ground_truth": "SELECT DISTINCT gtype FROM Video_games",
        "amends": [
            "Do select only the `gtype` column instead of selecting all columns with `*`. Do add `DISTINCT` to return unique values instead of returning duplicates. Do reference the correct table name `Video_games` with proper capitalization instead of `video_games`. Do remove the incorrect `WHERE type = 'different'` filter instead of keeping it, as the right query aims to retrieve all distinct game types without filtering. The amended query now correctly returns all unique game types from the Video_games table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"different types of video games\": make sure the output order: \"gtype\" 2) When the question asks for \"different types\": use DISTINCT to return unique values of \"gtype\" instead of returning duplicates 3) When referencing the table: use exact table name \"Video_games\" with proper capitalization instead of \"video_games\" 4) When the question asks for types without specific filtering: do not apply any WHERE clause filter, especially not WHERE type = 'different'"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM video_games WHERE type = 'different';",
            "SELECT DISTINCT GType FROM Video_Games;"
        ],
        "rule_sql": [
            "SELECT DISTINCT GType FROM Video_Games ORDER BY GType;"
        ]
    },
    "6258": {
        "db_id": "ship_1",
        "question": "Find the name of the ships that have more than one captain.",
        "ground_truth": "SELECT t1.name FROM ship AS t1 JOIN captain AS t2 ON t1.ship_id  =  t2.ship_id GROUP BY t2.ship_id HAVING count(*)  >  1",
        "amends": [
            "Do select `t1.name` with table alias instead of just `name` without qualification. Do use `FROM ship AS t1 JOIN captain AS t2` with explicit table aliases and a JOIN instead of `FROM ships` alone. Do add the join condition `ON t1.ship_id = t2.ship_id` instead of omitting any join. Do add `GROUP BY t2.ship_id` to group by the ship identifier instead of no grouping. Do move the count filter to `HAVING count(*) > 1` instead of using `WHERE captain_count > 1` with a non-existent column. The amended query now correctly counts captains per ship and filters for ships with multiple captains, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"ships that have more than one captain\": make sure the output order: t1.name. 2) When combining ship and captain tables for shared entities: link rows where t1.ship_id = t2.ship_id; keep only matching pairs (inner match). 3) When the question asks for \"count of captains per ship\": compute the number of rows using the grouping by t2.ship_id and count all matching rows. 4) When filtering for ships with more than one captain: apply the condition count(*) > 1 after grouping instead of before grouping."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM ships WHERE captain_count > 1;",
            "SELECT t1.Name \nFROM Ship AS t1 \nJOIN captain AS t2 ON t1.Ship_ID = t2.Ship_ID \nGROUP BY t2.Ship_ID \nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT t1.Name \nFROM Ship t1 \nINNER JOIN captain t2 ON t1.Ship_ID = t2.Ship_ID \nGROUP BY t1.Ship_ID, t1.Name \nHAVING COUNT(*) > 1 \nORDER BY t1.Name"
        ]
    },
    "3722": {
        "db_id": "mountain_photos",
        "question": "How many camera lenses are not used in taking any photos?",
        "ground_truth": "SELECT count(*) FROM camera_lens WHERE id NOT IN ( SELECT camera_lens_id FROM photos )",
        "amends": [
            "Do reference table `camera_lens` instead of `camera_lenses` and use column `id` instead of `lens_id` in the main query. Do use subquery column `camera_lens_id` instead of `lens_id` in the NOT IN clause instead of the incorrect column reference. The amended query now correctly checks for camera lens IDs that don't exist in the photos table by using the proper table name and column references, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"camera lenses not used in any photos\": use table \"camera_lens\" instead of \"camera_lenses\" and column \"id\" as the counting key. 2) When checking for lenses not used in photos: use column \"camera_lens_id\" from the photos table in the NOT IN subquery instead of \"lens_id\". 3) When counting unused camera lenses: count the number of rows in \"camera_lens\" where \"id\" values are not present in the \"camera_lens_id\" column of the \"photos\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM camera_lenses WHERE lens_id NOT IN (SELECT lens_id FROM photos);",
            "SELECT COUNT(*) \nFROM camera_lens \nWHERE id NOT IN (SELECT camera_lens_id FROM photos)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM camera_lens WHERE id NOT IN (SELECT camera_lens_id FROM photos)"
        ]
    },
    "6263": {
        "db_id": "ship_1",
        "question": "What is the name of the ship that is commanded by the youngest captain?",
        "ground_truth": "SELECT t1.name FROM ship AS t1 JOIN captain AS t2 ON t1.ship_id  =  t2.ship_id ORDER BY t2.age LIMIT 1",
        "amends": [
            "Do add `t1.` prefix to `name` instead of using unqualified `name`. Do change `FROM ships` to `FROM ship AS t1 JOIN captain AS t2` instead of just `FROM ships`. Do add `ON t1.ship_id = t2.ship_id` join condition instead of omitting the join entirely. Do change `ORDER BY captain_age ASC` to `ORDER BY t2.age` instead of using non-existent `captain_age` column. Do remove `ASC` keyword as it's the default ordering instead of keeping explicit specification. The amended query now correctly joins ship and captain tables to access captain's age for ordering and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"name of the ship\": make sure the output column is \"t1.name\" instead of unqualified \"name\". 2) When the question involves both ships and captains: combine tables using \"FROM ship AS t1 JOIN captain AS t2\" with join condition \"t1.ship_id = t2.ship_id\" to link ships to their captains. 3) When ordering by captain's age: use \"t2.age\" instead of non-existent \"captain_age\" column. 4) When finding the youngest captain: order by \"t2.age\" in ascending order (default ordering) and take the first row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM ships ORDER BY captain_age ASC LIMIT 1;",
            "SELECT t1.Name FROM ship AS t1 JOIN captain AS t2 ON t1.Ship_ID = t2.Ship_ID ORDER BY t2.age LIMIT 1"
        ],
        "rule_sql": [
            "SELECT t1.Name FROM ship AS t1 JOIN captain AS t2 ON t1.Ship_ID = t2.Ship_ID ORDER BY t2.age ASC LIMIT 1"
        ]
    },
    "844": {
        "db_id": "chinook_1",
        "question": "Find the average unit price of jazz tracks.",
        "ground_truth": "SELECT AVG(UnitPrice) FROM GENRE AS T1 JOIN TRACK AS T2 ON T1.GenreId  =  T2.GenreId WHERE T1.Name  =  \"Jazz\"",
        "amends": [
            "Do reference `UnitPrice` instead of `price` in the SELECT list. Do join `GENRE` and `TRACK` tables with `T1.GenreId = T2.GenreId` instead of querying only the tracks table. Do filter on `T1.Name = \"Jazz\"` instead of `genre = 'Jazz'` to properly utilize the genre table relationship. The amended query now correctly calculates the average unit price for Jazz tracks by joining the appropriate tables and filtering through the genre name."
        ],
        "rules": [
            "1) When answering about \"average unit price of jazz tracks\": make sure the output order: average of UnitPrice. 2) When the question mentions \"jazz tracks\": \"jazz\" actually means \"Name = 'Jazz' in the GENRE table\". 3) When combining TRACK and GENRE tables: link rows where T1.GenreId = T2.GenreId and keep only matching pairs (inner match). 4) When computing average unit price: use the exact column token \"UnitPrice\" from the TRACK table, not \"price\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(price) FROM tracks WHERE genre = 'Jazz';",
            "SELECT AVG(t.UnitPrice) AS AverageUnitPrice\nFROM Track t\nJOIN Genre g ON t.GenreId = g.GenreId\nWHERE g.Name = 'Jazz';"
        ],
        "rule_sql": [
            "SELECT AVG(t.UnitPrice) AS \"average of UnitPrice\" FROM Track t INNER JOIN Genre g ON t.GenreId = g.GenreId WHERE g.Name = 'Jazz'"
        ]
    },
    "4488": {
        "db_id": "decoration_competition",
        "question": "Show the different countries and the number of members from each.",
        "ground_truth": "SELECT Country ,  COUNT(*) FROM member GROUP BY Country",
        "amends": [
            "Do use table name `member` instead of `members` and column name `Country` instead of `country` to match the correct schema. Do maintain the same aggregate function `COUNT(*)` and `GROUP BY Country` structure instead of changing the grouping logic. The amended query now correctly references the intended table and column names while preserving the counting functionality."
        ],
        "rules": [
            "1) When the question asks about \"countries\" and \"number of members\": use table \"member\" and column \"Country\" with exact case and spelling. 2) When counting members per country: use COUNT(*) to count all rows in each group. 3) When grouping by country: organize results using GROUP BY \"Country\" to get counts for each distinct country value. 4) When producing output: maintain the column order of country name followed by count of members."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country, COUNT(*) FROM members GROUP BY country;",
            "SELECT Country, COUNT(*) AS Number_of_Members FROM member GROUP BY Country;"
        ],
        "rule_sql": [
            "SELECT Country, COUNT(*) AS Number_of_Members FROM member GROUP BY Country;"
        ]
    },
    "3011": {
        "db_id": "loan_1",
        "question": "What is the total number of customers who use banks in New York City?",
        "ground_truth": "SELECT sum(no_of_customers) FROM bank WHERE city  =  'New York City'",
        "amends": [
            "Do select `sum(no_of_customers)` instead of `COUNT(*)`. Do query from `bank` table instead of `customers` table. Do remove the `bank IS NOT NULL` filter instead of keeping it, as the aggregation now operates on the bank table directly. The amended query now correctly aggregates customer counts from the bank table for New York City instead of counting individual customer records with bank information."
        ],
        "rules": [
            "1) When answering about \"total number of customers who use banks in New York City\": make sure the output order: sum(no_of_customers). 2) When the question mentions \"customers who use banks\": \"customers\" actually means \"no_of_customers in schema\". 3) When the question mentions \"New York City\": use the exact literal 'New York City' for filtering. 4) When querying from the bank table: use the bank table as T1 instead of the customers table. 5) When aggregating customer counts: use sum(no_of_customers) instead of COUNT(*). 6) When filtering for location: apply city = 'New York City' condition to the bank table. 7) When handling bank information: do not include bank IS NOT NULL filter as the aggregation operates directly on the bank table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE city = 'New York City' AND bank IS NOT NULL;",
            "SELECT SUM(no_of_customers) FROM bank WHERE city = 'New York City';"
        ],
        "rule_sql": [
            "SELECT SUM(no_of_customers) FROM bank AS T1 WHERE city = 'New York City'"
        ]
    },
    "1157": {
        "db_id": "body_builder",
        "question": "What are the names of body builders whose total score is higher than 300?",
        "ground_truth": "SELECT T2.Name FROM body_builder AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Total  >  300",
        "amends": [
            "Do select `T2.Name` from the `people` table instead of `name` from the `body_builders` table. Do join `people AS T2` on `T1.People_ID = T2.People_ID` instead of querying a single table. Do use the table alias `T1` for `body_builder` instead of the full table name `body_builders`. Do filter on `T1.Total > 300` instead of `total_score > 300`. The amended query now correctly retrieves body builder names from the related people table while filtering on the total score from the body_builder table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"names of body builders\": make sure to select \"T2.Name\" from the \"people\" table instead of \"name\" from the \"body_builders\" table. 2) When combining \"body_builder\" as T1 and \"people\" as T2: link rows where \"T1.People_ID = T2.People_ID\" and keep only matching pairs (inner match). 3) When filtering for body builders with total score higher than 300: use the condition \"T1.Total > 300\" instead of \"total_score > 300\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM body_builders WHERE total_score > 300;",
            "SELECT T2.Name \nFROM body_builder AS T1 \nJOIN people AS T2 ON T1.People_ID = T2.People_ID \nWHERE T1.Total > 300"
        ],
        "rule_sql": [
            "SELECT T2.Name FROM body_builder AS T1 INNER JOIN people AS T2 ON T1.People_ID = T2.People_ID WHERE T1.Total > 300"
        ]
    },
    "6899": {
        "db_id": "tracking_orders",
        "question": "What is the customer id of the customer who has the most orders?",
        "ground_truth": "SELECT T1.customer_id FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT customer_id FROM orders GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT customer_id\nFROM Orders\nGROUP BY customer_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "4357": {
        "db_id": "tracking_grants_for_research",
        "question": "What are the details and id of the project with the most outcomes?",
        "ground_truth": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select specific columns `T1.project_details` and `T1.project_id` instead of using `*` to select all columns. Do add a `JOIN` with `Project_outcomes AS T2` on `T1.project_id = T2.project_id` instead of querying only the `projects` table. Do add `GROUP BY T1.project_id` and order by `count(*) DESC` instead of ordering by `id DESC` without aggregation. Do maintain the `LIMIT 1` clause but now it returns the project with the most outcomes instead of the most recent project by ID. The amended query now correctly identifies the project with the highest number of outcomes rather than simply the most recently created project."
        ],
        "rules": [
            "1) When answering about \"project with the most outcomes\": make sure the output order: T1.project_details, T1.project_id 2) When combining projects (T1) and Project_outcomes (T2) for shared entities: link rows where T1.project_id = T2.project_id exactly as shown; keep only matching pairs (inner match). 3) When the question asks for \"most outcomes\": organize results by T1.project_id and count the number of outcomes per project using the canonical key T1.project_id. 4) When the question asks for \"most outcomes\": rank rows by count of outcomes in descending order and keep the first 1 row. 5) When producing output: do not reorder columns beyond T1.project_details followed by T1.project_id as specified in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM projects ORDER BY id DESC LIMIT 1;",
            "SELECT T1.project_details, T1.project_id\nFROM Projects AS T1\nJOIN Project_Outcomes AS T2 ON T1.project_id = T2.project_id\nGROUP BY T1.project_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.project_details, T1.project_id\nFROM Projects T1\nINNER JOIN Project_Outcomes T2 ON T1.project_id = T2.project_id\nGROUP BY T1.project_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "6168": {
        "db_id": "music_4",
        "question": "What are the songs in volumes that have resulted in a nomination at music festivals?",
        "ground_truth": "SELECT T2.Song FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T1.Result  =  \"Nominated\"",
        "amends": [
            "Do select `T2.Song` instead of `s.title`. Do use `music_festival AS T1` and `volume AS T2` as table sources instead of `songs s`, `volumes v`, and `nominations n`. Do perform an `INNER JOIN` between `T1` and `T2` on `T1.Volume = T2.Volume_ID` instead of joining `songs` with `volumes` on `s.volume_id = v.id` and then with `nominations` on `s.id = n.song_id`. Do filter with `T1.Result = \"Nominated\"` instead of `n.festival_id IS NOT NULL`. The amended query now correctly retrieves nominated songs from the appropriate festival and volume tables, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about songs in volumes with festival nominations: select T2.Song as the output column. 2) When combining music_festival (T1) and volume (T2) tables: link rows where T1.Volume = T2.Volume_ID using an inner match. 3) When filtering for nominated results: include only rows where T1.Result exactly equals \"Nominated\" (case-sensitive)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.title \nFROM songs s \nJOIN volumes v ON s.volume_id = v.id \nJOIN nominations n ON s.id = n.song_id \nWHERE n.festival_id IS NOT NULL;",
            "SELECT T2.Song\nFROM music_festival AS T1\nINNER JOIN volume AS T2 ON T1.Volume = T2.Volume_ID\nWHERE T1.Result = 'Nominated'"
        ],
        "rule_sql": [
            "SELECT T2.Song\nFROM music_festival T1\nINNER JOIN volume T2 ON T1.Volume = T2.Volume_ID\nWHERE T1.Result = 'Nominated'"
        ]
    },
    "1354": {
        "db_id": "college_2",
        "question": "Find the department name of the instructor whose name contains 'Soisalon'.",
        "ground_truth": "SELECT dept_name FROM instructor WHERE name LIKE '%Soisalon%'",
        "amends": [
            "Do reference the `dept_name` column instead of `department_name` and use the `instructor` table instead of `instructors` while preserving the `LIKE '%Soisalon%'` filter condition, maintaining the same logical behavior for searching instructor names while correcting the table and column references to match the actual schema."
        ],
        "rules": [
            "1) When the question asks for \"department name\": use the exact column token \"dept_name\" instead of \"department_name\". 2) When referencing the instructor table: use the exact table name \"instructor\" instead of \"instructors\". 3) When searching for instructor names containing 'Soisalon': apply the exact literal pattern '%Soisalon%' with case and spacing preserved."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department_name FROM instructors WHERE name LIKE '%Soisalon%'",
            "SELECT dept_name FROM instructor WHERE name LIKE '%Soisalon%'"
        ],
        "rule_sql": [
            "SELECT dept_name FROM instructor WHERE name LIKE '%Soisalon%'"
        ]
    },
    "302": {
        "db_id": "product_catalog",
        "question": "What are all the catalog entry names?",
        "ground_truth": "SELECT distinct(catalog_entry_name) FROM catalog_contents",
        "amends": [
            "Do select `distinct(catalog_entry_name)` instead of `*` to return only unique catalog entry names rather than all columns. Do query from `catalog_contents` instead of `catalog_entries` to access the correct table containing the catalog entry data. The amended query now matches the intended behavior of returning distinct catalog entry names from the appropriate table."
        ],
        "rules": [
            "1) When the question asks for \"catalog entry names\": use the exact column token \"catalog_entry_name\" from the schema. 2) When the question asks for \"all\" catalog entry names: return only distinct values to avoid duplicates. 3) When accessing catalog entry data: use the table \"catalog_contents\" instead of \"catalog_entries\" as it contains the correct catalog entry information."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM catalog_entries;",
            "SELECT DISTINCT catalog_entry_name FROM Catalog_Contents"
        ],
        "rule_sql": [
            "SELECT DISTINCT catalog_entry_name FROM Catalog_Contents;"
        ]
    },
    "1827": {
        "db_id": "browser_web",
        "question": "List the name of browsers in descending order by market share.",
        "ground_truth": "SELECT name FROM browser ORDER BY market_share DESC",
        "amends": [
            "Do reference table `browser` instead of `browsers` to use the correct table name. Do sort by `market_share DESC` instead of `ASC` to order results in descending rather than ascending order. The amended query now correctly retrieves browser names from the proper table and sorts them by market share from highest to lowest, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for browser names: use the \"name\" column from the \"browser\" table. 2) When ordering by market share in descending order: sort by the \"market_share\" column in descending direction. 3) When referencing the browser table: use the exact table name \"browser\" (not \"browsers\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM browsers ORDER BY market_share ASC;",
            "SELECT name FROM browser ORDER BY market_share DESC;"
        ],
        "rule_sql": [
            "SELECT name FROM browser ORDER BY market_share DESC;"
        ]
    },
    "5666": {
        "db_id": "customers_and_products_contacts",
        "question": "What are the name and phone of the customer with the most ordered product quantity?",
        "ground_truth": "SELECT  T1.customer_name ,  T1.customer_phone FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id JOIN order_items AS T3 ON T3.order_id  =  T2.order_id GROUP BY T1.customer_id ORDER BY sum(T3.order_quantity) DESC LIMIT 1",
        "amends": [
            "Do use `T1.customer_name` and `T1.customer_phone` instead of `c.name` and `c.phone`. Do add `customer_orders AS T2` and `order_items AS T3` instead of omitting them. Do use `JOIN customer_orders AS T2 ON T1.customer_id = T2.customer_id` and `JOIN order_items AS T3 ON T3.order_id = T2.order_id` instead of only joining `orders o`. Do use `sum(T3.order_quantity)` instead of `COUNT(o.order_id)` for ordering. The amended query now correctly calculates total order quantity rather than order count and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting customer information: use T1.customer_name and T1.customer_phone as output columns. 2) When combining customer data with order information: join T1 (customers) with T2 (customer_orders) where T1.customer_id = T2.customer_id, and join T2 with T3 (order_items) where T3.order_id = T2.order_id. 3) When calculating total ordered product quantity: use sum(T3.order_quantity) instead of counting orders. 4) When finding the customer with the most ordered product quantity: order results by sum(T3.order_quantity) in descending direction and keep only the top row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name, c.phone \nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nGROUP BY c.customer_id\nORDER BY COUNT(o.order_id) DESC\nLIMIT 1;",
            "SELECT T1.customer_name, T1.customer_phone\nFROM Customers AS T1\nJOIN Customer_Orders AS T2 ON T1.customer_id = T2.customer_id\nJOIN Order_Items AS T3 ON T3.order_id = T2.order_id\nGROUP BY T1.customer_id\nORDER BY SUM(CAST(T3.order_quantity AS INTEGER)) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.customer_name, T1.customer_phone\nFROM Customers T1\nJOIN Customer_Orders T2 ON T1.customer_id = T2.customer_id\nJOIN Order_Items T3 ON T3.order_id = T2.order_id\nGROUP BY T1.customer_id, T1.customer_name, T1.customer_phone\nORDER BY SUM(CAST(T3.order_quantity AS REAL)) DESC\nLIMIT 1;"
        ]
    },
    "559": {
        "db_id": "store_1",
        "question": "List total amount of  invoice from Chicago, IL.",
        "ground_truth": "SELECT sum(total) FROM invoices WHERE billing_city  =  \"Chicago\" AND billing_state  =  \"IL\";",
        "amends": [
            "Do reference `total` instead of `amount` in the aggregate function. Do use `billing_city` instead of `city` and `billing_state` instead of `state` in the WHERE clause filters. Do use double quotes instead of single quotes for string literals. The amended query now correctly references the appropriate billing address columns and matches the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"total amount of invoice\": use the column \"total\" from table invoices for aggregation instead of \"amount\". 2) When filtering for location \"Chicago, IL\": use \"billing_city\" and \"billing_state\" columns from table invoices instead of \"city\" and \"state\" from customers table. 3) When using string literals for location values: use double quotes exactly as \"Chicago\" and \"IL\" with proper case and spacing."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(amount) FROM invoices WHERE city = 'Chicago' AND state = 'IL';",
            "SELECT SUM(total) FROM invoices WHERE billing_city = \"Chicago\" AND billing_state = \"IL\";"
        ],
        "rule_sql": [
            "SELECT SUM(total) AS total_amount FROM invoices WHERE billing_city = \"Chicago\" AND billing_state = \"IL\";"
        ]
    },
    "1128": {
        "db_id": "climbing",
        "question": "Show names of climbers and the names of mountains they climb.",
        "ground_truth": "SELECT T1.Name ,  T2.Name FROM climber AS T1 JOIN mountain AS T2 ON T1.Mountain_ID  =  T2.Mountain_ID",
        "amends": [
            "Do reference tables as `climber AS T1` and `mountain AS T2` instead of `climbers` and `mountains`. Do use join condition `T1.Mountain_ID = T2.Mountain_ID` instead of `climbers.climber_id = mountains.mountain_id`. Do select columns `T1.Name` and `T2.Name` instead of `climber_name` and `mountain_name`. The amended query now correctly joins climbers to mountains using the proper foreign key relationship and selects the appropriate name columns from each table."
        ],
        "rules": [
            "1) When answering about \"names of climbers and the names of mountains they climb\": make sure the output order: T1.Name, T2.Name\n2) When combining climber (T1) and mountain (T2) tables: link rows where T1.Mountain_ID = T2.Mountain_ID exactly as shown; keep only matching pairs (inner match)\n3) When the question mentions \"climbers\": \"climbers\" actually means \"T1.Name in schema\"\n4) When the question mentions \"mountains\": \"mountains\" actually means \"T2.Name in schema\"\n5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT climber_name, mountain_name FROM climbers JOIN mountains ON climbers.climber_id = mountains.mountain_id;",
            "SELECT T1.Name, T2.Name FROM climber AS T1 JOIN mountain AS T2 ON T1.Mountain_ID = T2.Mountain_ID"
        ],
        "rule_sql": [
            "SELECT T1.\"Name\", T2.\"Name\" FROM \"climber\" T1 INNER JOIN \"mountain\" T2 ON T1.\"Mountain_ID\" = T2.\"Mountain_ID\""
        ]
    },
    "5793": {
        "db_id": "customer_complaints",
        "question": "Return the average price of products that have each category code.",
        "ground_truth": "SELECT avg(product_price) ,  product_category_code FROM products GROUP BY product_category_code",
        "amends": [
            "Do select `avg(product_price)` and `product_category_code` instead of `AVG(price)` and `category_code`. Do remove the `HAVING COUNT(*) > 1` clause instead of keeping it. The amended query now correctly references the actual column names and removes the unnecessary filtering condition, matching the intended behavior.",
            "Do place `product_category_code` after the aggregate function instead of before it in the SELECT list. Do maintain the same `AVG(product_price)` aggregate calculation and `GROUP BY product_category_code` clause without changes. The amended query now correctly positions the non-aggregated column after the aggregate function while preserving the same logical behavior and output as the RIGHT_SQL."
        ],
        "rules": [
            "1) When answering about \"average price of products that have each category code\": make sure the output order: product_category_code, then average price. 2) When the question mentions \"category code\": \"category code\" actually means \"product_category_code in schema\". 3) When the question mentions \"price\": \"price\" actually means \"product_price in schema\". 4) When computing average price per category: organize results by product_category_code and compute the average of product_price per group. 5) When the amends specify to remove filtering: do not include any having clause that filters groups by count.",
            "1) When answering about \"average price of products that have each category code\": make sure the output order: AVG(product_price) first, then product_category_code. 2) When the question mentions \"each category code\": \"category code\" actually means \"product_category_code in schema\". 3) When the question asks for \"average price\": compute the average of product_price values. 4) When the question says \"per category code\"/\"by category code\": organize results by product_category_code and compute the average price per group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category_code, AVG(price) FROM products GROUP BY category_code HAVING COUNT(*) > 1",
            "SELECT product_category_code, AVG(product_price) FROM Products GROUP BY product_category_code",
            "SELECT AVG(product_price), product_category_code FROM Products GROUP BY product_category_code"
        ],
        "rule_sql": [
            "SELECT product_category_code, AVG(product_price) AS average_price FROM Products GROUP BY product_category_code ORDER BY product_category_code, average_price;"
        ]
    },
    "580": {
        "db_id": "store_1",
        "question": "How many customers are from California?",
        "ground_truth": "SELECT count(*) FROM customers WHERE state = \"CA\";",
        "amends": [
            "Do use the state abbreviation `\"CA\"` instead of the full state name `'California'` in the WHERE filter. The amended query now matches RIGHT_SQL's behavior by correctly filtering for California using the standard state abbreviation format."
        ],
        "rules": [
            "1) When the question mentions \"California\": use the state abbreviation \"CA\" instead of the full state name 'California' in the filter condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE state = 'California';",
            "SELECT COUNT(*) FROM customers WHERE state = 'CA';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM customers WHERE state = 'CA';"
        ]
    },
    "2809": {
        "db_id": "news_report",
        "question": "Show the most common nationality for journalists.",
        "ground_truth": "SELECT Nationality FROM journalist GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do reference the table as `journalist` instead of `journalists` and use column name `Nationality` instead of `nationality` to match the correct schema. Do order by `COUNT(*) DESC` instead of `count ASC` to find the most common nationality rather than the least common. Do select only `Nationality` instead of both `nationality` and `count` to return just the nationality value. Do remove the alias `count` from the SELECT clause since it's not needed when only selecting the grouped column. The amended query now correctly identifies the most frequent nationality among journalists."
        ],
        "rules": [
            "1) When the question asks about \"journalists\": use the exact table name \"journalist\" instead of \"journalists\". 2) When the question mentions \"nationality\": use the exact column name \"Nationality\" with proper case. 3) When the question asks for the \"most common nationality\": order by the count of journalists in descending order. 4) When selecting output for \"most common nationality\": return only the \"Nationality\" column value, not the count. 5) When counting journalists per nationality: use COUNT(*) to count all rows in each group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT nationality, COUNT(*) as count FROM journalists GROUP BY nationality ORDER BY count ASC LIMIT 1;",
            "SELECT Nationality FROM journalist GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Nationality FROM journalist GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "111": {
        "db_id": "bike_1",
        "question": "What are the names of stations that have latitude lower than 37.5?",
        "ground_truth": "SELECT name FROM station WHERE lat  <  37.5",
        "amends": [
            "Do reference table `station` instead of `stations` in the FROM clause. Do use column `lat` instead of `latitude` in the WHERE filter. Do apply less than comparison `< 37.5` instead of greater than `> 37.5` in the WHERE condition. The amended query now correctly filters for stations with latitude values below 37.5 degrees."
        ],
        "rules": [
            "1) When the question asks about stations: use table \"station\" instead of \"stations\". 2) When the question mentions latitude: use column \"lat\" instead of \"latitude\". 3) When filtering for latitude lower than 37.5: apply less than comparison (< 37.5) instead of greater than (> 37.5)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM stations WHERE latitude > 37.5;",
            "SELECT name FROM station WHERE lat < 37.5"
        ],
        "rule_sql": [
            "SELECT name FROM station WHERE lat < 37.5"
        ]
    },
    "936": {
        "db_id": "medicine_enzyme_interaction",
        "question": "What are the names of enzymes in descending order?",
        "ground_truth": "SELECT name FROM enzyme ORDER BY name DESC",
        "amends": [
            "Do reference table `enzyme` instead of `enzymes` in the FROM clause. Do use `DESC` ordering instead of `ASC` in the ORDER BY clause. The amended query now correctly selects from the enzyme table with descending name order."
        ],
        "rules": [
            "1) When the question asks about enzymes: use the exact table name \"enzyme\" instead of \"enzymes\". 2) When ordering enzyme names in descending order: sort the \"name\" column in descending direction (DESC) instead of ascending (ASC)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM enzymes ORDER BY name ASC;",
            "SELECT name FROM enzyme ORDER BY name DESC;"
        ],
        "rule_sql": [
            "SELECT name FROM enzyme ORDER BY name DESC;"
        ]
    },
    "493": {
        "db_id": "allergy_1",
        "question": "Show all ages and corresponding number of students.",
        "ground_truth": "SELECT age ,  count(*) FROM Student GROUP BY age",
        "amends": [
            "Do reference the table as `Student` instead of `students` to match the correct schema. Do maintain the same `SELECT` list with `age` and `count(*)` without changes. Do preserve the `GROUP BY age` clause without modification. Do remove the `ORDER BY age` clause instead of keeping it since the right query does not include ordering. The amended query now matches RIGHT_SQL's behavior by using the correct table name and removing the unnecessary ordering."
        ],
        "rules": [
            "1) When referencing the student data table: use the exact table name \"Student\" instead of \"students\". 2) When counting students by age: group results by the \"age\" column and count all rows in each group. 3) When the question does not specify ordering: do not include any ORDER BY clause in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT age, COUNT(*) FROM students GROUP BY age ORDER BY age;",
            "SELECT age, COUNT(*) FROM Student GROUP BY age;"
        ],
        "rule_sql": [
            "SELECT Age, COUNT(*) AS NumberOfStudents FROM Student GROUP BY Age"
        ]
    },
    "3564": {
        "db_id": "music_1",
        "question": "What is the average song rating for each language?",
        "ground_truth": "SELECT avg(rating) ,  languages FROM song GROUP BY languages",
        "amends": [
            "Do use `avg(rating)` without an alias instead of `AVG(rating) as average_rating`. Do reference the `languages` column instead of `language`. Do query from the `song` table instead of `songs`. Do group by `languages` instead of `language`. The amended query now correctly calculates average ratings grouped by language from the appropriate table structure.",
            "Do place the `languages` column after the aggregate function `avg(rating)` in the SELECT list instead of listing it first. Do maintain the same GROUP BY clause with `languages` to ensure proper aggregation by language groups. The amended query now correctly returns the average rating for each language while maintaining the same logical behavior as the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for average song rating by language: use the exact column name \"languages\" from the song table instead of \"language\". 2) When calculating average rating: use avg(rating) without an alias instead of AVG(rating) as average_rating. 3) When querying song data: use the table name \"song\" instead of \"songs\". 4) When grouping by language: group by the exact column \"languages\" instead of \"language\".",
            "1) When answering about \"average song rating for each language\": make sure the output order: average rating first, then language. 2) When the question asks for \"average song rating\": compute the average of the exact column \"rating\" from table song. 3) When the question says \"for each language\": organize results by the exact column \"languages\" from table song and compute the average rating per language group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT language, AVG(rating) as average_rating FROM songs GROUP BY language;",
            "SELECT languages, avg(rating) FROM song GROUP BY languages;",
            "SELECT avg(rating), languages FROM song GROUP BY languages;"
        ],
        "rule_sql": [
            "SELECT avg(rating), languages FROM song GROUP BY languages;"
        ]
    },
    "2612": {
        "db_id": "inn_1",
        "question": "Find the name of the room with the maximum occupancy.",
        "ground_truth": "SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT 1;",
        "amends": [
            "Do select `roomName` instead of `name` to use the correct column name from the schema. Do order by `maxOccupancy` instead of `occupancy` to use the proper column that represents maximum occupancy capacity. The amended query now correctly identifies the room with the highest maximum occupancy by using the appropriate column names from the Rooms table."
        ],
        "rules": [
            "1) When the question asks for the \"name of the room\": use the exact column token \"roomName\" from the Rooms table (T1). 2) When the question asks about \"maximum occupancy\": use the exact column token \"maxOccupancy\" from the Rooms table (T1) to represent occupancy capacity. 3) When finding the room with the maximum occupancy: rank rows by \"maxOccupancy\" in descending order and keep the first row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM rooms ORDER BY occupancy DESC LIMIT 1;",
            "SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT 1;"
        ]
    },
    "1573": {
        "db_id": "customers_and_invoices",
        "question": "Show the number of customers.",
        "ground_truth": "SELECT count(*) FROM Customers",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS number_of_customers FROM Customers;"
        ]
    },
    "5386": {
        "db_id": "tracking_software_problems",
        "question": "What are the product ids for the problems reported by Christop Berge with closure authorised by Ashley Medhurst?",
        "ground_truth": "SELECT product_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE T2.staff_first_name = \"Christop\" AND T2.staff_last_name = \"Berge\" INTERSECT SELECT product_id FROM problems AS T1 JOIN staff AS T2 ON T1.closure_authorised_by_staff_id = T2.staff_id WHERE T2.staff_first_name = \"Ashley\" AND T2.staff_last_name = \"Medhurst\"",
        "amends": [
            "Do join `problems` with `staff` on `reported_by_staff_id` instead of directly filtering by name string, and do join again with `staff` on `closure_authorised_by_staff_id` instead of directly filtering by name string. Do filter by `staff_first_name` and `staff_last_name` separately instead of using a concatenated full name. Do use `INTERSECT` to find product IDs that match both conditions instead of using `AND` in a single WHERE clause. Do reference staff through proper foreign key relationships instead of relying on name matching in a single table."
        ],
        "rules": [
            "1) When the question mentions \"Christop Berge\": this refers to matching both \"staff_first_name\" = 'Christop' and \"staff_last_name\" = 'Berge' in the Staff table. 2) When the question mentions \"Ashley Medhurst\": this refers to matching both \"staff_first_name\" = 'Ashley' and \"staff_last_name\" = 'Medhurst' in the Staff table. 3) When combining Problems table (T1) with Staff table for reported by: link rows where T1.\"reported_by_staff_id\" = T2.\"staff_id\" and keep only matching pairs (inner match). 4) When combining Problems table (T1) with Staff table for closure authorised by: link rows where T1.\"closure_authorised_by_staff_id\" = T3.\"staff_id\" and keep only matching pairs (inner match). 5) When finding product IDs that satisfy both staff conditions: use INTERSECT to combine results from the two separate staff matches instead of using AND in a single WHERE clause. 6) When answering about product ids for problems: make sure the output order: \"product_id\" from Problems table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT product_id FROM problems WHERE reported_by = 'Christop Berge' AND closure_authorised_by = 'Ashley Medhurst';",
            "SELECT p.product_id\nFROM Problems p\nJOIN Staff s1 ON p.reported_by_staff_id = s1.staff_id\nJOIN Staff s2 ON p.closure_authorised_by_staff_id = s2.staff_id\nWHERE s1.staff_first_name = 'Christop' AND s1.staff_last_name = 'Berge'\nINTERSECT\nSELECT p.product_id\nFROM Problems p\nJOIN Staff s1 ON p.reported_by_staff_id = s1.staff_id\nJOIN Staff s2 ON p.closure_authorised_by_staff_id = s2.staff_id\nWHERE s2.staff_first_name = 'Ashley' AND s2.staff_last_name = 'Medhurst';"
        ],
        "rule_sql": [
            "SELECT product_id FROM Problems WHERE reported_by_staff_id IN (\n    SELECT staff_id FROM Staff WHERE staff_first_name = 'Christop' AND staff_last_name = 'Berge'\n)\nINTERSECT\nSELECT product_id FROM Problems WHERE closure_authorised_by_staff_id IN (\n    SELECT staff_id FROM Staff WHERE staff_first_name = 'Ashley' AND staff_last_name = 'Medhurst'\n)"
        ]
    },
    "2060": {
        "db_id": "party_people",
        "question": "Return the name of the party with the most members.",
        "ground_truth": "SELECT T2.party_name FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `Member AS T1` with `party AS T2` on `T1.party_id = T2.party_id` instead of querying `parties` directly without any join. Do aggregate with `GROUP BY T1.party_id` and count members with `count(*)` instead of ordering by a direct `member_count` column. Do select `T2.party_name` from the joined table instead of `party_name` from a single table. Do order by the aggregate `count(*) DESC` instead of the raw `member_count DESC`. The amended query now correctly identifies the party with the most members by counting actual member records rather than relying on a potentially incorrect or missing member_count column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"party with the most members\": join Member as T1 with party as T2 on T1.party_id = T2.party_id using exact key equality. 2) When counting members per party: group by T1.party_id and count using count(*) to get the actual number of member records. 3) When selecting the party name: use T2.party_name from the joined party table instead of a direct column. 4) When ordering to find the party with most members: order by the aggregate count(*) in descending direction and keep only the top result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT party_name FROM parties ORDER BY member_count DESC LIMIT 1;",
            "SELECT T2.Party_name\nFROM member AS T1\nJOIN party AS T2 ON T1.Party_ID = T2.Party_ID\nGROUP BY T1.Party_ID\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Party_name \nFROM member AS T1 \nJOIN party AS T2 ON T1.Party_ID = T2.Party_ID \nGROUP BY T1.Party_ID \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ]
    },
    "3637": {
        "db_id": "baseball_1",
        "question": "How many players enter hall of fame each year?",
        "ground_truth": "SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;",
        "amends": [
            "Do use column `yearid` in both the SELECT list and GROUP BY clause instead of `year` to correctly reference the actual column name. Do remove the ORDER BY clause instead of keeping it since the RIGHT_SQL does not require sorted output. The amended query now matches RIGHT_SQL's behavior by properly aggregating records by the yearid column."
        ],
        "rules": [
            "1) When the question asks about \"year\" in the context of hall of fame inductions: use the exact column name \"yearid\" from the hall_of_fame table instead of \"year\". 2) When counting players entering hall of fame per year: count using the canonical key \"yearid\" and group by \"yearid\". 3) When the question does not specify ordering requirements: do not include any sorting in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, COUNT(*) FROM hall_of_fame GROUP BY year ORDER BY year;",
            "SELECT yearid, COUNT(*) AS num_players FROM hall_of_fame GROUP BY yearid;"
        ],
        "rule_sql": [
            "SELECT yearid, COUNT(*) AS num_players FROM hall_of_fame GROUP BY yearid;"
        ]
    },
    "6912": {
        "db_id": "tracking_orders",
        "question": "Which customers have both \"On Road\" and \"Shipped\" as order status? List the customer ids.",
        "ground_truth": "SELECT T1.customer_id FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T2.order_status = \"On Road\" INTERSECT SELECT T1.customer_id FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T2.order_status = \"Shipped\"",
        "amends": [
            "Do add `customers` table with alias `T1` instead of omitting it. Do change `FROM` source to `JOIN orders AS T2` instead of just `FROM orders`. Do add join condition `ON T1.customer_id = T2.customer_id` instead of no join. Do change column reference to `T2.order_status` instead of `status`. Do change filter condition to use `INTERSECT` between two separate queries for different status values instead of `OR` condition with `GROUP BY`. Do use exact string comparison `=\"On Road\"` and `=\"Shipped\"` instead of single quotes. Do remove `GROUP BY customer_id` instead of keeping it since the INTERSECT operation handles the distinct customer logic. The amended query now correctly finds customers who have both 'On Road' and 'Shipped' orders using set intersection instead of incorrectly grouping orders with either status."
        ],
        "rules": [
            "1) When answering about customers with both order statuses: use the customers table as T1 and orders table as T2 instead of just orders table. 2) When combining T1 and T2: link rows where T1.customer_id = T2.customer_id and keep only matching pairs (inner match). 3) When the question mentions \"On Road\" and \"Shipped\" as order status: use exact string comparisons T2.order_status = \"On Road\" and T2.order_status = \"Shipped\" instead of single quotes. 4) When finding customers with both statuses: use set intersection between separate queries for each status instead of OR condition with GROUP BY. 5) When the question asks for customer ids: output T1.customer_id as the result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT customer_id FROM orders WHERE status = 'On Road' OR status = 'Shipped' GROUP BY customer_id;",
            "SELECT T1.customer_id\nFROM Customers AS T1\nJOIN Orders AS T2 ON T1.customer_id = T2.customer_id\nWHERE T2.order_status = \"On Road\"\nINTERSECT\nSELECT T1.customer_id\nFROM Customers AS T1\nJOIN Orders AS T2 ON T1.customer_id = T2.customer_id\nWHERE T2.order_status = \"Shipped\""
        ],
        "rule_sql": [
            "SELECT T1.customer_id\nFROM Customers AS T1\nINNER JOIN Orders AS T2 ON T1.customer_id = T2.customer_id\nWHERE T2.order_status = \"On Road\"\nINTERSECT\nSELECT T1.customer_id\nFROM Customers AS T1\nINNER JOIN Orders AS T2 ON T1.customer_id = T2.customer_id\nWHERE T2.order_status = \"Shipped\""
        ]
    },
    "5907": {
        "db_id": "cre_Theme_park",
        "question": "What are the distinct visit dates?",
        "ground_truth": "SELECT DISTINCT Visit_Date FROM VISITS",
        "amends": [
            "Do reference the column as `Visit_Date` instead of `date` to match the actual column name. Do reference the table as `VISITS` instead of `visits` to match the actual table name. Do remove the `WHERE date IS NOT NULL` filter instead of keeping it since the DISTINCT already handles NULL values appropriately. Do remove the `ORDER BY date DESC` clause instead of including it as ordering is not required for this distinct selection. The amended query now correctly selects distinct visit dates from the VISITS table without unnecessary filtering or ordering."
        ],
        "rules": [
            "1) When selecting distinct values from a table: use the exact table name as specified in the schema, which is \"VISITS\" with double quotes. 2) When referencing the visit date column: use the exact column name \"Visit_Date\" with double quotes instead of generic terms like \"date\". 3) When selecting distinct values: do not include unnecessary filtering for NULL values since DISTINCT already handles NULL values appropriately. 4) When the question only asks for distinct values without ordering requirements: do not include ORDER BY clauses in the query."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT date FROM visits WHERE date IS NOT NULL ORDER BY date DESC",
            "SELECT DISTINCT Visit_Date FROM VISITS;"
        ],
        "rule_sql": [
            "SELECT DISTINCT \"Visit_Date\" FROM \"VISITS\";"
        ]
    },
    "360": {
        "db_id": "flight_1",
        "question": "What are the names of all aircrafts that can cover more distances than average?",
        "ground_truth": "SELECT name FROM Aircraft WHERE distance  >  (SELECT avg(distance) FROM Aircraft)",
        "amends": [
            "Do reference table `Aircraft` instead of `aircrafts` in both the main query and subquery. Do use column `distance` instead of `range` in both the comparison and aggregate calculation. Do maintain the same structure of comparing against a subquery that calculates the average value from the same table. The amended query now correctly uses the proper table and column names to match the intended logic of selecting aircraft names where the distance exceeds the average distance across all aircraft."
        ],
        "rules": [
            "1) When the question mentions \"aircrafts\": use the exact table name \"Aircraft\" with double quotes as shown in the amends. 2) When the question asks about \"cover more distances\": use the exact column name \"distance\" with double quotes as shown in the amends. 3) When comparing against average distance: calculate the average of \"distance\" from the \"Aircraft\" table and compare each aircraft's \"distance\" against this average value. 4) When selecting aircraft names: output the \"name\" column from the \"Aircraft\" table where the \"distance\" exceeds the calculated average."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM aircrafts WHERE range > (SELECT AVG(range) FROM aircrafts)",
            "SELECT name FROM Aircraft WHERE distance > (SELECT AVG(distance) FROM Aircraft)"
        ],
        "rule_sql": [
            "SELECT \"name\" FROM \"Aircraft\" WHERE \"distance\" > (SELECT AVG(\"distance\") FROM \"Aircraft\")"
        ]
    },
    "3621": {
        "db_id": "music_1",
        "question": "List the id, genre and artist name of English songs ordered by rating.",
        "ground_truth": "SELECT f_id ,  genre_is ,  artist_name FROM song WHERE languages  =   \"english\" ORDER BY rating",
        "amends": [
            "Do select `f_id`, `genre_is`, and `artist_name` instead of `id`, `genre`, and `artist_name`. Do query from `song` instead of `songs`. Do filter on `languages = \"english\"` instead of `language = 'English'`. Do order by `rating` instead of `release_date`. The amended query now correctly references the schema and matches the intended behavior."
        ],
        "rules": [
            "1) When selecting song identifiers: use \"f_id\" instead of \"id\" as the canonical identifier column. 2) When selecting song genres: use \"genre_is\" instead of \"genre\" as the column name. 3) When querying the songs table: use table name \"song\" instead of \"songs\". 4) When filtering by language: use column \"languages\" with exact literal value \"english\" (lowercase) instead of \"language = 'English'\". 5) When ordering songs by rating: use column \"rating\" instead of \"release_date\" for the sort order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, genre, artist_name FROM songs WHERE language = 'English' ORDER BY release_date;",
            "SELECT f_id, genre_is, artist_name FROM song WHERE languages = 'english' ORDER BY rating;"
        ],
        "rule_sql": [
            "SELECT f_id, genre_is, artist_name FROM song WHERE languages = 'english' ORDER BY rating;"
        ]
    },
    "4440": {
        "db_id": "network_2",
        "question": "Find the name and age of the person who is a friend of both Dan and Alice.",
        "ground_truth": "SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Dan' INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Alice'",
        "amends": [
            "Do use `JOIN` with `PersonFriend` table instead of querying `person` table directly. Do reference columns as `T1.name` and `T1.age` instead of just `name` and `age`. Do filter on `T2.friend = 'Dan'` and `T2.friend = 'Alice'` in separate queries instead of using `AND friend_of = 'Dan' AND friend_of = 'Alice'` which creates an impossible condition. Do use `INTERSECT` to find common friends instead of the contradictory `WHERE` clause. Do add table aliases `T1` and `T2` instead of omitting them. The amended query now correctly finds people who are friends with both Dan and Alice by intersecting two separate friend queries.",
            "Do join `PersonFriend` on `T1.name = T2.name` instead of `T1.name = T2.friend` in both query parts. Do filter on `T2.friend = 'Dan'` and `T2.friend = 'Alice'` instead of `T2.name = 'Dan'` and `T2.name = 'Alice'` respectively. The amended query now correctly finds people who are friends with both Dan and Alice by properly joining on the name columns and filtering on the friend columns, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"name and age of the person who is a friend of both Dan and Alice\": make sure the output order: T1.name, T1.age\n2) When the question mentions \"friend of both Dan and Alice\": use the PersonFriend table with separate queries for each friend condition and intersect the results\n3) When filtering for friends of specific people: use exact literal values 'Dan' and 'Alice' with the correct case and spacing\n4) When combining friend queries: use INTERSECT to find common friends instead of AND conditions that create impossible conditions\n5) When referencing columns from the person table: use the exact aliases T1.name and T1.age instead of unqualified column names\n6) When using table aliases: maintain T1 for the person table and T2 for the PersonFriend table as established in the amends",
            "1) When joining Person and PersonFriend tables: link rows where T1.name = T2.name exactly as shown in the amends, not T1.name = T2.friend\n2) When filtering for friends of Dan: use T2.friend = 'Dan' exactly with the literal 'Dan' and correct column reference\n3) When filtering for friends of Alice: use T2.friend = 'Alice' exactly with the literal 'Alice' and correct column reference\n4) When finding people who are friends with both Dan and Alice: use INTERSECT to combine results from both friend conditions to get only those who satisfy both"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, age FROM person WHERE friend_of = 'Dan' AND friend_of = 'Alice';",
            "SELECT T1.name, T1.age\nFROM Person T1\nJOIN PersonFriend T2 ON T1.name = T2.friend\nWHERE T2.name = 'Dan'\nINTERSECT\nSELECT T1.name, T1.age\nFROM Person T1\nJOIN PersonFriend T2 ON T1.name = T2.friend\nWHERE T2.name = 'Alice'",
            "SELECT T1.name, T1.age\nFROM Person T1\nJOIN PersonFriend T2 ON T1.name = T2.name\nWHERE T2.friend = 'Dan'\nINTERSECT\nSELECT T1.name, T1.age\nFROM Person T1\nJOIN PersonFriend T2 ON T1.name = T2.name\nWHERE T2.friend = 'Alice'"
        ],
        "rule_sql": [
            "SELECT T1.name, T1.age\nFROM Person T1\nJOIN PersonFriend T2 ON T1.name = T2.name\nWHERE T2.friend = 'Dan'\nINTERSECT\nSELECT T1.name, T1.age\nFROM Person T1\nJOIN PersonFriend T2 ON T1.name = T2.name\nWHERE T2.friend = 'Alice'"
        ]
    },
    "2934": {
        "db_id": "sakila_1",
        "question": "Which city has the most addresses? List the city name, number of addresses, and city id.",
        "ground_truth": "SELECT T2.city ,  count(*) ,  T1.city_id FROM address AS T1 JOIN city AS T2 ON T1.city_id  =  T2.city_id GROUP BY T1.city_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of no table references. Do join `address AS T1` with `city AS T2` on `T1.city_id = T2.city_id` instead of querying only the addresses table. Do select `T2.city` and `T1.city_id` instead of just `city` and `city_id` without table qualification. Do group by `T1.city_id` instead of grouping by `city` which could cause ambiguity. Do order by `count(*) DESC` instead of `address_count ASC` to get the highest count. Do remove the alias `address_count` instead of keeping it since the ORDER BY clause references the aggregate function directly. The amended query now correctly joins the address and city tables to find the city with the most addresses, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about cities and addresses: join table \"address\" as T1 with table \"city\" as T2 using T1.city_id = T2.city_id to match addresses to their cities. 2) When counting addresses per city: group by T1.city_id to count addresses correctly for each city. 3) When selecting city information: include T2.city for the city name and T1.city_id for the city identifier. 4) When finding the city with the most addresses: order by count(*) in descending direction to get the highest count. 5) When limiting to the top result: take only the first row after ordering by count in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, COUNT(*) as address_count, city_id FROM addresses GROUP BY city ORDER BY address_count ASC LIMIT 1;",
            "SELECT T2.city, COUNT(*) AS address_count, T1.city_id \nFROM address AS T1 \nJOIN city AS T2 ON T1.city_id = T2.city_id \nGROUP BY T1.city_id \nORDER BY COUNT(*) DESC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT c.city, COUNT(a.address_id) as address_count, c.city_id \nFROM address a \nJOIN city c ON a.city_id = c.city_id \nGROUP BY a.city_id \nORDER BY address_count DESC \nLIMIT 1;"
        ]
    },
    "1857": {
        "db_id": "wrestler",
        "question": "Give the names of wrestlers and their elimination moves.",
        "ground_truth": "SELECT T2.Name ,  T1.Elimination_Move FROM elimination AS T1 JOIN wrestler AS T2 ON T1.Wrestler_ID  =  T2.Wrestler_ID",
        "amends": [
            "Do select `T2.Name` and `T1.Elimination_Move` instead of `name` and `move`. Do join `elimination AS T1` with `wrestler AS T2` on `T1.Wrestler_ID = T2.Wrestler_ID` instead of querying only the `wrestlers` table. Do remove the `WHERE elimination = 'yes'` filter instead of keeping it, as the join condition now properly connects the tables. The amended query now correctly retrieves elimination moves from the elimination table joined with wrestler names from the wrestler table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about wrestlers and their elimination moves: make sure the output order: T2.Name, T1.Elimination_Move\n2) When combining elimination and wrestler tables: link rows where T1.Wrestler_ID = T2.Wrestler_ID exactly as shown; keep only matching pairs (inner match)\n3) When selecting wrestler names: use T2.Name instead of name\n4) When selecting elimination moves: use T1.Elimination_Move instead of move\n5) When the question asks for elimination moves: do not filter by elimination = 'yes' as the join condition properly connects the tables"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, move FROM wrestlers WHERE elimination = 'yes';",
            "SELECT T2.Name, T1.Elimination_Move FROM elimination AS T1 JOIN wrestler AS T2 ON T1.Wrestler_ID = T2.Wrestler_ID"
        ],
        "rule_sql": [
            "SELECT T2.Name, T1.Elimination_Move FROM Elimination T1 INNER JOIN wrestler T2 ON T1.Wrestler_ID = T2.Wrestler_ID"
        ]
    },
    "2215": {
        "db_id": "formula_1",
        "question": "Find the id and location of circuits that belong to France or Belgium?",
        "ground_truth": "SELECT circuitid ,  LOCATION FROM circuits WHERE country = \"France\" OR country = \"Belgium\"",
        "amends": [
            "Do select `circuitid` instead of `id` and maintain `LOCATION` instead of `location`. Do use `OR` condition for `country = \"France\"` OR `country = \"Belgium\"` instead of incorrectly using `AND` which would return no results. The amended query now correctly returns circuits from either France or Belgium instead of requiring circuits to be in both countries simultaneously."
        ],
        "rules": [
            "1) When the question asks for \"id\" of circuits: use the exact column token \"circuitid\" instead of \"id\". 2) When the question asks for \"location\" of circuits: use the exact column token \"LOCATION\" with the correct case. 3) When the question asks for circuits that belong to France OR Belgium: use OR condition with country = \"France\" OR country = \"Belgium\" instead of AND which would return no results. 4) When selecting output columns: maintain the order circuitid then LOCATION as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, location FROM circuits WHERE country = 'France' AND country = 'Belgium';",
            "SELECT circuitId, location FROM circuits WHERE country = 'France' OR country = 'Belgium';"
        ],
        "rule_sql": [
            "SELECT circuitId, location FROM circuits WHERE country = 'France' OR country = 'Belgium';"
        ]
    },
    "3525": {
        "db_id": "hr_1",
        "question": "display the department name and number of employees in each of the department.",
        "ground_truth": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name",
        "amends": [
            "Do add `JOIN departments AS T2 ON T1.department_id = T2.department_id` instead of omitting the departments table join. Do change the GROUP BY clause to `department_name` instead of `department_id` to properly group by the department name column from the joined departments table. Do add table alias `AS T1` for the employees table instead of leaving it unaliased. The amended query now correctly joins the departments table to access department names and groups by the actual name column rather than the ID, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"department name and number of employees in each department\": make sure the output order: department_name, count of employees. 2) When combining employees and departments tables: link rows where T1.department_id = T2.department_id and keep only matching pairs (inner match). 3) When the question asks for \"number of employees in each department\": compute the count using the canonical key T1.employee_id per department group. 4) When grouping by department: organize results by T2.department_name instead of T1.department_id to properly display department names. 5) When referring to table roles: use T1 for employees table and T2 for departments table as established in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department_name, COUNT(*) FROM employees GROUP BY department_id;",
            "SELECT T2.DEPARTMENT_NAME, COUNT(T1.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES FROM employees AS T1 JOIN departments AS T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID GROUP BY T2.DEPARTMENT_NAME"
        ],
        "rule_sql": [
            "SELECT T2.DEPARTMENT_NAME, COUNT(T1.EMPLOYEE_ID) \nFROM employees T1 \nINNER JOIN departments T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID \nGROUP BY T2.DEPARTMENT_NAME"
        ]
    },
    "6798": {
        "db_id": "activity_1",
        "question": "What are the first names of the professors who do not play Canoeing or Kayaking as activities?",
        "ground_truth": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'",
        "amends": [
            "Do select `lname` from `faculty` instead of `first_name` from `professors`. Do add `WHERE rank = 'Professor'` instead of omitting it. Do use `EXCEPT` with a subquery instead of `NOT IN`. Do add `JOIN Faculty_participates_in` and `JOIN activity` instead of omitting these tables. Do use `ON T1.facID = T2.facID` and `ON T2.actid = T3.actid` instead of incorrect join conditions. Do filter with `T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'` instead of `activity NOT IN`. Do add `DISTINCT` in the subquery instead of omitting it. The amended query now correctly identifies professors who don't participate in specified activities using proper table relationships and set operations.",
            "Do select `lname` instead of `Fname` in both SELECT clauses. Do use table alias `T1` instead of `f` for the Faculty table in the second query. Do use proper table aliases `T2` and `T3` instead of `fpi` and `a` respectively. Do fix the JOIN condition from `fpi.actid = a.actid` to `T2.actid = T3.actid` instead of the incorrect `T2.actid = T2.actid`. The amended query now correctly matches the RIGHT_SQL's behavior by properly joining tables and selecting the appropriate column.",
            "Do use `T2.actid = T3.actid` instead of `T2.actid = T2.actid` in the JOIN condition between Faculty_Participates_in and Activity tables, as the original condition incorrectly joins on the same table column instead of properly linking to the Activity table's actid column. The amended query now correctly establishes the relationship between participation records and activities, ensuring proper filtering for Canoeing and Kayaking activities.",
            "Do use `T2.actid = T3.actid` in the JOIN condition instead of `T2.actid = T2.actid` which creates an incorrect self-reference. The amended query now correctly joins the Faculty_participates_in table with the Activity table using the proper foreign key relationship, ensuring that only professors who participate in Canoeing or Kayaking activities are excluded from the result set.",
            "Do use `DISTINCT` in the second SELECT instead of omitting it to prevent duplicate names from appearing in the EXCEPT result. Do correct the JOIN condition from `T2.actid = T2.actid` to `T2.actid = T3.actid` instead of the self-referencing join that would cause incorrect matches. Do maintain the same column selection `lname` and WHERE filter for Professor rank instead of changing them. The amended query now correctly identifies professors who don't participate in Canoeing or Kayaking activities by properly joining tables and eliminating duplicates."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM professors WHERE activity NOT IN ('Canoeing', 'Kayaking')",
            "SELECT Fname FROM Faculty WHERE rank = 'Professor' EXCEPT SELECT DISTINCT f.Fname FROM Faculty f JOIN Faculty_Participates_in fpi ON f.FacID = fpi.FacID JOIN Activity a ON fpi.actid = a.actid WHERE a.activity_name = 'Canoeing' OR a.activity_name = 'Kayaking'",
            "SELECT lname FROM Faculty WHERE rank = 'Professor'\nEXCEPT\nSELECT DISTINCT T1.lname \nFROM Faculty T1\nJOIN Faculty_Participates_in T2 ON T1.FacID = T2.FacID\nJOIN Activity T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'",
            "SELECT lname FROM Faculty WHERE rank = 'Professor'\nEXCEPT\nSELECT DISTINCT T1.lname \nFROM Faculty T1\nJOIN Faculty_Participates_in T2 ON T1.FacID = T2.FacID\nJOIN Activity T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'",
            "SELECT lname\nFROM Faculty T1\nWHERE T1.Rank = 'Professor'\nEXCEPT\nSELECT T1.lname\nFROM Faculty T1\nJOIN Faculty_Participates_in T2 ON T1.FacID = T2.FacID\nJOIN Activity T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'",
            "SELECT lname FROM Faculty WHERE rank = 'Professor'\nEXCEPT\nSELECT DISTINCT T1.lname \nFROM Faculty T1\nJOIN Faculty_Participates_in T2 ON T1.FacID = T2.FacID\nJOIN Activity T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'"
        ],
        "rule_sql": []
    },
    "3165": {
        "db_id": "station_weather",
        "question": "What is the average high temperature for each day of week?",
        "ground_truth": "SELECT avg(high_temperature) ,  day_of_week FROM weekly_weather GROUP BY day_of_week",
        "amends": [
            "Do include `day_of_week` in the SELECT list instead of omitting it, which would cause the aggregation to fail by not including the GROUP BY column in the output. Do reference table `weekly_weather` instead of `weather_data` to ensure the correct data source is queried. The amended query now correctly includes both the aggregated average temperature and the grouping column, matching the intended behavior.",
            "Do place `avg(high_temperature)` without an alias instead of `AVG(high_temperature) AS average_high_temperature`, and do list `day_of_week` after the aggregate instead of before it in the SELECT clause, while maintaining the same GROUP BY logic. The amended query now matches RIGHT_SQL's behavior.",
            "Do place `avg(high_temperature)` before `day_of_week` in the SELECT list instead of after it, maintaining the same aggregation logic and GROUP BY clause structure. The amended query now matches RIGHT_SQL's behavior with identical column ordering."
        ],
        "rules": [
            "1) When answering about \"average high temperature for each day of week\": make sure the output order includes both the grouping column and the aggregated value. 2) When the question mentions \"day of week\": \"day of week\" actually means \"day_of_week in weekly_weather table\". 3) When the question asks for \"average high temperature\": compute the average of the high_temperature column. 4) When the question says \"for each day of week\": organize results by day_of_week and compute the average high temperature per group. 5) When referencing the data source: use table weekly_weather instead of weather_data to ensure the correct data source is queried.",
            "1) When the question asks for average high temperature for each day of week: compute the average of high_temperature values grouped by day_of_week. 2) When producing output columns: list the aggregate function avg(high_temperature) first, followed by day_of_week. 3) When grouping results: organize by day_of_week to show average temperature for each distinct day. 4) When using aggregate functions: do not add aliases to the aggregate expression avg(high_temperature).",
            "1) When answering about \"average high temperature for each day of week\": make sure the output order: avg(high_temperature) before day_of_week\n2) When the question asks for \"average high temperature per day of week\": organize results by day_of_week and compute the average of high_temperature per group"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(high_temperature) FROM weather_data GROUP BY day_of_week;",
            "SELECT day_of_week, AVG(high_temperature) AS average_high_temperature FROM weekly_weather GROUP BY day_of_week",
            "SELECT day_of_week, avg(high_temperature) FROM weekly_weather GROUP BY day_of_week",
            "SELECT avg(high_temperature), day_of_week FROM weekly_weather GROUP BY day_of_week"
        ],
        "rule_sql": [
            "SELECT AVG(high_temperature), day_of_week FROM weekly_weather GROUP BY day_of_week"
        ]
    },
    "3472": {
        "db_id": "hr_1",
        "question": "What is the minimum salary in each department?",
        "ground_truth": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id",
        "amends": [
            "Do use `MIN(salary)` instead of `MAX(salary)` for the aggregate function. Do reference `department_id` instead of `department` as the grouping column. Do place the aggregate column `MIN(salary)` first instead of second in the SELECT list. The amended query now correctly calculates minimum salaries by department ID instead of maximum salaries by department name.",
            "Do place `MIN(salary)` first in the SELECT list instead of `DEPARTMENT_ID` first, and do use lowercase column names `department_id` and `salary` instead of uppercase `DEPARTMENT_ID` and `SALARY`."
        ],
        "rules": [
            "1) When the question asks for minimum salary: use MIN(salary) instead of MAX(salary) as the aggregate function. 2) When grouping by department: use department_id as the grouping column instead of department. 3) When ordering output columns: place the aggregate column MIN(salary) first in the result instead of second.",
            "1) When the question asks for minimum salary in each department: make sure the output order is MIN(salary) first then department_id. 2) When referring to column names in the employees table: use lowercase department_id and salary instead of uppercase DEPARTMENT_ID and SALARY. 3) When grouping by department: organize results by department_id and compute the minimum salary per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department, MAX(salary) FROM employees GROUP BY department;",
            "SELECT DEPARTMENT_ID, MIN(SALARY) FROM employees GROUP BY DEPARTMENT_ID",
            "SELECT MIN(salary) AS min_salary, department_id FROM employees GROUP BY department_id"
        ],
        "rule_sql": [
            "SELECT MIN(salary) AS min_salary, department_id FROM employees GROUP BY department_id ORDER BY department_id;"
        ]
    },
    "1908": {
        "db_id": "school_finance",
        "question": "Find the number of schools that have more than one donator whose donation amount is less than 8.5.",
        "ground_truth": "SELECT count(*) FROM (SELECT * FROM endowment WHERE amount  >  8.5 GROUP BY school_id HAVING count(*)  >  1)",
        "amends": [
            "Do use the `endowment` table instead of the `schools` and `donations` tables. Do filter for `amount > 8.5` instead of `amount < 8.5`. Do remove the `WHERE` clause with the `IN` subquery and instead use a derived table structure. Do keep the `GROUP BY school_id` and `HAVING count(*) > 1` conditions but apply them directly to the main query instead of within a subquery. Do maintain the `COUNT(*)` aggregate function but apply it to the grouped results instead of counting all records. The amended query now correctly identifies schools with multiple endowment contributions exceeding 8.5, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"number of schools with more than one donator whose donation amount is less than 8.5\": use the endowment table instead of schools and donations tables. 2) When filtering donation amounts: use amount > 8.5 instead of amount < 8.5. 3) When structuring the query: use a derived table structure instead of a WHERE clause with IN subquery. 4) When grouping results: maintain GROUP BY school_id and HAVING count(*) > 1 conditions directly in the main query. 5) When counting schools: use COUNT(*) aggregate function applied to the grouped results instead of counting all records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM schools WHERE school_id IN (SELECT school_id FROM donations WHERE amount < 8.5 GROUP BY school_id HAVING COUNT(*) > 1);",
            "SELECT COUNT(*) \nFROM (\n    SELECT School_id \n    FROM endowment \n    WHERE amount > 8.5 \n    GROUP BY School_id \n    HAVING COUNT(*) > 1\n)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM (\n    SELECT School_id \n    FROM endowment \n    WHERE amount > 8.5 \n    GROUP BY School_id \n    HAVING COUNT(*) > 1\n) AS schools_with_multiple_donators"
        ]
    },
    "5957": {
        "db_id": "cre_Theme_park",
        "question": "What are the names of tourist attractions that can be reached by walk or is at address 660 Shea Crescent?",
        "ground_truth": "SELECT T2.Name FROM Locations AS T1 JOIN Tourist_Attractions AS T2 ON T1.Location_ID  =  T2.Location_ID WHERE T1.Address  =  \"660 Shea Crescent\" OR T2.How_to_Get_There  =  \"walk\"",
        "amends": [
            "Do select `T2.Name` from the `Tourist_Attractions` table instead of `name` from a single table. Do join `Locations AS T1` with `Tourist_Attractions AS T2` using `T1.Location_ID = T2.Location_ID` instead of querying only the `tourist_attractions` table. Do filter on `T1.Address = \"660 Shea Crescent\"` and `T2.How_to_Get_There = \"walk\"` instead of filtering on `transportation = 'walk'` and `address = '660 Shea Crescent'` within a single table. The amended query now correctly joins location and attraction data and uses the proper column names for filtering, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about tourist attractions: make sure the output order: T2.Name 2) When combining Locations and Tourist_Attractions tables: link rows where T1.Location_ID = T2.Location_ID and keep only matching pairs (inner match) 3) When the question mentions \"walk\": \"walk\" actually means T2.How_to_Get_There = \"walk\" in schema 4) When the question mentions address \"660 Shea Crescent\": \"660 Shea Crescent\" actually means T1.Address = \"660 Shea Crescent\" in schema 5) When filtering for attractions reachable by walk OR at address 660 Shea Crescent: include rows where T2.How_to_Get_There = \"walk\" OR T1.Address = \"660 Shea Crescent\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM tourist_attractions WHERE transportation = 'walk' OR address = '660 Shea Crescent';",
            "SELECT T2.Name \nFROM Locations AS T1\nJOIN Tourist_Attractions AS T2 ON T1.Location_ID = T2.Location_ID\nWHERE T1.Address = '660 Shea Crescent' OR T2.How_to_Get_There = 'walk'"
        ],
        "rule_sql": [
            "SELECT T2.Name \nFROM Locations T1 \nINNER JOIN Tourist_Attractions T2 ON T1.Location_ID = T2.Location_ID \nWHERE T2.How_to_Get_There = 'walk' OR T1.Address = '660 Shea Crescent' \nORDER BY T2.Name"
        ]
    },
    "2022": {
        "db_id": "gas_company",
        "question": "What are the headquarters without companies that are in the banking industry?",
        "ground_truth": "SELECT headquarters FROM company EXCEPT SELECT headquarters FROM company WHERE main_industry  =  'Banking'",
        "amends": [
            "Do use `EXCEPT` to exclude specific headquarters instead of a simple `WHERE` filter. Do reference the correct table name `company` instead of `companies`. Do filter on `main_industry = 'Banking'` (with proper case) instead of `industry = 'banking'`. Do remove the `WHERE` clause entirely and replace it with set-based exclusion logic using `EXCEPT`. The amended query now correctly returns headquarters from all companies except those in the Banking industry, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for headquarters without companies in a specific industry: use set-based exclusion logic with EXCEPT instead of simple WHERE filtering. 2) When referring to the companies table: use the exact table name \"company\" (not \"companies\"). 3) When filtering for the banking industry: use the exact literal 'Banking' (with proper case) and the exact column name \"main_industry\" (not \"industry\"). 4) When excluding companies in the banking industry: remove the WHERE clause entirely and implement exclusion through set operations."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT headquarters FROM companies WHERE industry = 'banking';",
            "SELECT Headquarters FROM company EXCEPT SELECT Headquarters FROM company WHERE Main_Industry = 'Banking'"
        ],
        "rule_sql": [
            "SELECT Headquarters FROM company\nEXCEPT\nSELECT Headquarters FROM company WHERE Main_Industry = 'Banking'"
        ]
    },
    "6302": {
        "db_id": "city_record",
        "question": "List venues of all matches in the order of their dates starting from the most recent one.",
        "ground_truth": "SELECT venue FROM MATCH ORDER BY date DESC",
        "amends": [
            "Do reference table `MATCH` instead of `matches` in the FROM clause. Do use `DESC` ordering instead of `ASC` for the date column in the ORDER BY clause. The amended query now correctly references the proper table name and sorts results in descending chronological order."
        ],
        "rules": [
            "1) When the question asks about matches: use table \"MATCH\" instead of \"matches\" as the data source. 2) When ordering by date starting from the most recent: sort the \"date\" column in descending order (DESC) rather than ascending order (ASC)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT venue FROM matches ORDER BY date ASC;",
            "SELECT Venue FROM \"match\" ORDER BY Date DESC;"
        ],
        "rule_sql": [
            "SELECT Venue FROM MATCH ORDER BY Date DESC;"
        ]
    },
    "2716": {
        "db_id": "storm_record",
        "question": "What is the storm name and max speed which affected the greatest number of regions?",
        "ground_truth": "SELECT T1.name ,  T1.max_speed FROM storm AS T1 JOIN affected_region AS T2 ON T1.storm_id  =  T2.storm_id GROUP BY T1.storm_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.name` and `T1.max_speed` instead of `storm_name`, `max_speed`, and `COUNT(region) as region_count`. Do use `FROM storm AS T1 JOIN affected_region AS T2` instead of `FROM storms`. Do add `ON T1.storm_id = T2.storm_id` instead of omitting the join condition. Do change `GROUP BY T1.storm_id` instead of `GROUP BY storm_name, max_speed`. Do use `ORDER BY count(*) DESC` instead of `ORDER BY region_count DESC`. The amended query now correctly joins the storm and affected_region tables to count regions per storm and returns the storm with the most affected regions."
        ],
        "rules": [
            "1) When answering about \"storm name and max speed which affected the greatest number of regions\": make sure the output order: T1.name, T1.max_speed\n2) When the question mentions \"storm name\": \"storm name\" actually means \"T1.name in schema\"\n3) When the question mentions \"max speed\": \"max speed\" actually means \"T1.max_speed in schema\"\n4) When the question asks for \"count of regions affected by a storm\": compute the number of rows using the join between T1 and T2 where T1.storm_id = T2.storm_id\n5) When combining T1 and T2 for shared entities: link rows where T1.storm_id = T2.storm_id exactly as shown in the amends; keep only matching pairs (inner match)\n6) When the question asks for \"greatest number of regions\": rank rows by count of affected regions in descending order and keep the first 1 row\n7) When grouping by storm: organize results by T1.storm_id and compute requested aggregates per group\n8) When ordering by count: use ORDER BY count(*) DESC instead of any alias name for the count"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT storm_name, max_speed, COUNT(region) as region_count FROM storms GROUP BY storm_name, max_speed ORDER BY region_count DESC LIMIT 1;",
            "SELECT T1.Name, T1.Max_speed\nFROM storm AS T1\nJOIN affected_region AS T2 ON T1.Storm_ID = T2.Storm_ID\nGROUP BY T1.Storm_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Name, T1.Max_speed\nFROM storm T1\nJOIN affected_region T2 ON T1.Storm_ID = T2.Storm_ID\nGROUP BY T1.Storm_ID\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "6494": {
        "db_id": "scientist_1",
        "question": "What are the names of all the scientists in alphabetical order?",
        "ground_truth": "SELECT name FROM scientists ORDER BY name",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM scientists ORDER BY name DESC;"
        ],
        "rule_sql": [
            "SELECT Name FROM Scientists ORDER BY Name ASC;"
        ]
    },
    "1677": {
        "db_id": "theme_gallery",
        "question": "Show theme and year for all exhibitions in an descending order of ticket price.",
        "ground_truth": "SELECT theme ,  YEAR FROM exhibition ORDER BY ticket_price DESC",
        "amends": [
            "Do reference table `exhibition` instead of `exhibitions` in the FROM clause. Do sort by `ticket_price DESC` instead of `ASC` in the ORDER BY clause. The amended query now correctly references the exhibition table and sorts in descending order by ticket price."
        ],
        "rules": [
            "1) When the question mentions \"exhibitions\": use the exact table name \"exhibition\" from the schema. 2) When the question asks for descending order of ticket price: sort by \"ticket_price\" in descending order (highest to lowest). 3) When answering about theme and year for all exhibitions: make sure the output order: \"theme\", \"year\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT theme, year FROM exhibitions ORDER BY ticket_price ASC;",
            "SELECT Theme, Year FROM exhibition ORDER BY Ticket_Price DESC;"
        ],
        "rule_sql": [
            "SELECT theme, year FROM exhibition ORDER BY ticket_price DESC;"
        ]
    },
    "4886": {
        "db_id": "school_player",
        "question": "Please show different denominations and the corresponding number of schools.",
        "ground_truth": "SELECT Denomination ,  COUNT(*) FROM school GROUP BY Denomination",
        "amends": [
            "Do use the exact table name `school` instead of the incorrect plural form `schools`. Do capitalize the column name `Denomination` in both the SELECT list and GROUP BY clause instead of using lowercase `denomination` to match the correct schema. The amended query now correctly references the singular table name and maintains proper column capitalization, ensuring it matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about schools: use the exact table name \"school\" instead of plural forms like \"schools\". 2) When referring to denominations in the school table: use the exact column name \"Denomination\" with proper capitalization in both SELECT and GROUP BY clauses. 3) When counting schools by denomination: count using the canonical key (each row represents a school) and group by the exact \"Denomination\" column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT denomination, COUNT(*) FROM schools GROUP BY denomination;",
            "SELECT Denomination, COUNT(*) AS NumberOfSchools FROM school GROUP BY Denomination;"
        ],
        "rule_sql": [
            "SELECT Denomination, COUNT(*) AS Number_of_Schools FROM school GROUP BY Denomination;"
        ]
    },
    "6078": {
        "db_id": "customers_and_addresses",
        "question": "Return the address content for the customer whose name is \"Maudie Kertzmann\".",
        "ground_truth": "SELECT t3.address_content FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t1.customer_name  =  \"Maudie Kertzmann\"",
        "amends": [
            "Do join `customer_addresses AS t2` on `t1.customer_id = t2.customer_id` and `addresses AS t3` on `t2.address_id = t3.address_id` instead of querying only the `customers` table. Do select `t3.address_content` instead of `address` from the customers table directly. Do use `t1.customer_name = \"Maudie Kertzmann\"` instead of `name = 'Maudie Kertzmann'` to reference the correct column name and use double quotes for the string literal. The amended query now correctly retrieves address information through proper table relationships instead of assuming the address is stored directly in the customers table."
        ],
        "rules": [
            "1) When the question asks for address content for a customer: join customer_addresses as T2 on T1.customer_id = T2.customer_id and addresses as T3 on T2.address_id = T3.address_id to access the correct address information. 2) When selecting address content: use T3.address_content instead of any address column from the customers table. 3) When filtering by customer name: use T1.customer_name = \"Maudie Kertzmann\" with double quotes around the literal value and the exact column name customer_name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT address FROM customers WHERE name = 'Maudie Kertzmann';",
            "SELECT t3.address_content \nFROM Customers AS t1\nJOIN Customer_Addresses AS t2 ON t1.customer_id = t2.customer_id\nJOIN Addresses AS t3 ON t2.address_id = t3.address_id\nWHERE t1.customer_name = \"Maudie Kertzmann\""
        ],
        "rule_sql": [
            "SELECT T3.address_content \nFROM Customers AS T1\nJOIN Customer_Addresses AS T2 ON T1.customer_id = T2.customer_id\nJOIN Addresses AS T3 ON T2.address_id = T3.address_id\nWHERE T1.customer_name = \"Maudie Kertzmann\""
        ]
    },
    "3135": {
        "db_id": "assets_maintenance",
        "question": "How many assets can each parts be used in? List the part name and the number.",
        "ground_truth": "SELECT T1.part_name ,  count(*) FROM Parts AS T1 JOIN Asset_Parts AS T2 ON T1.part_id  =  T2.part_id GROUP BY T1.part_name",
        "amends": [
            "Do join `Parts AS T1` with `Asset_Parts AS T2` on `T1.part_id = T2.part_id` instead of querying only the `parts` table without any join. Do count all rows with `count(*)` instead of counting `asset_id` which may not exist in the joined context. Do reference `T1.part_name` with table alias instead of just `part_name` for clarity. The amended query now correctly counts assets associated with parts through the join relationship rather than attempting to count from a single table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"how many assets can each parts be used in\": make sure to join table \"Parts\" as T1 with table \"Asset_Parts\" as T2 on T1.part_id = T2.part_id to establish the relationship between parts and assets. 2) When counting assets associated with parts: use count(*) to count all rows in the joined result rather than counting a specific column like asset_id. 3) When selecting the part name: reference it as T1.part_name with the table alias for clarity and accuracy. 4) When grouping results by part: use T1.part_name as the grouping key to organize the count of assets per part."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT part_name, COUNT(asset_id) AS asset_count FROM parts GROUP BY part_name;",
            "SELECT T1.part_name, COUNT(*) AS number_of_assets\nFROM Parts AS T1\nJOIN Asset_Parts AS T2 ON T1.part_id = T2.part_id\nGROUP BY T1.part_id, T1.part_name"
        ],
        "rule_sql": [
            "SELECT T1.part_name, COUNT(*) AS asset_count\nFROM Parts AS T1\nJOIN Asset_Parts AS T2 ON T1.part_id = T2.part_id\nGROUP BY T1.part_name;"
        ]
    },
    "5481": {
        "db_id": "voter_2",
        "question": "What are the distinct majors that students with treasurer votes are studying?",
        "ground_truth": "SELECT DISTINCT T1.Major FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote",
        "amends": [
            "Do add `JOIN VOTING_RECORD AS T2 ON T1.StuID = T2.Treasurer_Vote` instead of querying only the `students` table. Do change the table reference from `students` to `STUDENT AS T1` instead of using the original table name directly. Do change the column reference from `major` to `T1.Major` instead of using the unqualified column name. Do remove the `WHERE position = 'treasurer'` filter instead of keeping it, as the join condition now properly identifies treasurer votes. The amended query now correctly identifies students who received treasurer votes by joining the voting records table instead of relying on a position field filter, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"distinct majors that students with treasurer votes are studying\": make sure the output order: T1.Major. 2) When the question mentions \"students with treasurer votes\": this requires joining STUDENT as T1 with VOTING_RECORD as T2 where T1.StuID = T2.Treasurer_Vote to identify students who received treasurer votes. 3) When combining T1 and T2 for shared entities: link rows where T1.StuID = T2.Treasurer_Vote exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"distinct majors\": compute the number of unique values of T1.Major. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table and column names."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT major FROM students WHERE position = 'treasurer';",
            "SELECT DISTINCT T1.Major FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID = T2.Treasurer_Vote"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Major FROM Student T1 JOIN Voting_record T2 ON T1.StuID = T2.Treasurer_Vote ORDER BY T1.Major;"
        ]
    },
    "266": {
        "db_id": "musical",
        "question": "List the nominees that have been nominated more than two musicals.",
        "ground_truth": "SELECT Nominee FROM musical GROUP BY Nominee HAVING COUNT(*)  >  2",
        "amends": [
            "Do reference the `Nominee` column instead of `nominee` and remove the `nomination_count` alias from the SELECT list instead of including it. Do use the `musical` table instead of the `nominations` table and remove the `WHERE category = 'Musical'` filter instead of keeping it, as the table name already implies the musical category. Do maintain the `GROUP BY Nominee` and `HAVING COUNT(*) > 2` clauses without changes. The amended query now correctly identifies musical nominees with more than 2 nominations by using the appropriate table source."
        ],
        "rules": [
            "1) When answering about \"nominees that have been nominated more than two musicals\": use the \"musical\" table instead of \"nominations\" table. 2) When the question mentions \"nominees\": use the exact column token \"Nominee\" (with capital N) from the musical table. 3) When counting nominations per nominee: group by \"Nominee\" and count all rows using COUNT(*). 4) When filtering for nominees with more than two nominations: apply HAVING COUNT(*) > 2. 5) When producing output: include only the \"Nominee\" column without any alias for the count."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT nominee, COUNT(*) as nomination_count \nFROM nominations \nWHERE category = 'Musical' \nGROUP BY nominee \nHAVING COUNT(*) > 2;",
            "SELECT Nominee FROM musical GROUP BY Nominee HAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT Nominee FROM musical GROUP BY Nominee HAVING COUNT(*) > 2"
        ]
    },
    "191": {
        "db_id": "bike_1",
        "question": "For each station, find its latitude and the minimum duration of trips that ended at the station.",
        "ground_truth": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id",
        "amends": [
            "Do reference `T1.name` and `T1.lat` instead of `station_id` and `latitude` in the SELECT list. Do join `station AS T1` to `trip AS T2` instead of querying only the `trips` table. Do use `ON T1.id = T2.end_station_id` for the join condition instead of grouping by station_id and latitude directly. Do group by `T2.end_station_id` instead of grouping by both station_id and latitude. The amended query now correctly joins station and trip tables to find minimum duration per end station with proper station details."
        ],
        "rules": [
            "1) When answering about stations and their trip durations: join table \"station\" as T1 to table \"trip\" as T2 using the condition T1.id = T2.end_station_id to match trips to their ending stations. 2) When the question asks for minimum duration of trips that ended at each station: compute the minimum value of duration from T2 for each group defined by T2.end_station_id. 3) When selecting station information: use T1.name for station identification and T1.lat for latitude instead of station_id and latitude. 4) When grouping results: group by T2.end_station_id to organize results by the ending station of trips. 5) When producing output: present the results with columns in the order T1.name, T1.lat, and the minimum duration value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT station_id, latitude, MIN(duration) FROM trips GROUP BY station_id, latitude;",
            "SELECT T1.name, T1.lat, MIN(T2.duration) AS min_duration\nFROM station AS T1\nJOIN trip AS T2 ON T1.id = T2.end_station_id\nGROUP BY T2.end_station_id;"
        ],
        "rule_sql": [
            "SELECT T1.name, T1.lat, MIN(T2.duration) \nFROM station AS T1 \nJOIN trip AS T2 ON T1.id = T2.end_station_id \nGROUP BY T2.end_station_id \nORDER BY T2.end_station_id;"
        ]
    },
    "5802": {
        "db_id": "customer_complaints",
        "question": "What is the last name of the staff who has handled the first ever complaint?",
        "ground_truth": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT 1",
        "amends": [
            "Do specify `t1.last_name` with table alias instead of just `last_name` without qualification. Do add `FROM staff AS t1 JOIN complaints AS t2` with explicit table aliases instead of just `FROM staff` without joins. Do add join condition `ON t1.staff_id = t2.staff_id` to connect the tables instead of omitting the join entirely. Do order by `t2.date_complaint_raised` from the joined complaints table instead of `complaint_date` which doesn't exist in the original table. The amended query now correctly joins staff with complaints and orders by the complaint date from the appropriate table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting columns from multiple tables: always qualify column names with table aliases (e.g., use t1.last_name instead of just last_name). 2) When joining tables Staff and Complaints: use explicit table aliases (Staff AS t1, Complaints AS t2) and connect them with join condition t1.staff_id = t2.staff_id. 3) When ordering by complaint date: use t2.date_complaint_raised from the Complaints table instead of complaint_date which doesn't exist. 4) When answering about the first ever complaint: order by t2.date_complaint_raised in ascending order and take the first result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM staff ORDER BY complaint_date ASC LIMIT 1;",
            "SELECT t1.last_name\nFROM staff AS t1\nJOIN complaints AS t2 ON t1.staff_id = t2.staff_id\nORDER BY t2.date_complaint_raised ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t1.last_name \nFROM Staff AS t1 \nJOIN Complaints AS t2 ON t1.staff_id = t2.staff_id \nORDER BY t2.date_complaint_raised ASC \nLIMIT 1"
        ]
    },
    "98": {
        "db_id": "student_assessment",
        "question": "What are the first names of the people in alphabetical order?",
        "ground_truth": "SELECT first_name FROM people ORDER BY first_name",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM people ORDER BY last_name ASC;"
        ],
        "rule_sql": [
            "SELECT first_name FROM People ORDER BY first_name ASC;"
        ]
    },
    "2075": {
        "db_id": "party_people",
        "question": "What are the names of parties with at least 2 events?",
        "ground_truth": "SELECT T2.party_name FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id HAVING count(*)  >=  2",
        "amends": [
            "Do use `T2.party_name` from the `party` table instead of `party_name` from a non-existent `parties` table. Do add `FROM party_events AS T1 JOIN party AS T2 ON T1.party_id = T2.party_id` instead of the incorrect `FROM parties` source. Do add `GROUP BY T1.party_id` to properly aggregate events by party instead of omitting grouping. Do move the count filter to `HAVING count(*) >= 2` instead of incorrectly placing `COUNT(event_id) >= 2` in the `WHERE` clause without aggregation. Do use `count(*)` to count all events instead of the unspecified `COUNT(event_id)`. The amended query now correctly identifies parties with at least two events by joining the party_events and party tables, grouping by party_id, and filtering the aggregated results."
        ],
        "rules": [
            "1) When the question asks for party names from events data: use \"T2.party_name\" from the \"party\" table instead of \"party_name\" from a non-existent \"parties\" table. 2) When combining party events and party information: link rows where \"T1.party_id = T2.party_id\" and keep only matching pairs (inner match). 3) When counting events per party: group by \"T1.party_id\" to organize results by party. 4) When counting events: use count(*) to count all events instead of unspecified column references. 5) When filtering for parties with at least 2 events: apply the condition \"count(*) >= 2\" after grouping instead of in the WHERE clause."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT party_name FROM parties WHERE COUNT(event_id) >= 2",
            "SELECT T2.Party_name \nFROM party_events AS T1 \nJOIN party AS T2 ON T1.Party_ID = T2.Party_ID \nGROUP BY T1.Party_ID \nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T2.Party_name FROM party_events T1 JOIN party T2 ON T1.Party_ID = T2.Party_ID GROUP BY T1.Party_ID HAVING COUNT(*) >= 2"
        ]
    },
    "3246": {
        "db_id": "college_1",
        "question": "What are the first names of all students who took ACCT-211 and received a C?",
        "ground_truth": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211' AND T2.enroll_grade  =  'C'",
        "amends": [
            "Do select `T3.stu_fname` instead of `first_name` to use the correct column name from the student table. Do join `CLASS AS T1` instead of omitting it to properly access course information. Do join `enroll AS T2` on `T1.class_code = T2.class_code` instead of omitting the enrollment relationship. Do join `student AS T3` on `T2.stu_num = T3.stu_num` instead of querying students directly without proper relationships. Do filter on `T1.crs_code = 'ACCT-211'` instead of `course = 'ACCT-211'` to use the correct table and column for course codes. Do filter on `T2.enroll_grade = 'C'` instead of `grade = 'C'` to use the correct table and column for grades. The amended query now properly joins the three required tables and uses the correct column references to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for first names of students: use the exact column \"T3.stu_fname\" from the student table. 2) When the question mentions \"ACCT-211\": filter using \"T1.crs_code = 'ACCT-211'\" exactly as written with the correct table and column. 3) When the question mentions receiving a C grade: filter using \"T2.enroll_grade = 'C'\" exactly as written with the correct table and column. 4) When combining information about classes, enrollments, and students: join CLASS as T1 with enroll as T2 on \"T1.class_code = T2.class_code\" and join enroll as T2 with student as T3 on \"T2.stu_num = T3.stu_num\" using inner matches. 5) When answering about students who took a specific course: make sure to access course information through the CLASS table and enrollment information through the enroll table rather than directly from the student table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE course = 'ACCT-211' AND grade = 'C';",
            "SELECT T3.STU_FNAME\nFROM CLASS AS T1\nJOIN ENROLL AS T2 ON T1.CLASS_CODE = T2.CLASS_CODE\nJOIN STUDENT AS T3 ON T2.STU_NUM = T3.STU_NUM\nWHERE T1.CRS_CODE = 'ACCT-211'\nAND T2.ENROLL_GRADE = 'C'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T3.stu_fname\nFROM CLASS AS T1\nINNER JOIN ENROLL AS T2 ON T1.class_code = T2.class_code\nINNER JOIN STUDENT AS T3 ON T2.stu_num = T3.stu_num\nWHERE T1.crs_code = 'ACCT-211' AND T2.enroll_grade = 'C'"
        ]
    },
    "1467": {
        "db_id": "college_2",
        "question": "What are the names of the instructors in the Comp. Sci. department who earn more than 80000?",
        "ground_truth": "SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'  AND salary  >  80000",
        "amends": [
            "Do use column `dept_name` instead of `department` in the WHERE filter. Do use comparison operator `>` instead of `<` for the salary condition, filtering for instructors earning more than 80000 instead of less than 80000. The amended query now correctly filters for Computer Science instructors with salaries above 80000, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"department\": \"department\" actually means \"dept_name\" in schema. 2) When filtering for instructors earning more than 80000: use comparison operator > instead of < with salary value 80000. 3) When answering about instructor names in Comp. Sci. department: make sure the output order: name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM instructor WHERE department = 'Comp. Sci.' AND salary < 80000",
            "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 80000"
        ],
        "rule_sql": [
            "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 80000 ORDER BY name;"
        ]
    },
    "6283": {
        "db_id": "city_record",
        "question": "What are the three largest cities in terms of regional population?",
        "ground_truth": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3",
        "amends": [
            "Do select `city` instead of `city_name` and use `regional_population` for ordering instead of `population`. Do reference table `city` instead of `cities` and order by `regional_population DESC` instead of `population DESC`. The amended query now correctly selects from the appropriate table with the proper column names and ordering criteria to match the intended behavior.",
            "Do select `city` instead of `City, Regional_Population` to return only the city names instead of both city names and population values. Do maintain the same `ORDER BY regional_population DESC` clause instead of changing the ordering logic. Do preserve the `LIMIT 3` constraint instead of modifying the result set size. The amended query now correctly returns only the top 3 cities by regional population rather than including unnecessary population data in the output."
        ],
        "rules": [
            "1) When the question asks for \"cities\": select from table \"city\" instead of \"cities\". 2) When the question asks for city names: use column \"city\" instead of \"city_name\". 3) When the question asks about \"regional population\": use column \"regional_population\" instead of \"population\" for ordering. 4) When the question asks for \"three largest\" cities by regional population: order by \"regional_population\" in descending direction and keep the first 3 rows.",
            "1) When answering about \"largest cities in terms of regional population\": make sure the output order: city names only without population values. 2) When the question mentions \"three largest\": rank rows by regional_population in descending order and keep the first 3 rows. 3) When producing output: return only the city column instead of both city and regional_population columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city_name, population FROM cities ORDER BY population DESC LIMIT 3;",
            "SELECT City, Regional_Population FROM city ORDER BY Regional_Population DESC LIMIT 3;",
            "SELECT City FROM city ORDER BY Regional_Population DESC LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT City FROM city ORDER BY Regional_Population DESC LIMIT 3;"
        ]
    },
    "2438": {
        "db_id": "movie_1",
        "question": "How many movies were made before 2000?",
        "ground_truth": "SELECT count(*) FROM Movie WHERE YEAR  <  2000",
        "amends": [
            "Do reference table `Movie` instead of `movies` in the FROM clause. Do use filter condition `YEAR < 2000` instead of `year >= 2000` to count movies released before the year 2000 rather than after it. The amended query now correctly counts movies from before 2000 and matches the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"movies\": use the exact table name \"Movie\" from the schema. 2) When the question asks for movies \"before 2000\": use the filter condition YEAR < 2000 to include movies released before the year 2000. 3) When counting movies: count all rows from the Movie table that satisfy the condition YEAR < 2000."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies WHERE year >= 2000;",
            "SELECT COUNT(*) FROM Movie WHERE year < 2000"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Movie WHERE year < 2000"
        ]
    },
    "5560": {
        "db_id": "products_gen_characteristics",
        "question": "List all the characteristic names and data types of product \"cumin\".",
        "ground_truth": "SELECT t3.characteristic_name ,  t3.characteristic_data_type FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  \"cumin\"",
        "amends": [
            "Do add joins to `product_characteristics AS t2` and `CHARACTERISTICS AS t3` instead of querying only the `products` table. Do specify fully qualified column references `t3.characteristic_name` and `t3.characteristic_data_type` instead of unqualified `characteristic_name` and incorrect `data_type`. Do use double quotes around string literal `\"cumin\"` instead of single quotes. Do add join conditions `ON t1.product_id = t2.product_id` and `ON t2.characteristic_id = t3.characteristic_id` instead of missing the necessary table relationships. The amended query now correctly retrieves characteristic information through proper table joins and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about characteristics of a product: join products table as T1 with product_characteristics as T2 using T1.product_id = T2.product_id, then join with CHARACTERISTICS as T3 using T2.characteristic_id = T3.characteristic_id instead of querying only the products table. 2) When retrieving characteristic information: use fully qualified column references T3.characteristic_name and T3.characteristic_data_type instead of unqualified characteristic_name and incorrect data_type. 3) When filtering for product name \"cumin\": use double quotes around the string literal \"cumin\" instead of single quotes. 4) When combining tables for product characteristics: link rows where T1.product_id = T2.product_id and T2.characteristic_id = T3.characteristic_id to establish the necessary table relationships."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT characteristic_name, data_type FROM products WHERE product_name = 'cumin';",
            "SELECT t3.characteristic_name, t3.characteristic_data_type\nFROM Products AS t1\nJOIN Product_Characteristics AS t2 ON t1.product_id = t2.product_id\nJOIN Characteristics AS t3 ON t2.characteristic_id = t3.characteristic_id\nWHERE t1.product_name = \"cumin\""
        ],
        "rule_sql": [
            "SELECT T3.characteristic_name, T3.characteristic_data_type\nFROM Products AS T1\nJOIN Product_Characteristics AS T2 ON T1.product_id = T2.product_id\nJOIN Characteristics AS T3 ON T2.characteristic_id = T3.characteristic_id\nWHERE T1.product_name = \"cumin\""
        ]
    },
    "1763": {
        "db_id": "gymnast",
        "question": "Return the hometown that is most common among gymnasts.",
        "ground_truth": "SELECT T2.Hometown FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID GROUP BY T2.Hometown ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do join `gymnast AS T1` with `people AS T2` on `T1.Gymnast_ID = T2.People_ID` instead of querying `gymnasts` table directly without proper joins. Do select `T2.Hometown` from the joined people table instead of selecting `hometown` from a single table. Do group by `T2.Hometown` from the joined table instead of grouping by `hometown` from the original table. The amended query now correctly retrieves hometown information from the people table through proper table relationships, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"most common hometown among gymnasts\": make sure the output order: T2.Hometown\n2) When combining T1 and T2 for shared entities: link rows where T1.Gymnast_ID = T2.People_ID; keep only matching pairs (inner match).\n3) When the question asks for \"count of gymnasts\": compute the number of rows using T1.Gymnast_ID as the counting key.\n4) When the question mentions \"hometown\": \"hometown\" actually means \"T2.Hometown in schema\"\n5) When the question mentions \"most common\": rank rows by count of gymnasts in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT hometown FROM gymnasts GROUP BY hometown ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T2.Hometown\nFROM gymnast AS T1\nJOIN people AS T2 ON T1.Gymnast_ID = T2.People_ID\nGROUP BY T2.Hometown\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.Hometown\nFROM gymnast T1\nINNER JOIN people T2 ON T1.Gymnast_ID = T2.People_ID\nGROUP BY T2.Hometown\nORDER BY COUNT(T1.Gymnast_ID) DESC\nLIMIT 1"
        ]
    },
    "6999": {
        "db_id": "culture_company",
        "question": "What are all company names that have a corresponding movie directed in the year 1999?",
        "ground_truth": "SELECT T2.company_name FROM movie AS T1 JOIN culture_company AS T2 ON T1.movie_id  =  T2.movie_id WHERE T1.year  =  1999",
        "amends": [
            "Do select `T2.company_name` from the `culture_company` table instead of `company_name` from the `companies` table. Do join `movie AS T1` with `culture_company AS T2` using `ON T1.movie_id = T2.movie_id` instead of querying a single `companies` table. Do filter on `T1.year = 1999` instead of `year = 1999` to reference the correct table's year column. The amended query now correctly retrieves company names associated with movies from 1999 by properly joining the movie and culture_company tables."
        ],
        "rules": [
            "1) When answering about \"company names that have a corresponding movie directed in the year 1999\": make sure the output order: T2.company_name. 2) When the question mentions \"company names\": \"company names\" actually means \"T2.company_name in schema\". 3) When combining T1 and T2 for shared entities: link rows where T1.movie_id = T2.movie_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When filtering for movies from year 1999: use T1.year = 1999 exactly as specified in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT company_name FROM companies WHERE year = 1999;",
            "SELECT T2.Company_name FROM movie AS T1 JOIN culture_company AS T2 ON T1.movie_id = T2.movie_id WHERE T1.Year = 1999"
        ],
        "rule_sql": [
            "SELECT T2.Company_name FROM movie T1 INNER JOIN culture_company T2 ON T1.movie_id = T2.movie_id WHERE T1.Year = 1999"
        ]
    },
    "1439": {
        "db_id": "college_2",
        "question": "What is the name of the instructor who advises the student with the greatest number of total credits?",
        "ground_truth": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT 1",
        "amends": [
            "Do join through the `advisor` bridge table instead of directly joining `instructor` to `student`. Do use `advisor AS T1` with proper join conditions `T1.i_id = T2.id` and `T1.s_id = T3.id` instead of the incorrect direct join `ON i.id = s.advisor_id`. Do select `T2.name` from the instructor table instead of `i.name`. The amended query now correctly models the advisor-student relationship through the bridge table and matches the RIGHT_SQL's behavior.",
            "Do remove the `WHERE` filter comparing `T3.tot_cred` to a subquery instead of keeping it, and do add `ORDER BY T3.tot_cred DESC LIMIT 1` instead of omitting it to find the single instructor with the highest-credited student. The amended query now correctly returns only the top instructor by student credit instead of potentially multiple instructors with students at the maximum credit level."
        ],
        "rules": [
            "1) When the question asks about an instructor advising a student: use the \"advisor\" bridge table as T1 to connect instructor and student tables instead of direct joining. 2) When joining through the advisor bridge table: link T1.i_id to T2.id for instructor table and T1.s_id to T3.id for student table. 3) When selecting the instructor name: use T2.name from the instructor table rather than directly from the original instructor table. 4) When finding the student with greatest number of total credits: order by s.tot_cred in descending direction and keep only the top result.",
            "1) When answering about \"the instructor who advises the student with the greatest number of total credits\": make sure the output order: T2.name\n2) When the question mentions \"greatest number of total credits\": rank rows by T3.tot_cred in descending direction and keep the first 1 row.\n3) When combining advisor (T1) and instructor (T2) for shared entities: link rows where T1.i_ID = T2.ID exactly as shown; keep only matching pairs (inner match).\n4) When combining advisor (T1) and student (T3) for shared entities: link rows where T1.s_ID = T3.ID exactly as shown; keep only matching pairs (inner match).\n5) When the question implies ordering ties: break ties using the canonical key if shown in the amends (though not explicitly specified, use natural ordering or additional keys as needed)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT i.name FROM instructor i JOIN student s ON i.id = s.advisor_id ORDER BY s.tot_cred DESC LIMIT 1;",
            "SELECT T2.name \nFROM advisor AS T1 \nJOIN instructor AS T2 ON T1.i_ID = T2.ID \nJOIN student AS T3 ON T1.s_ID = T3.ID \nWHERE T3.tot_cred = (SELECT MAX(tot_cred) FROM student)",
            "SELECT T2.name\nFROM advisor AS T1\nJOIN instructor AS T2 ON T1.i_ID = T2.ID\nJOIN student AS T3 ON T1.s_ID = T3.ID\nORDER BY T3.tot_cred DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.name\nFROM advisor AS T1\nINNER JOIN instructor AS T2 ON T1.i_ID = T2.ID\nINNER JOIN student AS T3 ON T1.s_ID = T3.ID\nORDER BY T3.tot_cred DESC\nLIMIT 1;"
        ]
    },
    "6924": {
        "db_id": "tracking_orders",
        "question": "Which order has the most recent shipment? Give me the order id.",
        "ground_truth": "SELECT order_id FROM shipments WHERE shipment_date  =  (SELECT max(shipment_date) FROM shipments)",
        "amends": [
            "Do query the `shipments` table instead of the `orders` table. Do add a `WHERE` filter comparing `shipment_date` to a subquery instead of using `ORDER BY` with `LIMIT 1`. Do use a subquery with `max(shipment_date)` to find the most recent shipment date instead of sorting and limiting. Do remove the `ORDER BY` and `LIMIT` clauses instead of keeping them. The amended query now correctly identifies orders from the most recent shipment date in the shipments table rather than attempting to find the earliest shipment date from the orders table."
        ],
        "rules": [
            "1) When answering about \"most recent shipment\": use the \"shipments\" table instead of the \"orders\" table. 2) When finding the most recent shipment date: use max(\"shipment_date\") in a subquery instead of sorting and limiting. 3) When filtering for orders with the most recent shipment date: compare \"shipment_date\" to the maximum shipment date value from the subquery. 4) When the question asks for \"order id\": output the \"order_id\" column from the filtered results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT order_id FROM orders ORDER BY shipment_date ASC LIMIT 1;",
            "SELECT order_id FROM Shipments WHERE shipment_date = (SELECT MAX(shipment_date) FROM Shipments)"
        ],
        "rule_sql": [
            "SELECT order_id FROM Shipments WHERE shipment_date = (SELECT MAX(shipment_date) FROM Shipments)"
        ]
    },
    "2322": {
        "db_id": "perpetrator",
        "question": "Show the date of the tallest perpetrator.",
        "ground_truth": "SELECT T2.Date FROM people AS T1 JOIN perpetrator AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T1.Height DESC LIMIT 1",
        "amends": [
            "Do select `T2.Date` from the `perpetrator` table instead of selecting `date` from the `perpetrators` table. Do join `people AS T1` with `perpetrator AS T2` on `T1.People_ID = T2.People_ID` instead of querying only the `perpetrators` table. Do order by `T1.Height DESC` instead of ordering by `height DESC` from the wrong table. The amended query now correctly retrieves the date from the perpetrator table while ordering by height from the related people table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"the tallest perpetrator\": make sure the output order: T2.Date 2) When combining people and perpetrator tables: link rows where T1.People_ID = T2.People_ID and keep only matching pairs (inner match). 3) When ordering by height to find the tallest: rank rows by T1.Height in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT date FROM perpetrators ORDER BY height DESC LIMIT 1;",
            "SELECT T2.Date FROM perpetrator AS T2 JOIN people AS T1 ON T1.People_ID = T2.People_ID ORDER BY T1.Height DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Date\nFROM people T1\nINNER JOIN perpetrator T2 ON T1.People_ID = T2.People_ID\nORDER BY T1.Height DESC\nLIMIT 1"
        ]
    },
    "252": {
        "db_id": "musical",
        "question": "Show names of actors that have appeared in musical with name \"The Phantom of the Opera\".",
        "ground_truth": "SELECT T1.Name FROM actor AS T1 JOIN musical AS T2 ON T1.Musical_ID  =  T2.Musical_ID WHERE T2.Name  =  \"The Phantom of the Opera\"",
        "amends": [
            "Do select `T1.Name` from the `actor` table instead of `actor_name` from a non-existent `actors` table. Do join the `musical` table as `T2` on `T1.Musical_ID = T2.Musical_ID` instead of filtering directly on non-existent columns. Do filter with `T2.Name = \"The Phantom of the Opera\"` in the WHERE clause instead of incorrect `movie_genre = 'musical' AND movie_title = 'The Phantom of the Opera'` conditions. The amended query now correctly joins related tables and uses proper column references to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"actors that have appeared in musical with name 'The Phantom of the Opera'\": make sure the output order: T1.Name 2) When the question mentions \"actors\": \"actors\" actually means \"T1.Name in actor table\" 3) When the question mentions \"musical with name 'The Phantom of the Opera'\": filter using T2.Name = \"The Phantom of the Opera\" from the musical table 4) When combining actor and musical tables for shared entities: link rows where T1.Musical_ID = T2.Musical_ID; keep only matching pairs (inner match) 5) When handling text literals: do not change case, spacing, or punctuation - use exact literal \"The Phantom of the Opera\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT actor_name FROM actors WHERE movie_genre = 'musical' AND movie_title = 'The Phantom of the Opera';",
            "SELECT T1.Name FROM actor AS T1 JOIN musical AS T2 ON T1.Musical_ID = T2.Musical_ID WHERE T2.Name = 'The Phantom of the Opera'"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM actor T1 INNER JOIN musical T2 ON T1.Musical_ID = T2.Musical_ID WHERE T2.Name = \"The Phantom of the Opera\""
        ]
    },
    "2657": {
        "db_id": "local_govt_mdm",
        "question": "What are the distinct cross reference source system codes which are related to the master customer details 'Gottlieb, Becker and Wyman'?",
        "ground_truth": "SELECT DISTINCT T2.source_system_code FROM customer_master_index AS T1 JOIN cmi_cross_references AS T2 ON T1.master_customer_id  =  T2.master_customer_id WHERE T1.cmi_details  =  'Gottlieb ,  Becker and Wyman'",
        "amends": [
            "Do select `T2.source_system_code` from `cmi_cross_references` instead of `cross_reference_source_system_code` from `master_customer_details`. Do join `customer_master_index AS T1` with `cmi_cross_references AS T2` on `T1.master_customer_id = T2.master_customer_id` instead of querying a single table. Do filter on `T1.cmi_details = 'Gottlieb , Becker and Wyman'` instead of `customer_name = 'Gottlieb, Becker and Wyman'`. The amended query now correctly retrieves cross-reference source system codes through proper table relationships.",
            "Do use the exact string literal 'Gottlieb ,  Becker and Wyman' with comma spacing instead of 'Gottlieb, Becker and Wyman' without the space after the comma in the WHERE filter. The amended query now matches RIGHT_SQL's behavior with the corrected string comparison."
        ],
        "rules": [
            "1) When answering about distinct cross reference source system codes: select T2.source_system_code from cmi_cross_references instead of cross_reference_source_system_code from master_customer_details. 2) When combining customer_master_index and cmi_cross_references: join T1 (customer_master_index) with T2 (cmi_cross_references) on T1.master_customer_id = T2.master_customer_id using inner match. 3) When filtering for master customer details 'Gottlieb, Becker and Wyman': use T1.cmi_details = 'Gottlieb , Becker and Wyman' with exact spacing and punctuation as shown in the amends.",
            "1) When the question asks for distinct cross reference source system codes related to a specific master customer details value: select distinct T2.source_system_code from the CMI_Cross_References table (T2) joined with Customer_Master_Index table (T1) on T1.master_customer_id = T2.master_customer_id. 2) When filtering by master customer details 'Gottlieb, Becker and Wyman': use the exact string literal 'Gottlieb ,  Becker and Wyman' with the specific comma spacing (space after comma) in the WHERE condition on T1.cmi_details."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT cross_reference_source_system_code FROM master_customer_details WHERE customer_name = 'Gottlieb, Becker and Wyman';",
            "SELECT DISTINCT T2.source_system_code \nFROM Customer_Master_Index AS T1\nJOIN CMI_Cross_References AS T2 ON T1.master_customer_id = T2.master_customer_id\nWHERE T1.cmi_details = 'Gottlieb, Becker and Wyman'",
            "SELECT DISTINCT T2.source_system_code \nFROM Customer_Master_Index AS T1\nJOIN CMI_Cross_References AS T2 ON T1.master_customer_id = T2.master_customer_id\nWHERE T1.cmi_details = 'Gottlieb , Becker and Wyman'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.source_system_code\nFROM Customer_Master_Index T1\nINNER JOIN CMI_Cross_References T2 ON T1.master_customer_id = T2.master_customer_id\nWHERE T1.cmi_details = 'Gottlieb , Becker and Wyman'"
        ]
    },
    "2112": {
        "db_id": "cre_Doc_Control_Systems",
        "question": "How many documents have the status code done?",
        "ground_truth": "SELECT count(*) FROM Documents WHERE document_status_code = \"done\";",
        "amends": [
            "Do reference the `Documents` table instead of `documents` to match the correct table name. Do filter on `document_status_code` instead of `status` to use the correct column name for document status. Do use double quotes around the literal value \"done\" instead of single quotes to match the correct string literal format. The amended query now correctly counts documents with the specified status code, matching the behavior of the right SQL."
        ],
        "rules": [
            "1) When answering about \"documents with status code done\": use the exact table name \"Documents\" instead of \"documents\". 2) When filtering documents by status: use the exact column name \"document_status_code\" instead of \"status\". 3) When comparing document status codes: use the exact string literal \"done\" with double quotes instead of single quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM documents WHERE status = 'done';",
            "SELECT COUNT(*) FROM Documents WHERE document_status_code = \"done\";"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Documents WHERE document_status_code = \"done\";"
        ]
    },
    "5573": {
        "db_id": "products_gen_characteristics",
        "question": "What are the different product names for products that have the 'warm' characteristic:?",
        "ground_truth": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t3.characteristic_name  =  \"warm\"",
        "amends": [
            "Do use `DISTINCT t1.product_name` instead of just `product_name` to eliminate duplicates. Do add joins to `product_characteristics AS t2` and `CHARACTERISTICS AS t3` instead of querying only the `products` table. Do use the join condition `t1.product_id = t2.product_id` and `t2.characteristic_id = t3.characteristic_id` instead of no joins. Do filter on `t3.characteristic_name = \"warm\"` instead of `characteristic = 'warm'` to properly reference the characteristic name from the joined table. The amended query now correctly joins through the relationship tables to find products with the specified characteristic, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"different product names\": use DISTINCT on the exact token \"t1.product_name\" to eliminate duplicate values. 2) When combining tables for product characteristics: link rows where \"t1.product_id = t2.product_id\" and \"t2.characteristic_id = t3.characteristic_id\" using inner matches. 3) When filtering for the 'warm' characteristic: use the exact literal \"warm\" with the exact token \"t3.characteristic_name\" to match the characteristic name from the joined table. 4) When answering about products with specific characteristics: make sure the output order includes only \"t1.product_name\" as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT product_name FROM products WHERE characteristic = 'warm';",
            "SELECT DISTINCT t1.product_name\nFROM Products AS t1\nJOIN Product_Characteristics AS t2 ON t1.product_id = t2.product_id\nJOIN Characteristics AS t3 ON t2.characteristic_id = t3.characteristic_id\nWHERE t3.characteristic_name = 'warm'"
        ],
        "rule_sql": [
            "SELECT DISTINCT t1.product_name\nFROM Products t1\nINNER JOIN Product_Characteristics t2 ON t1.product_id = t2.product_id\nINNER JOIN Characteristics t3 ON t2.characteristic_id = t3.characteristic_id\nWHERE t3.characteristic_name = 'warm'"
        ]
    },
    "4937": {
        "db_id": "store_product",
        "question": "What is the most common maximum page size?",
        "ground_truth": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference table `product` instead of `books` and column `max_page_size` instead of `page_size` in the SELECT list and GROUP BY clause. Do use aggregate function `count(*)` instead of `COUNT(*)` in the ORDER BY clause while maintaining the same descending sort order and LIMIT 1 constraint. The amended query now correctly retrieves the maximum page size from the product table grouped by page size values and ordered by frequency count.",
            "Do remove the `COUNT(*) as frequency` column from the SELECT list instead of including it, as the query only needs to return the max_page_size value with the highest frequency. Do keep the `GROUP BY max_page_size` and `ORDER BY count(*) DESC LIMIT 1` structure unchanged, which correctly identifies the most frequent max_page_size value by counting occurrences and selecting the top result. The amended query now matches the intended behavior of returning only the max_page_size with the highest occurrence count."
        ],
        "rules": [
            "1) When answering about \"most common maximum page size\": make sure the output order: the most frequent max_page_size value. 2) When the question mentions \"maximum page size\": \"maximum page size\" actually means \"max_page_size in schema\". 3) When the question asks for \"most common\": rank rows by frequency count of max_page_size values in descending order and keep the first 1 row. 4) When counting frequency of max_page_size values: compute the number of rows using count(*) for each max_page_size group. 5) When grouping by max_page_size: organize results by the exact token \"max_page_size\" and compute requested aggregates per group.",
            "1) When answering about \"most common maximum page size\": make sure the output order: only return the max_page_size value with the highest frequency. 2) When counting occurrences of max_page_size values: count using the canonical key for the entity being grouped (max_page_size). 3) When the question mentions \"most common\": rank rows by count of max_page_size in descending order and keep the first 1 row. 4) When producing output: do not include the frequency count column in the final results, only return the max_page_size value itself."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(page_size) FROM books GROUP BY page_size ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT max_page_size, COUNT(*) as frequency FROM product GROUP BY max_page_size ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "6945": {
        "db_id": "architecture",
        "question": "How many architects are female?",
        "ground_truth": "SELECT count(*) FROM architect WHERE gender  =  'female'",
        "amends": [
            "Do reference table `architect` instead of `architects` and filter for `gender = 'female'` instead of `gender = 'male'`."
        ],
        "rules": [
            "1) When answering about \"how many architects are female\": use the table name \"architect\" exactly as specified in the schema, not \"architects\". 2) When filtering for gender: use the exact literal value 'female' (not 'male') for the gender condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM architects WHERE gender = 'male';",
            "SELECT COUNT(*) FROM architect WHERE gender = 'female';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM architect WHERE gender = 'female'"
        ]
    },
    "5403": {
        "db_id": "shop_membership",
        "question": "What are the names, address roads, and cities of the branches ordered by opening year?",
        "ground_truth": "SELECT name ,  address_road ,  city FROM branch ORDER BY open_year",
        "amends": [
            "Do reference table `branch` instead of `branches` in the FROM clause. Do order by `open_year` instead of `name` in the ORDER BY clause. The amended query now correctly references the intended table and sorts results by the opening year rather than branch name."
        ],
        "rules": [
            "1) When the question asks about branches: use table \"branch\" instead of \"branches\" as the data source. 2) When ordering results by opening year: use column \"open_year\" for sorting instead of \"name\". 3) When selecting branch information: include columns \"name\", \"address_road\", and \"city\" in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, address_road, city FROM branches ORDER BY name;",
            "SELECT Name, Address_road, City FROM branch ORDER BY Open_year;"
        ],
        "rule_sql": [
            "SELECT name, address_road, city FROM branch ORDER BY open_year;"
        ]
    },
    "5362": {
        "db_id": "tracking_software_problems",
        "question": "List the problem id and log id which are assigned to the staff named Rylan Homenick.",
        "ground_truth": "SELECT DISTINCT T2.problem_id ,  T2.problem_log_id FROM staff AS T1 JOIN problem_log AS T2 ON T1.staff_id = T2.assigned_to_staff_id WHERE T1.staff_first_name = \"Rylan\" AND T1.staff_last_name = \"Homenick\"",
        "amends": [
            "Do select `T2.problem_id` and `T2.problem_log_id` instead of `problem_id` and `log_id`. Do use `DISTINCT` instead of omitting it. Do join `staff AS T1` and `problem_log AS T2` on `T1.staff_id = T2.assigned_to_staff_id` instead of querying only `staff_assignments`. Do filter with `T1.staff_first_name = \"Rylan\" AND T1.staff_last_name = \"Homenick\"` instead of `staff_name = 'Rylan Homenick'`. The amended query now correctly joins staff and problem_log tables to find problem assignments for the specified staff member."
        ],
        "rules": [
            "1) When the question asks for \"problem id\" and \"log id\": select \"T2.problem_id\" and \"T2.problem_log_id\" as the exact output columns. 2) When joining tables to find staff assignments: combine \"staff AS T1\" and \"problem_log AS T2\" by matching rows where \"T1.staff_id = T2.assigned_to_staff_id\" and keep only matching pairs (inner match). 3) When filtering for staff named Rylan Homenick: use the exact condition \"T1.staff_first_name = 'Rylan' AND T1.staff_last_name = 'Homenick'\" with the literal values 'Rylan' and 'Homenick'. 4) When selecting from multiple joined tables: use DISTINCT to return only unique combinations of the selected columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT problem_id, log_id FROM staff_assignments WHERE staff_name = 'Rylan Homenick';",
            "SELECT DISTINCT T2.problem_id, T2.problem_log_id\nFROM staff AS T1\nJOIN problem_log AS T2 ON T1.staff_id = T2.assigned_to_staff_id\nWHERE T1.staff_first_name = 'Rylan' AND T1.staff_last_name = 'Homenick'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.problem_id, T2.problem_log_id\nFROM staff AS T1\nINNER JOIN problem_log AS T2 ON T1.staff_id = T2.assigned_to_staff_id\nWHERE T1.staff_first_name = 'Rylan' AND T1.staff_last_name = 'Homenick'"
        ]
    },
    "5253": {
        "db_id": "music_2",
        "question": "What are the different names of all songs without back vocals?",
        "ground_truth": "SELECT DISTINCT title FROM vocals AS t1 JOIN songs AS t2 ON t1.songid  =  t2.songid EXCEPT SELECT t2.title FROM vocals AS t1 JOIN songs AS t2 ON t1.songid  =  t2.songid WHERE TYPE  =  \"back\"",
        "amends": [
            "Do use `SELECT DISTINCT title` instead of `SELECT name` to return unique song titles rather than names. Do join `vocals AS t1` with `songs AS t2` on `t1.songid = t2.songid` instead of querying `songs` alone without any joins. Do add an `EXCEPT` clause to exclude songs with back vocals instead of using a simple `WHERE back_vocals = 'no'` filter. Do include a subquery `SELECT t2.title FROM vocals AS t1 JOIN songs AS t2 ON t1.songid = t2.songid WHERE TYPE = \"back\"` to specifically identify songs with back vocals for exclusion, instead of relying on a direct column filter. The amended query now correctly identifies songs without any back vocal contributions by using set operations rather than simple filtering."
        ],
        "rules": [
            "1) When answering about \"different names of all songs without back vocals\": make sure the output order: title. 2) When the question asks for \"different names\": return unique song titles using SELECT DISTINCT title. 3) When identifying songs without back vocals: use an EXCEPT clause to exclude songs that have back vocals instead of a simple WHERE filter. 4) When combining vocals and songs tables: link rows where t1.songid = t2.songid and keep only matching pairs (inner match). 5) When identifying songs with back vocals: use a subquery that selects t2.title from vocals AS t1 JOIN songs AS t2 ON t1.songid = t2.songid WHERE TYPE = \"back\" exactly as specified. 6) When handling text literals: use \"back\" exactly as shown with double quotes and lowercase spelling."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM songs WHERE back_vocals = 'no';",
            "SELECT DISTINCT Title\nFROM Songs\nEXCEPT\nSELECT t2.Title\nFROM Vocals AS t1\nJOIN Songs AS t2 ON t1.SongId = t2.SongId\nWHERE t1.Type = 'back'"
        ],
        "rule_sql": [
            "SELECT DISTINCT Title\nFROM Songs\nEXCEPT\nSELECT t2.Title\nFROM Vocals AS t1\nJOIN Songs AS t2 ON t1.SongId = t2.SongId\nWHERE t1.Type = \"back\""
        ]
    },
    "395": {
        "db_id": "flight_1",
        "question": "Show origin and destination for flights with price higher than 300.",
        "ground_truth": "SELECT origin ,  destination FROM Flight WHERE price  >  300",
        "amends": [
            "Do reference table `Flight` instead of `flights` in the FROM clause. Do use filter `price > 300` instead of `price < 300` in the WHERE clause, changing the comparison operator from less than to greater than. The amended query now correctly selects origin and destination from the Flight table where prices exceed 300 instead of being below 300, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"flights\": use the exact table name \"Flight\" with double quotes as shown in the schema. 2) When filtering for flights with price higher than 300: use the condition \"price > 300\" with the exact column name \"price\" and literal value 300. 3) When selecting origin and destination: output the columns \"origin\" and \"destination\" in that order from the \"Flight\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT origin, destination FROM flights WHERE price < 300;",
            "SELECT origin, destination FROM flight WHERE price > 300;"
        ],
        "rule_sql": [
            "SELECT \"origin\", \"destination\" FROM \"Flight\" WHERE \"price\" > 300"
        ]
    },
    "4325": {
        "db_id": "tracking_grants_for_research",
        "question": "What is the total amount of grant money for research?",
        "ground_truth": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'",
        "amends": [
            "Do reference `grant_amount` instead of `amount` in the SELECT list. Do add joins to `Organisations` and `organisation_Types` tables instead of querying only the `grants` table. Do use `JOIN` conditions on `organisation_id` and `organisation_type` instead of having no joins. Do filter on `organisation_type_description = 'Research'` instead of `type = 'education'`. Do remove the incorrect table alias `Grants AS T1` and use proper table references throughout. The amended query now correctly calculates the sum of grant amounts for research organizations instead of education grants."
        ],
        "rules": [
            "1) When answering about \"total amount of grant money for research\": make sure the output order: SUM(\"grant_amount\") 2) When the question mentions \"grant money\": \"grant money\" actually means \"grant_amount in schema\" 3) When the question mentions \"research\": \"research\" actually means \"organisation_type_description = 'Research' in schema\" 4) When combining Grants, Organisations, and Organisation_Types tables: link rows where Grants.organisation_id = Organisations.organisation_id and Organisations.organisation_type = Organisation_Types.organisation_type; keep only matching pairs (inner match) 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for column names like \"grant_amount\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(amount) FROM grants WHERE type = 'education';",
            "SELECT SUM(g.grant_amount) AS total_grant_money\nFROM Grants g\nJOIN Organisations o ON g.organisation_id = o.organisation_id\nJOIN Organisation_Types ot ON o.organisation_type = ot.organisation_type\nWHERE ot.organisation_type_description = 'Research';"
        ],
        "rule_sql": [
            "SELECT SUM(grant_amount) \nFROM Grants g\nJOIN Organisations o ON g.organisation_id = o.organisation_id\nJOIN Organisation_Types ot ON o.organisation_type = ot.organisation_type\nWHERE ot.organisation_type_description = 'Research'"
        ]
    },
    "4332": {
        "db_id": "tracking_grants_for_research",
        "question": "Which organisation type hires most research staff?",
        "ground_truth": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `Organisations` and `Research_Staff` tables on `organisation_id = employer_organisation_id` instead of querying only the `staff` table with a filter. Do select only `organisation_type` instead of including both `organisation_type` and `COUNT(*)`. Do use `JOIN` with explicit table aliases `T1` and `T2` instead of querying a single table. Do group by `T1.organisation_type` instead of `organisation_type` from a single table. Do order by `count(*)` descending instead of ordering by the alias `research_staff_count`. Do remove the explicit column alias `research_staff_count` instead of keeping it. The amended query now correctly counts research staff by joining the appropriate tables and matches the RIGHT_SQL's behavior.",
            "Do select only `organisation_type` instead of including `COUNT(*)` in the SELECT list. Do use `AS` for table aliases instead of omitting them. Do maintain the same join condition `T1.organisation_id = T2.employer_organisation_id` without change. Do keep the same `GROUP BY organisation_type` and `ORDER BY count(*) DESC LIMIT 1` structure. The amended query now correctly returns only the organisation type with the highest count instead of returning both the type and count value, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"which organisation type hires most research staff\": make sure the output order: organisation_type only. 2) When combining Organisations and Research_Staff tables: link rows where T1.organisation_id = T2.employer_organisation_id and keep only matching pairs (inner match). 3) When counting research staff: compute the number of rows using the canonical key from Research_Staff table. 4) When grouping by organisation type: organize results by T1.organisation_type and compute count per group. 5) When ranking organisation types by research staff count: rank rows by count in descending order and keep the first 1 row. 6) When handling text literals: do not change case, spacing, or punctuation for any values. 7) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for any table or column names.",
            "1) When answering about \"which organisation type hires most research staff\": make sure the output order: organisation_type only without count values. 2) When the question asks for \"most research staff\": rank organisation types by count of research staff in descending order and keep only the first 1 row. 3) When counting research staff: compute the number of rows using the join condition T1.organisation_id = T2.employer_organisation_id. 4) When grouping by organisation type: organize results by T1.organisation_type and compute the count per group. 5) When combining Organisations and Research_Staff tables: link rows where T1.organisation_id = T2.employer_organisation_id exactly as shown; keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT organisation_type, COUNT(*) as research_staff_count \nFROM staff \nWHERE job_title = 'Research Staff' \nGROUP BY organisation_type \nORDER BY research_staff_count DESC \nLIMIT 1;",
            "SELECT T1.organisation_type, COUNT(*) \nFROM Organisations T1 \nJOIN Research_Staff T2 ON T1.organisation_id = T2.employer_organisation_id \nGROUP BY T1.organisation_type \nORDER BY COUNT(*) DESC \nLIMIT 1",
            "SELECT T1.organisation_type\nFROM Organisations AS T1\nJOIN Research_Staff AS T2 ON T1.organisation_id = T2.employer_organisation_id\nGROUP BY T1.organisation_type\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT o.organisation_type\nFROM Organisations o\nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id\nGROUP BY o.organisation_type\nORDER BY COUNT(rs.staff_id) DESC\nLIMIT 1;"
        ]
    },
    "6884": {
        "db_id": "flight_4",
        "question": "What is the name of the airport that is the destination of the most number of routes that start in China?",
        "ground_truth": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use `T1.name` in the SELECT list instead of `a.name` and reference `T1.name` in GROUP BY instead of `a.airport_id`. Do join on `T1.apid = T2.dst_apid` instead of `a.airport_id = r.source_airport_id` to connect airports to destination routes rather than source routes. Do use table aliases `T1` and `T2` instead of `a` and `r` for consistency. The amended query now correctly finds Chinese airports with the most outgoing routes as destinations rather than as sources, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"the airport that is the destination of the most number of routes that start in China\": make sure the output order: T1.name. 2) When the question mentions \"destination of routes\": join T1 and T2 where T1.apid = T2.dst_apid to connect airports to destination routes. 3) When the question mentions \"routes that start in China\": filter routes where the source airport is in China by checking T2.src_country = 'China'. 4) When the question asks for \"the most number of routes\": count the number of routes per destination airport using T2.route_id or equivalent route identifier, then order by count descending and keep the top 1 result. 5) When grouping by destination airport: organize results by T1.apid and compute the count of routes per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.name \nFROM airports a \nJOIN routes r ON a.airport_id = r.source_airport_id \nWHERE a.country = 'China' \nGROUP BY a.airport_id \nORDER BY COUNT(*) DESC \nLIMIT 1;",
            "SELECT T1.name\nFROM airports T1\nJOIN routes T2 ON T1.apid = T2.dst_apid\nJOIN airports T3 ON T2.src_apid = T3.apid\nWHERE T3.country = 'China'\nGROUP BY T1.name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT a.name\nFROM airports a\nJOIN routes r ON a.apid = r.dst_apid\nJOIN airports src_airport ON r.src_apid = src_airport.apid\nWHERE src_airport.country = 'China'\nGROUP BY a.apid, a.name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "4567": {
        "db_id": "company_office",
        "question": "Please show the names of the buildings whose status is \"on-hold\", in ascending order of stories.",
        "ground_truth": "SELECT name FROM buildings WHERE Status  =  \"on-hold\" ORDER BY Stories ASC",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM buildings WHERE status = 'on-hold' ORDER BY stories DESC;"
        ],
        "rule_sql": [
            "SELECT name FROM buildings WHERE Status = 'on-hold' ORDER BY Stories ASC;"
        ]
    },
    "4727": {
        "db_id": "department_store",
        "question": "How many department stores does the store chain South have?",
        "ground_truth": "SELECT count(*) FROM department_stores AS T1 JOIN department_store_chain AS T2 ON T1.dept_store_chain_id  =  T2.dept_store_chain_id WHERE T2.dept_store_chain_name  =  \"South\"",
        "amends": [
            "Do join `department_stores` and `department_store_chain` tables instead of querying only the `stores` table. Do use `JOIN` with `T1.dept_store_chain_id = T2.dept_store_chain_id` instead of filtering directly on chain name. Do filter on `T2.dept_store_chain_name = \"South\"` instead of `chain = 'South'`. Do remove the `type = 'grocery'` filter instead of keeping it. The amended query now correctly counts department stores by joining to resolve chain names through the proper foreign key relationship."
        ],
        "rules": [
            "1) When answering about department stores for chain South: join department_stores as T1 and department_store_chain as T2 using T1.dept_store_chain_id = T2.dept_store_chain_id instead of querying a single stores table. 2) When filtering for chain name South: use T2.dept_store_chain_name = \"South\" instead of filtering directly on chain name in a single table. 3) When counting department stores: count using the canonical key from T1 (department stores table) instead of counting all rows. 4) When the question asks about department stores: do not include grocery store filters like type = 'grocery'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM stores WHERE chain = 'South' AND type = 'grocery';",
            "SELECT COUNT(*) \nFROM Department_Stores ds\nJOIN Department_Store_Chain dsc ON ds.dept_store_chain_id = dsc.dept_store_chain_id\nWHERE dsc.dept_store_chain_name = 'South'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Department_Stores AS T1\nJOIN Department_Store_Chain AS T2 ON T1.dept_store_chain_id = T2.dept_store_chain_id\nWHERE T2.dept_store_chain_name = 'South'"
        ]
    },
    "5906": {
        "db_id": "cre_Theme_park",
        "question": "Count the number of distinct names associated with the photos.",
        "ground_truth": "SELECT count(DISTINCT Name) FROM PHOTOS",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM photos;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Name) FROM Photos;"
        ]
    },
    "338": {
        "db_id": "product_catalog",
        "question": "On which days more than one revisions were made on catalogs.",
        "ground_truth": "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  1",
        "amends": [
            "Do reference the correct column name `date_of_latest_revision` instead of the incorrect `date` in both the SELECT list and GROUP BY clause. Do use the proper table name `Catalogs` with correct capitalization instead of `catalogs`. The amended query now correctly identifies duplicate date_of_latest_revision values in the Catalogs table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"days\" and \"revisions were made on catalogs\": use the exact column name \"date_of_latest_revision\" from table \"Catalogs\" instead of \"date\". 2) When counting revisions per day: group by \"date_of_latest_revision\" and count occurrences where the count is greater than 1. 3) When referring to the catalogs table: use the exact table name \"Catalogs\" with proper capitalization instead of \"catalogs\". 4) When outputting results: include only the \"date_of_latest_revision\" column in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT date FROM catalogs GROUP BY date HAVING COUNT(*) > 1",
            "SELECT date_of_latest_revision\nFROM Catalogs\nGROUP BY date_of_latest_revision\nHAVING COUNT(*) > 1;"
        ],
        "rule_sql": [
            "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING COUNT(*) > 1;"
        ]
    },
    "2881": {
        "db_id": "icfp_1",
        "question": "What are the first and last name of the author who published the paper titled \"Nameless, Painless\"?",
        "ground_truth": "SELECT t1.fname ,  t1.lname FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid WHERE t3.title  =  \"Nameless ,  Painless\"",
        "amends": [
            "Do select `t1.fname` and `t1.lname` instead of `first_name` and `last_name`. Do add `authorship AS t2` and `papers AS t3` tables instead of querying only the `authors` table. Do use `INNER JOIN` on `t1.authid = t2.authid` and `t2.paperid = t3.paperid` instead of no joins. Do filter on `t3.title = \"Nameless , Painless\"` instead of `paper_title = 'Nameless, Painless'` to properly reference the papers table. The amended query now correctly joins through the authorship relationship to filter papers by title and returns the corresponding author names.",
            "Do use implicit `JOIN` syntax instead of explicit `INNER JOIN` keywords. Do use lowercase table names `authors` and `authorship` instead of capitalized `Authors` and `Authorship`. Do use lowercase column names `authid` and `paperid` instead of mixed case `authID` and `paperID`. Do add spaces around the equals sign in join conditions instead of omitting them. Do use a comma in the string literal \"Nameless , Painless\" instead of \"Nameless, Painless\" without spaces around the comma. The amended query now matches the right SQL's behavior with identical logic and output."
        ],
        "rules": [
            "1) When the question asks for author names: use \"t1.fname\" and \"t1.lname\" instead of \"first_name\" and \"last_name\". 2) When finding authors of a specific paper: join through \"authorship AS t2\" and \"papers AS t3\" tables instead of querying only the \"authors\" table. 3) When combining tables: link rows where \"t1.authid = t2.authid\" and \"t2.paperid = t3.paperid\" using inner joins. 4) When filtering by paper title: use \"t3.title = \"Nameless , Painless\"\" with exact spacing and punctuation as shown in the schema.",
            "1) When joining tables authors and authorship: link rows where authors.authid equals authorship.authid exactly as shown in the schema foreign key relationship. 2) When joining tables authorship and papers: link rows where authorship.paperid equals papers.paperid exactly as shown in the schema foreign key relationship. 3) When filtering for the paper title \"Nameless , Painless\": use the exact string literal with spaces around the comma as specified in the amends. 4) When selecting author names from table authors: use the lowercase column names fname and lname as shown in the original query structure. 5) When using table aliases: maintain the original alias pattern where authors is t1, authorship is t2, and papers is t3 for consistency with the query structure."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM authors WHERE paper_title = 'Nameless, Painless'",
            "SELECT t1.fname, t1.lname\nFROM Authors AS t1\nINNER JOIN Authorship AS t2 ON t1.authID = t2.authID\nINNER JOIN Papers AS t3 ON t2.paperID = t3.paperID\nWHERE t3.title = \"Nameless, Painless\"",
            "SELECT t1.fname, t1.lname\nFROM authors AS t1, authorship AS t2, papers AS t3\nWHERE t1.authid = t2.authid\nAND t2.paperid = t3.paperid\nAND t3.title = \"Nameless , Painless\""
        ],
        "rule_sql": [
            "SELECT t1.fname, t1.lname FROM Authors AS t1 INNER JOIN Authorship AS t2 ON t1.authID = t2.authID INNER JOIN Papers AS t3 ON t2.paperID = t3.paperID WHERE t3.title = \"Nameless , Painless\""
        ]
    },
    "2743": {
        "db_id": "election",
        "question": "What are the distinct districts for elections?",
        "ground_truth": "SELECT DISTINCT District FROM election",
        "amends": [
            "Do use the correct table name `election` instead of the incorrect `elections` and maintain the proper column name `District` with correct capitalization instead of the lowercase `district`. The amended query now matches RIGHT_SQL's behavior by correctly referencing the intended table and column."
        ],
        "rules": [
            "1) When the question asks for \"distinct districts\": use the exact column name \"District\" from table \"election\" with proper capitalization. 2) When referring to the table containing district information: use the exact table name \"election\" instead of plural forms like \"elections\". 3) When selecting distinct values from the District column: ensure the output maintains the exact column name \"District\" with proper capitalization."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT district FROM elections;",
            "SELECT DISTINCT District FROM election;"
        ],
        "rule_sql": [
            "SELECT DISTINCT District FROM election;"
        ]
    },
    "2029": {
        "db_id": "gas_company",
        "question": "Show all locations where a gas station for company with market value greater than 100 is located.",
        "ground_truth": "SELECT T3.location FROM station_company AS T1 JOIN company AS T2 ON T1.company_id  =  T2.company_id JOIN gas_station AS T3 ON T1.station_id  =  T3.station_id WHERE T2.market_value  >  100",
        "amends": [
            "Do select only `T3.location` instead of all columns with `*`. Do join `station_company AS T1` to `company AS T2` on `T1.company_id = T2.company_id` instead of querying `gas_stations` directly. Do add a second join to `gas_station AS T3` on `T1.station_id = T3.station_id` instead of missing this relationship. Do filter on `T2.market_value > 100` instead of using the non-existent `company_market_value` column. The amended query now correctly retrieves gas station locations for companies with market value over 100 by properly navigating the relational schema."
        ],
        "rules": [
            "1) When answering about \"locations where a gas station for company with market value greater than 100 is located\": make sure the output order: T3.location 2) When combining station_company as T1 and company as T2: link rows where T1.company_id = T2.company_id and keep only matching pairs (inner match). 3) When combining T1 and gas_station as T3: link rows where T1.station_id = T3.station_id and keep only matching pairs (inner match). 4) When filtering for companies with market value greater than 100: apply the condition T2.market_value > 100 instead of using non-existent columns like company_market_value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM gas_stations WHERE company_market_value > 100;",
            "SELECT T3.Location \nFROM station_company AS T1\nJOIN company AS T2 ON T1.Company_ID = T2.Company_ID\nJOIN gas_station AS T3 ON T1.Station_ID = T3.Station_ID\nWHERE T2.Market_Value > 100"
        ],
        "rule_sql": [
            "SELECT DISTINCT T3.Location \nFROM station_company AS T1\nINNER JOIN company AS T2 ON T1.Company_ID = T2.Company_ID\nINNER JOIN gas_station AS T3 ON T1.Station_ID = T3.Station_ID\nWHERE T2.Market_Value > 100\nORDER BY T3.Location"
        ]
    },
    "6736": {
        "db_id": "activity_1",
        "question": "How many faculty members does each building have? List the result with the name of the building.",
        "ground_truth": "SELECT building ,  count(*) FROM Faculty GROUP BY building",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT building, COUNT(*) as faculty_count FROM faculty GROUP BY building;"
        ],
        "rule_sql": [
            "SELECT Building, COUNT(*) AS faculty_count FROM Faculty GROUP BY Building;"
        ]
    },
    "2986": {
        "db_id": "sakila_1",
        "question": "How many items in inventory does store 1 have?",
        "ground_truth": "SELECT count(*) FROM inventory WHERE store_id  =  1",
        "amends": [
            "Do filter on `store_id = 1` instead of `store_id = 2` in the WHERE clause, changing the store identifier from 2 to 1 to query the correct inventory location. The amended query now matches RIGHT_SQL's behavior by counting inventory records for store 1 rather than store 2."
        ],
        "rules": [
            "1) When the question asks for inventory count for a specific store: filter inventory records using the exact store identifier value mentioned in the question (store 1). 2) When counting items in inventory: count all rows in the inventory table that match the specified store filter condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM inventory WHERE store_id = 2;",
            "SELECT COUNT(*) FROM inventory WHERE store_id = 1;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM inventory WHERE store_id = 1;"
        ]
    },
    "6909": {
        "db_id": "tracking_orders",
        "question": "Find the names of the customers who have order status both \"On Road\" and \"Shipped\".",
        "ground_truth": "SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T2.order_status = \"On Road\" INTERSECT SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T2.order_status = \"Shipped\"",
        "amends": [
            "Do use `customer_name` instead of `name` in the SELECT list. Do change the table alias from `c` to `T1` and `o` to `T2` instead of the original aliases. Do use `order_status` instead of `status` for the column reference. Do replace the `OR` condition with an `INTERSECT` operation between two separate queries instead of combining conditions with OR. Do remove `DISTINCT` since INTERSECT inherently returns distinct results instead of keeping it. Do use double quotes around string literals instead of single quotes. The amended query now correctly uses INTERSECT to find customers who have both 'On Road' and 'Shipped' orders, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for customer names: use \"customer_name\" from table T1 instead of \"name\". 2) When combining tables Customers and Orders: use table aliases T1 for Customers and T2 for Orders. 3) When referring to order status: use column \"order_status\" from table T2 instead of \"status\". 4) When finding customers with both \"On Road\" and \"Shipped\" statuses: use INTERSECT operation between separate queries for each status instead of OR condition. 5) When using string literals: use double quotes around \"On Road\" and \"Shipped\" instead of single quotes. 6) When the operation inherently returns distinct results: do not use DISTINCT keyword."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT c.name \nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nWHERE o.status = 'On Road' OR o.status = 'Shipped'",
            "SELECT T1.customer_name\nFROM Customers T1\nJOIN Orders T2 ON T1.customer_id = T2.customer_id\nWHERE T2.order_status = \"On Road\"\nINTERSECT\nSELECT T1.customer_name\nFROM Customers T1\nJOIN Orders T2 ON T1.customer_id = T2.customer_id\nWHERE T2.order_status = \"Shipped\""
        ],
        "rule_sql": [
            "SELECT T1.customer_name\nFROM Customers T1\nJOIN Orders T2 ON T1.customer_id = T2.customer_id\nWHERE T2.order_status = \"On Road\"\nINTERSECT\nSELECT T1.customer_name\nFROM Customers T1\nJOIN Orders T2 ON T1.customer_id = T2.customer_id\nWHERE T2.order_status = \"Shipped\""
        ]
    },
    "3506": {
        "db_id": "hr_1",
        "question": "What are the ids, full names, and salaries for employees making more than average and who work in a department with employees who have the letter J in their first name?",
        "ground_truth": "SELECT employee_id ,  first_name ,  last_name ,  salary FROM employees WHERE salary  >  ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%J%')",
        "amends": [
            "Do select individual columns `employee_id`, `first_name`, `last_name`, `salary` instead of concatenating `first_name || ' ' || last_name AS full_name`. Do remove the alias `full_name` instead of keeping it. The amended query now matches RIGHT_SQL's behavior by returning separate name columns rather than a concatenated full name."
        ],
        "rules": [
            "1) When the question asks for \"full names\": return the individual columns \"first_name\" and \"last_name\" separately instead of concatenating them with a space. 2) When the question asks for employee information: do not use any alias like \"full_name\" for concatenated name fields. 3) When selecting output columns: maintain the exact order of \"employee_id\", \"first_name\", \"last_name\", \"salary\" as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT employee_id, first_name || ' ' || last_name AS full_name, salary\nFROM employees\nWHERE salary > (SELECT AVG(salary) FROM employees)\nAND department_id IN (\n    SELECT department_id \n    FROM employees \n    WHERE first_name LIKE '%J%'\n);",
            "SELECT e.EMPLOYEE_ID, e.FIRST_NAME, e.LAST_NAME, e.SALARY\nFROM employees e\nWHERE e.SALARY > (SELECT AVG(SALARY) FROM employees)\nAND e.DEPARTMENT_ID IN (\n    SELECT DISTINCT DEPARTMENT_ID \n    FROM employees \n    WHERE FIRST_NAME LIKE '%J%'\n)"
        ],
        "rule_sql": [
            "SELECT e.EMPLOYEE_ID, e.FIRST_NAME, e.LAST_NAME, e.SALARY\nFROM employees e\nWHERE e.SALARY > (SELECT AVG(SALARY) FROM employees)\nAND e.DEPARTMENT_ID IN (\n    SELECT DISTINCT DEPARTMENT_ID \n    FROM employees \n    WHERE FIRST_NAME LIKE '%J%'\n)"
        ]
    },
    "4": {
        "db_id": "department_management",
        "question": "What is the average number of employees of the departments whose rank is between 10 and 15?",
        "ground_truth": "SELECT avg(num_employees) FROM department WHERE ranking BETWEEN 10 AND 15",
        "amends": [
            "Do reference the `num_employees` column instead of `employee_count` and use the `department` table instead of `departments`. Do filter on the `ranking` column instead of `rank` while maintaining the same BETWEEN 10 AND 15 predicate. The amended query now correctly calculates the average number of employees from the department table for records with ranking values between 10 and 15, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"average number of employees\": use the exact column token \"num_employees\" from the department table. 2) When filtering by rank between 10 and 15: use the exact column token \"ranking\" with the inclusive range 10 to 15. 3) When referencing the department entity: use the exact table name \"department\" (not \"departments\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(employee_count) FROM departments WHERE rank BETWEEN 10 AND 15;",
            "SELECT AVG(Num_Employees) FROM department WHERE Ranking BETWEEN 10 AND 15"
        ],
        "rule_sql": [
            "SELECT AVG(Num_Employees) FROM department WHERE Ranking BETWEEN 10 AND 15;"
        ]
    },
    "5114": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "What is the phone number of the performer Ashley?",
        "ground_truth": "SELECT Customer_Phone FROM PERFORMERS WHERE Customer_Name  =  \"Ashley\"",
        "amends": [
            "Do reference the column as `Customer_Phone` instead of `phone` and use the table alias `PERFORMERS` instead of `performers`. Do use the filter condition `Customer_Name = \"Ashley\"` instead of `name = 'Ashley'` with proper column naming and quotation style. The amended query now correctly matches the RIGHT_SQL's behavior by using the appropriate column names and table reference."
        ],
        "rules": [
            "1) When the question asks for \"phone number\": use the exact column token \"Customer_Phone\" from the Customers table. 2) When the question mentions \"performer Ashley\": use the exact filter condition Customer_Name = \"Ashley\" with double quotes around the literal value. 3) When referring to the performers table: use the exact table alias \"PERFORMERS\" as specified in the schema. 4) When selecting output columns: ensure the output order matches the question's request for phone number information."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT phone FROM performers WHERE name = 'Ashley';",
            "SELECT Customer_Phone FROM Performers WHERE Customer_Name = 'Ashley';"
        ],
        "rule_sql": [
            "SELECT Customer_Phone FROM Performers WHERE Customer_Name = \"Ashley\""
        ]
    },
    "6509": {
        "db_id": "scientist_1",
        "question": "Find the number of scientists who are not assigned to any project.",
        "ground_truth": "SELECT count(*) FROM scientists WHERE ssn NOT IN (SELECT scientist FROM AssignedTo)",
        "amends": [
            "Do filter with `WHERE ssn NOT IN (SELECT scientist FROM AssignedTo)` instead of `WHERE project_id IS NULL`. Do change the aggregate function to `count(*)` instead of `COUNT(*)` (though this is purely cosmetic). The amended query now correctly identifies scientists not assigned to any project by checking their absence from the AssignedTo table rather than relying on a potentially incorrect NULL project_id field, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting scientists not assigned to any project: use count(*) to count all matching rows. 2) When checking if scientists are not assigned to any project: filter using ssn NOT IN (SELECT scientist FROM AssignedTo) instead of checking for NULL project_id values. 3) When referring to the scientist identifier: use the exact token ssn as the key for scientists. 4) When referring to the assignment relationship: use the exact token scientist from the AssignedTo table to link to scientists."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM scientists WHERE project_id IS NULL;",
            "SELECT count(*) FROM Scientists WHERE ssn NOT IN (SELECT scientist FROM AssignedTo)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Scientists WHERE ssn NOT IN (SELECT scientist FROM AssignedTo)"
        ]
    },
    "5828": {
        "db_id": "workshop_paper",
        "question": "Show the most common college of authors of submissions.",
        "ground_truth": "SELECT College FROM submission GROUP BY College ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do reference the `College` column from the `submission` table instead of the `college` column from the `authors` table. Do use `COUNT(*)` directly in the ORDER BY clause instead of aliasing it as `count` in the SELECT list. Do query the `submission` table instead of the `authors` table. The amended query now correctly identifies the college with the most submissions by counting records in the submission table and ordering by that count in descending order.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, as the query only needs to return the College column with the highest count. Do keep the `GROUP BY College` clause to group submissions by college, and maintain the `ORDER BY COUNT(*) DESC` to order colleges by their submission count in descending order, with `LIMIT 1` to select only the college with the highest count. The amended query now correctly returns only the college name instead of both the college and its count, matching the RIGHT_SQL's behavior of identifying the college with the most submissions."
        ],
        "rules": [
            "1) When answering about \"most common college of authors of submissions\": make sure the output order: College, COUNT(*) 2) When counting submissions per college: use COUNT(*) directly in the ORDER BY clause without aliasing it in the SELECT list 3) When querying for college information: use the \"College\" column from the \"submission\" table instead of any \"college\" column from other tables 4) When the question asks for the most common college: rank colleges by COUNT(*) in descending order and keep only the top 1 row",
            "1) When answering about \"most common college of authors of submissions\": make sure the output order: College. 2) When the question asks for \"most common college\": group submissions by College and count using the canonical key for submissions, then order by count in descending order and keep only the top 1 row. 3) When producing output: return only the College column, not the count value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT college, COUNT(*) as count FROM authors GROUP BY college ORDER BY count DESC LIMIT 1;",
            "SELECT College, COUNT(*) FROM submission GROUP BY College ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT College FROM submission GROUP BY College ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT College FROM submission GROUP BY College ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "2027": {
        "db_id": "gas_company",
        "question": "Show the manager name for gas stations belonging to the ExxonMobil company.",
        "ground_truth": "SELECT T3.manager_name FROM station_company AS T1 JOIN company AS T2 ON T1.company_id  =  T2.company_id JOIN gas_station AS T3 ON T1.station_id  =  T3.station_id WHERE T2.company  =  'ExxonMobil'",
        "amends": [
            "Do use explicit table aliases `T3.manager_name` instead of bare column reference `manager_name`. Do join three tables `station_company AS T1`, `company AS T2`, and `gas_station AS T3` instead of querying only `gas_stations`. Do add join conditions `T1.company_id = T2.company_id` and `T1.station_id = T3.station_id` instead of missing table relationships. Do filter on `T2.company = 'ExxonMobil'` instead of filtering directly on the gas_stations table. The amended query now correctly retrieves manager names by establishing proper relationships between company, station_company, and gas_station tables to match the intended business logic."
        ],
        "rules": [
            "1) When answering about \"manager name for gas stations belonging to ExxonMobil company\": make sure the output order: T3.manager_name. 2) When the question mentions \"gas stations belonging to ExxonMobil company\": use three tables station_company AS T1, company AS T2, and gas_station AS T3 instead of querying only gas_stations. 3) When combining T1 and T2 for shared entities: link rows where T1.company_id = T2.company_id and keep only matching pairs (inner match). 4) When combining T1 and T3 for shared entities: link rows where T1.station_id = T3.station_id and keep only matching pairs (inner match). 5) When filtering for ExxonMobil company: filter on T2.company = 'ExxonMobil' exactly as specified, preserving the exact case and spelling. 6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for any table or column names."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT manager_name FROM gas_stations WHERE company = 'ExxonMobil';",
            "SELECT T3.Manager_Name \nFROM station_company AS T1\nJOIN company AS T2 ON T1.Company_ID = T2.Company_ID\nJOIN gas_station AS T3 ON T1.Station_ID = T3.Station_ID\nWHERE T2.Company = 'ExxonMobil'"
        ],
        "rule_sql": [
            "SELECT T3.\"Manager_Name\" FROM station_company AS T1 INNER JOIN company AS T2 ON T1.\"Company_ID\" = T2.\"Company_ID\" INNER JOIN gas_station AS T3 ON T1.\"Station_ID\" = T3.\"Station_ID\" WHERE T2.\"Company\" = 'ExxonMobil'"
        ]
    },
    "324": {
        "db_id": "product_catalog",
        "question": "Which catalog content has the highest height? Give me the catalog entry name.",
        "ground_truth": "SELECT catalog_entry_name FROM catalog_contents ORDER BY height DESC LIMIT 1",
        "amends": [
            "Do select `catalog_entry_name` instead of `name` for the column name. Do reference table `catalog_contents` instead of `catalog` as the data source. Do order by `height DESC` instead of `height ASC` to sort in descending order rather than ascending. The amended query now correctly retrieves the catalog entry name from the catalog_contents table ordered by height in descending order with a limit of one result."
        ],
        "rules": [
            "1) When answering about \"catalog content with highest height\": make sure the output order: catalog_entry_name. 2) When the question mentions \"catalog content\": \"catalog content\" actually means \"catalog_contents\" in schema. 3) When the question mentions \"highest height\": rank rows by height in descending order and keep the first 1 row. 4) When selecting the name column: use \"catalog_entry_name\" instead of \"name\" as the exact column token."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM catalog ORDER BY height ASC LIMIT 1;",
            "SELECT catalog_entry_name FROM Catalog_Contents ORDER BY height DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT catalog_entry_name FROM Catalog_Contents ORDER BY height DESC LIMIT 1;"
        ]
    },
    "573": {
        "db_id": "store_1",
        "question": "Eduardo Martins is a customer at which company?",
        "ground_truth": "SELECT company FROM customers WHERE first_name = \"Eduardo\" AND last_name = \"Martins\";",
        "amends": [
            "Do select `company` instead of `company_name` as the column name in the SELECT list. Do use double quotes `\"Eduardo\"` and `\"Martins\"` instead of single quotes for the string literals in the WHERE filter conditions, while keeping the same filter logic on `first_name` and `last_name`. The amended query now correctly retrieves the company field using the proper column name and consistent string quoting to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting the company for a customer: use the exact column name \"company\" from the customers table, not \"company_name\". 2) When filtering by first name \"Eduardo\": use double quotes around the literal value as \"Eduardo\" exactly. 3) When filtering by last name \"Martins\": use double quotes around the literal value as \"Martins\" exactly. 4) When answering about which company Eduardo Martins is a customer at: make sure the output order contains only the company field."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT company_name FROM customers WHERE first_name = 'Eduardo' AND last_name = 'Martins';",
            "SELECT company FROM customers WHERE first_name = \"Eduardo\" AND last_name = \"Martins\";"
        ],
        "rule_sql": [
            "SELECT company FROM customers WHERE first_name = \"Eduardo\" AND last_name = \"Martins\";"
        ]
    },
    "140": {
        "db_id": "bike_1",
        "question": "What is the latitude, longitude, and city of the station from which the trip with smallest duration started?",
        "ground_truth": "SELECT T1.lat ,  T1.long ,  T1.city FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id ORDER BY T2.duration LIMIT 1",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of no aliases. Do select columns `lat` and `long` instead of `latitude` and `longitude`. Do join `station AS T1` with `trip AS T2` on `T1.id = T2.start_station_id` instead of using a subquery with `WHERE station_id = (SELECT start_station_id FROM trips)`. Do move the ordering by `T2.duration` to the main query's `ORDER BY` clause instead of having it in the subquery. Do apply `LIMIT 1` to the main query instead of the subquery. The amended query now correctly retrieves the station with the shortest trip duration by joining the tables directly rather than using an inefficient correlated subquery."
        ],
        "rules": [
            "1) When answering about station latitude, longitude, and city for the trip with smallest duration: select columns \"lat\", \"long\", and \"city\" from table \"station\" (aliased as T1). 2) When combining station and trip tables: join \"station AS T1\" with \"trip AS T2\" where T1.id equals T2.start_station_id using inner match. 3) When the question asks for the trip with smallest duration: order results by T2.duration in ascending order. 4) When retrieving only the top result: apply LIMIT 1 to the main query output. 5) When using table aliases: maintain T1 for station table and T2 for trip table throughout the query."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT latitude, longitude, city FROM stations WHERE station_id = (SELECT start_station_id FROM trips ORDER BY duration ASC LIMIT 1);",
            "SELECT T1.lat, T1.long, T1.city\nFROM station AS T1\nJOIN trip AS T2 ON T1.id = T2.start_station_id\nORDER BY T2.duration ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.lat, T1.long, T1.city FROM station AS T1 INNER JOIN trip AS T2 ON T1.id = T2.start_station_id ORDER BY T2.duration ASC LIMIT 1;"
        ]
    },
    "911": {
        "db_id": "insurance_fnol",
        "question": "What are all the policy types of the customer named \"Dayana Robel\"?",
        "ground_truth": "SELECT DISTINCT t3.policy_type_code FROM customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id  =  t2.customer_id JOIN available_policies AS t3 ON t2.policy_id  =  t3.policy_id WHERE t1.customer_name  =  \"Dayana Robel\"",
        "amends": [
            "Do select `DISTINCT t3.policy_type_code` instead of `policy_type` from the wrong column source. Do add joins to `customers_policies AS t2` and `available_policies AS t3` instead of querying only the `customers` table. Do use `LEFT JOIN` on `t1.customer_id = t2.customer_id` and `t2.policy_id = t3.policy_id` instead of no joins. Do filter on `t1.customer_name = \"Dayana Robel\"` instead of `name = 'Dayana Robel'` with corrected column reference and quote style. The amended query now correctly retrieves distinct policy types from the joined policy tables instead of attempting to get them directly from the customers table where they don't exist."
        ],
        "rules": [
            "1) When the question asks for policy types of a customer: select distinct policy_type_code from available_policies table (t3) instead of policy_type from customers table. 2) When joining tables for customer policy information: use LEFT JOIN between customers (t1) and customers_policies (t2) on t1.customer_id = t2.customer_id, and LEFT JOIN between customers_policies (t2) and available_policies (t3) on t2.policy_id = t3.policy_id. 3) When filtering for a specific customer name: use t1.customer_name = \"Dayana Robel\" with double quotes around the name value. 4) When the question mentions \"policy types\": this refers to policy_type_code column in available_policies table (t3). 5) When the question mentions \"customer named\": this refers to customer_name column in customers table (t1)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT policy_type FROM customers WHERE name = 'Dayana Robel';",
            "SELECT DISTINCT t3.policy_type_code\nFROM Customers AS t1\nLEFT JOIN Customers_Policies AS t2 ON t1.Customer_ID = t2.Customer_ID\nLEFT JOIN Available_Policies AS t3 ON t2.Policy_ID = t3.Policy_ID\nWHERE t1.Customer_name = 'Dayana Robel'"
        ],
        "rule_sql": [
            "SELECT DISTINCT t3.policy_type_code\nFROM Customers t1\nLEFT JOIN Customers_Policies t2 ON t1.Customer_ID = t2.Customer_ID\nLEFT JOIN Available_Policies t3 ON t2.Policy_ID = t3.Policy_ID\nWHERE t1.Customer_name = \"Dayana Robel\""
        ]
    },
    "595": {
        "db_id": "store_1",
        "question": "How many employees are living in Canada?",
        "ground_truth": "SELECT count(*) FROM employees WHERE country = \"Canada\";",
        "amends": [
            "Do filter on `country = \"Canada\"` instead of `country = 'USA'` to count employees from Canada rather than the USA. The amended query now correctly matches the intended behavior of counting Canadian employees."
        ],
        "rules": [
            "1) When the question asks for employees living in Canada: filter rows where the country column equals exactly 'Canada' (not 'USA'). 2) When counting employees: count the number of rows that satisfy the condition using the canonical counting method."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE country = 'USA';",
            "SELECT COUNT(*) FROM employees WHERE country = 'Canada';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM employees WHERE country = 'Canada';"
        ]
    },
    "6664": {
        "db_id": "driving_school",
        "question": "What is the status code, mobile phone number and email address of customer with last name as Kohler or first name as Marina?",
        "ground_truth": "SELECT customer_status_code ,  cell_mobile_phone_number ,  email_address FROM Customers WHERE first_name = \"Marina\" OR last_name  =  \"Kohler\"",
        "amends": [
            "Do select `customer_status_code`, `cell_mobile_phone_number`, and `email_address` instead of `status_code`, `mobile_phone`, and `email_address`. Do query from `Customers` instead of `customers`. Do use `OR` condition with `first_name = \"Marina\"` or `last_name = \"Kohler\"` instead of `AND` condition with `last_name = 'Kohler'` and `first_name = 'Marina'`. The amended query now correctly retrieves records matching either first or last name condition instead of requiring both conditions to be met simultaneously."
        ],
        "rules": [
            "1) When selecting columns for customer information: use exact column names \"customer_status_code\", \"cell_mobile_phone_number\", and \"email_address\" from table \"Customers\". 2) When querying from the customer table: use the exact table name \"Customers\" with proper case. 3) When searching for customers by name conditions: use OR logic to find records where either \"first_name\" equals \"Marina\" or \"last_name\" equals \"Kohler\", not requiring both conditions simultaneously."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT status_code, mobile_phone, email_address FROM customers WHERE last_name = 'Kohler' AND first_name = 'Marina';",
            "SELECT customer_status_code, cell_mobile_phone_number, email_address FROM Customers WHERE last_name = 'Kohler' OR first_name = 'Marina'"
        ],
        "rule_sql": [
            "SELECT customer_status_code, cell_mobile_phone_number, email_address FROM Customers WHERE first_name = 'Marina' OR last_name = 'Kohler'"
        ]
    },
    "2225": {
        "db_id": "formula_1",
        "question": "What are the average fastest lap speed in races held after 2004 grouped by race name and ordered by year?",
        "ground_truth": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year",
        "amends": [
            "Do join `results` table instead of querying only `races` table. Do use `JOIN` with `races.raceid = results.raceid` instead of no join condition. Do reference `results.fastestlapspeed` instead of `races.fastest_lap_speed`. Do use table aliases `T1` and `T2` instead of no aliases. Do filter on `year > 2014` instead of `year > 2004`. Do group by `T1.name` instead of `race_name`. Do order by `T1.year` instead of `year`. Do remove the column alias `avg_speed` instead of keeping it. The amended query now correctly calculates average fastest lap speed from the joined results table with proper filtering and grouping.",
            "Do place `avg(T2.fastestlapspeed)` first in the SELECT list instead of `T1.name` first. Do use lowercase `fastestlapspeed` instead of `fastestLapSpeed`. Do include `T1.year` in the SELECT list instead of omitting it from the GROUP BY clause. Do use `AS T1` and `AS T2` for table aliases instead of omitting the AS keyword. Do use lowercase `raceid` in the join condition instead of `raceId`. The amended query now correctly includes all non-aggregated columns in the GROUP BY clause and matches the RIGHT_SQL's behavior.",
            "Do reorder the SELECT list to place `avg(T2.fastestlapspeed)` first instead of `T1.year` first, and do remove `T1.year` from the GROUP BY clause instead of including it, since the average fastest lap speed is being calculated per race name rather than per year and name combination. Do keep the JOIN condition `ON T1.raceid = T2.raceid` unchanged, maintain the WHERE filter `T1.year > 2014`, and preserve the ORDER BY `T1.year` to ensure the amended query now matches the RIGHT_SQL's behavior of calculating average fastest lap speed by race name for years after 2014."
        ],
        "rules": [
            "1) When answering about average fastest lap speed: use the \"results\" table's \"fastestlapspeed\" column instead of the \"races\" table's column. 2) When combining race and result data: link rows where T1.raceid = T2.raceid using an inner join. 3) When filtering by year: use the condition year > 2014 instead of year > 2004. 4) When grouping by race name: use T1.name instead of race_name. 5) When ordering results: order by T1.year instead of year. 6) When selecting output columns: do not use column aliases like avg_speed.",
            "1) When answering about \"average fastest lap speed in races held after 2004 grouped by race name and ordered by year\": make sure the output order: avg(T2.fastestlapspeed), T1.name, T1.year. 2) When the question mentions \"fastest lap speed\": \"fastest lap speed\" actually means \"fastestlapspeed in schema\" using lowercase spelling. 3) When combining T1 and T2 for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (T1.raceid = T2.raceid); keep only matching pairs (inner match). 4) When the question asks for races held after 2004: filter rows where T1.year > 2004. 5) When the question says \"grouped by race name\": organize results by T1.name and compute requested aggregates per group. 6) When the question asks for \"average fastest lap speed\": compute the average of T2.fastestlapspeed. 7) When the question asks for ordering by year: sort the final results by T1.year in ascending order. 8) When choosing identifier delimiters: do not replace lowercase identifiers with camelCase or other casing variations.",
            "1) When answering about \"average fastest lap speed in races held after 2004 grouped by race name and ordered by year\": make sure the output order: avg(T2.fastestlapspeed), T1.year, T1.name. 2) When the question asks for average fastest lap speed per race name: organize results by T1.name and compute average of T2.fastestlapspeed per group. 3) When the question mentions \"races held after 2004\": filter rows where T1.year > 2014. 4) When combining races and results tables: link rows where T1.raceid = T2.raceid and keep only matching pairs (inner match). 5) When ordering results by year: sort the final output by T1.year."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT race_name, year, AVG(fastest_lap_speed) as avg_speed \nFROM races \nWHERE year > 2004 \nGROUP BY race_name \nORDER BY year;",
            "SELECT T1.name, T1.year, AVG(T2.fastestLapSpeed) \nFROM races T1\nJOIN results T2 ON T1.raceId = T2.raceId\nWHERE T1.year > 2014\nGROUP BY T1.name\nORDER BY T1.year",
            "SELECT T1.year, T1.name, AVG(T2.fastestlapspeed) \nFROM races AS T1 \nJOIN results AS T2 ON T1.raceid = T2.raceid \nWHERE T1.year > 2014 \nGROUP BY T1.year, T1.name \nORDER BY T1.year",
            "SELECT avg(T2.fastestlapspeed), T1.name, T1.year\nFROM races AS T1\nJOIN results AS T2 ON T1.raceid = T2.raceid\nWHERE T1.year > 2014\nGROUP BY T1.name\nORDER BY T1.year"
        ],
        "rule_sql": [
            "SELECT AVG(T2.fastestlapspeed), T1.name, T1.year FROM races T1 INNER JOIN results T2 ON T1.raceId = T2.raceId WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year"
        ]
    },
    "6984": {
        "db_id": "culture_company",
        "question": "How many movie directors are there?",
        "ground_truth": "SELECT COUNT (DISTINCT director) FROM movie",
        "amends": [
            "Do count `DISTINCT director` instead of counting all rows with `COUNT(*)`. Do reference the correct table name `movie` instead of the pluralized `movies`. The amended query now correctly counts unique directors rather than total movie records, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"count of movie directors\": count the number of unique values of the exact token \"director\" from table \"movie\". 2) When counting distinct entities: use DISTINCT on the specific column rather than counting all rows with COUNT(*). 3) When referencing table names: use the exact table name \"movie\" as shown in the schema, not pluralized forms like \"movies\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies;",
            "SELECT COUNT(DISTINCT Director) FROM movie;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Director) FROM movie;"
        ]
    },
    "4333": {
        "db_id": "tracking_grants_for_research",
        "question": "What is the type of the organization with the most research staff?",
        "ground_truth": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.organisation_type` instead of `type`. Do add `FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id = T2.employer_organisation_id` instead of `FROM organizations`. Do add `GROUP BY T1.organisation_type` instead of omitting grouping. Do change `ORDER BY count(*) DESC` instead of `ORDER BY research_staff DESC` to aggregate staff counts per organization type. The amended query now correctly joins organization and research staff tables, groups by organization type, and orders by staff count to find the organization type with the most research staff."
        ],
        "rules": [
            "1) When answering about \"type of organization with the most research staff\": make sure the output order: T1.organisation_type 2) When the question mentions \"type\": \"type\" actually means \"organisation_type in schema\" 3) When combining T1 and T2 for shared entities: link rows where T1.organisation_id = T2.employer_organisation_id; keep only matching pairs (inner match). 4) When the question asks for \"count of research staff\" per organization type: compute the number of rows using count(*) per T1.organisation_type. 5) When the question asks for \"most research staff\": rank organization types by count(*) in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type FROM organizations ORDER BY research_staff DESC LIMIT 1;",
            "SELECT T1.organisation_type\nFROM Organisations AS T1\nJOIN Research_Staff AS T2 ON T1.organisation_id = T2.employer_organisation_id\nGROUP BY T1.organisation_type\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT o.organisation_type\nFROM Organisations o\nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id\nGROUP BY o.organisation_type\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "3598": {
        "db_id": "music_1",
        "question": "What is the average rating and resolution of all bangla songs?",
        "ground_truth": "SELECT avg(rating) ,  avg(resolution) FROM song WHERE languages  =  \"bangla\"",
        "amends": [
            "Do use `avg(rating)` and `avg(resolution)` instead of `AVG(rating)` and `resolution` to apply aggregation to both columns. Do reference table `song` instead of `songs` for the correct table name. Do use column `languages` instead of `language` for the proper column reference. Do use double quotes `\"bangla\"` instead of single quotes `'Bangla'` for string literal formatting. The amended query now correctly calculates average ratings and resolutions for Bangla language songs from the appropriate table."
        ],
        "rules": [
            "1) When answering about average rating and resolution of all bangla songs: make sure the output order: avg(rating), avg(resolution). 2) When the question mentions \"bangla songs\": \"bangla\" actually means \"languages = \\\"bangla\\\"\" in schema. 3) When computing averages for multiple columns: apply avg() aggregation to each column individually (avg(rating) and avg(resolution)). 4) When referencing the songs table: use the exact table name \"song\" instead of \"songs\". 5) When filtering by language: use the exact column name \"languages\" instead of \"language\". 6) When using string literals for filtering: use double quotes and exact case as shown in the schema (\\\"bangla\\\" instead of 'Bangla')."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(rating), resolution FROM songs WHERE language = 'Bangla';",
            "SELECT avg(rating) as average_rating, avg(resolution) as average_resolution FROM song WHERE languages = \"bangla\""
        ],
        "rule_sql": [
            "SELECT AVG(rating) AS avg_rating, AVG(resolution) AS avg_resolution FROM song WHERE languages = \"bangla\";"
        ]
    },
    "5422": {
        "db_id": "shop_membership",
        "question": "Show all branch names with the number of members in each branch registered after 2015.",
        "ground_truth": "SELECT T2.name ,  count(*) FROM membership_register_branch AS T1 JOIN branch AS T2 ON T1.branch_id  =  T2.branch_id WHERE T1.register_year  >  2015 GROUP BY T2.branch_id",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of direct table references. Do join `membership_register_branch AS T1` with `branch AS T2` on `T1.branch_id = T2.branch_id` instead of querying a single `members` table. Do select `T2.name` instead of `branch_name` to get the actual branch name from the branch table. Do filter on `T1.register_year > 2015` instead of `registration_date > '2015-01-01'` to use year comparison rather than date comparison. Do group by `T2.branch_id` instead of `branch_name` to ensure proper aggregation by the primary key. The amended query now correctly joins the membership register with branch information and uses appropriate year-based filtering."
        ],
        "rules": [
            "1) When answering about \"branch names with number of members registered after 2015\": make sure the output order: T2.name first, then count of members. 2) When the question mentions \"branch names\": \"branch names\" actually means \"T2.name in schema\". 3) When the question mentions \"members registered after 2015\": use T1.register_year > 2015 instead of date comparison. 4) When combining T1 (membership_register_branch) and T2 (branch) for shared entities: link rows where T1.branch_id = T2.branch_id; keep only matching pairs (inner match). 5) When the question asks for \"count of members\": compute the number of rows using the canonical key T1.branch_id. 6) When the question says \"per branch\"/\"by branch\": organize results by T2.branch_id and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT branch_name, COUNT(*) FROM members WHERE registration_date > '2015-01-01' GROUP BY branch_name;",
            "SELECT T2.Name, COUNT(T1.Member_ID) AS Number_of_Members\nFROM membership_register_branch AS T1\nJOIN branch AS T2 ON T1.Branch_ID = T2.Branch_ID\nWHERE T1.Register_Year > '2015'\nGROUP BY T2.Branch_ID;"
        ],
        "rule_sql": [
            "SELECT T2.Name, COUNT(T1.Member_ID) \nFROM membership_register_branch T1\nJOIN branch T2 ON T1.Branch_ID = T2.Branch_ID\nWHERE T1.Register_Year > '2015'\nGROUP BY T2.Branch_ID\nORDER BY T2.Name, COUNT(T1.Member_ID)"
        ]
    },
    "2440": {
        "db_id": "movie_1",
        "question": "Who is the director of movie Avatar?",
        "ground_truth": "SELECT director FROM Movie WHERE title  = 'Avatar'",
        "amends": [
            "Do select `director` instead of `actor_name` from the source table. Do reference table `Movie` instead of `movies` in the FROM clause. The WHERE filter on `title = 'Avatar'` remains unchanged. The amended query now correctly retrieves the director information from the Movie table instead of attempting to fetch actor names from a potentially incorrect table reference."
        ],
        "rules": [
            "1) When the question asks about \"director of movie Avatar\": select the exact column \"director\" from table \"Movie\" with alias T1. 2) When filtering for a specific movie title: use the exact literal 'Avatar' with the column \"title\" in the WHERE condition. 3) When referencing tables: use the exact table name \"Movie\" instead of any other table reference like \"movies\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT actor_name FROM movies WHERE title = 'Avatar';",
            "SELECT director FROM Movie WHERE title = 'Avatar';"
        ],
        "rule_sql": [
            "SELECT T1.director FROM Movie AS T1 WHERE T1.title = 'Avatar'"
        ]
    },
    "4746": {
        "db_id": "department_store",
        "question": "What are the maximum and minimum product prices for each product type?",
        "ground_truth": "SELECT product_type_code ,  max(product_price) ,  min(product_price) FROM products GROUP BY product_type_code",
        "amends": [
            "Do reference `product_type_code` instead of `product_type` in the SELECT list and GROUP BY clause. Do use `product_price` instead of `price` for both the MAX and MIN aggregate functions. Do group by `product_type_code` instead of `product_id` to correctly aggregate by product type rather than individual products. The amended query now correctly calculates maximum and minimum prices grouped by product type codes instead of by individual product IDs."
        ],
        "rules": [
            "1) When the question asks for maximum and minimum product prices by product type: use \"product_type_code\" instead of \"product_type\" for grouping and selection. 2) When calculating price aggregates: use \"product_price\" instead of \"price\" for both MAX and MIN functions. 3) When grouping by product type: group by \"product_type_code\" instead of \"product_id\" to aggregate by product type categories rather than individual products."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT product_type, MAX(price) as max_price, MIN(price) as min_price FROM products GROUP BY product_id;",
            "SELECT product_type_code, MAX(product_price) AS max_price, MIN(product_price) AS min_price FROM Products GROUP BY product_type_code;"
        ],
        "rule_sql": [
            "SELECT product_type_code, MAX(product_price) AS max_price, MIN(product_price) AS min_price FROM Products GROUP BY product_type_code;"
        ]
    },
    "3523": {
        "db_id": "hr_1",
        "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.",
        "ground_truth": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT e.first_name, e.last_name, e.employee_id, c.country_name \nFROM employees e \nJOIN departments d ON e.department_id = d.department_id \nJOIN locations l ON d.location_id = l.location_id \nJOIN countries c ON l.country_id = c.country_id"
        ],
        "rule_sql": [
            "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS full_name, e.EMPLOYEE_ID, c.COUNTRY_NAME\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID\nJOIN countries c ON l.COUNTRY_ID = c.COUNTRY_ID;",
            "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS full_name, e.EMPLOYEE_ID, c.COUNTRY_NAME\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID\nJOIN countries c ON l.COUNTRY_ID = c.COUNTRY_ID;"
        ]
    },
    "6622": {
        "db_id": "driving_school",
        "question": "List all vehicle id",
        "ground_truth": "SELECT vehicle_id FROM Vehicles;",
        "amends": [
            "Do select `vehicle_id` instead of `vehicle_name` and use table name `Vehicles` instead of `vehicles` to match the correct schema and case sensitivity. The amended query now correctly retrieves the vehicle identifier column from the properly capitalized table name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"vehicle id\": select the exact column \"vehicle_id\" from the \"Vehicles\" table. 2) When referring to the table containing vehicle information: use the exact table name \"Vehicles\" with proper capitalization as shown in the schema. 3) When producing output: ensure the result contains only the \"vehicle_id\" column values from the \"Vehicles\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT vehicle_name FROM vehicles;",
            "SELECT vehicle_id FROM Vehicles;"
        ],
        "rule_sql": [
            "SELECT vehicle_id FROM Vehicles;"
        ]
    },
    "6680": {
        "db_id": "driving_school",
        "question": "List the first name and last name of customers have the amount of outstanding between 1000 and 3000.",
        "ground_truth": "SELECT first_name ,  last_name FROM Customers WHERE amount_outstanding BETWEEN 1000 AND 3000;",
        "amends": [
            "Do reference the correct table name `Customers` instead of `customers` and use the correct column name `amount_outstanding` instead of `outstanding_amount`. Do use the `BETWEEN` operator with range `1000 AND 3000` instead of the `OR` condition with `outstanding_amount < 1000 OR outstanding_amount > 3000`, which incorrectly excluded values between 1000 and 3000 instead of including them. The amended query now correctly filters for customers with outstanding amounts within the specified range, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"customers\": use the exact table name \"Customers\" with double quotes and capital C. 2) When the question mentions \"outstanding amount\": use the exact column name \"amount_outstanding\" with double quotes and underscore. 3) When filtering for values between 1000 and 3000 inclusive: use the BETWEEN operator with the range 1000 AND 3000 instead of OR conditions that would exclude the range. 4) When selecting customer names: output \"first_name\" and \"last_name\" columns in that order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM customers WHERE outstanding_amount < 1000 OR outstanding_amount > 3000;",
            "SELECT first_name, last_name FROM Customers WHERE amount_outstanding BETWEEN 1000 AND 3000;"
        ],
        "rule_sql": [
            "SELECT \"first_name\", \"last_name\" FROM \"Customers\" WHERE \"amount_outstanding\" BETWEEN 1000 AND 3000"
        ]
    },
    "4717": {
        "db_id": "department_store",
        "question": "What are the staff ids and genders of all staffs whose job title is Department Manager?",
        "ground_truth": "SELECT T1.staff_id ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.job_title_code  =  \"Department Manager\"",
        "amends": [
            "Do add table alias `T1` for the `staff` table and specify `T1.staff_gender` instead of just `gender` in the SELECT list. Do add a `JOIN` with `staff_department_assignments AS T2` on `T1.staff_id = T2.staff_id` instead of querying only the `staff` table. Do change the WHERE filter to use `T2.job_title_code = \"Department Manager\"` instead of `job_title = 'Department Manager'` from the original table. The amended query now correctly joins the department assignments table to filter staff by their job title code rather than relying on a potentially incorrect job_title field in the staff table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about staff ids and genders of staff with job title Department Manager: make sure the output order: staff_id, staff_gender. 2) When the question mentions \"gender\": \"gender\" actually means \"staff_gender in schema\". 3) When filtering for job title Department Manager: use \"Department Manager\" as the exact literal value for T2.job_title_code. 4) When combining T1 (staff) and T2 (staff_department_assignments) for shared entities: link rows where T1.staff_id = T2.staff_id; keep only matching pairs (inner match). 5) When selecting columns: use T1.staff_id and T1.staff_gender from the staff table, not just staff_id and gender."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT staff_id, gender FROM staff WHERE job_title = 'Department Manager';",
            "SELECT T1.staff_id, T1.staff_gender \nFROM Staff AS T1\nJOIN Staff_Department_Assignments AS T2 ON T1.staff_id = T2.staff_id\nWHERE T2.job_title_code = 'Department Manager'"
        ],
        "rule_sql": [
            "SELECT T1.staff_id, T1.staff_gender \nFROM Staff T1\nINNER JOIN Staff_Department_Assignments T2 ON T1.staff_id = T2.staff_id\nWHERE T2.job_title_code = 'Department Manager'"
        ]
    },
    "3786": {
        "db_id": "e_learning",
        "question": "How many tests have result \"Fail\"?",
        "ground_truth": "SELECT count(*) FROM Student_Tests_Taken WHERE test_result  =  \"Fail\"",
        "amends": [
            "Do reference table `Student_Tests_Taken` instead of `tests` and filter on column `test_result` with value `\"Fail\"` instead of `result` with value `'Pass'`."
        ],
        "rules": [
            "1) When answering about \"How many tests have result 'Fail'\": use table \"Student_Tests_Taken\" instead of \"tests\". 2) When filtering for test results: use column \"test_result\" instead of \"result\". 3) When filtering for the specific result value: use the exact literal value \"Fail\" instead of \"Pass\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM tests WHERE result = 'Pass';",
            "SELECT COUNT(*) FROM Student_Tests_Taken WHERE test_result = 'Fail';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Student_Tests_Taken WHERE test_result = 'Fail'"
        ]
    },
    "3232": {
        "db_id": "college_1",
        "question": "How many different departments are there?",
        "ground_truth": "SELECT count(DISTINCT dept_name) FROM department",
        "amends": [
            "Do `count(DISTINCT dept_name)` instead of `COUNT(*)` to count distinct department names rather than all employee records. Do select from `department` table instead of `employees` to analyze department data rather than employee data. The amended query now correctly counts unique department names from the department table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"How many different departments are there?\": make sure the output order: count of distinct department names. 2) When the question mentions \"different departments\": \"different departments\" actually means \"distinct dept_name in schema\". 3) When counting distinct department names: compute the number of unique values of the exact token \"dept_name\". 4) When selecting from the department table: use the \"department\" table as the data source for department information."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees;",
            "SELECT COUNT(DISTINCT DEPT_NAME) FROM DEPARTMENT;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT DEPT_NAME) FROM DEPARTMENT;"
        ]
    },
    "1839": {
        "db_id": "browser_web",
        "question": "List the names of the browser that are compatible with both 'CACHEbox' and 'Fasterfox'.",
        "ground_truth": "SELECT T3.name FROM web_client_accelerator AS T1 JOIN accelerator_compatible_browser AS T2 ON T2.accelerator_id  =  T1.id JOIN browser AS T3 ON T2.browser_id  =  T3.id WHERE T1.name  =  'CACHEbox' INTERSECT SELECT T3.name FROM web_client_accelerator AS T1 JOIN accelerator_compatible_browser AS T2 ON T2.accelerator_id  =  T1.id JOIN browser AS T3 ON T2.browser_id  =  T3.id WHERE T1.name  =  'Fasterfox'",
        "amends": [
            "Do use a three-table join structure with `web_client_accelerator`, `accelerator_compatible_browser`, and `browser` instead of querying a single `browsers` table. Do join `accelerator_compatible_browser` on `accelerator_id = id` instead of using simple WHERE conditions. Do filter on `T1.name = 'CACHEbox'` and `T1.name = 'Fasterfox'` in separate queries instead of using incompatible AND conditions on the same column. Do use `INTERSECT` to find browsers compatible with both accelerators instead of trying to satisfy both conditions simultaneously in a single WHERE clause. Do select `T3.name` from the joined browser table instead of `browser_name` from a standalone table. The amended query now correctly identifies browsers that are compatible with both CACHEbox and Fasterfox accelerators through proper relational joins and set operations."
        ],
        "rules": [
            "1) When answering about browser compatibility with multiple accelerators: use a three-table join structure with web_client_accelerator as T1, accelerator_compatible_browser as T2, and browser as T3 instead of querying a single table. 2) When joining accelerator_compatible_browser to web_client_accelerator: link rows where T2.accelerator_id equals T1.id exactly. 3) When filtering for specific accelerators 'CACHEbox' and 'Fasterfox': create separate queries filtering on T1.name = 'CACHEbox' and T1.name = 'Fasterfox' respectively. 4) When finding browsers compatible with both accelerators: use INTERSECT operation between the two separate query results instead of using AND conditions on the same column. 5) When selecting browser names: output T3.name from the joined browser table instead of browser_name from a standalone table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT browser_name FROM browsers WHERE compatible_with = 'CACHEbox' AND compatible_with = 'Fasterfox';",
            "SELECT T3.name\nFROM Web_client_accelerator T1\nJOIN accelerator_compatible_browser T2 ON T1.id = T2.accelerator_id\nJOIN browser T3 ON T2.browser_id = T3.id\nWHERE T1.name = 'CACHEbox'\nINTERSECT\nSELECT T3.name\nFROM Web_client_accelerator T1\nJOIN accelerator_compatible_browser T2 ON T1.id = T2.accelerator_id\nJOIN browser T3 ON T2.browser_id = T3.id\nWHERE T1.name = 'Fasterfox'"
        ],
        "rule_sql": [
            "SELECT T3.name \nFROM Web_client_accelerator AS T1\nJOIN accelerator_compatible_browser AS T2 ON T2.accelerator_id = T1.id\nJOIN browser AS T3 ON T2.browser_id = T3.id\nWHERE T1.name = 'CACHEbox'\nINTERSECT\nSELECT T3.name \nFROM Web_client_accelerator AS T1\nJOIN accelerator_compatible_browser AS T2 ON T2.accelerator_id = T1.id\nJOIN browser AS T3 ON T2.browser_id = T3.id\nWHERE T1.name = 'Fasterfox'"
        ]
    },
    "2485": {
        "db_id": "movie_1",
        "question": "What are the titles of all movies that were not reviewed by Chris Jackson?",
        "ground_truth": "SELECT DISTINCT title FROM Movie EXCEPT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T3.name  =  'Chris Jackson'",
        "amends": [
            "Do use `DISTINCT title` instead of just `title` to eliminate duplicates. Do change the data source to `Movie` instead of `movies` and add an `EXCEPT` operation instead of a simple filter. Do add joins between `Rating`, `Movie`, and `Reviewer` tables instead of querying a single table. Do filter on `T3.name = 'Chris Jackson'` instead of `reviewer != 'Chris Jackson'` to properly exclude movies rated by that specific reviewer. Do remove the direct `WHERE` clause and instead use the `EXCEPT` operation to subtract movies rated by Chris Jackson from all movies. The amended query now correctly identifies movies that have never been rated by Chris Jackson rather than incorrectly filtering on a non-existent reviewer column."
        ],
        "rules": [
            "1) When the question asks for movie titles that were not reviewed by a specific person: use an EXCEPT operation to subtract movies rated by that reviewer from all movies instead of using a simple filter condition. 2) When combining data from multiple tables: join the Rating, Movie, and Reviewer tables using their canonical relationships instead of querying a single table. 3) When filtering for a specific reviewer named 'Chris Jackson': use the exact literal 'Chris Jackson' with the correct case and spacing in the condition T3.name = 'Chris Jackson'. 4) When selecting movie titles: use DISTINCT title to eliminate duplicate titles from the results. 5) When referring to the Movie table: use the exact identifier \"Movie\" (with proper case) instead of \"movies\". 6) When the question asks about movies not reviewed by someone: ensure the logic properly excludes movies that have been rated by that specific reviewer rather than filtering on a non-existent reviewer column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM movies WHERE reviewer != 'Chris Jackson';",
            "SELECT DISTINCT title\nFROM Movie\nEXCEPT\nSELECT DISTINCT m.title\nFROM Movie m\nJOIN Rating r ON m.mID = r.mID\nJOIN Reviewer rev ON r.rID = rev.rID\nWHERE rev.name = 'Chris Jackson'"
        ],
        "rule_sql": [
            "SELECT DISTINCT title FROM Movie\nEXCEPT\nSELECT DISTINCT M.title\nFROM Movie M\nJOIN Rating R ON M.mID = R.mID\nJOIN Reviewer Rev ON R.rID = Rev.rID\nWHERE Rev.name = 'Chris Jackson'"
        ]
    },
    "2368": {
        "db_id": "csu_1",
        "question": "How many degrees were conferred in \"San Jose State University\" in 2000?",
        "ground_truth": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  \"San Jose State University\" AND t2.year  =  2000",
        "amends": [
            "Do select `degrees` instead of `COUNT(*)` to return the actual degree values rather than just a count. Do join `campuses` as `T1` with `degrees` as `T2` on `t1.id = t2.campus` instead of querying only the `degrees` table to properly relate campuses to their degrees. Do filter on `t1.campus = \"San Jose State University\"` instead of `university = 'San Jose State University'` to use the correct column name from the campuses table. Do filter on `t2.year = 2000` instead of `year = 2000` to specify the table alias for clarity. The amended query now correctly joins campuses with degrees and returns the actual degree data instead of just a count, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about degrees conferred: return the actual degree values from the \"degrees\" table instead of just counting them. 2) When combining campuses and degrees tables: link rows where T1.id = T2.campus to properly relate campuses to their degrees, keeping only matching pairs. 3) When filtering for a specific university: use T1.campus = \"San Jose State University\" to match the exact campus name from the campuses table. 4) When filtering for a specific year: use T2.year = 2000 to specify the year from the degrees table with the exact value 2000."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM degrees WHERE university = 'San Jose State University' AND year = 2000;",
            "SELECT T2.Degrees \nFROM Campuses AS T1 \nJOIN degrees AS T2 ON T1.Id = T2.Campus \nWHERE T1.Campus = 'San Jose State University' \nAND T2.Year = 2000"
        ],
        "rule_sql": [
            "SELECT d.Degrees \nFROM degrees d\nJOIN Campuses c ON d.Campus = c.Id\nWHERE c.Campus = 'San Jose State University' AND d.Year = 2000"
        ]
    },
    "5243": {
        "db_id": "music_2",
        "question": "What instruments did the musician with the last name \"Heilo\" play in \"Badlands\"?",
        "ground_truth": "SELECT T4.instrument FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId JOIN Instruments AS T4 ON T4.songid  =  T3.songid AND T4.bandmateid  =  T2.id WHERE T2.lastname  =  \"Heilo\" AND T3.title  =  \"Badlands\"",
        "amends": [
            "Do join multiple tables including `Performance`, `Band`, `Songs`, and `Instruments` instead of querying only the `musicians` table. Do use explicit `JOIN` syntax with proper join conditions instead of assuming a single table contains all needed data. Do reference `T4.instrument` from the `Instruments` table instead of `instrument` from a non-existent column in `musicians`. Do filter on `T2.lastname = \"Heilo\"` and `T3.title = \"Badlands\"` instead of `last_name = 'Heilo'` and `song_title = 'Badlands'` using incorrect column names. Do add proper join predicates connecting `T1.bandmate = T2.id`, `T3.SongId = T1.SongId`, and `T4.songid = T3.songid AND T4.bandmateid = T2.id` instead of missing the necessary table relationships. The amended query now correctly retrieves instrument information through proper table joins and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about instruments played by a musician with last name \"Heilo\" in song \"Badlands\": join tables Performance (T1), Band (T2), Songs (T3), and Instruments (T4) using explicit join conditions. 2) When combining T1 and T2: link rows where T1.bandmate = T2.id to connect performances with band members. 3) When combining T1 and T3: link rows where T3.SongId = T1.SongId to connect performances with songs. 4) When combining T3 and T4: link rows where T4.songid = T3.songid AND T4.bandmateid = T2.id to connect instruments with songs and band members. 5) When filtering for the musician: use T2.lastname = \"Heilo\" exactly as specified. 6) When filtering for the song: use T3.title = \"Badlands\" exactly as specified. 7) When selecting the instrument: reference T4.instrument from the Instruments table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT instrument FROM musicians WHERE last_name = 'Heilo' AND song_title = 'Badlands';",
            "SELECT i.Instrument\nFROM Band b\nJOIN Performance p ON b.Id = p.Bandmate\nJOIN Songs s ON p.SongId = s.SongId\nJOIN Instruments i ON s.SongId = i.SongId AND b.Id = i.BandmateId\nWHERE b.Lastname = 'Heilo' AND s.Title = 'Badlands'"
        ],
        "rule_sql": [
            "SELECT T4.Instrument\nFROM Performance T1\nJOIN Band T2 ON T1.Bandmate = T2.Id\nJOIN Songs T3 ON T3.SongId = T1.SongId\nJOIN Instruments T4 ON T4.SongId = T3.SongId AND T4.BandmateId = T2.Id\nWHERE T2.Lastname = 'Heilo'\nAND T3.Title = 'Badlands'"
        ]
    },
    "5347": {
        "db_id": "manufactory_1",
        "question": "What is the name and price of the cheapest product?",
        "ground_truth": "SELECT name ,  price FROM Products ORDER BY price ASC LIMIT 1",
        "amends": [
            "Do `ORDER BY price ASC` instead of `ORDER BY price DESC` to sort prices in ascending order rather than descending order. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the \"cheapest product\": sort products by price in ascending order to find the lowest price. 2) When ordering by price to find the cheapest: use ORDER BY price ASC instead of ORDER BY price DESC. 3) When selecting the cheapest product: limit the result to only the first row after sorting by price in ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, price FROM products ORDER BY price DESC LIMIT 1;",
            "SELECT Name, Price FROM Products ORDER BY Price ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name, Price FROM Products ORDER BY Price ASC LIMIT 1;"
        ]
    },
    "860": {
        "db_id": "chinook_1",
        "question": "What are the different first names for customers from Brazil who have also had an invoice?",
        "ground_truth": "SELECT DISTINCT T1.FirstName FROM CUSTOMER AS T1 JOIN INVOICE AS T2 ON T1.CustomerId  =  T2.CustomerId WHERE T1.country  =  \"Brazil\"",
        "amends": [
            "Do use `JOIN` with `T1.CustomerId = T2.CustomerId` instead of `IN` subquery filtering by `CustomerId FROM invoices`. Do reference table as `CUSTOMER AS T1` instead of `customers c`. Do reference joined table as `INVOICE AS T2` instead of `invoices` in subquery. Do use double quotes for string literal `\"Brazil\"` instead of single quotes `'Brazil'`. Do remove the unnecessary `DISTINCT` modifier since the join already ensures uniqueness through the relationship. The amended query now correctly uses an explicit join to filter customers with invoices from Brazil, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When combining CUSTOMER and INVOICE tables: link rows where T1.CustomerId = T2.CustomerId using an explicit join instead of subquery filtering. 2) When referencing the customer table: use CUSTOMER AS T1 instead of customers c. 3) When referencing the invoice table: use INVOICE AS T2 instead of invoices. 4) When filtering for country: use double quotes for the literal \"Brazil\" instead of single quotes. 5) When selecting first names from customers with invoices: remove the DISTINCT modifier since the join relationship already ensures uniqueness."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT c.FirstName \nFROM customers c \nWHERE c.Country = 'Brazil' \nAND c.CustomerId IN (SELECT CustomerId FROM invoices)",
            "SELECT T1.FirstName FROM CUSTOMER AS T1 JOIN INVOICE AS T2 ON T1.CustomerId = T2.CustomerId WHERE T1.Country = \"Brazil\""
        ],
        "rule_sql": [
            "SELECT T1.FirstName\nFROM CUSTOMER AS T1\nJOIN INVOICE AS T2 ON T1.CustomerId = T2.CustomerId\nWHERE T1.Country = \"Brazil\""
        ]
    },
    "4770": {
        "db_id": "department_store",
        "question": "Give the ids and names of products with price lower than 600 or higher than 900.",
        "ground_truth": "SELECT product_id ,  product_name FROM products WHERE product_price  <  600 OR product_price  >  900",
        "amends": [
            "Do select `product_id` and `product_name` instead of `id` and `name`. Do use `OR` condition with `product_price < 600 OR product_price > 900` instead of `AND` condition with `price > 600 AND price < 900`. The amended query now correctly selects products outside the price range rather than within it, matching the intended logic."
        ],
        "rules": [
            "1) When the question asks for \"ids and names of products\": select \"product_id\" and \"product_name\" as the exact column identifiers. 2) When filtering products by price range: use the condition \"product_price < 600 OR product_price > 900\" to find products outside the 600-900 range rather than within it. 3) When the question specifies \"lower than 600 or higher than 900\": implement this as an OR condition to capture both price ranges, not an AND condition that would find products within the range."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, name FROM products WHERE price > 600 AND price < 900;",
            "SELECT product_id, product_name FROM Products WHERE product_price < 600 OR product_price > 900;"
        ],
        "rule_sql": [
            "SELECT product_id, product_name FROM Products WHERE product_price < 600 OR product_price > 900;"
        ]
    },
    "2752": {
        "db_id": "election",
        "question": "Show the lieutenant governor and comptroller from the democratic party.",
        "ground_truth": "SELECT Lieutenant_Governor ,  Comptroller FROM party WHERE Party  =  \"Democratic\"",
        "amends": [
            "Do reference columns `Lieutenant_Governor` and `Comptroller` with proper capitalization instead of lowercase `lieutenant_governor` and `comptroller`. Do query from table `party` instead of table `officials`. Do filter with condition `Party = \"Democratic\"` instead of `party = 'Republican'` using proper column name capitalization, double quotes for string literal, and different party value. The amended query now correctly retrieves Democratic party officials from the appropriate table with properly referenced column names."
        ],
        "rules": [
            "1) When the question asks for lieutenant governor and comptroller: use exact column names \"Lieutenant_Governor\" and \"Comptroller\" with proper capitalization. 2) When querying for party officials: use table \"party\" instead of other tables. 3) When filtering for democratic party: use condition Party = \"Democratic\" with exact column name capitalization and double quotes for the string literal. 4) When the question specifies democratic party: do not use 'Republican' or other party values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT lieutenant_governor, comptroller FROM officials WHERE party = 'Republican';",
            "SELECT Lieutenant_Governor, Comptroller FROM party WHERE Party = \"Democratic\";"
        ],
        "rule_sql": [
            "SELECT Lieutenant_Governor, Comptroller FROM party WHERE Party = \"Democratic\";"
        ]
    },
    "2337": {
        "db_id": "csu_1",
        "question": "What is the campus fee for San Jose State University in 1996?",
        "ground_truth": "SELECT campusfee FROM campuses AS T1 JOIN csu_fees AS T2 ON T1.id  =  t2.campus WHERE t1.campus  =  \"San Jose State University\" AND T2.year  =  1996",
        "amends": [
            "Do select `campusfee` from the `csu_fees` table instead of `campus_fee` from `universities`. Do join `campuses AS T1` with `csu_fees AS T2` using `ON T1.id = T2.campus` instead of querying only the `universities` table. Do filter on `t1.campus = \"San Jose State University\"` instead of `name = 'San Jose State University'` and maintain `T2.year = 1996` instead of `year = 1996`. The amended query now correctly retrieves the campus fee by joining the campuses and fees tables with proper table aliases and join conditions, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about campus fees: select \"campusfee\" from the \"csu_fees\" table instead of \"campus_fee\" from \"universities\". 2) When combining campus and fee information: join \"campuses AS T1\" with \"csu_fees AS T2\" using \"T1.id = T2.campus\" to link campus records with their corresponding fee data. 3) When filtering for a specific university: use \"T1.campus = \\\"San Jose State University\\\"\" instead of \"name = 'San Jose State University'\" to match the exact campus name. 4) When filtering for a specific year: use \"T2.year = 1996\" to get fees for the exact year 1996."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT campus_fee FROM universities WHERE name = 'San Jose State University' AND year = 1996;",
            "SELECT T2.CampusFee FROM Campuses AS T1 JOIN csu_fees AS T2 ON T1.Id = T2.Campus WHERE T1.Campus = 'San Jose State University' AND T2.Year = 1996"
        ],
        "rule_sql": [
            "SELECT T2.CampusFee \nFROM Campuses AS T1 \nJOIN csu_fees AS T2 ON T1.Id = T2.Campus \nWHERE T1.Campus = \"San Jose State University\" \nAND T2.Year = 1996"
        ]
    },
    "4644": {
        "db_id": "college_3",
        "question": "How many departments are in the division AS?",
        "ground_truth": "SELECT count(*) FROM DEPARTMENT WHERE Division  =  \"AS\"",
        "amends": [
            "Do reference the table as `DEPARTMENT` instead of `departments` to match the correct schema. Do use uppercase `Division` instead of lowercase `division` for the column name to ensure proper case sensitivity. Do use double quotes `\"AS\"` instead of single quotes `'AS'` for the string literal to maintain consistency with the right SQL format. The amended query now correctly counts records from the DEPARTMENT table where the Division column equals \"AS\", matching the behavior of the right SQL."
        ],
        "rules": [
            "1) When referencing the department table: use the exact identifier \"DEPARTMENT\" instead of \"departments\" to match the schema. 2) When filtering by division: use the exact column identifier \"Division\" (case-sensitive) instead of \"division\". 3) When comparing to the literal value AS: use double quotes \"AS\" instead of single quotes 'AS' to maintain proper SQL format. 4) When counting departments in division AS: count records from the DEPARTMENT table where Division equals \"AS\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM departments WHERE division = 'AS';",
            "SELECT COUNT(*) FROM DEPARTMENT WHERE Division = \"AS\";"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM DEPARTMENT WHERE Division = \"AS\";"
        ]
    },
    "5150": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "What are the names of the drama workshop groups with address in Feliciaberg city?",
        "ground_truth": "SELECT T2.Store_Name FROM Addresses AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Address_ID  =  T2.Address_ID WHERE T1.City_Town  =  \"Feliciaberg\"",
        "amends": [
            "Do select `T2.Store_Name` instead of `name` and use `Drama_Workshop_Groups` as the source table instead of `workshop_groups`. Do add a `JOIN` with `Addresses AS T1` on `T1.Address_ID = T2.Address_ID` instead of querying a single table. Do filter on `T1.City_Town = \"Feliciaberg\"` instead of `city = 'Feliciaberg'` and remove the `type = 'comedy'` condition instead of keeping it. The amended query now correctly retrieves drama workshop groups from the appropriate table structure with proper address joining."
        ],
        "rules": [
            "1) When answering about drama workshop groups with address in Feliciaberg city: select T2.Store_Name as the output column instead of name. 2) When querying drama workshop groups: use the Drama_Workshop_Groups table (aliased as T2) instead of workshop_groups. 3) When combining address information with workshop groups: join Addresses (aliased as T1) with Drama_Workshop_Groups on T1.Address_ID = T2.Address_ID using an inner match. 4) When filtering for Feliciaberg city: use T1.City_Town = \"Feliciaberg\" instead of city = 'Feliciaberg'. 5) When the question asks for drama workshop groups: do not include any type = 'comedy' condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM workshop_groups WHERE city = 'Feliciaberg' AND type = 'comedy';",
            "SELECT T2.Store_Name \nFROM Drama_Workshop_Groups AS T2 \nJOIN Addresses AS T1 ON T1.Address_ID = T2.Address_ID \nWHERE T1.City_Town = 'Feliciaberg'"
        ],
        "rule_sql": [
            "SELECT T2.Store_Name \nFROM Drama_Workshop_Groups T2\nINNER JOIN Addresses T1 ON T1.Address_ID = T2.Address_ID\nWHERE T1.City_Town = \"Feliciaberg\""
        ]
    },
    "4205": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "What is the code of each role and the number of employees in each role?",
        "ground_truth": "SELECT role_code ,  count(*) FROM Employees GROUP BY role_code",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT role_code, COUNT(*) FROM employees GROUP BY role_code;"
        ],
        "rule_sql": [
            "SELECT r.Role_Code, COUNT(e.Employee_ID) AS Number_of_Employees FROM Roles r LEFT JOIN Employees e ON r.Role_Code = e.Role_Code GROUP BY r.Role_Code ORDER BY r.Role_Code;"
        ]
    },
    "5965": {
        "db_id": "cre_Theme_park",
        "question": "What are the names of tourist attraction that Alison visited but Rosalind did not visit?",
        "ground_truth": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  \"Alison\" EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  \"Rosalind\"",
        "amends": [
            "Do use `EXCEPT` set operation instead of multiple joins with same-table aliases. Do select from `Tourist_Attractions` as `T1` instead of `tourist_attractions` as `t`. Do join `VISITORS` as `T2` and `VISITS` as `T3` instead of separate joins with aliases `v1`, `vis1`, `v2`, `vis2`. Do use join condition `T1.Tourist_Attraction_ID = T3.Tourist_Attraction_ID` instead of `t.id = v1.attraction_id`. Do use join condition `T2.Tourist_ID = T3.Tourist_ID` instead of `v1.visitor_id = vis1.id`. Do filter on `T2.Tourist_Details = \"Alison\"` instead of `vis1.name = 'Alison'`. Do add a second query with `WHERE T2.Tourist_Details = \"Rosalind\"` and use `EXCEPT` instead of filtering both conditions in the same WHERE clause. Do use column `Tourist_Attraction_ID` and `Tourist_ID` instead of `id` and `attraction_id`. The amended query now correctly finds attractions visited by Alison but not Rosalind using set operations instead of incorrect join logic."
        ],
        "rules": [
            "1) When selecting from the Tourist_Attractions table: use alias T1 instead of t or other aliases. 2) When joining with VISITORS table: use alias T2 and join condition T2.Tourist_ID = T3.Tourist_ID. 3) When joining with VISITS table: use alias T3 and join condition T1.Tourist_Attraction_ID = T3.Tourist_Attraction_ID. 4) When filtering for Alison: use condition T2.Tourist_Details = \"Alison\" exactly as specified. 5) When filtering for Rosalind: use condition T2.Tourist_Details = \"Rosalind\" exactly as specified. 6) When finding attractions visited by one person but not another: use EXCEPT set operation between two queries instead of multiple joins with same-table aliases. 7) When referencing identifiers: use exact column names Tourist_Attraction_ID and Tourist_ID instead of id and attraction_id."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.name \nFROM tourist_attractions t\nJOIN visits v1 ON t.id = v1.attraction_id\nJOIN visitors vis1 ON v1.visitor_id = vis1.id\nJOIN visits v2 ON t.id = v2.attraction_id\nJOIN visitors vis2 ON v2.visitor_id = vis2.id\nWHERE vis1.name = 'Alison' AND vis2.name = 'Rosalind';",
            "SELECT T1.Name\nFROM Tourist_Attractions T1\nJOIN Visits T3 ON T1.Tourist_Attraction_ID = T3.Tourist_Attraction_ID\nJOIN Visitors T2 ON T2.Tourist_ID = T3.Tourist_ID\nWHERE T2.Tourist_Details = 'Alison'\nEXCEPT\nSELECT T1.Name\nFROM Tourist_Attractions T1\nJOIN Visits T3 ON T1.Tourist_Attraction_ID = T3.Tourist_Attraction_ID\nJOIN Visitors T2 ON T2.Tourist_ID = T3.Tourist_ID\nWHERE T2.Tourist_Details = 'Rosalind'"
        ],
        "rule_sql": [
            "SELECT T1.Name\nFROM Tourist_Attractions T1\nJOIN Visits T3 ON T1.Tourist_Attraction_ID = T3.Tourist_Attraction_ID\nJOIN Visitors T2 ON T2.Tourist_ID = T3.Tourist_ID\nWHERE T2.Tourist_Details = \"Alison\"\nEXCEPT\nSELECT T1.Name\nFROM Tourist_Attractions T1\nJOIN Visits T3 ON T1.Tourist_Attraction_ID = T3.Tourist_Attraction_ID\nJOIN Visitors T2 ON T2.Tourist_ID = T3.Tourist_ID\nWHERE T2.Tourist_Details = \"Rosalind\""
        ]
    },
    "5485": {
        "db_id": "voter_2",
        "question": "What are the first names and last names of the students who are 18 years old and have vice president votes.",
        "ground_truth": "SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  18",
        "amends": [
            "Do select `Fname` and `LName` with `DISTINCT` instead of `first_name` and `last_name` without distinct. Do join `STUDENT` with `VOTING_RECORD` on `StuID = VICE_President_VOTE` instead of querying only the `students` table. Do filter on `age = 18` instead of both `age = 18 AND votes = 'vice president'`. Do remove the incorrect filter condition on `votes` column and instead use the join condition to properly connect students with their vice president voting records. The amended query now correctly identifies students who received vice president votes by joining the appropriate tables with the correct relationship."
        ],
        "rules": [
            "1) When the question asks for first names and last names: use \"Fname\" and \"LName\" columns from table \"Student\" with DISTINCT to avoid duplicates. 2) When identifying students who are 18 years old: filter on \"age = 18\" condition. 3) When identifying students who have vice president votes: join table \"Student\" (as T1) with table \"VOTING_RECORD\" (as T2) where T1.\"StuID\" = T2.\"VICE_President_VOTE\" to establish the relationship between students and their vice president voting records. 4) When combining tables for this query: perform an inner join to keep only students who have matching vice president voting records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM students WHERE age = 18 AND votes = 'vice president';",
            "SELECT DISTINCT s.Fname, s.LName\nFROM Student s\nJOIN Voting_record vr ON s.StuID = vr.Vice_President_Vote\nWHERE s.Age = 18"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Fname, T1.LName FROM Student T1 INNER JOIN Voting_record T2 ON T1.StuID = T2.Vice_President_Vote WHERE T1.Age = 18"
        ]
    },
    "1380": {
        "db_id": "college_2",
        "question": "Who is the instructor with the highest salary?",
        "ground_truth": "SELECT name FROM instructor ORDER BY salary DESC LIMIT 1",
        "amends": [
            "Do use table name `instructor` instead of `instructors`. Do use `ORDER BY salary DESC` instead of `ORDER BY salary ASC` to sort by highest salary rather than lowest salary. The amended query now correctly retrieves the instructor with the highest salary, matching the intended behavior.",
            "Do select only `name` instead of all columns with `*`. Do maintain the same `ORDER BY salary DESC` and `LIMIT 1` to retrieve the highest-paid instructor's name. The amended query now correctly returns only the instructor name instead of all columns while preserving the same ranking and limiting behavior."
        ],
        "rules": [
            "1) When the question asks about instructors: use the exact table name \"instructor\" instead of \"instructors\". 2) When the question asks for the \"highest salary\": sort by the salary column in descending order (DESC) rather than ascending order (ASC). 3) When answering about \"Who is the instructor with the highest salary\": make sure the output order: name.",
            "1) When answering about \"Who is the instructor with the highest salary?\": make sure the output order: name. 2) When the question mentions \"highest salary\": rank rows by salary in descending order and keep the first 1 row. 3) When selecting output columns: use only name instead of all columns with *."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM instructors ORDER BY salary ASC LIMIT 1;",
            "SELECT * FROM instructor ORDER BY salary DESC LIMIT 1;",
            "SELECT name FROM instructor ORDER BY salary DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT name FROM instructor ORDER BY salary DESC LIMIT 1;"
        ]
    },
    "1507": {
        "db_id": "insurance_and_eClaims",
        "question": "List the names of all the customers in alphabetical order.",
        "ground_truth": "SELECT customer_details FROM customers ORDER BY customer_details",
        "amends": [
            "Do select `customer_details` instead of `name` from the customers table. Do use default ascending order instead of `DESC` descending order. The amended query now correctly retrieves customer details in alphabetical order as specified."
        ],
        "rules": [
            "1) When selecting customer names from the customers table: use the exact column name \"customer_details\" instead of \"name\". 2) When ordering customer names alphabetically: use ascending order instead of descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM customers ORDER BY name DESC;",
            "SELECT Customer_Details FROM Customers ORDER BY Customer_Details ASC;"
        ],
        "rule_sql": [
            "SELECT Customer_Details FROM Customers ORDER BY Customer_Details ASC;"
        ]
    },
    "1500": {
        "db_id": "debate",
        "question": "Show the distinct venues of debates",
        "ground_truth": "SELECT DISTINCT Venue FROM debate",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate venue entries. Do reference the table as `debate` instead of `debates` to match the correct table name. Do capitalize `Venue` instead of `venue` to match the correct column name case. The amended query now correctly returns unique venue values from the debate table."
        ],
        "rules": [
            "1) When the question asks for \"distinct venues\": use DISTINCT to eliminate duplicate entries from the \"Venue\" column. 2) When referencing the debate table: use the exact table name \"debate\" instead of \"debates\". 3) When selecting the venue column: use the exact column name \"Venue\" with proper capitalization as shown in the schema. 4) When answering about \"venues of debates\": make sure the output order: \"Venue\" values from the debate table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT venue FROM debates",
            "SELECT DISTINCT Venue FROM debate;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Venue FROM debate ORDER BY Venue;"
        ]
    },
    "2268": {
        "db_id": "entrepreneur",
        "question": "What are the companies and investors that correspond to each entrepreneur?",
        "ground_truth": "SELECT Company ,  Investor FROM entrepreneur",
        "amends": [
            "Do select `Company` and `Investor` columns instead of `entrepreneur`, `company`, and `investor`. Do use a single table `entrepreneur` instead of joining multiple tables `entrepreneurs`, `companies`, and `investors`. Do remove all JOIN conditions and relationships instead of including them. The amended query now correctly retrieves only company and investor data from the entrepreneur table as specified."
        ],
        "rules": [
            "1) When answering about companies and investors for each entrepreneur: make sure the output order: Company, Investor. 2) When the question mentions \"companies\": \"companies\" actually means \"Company\" column in the entrepreneur table. 3) When the question mentions \"investors\": \"investors\" actually means \"Investor\" column in the entrepreneur table. 4) When retrieving data from the entrepreneur table: use only the single table entrepreneur without any joins to other tables. 5) When selecting columns: include exactly \"Company\" and \"Investor\" columns from the entrepreneur table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT entrepreneur, company, investor FROM entrepreneurs JOIN companies ON entrepreneurs.id = companies.entrepreneur_id JOIN investors ON companies.id = investors.company_id",
            "SELECT Company, Investor FROM entrepreneur;"
        ],
        "rule_sql": [
            "SELECT Company, Investor FROM entrepreneur;"
        ]
    },
    "5408": {
        "db_id": "shop_membership",
        "question": "List all open years when at least two shops are opened.",
        "ground_truth": "SELECT open_year FROM branch GROUP BY open_year HAVING count(*)  >=  2",
        "amends": [
            "Do use `open_year` instead of `year` in the SELECT list and GROUP BY clause. Do reference the `branch` table instead of the `shops` table. Do remove the `WHERE status = 'open'` filter instead of keeping it, as the filtering logic is now handled by the table selection. Do use `count(*) >= 2` in the HAVING clause instead of `shop_count >= 2` since the alias is no longer defined. The amended query now correctly counts branches grouped by their opening year and filters for years with at least two branches, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"open years when at least two shops are opened\": make sure the output order: open_year first, then count. 2) When the question mentions \"shops\": \"shops\" actually means \"branch in schema\". 3) When the question asks for \"count of shops\": compute the number of rows using count(*) from the branch table. 4) When the question says \"per year\"/\"by year\": organize results by open_year and compute count per group. 5) When the question asks for \"at least two\": filter groups where count(*) >= 2. 6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, COUNT(*) as shop_count FROM shops WHERE status = 'open' GROUP BY year HAVING shop_count >= 2",
            "SELECT open_year FROM branch GROUP BY open_year HAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT \"Open_year\", COUNT(*) AS count FROM \"branch\" GROUP BY \"Open_year\" HAVING COUNT(*) >= 2 ORDER BY \"Open_year\", count;"
        ]
    },
    "696": {
        "db_id": "customers_card_transactions",
        "question": "Return the phone and email of the customer with the first name Aniyah and last name Feest.",
        "ground_truth": "SELECT customer_phone ,  customer_email FROM Customers WHERE customer_first_name  =  \"Aniyah\" AND customer_last_name  =  \"Feest\"",
        "amends": [
            "Do use column names `customer_phone` and `customer_email` instead of `phone` and `email`. Do change the logical operator to `AND` instead of `OR` between the name conditions. Do use table name `Customers` instead of `customers`. Do use double quotes around string literals instead of single quotes. The amended query now correctly filters for customers who have both first name 'Aniyah' and last name 'Feest' instead of either condition, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for phone and email: use the exact column names \"customer_phone\" and \"customer_email\" from the Customers table. 2) When filtering for a customer with first name Aniyah and last name Feest: use the logical operator AND between the name conditions instead of OR. 3) When referring to the table containing customer information: use the exact table name \"Customers\" with proper casing. 4) When using string literals for names: use double quotes around \"Aniyah\" and \"Feest\" instead of single quotes. 5) When combining name conditions: ensure both first name equals \"Aniyah\" AND last name equals \"Feest\" must be true for the same customer row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT phone, email FROM customers WHERE first_name = 'Aniyah' OR last_name = 'Feest';",
            "SELECT customer_phone, customer_email FROM Customers WHERE customer_first_name = \"Aniyah\" AND customer_last_name = \"Feest\""
        ],
        "rule_sql": [
            "SELECT customer_phone, customer_email FROM Customers WHERE customer_first_name = \"Aniyah\" AND customer_last_name = \"Feest\""
        ]
    },
    "1823": {
        "db_id": "small_bank_1",
        "question": "What are the names of customers who have a savings balance lower than their checking balance, and what is the total of their checking and savings balances?",
        "ground_truth": "SELECT T1.name ,  T3.balance + T2.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid WHERE T3.balance  <  T2.balance",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `c` and `s`. Do reference columns `T1.name`, `T3.balance`, and `T2.balance` instead of `c.name`, `s.balance`, and `c.balance`. Do join three tables `accounts AS T1`, `checking AS T2`, and `savings AS T3` instead of only two tables `customers` and `savings`. Do use join conditions `T1.custid = T2.custid` and `T1.custid = T3.custid` instead of `c.customer_id = s.customer_id`. Do apply the filter `T3.balance < T2.balance` instead of `s.balance < c.balance`. Do omit the column alias `total_balance` instead of including it. The amended query now correctly joins all three required tables and compares the appropriate balance columns to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about customer names and balance totals: use columns T1.name, (T2.balance + T3.balance) in the output order. 2) When combining accounts, checking, and savings tables: link rows where T1.custid = T2.custid and T1.custid = T3.custid, keeping only matching pairs (inner match). 3) When filtering for savings balance lower than checking balance: apply the condition T3.balance < T2.balance. 4) When computing total balances: calculate the sum of T2.balance and T3.balance without using a column alias."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name, (s.balance + c.balance) AS total_balance\nFROM customers c\nJOIN savings s ON c.customer_id = s.customer_id\nWHERE s.balance < c.balance",
            "SELECT T1.name, T3.balance + T2.balance \nFROM ACCOUNTS AS T1\nJOIN CHECKING AS T2 ON T1.custid = T2.custid\nJOIN SAVINGS AS T3 ON T1.custid = T3.custid\nWHERE T3.balance < T2.balance"
        ],
        "rule_sql": [
            "SELECT T1.name, (T2.balance + T3.balance) FROM ACCOUNTS T1 JOIN CHECKING T2 ON T1.custid = T2.custid JOIN SAVINGS T3 ON T1.custid = T3.custid WHERE T3.balance < T2.balance"
        ]
    },
    "103": {
        "db_id": "student_assessment",
        "question": "What are all info of students who registered courses but not attended courses?",
        "ground_truth": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)",
        "amends": [
            "Do query from `student_course_registrations` instead of `students` to use the correct source table. Do remove the `IN (SELECT student_id FROM registrations)` filter instead of keeping it since the table already contains only registered students. Do change the NOT IN subquery to reference `student_course_attendance` instead of `attendance` to use the correct attendance table. Do eliminate the redundant registration check since the main table already contains registration records, focusing only on finding students who haven't attended courses. The amended query now correctly identifies students registered for courses but without attendance records.",
            "Do select all columns from `student_course_registrations` instead of selecting `s.*` from `Students` with a `DISTINCT` modifier. Do use a single table `student_course_registrations` as the source instead of joining `Students` with `Student_Course_Registrations` on `s.student_id = scr.student_id`. Do remove the unnecessary `DISTINCT` modifier in both the outer query and the subquery instead of keeping redundant distinct operations. Do maintain the `NOT IN` subquery filtering for `student_id` values not present in `student_course_attendance` but simplify it by removing the `DISTINCT` keyword. The amended query now correctly identifies student course registrations where students have no attendance records, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When querying about students who registered courses but not attended courses: use the \"student_course_registrations\" table as the main source instead of \"students\" table. 2) When the table already contains only registered students: do not add an additional filter for registration status. 3) When checking for non-attendance: reference the \"student_course_attendance\" table instead of \"attendance\" table. 4) When identifying students without attendance records: use the condition that student_id from student_course_registrations should not exist in student_course_attendance table.",
            "1) When answering about \"all info of students who registered courses but not attended courses\": make sure to select all columns from \"student_course_registrations\" table instead of selecting from \"Students\" table. 2) When the question involves students who registered courses: use \"student_course_registrations\" as the main table instead of joining with \"Students\" table. 3) When filtering for students who have not attended courses: use a NOT IN subquery that checks for \"student_id\" values not present in \"student_course_attendance\" table. 4) When using NOT IN subqueries: do not include unnecessary DISTINCT modifiers in either the outer query or the subquery. 5) When combining information about registrations and attendance: the relationship is established through \"student_id\" column which serves as a foreign key from \"student_course_attendance\" to \"student_course_registrations\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM students WHERE student_id IN (SELECT student_id FROM registrations) AND student_id NOT IN (SELECT student_id FROM attendance);",
            "SELECT DISTINCT s.* \nFROM Students s\nJOIN Student_Course_Registrations scr ON s.student_id = scr.student_id\nWHERE s.student_id NOT IN (\n    SELECT DISTINCT student_id \n    FROM Student_Course_Attendance\n)",
            "SELECT * FROM Student_Course_Registrations WHERE student_id NOT IN (SELECT student_id FROM Student_Course_Attendance)"
        ],
        "rule_sql": [
            "SELECT * FROM Student_Course_Registrations WHERE student_id NOT IN (SELECT student_id FROM Student_Course_Attendance)"
        ]
    },
    "654": {
        "db_id": "journal_committee",
        "question": "What is the name of the youngest editor?",
        "ground_truth": "SELECT Name FROM editor ORDER BY Age ASC LIMIT 1",
        "amends": [
            "Do reference the `Name` column instead of `name` to match the correct column name. Do reference the `editor` table instead of `editors` to use the correct table name. Do reference the `Age` column instead of `age` to match the correct column name in the ORDER BY clause. The amended query now correctly selects from the editor table with proper column capitalization and matches the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"name\": use the exact column token \"Name\" from the editor table. 2) When the question asks about \"youngest\": order by the exact column token \"Age\" in ascending order and take the first row. 3) When referencing the table containing editor information: use the exact table name \"editor\" (not \"editors\"). 4) When selecting from the editor table: ensure proper capitalization of column names \"Name\" and \"Age\" as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM editors ORDER BY age ASC LIMIT 1;",
            "SELECT Name FROM editor ORDER BY Age ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name FROM editor ORDER BY Age ASC LIMIT 1;"
        ]
    },
    "5000": {
        "db_id": "soccer_2",
        "question": "Find the name of all students who were in the tryout sorted in alphabetic order.",
        "ground_truth": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName",
        "amends": [
            "Do select `T1.pName` from the `player` table instead of `name` from `students`. Do join with `tryout AS T2` on `T1.pID = T2.pID` instead of filtering with `WHERE tryout = 'yes'`. Do order by `T1.pName` instead of `name ASC`. The amended query now correctly retrieves player names from the player table who have tryout records, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"students who were in the tryout\": select \"T1.pName\" from the \"player\" table instead of \"name\" from \"students\". 2) When combining player and tryout tables: link rows where \"T1.pID\" = \"T2.pID\" to find players with tryout records. 3) When ordering results alphabetically: sort by \"T1.pName\" in ascending order. 4) When the question asks for \"students\": recognize that this refers to players in the \"player\" table with \"pName\" as the name column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM students WHERE tryout = 'yes' ORDER BY name ASC;",
            "SELECT T1.pName FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID ORDER BY T1.pName"
        ],
        "rule_sql": [
            "SELECT T1.pName \nFROM Player T1\nJOIN Tryout T2 ON T1.pID = T2.pID\nORDER BY T1.pName ASC"
        ]
    },
    "5259": {
        "db_id": "music_2",
        "question": "What is the first name of the band mate who perfomed in the most songs?",
        "ground_truth": "SELECT t2.firstname FROM Performance AS t1 JOIN Band AS t2 ON t1.bandmate  =  t2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId GROUP BY firstname ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `t2.firstname` from the `Band` table instead of `first_name` from an unspecified source. Do join `Performance AS t1` to `Band AS t2` on `t1.bandmate = t2.id` and join `Songs AS T3` on `T3.SongId = T1.SongId` instead of querying a single `band_mates` table without proper joins. Do add `GROUP BY firstname` to aggregate by band member instead of ordering by an ungrouped aggregate. Do use `count(*)` to count performances instead of `COUNT(song_id)` which would count distinct songs. The amended query now correctly identifies the band member with the most song performances by joining the performance, band, and songs tables, grouping by band member, and counting performances."
        ],
        "rules": [
            "1) When answering about \"first name of the band mate who performed in the most songs\": make sure the output order: t2.firstname. 2) When the question mentions \"band mate\": \"band mate\" actually means \"t2.id in schema\" through the join t1.bandmate = t2.id. 3) When combining Performance AS t1 and Band AS t2 for shared entities: link rows where t1.bandmate = t2.id exactly as shown in the amends; keep only matching pairs (inner match). 4) When combining Performance AS t1 and Songs AS T3 for shared entities: link rows where T3.SongId = T1.SongId exactly as shown in the amends; keep only matching pairs (inner match). 5) When the question asks for \"count of performances\": compute the number of rows using count(*) to count all performances. 6) When the question asks for \"most songs\" performed: rank rows by count(*) in descending direction and keep the first 1 row. 7) When the question says \"per band mate\"/\"by band mate\": organize results by t2.firstname and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM band_mates ORDER BY COUNT(song_id) DESC LIMIT 1;",
            "SELECT t2.Firstname\nFROM Performance AS t1\nJOIN Band AS t2 ON t1.Bandmate = t2.Id\nJOIN Songs AS t3 ON t3.SongId = t1.SongId\nGROUP BY t2.Firstname\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t2.firstname\nFROM Performance AS t1\nJOIN Band AS t2 ON t1.bandmate = t2.id\nGROUP BY t2.id, t2.firstname\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "6297": {
        "db_id": "city_record",
        "question": "Which cities have regional population above 10000000?",
        "ground_truth": "SELECT city FROM city WHERE regional_population  >  10000000",
        "amends": [
            "Do reference the `city` column instead of `city_name` and use the `city` table instead of `cities`. Do filter on `regional_population > 10000000` instead of `population > 10000000` to correctly apply the population threshold to the regional rather than city-specific population metric. The amended query now matches the intended behavior of selecting cities based on regional population criteria."
        ],
        "rules": [
            "1) When the question mentions \"cities\": use the table \"city\" instead of \"cities\". 2) When the question asks for city names: use the column \"city\" instead of \"city_name\". 3) When the question specifies \"regional population above 10000000\": filter using \"regional_population > 10000000\" instead of \"population > 10000000\" to apply the threshold to the regional population metric."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city_name FROM cities WHERE population > 10000000;",
            "SELECT City FROM city WHERE Regional_Population > 10000000"
        ],
        "rule_sql": [
            "SELECT City FROM city WHERE Regional_Population > 10000000"
        ]
    },
    "234": {
        "db_id": "musical",
        "question": "How many actors are there?",
        "ground_truth": "SELECT count(*) FROM actor",
        "amends": [
            "Do select from `actor` table instead of `movies` table. The amended query now correctly counts records from the intended actor table rather than the movies table."
        ],
        "rules": [
            "1) When answering about \"how many actors\": make sure to count from the \"actor\" table instead of the \"movies\" table. 2) When counting entities: use the canonical key for counting (typically the primary key of the table being counted)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies;",
            "SELECT COUNT(*) FROM actor;"
        ],
        "rule_sql": [
            "SELECT COUNT(Actor_ID) FROM actor;"
        ]
    },
    "2973": {
        "db_id": "sakila_1",
        "question": "Return the titles of any movies with an R rating.",
        "ground_truth": "SELECT title FROM film WHERE rating  =  'R'",
        "amends": [
            "Do reference table `film` instead of `movies` in the FROM clause. Do filter for rating `'R'` instead of `'PG'` in the WHERE condition. The amended query now correctly selects titles from the film table with an R rating instead of incorrectly querying a non-existent movies table with PG rating."
        ],
        "rules": [
            "1) When the question asks about movies: use the table \"film\" instead of \"movies\" as the source table. 2) When filtering by rating: use the exact literal value 'R' (with uppercase R and single quotes) instead of 'PG' to filter for R-rated movies. 3) When selecting movie titles: extract the \"title\" column from the \"film\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM movies WHERE rating = 'PG'",
            "SELECT title FROM film WHERE rating = 'R';"
        ],
        "rule_sql": [
            "SELECT title FROM film WHERE rating = 'R';"
        ]
    },
    "6769": {
        "db_id": "activity_1",
        "question": "How many faculty members participate in an activity?",
        "ground_truth": "SELECT count(DISTINCT FacID) FROM Faculty_participates_in",
        "amends": [
            "Do count `DISTINCT FacID` instead of counting all rows with `COUNT(*)`. Do use table `Faculty_participates_in` instead of `faculty`. Do remove the `WHERE activity_id IS NOT NULL` filter instead of keeping it, as the correct logic counts distinct faculty IDs from the participation table without filtering. The amended query now correctly counts unique faculty members who participate in activities rather than counting all non-null activity records in the faculty table."
        ],
        "rules": [
            "1) When counting faculty members who participate in activities: count distinct \"FacID\" values from the \"Faculty_participates_in\" table instead of counting all rows. 2) When the question asks about faculty participation: use the \"Faculty_participates_in\" table rather than the \"faculty\" table. 3) When counting participants: do not apply any filtering condition on activity_id, as the participation table inherently contains only participation records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM faculty WHERE activity_id IS NOT NULL;",
            "SELECT COUNT(DISTINCT FacID) FROM Faculty_Participates_in"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT FacID) FROM Faculty_Participates_in;"
        ]
    },
    "450": {
        "db_id": "allergy_1",
        "question": "What is allergy type of a cat allergy?",
        "ground_truth": "SELECT allergytype FROM Allergy_type WHERE allergy  =  \"Cat\"",
        "amends": [
            "Do reference the table as `Allergy_type` instead of `allergies` and select the column `allergytype` instead of `allergy_type`. Do filter on the condition `allergy = \"Cat\"` instead of `animal = 'cat'` to correctly query the intended data model. The amended query now matches the RIGHT_SQL's behavior by properly accessing the correct table structure and filtering criteria."
        ],
        "rules": [
            "1) When the question mentions \"allergy type\": \"allergy type\" actually means \"allergytype in schema\". 2) When the question mentions \"cat allergy\": filter rows where the exact literal \"Cat\" matches the \"allergy\" column. 3) When answering about \"allergy type of a cat allergy\": make sure the output order: allergytype. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 5) When handling text literals: do not change case, spacing, or punctuation - use exact literal \"Cat\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT allergy_type FROM allergies WHERE animal = 'cat';",
            "SELECT allergytype FROM Allergy_Type WHERE allergy = 'Cat';"
        ],
        "rule_sql": [
            "SELECT AllergyType FROM Allergy_Type WHERE Allergy = \"Cat\";"
        ]
    },
    "2188": {
        "db_id": "formula_1",
        "question": "For each nationality, how many different constructors are there?",
        "ground_truth": "SELECT count(*) ,  nationality FROM constructors GROUP BY nationality",
        "amends": [
            "Do place the `count(*)` column first in the SELECT list instead of having `nationality` first. Do maintain the same `GROUP BY nationality` clause instead of changing the grouping logic. The amended query now correctly matches the RIGHT_SQL's behavior with the proper column order while preserving the same aggregation logic."
        ],
        "rules": [
            "1) When answering about \"how many different constructors are there per nationality\": make sure the output order: count first, then nationality. 2) When the question asks for \"count of constructors per nationality\": compute the number of rows using the canonical key for constructors (constructorId) and group by the exact token \"nationality\". 3) When producing output columns: place the count column before the nationality column in the result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT nationality, COUNT(*) FROM constructors GROUP BY nationality;",
            "SELECT COUNT(*) AS constructor_count, nationality FROM constructors GROUP BY nationality"
        ],
        "rule_sql": [
            "SELECT COUNT(constructorId) AS count, nationality FROM constructors GROUP BY nationality ORDER BY count DESC, nationality;"
        ]
    },
    "3225": {
        "db_id": "college_1",
        "question": "how many schools exist in total?",
        "ground_truth": "SELECT count(DISTINCT school_code) FROM department",
        "amends": [
            "Do select `count(DISTINCT school_code)` instead of `COUNT(*)`. Do query from `department` instead of `students`. Do add the `DISTINCT` modifier for counting unique values instead of counting all rows. The amended query now correctly counts distinct school codes from the department table instead of counting all student records."
        ],
        "rules": [
            "1) When counting schools: count distinct \"school_code\" values instead of counting all rows. 2) When answering about schools: use the \"department\" table instead of the \"students\" table. 3) When the question asks \"how many schools exist in total\": compute the number of unique \"school_code\" values from the \"department\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;",
            "SELECT COUNT(DISTINCT SCHOOL_CODE) FROM DEPARTMENT;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT SCHOOL_CODE) FROM DEPARTMENT;"
        ]
    },
    "410": {
        "db_id": "flight_1",
        "question": "What destination has the fewest number of flights?",
        "ground_truth": "SELECT destination FROM Flight GROUP BY destination ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do reference the table as `Flight` instead of `flights` in the FROM clause. Do remove the explicit column alias `flight_count` instead of keeping it in the SELECT list. Do use `count(*)` directly in the ORDER BY clause instead of referencing the alias `flight_count`. The amended query now correctly identifies the destination with the fewest flights by counting records per destination and ordering by that count.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, and do remove the explicit `ASC` direction from the ORDER BY clause instead of specifying it, as the default ascending order is sufficient. The amended query now correctly returns only the destination column while maintaining the same grouping and ordering logic to find the destination with the lowest flight count."
        ],
        "rules": [
            "1) When answering about \"destination with fewest number of flights\": make sure the output order: destination, count(*) 2) When the question mentions \"destination\": \"destination\" actually means \"destination in schema\" 3) When the question asks for \"fewest number of flights\": rank rows by count(*) in ascending direction and keep the first 1 row 4) When the question asks for \"count of flights\": compute the number of rows using count(*) 5) When the question says \"per destination\"/\"by destination\": organize results by destination and compute count(*) per group 6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms 7) When handling text literals: do not change case, spacing, or punctuation 8) When producing output or grouping: do not reorder columns or grouping keys beyond what the question requires",
            "1) When answering about \"fewest number of flights per destination\": organize results by the exact token \"destination\" and compute the count of flights per group. 2) When counting flights: compute the number of rows using the canonical key for flights (exact token not specified in schema). 3) When the question asks for the destination with the fewest flights: rank destinations by flight count in ascending order and keep only the first row. 4) When producing output: make sure the output order includes only the \"destination\" column, not the count value."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT destination, COUNT(*) as flight_count FROM flights GROUP BY destination ORDER BY flight_count ASC LIMIT 1;",
            "SELECT destination, COUNT(*) FROM Flight GROUP BY destination ORDER BY COUNT(*) ASC LIMIT 1;",
            "SELECT destination FROM flight GROUP BY destination ORDER BY COUNT(*) LIMIT 1"
        ],
        "rule_sql": [
            "SELECT destination, COUNT(*) FROM flight GROUP BY destination ORDER BY COUNT(*) ASC LIMIT 1"
        ]
    },
    "5747": {
        "db_id": "dorm_1",
        "question": "What are the total number of students who are living in a male dorm?",
        "ground_truth": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'",
        "amends": [
            "Do add joins to `lives_in` and `dorm` tables instead of querying only the `students` table. Do use `JOIN` conditions `T1.stuid = T2.stuid` and `T3.dormid = T2.dormid` instead of missing these relationships entirely. Do filter on `T3.gender = 'M'` instead of the non-existent `dorm_gender` column. Do reference the correct table aliases `T1`, `T2`, and `T3` instead of the single table approach. The amended query now correctly counts students based on dorm gender by properly joining through the relationship tables."
        ],
        "rules": [
            "1) When answering about \"students living in a male dorm\": make sure to join the students table (T1) with the lives_in table (T2) using T1.stuid = T2.stuid, and then join with the dorm table (T3) using T3.dormid = T2.dormid. 2) When filtering for male dorms: use T3.gender = 'M' instead of any non-existent dorm_gender column. 3) When counting students: count using the canonical key T1.stuid to ensure accurate student counts. 4) When combining tables for this query: perform inner joins to keep only matching pairs between students, their dorm assignments, and dorm information."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE dorm_gender = 'male';",
            "SELECT COUNT(*) \nFROM Student T1\nJOIN Lives_in T2 ON T1.StuID = T2.stuid\nJOIN Dorm T3 ON T2.dormid = T3.dormid\nWHERE T3.gender = 'M'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.StuID) \nFROM Student T1\nINNER JOIN Lives_in T2 ON T1.StuID = T2.stuid\nINNER JOIN Dorm T3 ON T3.dormid = T2.dormid\nWHERE T3.gender = 'M'"
        ]
    },
    "6245": {
        "db_id": "ship_1",
        "question": "Count the number of ships.",
        "ground_truth": "SELECT count(*) FROM ship",
        "amends": [
            "Do query the `ship` table instead of the `airplanes` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)`. The amended query now correctly counts records from the ship table instead of the airplanes table."
        ],
        "rules": [
            "1) When counting ships: use the \"ship\" table instead of the \"airplanes\" table. 2) When counting all records: use lowercase \"count(*)\" to count all rows in the specified table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM airplanes;",
            "SELECT count(*) FROM Ship;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM Ship"
        ]
    },
    "3759": {
        "db_id": "program_share",
        "question": "Count the number of distinct channel owners.",
        "ground_truth": "SELECT count(DISTINCT OWNER) FROM channel",
        "amends": [
            "Do use `count(DISTINCT OWNER)` instead of `COUNT(owner)` to count unique owners rather than all occurrences. Do reference table `channel` instead of `channels` to use the correct table name. The amended query now correctly counts distinct owners from the proper table, matching the intended behavior."
        ],
        "rules": [
            "1) When counting distinct channel owners: use count(DISTINCT OWNER) to count unique values of the OWNER column rather than all occurrences. 2) When referencing the channels table: use the exact table name channel instead of channels to reference the correct table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(owner) FROM channels;",
            "SELECT COUNT(DISTINCT Owner) FROM channel;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Owner) FROM channel;"
        ]
    },
    "3230": {
        "db_id": "college_1",
        "question": "What are the number of different course codes?",
        "ground_truth": "SELECT count(DISTINCT crs_code) FROM CLASS",
        "amends": [
            "Do `count(DISTINCT crs_code)` instead of `COUNT(*)` to count unique course codes rather than all rows. Do use table `CLASS` instead of `courses` as the data source. Do remove the asterisk wildcard instead of keeping it to specifically target the course code column. The amended query now correctly counts distinct course codes from the CLASS table instead of counting all rows from the courses table."
        ],
        "rules": [
            "1) When counting different course codes: count distinct values of the exact column token \"crs_code\" from table \"CLASS\". 2) When the question asks for \"number of different course codes\": this means counting unique values in the \"crs_code\" column, not counting all rows. 3) When choosing the data source: use table \"CLASS\" instead of any other table name like \"courses\" to access the course code data."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM courses;",
            "SELECT COUNT(DISTINCT CRS_CODE) FROM CLASS;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT CRS_CODE) FROM CLASS;"
        ]
    },
    "5578": {
        "db_id": "products_gen_characteristics",
        "question": "What is the unit of measuerment of the product category code \"Herbs\"?",
        "ground_truth": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  \"Herbs\"",
        "amends": [
            "Do select from `ref_product_categories` instead of `products` to reference the correct table. Do use column `unit_of_measure` instead of `unit_of_measurement` to match the proper column name. Do filter on `product_category_code = \"Herbs\"` instead of `category = 'Herbs'` to use the correct filter column and value format. The amended query now correctly retrieves unit of measure data from the reference table using the appropriate category code filter."
        ],
        "rules": [
            "1) When answering about \"unit of measurement of the product category code 'Herbs'\": make sure the output order: unit_of_measure. 2) When the question mentions \"product category code\": \"product category code\" actually means \"product_category_code in schema\". 3) When the question mentions \"Herbs\": use the exact literal \"Herbs\" with double quotes as shown in the schema. 4) When selecting from reference tables: use table \"ref_product_categories\" instead of base product tables. 5) When referring to unit of measurement: use column \"unit_of_measure\" instead of \"unit_of_measurement\" to match the proper column name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT unit_of_measurement FROM products WHERE category = 'Herbs';",
            "SELECT unit_of_measure FROM Ref_Product_Categories WHERE product_category_code = 'Herbs';"
        ],
        "rule_sql": [
            "SELECT unit_of_measure FROM Ref_Product_Categories WHERE product_category_code = 'Herbs';"
        ]
    },
    "582": {
        "db_id": "store_1",
        "question": "In which country does Roberto Almeida?",
        "ground_truth": "SELECT country FROM customers WHERE first_name = \"Roberto\" AND last_name = \"Almeida\";",
        "amends": [
            "Do query the `customers` table instead of the `people` table. Do use double quotes for string literals \"Roberto\" and \"Almeida\" instead of single quotes 'Roberto' and 'Almeida'. The amended query now correctly selects from the customers table with proper string literal syntax, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about a person's country: query the \"customers\" table instead of the \"people\" table. 2) When using string literals \"Roberto\" and \"Almeida\": use double quotes instead of single quotes around these values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM people WHERE first_name = 'Roberto' AND last_name = 'Almeida';",
            "SELECT country FROM customers WHERE first_name = \"Roberto\" AND last_name = \"Almeida\";"
        ],
        "rule_sql": [
            "SELECT country FROM customers WHERE first_name = \"Roberto\" AND last_name = \"Almeida\";"
        ]
    },
    "3972": {
        "db_id": "hospital_1",
        "question": "Find the physicians who are trained in a procedure that costs more than 5000.",
        "ground_truth": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000",
        "amends": [
            "Do reference `T1.name` instead of `p.name` for the physician name. Do join `physician AS T1` instead of `physicians p` with corrected table naming. Do use `T1.employeeid = T2.physician` instead of `p.id = t.physician` for the join condition with proper column references. Do join `procedures AS T3` on `T3.code = T2.treatment` instead of `pr.code = t.procedure` with corrected join column naming. Do filter on `T3.cost > 5000` instead of `pr.cost > 5000` with proper table alias. The amended query now correctly matches the intended logic by fixing table aliases, column references, and join conditions to properly relate physicians to their trained procedures based on cost threshold."
        ],
        "rules": [
            "1) When answering about physicians trained in procedures costing more than 5000: make sure the output order: T1.name. 2) When combining physician table as T1 and trained_in table as T2: link rows where T1.employeeid = T2.physician and keep only matching pairs. 3) When combining T2 and procedures table as T3: link rows where T3.code = T2.treatment and keep only matching pairs. 4) When filtering for procedures costing more than 5000: include only rows where T3.cost > 5000."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.name FROM physicians p JOIN trained_in t ON p.id = t.physician JOIN procedures pr ON t.procedure = pr.code WHERE pr.cost > 5000",
            "SELECT T1.Name\nFROM Physician AS T1\nJOIN Trained_In AS T2 ON T1.EmployeeID = T2.Physician\nJOIN Procedures AS T3 ON T3.Code = T2.Treatment\nWHERE T3.Cost > 5000;"
        ],
        "rule_sql": [
            "SELECT T1.Name\nFROM Physician AS T1\nJOIN Trained_In AS T2 ON T1.EmployeeID = T2.Physician\nJOIN Procedures AS T3 ON T3.Code = T2.Treatment\nWHERE T3.Cost > 5000\nORDER BY T1.Name;"
        ]
    },
    "568": {
        "db_id": "store_1",
        "question": "What is the number of invoices and total money billed in them from CA?",
        "ground_truth": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  \"CA\";",
        "amends": [
            "Do add `billing_state` to the SELECT list instead of omitting it. Do remove the `invoice_count` and `total_billed` aliases instead of keeping them. Do change the WHERE filter from literal 'California' to 'CA' instead of using the full state name. The amended query now correctly groups by state code and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for invoices from CA: use the exact literal 'CA' instead of 'California' for filtering the billing_state column. 2) When the question asks for both count and total money: include billing_state in the output columns to show which state the results correspond to. 3) When computing aggregates: do not use aliases like invoice_count and total_billed in the output column names."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) as invoice_count, SUM(total) as total_billed FROM invoices WHERE billing_state = 'California';",
            "SELECT billing_state, COUNT(*) AS invoice_count, SUM(total) AS total_billed FROM invoices WHERE billing_state = 'CA' GROUP BY billing_state;"
        ],
        "rule_sql": [
            "SELECT billing_state, COUNT(*) AS count, SUM(total) AS total FROM invoices WHERE billing_state = 'CA' GROUP BY billing_state;"
        ]
    },
    "638": {
        "db_id": "store_1",
        "question": "What are the names of all playlists that have more than 100 tracks?",
        "ground_truth": "SELECT T2.name FROM playlist_tracks AS T1 JOIN playlists AS T2 ON T2.id = T1.playlist_id GROUP BY T1.playlist_id HAVING count(T1.track_id)  >  100;",
        "amends": [
            "Do select `T2.name` from the joined table instead of `Name` directly from the source table. Do join `playlist_tracks AS T1` with `playlists AS T2` on `T2.id = T1.playlist_id` instead of querying `playlists` alone. Do use `GROUP BY T1.playlist_id` to aggregate tracks per playlist instead of relying on a pre-calculated `TrackCount` column. Do apply the count filter with `HAVING count(T1.track_id) > 100` instead of `WHERE TrackCount > 100` to properly calculate the track count dynamically. The amended query now correctly calculates playlist track counts through aggregation rather than depending on a potentially stale stored value, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"names of playlists with more than 100 tracks\": make sure the output order: T2.name. 2) When the question mentions \"playlists\": join playlist_tracks AS T1 with playlists AS T2 on T2.id = T1.playlist_id using inner match. 3) When counting tracks per playlist: use GROUP BY T1.playlist_id to organize results by playlist. 4) When counting tracks: compute count(T1.track_id) as the number of tracks per playlist. 5) When filtering for playlists with more than 100 tracks: apply HAVING count(T1.track_id) > 100 after grouping."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Name FROM playlists WHERE TrackCount > 100;",
            "SELECT T2.name \nFROM playlist_tracks AS T1 \nJOIN playlists AS T2 ON T2.id = T1.playlist_id \nGROUP BY T1.playlist_id \nHAVING COUNT(T1.track_id) > 100"
        ],
        "rule_sql": [
            "SELECT T2.name \nFROM playlist_tracks AS T1 \nINNER JOIN playlists AS T2 ON T2.id = T1.playlist_id \nGROUP BY T1.playlist_id \nHAVING COUNT(T1.track_id) > 100 \nORDER BY T2.name"
        ]
    },
    "4217": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "What are the employee ids of the employees whose role name is \"Human Resource\" or \"Manager\"?",
        "ground_truth": "SELECT T1.employee_id FROM Employees AS T1 JOIN ROLES AS T2 ON T1.role_code  =  T2.role_code WHERE T2.role_name  =  \"Human Resource\" OR T2.role_name  =  \"Manager\"",
        "amends": [
            "Do join `Employees AS T1` with `ROLES AS T2` on `T1.role_code = T2.role_code` instead of querying only the employees table. Do filter with `T2.role_name = \"Human Resource\" OR T2.role_name = \"Manager\"` instead of the impossible condition `role_name = 'Human Resource' AND role_name = 'Manager'`. Do select `T1.employee_id` with proper table qualification instead of just `employee_id`. The amended query now correctly retrieves employees who have either Human Resource or Manager roles by properly joining with the roles table and using logical OR instead of contradictory AND conditions, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about employee roles: join Employees as T1 with ROLES as T2 on T1.role_code = T2.role_code to access role information. 2) When filtering for specific role names \"Human Resource\" or \"Manager\": use T2.role_name = \"Human Resource\" OR T2.role_name = \"Manager\" instead of contradictory AND conditions. 3) When selecting employee identifiers: use T1.employee_id with proper table qualification instead of unqualified column names. 4) When combining tables for role information: perform an inner match where T1.role_code equals T2.role_code to ensure only valid employee-role relationships are considered."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT employee_id FROM employees WHERE role_name = 'Human Resource' AND role_name = 'Manager'",
            "SELECT T1.Employee_ID FROM Employees AS T1 JOIN Roles AS T2 ON T1.Role_Code = T2.Role_Code WHERE T2.Role_Name = 'Human Resource' OR T2.Role_Name = 'Manager'"
        ],
        "rule_sql": [
            "SELECT T1.Employee_ID \nFROM Employees AS T1\nINNER JOIN Roles AS T2 ON T1.Role_Code = T2.Role_Code\nWHERE T2.Role_Name = 'Human Resource' OR T2.Role_Name = 'Manager'"
        ]
    },
    "3052": {
        "db_id": "loan_1",
        "question": "Find the name of customer who has the highest amount of loans.",
        "ground_truth": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id GROUP BY T1.cust_name ORDER BY sum(T2.amount) DESC LIMIT 1",
        "amends": [
            "Do select `T1.cust_name` instead of `name` and add aggregation with `sum(T2.amount)` instead of referencing `loan_amount` directly. Do join `customer AS T1` with `loan AS T2` on `T1.cust_id = T2.cust_id` instead of querying only the `customers` table. Do add `GROUP BY T1.cust_name` instead of omitting grouping. Do order by `sum(T2.amount) DESC` instead of `loan_amount DESC` to properly aggregate loan amounts per customer. The amended query now correctly calculates the customer with the highest total loan amount by joining customer and loan tables, grouping by customer name, and summing individual loan amounts."
        ],
        "rules": [
            "1) When answering about \"customer who has the highest amount of loans\": make sure the output order: T1.cust_name. 2) When the question mentions \"amount of loans\": \"amount of loans\" actually means \"sum(T2.amount) in schema\". 3) When the question mentions \"highest\": rank rows by sum(T2.amount) in descending direction and keep the first 1 row. 4) When combining T1 and T2 for shared entities: link rows where T1.cust_id = T2.cust_id; keep only matching pairs (inner match). 5) When the question asks for \"customer who has loans\": organize results by T1.cust_name and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM customers ORDER BY loan_amount DESC LIMIT 1;",
            "SELECT T1.cust_name\nFROM customer AS T1\nJOIN loan AS T2 ON T1.cust_ID = T2.cust_ID\nGROUP BY T1.cust_name\nORDER BY SUM(T2.amount) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT c.cust_name\nFROM customer c\nJOIN loan l ON c.cust_ID = l.cust_ID\nGROUP BY c.cust_name\nORDER BY SUM(l.amount) DESC\nLIMIT 1;"
        ]
    },
    "159": {
        "db_id": "bike_1",
        "question": "On which day and in which zip code was the min dew point lower than any day in zip code 94107?",
        "ground_truth": "SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  94107)",
        "amends": [
            "Do select `date` and `zip_code` instead of selecting `date`, `zip_code`, and `MIN(dew_point)`. Do use table `weather` instead of `weather_data`. Do use column `min_dew_point_f` instead of `dew_point` in the main filter. Do remove the `GROUP BY date, zip_code` clause instead of keeping it. Do remove the `ORDER BY dew_point ASC` clause instead of keeping it. Do remove the `LIMIT 1` clause instead of keeping it. Do use numeric value `94107` instead of string `'94107'` in the subquery. Do use aggregate `min(min_dew_point_f)` in the subquery instead of `MIN(dew_point)`. The amended query now correctly identifies records where the minimum dew point is below the minimum dew point for the specified zip code."
        ],
        "rules": [
            "1) When the question asks for \"date\" and \"zip code\": select columns \"date\" and \"zip_code\" from table \"weather\" (aliased as T1). 2) When comparing minimum dew point values: use column \"min_dew_point_f\" instead of \"dew_point\". 3) When filtering for records where minimum dew point is lower than any day in zip code 94107: use a subquery that finds the minimum \"min_dew_point_f\" value where \"zip_code\" equals 94107 (numeric value, not string). 4) When the question does not require aggregation by date and zip code: do not include GROUP BY clause. 5) When the question does not require ordering or limiting results: do not include ORDER BY or LIMIT clauses. 6) When referring to the weather table: use table name \"weather\" instead of \"weather_data\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT date, zip_code, MIN(dew_point) \nFROM weather_data \nWHERE dew_point < (SELECT MIN(dew_point) FROM weather_data WHERE zip_code = '94107')\nGROUP BY date, zip_code\nORDER BY dew_point ASC\nLIMIT 1;",
            "SELECT date, zip_code FROM weather WHERE min_dew_point_f < (SELECT MIN(min_dew_point_f) FROM weather WHERE zip_code = 94107)"
        ],
        "rule_sql": [
            "SELECT date, zip_code FROM weather WHERE min_dew_point_f < (SELECT MIN(min_dew_point_f) FROM weather WHERE zip_code = 94107)"
        ]
    },
    "4612": {
        "db_id": "entertainment_awards",
        "question": "Show the id, name of each festival and the number of artworks it has nominated.",
        "ground_truth": "SELECT T1.Festival_ID ,  T3.Festival_Name ,  COUNT(*) FROM nomination AS T1 JOIN artwork AS T2 ON T1.Artwork_ID  =  T2.Artwork_ID JOIN festival_detail AS T3 ON T1.Festival_ID  =  T3.Festival_ID GROUP BY T1.Festival_ID",
        "amends": [
            "Do use `nomination`, `artwork`, and `festival_detail` tables instead of `festivals` and `artworks`. Do join `nomination` with `artwork` on `Artwork_ID` instead of joining festivals with artworks directly. Do add `festival_detail` table joined on `Festival_ID` instead of omitting it. Do select `T1.Festival_ID` and `T3.Festival_Name` instead of `f.id` and `f.name`. Do use `COUNT(*)` instead of `COUNT(a.id)` to count all nominations. Do group by only `T1.Festival_ID` instead of both `f.id` and `f.name`. The amended query now correctly counts nominations per festival using the proper relationship tables."
        ],
        "rules": [
            "1) When answering about \"number of artworks nominated per festival\": use the nomination table as T1 to count nominations instead of directly counting artworks. 2) When the question mentions \"festival id\": select \"T1.Festival_ID\" instead of f.id. 3) When the question mentions \"festival name\": select \"T3.Festival_Name\" from festival_detail table instead of f.name. 4) When counting nominations per festival: use COUNT(*) to count all nomination records instead of counting artwork IDs. 5) When grouping by festival: group by only \"T1.Festival_ID\" instead of both id and name. 6) When combining tables for festival nominations: link nomination (T1) with artwork (T2) on \"T1.Artwork_ID = T2.Artwork_ID\" and with festival_detail (T3) on \"T1.Festival_ID = T3.Festival_ID\" using inner matches. 7) When handling identifier delimiters: do not replace double quotes with backticks or unquoted forms for columns like \"Artwork_ID\" and \"Festival_ID\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT f.id, f.name, COUNT(a.id) AS artwork_count\nFROM festivals f\nLEFT JOIN artworks a ON f.id = a.festival_id\nGROUP BY f.id, f.name",
            "SELECT fd.Festival_ID, fd.Festival_Name, COUNT(*) AS Number_of_Artworks\nFROM festival_detail fd\nJOIN nomination n ON fd.Festival_ID = n.Festival_ID\nGROUP BY fd.Festival_ID, fd.Festival_Name"
        ],
        "rule_sql": [
            "SELECT T1.Festival_ID, T3.Festival_Name, COUNT(*) AS Number_of_Nominated_Artworks FROM nomination AS T1 INNER JOIN festival_detail AS T3 ON T1.Festival_ID = T3.Festival_ID GROUP BY T1.Festival_ID"
        ]
    },
    "3024": {
        "db_id": "loan_1",
        "question": "Find the state, account type, and credit score of the customer whose number of loan is 0.",
        "ground_truth": "SELECT state ,  acc_type ,  credit_score FROM customer WHERE no_of_loans  =  0",
        "amends": [
            "Do reference the table as `customer` instead of `customers` to match the correct table name. Do use column alias `acc_type` instead of `account_type` to align with the actual column name. Do use column name `no_of_loans` instead of `number_of_loan` for the filter condition. The amended query now correctly references the customer table with proper column names while maintaining the same filtering logic for zero loans."
        ],
        "rules": [
            "1) When the question asks about customer information: use the table name \"customer\" exactly as specified in the schema, not \"customers\". 2) When the question mentions \"account type\": the exact column name is \"acc_type\" in the customer table. 3) When the question mentions \"number of loan\": the exact column name is \"no_of_loans\" in the customer table. 4) When filtering for customers with zero loans: use the condition no_of_loans = 0 to find customers with exactly zero loans."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT state, account_type, credit_score FROM customers WHERE number_of_loan = 0;",
            "SELECT state, acc_type, credit_score FROM customer WHERE no_of_loans = 0"
        ],
        "rule_sql": [
            "SELECT state, acc_type, credit_score FROM customer WHERE no_of_loans = 0;"
        ]
    },
    "6150": {
        "db_id": "music_4",
        "question": "Return the famous titles of the artist called \"Triumfall\".",
        "ground_truth": "SELECT Famous_Title FROM artist WHERE Artist  =  \"Triumfall\"",
        "amends": [
            "Do reference the `Famous_Title` column instead of `title` and use the `artist` table instead of `artists`. Do use the filter condition `Artist = \"Triumfall\"` instead of `name = 'Triumfall'` with proper double quotes for the string literal. The amended query now correctly retrieves the desired column from the specified table with the appropriate filtering condition."
        ],
        "rules": [
            "1) When answering about \"famous titles of the artist called Triumfall\": make sure the output order: Famous_Title. 2) When the question mentions \"artist called 'Triumfall'\": \"artist called 'Triumfall'\" actually means \"Artist = \\\"Triumfall\\\" in schema\". 3) When the question mentions \"famous titles\": \"famous titles\" actually means \"Famous_Title column in artist table\". 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for string literals like \\\"Triumfall\\\". 5) When handling text literals: do not change case, spacing, or punctuation for the exact value \\\"Triumfall\\\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM artists WHERE name = 'Triumfall';",
            "SELECT Famous_Title FROM artist WHERE Artist = \"Triumfall\";"
        ],
        "rule_sql": [
            "SELECT Famous_Title FROM artist WHERE Artist = \"Triumfall\";"
        ]
    },
    "3507": {
        "db_id": "hr_1",
        "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.",
        "ground_truth": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT employee_id, job_id FROM employees WHERE salary < (SELECT MIN(salary) FROM employees WHERE job_id = 'MK_MAN')"
        ],
        "rule_sql": [
            "SELECT e.EMPLOYEE_ID, e.JOB_ID\nFROM employees e\nWHERE e.SALARY < ANY (\n    SELECT e2.SALARY\n    FROM employees e2\n    JOIN jobs j ON e2.JOB_ID = j.JOB_ID\n    WHERE j.JOB_TITLE = 'MK_MAN'\n)",
            "SELECT e.EMPLOYEE_ID, e.JOB_ID\nFROM employees e\nWHERE e.SALARY < ANY (\n    SELECT e2.SALARY\n    FROM employees e2\n    JOIN jobs j ON e2.JOB_ID = j.JOB_ID\n    WHERE j.JOB_TITLE = 'MK_MAN'\n)"
        ]
    },
    "5199": {
        "db_id": "music_2",
        "question": "What is the last name of the musicians who has played back position the most?",
        "ground_truth": "SELECT T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id WHERE stageposition  =  \"back\" GROUP BY lastname ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.lastname` from the `Band` table instead of `last_name` from `musicians`. Do join `Performance AS T1` with `Band AS T2` on `T1.bandmate = T2.id` instead of querying a single table. Do add a WHERE filter for `stageposition = \"back\"` instead of omitting any filtering. Do add GROUP BY `lastname` and ORDER BY `count(*) DESC` to count performances instead of ordering by `back_position DESC`. Do maintain the `LIMIT 1` clause to return only the top result. The amended query now correctly identifies the band member with the most back stage performances instead of simply selecting the last name with the highest back position value."
        ],
        "rules": [
            "1) When answering about \"musicians who has played back position the most\": make sure the output order: T2.lastname. 2) When the question mentions \"musicians\": \"musicians\" actually means \"Band table (T2)\" in schema. 3) When combining Performance (T1) and Band (T2) for shared entities: link rows where T1.bandmate = T2.id exactly as shown in the amends; keep only matching pairs (inner match). 4) When filtering for back position: include only rows where T1.stageposition = \"back\" exactly as specified. 5) When counting performances per musician: organize results by T2.lastname and compute count(*) per group. 6) When the question asks for \"the most\": rank rows by count(*) in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM musicians ORDER BY back_position DESC LIMIT 1;",
            "SELECT T2.Lastname\nFROM Performance AS T1\nJOIN Band AS T2 ON T1.Bandmate = T2.Id\nWHERE T1.StagePosition = 'back'\nGROUP BY T2.Lastname\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Lastname\nFROM Performance T1\nINNER JOIN Band T2 ON T1.Bandmate = T2.Id\nWHERE T1.StagePosition = 'back'\nGROUP BY T2.Lastname\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "4133": {
        "db_id": "film_rank",
        "question": "Who are the different directors of films which had market estimation in 1995?",
        "ground_truth": "SELECT DISTINCT T1.Director FROM film AS T1 JOIN film_market_estimation AS T2 ON T1.Film_ID  =  T2.Film_ID WHERE T2.Year  =  1995",
        "amends": [
            "Do use `T1.Director` with table alias instead of `director` without qualification. Do join `film_market_estimation AS T2` with `ON T1.Film_ID = T2.Film_ID` instead of querying only the `films` table. Do filter on `T2.Year = 1995` instead of `market_estimation = 1995` to correctly reference the joined table's column. The amended query now properly joins tables and filters on the correct column to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"different directors of films with market estimation in 1995\": make sure the output order: T1.Director. 2) When the question mentions \"films which had market estimation in 1995\": this requires joining films table (T1) with film_market_estimation table (T2) using T1.Film_ID = T2.Film_ID to link the tables. 3) When filtering for market estimation year 1995: use T2.Year = 1995 exactly as specified. 4) When selecting directors: use T1.Director with table alias qualification instead of unqualified director. 5) When the question asks for \"different directors\": ensure distinct values of T1.Director are returned."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT director FROM films WHERE market_estimation = 1995;",
            "SELECT DISTINCT T1.Director\nFROM film AS T1\nJOIN film_market_estimation AS T2 ON T1.Film_ID = T2.Film_ID\nWHERE T2.Year = 1995"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Director\nFROM film T1\nJOIN film_market_estimation T2 ON T1.Film_ID = T2.Film_ID\nWHERE T2.Year = 1995\nORDER BY T1.Director;"
        ]
    },
    "107": {
        "db_id": "student_assessment",
        "question": "List the id of students who attended  statistics courses in the order of attendance date.",
        "ground_truth": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = \"statistics\" ORDER BY T2.date_of_attendance",
        "amends": [
            "Do select `T2.student_id` from the attendance table instead of `student_id` from the students table. Do join `courses AS T1` with `student_course_attendance AS T2` on `T1.course_id = T2.course_id` instead of querying only the students table. Do filter on `T1.course_name = \"statistics\"` through the courses table relationship instead of directly on a course_name field in students. Do order by `T2.date_of_attendance` from the attendance table instead of `attendance_date` from students. The amended query now correctly retrieves student attendance records by joining through the proper relational structure instead of assuming course information exists directly in the students table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"students who attended statistics courses\": make sure the output order: T2.student_id. 2) When the question mentions \"statistics courses\": \"statistics\" actually means T1.course_name = \"statistics\" in schema. 3) When combining T1 (courses) and T2 (student_course_attendance) for shared entities: link rows where T1.course_id = T2.course_id; keep only matching pairs (inner match). 4) When ordering by attendance date: order by T2.date_of_attendance from the attendance table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id FROM students WHERE course_name = 'statistics' ORDER BY attendance_date;",
            "SELECT T2.student_id\nFROM Student_Course_Attendance AS T2\nJOIN Courses AS T1 ON T1.course_id = T2.course_id\nWHERE T1.course_name = 'statistics'\nORDER BY T2.date_of_attendance;"
        ],
        "rule_sql": [
            "SELECT T2.student_id\nFROM Courses T1\nINNER JOIN Student_Course_Attendance T2 ON T1.course_id = T2.course_id\nWHERE T1.course_name = 'statistics'\nORDER BY T2.date_of_attendance"
        ]
    },
    "2230": {
        "db_id": "formula_1",
        "question": "For each id of a driver who participated in at most 30 races, how many races did they participate in?",
        "ground_truth": "SELECT T1.driverid ,  count(*) FROM drivers AS T1 JOIN results AS T2 ON T1.driverid = T2.driverid JOIN races AS T3 ON T2.raceid = T3.raceid GROUP BY T1.driverid HAVING count(*)  <=  30",
        "amends": [
            "Do use `drivers AS T1` joined with `results AS T2` on `T1.driverid = T2.driverid` and `races AS T3` on `T2.raceid = T3.raceid` instead of querying only `driver_races` table. Do select `T1.driverid` instead of `driver_id` and use `count(*)` instead of `COUNT(race_id)`. Do group by `T1.driverid` instead of `driver_id` while keeping the same `HAVING count(*) <= 30` condition. The amended query now correctly joins multiple tables to count race results per driver and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"races participated in by drivers\": make sure to use tables \"drivers AS T1\", \"results AS T2\", and \"races AS T3\" instead of a single table. 2) When combining tables for driver race participation: link rows where T1.driverid = T2.driverid and T2.raceid = T3.raceid, keeping only matching pairs (inner match). 3) When counting races per driver: use count(*) to count the number of race participations. 4) When grouping by driver: group by T1.driverid instead of driver_id. 5) When filtering for drivers with at most 30 races: apply the condition count(*) <= 30 after grouping. 6) When selecting output columns: include T1.driverid and count(*) as race_count."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT driver_id, COUNT(race_id) AS race_count \nFROM driver_races \nGROUP BY driver_id \nHAVING COUNT(race_id) <= 30",
            "SELECT T1.driverId, COUNT(*) AS race_count\nFROM drivers AS T1\nJOIN results AS T2 ON T1.driverId = T2.driverId\nJOIN races AS T3 ON T2.raceId = T3.raceId\nGROUP BY T1.driverId\nHAVING COUNT(*) <= 30"
        ],
        "rule_sql": [
            "SELECT T1.driverId, COUNT(*) AS race_count\nFROM drivers AS T1\nJOIN results AS T2 ON T1.driverId = T2.driverId\nJOIN races AS T3 ON T2.raceId = T3.raceId\nGROUP BY T1.driverId\nHAVING COUNT(*) <= 30"
        ]
    },
    "2594": {
        "db_id": "inn_1",
        "question": "What is the decor of room Recluse and defiance?",
        "ground_truth": "SELECT decor FROM Rooms WHERE roomName  =  \"Recluse and defiance\";",
        "amends": [
            "Do reference the table as `Rooms` instead of `rooms` to match the correct table name. Do use the column name `roomName` instead of `room_name` to reference the correct column. Do use double quotes `\"Recluse and defiance\"` instead of single quotes for the string literal. The amended query now correctly selects decor from the Rooms table where roomName equals the specified value, matching the behavior of the right SQL."
        ],
        "rules": [
            "1) When referencing table names: use exact table name \"Rooms\" with double quotes and proper capitalization instead of lowercase \"rooms\". 2) When referencing column names: use exact column name \"roomName\" with proper camelCase instead of snake_case \"room_name\". 3) When using string literals: wrap text values in double quotes like \"Recluse and defiance\" instead of single quotes. 4) When answering about room decor: select the \"decor\" column from table \"Rooms\" where \"roomName\" equals the exact literal value \"Recluse and defiance\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT decor FROM rooms WHERE room_name = 'Recluse and defiance';",
            "SELECT decor FROM Rooms WHERE roomName = \"Recluse and defiance\";"
        ],
        "rule_sql": [
            "SELECT \"decor\" FROM \"Rooms\" WHERE \"roomName\" = \"Recluse and defiance\""
        ]
    },
    "539": {
        "db_id": "store_1",
        "question": "A list of the top 8 countries by gross/total invoice size. List country name and gross invoice size.",
        "ground_truth": "SELECT billing_country ,  SUM(total) FROM invoices GROUP BY billing_country ORDER BY SUM(total) DESC LIMIT 8;",
        "amends": [
            "Do use `billing_country` instead of `Country` for the country column name. Do use `total` instead of `Total` for the amount column name. Do remove the alias `GrossInvoiceSize` instead of keeping it. Do reference `SUM(total)` directly in the ORDER BY clause instead of using the alias `GrossInvoiceSize`. The amended query now correctly references the actual column names and maintains proper aggregation behavior without relying on column aliases in the ORDER BY clause."
        ],
        "rules": [
            "1) When the question asks for \"country name\": use the exact column name \"billing_country\" from the invoices table. 2) When the question asks for \"gross/total invoice size\": calculate the sum of the \"total\" column from the invoices table. 3) When the question asks for \"top 8 countries\": rank countries by the sum of total in descending order and keep the first 8 rows. 4) When grouping by country: organize results by \"billing_country\" and compute the sum of \"total\" per group. 5) When ordering results: order directly by SUM(total) in descending order without using column aliases. 6) When producing output columns: list \"billing_country\" first followed by the sum of \"total\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Country, SUM(Total) as GrossInvoiceSize \nFROM Invoices \nGROUP BY Country \nORDER BY GrossInvoiceSize DESC \nLIMIT 8;",
            "SELECT billing_country, SUM(total) AS GrossInvoiceSize\nFROM invoices\nGROUP BY billing_country\nORDER BY SUM(total) DESC\nLIMIT 8"
        ],
        "rule_sql": [
            "SELECT billing_country, SUM(total) FROM invoices GROUP BY billing_country ORDER BY SUM(total) DESC LIMIT 8"
        ]
    },
    "5140": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "What are the total order quantities of photo products?",
        "ground_truth": "SELECT sum(T1.Order_Quantity) FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_Name  =  \"photo\"",
        "amends": [
            "Do use `sum(T1.Order_Quantity)` with explicit table alias instead of `SUM(quantity)` with ambiguous column reference. Do join `ORDER_ITEMS AS T1` with `Products AS T2` on `T1.Product_ID = T2.Product_ID` instead of querying only the `orders` table. Do filter on `T2.Product_Name = \"photo\"` instead of `product_type = 'photo'` to correctly reference the product name attribute. Do reference the quantity column as `T1.Order_Quantity` with proper table qualification instead of the ambiguous `quantity` column. The amended query now correctly joins the order items with products table to filter by product name and sum the appropriate quantity values, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"total order quantities of photo products\": make sure the output order: sum(T1.Order_Quantity). 2) When combining ORDER_ITEMS AS T1 and Products AS T2: link rows where T1.Product_ID = T2.Product_ID and keep only matching pairs (inner match). 3) When filtering for photo products: use T2.Product_Name = \"photo\" exactly as specified with double quotes. 4) When summing quantities: use sum(T1.Order_Quantity) with explicit table alias qualification."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(quantity) FROM orders WHERE product_type = 'photo';",
            "SELECT SUM(T1.Order_Quantity) AS total_order_quantity\nFROM Order_Items AS T1\nJOIN Products AS T2 ON T1.Product_ID = T2.Product_ID\nWHERE T2.Product_Name = 'photo'"
        ],
        "rule_sql": [
            "SELECT SUM(T1.Order_Quantity) \nFROM Order_Items AS T1 \nINNER JOIN Products AS T2 ON T1.Product_ID = T2.Product_ID \nWHERE T2.Product_Name = \"photo\""
        ]
    },
    "5181": {
        "db_id": "music_2",
        "question": "Count the number of songs.",
        "ground_truth": "SELECT count(*) FROM Songs",
        "amends": [
            "Do query the `Songs` table instead of the `artists` table. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting songs: use the \"Songs\" table instead of the \"artists\" table. 2) When the question asks for \"count of songs\": compute the number of rows using the canonical key from the \"Songs\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM artists;",
            "SELECT COUNT(*) FROM Songs;"
        ],
        "rule_sql": [
            "SELECT COUNT(SongId) FROM Songs;"
        ]
    },
    "4720": {
        "db_id": "department_store",
        "question": "How many customers use each payment method?",
        "ground_truth": "SELECT payment_method_code ,  count(*) FROM customers GROUP BY payment_method_code",
        "amends": [
            "Do reference `payment_method_code` instead of `payment_method` in both the SELECT list and GROUP BY clause, ensuring the column name matches the actual schema definition for accurate aggregation by payment method codes rather than a potentially non-existent or incorrect column. The amended query now correctly groups and counts customers by their payment method codes as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks about \"payment method\": use the exact column token \"payment_method_code\" from the Customers table instead of \"payment_method\". 2) When counting customers per payment method: group by \"payment_method_code\" and count using the canonical key for customers. 3) When producing output for payment method usage: ensure the output order shows payment_method_code first followed by the count."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT payment_method, COUNT(*) FROM customers GROUP BY payment_method;",
            "SELECT payment_method_code, COUNT(*) AS customer_count FROM Customers GROUP BY payment_method_code;"
        ],
        "rule_sql": [
            "SELECT payment_method_code, COUNT(customer_id) AS customer_count FROM Customers GROUP BY payment_method_code ORDER BY payment_method_code;"
        ]
    },
    "3979": {
        "db_id": "hospital_1",
        "question": "What are the names of procedures physician John Wen was trained in?",
        "ground_truth": "SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  \"John Wen\"",
        "amends": [
            "Do select `T3.name` from the procedures table instead of `p.name`. Do join `physician AS T1` and `trained_in AS T2` on `T1.employeeid = T2.physician` instead of directly joining procedures with physicians. Do add a second join condition `T3.code = T2.treatment` to connect procedures through the trained_in bridge table instead of using `p.physician_id = ph.id`. Do use the correct physician identifier `T1.employeeid` instead of `ph.id`. Do filter on `T1.name = \"John Wen\"` instead of `ph.name = 'John Wen'` with proper table alias and quote style. The amended query now correctly navigates the relationship through the trained_in association table to find procedures that physicians are trained to perform, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"names of procedures physician John Wen was trained in\": make sure the output order: T3.name. 2) When the question mentions \"physician John Wen\": \"John Wen\" actually means T1.name = \"John Wen\" in schema. 3) When combining physician (T1) and trained_in (T2) tables: link rows where T1.employeeid = T2.physician and keep only matching pairs (inner match). 4) When combining trained_in (T2) and procedures (T3) tables: link rows where T3.code = T2.treatment and keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for literal values like \"John Wen\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.name FROM procedures p JOIN physicians ph ON p.physician_id = ph.id WHERE ph.name = 'John Wen';",
            "SELECT T3.Name \nFROM Physician AS T1\nJOIN Trained_In AS T2 ON T1.EmployeeID = T2.Physician\nJOIN Procedures AS T3 ON T3.Code = T2.Treatment\nWHERE T1.Name = 'John Wen';"
        ],
        "rule_sql": [
            "SELECT T3.Name \nFROM Physician T1\nINNER JOIN Trained_In T2 ON T1.EmployeeID = T2.Physician\nINNER JOIN Procedures T3 ON T3.Code = T2.Treatment\nWHERE T1.Name = \"John Wen\"\nORDER BY T3.Name"
        ]
    },
    "6426": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "What are the codes, names, and descriptions of the different document types?",
        "ground_truth": "SELECT document_type_code ,  document_type_name ,  document_type_description FROM Ref_document_types",
        "amends": [
            "Do select `document_type_code`, `document_type_name`, and `document_type_description` instead of `code`, `name`, and `description`. Do query from `Ref_document_types` table instead of `document_types` table. Do remove the `WHERE code IS NULL` filter instead of keeping it, as the right query retrieves all records without filtering. The amended query now correctly references the proper table and column names to match the intended schema structure."
        ],
        "rules": [
            "1) When selecting document type information: use columns \"document_type_code\", \"document_type_name\", and \"document_type_description\" from table \"Ref_document_types\". 2) When retrieving all document types: do not apply any filtering condition (remove WHERE clause). 3) When the question asks for codes, names, and descriptions: output them in the order \"document_type_code\", \"document_type_name\", \"document_type_description\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT code, name, description FROM document_types WHERE code IS NULL",
            "SELECT Document_Type_Code, Document_Type_Name, Document_Type_Description FROM Ref_Document_Types"
        ],
        "rule_sql": [
            "SELECT document_type_code, document_type_name, document_type_description FROM Ref_Document_Types"
        ]
    },
    "3815": {
        "db_id": "e_learning",
        "question": "What are the subject ID, subject name, and the number of available courses for each subject?",
        "ground_truth": "SELECT T1.subject_id ,  T2.subject_name ,  COUNT(*) FROM Courses AS T1 JOIN Subjects AS T2 ON T1.subject_id  =  T2.subject_id GROUP BY T1.subject_id",
        "amends": [
            "Do join `Courses AS T1` with `Subjects AS T2` on `T1.subject_id = T2.subject_id` instead of querying only the `subjects` table. Do count all rows with `COUNT(*)` instead of counting `course_id` specifically. Do group by only `T1.subject_id` instead of grouping by both `subject_id` and `subject_name`. Do include `T2.subject_name` in the SELECT list without an alias instead of using `subject_name` with an alias. The amended query now correctly counts courses per subject by joining the Courses and Subjects tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"subject ID, subject name, and number of available courses for each subject\": make sure the output order: subject_id, subject_name, available_courses. 2) When counting available courses per subject: join \"Courses AS T1\" with \"Subjects AS T2\" on \"T1.subject_id = T2.subject_id\" using inner match. 3) When counting courses: count all rows using COUNT(*) instead of counting specific columns. 4) When grouping by subject: group by only \"T1.subject_id\" instead of grouping by both subject_id and subject_name. 5) When including subject name in output: include \"T2.subject_name\" in the SELECT list without an alias."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT subject_id, subject_name, COUNT(course_id) as available_courses FROM subjects GROUP BY subject_id, subject_name",
            "SELECT T1.subject_id, T2.subject_name, COUNT(*) AS number_of_courses\nFROM Courses AS T1\nJOIN Subjects AS T2 ON T1.subject_id = T2.subject_id\nGROUP BY T1.subject_id"
        ],
        "rule_sql": [
            "SELECT T1.subject_id, T2.subject_name, COUNT(*) AS available_courses\nFROM Courses AS T1\nINNER JOIN Subjects AS T2 ON T1.subject_id = T2.subject_id\nGROUP BY T1.subject_id\nORDER BY T1.subject_id;"
        ]
    },
    "1596": {
        "db_id": "customers_and_invoices",
        "question": "What are the different product sizes?",
        "ground_truth": "SELECT DISTINCT product_size FROM Products",
        "amends": [
            "Do select only `product_size` instead of all columns with `*`. Do add `DISTINCT` to return unique values instead of returning all duplicate values. Do use proper table name capitalization `Products` instead of lowercase `products`. The amended query now correctly returns only unique product sizes from the Products table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"different product sizes\": make sure the output order: product_size. 2) When the question asks for \"different\" values: return only unique values of the exact column \"product_size\". 3) When referring to the Products table: use the exact table name \"Products\" with proper capitalization. 4) When selecting from the Products table: only include the \"product_size\" column instead of all columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM products;",
            "SELECT DISTINCT product_size FROM Products;"
        ],
        "rule_sql": [
            "SELECT DISTINCT product_size FROM Products ORDER BY product_size;"
        ]
    },
    "5875": {
        "db_id": "tracking_share_transactions",
        "question": "Show the transaction type code that occurs the fewest times.",
        "ground_truth": "SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) ASC LIMIT 1",
        "amends": [
            "Do order by `COUNT(*) ASC` instead of `count DESC` and do remove the `COUNT(*) as count` column from the SELECT list instead of including it, while keeping the same `GROUP BY transaction_type_code` and `LIMIT 1` structure. The amended query now matches RIGHT_SQL's behavior by returning the transaction type with the lowest count rather than the highest."
        ],
        "rules": [
            "1) When counting occurrences of transaction types: count the number of rows for each transaction_type_code. 2) When finding the transaction type with fewest occurrences: order the results by the count in ascending order. 3) When showing only the transaction type with the fewest occurrences: limit the output to just one row. 4) When presenting the result: include only the transaction_type_code column in the output, not the count column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT transaction_type_code, COUNT(*) as count FROM transactions GROUP BY transaction_type_code ORDER BY count DESC LIMIT 1;",
            "SELECT transaction_type_code FROM Transactions GROUP BY transaction_type_code ORDER BY COUNT(*) ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT transaction_type_code FROM Transactions GROUP BY transaction_type_code ORDER BY COUNT(*) ASC LIMIT 1;"
        ]
    },
    "5969": {
        "db_id": "game_1",
        "question": "How many video games exist?",
        "ground_truth": "SELECT count(*) FROM Video_games",
        "amends": [
            "Do reference the `Video_games` table instead of the `games` table. Do filter by the table name itself instead of using a `type = 'video'` condition. Do maintain the same aggregate function `count(*)` without changes. The amended query now correctly counts all records from the Video_games table instead of attempting to filter a generic games table by type, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"how many video games exist\": use the exact table name \"Video_games\" as specified in the schema. 2) When counting entities from the Video_games table: count all records using count(*) without any filtering conditions. 3) When the question asks for video games: do not use a type filter condition like 'type = \\\"video\\\"' since the table name itself identifies the entity type."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE type = 'video';",
            "SELECT COUNT(*) FROM Video_Games;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Video_Games;"
        ]
    },
    "3649": {
        "db_id": "baseball_1",
        "question": "List three countries which are the origins of the least players.",
        "ground_truth": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;",
        "amends": [
            "Do use `birth_country` instead of `country` as the column name in both the SELECT list and GROUP BY clause. Do use `count(*)` directly in the ORDER BY clause instead of referencing the alias `player_count`. Do order by `ASC` instead of `DESC` to sort in ascending order. Do query from table `player` instead of `players`. The amended query now correctly selects birth countries from the player table, groups by birth country, orders by the count in ascending order, and limits to 3 results, matching the intended behavior.",
            "Do remove the `COUNT(*) AS player_count` column from the SELECT list instead of including it, while keeping the `birth_country` grouping column. Do maintain the `GROUP BY birth_country` clause instead of altering it. Do preserve the `ORDER BY count(*) ASC` instead of changing the ordering. Do retain the `LIMIT 3` instead of modifying the limit. The amended query now matches the RIGHT_SQL's behavior by selecting only the birth_country column without the count aggregation in the output."
        ],
        "rules": [
            "1) When the question asks for \"countries which are the origins of players\": use the exact column name \"birth_country\" from table \"player\" instead of \"country\". 2) When counting players per country: count all rows using \"count(*)\" and group by \"birth_country\". 3) When finding the \"least players\": order the results by the count in ascending order (ASC) to get the smallest counts first. 4) When the question asks for \"three countries\": limit the results to exactly 3 rows.",
            "1) When answering about \"countries which are the origins of the least players\": make sure the output order: birth_country only without the count column. 2) When the question asks for \"three countries\": rank rows by player count in ascending order and keep the first 3 rows. 3) When the question asks for \"count of players per country\": compute the number of rows using the birth_country grouping but do not include the count in the final output. 4) When grouping by birth_country: organize results by birth_country and compute the count per group for ordering purposes only."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country, COUNT(*) as player_count FROM players GROUP BY country ORDER BY player_count DESC LIMIT 3;",
            "SELECT birth_country, COUNT(*) AS player_count FROM player GROUP BY birth_country ORDER BY COUNT(*) ASC LIMIT 3;",
            "SELECT birth_country FROM player GROUP BY birth_country ORDER BY COUNT(*) ASC LIMIT 3"
        ],
        "rule_sql": [
            "SELECT birth_country FROM player GROUP BY birth_country ORDER BY COUNT(*) ASC LIMIT 3"
        ]
    },
    "2962": {
        "db_id": "sakila_1",
        "question": "What is the genre name of the film HUNGER ROOF?",
        "ground_truth": "SELECT T1.name FROM category AS T1 JOIN film_category AS T2 ON T1.category_id  =  T2.category_id JOIN film AS T3 ON T2.film_id  =  T3.film_id WHERE T3.title  =  'HUNGER ROOF'",
        "amends": [
            "Do select `T1.name` from the `category` table instead of `title` from `genres`. Do join `category AS T1` to `film_category AS T2` on `T1.category_id = T2.category_id` instead of querying only the `genres` table. Do add a second join to `film AS T3` on `T2.film_id = T3.film_id` instead of omitting these table relationships. Do filter on `T3.title = 'HUNGER ROOF'` instead of `film_name = 'HUNGER ROOF'` to correctly reference the film title column. The amended query now properly retrieves category names for films by establishing the correct table relationships through appropriate joins."
        ],
        "rules": [
            "1) When answering about film genre names: make sure the output order: T1.name 2) When the question mentions \"genre name\": \"genre name\" actually means \"T1.name in category table\" 3) When combining T1 (category) and T2 (film_category) for shared entities: link rows where T1.category_id = T2.category_id exactly as shown; keep only matching pairs (inner match) 4) When combining T2 (film_category) and T3 (film) for shared entities: link rows where T2.film_id = T3.film_id exactly as shown; keep only matching pairs (inner match) 5) When filtering for film title \"HUNGER ROOF\": use exact literal 'HUNGER ROOF' with T3.title column 6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms 7) When handling text literals: do not change case, spacing, or punctuation of 'HUNGER ROOF'"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM genres WHERE film_name = 'HUNGER ROOF';",
            "SELECT T1.name \nFROM category AS T1\nJOIN film_category AS T2 ON T1.category_id = T2.category_id\nJOIN film AS T3 ON T2.film_id = T3.film_id\nWHERE T3.title = 'HUNGER ROOF'"
        ],
        "rule_sql": [
            "SELECT T1.name \nFROM category T1\nINNER JOIN film_category T2 ON T1.category_id = T2.category_id\nINNER JOIN film T3 ON T2.film_id = T3.film_id\nWHERE T3.title = 'HUNGER ROOF'"
        ]
    },
    "2723": {
        "db_id": "storm_record",
        "question": "What are the names of storms that did not affect two or more regions?",
        "ground_truth": "SELECT name FROM storm EXCEPT SELECT T1.name FROM storm AS T1 JOIN affected_region AS T2 ON T1.storm_id  =  T2.storm_id GROUP BY T1.storm_id HAVING count(*)  >=  2",
        "amends": [
            "Do use `EXCEPT` with a subquery instead of a simple `WHERE` filter. Do reference the table as `storm` instead of `storms`. Do add a join to `affected_region` on `storm_id` instead of omitting this relationship. Do group by `storm_id` instead of not using grouping. Do move the count condition to `HAVING count(*) >= 2` instead of using `WHERE region_count >= 2`. Do properly correlate the subquery through the join condition instead of assuming a direct column exists. The amended query now correctly identifies storms by excluding those that affect two or more regions through the proper many-to-many relationship."
        ],
        "rules": [
            "1) When the question asks about storms that did not affect two or more regions: use EXCEPT to exclude storms that meet the condition rather than filtering with WHERE. 2) When referring to the storms table: use the exact table name \"storm\" instead of \"storms\". 3) When determining which regions a storm affected: join the \"storm\" table with \"affected_region\" on storm_id to establish the many-to-many relationship. 4) When counting how many regions a storm affects: group by storm_id and use HAVING count(*) >= 2 to identify storms affecting two or more regions. 5) When correlating the subquery: ensure the join condition properly links the main query and subquery through the storm_id relationship."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM storms WHERE region_count >= 2;",
            "SELECT s.Name\nFROM storm s\nWHERE s.Storm_ID NOT IN (\n    SELECT ar.Storm_ID\n    FROM affected_region ar\n    GROUP BY ar.Storm_ID\n    HAVING COUNT(*) >= 2\n)"
        ],
        "rule_sql": [
            "SELECT Name FROM storm\nEXCEPT\nSELECT s.Name FROM storm s\nJOIN affected_region ar ON s.Storm_ID = ar.Storm_ID\nGROUP BY s.Storm_ID\nHAVING COUNT(*) >= 2"
        ]
    },
    "3381": {
        "db_id": "sports_competition",
        "question": "find the number of players whose points are lower than 30 in each position.",
        "ground_truth": "SELECT count(*) ,  POSITION FROM player WHERE points  <  30 GROUP BY POSITION",
        "amends": [
            "Do use `count(*)` as the first column in the SELECT list instead of `COUNT(*)` as the second column. Do reference the table `player` instead of `players` in the FROM clause. Do group by `POSITION` (uppercase) instead of `position` (lowercase) while maintaining the same GROUP BY logic. The amended query now correctly counts players by position with points under 30, matching the intended behavior."
        ],
        "rules": [
            "1) When counting entities from the player table: use the exact table name \"player\" instead of \"players\". 2) When grouping by position: use the exact column name \"POSITION\" in uppercase instead of lowercase \"position\". 3) When ordering output columns for counting queries: place the count(*) column first in the output, followed by the grouping column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT position, COUNT(*) FROM players WHERE points < 30 GROUP BY position;",
            "SELECT count(*), Position FROM player WHERE Points < 30 GROUP BY POSITION;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS player_count, \"Position\" FROM player WHERE Points < 30 GROUP BY \"Position\""
        ]
    },
    "6551": {
        "db_id": "wine_1",
        "question": "What are the wines that have prices lower than 50 and have appelations in Monterey county?",
        "ground_truth": "SELECT T2.Name FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  \"Monterey\" AND T2.price  <  50",
        "amends": [
            "Do select `T2.Name` instead of `*` to return only specific columns. Do join `APPELLATIONS AS T1` with `WINE AS T2` on `T1.Appelation = T2.Appelation` instead of querying a single `wines` table. Do filter on `T1.County = \"Monterey\"` instead of `county = 'Monterey'` to reference the correct table and use proper quotes. Do filter on `T2.price < 50` instead of `price < 50` to reference the correct table. The amended query now correctly joins the two related tables and returns only the wine names from Monterey county with prices under 50, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about wines with prices lower than 50 and appelations in Monterey county: make sure the output order includes only T2.Name. 2) When combining APPELLATIONS and WINE tables: link rows where T1.Appelation = T2.Appelation and keep only matching pairs (inner match). 3) When filtering for Monterey county: use T1.County = \"Monterey\" with double quotes around the literal. 4) When filtering for prices under 50: use T2.price < 50 to reference the correct table. 5) When the question mentions \"wines\": the wine names are actually stored in T2.Name from the WINE table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM wines WHERE price < 50 AND county = 'Monterey';",
            "SELECT T2.Name \nFROM appellations AS T1 \nJOIN wine AS T2 ON T1.Appelation = T2.Appelation \nWHERE T1.County = \"Monterey\" \nAND T2.Price < 50"
        ],
        "rule_sql": [
            "SELECT T2.Name \nFROM appellations T1 \nINNER JOIN wine T2 ON T1.Appelation = T2.Appelation \nWHERE T1.County = \"Monterey\" \nAND T2.Price < 50"
        ]
    },
    "3411": {
        "db_id": "hr_1",
        "question": "Return all the information for all employees without any department number.",
        "ground_truth": "SELECT * FROM employees WHERE department_id  =  \"null\"",
        "amends": [
            "Do use equality comparison `= \"null\"` instead of `IS NOT NULL` for the WHERE filter on `department_id`, as the right query specifically checks for string \"null\" values rather than non-NULL database values. The amended query now correctly matches the RIGHT_SQL's behavior of filtering for explicit \"null\" string values in the department_id column."
        ],
        "rules": [
            "1) When filtering for employees without department number: use equality comparison with the string literal \"null\" (department_id = \"null\") instead of checking for database NULL values. 2) When the question asks for \"all the information\": return all columns from the employees table without any column exclusions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM employees WHERE department_id IS NOT NULL",
            "SELECT * FROM employees WHERE DEPARTMENT_ID = \"null\""
        ],
        "rule_sql": [
            "SELECT * FROM employees WHERE department_id = \"null\""
        ]
    },
    "5498": {
        "db_id": "voter_2",
        "question": "Find the distinct last names of all the students who have president votes and whose advisor is 8741.",
        "ground_truth": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  \"8741\"",
        "amends": [
            "Do use `T1.LName` instead of `last_name` and reference the `STUDENT` table as `T1` instead of `students`. Do add a `JOIN` with `VOTING_RECORD AS T2` on `T1.StuID = PRESIDENT_Vote` instead of filtering directly on `president_votes > 0`. Do change the filter to `Advisor = \"8741\"` instead of `advisor_id = 8741` and use string comparison instead of numeric. Do use `INTERSECT` to combine results from both queries instead of a single WHERE clause with AND conditions. Do remove the DISTINCT from the first part since INTERSECT inherently eliminates duplicates, keeping it only in the second SELECT. The amended query now correctly finds students who both voted for president and have advisor 8741, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"last names\": use the exact column token \"T1.LName\" instead of \"last_name\". 2) When the question refers to \"students\": use the table \"STUDENT\" with alias \"T1\" instead of \"students\". 3) When identifying students who \"have president votes\": join with table \"VOTING_RECORD\" as \"T2\" where \"T1.StuID = T2.PRESIDENT_Vote\" instead of filtering on \"president_votes > 0\". 4) When filtering for advisor \"8741\": use the exact literal \"8741\" with string comparison and column \"Advisor\" instead of numeric comparison with \"advisor_id\". 5) When combining conditions for students who both voted for president and have advisor 8741: use INTERSECT to combine results from both queries instead of a single WHERE clause with AND conditions. 6) When eliminating duplicate last names: remove DISTINCT from individual SELECT statements since INTERSECT inherently eliminates duplicates."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT last_name FROM students WHERE president_votes > 0 AND advisor_id = 8741;",
            "SELECT T1.LName FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.President_Vote INTERSECT SELECT T1.LName FROM Student AS T1 WHERE T1.Advisor = \"8741\""
        ],
        "rule_sql": [
            "SELECT T1.LName FROM STUDENT T1 JOIN VOTING_RECORD T2 ON T1.StuID = T2.PRESIDENT_Vote INTERSECT SELECT T1.LName FROM STUDENT T1 WHERE T1.Advisor = '8741'"
        ]
    },
    "9": {
        "db_id": "department_management",
        "question": "Show the name and number of employees for the departments managed by heads whose temporary acting value is 'Yes'?",
        "ground_truth": "SELECT T1.name ,  T1.num_employees FROM department AS T1 JOIN management AS T2 ON T1.department_id  =  T2.department_id WHERE T2.temporary_acting  =  'Yes'",
        "amends": [
            "Do select `T1.name` and `T1.num_employees` instead of `department_name` and `COUNT(*) as employee_count`. Do use `department AS T1` instead of `departments d` and add `management AS T2` instead of omitting it. Do join on `T1.department_id = T2.department_id` instead of `d.department_id = e.department_id`. Do filter on `T2.temporary_acting = 'Yes'` instead of `d.head_temporary_acting = 'Yes'`. Do remove the `GROUP BY` clause instead of keeping it. The amended query now correctly retrieves department names and employee counts from the management table rather than counting employees directly, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about departments managed by heads with temporary acting value 'Yes': select T1.name and T1.num_employees as output columns. 2) When combining department and management tables: link rows where T1.department_id = T2.department_id and keep only matching pairs (inner match). 3) When filtering for temporary acting heads: include only rows where T2.temporary_acting = 'Yes' exactly. 4) When the question asks for number of employees: use T1.num_employees directly instead of counting employees. 5) When producing output: do not use GROUP BY clause since employee count is already stored in T1.num_employees."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department_name, COUNT(*) as employee_count \nFROM departments d\nJOIN employees e ON d.department_id = e.department_id\nWHERE d.head_temporary_acting = 'Yes'\nGROUP BY department_name;",
            "SELECT T1.Name, T1.Num_Employees \nFROM department AS T1 \nJOIN management AS T2 ON T1.Department_ID = T2.Department_ID \nWHERE T2.temporary_acting = 'Yes'"
        ],
        "rule_sql": [
            "SELECT T1.Name, T1.Num_Employees \nFROM department T1 \nINNER JOIN management T2 ON T1.Department_ID = T2.Department_ID \nWHERE T2.temporary_acting = 'Yes'"
        ]
    },
    "4757": {
        "db_id": "department_store",
        "question": "What are the names and ids of customers whose address contains TN?",
        "ground_truth": "SELECT customer_name ,  customer_id FROM customers WHERE customer_address LIKE \"%TN%\"",
        "amends": [
            "Do select `customer_name` and `customer_id` instead of `customer_id`, `first_name`, and `last_name`. Do filter on `customer_address LIKE \"%TN%\"` instead of `address LIKE '%TN%'`. The amended query now correctly retrieves customer names and IDs based on address filtering using the appropriate column names.",
            "Do maintain the same column selection of `customer_id` and `customer_name` instead of changing their order. Do use the same table source `Customers` with consistent case handling instead of altering the table name casing. Do preserve the identical `WHERE` filter condition `customer_address LIKE '%TN%'` instead of modifying the pattern matching syntax. The amended query now correctly matches the RIGHT_SQL's behavior while maintaining logical equivalence.",
            "Do maintain the same column selection of `customer_id` and `customer_name` instead of changing the order. Do keep the same table source `Customers` with the same case instead of changing to lowercase. Do preserve the WHERE filter `LIKE '%TN%'` with single quotes instead of double quotes. The amended query now correctly matches the RIGHT_SQL's behavior while maintaining identical logical functionality.",
            "Do maintain the same column selection of `customer_id` and `customer_name` instead of changing the order. Do keep the same table source `Customers` with the same case instead of altering it. Do preserve the identical WHERE filter `customer_address LIKE '%TN%'` with the same pattern matching instead of modifying the quote style from single to double quotes. The amended query now correctly matches the RIGHT_SQL's behavior while maintaining identical logical functionality.",
            "Do maintain the same column selection of `customer_id` and `customer_name` instead of changing the order. Do keep the same table source `Customers` with the same case instead of altering it. Do preserve the identical WHERE filter condition `customer_address LIKE '%TN%'` with the same pattern matching instead of modifying the quote style from single to double quotes. The amended query now correctly matches the RIGHT_SQL's behavior while maintaining functional equivalence."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_id, first_name, last_name FROM customers WHERE address LIKE '%TN%';",
            "SELECT customer_id, customer_name FROM Customers WHERE customer_address LIKE '%TN%'",
            "SELECT customer_id, customer_name FROM Customers WHERE customer_address LIKE '%TN%'",
            "SELECT customer_id, customer_name FROM Customers WHERE customer_address LIKE '%TN%'",
            "SELECT customer_id, customer_name FROM Customers WHERE customer_address LIKE '%TN%'",
            "SELECT customer_id, customer_name FROM Customers WHERE customer_address LIKE '%TN%'"
        ],
        "rule_sql": []
    },
    "6863": {
        "db_id": "flight_4",
        "question": "Find the average elevation of all airports for each country.",
        "ground_truth": "SELECT avg(elevation) ,  country FROM airports GROUP BY country",
        "amends": [
            "Do place `country` after `avg(elevation)` in the SELECT list instead of before it, maintaining the same aggregation logic and GROUP BY clause. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"average elevation of all airports for each country\": make sure the output order: avg(elevation) first, then country. 2) When the question asks for \"average elevation\": compute the average of the elevation column. 3) When the question says \"for each country\": organize results by the country column and compute the average elevation per country."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country, AVG(elevation) FROM airports GROUP BY country;",
            "SELECT avg(elevation), country FROM airports GROUP BY country"
        ],
        "rule_sql": [
            "SELECT AVG(elevation) AS average_elevation, country FROM airports GROUP BY country ORDER BY average_elevation, country;"
        ]
    },
    "4051": {
        "db_id": "student_1",
        "question": "Which teachers teach in classroom 110? Give me their first names.",
        "ground_truth": "SELECT firstname FROM teachers WHERE classroom  =  110",
        "amends": [
            "Do reference the column as `firstname` instead of `first_name` to match the actual column name in the schema. Do use a numeric value `110` without quotes instead of the string literal `'110'` for the classroom filter, as classroom appears to be a numeric column rather than a text column. The amended query now correctly selects from the teachers table using proper column reference and numeric comparison semantics."
        ],
        "rules": [
            "1) When the question asks for \"first names\": use the exact column name \"firstname\" from the teachers table. 2) When filtering by classroom number 110: use numeric value 110 without quotes since classroom is a numeric column. 3) When answering about teachers in classroom 110: select from the teachers table and filter where classroom equals 110."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM teachers WHERE classroom = '110';",
            "SELECT firstname FROM teachers WHERE classroom = 110"
        ],
        "rule_sql": [
            "SELECT firstname FROM teachers WHERE classroom = 110"
        ]
    },
    "6138": {
        "db_id": "customers_and_addresses",
        "question": "What are names of customers who never ordered product Latte.",
        "ground_truth": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id JOIN products AS t4 ON t3.product_id  =  t4.product_id WHERE t4.product_details  =  'Latte'",
        "amends": [
            "Do use `EXCEPT` set operation instead of simple joins and filtering. Do select `customer_name` instead of `c.name`. Do add table aliases `t1`, `t2`, `t3`, `t4` instead of single-letter aliases. Do join `customer_orders` instead of `orders` and use `t1.customer_id = t2.customer_id` instead of `c.id = o.customer_id`. Do filter on `t4.product_details = 'Latte'` instead of `p.name != 'Latte'`. The amended query now correctly identifies customers who have never ordered 'Latte' products using set difference logic instead of incorrect exclusion filtering."
        ],
        "rules": [
            "1) When answering about \"customers who never ordered product Latte\": use EXCEPT set operation to find customers who exist in the customer list but not in the set of customers who ordered 'Latte'. 2) When the question mentions \"names of customers\": \"customer_name\" actually means \"customer_name in Customers table\". 3) When selecting customer names: select \"customer_name\" instead of \"c.name\". 4) When using table aliases: use \"t1\" for Customers, \"t2\" for customer_orders, \"t3\" for order_items, and \"t4\" for products. 5) When joining Customers and customer_orders: link rows where \"t1.customer_id = t2.customer_id\". 6) When filtering for 'Latte' products: use exact literal \"t4.product_details = 'Latte'\" with the exact case and spelling. 7) When handling text literals: preserve the exact case and spelling of 'Latte' as shown in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name \nFROM customers c\nJOIN orders o ON c.id = o.customer_id\nJOIN order_items oi ON o.id = oi.order_id\nJOIN products p ON oi.product_id = p.id\nWHERE p.name != 'Latte';",
            "SELECT t1.customer_name\nFROM Customers t1\nEXCEPT\nSELECT t2.customer_name\nFROM Customers t2\nJOIN Customer_Orders t3 ON t2.customer_id = t3.customer_id\nJOIN Order_Items t4 ON t3.order_id = t4.order_id\nJOIN Products t5 ON t4.product_id = t5.product_id\nWHERE t5.product_details = 'Latte'"
        ],
        "rule_sql": [
            "SELECT customer_name FROM Customers t1\nEXCEPT\nSELECT t1.customer_name FROM Customers t1\nJOIN Customer_Orders t2 ON t1.customer_id = t2.customer_id\nJOIN Order_Items t3 ON t2.order_id = t3.order_id\nJOIN Products t4 ON t3.product_id = t4.product_id\nWHERE t4.product_details = 'Latte'"
        ]
    },
    "4507": {
        "db_id": "document_management",
        "question": "What is the average access count of documents?",
        "ground_truth": "SELECT avg(access_count) FROM documents",
        "amends": [
            "Do use `avg(access_count)` in the SELECT list instead of `AVG(document_id)` to calculate the average of access counts rather than document IDs. This change correctly measures the average access frequency instead of averaging document identifiers, which would produce meaningless results. The amended query now matches the intended behavior of calculating average access counts from the documents table."
        ],
        "rules": [
            "1) When the question asks for \"average access count of documents\": use the exact column token \"access_count\" from the documents table to calculate the average. 2) When calculating averages: do not average identifier columns like \"document_id\" as this produces meaningless results; instead average the actual measurement columns like \"access_count\" that represent countable quantities."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(document_id) FROM documents;",
            "SELECT AVG(access_count) FROM Documents;"
        ],
        "rule_sql": [
            "SELECT AVG(access_count) AS average_access_count FROM Documents;"
        ]
    },
    "680": {
        "db_id": "customers_card_transactions",
        "question": "What is the customer id of the customer with the most accounts, and how many accounts does this person have?",
        "ground_truth": "SELECT customer_id ,  count(*) FROM Accounts GROUP BY customer_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT customer_id, COUNT(account_id) as account_count \nFROM accounts \nGROUP BY customer_id \nORDER BY account_count DESC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT c.customer_id, COUNT(a.account_id) AS account_count\nFROM Customers c\nJOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id\nORDER BY account_count DESC\nLIMIT 1;"
        ]
    },
    "2685": {
        "db_id": "party_host",
        "question": "Which parties have more than 20 hosts? Give me the host names for these parties.",
        "ground_truth": "SELECT T2.Name FROM party_host AS T1 JOIN HOST AS T2 ON T1.Host_ID  =  T2.Host_ID JOIN party AS T3 ON T1.Party_ID  =  T3.Party_ID WHERE T3.Number_of_hosts  >  20",
        "amends": [
            "Do select `T2.Name` instead of `party_name, host_name`. Do use `FROM party_host AS T1 JOIN HOST AS T2 ON T1.Host_ID = T2.Host_ID JOIN party AS T3 ON T1.Party_ID = T3.Party_ID` instead of `FROM parties`. Do apply filter `T3.Number_of_hosts > 20` instead of `host_count > 20`. The amended query now correctly joins multiple tables to retrieve host names for parties with more than 20 hosts, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"parties with more than 20 hosts\": make sure the output order: T2.Name 2) When the question mentions \"parties have more than 20 hosts\": use filter condition T3.Number_of_hosts > 20 3) When combining tables for this question: link rows using T1.Host_ID = T2.Host_ID and T1.Party_ID = T3.Party_ID, keeping only matching pairs (inner match) 4) When the question asks for \"host names\": \"host names\" actually means \"T2.Name in schema\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT party_name, host_name FROM parties WHERE host_count > 20",
            "SELECT T2.Name \nFROM party_host AS T1 \nJOIN host AS T2 ON T1.Host_ID = T2.Host_ID \nJOIN party AS T3 ON T1.Party_ID = T3.Party_ID \nWHERE T3.Number_of_hosts > 20"
        ],
        "rule_sql": [
            "SELECT T2.Name \nFROM party_host T1\nINNER JOIN host T2 ON T1.Host_ID = T2.Host_ID\nINNER JOIN party T3 ON T1.Party_ID = T3.Party_ID\nWHERE T3.Number_of_hosts > 20\nORDER BY T2.Name"
        ]
    },
    "3862": {
        "db_id": "insurance_policies",
        "question": "Among all the claims, which settlements have a claimed amount that is no more than the average? List the claim start date.",
        "ground_truth": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )",
        "amends": [
            "Do reference column `Date_Claim_Made` instead of `claim_start_date` in the SELECT list. Do reference table `Claims` instead of `claims` as the data source. Do filter on `Amount_Settled` instead of `claimed_amount` in the WHERE clause. Do use the inequality `<=` instead of `>` when comparing against the subquery result. Do calculate the average of `Amount_Settled` instead of `claimed_amount` in the subquery. The amended query now correctly identifies claims with settlement amounts at or below the average settlement amount across all claims.",
            "Do reference `Amount_Settled` directly from the `Claims` table instead of joining to the `Settlements` table. Do remove the `JOIN Settlements` clause entirely instead of keeping the unnecessary join. Do use the `Claims` table in the subquery instead of the `Settlements` table to ensure the average calculation is performed on the correct dataset. Do eliminate the table alias `c` from the main query since it's no longer needed without the join. The amended query now correctly filters claims based on whether their settlement amount is less than or equal to the average settlement amount across all claims, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"claim start date\": use the exact column token \"Date_Claim_Made\" from the Claims table. 2) When filtering claims based on settlement amount compared to average: use the column \"Amount_Settled\" instead of \"claimed_amount\" for both the comparison and average calculation. 3) When identifying claims with amounts \"no more than\" the average: use the inequality <= (less than or equal to) instead of > (greater than). 4) When referencing the claims table: use the exact table name \"Claims\" (with capital C) as shown in the schema. 5) When calculating the average settlement amount: compute AVG(\"Amount_Settled\") across all records in the Claims table.",
            "1) When answering about claims with settlement amounts no more than average: make sure the output order includes only the claim start date from the Claims table. 2) When the question mentions \"claimed amount\": \"claimed amount\" actually means \"Amount_Settled in the Claims table\". 3) When filtering claims by settlement amount: compare each claim's Amount_Settled value against the average of all Amount_Settled values from the Claims table. 4) When computing the average settlement amount: calculate the average of the Amount_Settled column from the Claims table without any joins. 5) When selecting the claim start date: use the Date_Claim_Made column from the Claims table without table aliases."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT claim_start_date FROM claims WHERE claimed_amount > (SELECT AVG(claimed_amount) FROM claims);",
            "SELECT c.Date_Claim_Made\nFROM Claims c\nJOIN Settlements s ON c.Claim_ID = s.Claim_ID\nWHERE s.Amount_Settled <= (\n    SELECT AVG(Amount_Settled)\n    FROM Settlements\n);",
            "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled <= (SELECT AVG(Amount_Settled) FROM Claims)"
        ],
        "rule_sql": [
            "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled <= (SELECT AVG(Amount_Settled) FROM Claims)"
        ]
    },
    "4595": {
        "db_id": "solvency_ii",
        "question": "Show the names of products that are in at least two events.",
        "ground_truth": "SELECT T1.Product_Name FROM Products AS T1 JOIN Products_in_Events AS T2 ON T1.Product_ID  =  T2.Product_ID GROUP BY T1.Product_Name HAVING COUNT(*)  >=  2",
        "amends": [
            "Do select `T1.Product_Name` with table alias instead of `name` without qualification. Do add `Products AS T1` and `Products_in_Events AS T2` as FROM sources instead of only `products`. Do add `JOIN` with `ON T1.Product_ID = T2.Product_ID` instead of missing the join condition. Do add `GROUP BY T1.Product_Name` instead of omitting grouping. Do move the count filter to `HAVING COUNT(*) >= 2` instead of using `WHERE event_count >= 2` without aggregation. The amended query now correctly counts product appearances across events through proper table joining and aggregation, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"products that are in at least two events\": make sure the output order: T1.Product_Name. 2) When the question mentions \"products\": use table \"Products AS T1\" as the base table. 3) When the question mentions \"events\": use table \"Products_in_Events AS T2\" to track product appearances in events. 4) When combining T1 and T2 for shared entities: link rows where T1.Product_ID = T2.Product_ID exactly as shown; keep only matching pairs (inner match). 5) When the question asks for \"products that are in at least two events\": organize results by T1.Product_Name and compute COUNT(*) per group. 6) When filtering for products in at least two events: apply the condition COUNT(*) >= 2 in the HAVING clause instead of WHERE."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM products WHERE event_count >= 2;",
            "SELECT T1.Product_Name\nFROM Products AS T1\nJOIN Products_in_Events AS T2 ON T1.Product_ID = T2.Product_ID\nGROUP BY T1.Product_Name\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T1.Product_Name\nFROM Products AS T1\nINNER JOIN Products_in_Events AS T2 ON T1.Product_ID = T2.Product_ID\nGROUP BY T1.Product_Name\nHAVING COUNT(*) >= 2\nORDER BY T1.Product_Name;"
        ]
    },
    "6261": {
        "db_id": "ship_1",
        "question": "Return the names and classes of ships that do not have a captain?",
        "ground_truth": "SELECT name ,  CLASS FROM ship WHERE ship_id NOT IN (SELECT ship_id FROM captain)",
        "amends": [
            "Do reference table `ship` instead of `ships` in the FROM clause. Do change the WHERE condition to use a subquery with `ship_id NOT IN (SELECT ship_id FROM captain)` instead of checking `captain IS NULL`. Do remove the direct NULL check on a captain column that doesn't exist in the schema, instead using a proper relational approach to find ships without captains through the absence of matching records in the captain table. The amended query now correctly identifies ships without captains by checking for ship_ids that don't exist in the captain table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about ships without captains: use a relational approach to find ships that don't have matching records in the captain table instead of checking for NULL values. 2) When referencing the main ship table: use the exact table name \"ship\" (not \"ships\") as shown in the schema. 3) When identifying ships without captains: check for ship_id values that are NOT IN the set of ship_id values from the captain table. 4) When selecting output columns: return the name and class columns from the ship table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, class FROM ships WHERE captain IS NULL;",
            "SELECT Name, Class FROM Ship WHERE Ship_ID NOT IN (SELECT Ship_ID FROM captain)"
        ],
        "rule_sql": [
            "SELECT s.Name, s.Class FROM ship s WHERE s.Ship_ID NOT IN (SELECT c.Ship_ID FROM captain c)"
        ]
    },
    "6613": {
        "db_id": "train_station",
        "question": "show the train name and station name for each train.",
        "ground_truth": "SELECT T2.name ,  T3.name FROM train_station AS T1 JOIN station AS T2 ON T1.station_id  =  T2.station_id JOIN train AS T3 ON T3.train_id  =  T1.train_id",
        "amends": [
            "Do use explicit `JOIN` syntax with proper table aliases instead of implicit cross join between `trains` and `stations`. Do reference `T2.name` and `T3.name` instead of `train_name` and `station_name`. Do add the `train_station` junction table as `T1` instead of omitting it. Do join `station AS T2` on `T1.station_id = T2.station_id` instead of missing the relationship. Do join `train AS T3` on `T3.train_id = T1.train_id` instead of missing the relationship. The amended query now correctly establishes the many-to-many relationship through the junction table and matches RIGHT_SQL's behavior.",
            "Do use lowercase column names `T2.name` and `T3.name` instead of uppercase aliases `T3.Name` and `T2.Name`. Do use lowercase join predicates `T1.station_id = T2.station_id` and `T3.train_id = T1.train_id` instead of uppercase column references. The amended query now correctly matches the RIGHT_SQL's behavior with consistent lowercase naming conventions.",
            "Do select `T2.name` and `T3.name` without aliases instead of using `T3.name AS train_name` and `T2.name AS station_name`. Do remove the `ORDER BY T3.name, T2.name` clause instead of keeping it. The amended query now matches RIGHT_SQL's behavior by returning the same column selection without ordering or aliases.",
            "Do select `T2.name` as the first column instead of `T3.name`, and maintain `T3.name` as the second column instead of `T2.name` to correct the column order. The FROM clause with `train_station AS T1 JOIN station AS T2 ON T1.station_id = T2.station_id JOIN train AS T3 ON T3.train_id = T1.train_id` remains unchanged as the join logic and table aliases are identical. The amended query now matches RIGHT_SQL's behavior by properly ordering the station name before the train name in the result set."
        ],
        "rules": [
            "1) When answering about \"train name and station name for each train\": make sure the output order: T3.name, T2.name\n2) When combining tables for train-station relationships: use the train_station junction table as T1 to link station AS T2 on T1.station_id = T2.station_id and train AS T3 on T3.train_id = T1.train_id\n3) When the question mentions \"train name\": \"train name\" actually means \"T3.name in schema\"\n4) When the question mentions \"station name\": \"station name\" actually means \"T2.name in schema\"\n5) When combining multiple tables: use explicit JOIN syntax instead of implicit cross joins between tables",
            "1) When the question asks for train name and station name: use lowercase column names \"T3.name\" for train name and \"T2.name\" for station name. 2) When joining train_station table (T1) with station table (T2): link rows where \"T1.station_id = T2.station_id\" using lowercase column names. 3) When joining train_station table (T1) with train table (T3): link rows where \"T3.train_id = T1.train_id\" using lowercase column names.",
            "1) When selecting column names that match the question's requested output exactly: use the exact column names without aliases (T2.name and T3.name) instead of creating aliases like train_name and station_name. 2) When the question does not specify any ordering requirements: do not include any ORDER BY clause in the query. 3) When the question asks for \"train name\" and \"station name\": these correspond to T3.name and T2.name respectively in the schema, where T3 represents the train table and T2 represents the station table.",
            "1) When answering about \"show the train name and station name for each train\": make sure the output order: station name first, then train name. 2) When combining tables train_station (T1), station (T2), and train (T3): link rows where T1.station_id = T2.station_id and T3.train_id = T1.train_id, keeping only matching pairs (inner match). 3) When selecting column names: use T2.name for station name and T3.name for train name with the exact aliases as shown."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT train_name, station_name FROM trains, stations",
            "SELECT T3.Name AS train_name, T2.Name AS station_name\nFROM train_station AS T1\nJOIN station AS T2 ON T1.Station_ID = T2.Station_ID\nJOIN train AS T3 ON T3.Train_ID = T1.Train_ID",
            "SELECT T3.name AS train_name, T2.name AS station_name\nFROM train_station AS T1\nJOIN station AS T2 ON T1.station_id = T2.station_id\nJOIN train AS T3 ON T3.train_id = T1.train_id\nORDER BY T3.name, T2.name;",
            "SELECT T3.name, T2.name FROM train_station AS T1 JOIN station AS T2 ON T1.station_id = T2.station_id JOIN train AS T3 ON T3.train_id = T1.train_id",
            "SELECT T2.name, T3.name FROM train_station AS T1 JOIN station AS T2 ON T1.station_id = T2.station_id JOIN train AS T3 ON T3.train_id = T1.train_id"
        ],
        "rule_sql": [
            "SELECT T3.name, T2.name FROM train_station AS T1 JOIN station AS T2 ON T1.station_id = T2.station_id JOIN train AS T3 ON T3.train_id = T1.train_id"
        ]
    },
    "6431": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "Show the number of projects.",
        "ground_truth": "SELECT count(*) FROM Projects",
        "amends": [
            "Do select from `Projects` instead of `employees`. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` to match the right SQL's formatting convention. The amended query now correctly counts records from the Projects table instead of employees, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"number of projects\": select from the \"Projects\" table instead of \"employees\". 2) When counting records: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" to match the right SQL's formatting convention."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees;",
            "SELECT count(*) FROM Projects;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM Projects;"
        ]
    },
    "6043": {
        "db_id": "game_1",
        "question": "Show the game name that has most number of hours played.",
        "ground_truth": "SELECT gname FROM Plays_games AS T1 JOIN Video_games AS T2 ON T1.gameid  =  T2.gameid GROUP BY T1.gameid ORDER BY sum(hours_played) DESC LIMIT 1",
        "amends": [
            "Do select `gname` from the `Video_games` table instead of `game_name` from the `games` table. Do join `Plays_games` and `Video_games` tables on `gameid` instead of querying a single table. Do add `GROUP BY T1.gameid` to aggregate by game instead of selecting individual records. Do order by `sum(hours_played) DESC` instead of `hours_played ASC` to find the game with the highest total playtime rather than the single lowest playtime session. Do remove the direct table reference and instead use a proper join structure to relate player data with game information. The amended query now correctly identifies the game with the highest total hours played across all players instead of finding a single game session with minimal playtime."
        ],
        "rules": [
            "1) When answering about \"game name that has most number of hours played\": make sure the output order: T2.gname 2) When the question mentions \"game name\": \"game name\" actually means \"gname in Video_games table\" 3) When combining T1 (Plays_games) and T2 (Video_games) for shared entities: link rows where T1.gameid = T2.gameid; keep only matching pairs (inner match) 4) When the question asks for \"most number of hours played\" per game: organize results by T1.gameid and compute sum(hours_played) per group, then rank by sum(hours_played) in descending order and keep the first row 5) When the question asks for \"count of hours played\": compute the sum of hours_played values using T1.hours_played"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT game_name FROM games ORDER BY hours_played ASC LIMIT 1;",
            "SELECT vg.GName\nFROM Video_Games vg\nJOIN Plays_Games pg ON vg.GameID = pg.GameID\nGROUP BY vg.GameID\nORDER BY SUM(pg.Hours_Played) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.GName\nFROM Plays_Games T1\nINNER JOIN Video_Games T2 ON T1.GameID = T2.GameID\nGROUP BY T1.GameID\nORDER BY SUM(T1.Hours_Played) DESC\nLIMIT 1;"
        ]
    },
    "2456": {
        "db_id": "movie_1",
        "question": "What is the average rating star for each reviewer?",
        "ground_truth": "SELECT T2.name ,  avg(T1.stars) FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID GROUP BY T2.name",
        "amends": [
            "Do specify `T2.name` in the SELECT list instead of `reviewer` and use `avg(T1.stars)` instead of `AVG(rating)`. Do join `Rating AS T1` with `Reviewer AS T2` on `T1.rID = T2.rID` instead of querying only the `reviews` table without proper joins. Do group by `T2.name` instead of grouping by `rating` to calculate average ratings per reviewer rather than per rating value. The amended query now correctly joins the Rating and Reviewer tables to calculate average star ratings for each reviewer by name."
        ],
        "rules": [
            "1) When answering about \"average rating star for each reviewer\": make sure the output order: T2.name, avg(T1.stars) 2) When the question mentions \"reviewer\": \"reviewer\" actually means \"T2.name in schema\" 3) When the question mentions \"rating star\": \"rating star\" actually means \"T1.stars in schema\" 4) When combining T1 and T2 for shared entities: link rows where T1.rID = T2.rID exactly as shown in the amends; keep only matching pairs (inner match) 5) When the question asks for \"each reviewer\": organize results by T2.name and compute requested aggregates per group 6) When computing average rating: use avg(T1.stars) instead of AVG(rating)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT reviewer, AVG(rating) FROM reviews GROUP BY rating;",
            "SELECT T2.name, AVG(T1.stars) AS average_rating FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID = T2.rID GROUP BY T2.name"
        ],
        "rule_sql": [
            "SELECT T2.name, avg(T1.stars) FROM Rating T1 JOIN Reviewer T2 ON T1.rID = T2.rID GROUP BY T2.name"
        ]
    },
    "3837": {
        "db_id": "e_learning",
        "question": "What are the student ID and login name of the student who are enrolled in the most courses?",
        "ground_truth": "SELECT T1.student_id ,  T2.login_name FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do join `Student_Course_Enrolment AS T1` with `Students AS T2` on `T1.student_id = T2.student_id` instead of querying only the `students` table. Do add `GROUP BY T1.student_id` instead of omitting aggregation grouping. Do use `COUNT(*)` for enrollment counting instead of `COUNT(course_id)` without proper context. Do include both `T1.student_id` and `T2.login_name` in the SELECT list instead of selecting from a single table without joins. The amended query now correctly identifies the student with the most course enrollments by properly joining enrollment and student data before aggregation."
        ],
        "rules": [
            "1) When answering about \"student who are enrolled in the most courses\": join Student_Course_Enrolment AS T1 with Students AS T2 on T1.student_id = T2.student_id to combine enrollment and student data. 2) When counting course enrollments per student: use COUNT(*) for enrollment counting instead of COUNT(course_id) without proper context. 3) When grouping by student for enrollment counts: add GROUP BY T1.student_id to organize results by student. 4) When selecting student information: include both T1.student_id and T2.login_name in the output instead of selecting from a single table without joins. 5) When finding the student with the most enrollments: order by enrollment count in descending order and keep only the top row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id, login_name FROM students ORDER BY COUNT(course_id) DESC LIMIT 1;",
            "SELECT T1.student_id, T2.login_name\nFROM Student_Course_Enrolment AS T1\nJOIN Students AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.student_id, T2.login_name\nFROM Student_Course_Enrolment AS T1\nJOIN Students AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "986": {
        "db_id": "university_basketball",
        "question": "Count the number of schools that have had basketball matches.",
        "ground_truth": "SELECT count(DISTINCT school_id) FROM basketball_match",
        "amends": [
            "Do count `DISTINCT school_id` instead of `COUNT(*)` to count unique schools rather than all rows. Do query from `basketball_match` table instead of `schools` table to access the correct data source. Do remove the `WHERE sport = 'basketball'` filter instead of keeping it since the basketball context is already implied by the table name. The amended query now correctly counts distinct schools from the basketball match data instead of counting all rows from a general schools table with a sport filter."
        ],
        "rules": [
            "1) When counting schools from basketball match data: use the \"basketball_match\" table instead of the \"schools\" table to access the correct data source. 2) When counting the number of schools: count distinct \"school_id\" values instead of counting all rows to ensure each school is counted only once. 3) When the context is already implied by the table name (basketball_match): do not apply additional filters like \"sport = 'basketball'\" since the table specifically contains basketball matches."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM schools WHERE sport = 'basketball';",
            "SELECT COUNT(DISTINCT School_ID) FROM basketball_match;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT School_ID) FROM basketball_match;"
        ]
    },
    "6050": {
        "db_id": "game_1",
        "question": "What is the first and last name of all students who play Football or Lacrosse?",
        "ground_truth": "SELECT T2.lname ,  T2.fname FROM SportsInfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.SportName  =  \"Football\" OR T1.SportName  =  \"Lacrosse\"",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of no aliases. Do join `SportsInfo AS T1` with `Student AS T2` on `T1.StuID = T2.StuID` instead of querying a single table. Do select `T2.lname` and `T2.fname` instead of `first_name` and `last_name`. Do filter with `T1.SportName = \"Football\" OR T1.SportName = \"Lacrosse\"` instead of `sport = 'Football' AND sport = 'Lacrosse'` to find students who play either sport rather than requiring both sports simultaneously. The amended query now correctly identifies students participating in Football or Lacrosse by joining the appropriate tables and using OR logic instead of contradictory AND conditions.",
            "Do use lowercase column names `lname` and `fname` instead of uppercase `LName` and `Fname`. Do use double quotes `\"Football\"` and `\"Lacrosse\"` instead of single quotes for string literals. The amended query now correctly matches the RIGHT_SQL's behavior with proper column casing and string literal formatting.",
            "Do reverse the column order to `T2.lname, T2.fname` instead of `T2.fname, T2.lname` in the SELECT list, while maintaining the same FROM clause with `JOIN Student AS T2 ON T1.StuID = T2.StuID` and identical WHERE filter conditions `T1.SportName = \"Football\" OR T1.SportName = \"Lacrosse\"`. The amended query now matches RIGHT_SQL's behavior with the corrected column sequence."
        ],
        "rules": [
            "1) When answering about \"students who play Football or Lacrosse\": make sure the output order: T2.fname, T2.lname 2) When the question mentions \"first and last name\": \"first name\" actually means \"T2.fname in schema\" and \"last name\" actually means \"T2.lname in schema\" 3) When combining SportsInfo as T1 and Student as T2 for shared entities: link rows where T1.StuID = T2.StuID and keep only matching pairs (inner match) 4) When filtering for students who play Football or Lacrosse: use T1.SportName = \"Football\" OR T1.SportName = \"Lacrosse\" instead of requiring both sports simultaneously 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for literals like \"Football\" and \"Lacrosse\"",
            "1) When the question asks for \"first and last name\": use the exact column names \"fname\" and \"lname\" in lowercase as shown in the schema. 2) When the question mentions sports \"Football\" or \"Lacrosse\": use the exact string literals \"Football\" and \"Lacrosse\" with double quotes. 3) When combining SportsInfo (T1) and Student (T2) tables: link rows where T1.StuID equals T2.StuID to find students who play the specified sports.",
            "1) When answering about \"first and last name of all students who play Football or Lacrosse\": make sure the output order: T2.lname, T2.fname\n2) When combining SportsInfo (T1) and Student (T2) for shared entities: link rows where T1.StuID = T2.StuID exactly as shown; keep only matching pairs (inner match)\n3) When filtering for students who play specific sports: include only rows where T1.SportName = \"Football\" OR T1.SportName = \"Lacrosse\", preserving the exact case and spelling of sport names"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM students WHERE sport = 'Football' AND sport = 'Lacrosse';",
            "SELECT T2.Fname, T2.LName \nFROM SportsInfo AS T1 \nJOIN Student AS T2 ON T1.StuID = T2.StuID \nWHERE T1.SportName = 'Football' OR T1.SportName = 'Lacrosse'",
            "SELECT T2.fname, T2.lname\nFROM SportsInfo AS T1\nJOIN Student AS T2 ON T1.StuID = T2.StuID\nWHERE T1.SportName = \"Football\" OR T1.SportName = \"Lacrosse\"",
            "SELECT T2.lname, T2.fname\nFROM SportsInfo AS T1\nJOIN Student AS T2 ON T1.StuID = T2.StuID\nWHERE T1.SportName = \"Football\" OR T1.SportName = \"Lacrosse\""
        ],
        "rule_sql": [
            "SELECT T2.fname, T2.lname FROM SportsInfo T1 JOIN Student T2 ON T1.StuID = T2.StuID WHERE T1.SportName = \"Football\" OR T1.SportName = \"Lacrosse\""
        ]
    },
    "4538": {
        "db_id": "document_management",
        "question": "What are the names and urls of images, sorted alphabetically?",
        "ground_truth": "SELECT image_name ,  image_url FROM images ORDER BY image_name",
        "amends": [
            "Do select `image_name` and `image_url` instead of `name` and `url` to use the correct column names from the schema. Do order by `image_name` instead of `url ASC` to sort by the image name rather than the URL. The amended query now correctly retrieves and orders the image data as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for \"names and urls of images\": select \"image_name\" and \"image_url\" from the Images table. 2) When the question specifies \"sorted alphabetically\": order the results by \"image_name\" in ascending alphabetical order. 3) When choosing column names: use the exact identifiers \"image_name\" and \"image_url\" as they appear in the schema, not generic names like \"name\" and \"url\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, url FROM images ORDER BY url ASC;",
            "SELECT image_name, image_url FROM Images ORDER BY image_name ASC;"
        ],
        "rule_sql": [
            "SELECT image_name, image_url FROM Images ORDER BY image_name ASC;"
        ]
    },
    "3700": {
        "db_id": "baseball_1",
        "question": "Count the total number of games the team Boston Red Stockings attended from 1990 to 2000.",
        "ground_truth": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year BETWEEN 1990 AND 2000;",
        "amends": [
            "Do use `sum(T1.games)` instead of `COUNT(*)` to sum actual game counts rather than counting rows. Do join `home_game AS T1` with `team AS T2` instead of querying a single `games` table. Do use the join condition `T1.team_id = T2.team_id_br` instead of directly filtering by team name. Do filter by `T2.name = 'Boston Red Stockings'` in the WHERE clause instead of directly filtering the games table by team name. Do maintain the year filter `T1.year BETWEEN 1990 AND 2000` but apply it to the home_game table instead of the original games table. The amended query now correctly aggregates game counts from the home_game table while properly joining with the team table to identify the Boston Red Stockings by their team ID relationship, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting games attended by a team: use sum(T1.games) instead of COUNT(*) to sum actual game counts rather than counting rows. 2) When the question mentions \"Boston Red Stockings\": this refers to T2.name = 'Boston Red Stockings' in the team table. 3) When combining home_game and team tables: link rows where T1.team_id = T2.team_id_br and keep only matching pairs (inner match). 4) When filtering by year range 1990 to 2000: apply T1.year BETWEEN 1990 AND 2000 to the home_game table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE team = 'Boston Red Stockings' AND year BETWEEN 1990 AND 2000",
            "SELECT SUM(T1.games) AS total_games\nFROM home_game AS T1\nJOIN team AS T2 ON T1.team_id = T2.team_id_br\nWHERE T2.name = 'Boston Red Stockings'\nAND T1.year BETWEEN 1990 AND 2000"
        ],
        "rule_sql": [
            "SELECT SUM(hg.games) AS total_games\nFROM home_game hg\nINNER JOIN team t ON hg.team_id = t.team_id_br\nWHERE t.name = 'Boston Red Stockings'\nAND hg.year BETWEEN 1990 AND 2000"
        ]
    },
    "2914": {
        "db_id": "icfp_1",
        "question": "What is the first name of the author with last name \"Ueno\"?",
        "ground_truth": "SELECT fname FROM authors WHERE lname  =  \"Ueno\"",
        "amends": [
            "Do select `fname` instead of `first_name` and do filter on `lname` instead of `last_name` while removing the `ORDER BY author_id DESC LIMIT 1` clause instead of keeping it, as the right query simply retrieves the first name without ordering or limiting results."
        ],
        "rules": [
            "1) When the question asks for \"first name\" of an author: use the exact column token \"fname\" from the Authors table instead of \"first_name\". 2) When filtering by \"last name\" with value \"Ueno\": use the exact column token \"lname\" from the Authors table and match the exact literal value 'Ueno' with proper case. 3) When the question does not specify ordering or limiting results: do not apply any ORDER BY or LIMIT clauses to the query."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM authors WHERE last_name = 'Ueno' ORDER BY author_id DESC LIMIT 1;",
            "SELECT fname FROM Authors WHERE lname = 'Ueno'"
        ],
        "rule_sql": [
            "SELECT fname FROM Authors WHERE lname = 'Ueno';"
        ]
    },
    "6281": {
        "db_id": "city_record",
        "question": "IN which year did city \"Taizhou ( Zhejiang )\" serve as a host city?",
        "ground_truth": "SELECT T2.year FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city WHERE T1.city  =  \"Taizhou ( Zhejiang )\"",
        "amends": [
            "Do select `T2.year` from the `hosting_city` table instead of `year` from the `cities` table. Do use a `JOIN` between `city` and `hosting_city` tables on `T1.city_id = T2.host_city` instead of querying a single `cities` table. Do filter on `T1.city = \"Taizhou ( Zhejiang )\"` instead of `city = 'Taizhou (Zhejiang)' AND host = 'yes'`. Do remove the `host = 'yes'` condition entirely instead of including it, as the join to `hosting_city` inherently implies hosting status. The amended query now correctly retrieves the hosting year by properly relating city information through the appropriate table relationships."
        ],
        "rules": [
            "1) When answering about \"which year did city serve as a host city\": make sure the output order: T2.year. 2) When the question mentions \"city 'Taizhou ( Zhejiang )'\": \"city\" actually means \"T1.city in schema\" and the literal must be exactly \"Taizhou ( Zhejiang )\" with the exact spacing and parentheses. 3) When combining T1 (city) and T2 (hosting_city) for shared entities: link rows where T1.city_id = T2.host_city exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question implies hosting status: do not include host = 'yes' condition, as the join to hosting_city table inherently implies hosting status."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year FROM cities WHERE city = 'Taizhou (Zhejiang)' AND host = 'yes';",
            "SELECT T2.Year \nFROM city T1 \nJOIN hosting_city T2 ON T1.City_ID = T2.Host_City \nWHERE T1.City = 'Taizhou ( Zhejiang )'"
        ],
        "rule_sql": [
            "SELECT T2.Year\nFROM city T1\nINNER JOIN hosting_city T2 ON T1.City_ID = T2.Host_City\nWHERE T1.City = 'Taizhou ( Zhejiang )'\nORDER BY T2.Year"
        ]
    },
    "5863": {
        "db_id": "tracking_share_transactions",
        "question": "What are the sale details and dates of transactions with amount smaller than 3000?",
        "ground_truth": "SELECT T1.sales_details ,  T2.date_of_transaction FROM SALES AS T1 JOIN TRANSACTIONS AS T2 ON T1.sales_transaction_id  =  T2.transaction_id WHERE T2.amount_of_transaction  <  3000",
        "amends": [
            "Do select specific columns `T1.sales_details` and `T2.date_of_transaction` instead of using `*` to select all columns. Do join tables `SALES AS T1` and `TRANSACTIONS AS T2` instead of querying only the `transactions` table. Do use the join condition `T1.sales_transaction_id = T2.transaction_id` instead of having no join condition. Do filter on `T2.amount_of_transaction < 3000` instead of `amount > 3000` to use the correct column name and comparison operator. The amended query now correctly joins the sales and transactions tables and filters for transactions under 3000, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"sale details and dates of transactions with amount smaller than 3000\": make sure the output order: T1.sales_details, T2.date_of_transaction. 2) When combining SALES as T1 and TRANSACTIONS as T2: link rows where T1.sales_transaction_id = T2.transaction_id and keep only matching pairs (inner match). 3) When filtering for transactions with amount smaller than 3000: use T2.amount_of_transaction < 3000 instead of amount > 3000 to use the correct column name and comparison operator."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM transactions WHERE amount > 3000;",
            "SELECT T1.sales_details, T2.date_of_transaction \nFROM Sales AS T1 \nJOIN Transactions AS T2 ON T1.sales_transaction_id = T2.transaction_id \nWHERE T2.amount_of_transaction < 3000"
        ],
        "rule_sql": [
            "SELECT T1.sales_details, T2.date_of_transaction\nFROM Sales AS T1\nINNER JOIN Transactions AS T2 ON T1.sales_transaction_id = T2.transaction_id\nWHERE T2.amount_of_transaction < 3000"
        ]
    },
    "3728": {
        "db_id": "program_share",
        "question": "Find the names of channels that are not owned by CCTV.",
        "ground_truth": "SELECT name FROM channel WHERE OWNER != 'CCTV'",
        "amends": [
            "Do reference table `channel` instead of `channels` in the FROM clause. Do use inequality filter `OWNER != 'CCTV'` instead of equality filter `owner = 'CCTV'` in the WHERE clause. The amended query now correctly filters for channels not owned by CCTV and uses the proper table name."
        ],
        "rules": [
            "1) When the question asks about channels: use the exact table name \"channel\" instead of \"channels\" 2) When filtering for channels not owned by CCTV: use the inequality condition OWNER != 'CCTV' instead of equality condition 3) When selecting channel names: ensure the output column is \"name\" from the channel table"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM channels WHERE owner = 'CCTV';",
            "SELECT Name FROM channel WHERE Owner != 'CCTV';"
        ],
        "rule_sql": [
            "SELECT name FROM channel WHERE Owner != 'CCTV';"
        ]
    },
    "3006": {
        "db_id": "loan_1",
        "question": "How many bank branches are there?",
        "ground_truth": "SELECT count(*) FROM bank",
        "amends": [
            "Do query the `bank` table instead of the `employees` table. Do filter on the implicit table structure of `bank` instead of using `WHERE department = 'bank branch'` which referenced a non-existent column. The amended query now correctly counts records from the appropriate table and matches the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"how many bank branches\": query the \"bank\" table instead of the \"employees\" table. 2) When counting bank branches: count all records from the \"bank\" table without filtering on non-existent columns like \"department\". 3) When the question asks for count of entities: compute the number of rows using all records from the appropriate table as shown in the schema structure."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE department = 'bank branch';",
            "SELECT COUNT(*) FROM bank;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM bank;"
        ]
    },
    "6083": {
        "db_id": "customers_and_addresses",
        "question": "Find the list of cities that no customer is living in.",
        "ground_truth": "SELECT city FROM addresses WHERE city NOT IN ( SELECT DISTINCT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id)",
        "amends": [
            "Do query from `addresses` table instead of `cities` table. Do use a three-table join with `customers AS t1`, `customer_addresses AS t2`, and `addresses AS t3` instead of a simple subquery on `customers`. Do join on `t1.customer_id = t2.customer_id` and `t2.address_id = t3.address_id` instead of directly querying city from customers. Do add `DISTINCT` in the subquery to eliminate duplicate cities instead of potentially returning duplicates. Do reference `t3.city` from the joined addresses table instead of directly selecting city from customers. The amended query now correctly identifies cities from addresses that are not associated with any customer through the proper join relationships, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"cities that no customer is living in\": make sure the output order: city from addresses table. 2) When the question mentions \"cities\": \"cities\" actually means \"city in addresses table\". 3) When combining customers AS t1, customer_addresses AS t2, and addresses AS t3: link rows where t1.customer_id = t2.customer_id and t2.address_id = t3.address_id; keep only matching pairs (inner match). 4) When finding cities not associated with any customer: use a subquery that selects DISTINCT t3.city from the joined tables to eliminate duplicate cities. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city FROM cities WHERE city NOT IN (SELECT city FROM customers)",
            "SELECT DISTINCT a.city \nFROM Addresses a\nWHERE a.city NOT IN (\n    SELECT DISTINCT t3.city\n    FROM Customers t1\n    JOIN Customer_Addresses t2 ON t1.customer_id = t2.customer_id\n    JOIN Addresses t3 ON t2.address_id = t3.address_id\n)"
        ],
        "rule_sql": [
            "SELECT city FROM Addresses WHERE city NOT IN (SELECT DISTINCT a.city FROM Customers c JOIN Customer_Addresses ca ON c.customer_id = ca.customer_id JOIN Addresses a ON ca.address_id = a.address_id) ORDER BY city;"
        ]
    },
    "2537": {
        "db_id": "county_public_safety",
        "question": "What are the different police forces of counties that are not located in the East?",
        "ground_truth": "SELECT DISTINCT Police_force FROM county_public_safety WHERE LOCATION != \"East\"",
        "amends": [
            "Do reference table `county_public_safety` instead of `counties` and column `Police_force` instead of `police_force`. Do use filter `LOCATION != \"East\"` instead of `region != 'East'` while maintaining the `SELECT DISTINCT` clause. The amended query now correctly references the appropriate table and column names to match the intended data structure and filtering logic."
        ],
        "rules": [
            "1) When answering about \"different police forces of counties that are not located in the East\": make sure the output order: Police_force. 2) When the question mentions \"police forces\": \"police forces\" actually means \"Police_force in schema\". 3) When the question mentions \"counties that are not located in the East\": use filter LOCATION != \"East\" instead of region != 'East'. 4) When the question asks for \"different police forces\": use SELECT DISTINCT Police_force to get unique values. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for \"East\". 6) When handling text literals: do not change case, spacing, or punctuation for \"East\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT police_force FROM counties WHERE region != 'East';",
            "SELECT DISTINCT Police_force FROM county_public_safety WHERE Location != 'East';"
        ],
        "rule_sql": [
            "SELECT DISTINCT Police_force FROM county_public_safety WHERE Location != \"East\" ORDER BY Police_force;"
        ]
    },
    "4365": {
        "db_id": "tracking_grants_for_research",
        "question": "What is the type of the document whose description starts with the word 'Initial'?",
        "ground_truth": "SELECT document_type_code FROM Document_Types WHERE document_description LIKE 'Initial%'",
        "amends": [
            "Do select `document_type_code` instead of `type` and query from `Document_Types` instead of `documents`. Do filter on `document_description` instead of `description` while maintaining the same `LIKE 'Initial%'` pattern. The amended query now correctly references the appropriate table and column names to match the intended schema structure while preserving the same filtering logic."
        ],
        "rules": [
            "1) When the question asks for \"type of the document\": \"type\" actually means \"document_type_code\" in the Documents table. 2) When the question mentions \"description starts with the word 'Initial'\": filter on \"document_description\" column from Document_Types table using the exact pattern 'Initial%'. 3) When combining Document_Types and Documents tables: link rows where Document_Types.document_type_code = Documents.document_type_code using an inner match. 4) When answering about \"type of the document whose description starts with 'Initial'\": make sure the output order: document_type_code."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type FROM documents WHERE description LIKE 'Initial%';",
            "SELECT document_type_code FROM Document_Types WHERE document_description LIKE 'Initial%'"
        ],
        "rule_sql": [
            "SELECT d.document_type_code \nFROM Documents d\nJOIN Document_Types dt ON d.document_type_code = dt.document_type_code\nWHERE dt.document_description LIKE 'Initial%'\nORDER BY d.document_type_code;"
        ]
    },
    "827": {
        "db_id": "chinook_1",
        "question": "Find the names of all the tracks that contain the word \"you\".",
        "ground_truth": "SELECT Name FROM TRACK WHERE Name LIKE '%you%'",
        "amends": [
            "Do reference the table as `TRACK` instead of `tracks` and use column name `Name` instead of `name` in both the SELECT list and WHERE clause, while maintaining the same `LIKE '%you%'` filter condition. The amended query now correctly matches the RIGHT_SQL's behavior with proper table and column naming conventions."
        ],
        "rules": [
            "1) When the question asks for track names containing \"you\": use the exact table name \"TRACK\" and column name \"Name\" with double quotes as shown in the schema. 2) When filtering for tracks containing the word \"you\": use the exact literal pattern '%you%' with case-sensitive matching. 3) When selecting output columns: return only the \"Name\" column from the \"TRACK\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM tracks WHERE name LIKE '%you%';",
            "SELECT Name FROM Track WHERE Name LIKE '%you%'"
        ],
        "rule_sql": [
            "SELECT \"Name\" FROM \"Track\" WHERE \"Name\" LIKE '%you%';"
        ]
    },
    "5256": {
        "db_id": "music_2",
        "question": "Which vocal type did the musician with last name \"Heilo\" played in the song with title \"Der Kapitan\"?",
        "ground_truth": "SELECT TYPE FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid JOIN band AS T3 ON T1.bandmate  =  T3.id WHERE T3.lastname  =  \"Heilo\" AND T2.title  =  \"Der Kapitan\"",
        "amends": [
            "Do join `vocals AS T1` with `songs AS T2` on `T1.songid = T2.songid` and `band AS T3` on `T1.bandmate = T3.id` instead of querying only the `musicians` table. Do filter on `T3.lastname = \"Heilo\"` and `T2.title = \"Der Kapitan\"` instead of filtering `last_name` and `song_title` from a single table. Do select `TYPE` from the joined tables instead of selecting `vocal_type` from a non-existent column. The amended query now correctly retrieves vocal type information by properly joining the vocals, songs, and band tables with the appropriate relationships and filters."
        ],
        "rules": [
            "1) When answering about vocal type for musician \"Heilo\" in song \"Der Kapitan\": make sure the output order: TYPE from vocals table\n2) When the question mentions \"last name Heilo\": \"Heilo\" actually means T3.lastname = \"Heilo\" in schema\n3) When the question mentions \"song title Der Kapitan\": \"Der Kapitan\" actually means T2.title = \"Der Kapitan\" in schema\n4) When combining vocals (T1) and songs (T2) for shared entities: link rows where T1.songid = T2.songid exactly as shown in the amends; keep only matching pairs (inner match)\n5) When combining vocals (T1) and band (T3) for shared entities: link rows where T1.bandmate = T3.id exactly as shown in the amends; keep only matching pairs (inner match)\n6) When selecting vocal type information: use T1.TYPE from the vocals table instead of non-existent vocal_type column"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT vocal_type FROM musicians WHERE last_name = 'Heilo' AND song_title = 'Der Kapitan';",
            "SELECT T1.Type \nFROM Vocals AS T1 \nJOIN Songs AS T2 ON T1.SongId = T2.SongId \nJOIN Band AS T3 ON T1.Bandmate = T3.Id \nWHERE T3.Lastname = 'Heilo' AND T2.Title = 'Der Kapitan'"
        ],
        "rule_sql": [
            "SELECT T1.Type \nFROM Vocals T1\nJOIN Songs T2 ON T1.SongId = T2.SongId\nJOIN Band T3 ON T1.Bandmate = T3.Id\nWHERE T3.Lastname = 'Heilo' \nAND T2.Title = 'Der Kapitan'"
        ]
    },
    "3131": {
        "db_id": "assets_maintenance",
        "question": "Which engineer has visited the most times? Show the engineer id, first name and last name.",
        "ground_truth": "SELECT T1.engineer_id ,  T1.first_name ,  T1.last_name FROM Maintenance_Engineers AS T1 JOIN Engineer_Visits AS T2 GROUP BY T1.engineer_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.engineer_id`, `T1.first_name`, `T1.last_name` instead of `engineer_id`, `first_name`, `last_name`, `COUNT(*) as visit_count`. Do use `FROM Maintenance_Engineers AS T1 JOIN Engineer_Visits AS T2` instead of `FROM engineers`. Do remove the explicit `COUNT(*)` column from SELECT instead of including it. Do keep `GROUP BY T1.engineer_id` but change the table reference. Do maintain `ORDER BY count(*) DESC LIMIT 1` instead of `ORDER BY visit_count DESC LIMIT 1`. The amended query now correctly joins the Maintenance_Engineers and Engineer_Visits tables to count visits per engineer while returning engineer details.",
            "Do remove the `ON T1.engineer_id = T2.engineer_id` join condition instead of including it, as the RIGHT_SQL performs a cross join between the tables without any filtering predicate. Do keep the same `SELECT` list with `T1.engineer_id`, `T1.first_name`, and `T1.last_name` instead of changing it. Do maintain the `GROUP BY T1.engineer_id` and `ORDER BY count(*) DESC LIMIT 1` structure instead of altering the aggregation and ordering logic. The amended query now correctly performs a cross join between Maintenance_Engineers and Engineer_Visits tables and returns the engineer with the highest count of visit combinations."
        ],
        "rules": [
            "1) When answering about \"which engineer has visited the most times\": make sure the output order: T1.engineer_id, T1.first_name, T1.last_name. 2) When combining Maintenance_Engineers and Engineer_Visits tables: link rows where T1.engineer_id = T2.engineer_id and keep only matching pairs (inner match). 3) When counting visits per engineer: compute the number of rows using T2.engineer_id as the counting key. 4) When the question asks for \"the most times\": rank rows by visit count in descending order and keep the first 1 row. 5) When producing output: do not include the visit count column in the final results.",
            "1) When combining tables Maintenance_Engineers and Engineer_Visits: perform a cross join without any filtering condition instead of using an equality join on engineer_id. 2) When counting visit occurrences for engineers: count all row combinations from the cross join between Maintenance_Engineers and Engineer_Visits tables. 3) When finding the engineer with the most visits: group by T1.engineer_id, order by the count in descending order, and keep only the top result. 4) When selecting output columns: include T1.engineer_id, T1.first_name, and T1.last_name in that exact order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT engineer_id, first_name, last_name, COUNT(*) as visit_count \nFROM engineers \nGROUP BY engineer_id \nORDER BY visit_count DESC \nLIMIT 1;",
            "SELECT T1.engineer_id, T1.first_name, T1.last_name\nFROM Maintenance_Engineers AS T1\nJOIN Engineer_Visits AS T2 ON T1.engineer_id = T2.engineer_id\nGROUP BY T1.engineer_id\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT T1.engineer_id, T1.first_name, T1.last_name\nFROM Maintenance_Engineers AS T1\nJOIN Engineer_Visits AS T2\nGROUP BY T1.engineer_id\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.engineer_id, T1.first_name, T1.last_name\nFROM Maintenance_Engineers T1\nCROSS JOIN Engineer_Visits T2\nGROUP BY T1.engineer_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "1602": {
        "db_id": "customers_and_invoices",
        "question": "What is the invoice number and invoice date corresponding to the invoice with the greatest number of transactions?",
        "ground_truth": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number = T2.invoice_number` as the FROM source with an INNER JOIN instead of just `invoices`. Do change the SELECT list to `T2.invoice_number, T2.invoice_date` with explicit table aliases instead of `invoice_number, invoice_date`. Do add `GROUP BY T1.invoice_number` to aggregate by invoice instead of omitting it. Do change the ORDER BY to `count(*) DESC` to count all transactions per invoice group instead of `COUNT(transaction_id) DESC` which incorrectly attempted to aggregate without grouping. The amended query now correctly joins transaction and invoice tables, groups by invoice number to find the invoice with the most transactions, and returns the corresponding invoice details, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"invoice number and invoice date for the invoice with greatest number of transactions\": make sure the output order: T2.invoice_number, T2.invoice_date. 2) When combining Financial_transactions and Invoices tables: link rows where T1.invoice_number = T2.invoice_number using an inner join and keep only matching pairs. 3) When counting transactions per invoice: group by T1.invoice_number and count all rows in each group using count(*). 4) When finding the invoice with greatest number of transactions: rank invoices by transaction count in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT invoice_number, invoice_date FROM invoices ORDER BY COUNT(transaction_id) DESC LIMIT 1;",
            "SELECT T2.invoice_number, T2.invoice_date\nFROM Financial_Transactions AS T1\nJOIN Invoices AS T2 ON T1.invoice_number = T2.invoice_number\nGROUP BY T1.invoice_number\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.invoice_number, T2.invoice_date\nFROM Financial_Transactions T1\nINNER JOIN Invoices T2 ON T1.invoice_number = T2.invoice_number\nGROUP BY T1.invoice_number\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "2618": {
        "db_id": "inn_1",
        "question": "Find the number of rooms with king bed for each decor type.",
        "ground_truth": "SELECT decor ,  count(*) FROM Rooms WHERE bedType = \"King\" GROUP BY decor;",
        "amends": [
            "Do use column name `decor` instead of `decor_type` in both SELECT list and GROUP BY clause. Do use table name `Rooms` instead of `rooms` in FROM clause. Do use filter condition `bedType = \"King\"` instead of `bed_type = 'king'` in WHERE clause. The amended query now correctly references the schema elements and matches the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"decor type\": use the exact column name \"decor\" from the Rooms table instead of \"decor_type\". 2) When filtering for king beds: use the exact literal value \"King\" (with capital K) and column name \"bedType\" instead of 'king' and bed_type. 3) When referencing the rooms table: use the exact table name \"Rooms\" (with capital R) instead of \"rooms\". 4) When counting rooms per decor type: count using the canonical key for rooms (implied by the table structure) and group by the \"decor\" column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT decor_type, COUNT(*) FROM rooms WHERE bed_type = 'king' GROUP BY decor_type;",
            "SELECT decor, COUNT(*) AS room_count FROM Rooms WHERE bedType = \"King\" GROUP BY decor;"
        ],
        "rule_sql": [
            "SELECT decor, COUNT(*) AS room_count FROM Rooms WHERE bedType = 'King' GROUP BY decor;"
        ]
    },
    "1280": {
        "db_id": "game_injury",
        "question": "What is the season of the game which causes the player 'Walter Samuel' to get injured?",
        "ground_truth": "SELECT T1.season FROM game AS T1 JOIN injury_accident AS T2 ON T1.id  =  T2.game_id WHERE T2.player  =  'Walter Samuel'",
        "amends": [
            "Do join `game AS T1` with `injury_accident AS T2` on `T1.id = T2.game_id` instead of querying only the `games` table. Do filter on `T2.player = 'Walter Samuel'` instead of filtering on `player_name = 'Walter Samuel' AND injury = 'yes'`. Do select `T1.season` instead of just `season`. The amended query now correctly retrieves seasons from game records joined with injury accident data where the specified player was involved, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"the season of the game which causes the player 'Walter Samuel' to get injured\": make sure the output order: T1.season. 2) When combining T1 (game) and T2 (injury_accident) for shared entities: link rows where T1.id = T2.game_id exactly as shown; keep only matching pairs (inner match). 3) When the question mentions \"player 'Walter Samuel'\": \"Walter Samuel\" actually means T2.player = 'Walter Samuel' in schema. 4) When the question mentions \"get injured\": this condition is implicitly satisfied by joining with injury_accident table T2, so no additional injury filter is needed."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT season FROM games WHERE player_name = 'Walter Samuel' AND injury = 'yes'",
            "SELECT T1.Season FROM game AS T1 JOIN injury_accident AS T2 ON T1.id = T2.game_id WHERE T2.Player = 'Walter Samuel'"
        ],
        "rule_sql": [
            "SELECT T1.Season FROM game T1 INNER JOIN injury_accident T2 ON T1.id = T2.game_id WHERE T2.Player = 'Walter Samuel'"
        ]
    },
    "1993": {
        "db_id": "gas_company",
        "question": "How many gas companies are there?",
        "ground_truth": "SELECT count(*) FROM company",
        "amends": [
            "Do reference the `company` table instead of the `companies` table. Do remove the `WHERE type = 'oil'` filter instead of keeping it. The amended query now correctly counts all records from the company table without unnecessary filtering."
        ],
        "rules": [
            "1) When answering about \"how many gas companies\": make sure to count all records from the \"company\" table without filtering by type. 2) When the question mentions \"companies\": \"companies\" actually means \"company\" in the schema. 3) When the question asks for \"count of gas companies\": compute the number of rows using all records from the \"company\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM companies WHERE type = 'oil'",
            "SELECT COUNT(*) FROM company;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM company;"
        ]
    },
    "2259": {
        "db_id": "machine_repair",
        "question": "List the names of technicians who have not been assigned to repair machines.",
        "ground_truth": "SELECT Name FROM technician WHERE technician_id NOT IN (SELECT technician_id FROM repair_assignment)",
        "amends": [
            "Do reference the `technician` table instead of `technicians` and use column `Name` instead of `name`. Do use the `repair_assignment` table instead of `repairs` in the subquery while keeping the same `technician_id` column reference and NOT IN logic. The amended query now correctly identifies technicians without repair assignments by using the appropriate table names and column casing."
        ],
        "rules": [
            "1) When the question asks about technicians who have not been assigned repairs: use table \"technician\" (as T1) instead of \"technicians\" and output column \"Name\" instead of \"name\". 2) When checking for unassigned technicians: use table \"repair_assignment\" instead of \"repairs\" in the subquery while maintaining the same \"technician_id\" column reference and NOT IN logic. 3) When combining technician and repair_assignment data: use the exact column \"technician_id\" as the linking key between tables to identify technicians without assignments."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM technicians WHERE technician_id NOT IN (SELECT technician_id FROM repairs)",
            "SELECT Name FROM technician WHERE technician_id NOT IN (SELECT technician_id FROM repair_assignment)"
        ],
        "rule_sql": [
            "SELECT Name FROM technician WHERE technician_id NOT IN (SELECT technician_id FROM repair_assignment)"
        ]
    },
    "6940": {
        "db_id": "tracking_orders",
        "question": "What are the names of the customers who have made two or less orders?",
        "ground_truth": "SELECT T2.customer_name FROM orders AS T1 JOIN customers AS T2 ON T1.customer_id = T2.customer_id GROUP BY T2.customer_id HAVING count(*)  <=  2",
        "amends": [
            "Do use `JOIN` with `customers` table instead of a subquery in `WHERE`. Do reference `T2.customer_name` in the SELECT list instead of `c.name`. Do group by `T2.customer_id` instead of grouping within a subquery. Do use `HAVING count(*) <= 2` instead of `HAVING COUNT(o.order_id) >= 2` to filter for customers with at most two orders rather than at least two orders. Do remove the subquery structure entirely instead of keeping it. The amended query now correctly identifies customers with two or fewer orders by joining the tables directly and applying the proper aggregate filter."
        ],
        "rules": [
            "1) When answering about customer names who have made two or less orders: make sure the output order includes T2.customer_name. 2) When combining customers and orders tables: link rows where T1.customer_id = T2.customer_id and keep only matching pairs (inner match). 3) When grouping by customer: organize results by T2.customer_id and compute requested aggregates per group. 4) When filtering for customers with two or less orders: use HAVING count(*) <= 2 to filter for customers with at most two orders. 5) When the question asks for customer names: use T2.customer_name instead of c.name in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name \nFROM customers c \nWHERE c.customer_id IN (\n    SELECT o.customer_id \n    FROM orders o \n    GROUP BY o.customer_id \n    HAVING COUNT(o.order_id) >= 2\n)",
            "SELECT c.customer_name\nFROM Customers c\nJOIN Orders o ON c.customer_id = o.customer_id\nGROUP BY c.customer_id\nHAVING COUNT(*) <= 2"
        ],
        "rule_sql": [
            "SELECT T2.customer_name\nFROM Orders T1\nINNER JOIN Customers T2 ON T1.customer_id = T2.customer_id\nGROUP BY T2.customer_id\nHAVING COUNT(*) <= 2\nORDER BY T2.customer_name;"
        ]
    },
    "2909": {
        "db_id": "icfp_1",
        "question": "Who has written a paper that has the word \"Functional\" in its title? Return the first names of the authors.",
        "ground_truth": "SELECT t1.fname FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid WHERE t3.title LIKE \"%Functional%\"",
        "amends": [
            "Do select `t1.fname` instead of `first_name` to use the correct column name with table alias. Do add `authorship AS t2` and `papers AS t3` tables instead of querying only the `authors` table to enable proper joins. Do use `JOIN` with `t1.authid = t2.authid` and `t2.paperid = t3.paperid` conditions instead of no joins to properly link authors to their papers. Do apply the `LIKE \"%Functional%\"` filter on `t3.title` instead of `title` to search paper titles rather than author titles. The amended query now correctly retrieves author names based on paper content rather than incorrectly searching for titles in the authors table."
        ],
        "rules": [
            "1) When the question asks for \"first names of the authors\": use the exact column token \"t1.fname\" instead of \"first_name\" to match the schema's column name with table alias. 2) When searching for papers with the word \"Functional\" in the title: apply the LIKE '%Functional%' filter on \"t3.title\" (the Papers table's title column) instead of any other table's title column. 3) When linking authors to their papers: combine tables using inner matches where \"t1.authid = t2.authid\" (Authors to Authorship) and \"t2.paperid = t3.paperid\" (Authorship to Papers) to properly connect authors with their written papers. 4) When answering about authors who wrote papers: include both Authorship (t2) and Papers (t3) tables in addition to Authors (t1) to enable proper relationship traversal between entities."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM authors WHERE title LIKE '%Functional%';",
            "SELECT t1.fname \nFROM Authors AS t1\nJOIN Authorship AS t2 ON t1.authID = t2.authID\nJOIN Papers AS t3 ON t2.paperID = t3.paperID\nWHERE t3.title LIKE '%Functional%'"
        ],
        "rule_sql": [
            "SELECT DISTINCT t1.fname FROM Authors t1 JOIN Authorship t2 ON t1.authID = t2.authID JOIN Papers t3 ON t2.paperID = t3.paperID WHERE t3.title LIKE '%Functional%'"
        ]
    },
    "2839": {
        "db_id": "restaurant_1",
        "question": "When did Linda Smith visit Subway?",
        "ground_truth": "SELECT TIME FROM Student JOIN Visits_Restaurant ON Student.StuID = Visits_Restaurant.StuID JOIN Restaurant ON Visits_Restaurant.ResID = Restaurant.ResID WHERE Student.Fname = \"Linda\" AND Student.Lname = \"Smith\" AND Restaurant.ResName = \"Subway\";",
        "amends": [
            "Do select `TIME` instead of `visit_date` and use proper table joins instead of direct table references. Do join `Student` and `Visits_Restaurant` on `Student.StuID = Visits_Restaurant.StuID` instead of querying a single `visits` table. Do join `Restaurant` on `Visits_Restaurant.ResID = Restaurant.ResID` instead of filtering by restaurant name directly. Do filter by `Student.Fname = \"Linda\"` and `Student.Lname = \"Smith\"` instead of `visitor_name = 'Linda Smith'` to properly separate first and last names. Do filter by `Restaurant.ResName = \"Subway\"` instead of `restaurant = 'McDonalds'` to query the correct restaurant establishment. The amended query now correctly joins normalized tables and matches the intended behavior."
        ],
        "rules": [
            "1) When answering about \"When did Linda Smith visit Subway?\": make sure the output order: TIME\n2) When the question mentions \"Linda Smith\": \"Linda Smith\" actually means \"Student.Fname = 'Linda' and Student.Lname = 'Smith' in schema\"\n3) When the question mentions \"Subway\": \"Subway\" actually means \"Restaurant.ResName = 'Subway' in schema\"\n4) When combining Student and Visits_Restaurant for shared entities: link rows where Student.StuID = Visits_Restaurant.StuID; keep only matching pairs (inner match)\n5) When combining Visits_Restaurant and Restaurant for shared entities: link rows where Visits_Restaurant.ResID = Restaurant.ResID; keep only matching pairs (inner match)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT visit_date FROM visits WHERE visitor_name = 'Linda Smith' AND restaurant = 'McDonalds';",
            "SELECT vr.Time \nFROM Visits_Restaurant vr\nJOIN Student s ON vr.StuID = s.StuID\nJOIN Restaurant r ON vr.ResID = r.ResID\nWHERE s.Fname = 'Linda' \nAND s.LName = 'Smith' \nAND r.ResName = 'Subway';"
        ],
        "rule_sql": [
            "SELECT vr.Time \nFROM Student s\nJOIN Visits_Restaurant vr ON s.StuID = vr.StuID\nJOIN Restaurant r ON vr.ResID = r.ResID\nWHERE s.Fname = 'Linda' AND s.Lname = 'Smith' AND r.ResName = 'Subway'\nORDER BY vr.Time;"
        ]
    },
    "4768": {
        "db_id": "department_store",
        "question": "What are the ids of all products that were either ordered more than 3 times or have a cumulative amount purchased of above 80000?",
        "ground_truth": "SELECT product_id FROM Order_Items GROUP BY product_id HAVING count(*)  >  3 UNION SELECT product_id FROM Product_Suppliers GROUP BY product_id HAVING sum(total_amount_purchased)  >  80000",
        "amends": [
            "Do use `UNION` to combine results from two separate aggregate queries instead of a single `WHERE` clause with `OR` conditions. Do query `Order_Items` table with `GROUP BY product_id` and `HAVING count(*) > 3` instead of filtering `orders` table with `order_count > 3`. Do query `Product_Suppliers` table with `GROUP BY product_id` and `HAVING sum(total_amount_purchased) > 80000` instead of filtering with `total_amount > 80000`. Do use aggregate function `sum()` on `total_amount_purchased` instead of direct column comparison. Do remove the `WHERE` clause entirely and replace with `HAVING` clauses in separate grouped queries. The amended query now correctly identifies products meeting either condition through proper aggregation and union, matching the intended behavior."
        ],
        "rules": [
            "1) When counting orders per product: use the Order_Items table with GROUP BY product_id and count the number of rows using count(*) to get order counts. 2) When calculating cumulative purchase amounts per product: use the Product_Suppliers table with GROUP BY product_id and sum the total_amount_purchased column to get cumulative amounts. 3) When identifying products that meet either condition (order count > 3 OR cumulative amount > 80000): use UNION to combine results from separate aggregate queries instead of a single WHERE clause with OR conditions. 4) When filtering aggregated results: use HAVING clauses in grouped queries instead of WHERE clauses for aggregate conditions like count(*) > 3 and sum(total_amount_purchased) > 80000."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT product_id \nFROM orders \nWHERE order_count > 3 OR total_amount > 80000",
            "SELECT product_id\nFROM (\n    SELECT product_id\n    FROM Order_Items\n    GROUP BY product_id\n    HAVING COUNT(*) > 3\n    \n    UNION\n    \n    SELECT product_id\n    FROM Product_Suppliers\n    GROUP BY product_id\n    HAVING SUM(CAST(total_amount_purchased AS DECIMAL)) > 80000\n) AS combined_results"
        ],
        "rule_sql": [
            "SELECT product_id FROM (\n    SELECT product_id, COUNT(*) as order_count\n    FROM Order_Items\n    GROUP BY product_id\n    HAVING COUNT(*) > 3\n    \n    UNION\n    \n    SELECT product_id, SUM(CAST(total_amount_purchased AS DECIMAL)) as cumulative_amount\n    FROM Product_Suppliers\n    GROUP BY product_id\n    HAVING SUM(CAST(total_amount_purchased AS DECIMAL)) > 80000\n) AS combined_results"
        ]
    },
    "274": {
        "db_id": "twitter_1",
        "question": "Find the emails of the user named \"Mary\".",
        "ground_truth": "SELECT email FROM user_profiles WHERE name  =  'Mary'",
        "amends": [
            "Do query the `user_profiles` table instead of the `users` table, as the correct data source for email addresses associated with names. The amended query now matches RIGHT_SQL's behavior by retrieving email information from the appropriate table structure."
        ],
        "rules": [
            "1) When the question asks for emails of users: query the \"user_profiles\" table instead of the \"users\" table as the correct data source for email addresses. 2) When the question specifies a user named \"Mary\": filter rows where the name column equals the exact literal 'Mary' (case-sensitive). 3) When retrieving email information: select the email column from the \"user_profiles\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT email FROM users WHERE name = 'Mary';",
            "SELECT email FROM user_profiles WHERE name = 'Mary';"
        ],
        "rule_sql": [
            "SELECT email FROM user_profiles WHERE name = 'Mary'"
        ]
    },
    "4382": {
        "db_id": "tracking_grants_for_research",
        "question": "List the organisation id with the maximum outcome count, and the count.",
        "ground_truth": "SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.organisation_id` and `count(*)` without an alias instead of selecting `organisation_id` and `COUNT(*) as outcome_count`. Do join `Projects AS T1` with `Project_outcomes AS T2` on `T1.project_id = T2.project_id` instead of querying only the `outcomes` table. Do group by `T1.organisation_id` instead of grouping by `organisation_id` from a single table. Do order by `count(*) DESC` instead of ordering by `outcome_count ASC`. The amended query now correctly counts project outcomes per organization from the joined tables and returns the organization with the highest count instead of the lowest, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"organisation id with the maximum outcome count\": make sure the output order: T1.organisation_id, count(*). 2) When the question mentions \"outcome count\": \"outcome count\" actually means \"count of project outcomes in schema\" using T2.project_id. 3) When combining Projects AS T1 and Project_outcomes AS T2: link rows where T1.project_id = T2.project_id exactly as shown; keep only matching pairs (inner match). 4) When the question asks for \"count of outcomes\": compute the number of rows using the canonical key token T2.project_id. 5) When the question asks for \"maximum outcome count\": rank rows by count(*) in descending direction and keep the first 1 row. 6) When the question says \"per organisation_id\": organize results by T1.organisation_id and compute count(*) per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT organisation_id, COUNT(*) as outcome_count \nFROM outcomes \nGROUP BY organisation_id \nORDER BY outcome_count ASC \nLIMIT 1;",
            "SELECT T1.organisation_id, count(*)\nFROM Projects AS T1\nJOIN Project_Outcomes AS T2 ON T1.project_id = T2.project_id\nGROUP BY T1.organisation_id\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.organisation_id, COUNT(*) \nFROM Projects AS T1 \nINNER JOIN Project_Outcomes AS T2 ON T1.project_id = T2.project_id \nGROUP BY T1.organisation_id \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ]
    },
    "2984": {
        "db_id": "sakila_1",
        "question": "Which movies have 'Deleted Scenes' as a substring in the special feature?",
        "ground_truth": "SELECT title FROM film WHERE special_features LIKE '%Deleted Scenes%'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM film WHERE special_features LIKE '%Deleted Scenes%';"
        ],
        "rule_sql": [
            "SELECT film_id, title, special_features FROM film WHERE special_features LIKE '%Deleted Scenes%';",
            "SELECT film_id, title, special_features FROM film WHERE special_features LIKE '%Deleted Scenes%';"
        ]
    },
    "6205": {
        "db_id": "roller_coaster",
        "question": "What are the lengths and heights of roller coasters?",
        "ground_truth": "SELECT LENGTH ,  Height FROM roller_coaster",
        "amends": [
            "Do reference the table as `roller_coaster` instead of `roller_coasters` to match the correct table name. Do include only `LENGTH` and `Height` columns instead of adding the extra `name` column that was not present in the right query. Do remove the `WHERE height > 1000` filter instead of keeping it, as the right query does not include any filtering conditions. The amended query now correctly selects only the LENGTH and Height columns from the roller_coaster table without any filtering, matching the behavior of the right SQL."
        ],
        "rules": [
            "1) When the question asks for roller coasters information: use the exact table name \"roller_coaster\" instead of \"roller_coasters\". 2) When selecting columns for roller coasters: include only \"LENGTH\" and \"Height\" columns, not additional columns like \"name\". 3) When no filtering conditions are specified in the question: do not apply any WHERE clause filters like \"height > 1000\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, length, height FROM roller_coasters WHERE height > 1000;",
            "SELECT Length, Height FROM roller_coaster"
        ],
        "rule_sql": [
            "SELECT Length, Height FROM roller_coaster;"
        ]
    },
    "4492": {
        "db_id": "decoration_competition",
        "question": "Show the names of members and names of colleges they go to.",
        "ground_truth": "SELECT T2.Name ,  T1.Name FROM college AS T1 JOIN member AS T2 ON T1.College_ID  =  T2.College_ID",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference `T2.Name` and `T1.Name` instead of `members.name` and `colleges.name`. Do join `college AS T1` with `member AS T2` instead of `members` with `colleges`. Do use join condition `T1.College_ID = T2.College_ID` instead of `members.college_id = colleges.id`. The amended query now correctly matches the intended table relationships and column references."
        ],
        "rules": [
            "1) When joining college and member tables: use T1 as alias for college table and T2 as alias for member table. 2) When selecting names from tables: use T2.Name for member names and T1.Name for college names. 3) When combining college and member tables: link rows where T1.College_ID equals T2.College_ID using inner match. 4) When answering about member and college names: make sure the output order is T2.Name followed by T1.Name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT members.name, colleges.name FROM members JOIN colleges ON members.college_id = colleges.id;",
            "SELECT T2.Name, T1.Name FROM college AS T1 JOIN member AS T2 ON T1.College_ID = T2.College_ID"
        ],
        "rule_sql": [
            "SELECT T2.Name, T1.Name FROM college T1 INNER JOIN member T2 ON T1.College_ID = T2.College_ID ORDER BY T2.Name, T1.Name;"
        ]
    },
    "369": {
        "db_id": "flight_1",
        "question": "What is the name and salary for employee with id 242518965?",
        "ground_truth": "SELECT name ,  salary FROM Employee WHERE eid  =  242518965",
        "amends": [
            "Do reference the table as `Employee` instead of `employees` in the FROM clause. Do use the column `eid` instead of `employee_id` in the WHERE filter. Do remove the single quotes around the numeric value `242518965` instead of treating it as a string literal. The amended query now correctly matches the RIGHT_SQL's behavior by using proper table and column names with appropriate numeric comparison semantics."
        ],
        "rules": [
            "1) When the question asks about employee information: use table \"Employee\" instead of \"employees\" 2) When filtering by employee id: use column \"eid\" instead of \"employee_id\" 3) When comparing numeric employee id values: do not use quotes around the numeric literal 242518965"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, salary FROM employees WHERE employee_id = '242518965';",
            "SELECT name, salary FROM Employee WHERE eid = 242518965"
        ],
        "rule_sql": [
            "SELECT name, salary FROM employee WHERE eid = 242518965"
        ]
    },
    "5170": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "What is the description of the service type which offers both the photo product and the film product?",
        "ground_truth": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'photo' INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'film'",
        "amends": [
            "Do use `Ref_Service_Types AS T1` and `Services AS T2` as FROM sources instead of only `service_types`. Do add `JOIN` with `T1.Service_Type_Code = T2.Service_Type_Code` instead of no join condition. Do change WHERE filter to `T2.Product_Name = 'photo'` instead of `product = 'photo' AND product = 'film'` which is impossible. Do add `INTERSECT` with another query for `T2.Product_Name = 'film'` instead of trying to filter for both values in the same row. Do select `T1.Service_Type_Description` instead of `description`. The amended query now correctly finds service types that work with both photo and film products using intersection logic."
        ],
        "rules": [
            "1) When answering about service types that offer both photo and film products: use tables Ref_Service_Types AS T1 and Services AS T2 instead of only service_types. 2) When combining T1 and T2: link rows where T1.Service_Type_Code = T2.Service_Type_Code and keep only matching pairs (inner match). 3) When filtering for photo products: use T2.Product_Name = 'photo' instead of product = 'photo'. 4) When filtering for film products: use T2.Product_Name = 'film' instead of product = 'film'. 5) When finding service types that work with both products: use INTERSECT logic between queries for photo and film instead of trying to filter for both values in the same row. 6) When selecting the description: use T1.Service_Type_Description instead of description."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description FROM service_types WHERE product = 'photo' AND product = 'film';",
            "SELECT T1.Service_Type_Description\nFROM Ref_Service_Types AS T1\nJOIN Services AS T2 ON T1.Service_Type_Code = T2.Service_Type_Code\nWHERE T2.Product_Name = 'photo'\nINTERSECT\nSELECT T1.Service_Type_Description\nFROM Ref_Service_Types AS T1\nJOIN Services AS T2 ON T1.Service_Type_Code = T2.Service_Type_Code\nWHERE T2.Product_Name = 'film'"
        ],
        "rule_sql": [
            "SELECT T1.Service_Type_Description\nFROM Ref_Service_Types AS T1\nJOIN Services AS T2 ON T1.Service_Type_Code = T2.Service_Type_Code\nWHERE T2.Product_Name = 'photo'\nINTERSECT\nSELECT T1.Service_Type_Description\nFROM Ref_Service_Types AS T1\nJOIN Services AS T2 ON T1.Service_Type_Code = T2.Service_Type_Code\nWHERE T2.Product_Name = 'film'"
        ]
    },
    "4642": {
        "db_id": "college_3",
        "question": "What are the course names for courses taught on MTW?",
        "ground_truth": "SELECT CName FROM COURSE WHERE Days  =  \"MTW\"",
        "amends": [
            "Do reference the column as `CName` instead of `course_name` and use table name `COURSE` instead of `courses`. Do use the column name `Days` instead of `days_taught` for the filter condition. Do use double quotes `\"MTW\"` instead of single quotes `'MTW'` for the string literal. The amended query now correctly retrieves course names from the COURSE table where the days taught are MTW, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for course names: use the exact column name \"CName\" from the COURSE table. 2) When filtering for courses taught on specific days: use the exact column name \"Days\" from the COURSE table. 3) When matching the literal value \"MTW\": use double quotes exactly as \"MTW\" (not single quotes). 4) When answering about courses taught on MTW: make sure the output order shows only \"CName\" values where \"Days\" equals \"MTW\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_name FROM courses WHERE days_taught = 'MTW';",
            "SELECT CName FROM Course WHERE Days = \"MTW\";"
        ],
        "rule_sql": [
            "SELECT CName FROM Course WHERE Days = \"MTW\";"
        ]
    },
    "6186": {
        "db_id": "music_4",
        "question": "What are the categories of music festivals for which there have been more than 1 music festival?",
        "ground_truth": "SELECT Category FROM music_festival GROUP BY Category HAVING COUNT(*)  >  1",
        "amends": [
            "Do reference the table as `music_festival` instead of `music_festivals` and use `Category` instead of `category` for the column name. Do remove the alias `festival_count` from the SELECT clause instead of keeping it, and reference the aggregate function directly in the HAVING clause as `COUNT(*) > 1` instead of using the alias `festival_count > 1`. Do select only the `Category` column instead of including both `category` and the count expression. The amended query now correctly identifies duplicate categories by counting occurrences directly in the HAVING clause without unnecessary aliasing."
        ],
        "rules": [
            "1) When answering about categories of music festivals: make sure the output order is only the Category column. 2) When the question mentions \"categories\": \"categories\" actually means \"Category in schema\" with exact case. 3) When the question asks for \"categories for which there have been more than 1 music festival\": organize results by Category and compute COUNT(*) > 1 per group. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 5) When handling text literals: do not change case, spacing, or punctuation from the schema's exact tokens."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT category, COUNT(*) as festival_count FROM music_festivals GROUP BY category HAVING festival_count > 1;",
            "SELECT Category FROM music_festival GROUP BY Category HAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT \"Category\" FROM \"music_festival\" GROUP BY \"Category\" HAVING COUNT(*) > 1"
        ]
    },
    "4412": {
        "db_id": "network_2",
        "question": "Who is the youngest male?",
        "ground_truth": "SELECT name FROM Person WHERE gender  =  'male' AND age  =  (SELECT min(age) FROM person WHERE gender  =  'male' )",
        "amends": [
            "Do select only `name` instead of all columns with `*`. Do query from `Person` table instead of `people`. Do filter for `gender = 'male'` instead of `gender = 'female'`. Do add a subquery to find `min(age)` for males instead of simple `ORDER BY age ASC LIMIT 1`. Do use `AND age =` to match the minimum age instead of limiting to one arbitrary row. Do remove the explicit `ORDER BY` and `LIMIT` clauses since the subquery handles the age filtering logic. The amended query now correctly identifies the name of the youngest male person instead of returning an arbitrary female with the lowest age."
        ],
        "rules": [
            "1) When answering about \"the youngest male\": make sure the output order: name. 2) When the question mentions \"male\": \"male\" actually means \"gender = 'male'\" in schema. 3) When the question asks for \"youngest\": find the minimum age value for males using min(age) and match rows where age equals that minimum value. 4) When selecting from the person table: use the exact table name \"Person\" instead of \"people\". 5) When producing output: select only the \"name\" column instead of all columns with *."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM people WHERE gender = 'female' ORDER BY age ASC LIMIT 1;",
            "SELECT name FROM Person WHERE gender = 'male' AND age = (SELECT MIN(age) FROM Person WHERE gender = 'male')"
        ],
        "rule_sql": [
            "SELECT name FROM Person WHERE gender = 'male' AND age = (SELECT MIN(age) FROM Person WHERE gender = 'male')"
        ]
    },
    "1233": {
        "db_id": "apartment_rentals",
        "question": "What are the guest first name, start date, and end date of each apartment booking?",
        "ground_truth": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id",
        "amends": [
            "Do specify table aliases `T2.guest_first_name`, `T1.booking_start_date` instead of unqualified column names. Do join `Apartment_Bookings AS T1` and `Guests AS T2` instead of querying only the `bookings` table. Do use the join condition `ON T1.guest_id = T2.guest_id` instead of filtering by `booking_type = 'hotel'`. Do select `booking_start_date` twice instead of `start_date` and `end_date`. The amended query now correctly joins guest information with booking details.",
            "Do select `T1.booking_start_date` twice instead of selecting `T1.booking_end_date` in the second position. The amended query now matches RIGHT_SQL's behavior by correctly retrieving the guest's first name along with the booking start date repeated twice instead of including the booking end date."
        ],
        "rules": [
            "1) When answering about apartment bookings: join Apartment_Bookings AS T1 and Guests AS T2 using the condition T1.guest_id = T2.guest_id to combine guest information with booking details. 2) When selecting guest first name: use T2.guest_first_name instead of unqualified column names. 3) When selecting booking dates: use T1.booking_start_date for both start date and end date instead of start_date and end_date. 4) When combining tables: perform an inner match where T1.guest_id equals T2.guest_id to keep only matching pairs of booking and guest records.",
            "1) When selecting columns for apartment booking information: ensure the output order is T2.guest_first_name, T1.booking_start_date, T1.booking_start_date (select booking_start_date twice instead of booking_end_date in the second position)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT guest_first_name, start_date, end_date FROM bookings WHERE booking_type = 'hotel';",
            "SELECT T2.guest_first_name, T1.booking_start_date, T1.booking_end_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id = T2.guest_id",
            "SELECT T2.guest_first_name, T1.booking_start_date, T1.booking_start_date\nFROM Apartment_Bookings AS T1\nJOIN Guests AS T2 ON T1.guest_id = T2.guest_id"
        ],
        "rule_sql": [
            "SELECT T2.guest_first_name, T1.booking_start_date, T1.booking_start_date FROM Apartment_Bookings AS T1 INNER JOIN Guests AS T2 ON T1.guest_id = T2.guest_id"
        ]
    },
    "3590": {
        "db_id": "music_1",
        "question": "What are the names of all male British artists?",
        "ground_truth": "SELECT artist_name FROM artist WHERE country  =  \"UK\" AND gender  =  \"Male\"",
        "amends": [
            "Do reference `artist_name` instead of `name` and use table `artist` instead of `artists`. Do filter on `country = \"UK\"` instead of `nationality = 'British'` and use `gender = \"Male\"` instead of `gender = 'male'` with proper case sensitivity and quote style. The amended query now correctly selects artist names from the artist table filtered by UK country and Male gender, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"names of all male British artists\": make sure the output order: artist_name. 2) When the question mentions \"names\": \"names\" actually means \"artist_name in schema\". 3) When the question mentions \"male\": \"male\" actually means \"gender = \\\"Male\\\" in schema\" with exact case and double quotes. 4) When the question mentions \"British\": \"British\" actually means \"country = \\\"UK\\\" in schema\" with exact literal value and double quotes. 5) When selecting from the artist table: use table name \"artist\" not \"artists\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM artists WHERE gender = 'male' AND nationality = 'British';",
            "SELECT artist_name FROM artist WHERE country = 'UK' AND gender = 'Male';"
        ],
        "rule_sql": [
            "SELECT artist_name FROM artist WHERE gender = \"Male\" AND country = \"UK\";"
        ]
    },
    "4744": {
        "db_id": "department_store",
        "question": "Return the id of the department with the fewest staff assignments.",
        "ground_truth": "SELECT department_id FROM staff_department_assignments GROUP BY department_id ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do reference table `staff_department_assignments` instead of `staff_assignments` as the FROM source. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` in the ORDER BY clause. Do remove the explicit `ASC` direction from the ORDER BY clause instead of specifying it, as ascending order is the default. The amended query now correctly references the appropriate table and uses consistent function casing while maintaining the same logic to find the department with the fewest staff assignments."
        ],
        "rules": [
            "1) When answering about \"department with the fewest staff assignments\": use table \"staff_department_assignments\" as the FROM source instead of \"staff_assignments\". 2) When counting staff assignments: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" in the ORDER BY clause. 3) When ordering by count to find the fewest: do not specify explicit \"ASC\" direction as ascending order is the default."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department_id FROM staff_assignments GROUP BY department_id ORDER BY COUNT(*) ASC LIMIT 1;",
            "SELECT department_id FROM staff_department_assignments GROUP BY department_id ORDER BY count(*) LIMIT 1"
        ],
        "rule_sql": [
            "SELECT department_id FROM staff_department_assignments GROUP BY department_id ORDER BY count(*) LIMIT 1"
        ]
    },
    "4662": {
        "db_id": "college_3",
        "question": "What are the course names, ordered by credits?",
        "ground_truth": "SELECT CName FROM COURSE ORDER BY Credits",
        "amends": [
            "Do select `CName` instead of `course_name` and do order by `Credits` instead of `course_name DESC` instead of the original column selection and ordering approach."
        ],
        "rules": [
            "1) When the question asks for \"course names\": select the exact column \"CName\" from table Course. 2) When the question asks to order by \"credits\": sort the results using the exact column \"Credits\" from table Course. 3) When producing output: maintain the exact column order with \"CName\" as the output column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_name FROM courses ORDER BY course_name DESC;",
            "SELECT CName FROM Course ORDER BY Credits;"
        ],
        "rule_sql": [
            "SELECT CName FROM Course ORDER BY Credits;"
        ]
    },
    "3503": {
        "db_id": "hr_1",
        "question": "display the employee number and name( first name and last name ) for all employees who work in a department with any employee whose name contains a \u2019T\u2019.",
        "ground_truth": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' )",
        "amends": [
            "Do use `employee_id` instead of `employee_number` in the SELECT list. Do remove the `last_name LIKE '%T%'` condition from the subquery instead of keeping it, focusing only on filtering by `first_name LIKE '%T%'` to match the correct department selection logic. The amended query now correctly identifies employees based on departments containing employees with 'T' in their first name only, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting employee identification information: use \"employee_id\" instead of \"employee_number\" as the output column. 2) When filtering for departments with employees whose name contains 'T': only check for 'T' in the first_name column using the pattern '%T%', not in the last_name column. 3) When identifying departments with matching employees: use a subquery that selects department_id from employees where first_name contains 'T' to find the relevant departments."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT employee_number, first_name, last_name \nFROM employees \nWHERE department_id IN (\n    SELECT department_id \n    FROM employees \n    WHERE first_name LIKE '%T%' OR last_name LIKE '%T%'\n)",
            "SELECT employee_id, first_name, last_name \nFROM employees \nWHERE department_id IN (\n    SELECT DISTINCT department_id \n    FROM employees \n    WHERE first_name LIKE '%T%'\n)"
        ],
        "rule_sql": [
            "SELECT employee_id, first_name, last_name FROM employees WHERE department_id IN (SELECT department_id FROM employees WHERE first_name LIKE '%T%')"
        ]
    },
    "1408": {
        "db_id": "college_2",
        "question": "Find the name of department has the highest amount of students?",
        "ground_truth": "SELECT dept_name FROM student GROUP BY dept_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `dept_name` instead of `department_name` and use `count(*)` instead of `student_count`. Do use `GROUP BY dept_name` instead of omitting it. Do change the sort order to `DESC` instead of `ASC` and move from the departments table to the student table instead of keeping the original source. The amended query now correctly identifies departments by counting students per department and returns the department with the highest student count instead of the lowest."
        ],
        "rules": [
            "1) When answering about \"department with highest amount of students\": make sure the output order: dept_name. 2) When the question mentions \"department name\": \"department name\" actually means \"dept_name in schema\". 3) When the question asks for \"count of students\": compute the number of rows using count(*) from the student table. 4) When the question asks for \"highest amount of students\": rank rows by count(*) in descending order and keep the first 1 row. 5) When the question says \"per department\"/\"by department\": organize results by dept_name and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department_name FROM departments ORDER BY student_count ASC LIMIT 1;",
            "SELECT dept_name FROM student GROUP BY dept_name ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT dept_name FROM student GROUP BY dept_name ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "3809": {
        "db_id": "e_learning",
        "question": "Which course authors teach two or more courses? Give me their addresses and author IDs.",
        "ground_truth": "SELECT T1.address_line_1 ,  T2.author_id FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id GROUP BY T2.author_id HAVING Count(*)  >=  2",
        "amends": [
            "Do select `T1.address_line_1` and `T2.author_id` instead of `author_id` and `address`. Do join `Course_Authors_and_Tutors AS T1` with `Courses AS T2` on `T1.author_id = T2.author_id` instead of querying only `course_authors`. Do group by `T2.author_id` instead of `author_id`. Do use `Count(*) >= 2` instead of `COUNT(course_id) >= 2`. The amended query now correctly retrieves addresses from the authors table while counting courses from the courses table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about course authors teaching multiple courses: make sure the output order: author_id first, then address_line_1. 2) When the question mentions \"address\": \"address\" actually means \"address_line_1 in Course_Authors_and_Tutors table\". 3) When combining Course_Authors_and_Tutors (T1) and Courses (T2) for shared authors: link rows where T1.author_id = T2.author_id exactly as shown; keep only matching pairs (inner match). 4) When the question asks for authors teaching two or more courses: group by T2.author_id and keep groups where Count(*) >= 2. 5) When counting courses per author: use Count(*) instead of counting a specific column to include all courses taught by each author."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author_id, address FROM course_authors GROUP BY author_id HAVING COUNT(course_id) >= 2;",
            "SELECT T1.address_line_1, T2.author_id\nFROM Course_Authors_and_Tutors AS T1\nJOIN Courses AS T2 ON T1.author_id = T2.author_id\nGROUP BY T2.author_id\nHAVING COUNT(*) >= 2;"
        ],
        "rule_sql": [
            "SELECT ca.author_id, ca.address_line_1\nFROM Course_Authors_and_Tutors ca\nJOIN Courses c ON ca.author_id = c.author_id\nGROUP BY ca.author_id\nHAVING COUNT(*) >= 2\nORDER BY ca.author_id, ca.address_line_1"
        ]
    },
    "3189": {
        "db_id": "college_1",
        "question": "How many different locations does the school with code BUS has?",
        "ground_truth": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'",
        "amends": [
            "Do select `count(DISTINCT dept_address)` instead of `COUNT(*)`. Do query from `department` table instead of `schools` table. Do filter on `school_code = 'BUS'` instead of `code = 'BUS'`. Do remove the asterisk wildcard and instead count distinct department addresses to avoid duplicate counts when multiple departments share the same address within the same school code. The amended query now correctly counts unique department addresses for the BUS school code instead of counting all rows from the wrong table."
        ],
        "rules": [
            "1) When the question asks about \"different locations\" for a school: count distinct values of \"dept_address\" instead of counting all rows. 2) When querying about school information: use the \"department\" table instead of the \"schools\" table. 3) When filtering by school code: use the exact column name \"school_code\" with the literal value 'BUS' (case-sensitive). 4) When counting distinct locations: ensure you count unique department addresses to avoid duplicate counts when multiple departments share the same address within the same school code."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM schools WHERE code = 'BUS';",
            "SELECT COUNT(DISTINCT DEPT_ADDRESS) FROM DEPARTMENT WHERE SCHOOL_CODE = 'BUS'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT DEPT_ADDRESS) FROM DEPARTMENT WHERE SCHOOL_CODE = 'BUS';"
        ]
    },
    "1547": {
        "db_id": "customers_and_invoices",
        "question": "Show the number of accounts.",
        "ground_truth": "SELECT count(*) FROM Accounts",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS number_of_accounts FROM Accounts;"
        ]
    },
    "3684": {
        "db_id": "baseball_1",
        "question": "List all the salary values players received in 2010 and 2001.",
        "ground_truth": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001",
        "amends": [
            "Do use `UNION` to combine results from two separate queries instead of using `OR` in a single query. Do reference the table as `salary` instead of `salaries`. Do write two separate `SELECT` statements with explicit `WHERE YEAR = 2010` and `WHERE YEAR = 2001` conditions instead of combining them with `OR`. Do maintain the same column selection `salary` in both unioned queries instead of changing the output structure. The amended query now correctly returns distinct salary values for each specified year through union operation instead of potentially returning duplicate rows from a single table scan."
        ],
        "rules": [
            "1) When the question asks for salary values from multiple specific years (2010 and 2001): use UNION to combine results from separate queries for each year instead of OR conditions in a single query. 2) When referencing the salary table: use the exact table name \"salary\" (not \"salaries\") as specified in the schema. 3) When selecting salary values for year 2010: write a separate query with explicit condition WHERE YEAR = 2010. 4) When selecting salary values for year 2001: write a separate query with explicit condition WHERE YEAR = 2001. 5) When combining results from multiple years: maintain the same output column structure (salary) in both unioned queries to ensure compatible union operation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT salary FROM salaries WHERE year = 2010 OR year = 2001;",
            "SELECT salary FROM salary WHERE year = 2010\nUNION\nSELECT salary FROM salary WHERE year = 2001"
        ],
        "rule_sql": [
            "SELECT salary FROM salary WHERE year = 2010\nUNION\nSELECT salary FROM salary WHERE year = 2001"
        ]
    },
    "4971": {
        "db_id": "soccer_2",
        "question": "What are the names of players who train between 500 and 1500 hours?",
        "ground_truth": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500",
        "amends": [
            "Do select `pName` instead of `name` and use table `Player` instead of `players`. Do use `BETWEEN 500 AND 1500` instead of `< 500 OR > 1500` to correctly filter for values within the range rather than excluding them. Do remove the incorrect column reference `training_hours` and instead use `HS` which appears to be the correct column name for the hours specification. The amended query now correctly selects players whose hours fall within the specified range rather than those outside it, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for player names: use column \"pName\" from table \"Player\" instead of \"name\" from \"players\". 2) When filtering for training hours between 500 and 1500: use column \"HS\" with the inclusive range condition BETWEEN 500 AND 1500 instead of excluding the range with OR conditions. 3) When the question specifies a range \"between X and Y\": include both boundary values in the range (inclusive)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM players WHERE training_hours < 500 OR training_hours > 1500;",
            "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500"
        ],
        "rule_sql": [
            "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500"
        ]
    },
    "2373": {
        "db_id": "csu_1",
        "question": "How many faculty, in total, are there in the year 2002?",
        "ground_truth": "SELECT sum(faculty) FROM faculty WHERE YEAR  =  2002",
        "amends": [
            "Do use `sum(faculty)` instead of `COUNT(*)` to calculate the total faculty count rather than counting rows. Do keep the `WHERE YEAR = 2002` filter unchanged as it correctly restricts to the year 2002. The amended query now correctly sums faculty values instead of counting rows, matching the intended behavior of calculating total faculty count for the specified year."
        ],
        "rules": [
            "1) When calculating total faculty count: use sum(\"faculty\") instead of counting rows to get the actual sum of faculty values. 2) When filtering for year 2002: keep the condition YEAR = 2002 to restrict results to the specified year."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM faculty WHERE year = 2002;",
            "SELECT SUM(Faculty) FROM faculty WHERE Year = 2002"
        ],
        "rule_sql": [
            "SELECT SUM(\"Faculty\") AS TotalFaculty FROM faculty WHERE \"Year\" = 2002"
        ]
    },
    "2927": {
        "db_id": "sakila_1",
        "question": "Return the most common first name among all actors.",
        "ground_truth": "SELECT first_name FROM actor GROUP BY first_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference table `actor` instead of `actors` in the FROM clause. Do move the aggregate function `count(*)` to the ORDER BY clause instead of including it in the SELECT list. Do remove the alias `count` from the SELECT list instead of keeping it. Do maintain the GROUP BY on `first_name` and the DESC ordering with LIMIT 1. The amended query now correctly identifies the most common first name by counting occurrences within the ORDER BY rather than selecting the count value."
        ],
        "rules": [
            "1) When answering about \"most common first name among all actors\": use table \"actor\" instead of \"actors\" in the FROM clause. 2) When counting occurrences of first names: use count(*) in the ORDER BY clause instead of including it in the SELECT list. 3) When selecting output columns: include only \"first_name\" in the SELECT list and remove any alias for the count. 4) When grouping by first names: maintain GROUP BY on \"first_name\" to organize results by each unique first name. 5) When finding the most common value: order rows by count in descending direction and keep only the first row using LIMIT 1."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, COUNT(*) as count FROM actors GROUP BY first_name ORDER BY count DESC LIMIT 1;",
            "SELECT first_name FROM actor GROUP BY first_name ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT first_name FROM actor GROUP BY first_name ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "1770": {
        "db_id": "gymnast",
        "question": "Show the hometowns shared by people older than 23 and younger than 20.",
        "ground_truth": "SELECT Hometown FROM people WHERE Age  >  23 INTERSECT SELECT Hometown FROM people WHERE Age  <  20",
        "amends": [
            "Do use `INTERSECT` to find common hometowns instead of using a contradictory `WHERE` clause with `age > 23 AND age < 20`. Do add a second `SELECT` statement with `Age < 20` condition instead of having both conditions in a single contradictory filter. Do change the column reference to `Hometown` with proper capitalization instead of `hometown` lowercase. Do remove the impossible `WHERE` condition that could never return results and instead use set intersection to find people who exist in both age groups. The amended query now correctly identifies hometowns that have both people over 23 and people under 20, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for shared hometowns between two different age groups: use set intersection to find common values instead of contradictory WHERE conditions. 2) When the question mentions \"hometowns\": use the exact column token \"Hometown\" with proper capitalization instead of lowercase \"hometown\". 3) When finding people older than 23: create one SELECT statement with condition \"Age > 23\". 4) When finding people younger than 20: create a separate SELECT statement with condition \"Age < 20\". 5) When combining results from both age groups: use INTERSECT operation to find hometowns that appear in both result sets."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT hometown FROM people WHERE age > 23 AND age < 20;",
            "SELECT Hometown FROM people WHERE Age > 23\nINTERSECT\nSELECT Hometown FROM people WHERE Age < 20"
        ],
        "rule_sql": [
            "SELECT Hometown FROM people WHERE Age > 23\nINTERSECT\nSELECT Hometown FROM people WHERE Age < 20"
        ]
    },
    "3935": {
        "db_id": "hospital_1",
        "question": "How many rooms are located for each block code?",
        "ground_truth": "SELECT count(*) ,  T1.blockcode FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockcode",
        "amends": [
            "Do specify `T1.blockcode` in the SELECT list instead of `block_code`. Do join `BLOCK AS T1` and `room AS T2` with conditions `ON T1.blockfloor = T2.blockfloor AND T1.blockcode = T2.blockcode` instead of querying only the `rooms` table. Do group by `T1.blockcode` instead of `room_number`. The amended query now correctly counts rooms per block by joining the block and room tables on both blockfloor and blockcode, matching the intended behavior.",
            "Do use `count(*)` without an alias instead of `COUNT(*) AS RoomCount` in the SELECT list. Do place `T1.blockcode` after the aggregate instead of before it in the SELECT clause. Do use lowercase `blockcode` instead of `BlockCode` for consistency. Do maintain the same FROM clause with `JOIN room AS T2` on the same join predicates `T1.blockfloor = T2.blockfloor AND T1.blockcode = T2.blockcode` without changes. Do keep the same GROUP BY clause with `T1.blockcode` unchanged. The amended query now matches RIGHT_SQL's behavior by removing the unnecessary column alias and adjusting column ordering while preserving the same logical result.",
            "Do place `T1.blockcode` after `count(*)` in the SELECT list instead of before it. Do add a space after the comma in the SELECT list instead of omitting it. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"rooms per block code\": make sure the output order: T1.blockcode, then the count of rooms. 2) When the question mentions \"block code\": \"block code\" actually means \"T1.blockcode in schema\". 3) When combining T1 (BLOCK) and T2 (room) for shared entities: link rows where T1.blockfloor = T2.blockfloor AND T1.blockcode = T2.blockcode exactly as shown; keep only matching pairs (inner match). 4) When the question asks for \"count of rooms per block code\": compute the number of rows using the canonical key from T2 (room table) grouped by T1.blockcode. 5) When grouping by block code: organize results by T1.blockcode and compute room count per group.",
            "1) When counting rooms per block code: use count(*) without an alias instead of COUNT(*) AS RoomCount. 2) When ordering output columns: place T1.blockcode after the aggregate count instead of before it. 3) When referring to identifiers: use lowercase blockcode consistently instead of BlockCode. 4) When combining Block and Room tables: link rows where T1.blockfloor = T2.blockfloor AND T1.blockcode = T2.blockcode and keep only matching pairs (inner match). 5) When grouping results: organize by T1.blockcode to compute room counts per block code.",
            "1) When answering about \"How many rooms are located for each block code\": make sure the output order: count(*) first, then T1.blockcode. 2) When formatting the SELECT list: include a space after the comma between columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT block_code, COUNT(*) FROM rooms GROUP BY room_number;",
            "SELECT T1.BlockCode, COUNT(*) AS RoomCount\nFROM Block AS T1\nJOIN Room AS T2 ON T1.BlockFloor = T2.BlockFloor AND T1.BlockCode = T2.BlockCode\nGROUP BY T1.BlockCode",
            "SELECT T1.blockcode, COUNT(*) \nFROM Block AS T1 \nJOIN Room AS T2 ON T1.blockfloor = T2.blockfloor AND T1.blockcode = T2.blockcode \nGROUP BY T1.blockcode",
            "SELECT count(*), T1.blockcode FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor = T2.blockfloor AND T1.blockcode = T2.blockcode GROUP BY T1.blockcode"
        ],
        "rule_sql": [
            "SELECT COUNT(*), T1.blockcode FROM Block T1 JOIN Room T2 ON T1.blockfloor = T2.blockfloor AND T1.blockcode = T2.blockcode GROUP BY T1.blockcode"
        ]
    },
    "435": {
        "db_id": "flight_1",
        "question": "what is the salary and name of the employee who has the most number of aircraft certificates?",
        "ground_truth": "SELECT T1.name ,  T1.salary FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `JOIN Certificate AS T2 ON T1.eid = T2.eid` instead of omitting the table join entirely. Do change the source table from `employees` to `Employee AS T1` instead of using the original table name. Do add `GROUP BY T1.eid` instead of omitting the grouping clause. Do change the ORDER BY expression from `COUNT(certificates)` to `count(*)` instead of using the incorrect column reference. Do add table aliases `T1` and `T2` instead of using unqualified column names. The amended query now correctly joins the Employee and Certificate tables, groups by employee ID, and counts certificates per employee to find the employee with the most certificates, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"employee who has the most number of aircraft certificates\": make sure to join Employee table as T1 with Certificate table as T2 using T1.eid = T2.eid. 2) When counting certificates per employee: group by T1.eid and count all rows using count(*). 3) When finding the employee with the most certificates: order by the certificate count in descending order and take the first row. 4) When selecting output columns: include name and salary from T1. 5) When combining Employee and Certificate tables: perform an inner match where T1.eid equals T2.eid to only include employees with certificates."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, salary FROM employees ORDER BY COUNT(certificates) DESC LIMIT 1;",
            "SELECT T1.name, T1.salary\nFROM Employee AS T1\nJOIN Certificate AS T2 ON T1.eid = T2.eid\nGROUP BY T1.eid\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.name, T1.salary\nFROM employee T1\nINNER JOIN certificate T2 ON T1.eid = T2.eid\nGROUP BY T1.eid\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "219": {
        "db_id": "book_2",
        "question": "What are the distinct publishers of publications with price higher than 5000000?",
        "ground_truth": "SELECT DISTINCT Publisher FROM publication WHERE Price  >  5000000",
        "amends": [
            "Do reference table `publication` instead of `publications` and use column `Publisher` instead of `publisher` while maintaining the same DISTINCT selection. Do use column `Price` instead of `price` while keeping the same filter condition `> 5000000` in the WHERE clause. The amended query now correctly references the proper table and column names while preserving the same logical behavior of selecting distinct publishers with prices exceeding 5,000,000."
        ],
        "rules": [
            "1) When the question asks about \"publications\": use the exact table name \"publication\" instead of \"publications\". 2) When the question mentions \"publishers\": use the exact column name \"Publisher\" from table \"publication\". 3) When the question asks for \"distinct publishers\": select unique values from the \"Publisher\" column. 4) When the question specifies \"price higher than 5000000\": filter rows where the \"Price\" column value is greater than 5000000."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT publisher FROM publications WHERE price > 5000000;",
            "SELECT DISTINCT Publisher FROM publication WHERE Price > 5000000"
        ],
        "rule_sql": [
            "SELECT DISTINCT Publisher FROM publication WHERE Price > 5000000;"
        ]
    },
    "5021": {
        "db_id": "soccer_2",
        "question": "What are the names of all tryout participants who are from the largest college?",
        "ground_truth": "SELECT T2.pName FROM  tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID WHERE T1.cName  =  (SELECT cName FROM college ORDER BY enr DESC LIMIT 1)",
        "amends": [
            "Do reference table `tryout` instead of `participants` and `college` instead of `colleges` in the FROM clause. Do use `JOIN player` instead of `JOIN colleges` with the join condition `ON T1.pID = T2.pID` instead of `ON p.college_id = c.id`. Do select `T2.pName` instead of `p.name` in the SELECT list. Do change the WHERE filter to `T1.cName = (SELECT cName FROM college ORDER BY enr DESC LIMIT 1)` instead of `c.size = (SELECT MAX(size) FROM colleges)`, using a subquery with ORDER BY and LIMIT instead of MAX aggregation. The amended query now correctly retrieves player names from tryouts associated with the college having the highest enrollment."
        ],
        "rules": [
            "1) When answering about \"tryout participants\": use table \"tryout\" as T1 instead of \"participants\". 2) When joining with college information: use \"JOIN player\" as T2 instead of \"colleges\" with join condition T1.pID = T2.pID. 3) When selecting player names: select T2.pName instead of p.name. 4) When finding the largest college: use T1.cName = (SELECT cName FROM college ORDER BY enr DESC LIMIT 1) instead of size-based MAX aggregation, where \"largest\" means highest enrollment (enr). 5) When combining tryout and player tables: link rows where T1.pID = T2.pID exactly and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.name \nFROM participants p\nJOIN colleges c ON p.college_id = c.id\nWHERE c.size = (SELECT MAX(size) FROM colleges);",
            "SELECT T2.pName \nFROM Tryout T1 \nJOIN Player T2 ON T1.pID = T2.pID \nWHERE T1.cName = (SELECT cName FROM College ORDER BY enr DESC LIMIT 1)"
        ],
        "rule_sql": [
            "SELECT T2.pName FROM Tryout AS T1 JOIN Player AS T2 ON T1.pID = T2.pID WHERE T1.cName = (SELECT cName FROM College ORDER BY enr DESC LIMIT 1)"
        ]
    },
    "1873": {
        "db_id": "wrestler",
        "question": "Which reign is the most common among wrestlers?",
        "ground_truth": "SELECT Reign FROM wrestler GROUP BY Reign ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do use the correct table name `wrestler` instead of the incorrect `wrestlers`. Do reference the column `Reign` with proper capitalization instead of lowercase `reign`. Do place the aggregate function `COUNT(*)` directly in the ORDER BY clause instead of selecting it as a separate column with an alias. Do remove the explicit column selection of the count from the SELECT list instead of including it. The amended query now correctly identifies the most frequent reign value by counting occurrences directly in the ordering clause without unnecessary column projection."
        ],
        "rules": [
            "1) When answering about \"most common reign among wrestlers\": use the table name \"wrestler\" exactly as specified in the schema. 2) When the question mentions \"reign\": \"reign\" actually means \"Reign\" in schema with exact capitalization. 3) When counting occurrences of reign values: count all rows using COUNT(*) directly in the ordering clause without selecting it as a separate column. 4) When ordering by frequency to find the most common: order by the count in descending direction and keep only the top result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT reign, COUNT(*) as count FROM wrestlers GROUP BY reign ORDER BY count DESC LIMIT 1;",
            "SELECT Reign FROM wrestler GROUP BY Reign ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Reign FROM wrestler GROUP BY Reign ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "4220": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "Show the location name for document \"Robin CV\".",
        "ground_truth": "SELECT T3.location_name FROM All_documents AS T1 JOIN Document_locations AS T2 ON T1.document_id  =  T2.document_id JOIN Ref_locations AS T3 ON T2.location_code  =  T3.location_code WHERE T1.document_name  =  \"Robin CV\"",
        "amends": [
            "Do select `T3.location_name` instead of `document_name`. Do use `FROM All_documents AS T1` with two joins instead of `FROM locations`. Do add `JOIN Document_locations AS T2 ON T1.document_id = T2.document_id` and `JOIN Ref_locations AS T3 ON T2.location_code = T3.location_code` instead of a single table. Do filter on `T1.document_name = \"Robin CV\"` instead of `location_name = 'Robin CV'`. The amended query now correctly joins three tables to find the location name associated with a specific document name, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"location name for document 'Robin CV'\": select \"T3\".\"location_name\" as the output column. 2) When querying about documents: start from \"All_documents\" as T1 and filter on \"T1\".\"document_name\" = \"Robin CV\". 3) When finding location information for documents: join \"Document_locations\" as T2 where \"T1\".\"document_id\" = \"T2\".\"document_id\". 4) When translating location codes to names: join \"Ref_locations\" as T3 where \"T2\".\"location_code\" = \"T3\".\"location_code\" to get the location name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_name FROM locations WHERE location_name = 'Robin CV'",
            "SELECT T3.Location_Name\nFROM All_Documents AS T1\nJOIN Document_Locations AS T2 ON T1.Document_ID = T2.Document_ID\nJOIN Ref_Locations AS T3 ON T2.Location_Code = T3.Location_Code\nWHERE T1.Document_Name = 'Robin CV'"
        ],
        "rule_sql": [
            "SELECT T3.Location_Name \nFROM All_Documents AS T1\nJOIN Document_Locations AS T2 ON T1.Document_ID = T2.Document_ID\nJOIN Ref_Locations AS T3 ON T2.Location_Code = T3.Location_Code\nWHERE T1.Document_Name = 'Robin CV'"
        ]
    },
    "3035": {
        "db_id": "loan_1",
        "question": "What are the total account balances for each customer from Utah or Texas?",
        "ground_truth": "SELECT sum(acc_bal) FROM customer WHERE state  =  'Utah' OR state  =  'Texas'",
        "amends": [
            "Do select `sum(acc_bal)` instead of `customer_id, SUM(balance) as total_balance`. Do use `FROM customer` instead of `FROM accounts`. Do remove `GROUP BY customer_id` instead of keeping it. Do use `acc_bal` column instead of `balance` column. The amended query now correctly aggregates account balances from the customer table for Utah and Texas states."
        ],
        "rules": [
            "1) When answering about \"total account balances for each customer from Utah or Texas\": make sure the output order: sum(acc_bal) only. 2) When the question mentions \"customer\": use table \"customer\" instead of \"accounts\". 3) When the question mentions \"balance\": use column \"acc_bal\" instead of \"balance\". 4) When the question asks for \"total account balances\": compute the sum of \"acc_bal\" values. 5) When filtering for customers from Utah or Texas: use state = 'Utah' OR state = 'Texas' with exact literals 'Utah' and 'Texas'. 6) When computing aggregates without grouping: do not use GROUP BY customer_id."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT customer_id, SUM(balance) as total_balance \nFROM accounts \nWHERE state = 'Utah' OR state = 'Texas' \nGROUP BY customer_id",
            "SELECT SUM(acc_bal) FROM customer WHERE state = 'Utah' OR state = 'Texas';"
        ],
        "rule_sql": [
            "SELECT SUM(acc_bal) FROM customer WHERE state = 'Utah' OR state = 'Texas'"
        ]
    },
    "3324": {
        "db_id": "college_1",
        "question": "What are the different first names and highest degree attained for professors teaching in the Computer Information Systems department?",
        "ground_truth": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'",
        "amends": [
            "Do select `emp_fname` and `prof_high_degree` instead of `first_name` and `degree`. Do join four tables (`CLASS`, `employee`, `professor`, `department`) with `INNER JOIN` conditions instead of querying only a single `professors` table. Do filter on `dept_name = 'Computer Info. Systems'` instead of `department = 'Computer Information Systems'`. Do add `DISTINCT` to remove duplicates instead of omitting it. Do remove `ORDER BY` and `LIMIT` clauses instead of keeping them, as the distinct selection no longer requires ranking. The amended query now correctly joins across the normalized schema to find professors in the specified department and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"first names\" and \"highest degree attained\": use the exact column tokens \"emp_fname\" and \"prof_high_degree\" instead of \"first_name\" and \"degree\". 2) When querying about professors in a specific department: join the four tables CLASS, employee, professor, and department using INNER JOIN conditions instead of querying only a single professors table. 3) When filtering for the Computer Information Systems department: use the exact literal filter \"dept_name = 'Computer Info. Systems'\" instead of \"department = 'Computer Information Systems'\". 4) When the question asks for \"different\" first names and highest degrees: add DISTINCT to remove duplicate combinations of emp_fname and prof_high_degree. 5) When the question asks for all different combinations rather than a single highest: remove ORDER BY and LIMIT clauses as distinct selection no longer requires ranking."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, degree FROM professors WHERE department = 'Computer Information Systems' ORDER BY degree DESC LIMIT 1;",
            "SELECT DISTINCT e.EMP_FNAME, p.PROF_HIGH_DEGREE\nFROM CLASS c\nINNER JOIN EMPLOYEE e ON c.PROF_NUM = e.EMP_NUM\nINNER JOIN PROFESSOR p ON e.EMP_NUM = p.EMP_NUM\nINNER JOIN DEPARTMENT d ON p.DEPT_CODE = d.DEPT_CODE\nWHERE d.DEPT_NAME = 'Computer Info. Systems'"
        ],
        "rule_sql": [
            "SELECT DISTINCT e.emp_fname, p.prof_high_degree\nFROM CLASS c\nINNER JOIN EMPLOYEE e ON c.PROF_NUM = e.EMP_NUM\nINNER JOIN PROFESSOR p ON e.EMP_NUM = p.EMP_NUM\nINNER JOIN DEPARTMENT d ON p.DEPT_CODE = d.DEPT_CODE\nWHERE d.dept_name = 'Computer Info. Systems'"
        ]
    },
    "6271": {
        "db_id": "city_record",
        "question": "What is the match id of the competition called \"1994 FIFA World Cup qualification\"?",
        "ground_truth": "SELECT match_id FROM MATCH WHERE competition = \"1994 FIFA World Cup qualification\"",
        "amends": [
            "Do query the `MATCH` table instead of the `competitions` table. Do use the column `competition` for filtering instead of `competition_name`. Do use double quotes around the string literal instead of single quotes. The amended query now correctly retrieves match_id records from the appropriate table with the proper filter condition."
        ],
        "rules": [
            "1) When answering about match id of a competition: query the \"MATCH\" table instead of the \"competitions\" table. 2) When filtering by competition name: use the column \"competition\" for filtering instead of \"competition_name\". 3) When using string literals for competition names: use double quotes around the literal instead of single quotes, exactly as \"1994 FIFA World Cup qualification\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT match_id FROM competitions WHERE competition_name = '1994 FIFA World Cup qualification';",
            "SELECT Match_ID FROM \"match\" WHERE Competition = \"1994 FIFA World Cup qualification\";"
        ],
        "rule_sql": [
            "SELECT Match_ID FROM match WHERE Competition = \"1994 FIFA World Cup qualification\";"
        ]
    },
    "759": {
        "db_id": "race_track",
        "question": "What are distinct locations where tracks are located?",
        "ground_truth": "SELECT DISTINCT LOCATION FROM track",
        "amends": [
            "Do reference the `track` table instead of the `tracks` table in the FROM clause. Do use uppercase `LOCATION` instead of lowercase `location` in the SELECT list while maintaining the DISTINCT modifier. The amended query now correctly references the intended table and uses consistent column naming while preserving the distinct location retrieval behavior."
        ],
        "rules": [
            "1) When the question asks for distinct locations from the track table: use SELECT DISTINCT \"LOCATION\" FROM \"track\" to retrieve unique location values. 2) When referring to the table containing track information: use the exact table name \"track\" (not \"tracks\") as specified in the schema. 3) When selecting the location column: use the exact column name \"LOCATION\" in uppercase with double quotes as shown in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT location FROM tracks;",
            "SELECT DISTINCT LOCATION FROM track;"
        ],
        "rule_sql": [
            "SELECT DISTINCT \"LOCATION\" FROM \"track\""
        ]
    },
    "2158": {
        "db_id": "formula_1",
        "question": "What are the names of all the races that occurred in the year 2017?",
        "ground_truth": "SELECT name FROM races WHERE YEAR = 2017",
        "amends": [
            "Do use column `name` in the SELECT list instead of `race_name`. The amended query now correctly retrieves the race names from the races table for the year 2017, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for race names: use the exact column token \"name\" from the races table instead of \"race_name\". 2) When filtering for races in the year 2017: use the exact literal value 2017 for the year comparison."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT race_name FROM races WHERE year = 2017;",
            "SELECT name FROM races WHERE year = 2017;"
        ],
        "rule_sql": [
            "SELECT name FROM races WHERE year = 2017;"
        ]
    },
    "2231": {
        "db_id": "formula_1",
        "question": "Find the id and surname of the driver who participated the most number of races?",
        "ground_truth": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN results AS T2 ON T1.driverid = T2.driverid JOIN races AS T3 ON T2.raceid = T3.raceid GROUP BY T1.driverid ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `results` and `races` tables with proper joins instead of querying only the `drivers` table. Do use `JOIN results AS T2 ON T1.driverid = T2.driverid` and `JOIN races AS T3 ON T2.raceid = T3.raceid` instead of missing these essential table relationships. Do include `GROUP BY T1.driverid` instead of omitting the grouping clause needed for the aggregate function. Do use `count(*)` instead of `COUNT(race_id)` to count all race results rather than a specific column. Do reference `T1.driverid` and `T1.surname` with proper table aliases instead of using unqualified `id` and `surname`. The amended query now correctly counts race participations per driver and returns the driver with the most race entries, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"driver who participated the most number of races\": make sure the output order: T1.driverid, T1.surname 2) When counting race participations per driver: compute the number of race entries using count(*) grouped by T1.driverid 3) When combining drivers, results, and races tables: link rows where T1.driverid = T2.driverid and T2.raceid = T3.raceid, keeping only matching pairs (inner match) 4) When finding the driver with the most participations: rank drivers by count(*) in descending order and keep the first 1 row 5) When referring to driver identifiers: use T1.driverid instead of unqualified id 6) When referring to driver surnames: use T1.surname instead of unqualified surname"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, surname FROM drivers ORDER BY COUNT(race_id) DESC LIMIT 1;",
            "SELECT T1.driverId, T1.surname\nFROM drivers AS T1\nJOIN results AS T2 ON T1.driverId = T2.driverId\nJOIN races AS T3 ON T2.raceId = T3.raceId\nGROUP BY T1.driverId, T1.surname\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.driverId, T1.surname\nFROM drivers T1\nJOIN results T2 ON T1.driverId = T2.driverId\nJOIN races T3 ON T2.raceId = T3.raceId\nGROUP BY T1.driverId, T1.surname\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "890": {
        "db_id": "chinook_1",
        "question": "Find the titles of albums that contain tracks of both the Reggae and Rock genres.",
        "ground_truth": "SELECT T1.Title FROM Album AS T1 JOIN Track AS T2 ON T1.AlbumId  =  T2.AlbumId JOIN Genre AS T3 ON T2.GenreID  =  T3.GenreID WHERE T3.Name  =  'Reggae' INTERSECT SELECT T1.Title FROM Album AS T1 JOIN Track AS T2 ON T1.AlbumId  =  T2.AlbumId JOIN Genre AS T3 ON T2.GenreID  =  T3.GenreID WHERE T3.Name  =  'Rock'",
        "amends": [
            "Do use `INTERSECT` to find albums containing both genres instead of `OR` which finds albums with either genre. Do remove `DISTINCT` since `INTERSECT` inherently returns unique results instead of keeping it. Do change the table aliases from `a`, `t`, `g` to `T1`, `T2`, `T3` for consistency across both query parts. Do split the single query into two separate `SELECT` statements joined by `INTERSECT` instead of using a single query with `OR` condition. Do maintain the same join structure (`Album JOIN Track JOIN Genre`) and filter conditions in both query parts. The amended query now correctly identifies albums that contain both Reggae and Rock tracks instead of albums that contain either genre."
        ],
        "rules": [
            "1) When the question asks for albums containing tracks of both Reggae and Rock genres: use INTERSECT to combine results from two separate queries instead of OR which would find albums with either genre. 2) When using INTERSECT to combine results: remove DISTINCT since INTERSECT inherently returns unique results. 3) When joining tables for this schema: use aliases T1 for albums, T2 for tracks, and T3 for genres consistently across both query parts. 4) When filtering by genre: use exact literal values 'Reggae' and 'Rock' with correct case and spelling. 5) When combining tables: maintain the join structure where T1.AlbumId = T2.AlbumId and T2.GenreId = T3.GenreId in both query parts. 6) When the question asks for album titles: output the column T1.Title as the final result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT a.Title \nFROM albums a\nJOIN tracks t ON a.AlbumId = t.AlbumId\nJOIN genres g ON t.GenreId = g.GenreId\nWHERE g.Name = 'Reggae' OR g.Name = 'Rock';",
            "SELECT T1.Title\nFROM Album T1\nJOIN Track T2 ON T1.AlbumId = T2.AlbumId\nJOIN Genre T3 ON T2.GenreId = T3.GenreId\nWHERE T3.Name = 'Reggae'\nINTERSECT\nSELECT T1.Title\nFROM Album T1\nJOIN Track T2 ON T1.AlbumId = T2.AlbumId\nJOIN Genre T3 ON T2.GenreId = T3.GenreId\nWHERE T3.Name = 'Rock'"
        ],
        "rule_sql": [
            "SELECT T1.Title\nFROM Album T1\nJOIN Track T2 ON T1.AlbumId = T2.AlbumId\nJOIN Genre T3 ON T2.GenreId = T3.GenreId\nWHERE T3.Name = 'Reggae'\nINTERSECT\nSELECT T1.Title\nFROM Album T1\nJOIN Track T2 ON T1.AlbumId = T2.AlbumId\nJOIN Genre T3 ON T2.GenreId = T3.GenreId\nWHERE T3.Name = 'Rock'"
        ]
    },
    "3494": {
        "db_id": "hr_1",
        "question": "Give the first name and job id for all employees in the Finance department.",
        "ground_truth": "SELECT T1.first_name ,  T1.job_id FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T2.department_name  =  'Finance'",
        "amends": [
            "Do reference columns with table aliases `T1.first_name` and `T1.job_id` instead of using unqualified column names. Do add a `JOIN` to the `departments` table `AS T2` instead of querying only the `employees` table. Do use the join condition `T1.department_id = T2.department_id` instead of filtering directly on a non-existent `department` column. Do filter on `T2.department_name = 'Finance'` instead of the incorrect `department = 'Finance'` predicate. The amended query now correctly joins the tables and filters by department name rather than attempting to filter on a non-existent column, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"employees in the Finance department\": make sure the output order: first_name, job_id. 2) When the question mentions \"Finance department\": \"Finance\" actually means \"T2.department_name = 'Finance'\" in schema. 3) When combining T1 (employees) and T2 (departments) for shared entities: link rows where T1.department_id = T2.department_id; keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not use unqualified column names; always reference columns with table aliases T1.first_name and T1.job_id."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, job_id FROM employees WHERE department = 'Finance';",
            "SELECT T1.first_name, T1.job_id FROM employees AS T1 JOIN departments AS T2 ON T1.department_id = T2.department_id WHERE T2.department_name = 'Finance'"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.job_id FROM employees T1 INNER JOIN departments T2 ON T1.department_id = T2.department_id WHERE T2.department_name = 'Finance'"
        ]
    },
    "4434": {
        "db_id": "network_2",
        "question": "list the name, job title of all people ordered by their names.",
        "ground_truth": "SELECT name ,  job FROM Person ORDER BY name",
        "amends": [
            "Do add `job` to the SELECT list instead of omitting it and change the table reference from `people` to `Person` instead of keeping the original table name. Do maintain the `ORDER BY name` clause as it appears in both queries. The amended query now correctly selects both name and job columns from the Person table while preserving the alphabetical ordering by name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"name\" and \"job title\": select both \"name\" and \"job\" columns from the \"Person\" table. 2) When ordering results by name: sort the output alphabetically using the \"name\" column. 3) When referring to the people table: use the exact table name \"Person\" instead of \"people\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM people ORDER BY name;",
            "SELECT name, job FROM Person ORDER BY name;"
        ],
        "rule_sql": [
            "SELECT name, job FROM Person ORDER BY name;"
        ]
    },
    "4733": {
        "db_id": "department_store",
        "question": "Return the distinct name of customers whose order status is Pending, in the order of customer id.",
        "ground_truth": "SELECT DISTINCT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  \"Pending\" ORDER BY T2.customer_id",
        "amends": [
            "Do add `JOIN customer_orders AS T2 ON T1.customer_id = T2.customer_id` instead of querying only the `customers` table. Do reference `T2.order_status_code = \"Pending\"` instead of `order_status = 'Pending'` to filter on the correct table and column. Do use table aliases `T1.customer_name` and `T2.customer_id` instead of unqualified column names for clarity and to avoid ambiguity. Do order by `T2.customer_id` instead of `order_id` to use the appropriate ordering column. The amended query now correctly joins the necessary tables and references the proper columns to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"distinct name of customers whose order status is Pending\": make sure to join tables customers as T1 and customer_orders as T2 using T1.customer_id = T2.customer_id to combine customer and order information. 2) When filtering for orders with status \"Pending\": use T2.order_status_code = \"Pending\" exactly as specified, not 'Pending' with single quotes. 3) When selecting customer names: use T1.customer_name from the customers table. 4) When ordering results by customer id: use T2.customer_id for ordering, not order_id. 5) When combining T1 and T2 for shared entities: link rows where T1.customer_id = T2.customer_id and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT customer_name FROM customers WHERE order_status = 'Pending' ORDER BY order_id;",
            "SELECT DISTINCT T1.customer_name\nFROM Customers AS T1\nJOIN Customer_Orders AS T2 ON T1.customer_id = T2.customer_id\nWHERE T2.order_status_code = 'Pending'\nORDER BY T2.customer_id"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.customer_name\nFROM Customers AS T1\nINNER JOIN Customer_Orders AS T2 ON T1.customer_id = T2.customer_id\nWHERE T2.order_status_code = Pending\nORDER BY T2.customer_id"
        ]
    },
    "4018": {
        "db_id": "ship_mission",
        "question": "Show codes and fates of missions, and names of ships involved.",
        "ground_truth": "SELECT T1.Code ,  T1.Fate ,  T2.Name FROM mission AS T1 JOIN ship AS T2 ON T1.Ship_ID  =  T2.Ship_ID",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference columns as `T1.Code` and `T1.Fate` instead of `mission_code` and `mission_fate`. Do reference column as `T2.Name` instead of `ship_name`. Do use table name `mission` instead of `missions`. Do use table name `ship` instead of `ships`. Do use column name `Ship_ID` instead of `ship_id`. The amended query now correctly references the proper table and column names with appropriate aliasing."
        ],
        "rules": [
            "1) When answering about \"codes and fates of missions, and names of ships involved\": make sure the output order: T1.Code, T1.Fate, T2.Name\n2) When the question mentions \"codes\": \"codes\" actually means \"T1.Code in schema\"\n3) When the question mentions \"fates\": \"fates\" actually means \"T1.Fate in schema\"\n4) When the question mentions \"names of ships\": \"names of ships\" actually means \"T2.Name in schema\"\n5) When combining T1 (mission) and T2 (ship) for shared entities: link rows where T1.Ship_ID = T2.Ship_ID; keep only matching pairs (inner match)\n6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms\n7) When handling text literals: do not change case, spacing, or punctuation\n8) When referring to table roles: do not rename or swap the aliases T1, T2 once set for this schema"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT mission_code, mission_fate, ship_name FROM missions JOIN ships ON missions.ship_id = ships.ship_id",
            "SELECT T1.Code, T1.Fate, T2.Name FROM mission T1 JOIN ship T2 ON T1.Ship_ID = T2.Ship_ID"
        ],
        "rule_sql": [
            "SELECT T1.\"Code\", T1.\"Fate\", T2.\"Name\" FROM \"mission\" T1 INNER JOIN \"ship\" T2 ON T1.\"Ship_ID\" = T2.\"Ship_ID\""
        ]
    },
    "5926": {
        "db_id": "cre_Theme_park",
        "question": "Tell me the name of the staff in charge of the attraction called \"US museum\".",
        "ground_truth": "SELECT T1.Name FROM STAFF AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID WHERE T2.Name  =  \"US museum\"",
        "amends": [
            "Do add `JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID` instead of querying only the `staff` table. Do reference `T1.Name` with table alias instead of just `name`. Do filter on `T2.Name = \"US museum\"` instead of `attraction = 'US museum'` to properly join through the relationship table. Do use table aliases `T1` and `T2` instead of no aliases. The amended query now correctly joins through the tourist attractions relationship table to find staff associated with the specific attraction name."
        ],
        "rules": [
            "1) When answering about staff in charge of an attraction: combine the staff table (as T1) and tourist_attractions table (as T2) by linking rows where T1.Tourist_Attraction_ID equals T2.Tourist_Attraction_ID, keeping only matching pairs. 2) When the question mentions \"US museum\": \"US museum\" actually means T2.Name = \"US museum\" in the schema. 3) When the question asks for the name of staff: output T1.Name with the exact table alias T1. 4) When choosing identifier delimiters: use double quotes for \"US museum\" exactly as shown in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM staff WHERE attraction = 'US museum'",
            "SELECT T1.Name \nFROM Staff AS T1\nJOIN Tourist_Attractions AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID\nWHERE T2.Name = 'US museum'"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM Staff AS T1 JOIN Tourist_Attractions AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID WHERE T2.Name = \"US museum\""
        ]
    },
    "6705": {
        "db_id": "driving_school",
        "question": "What is the total time for all lessons taught by Janessa Sawayn?",
        "ground_truth": "SELECT sum(lesson_time) FROM Lessons AS T1 JOIN Staff AS T2 ON T1.staff_id = T2.staff_id WHERE T2.first_name = \"Janessa\" AND T2.last_name = \"Sawayn\";",
        "amends": [
            "Do use `sum(lesson_time)` instead of `SUM(duration)` for the aggregate expression. Do join `Lessons AS T1` with `Staff AS T2` on `T1.staff_id = T2.staff_id` instead of querying only the lessons table. Do filter on `T2.first_name = \"Janessa\" AND T2.last_name = \"Sawayn\"` instead of `teacher_name = 'Janessa Sawayn'` to properly match staff by first and last name through the relationship table. The amended query now correctly joins the lessons and staff tables to filter by staff name attributes and sum the appropriate time column."
        ],
        "rules": [
            "1) When answering about \"total time for all lessons taught by Janessa Sawayn\": make sure the output order: sum(lesson_time). 2) When the question mentions \"Janessa Sawayn\": \"Janessa Sawayn\" actually means \"T2.first_name = 'Janessa' AND T2.last_name = 'Sawayn'\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.staff_id = T2.staff_id; keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(duration) FROM lessons WHERE teacher_name = 'Janessa Sawayn';",
            "SELECT SUM(T1.lesson_time) AS total_time\nFROM Lessons AS T1\nJOIN Staff AS T2 ON T1.staff_id = T2.staff_id\nWHERE T2.first_name = 'Janessa' AND T2.last_name = 'Sawayn'"
        ],
        "rule_sql": [
            "SELECT SUM(lesson_time) AS total_lesson_time\nFROM Lessons\nJOIN Staff ON Lessons.staff_id = Staff.staff_id\nWHERE Staff.first_name = 'Janessa' AND Staff.last_name = 'Sawayn';"
        ]
    },
    "1769": {
        "db_id": "gymnast",
        "question": "From which hometowns did no gymnasts come from?",
        "ground_truth": "SELECT DISTINCT Hometown FROM people EXCEPT SELECT DISTINCT T2.Hometown FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID",
        "amends": [
            "Do use `SELECT DISTINCT Hometown` instead of `SELECT hometown` without distinct. Do query from `people` table instead of `gymnasts` table. Do add `EXCEPT` operation instead of simple grouping. Do include a subquery with `JOIN` between `gymnast` and `people` tables on `T1.Gymnast_ID = T2.People_ID` instead of omitting this relationship logic. Do remove the `GROUP BY` and `HAVING COUNT(*) > 0` clause instead of keeping this redundant filtering, as the EXCEPT operation with proper join logic provides the correct set difference semantics. The amended query now correctly identifies hometowns from people that are not associated with any gymnasts, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"hometowns with no gymnasts\": use the exact identifier \"Hometown\" from the people table. 2) When the question mentions \"hometowns\": \"hometowns\" actually means \"Hometown in people table\". 3) When finding places with no associated entities: use EXCEPT operation to subtract hometowns of gymnasts from all hometowns. 4) When combining gymnast and people tables: link rows where T1.Gymnast_ID = T2.People_ID and keep only matching pairs (inner match). 5) When selecting distinct values: use DISTINCT to return unique Hometown values only."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT hometown FROM gymnasts GROUP BY hometown HAVING COUNT(*) > 0;",
            "SELECT DISTINCT Hometown FROM people\nEXCEPT\nSELECT DISTINCT p.Hometown \nFROM people p\nJOIN gymnast g ON p.People_ID = g.Gymnast_ID"
        ],
        "rule_sql": [
            "SELECT DISTINCT Hometown FROM people\nEXCEPT\nSELECT DISTINCT p.Hometown \nFROM gymnast g\nINNER JOIN people p ON g.Gymnast_ID = p.People_ID"
        ]
    },
    "148": {
        "db_id": "bike_1",
        "question": "What is the zip code that has the lowest average mean sea level pressure?",
        "ground_truth": "SELECT zip_code FROM weather GROUP BY zip_code ORDER BY avg(mean_sea_level_pressure_inches) LIMIT 1",
        "amends": [
            "Do select only `zip_code` instead of including `AVG(mean_sea_level_pressure)` with an alias. Do use table `weather` instead of `weather_data`. Do remove the explicit aggregation in SELECT and instead use `avg(mean_sea_level_pressure_inches)` directly in ORDER BY instead of referencing an alias. Do change the sort order to ascending (default) instead of descending. The amended query now correctly identifies zip codes by ordering them based on average pressure without unnecessary column selection."
        ],
        "rules": [
            "1) When answering about \"zip code with lowest average mean sea level pressure\": make sure the output order: zip_code only without including the average value in the output. 2) When the question mentions \"weather data\": use table \"weather\" instead of \"weather_data\". 3) When computing average pressure: use column \"mean_sea_level_pressure_inches\" for the average calculation. 4) When ordering by average pressure to find the lowest: sort in ascending order (default) without specifying DESC. 5) When selecting the zip code with the lowest average: use ORDER BY avg(mean_sea_level_pressure_inches) directly without creating an alias in the SELECT clause."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT zip_code, AVG(mean_sea_level_pressure) as avg_pressure FROM weather_data GROUP BY zip_code ORDER BY avg_pressure DESC LIMIT 1;",
            "SELECT zip_code FROM weather GROUP BY zip_code ORDER BY AVG(mean_sea_level_pressure_inches) LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT zip_code FROM weather GROUP BY zip_code ORDER BY AVG(mean_sea_level_pressure_inches) LIMIT 1;"
        ]
    },
    "4764": {
        "db_id": "department_store",
        "question": "What are the names and phone numbers for all suppliers, sorted in alphabetical order of their addressed?",
        "ground_truth": "SELECT T1.supplier_name ,  T1.supplier_phone FROM Suppliers AS T1 JOIN supplier_addresses AS T2 ON T1.supplier_id  =  T2.supplier_id JOIN addresses AS T3 ON T2.address_id  =  T3.address_id ORDER BY T3.address_details",
        "amends": [
            "Do select `T1.supplier_name` and `T1.supplier_phone` instead of `name` and `phone`. Do add `FROM Suppliers AS T1 JOIN supplier_addresses AS T2 ON T1.supplier_id = T2.supplier_id JOIN addresses AS T3 ON T2.address_id = T3.address_id` instead of just `FROM suppliers`. Do order by `T3.address_details` instead of `name`. The amended query now correctly joins multiple tables to retrieve supplier information with address-based ordering."
        ],
        "rules": [
            "1) When selecting supplier information: use T1.supplier_name and T1.supplier_phone instead of generic name and phone columns. 2) When retrieving supplier data with address information: join Suppliers AS T1 with supplier_addresses AS T2 using T1.supplier_id = T2.supplier_id, then join with addresses AS T3 using T2.address_id = T3.address_id. 3) When sorting suppliers by their address: order by T3.address_details instead of supplier name to achieve alphabetical order by address."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, phone FROM suppliers ORDER BY name;",
            "SELECT T1.supplier_name, T1.supplier_phone\nFROM Suppliers AS T1\nJOIN Supplier_Addresses AS T2 ON T1.supplier_id = T2.supplier_id\nJOIN Addresses AS T3 ON T2.address_id = T3.address_id\nORDER BY T3.address_details ASC;"
        ],
        "rule_sql": [
            "SELECT T1.supplier_name, T1.supplier_phone\nFROM Suppliers AS T1\nJOIN Supplier_Addresses AS T2 ON T1.supplier_id = T2.supplier_id\nJOIN Addresses AS T3 ON T2.address_id = T3.address_id\nORDER BY T3.address_details ASC;"
        ]
    },
    "1174": {
        "db_id": "election_representative",
        "question": "How many elections are there?",
        "ground_truth": "SELECT count(*) FROM election",
        "amends": [
            "Do reference the table as `election` instead of `elections` to match the correct table name in the database schema. The amended query now correctly counts records from the intended table, ensuring the result reflects the actual data in the `election` table rather than potentially missing or incorrect data from a non-existent `elections` table."
        ],
        "rules": [
            "1) When the question asks about \"elections\": use the exact table name \"election\" instead of \"elections\" to match the database schema. 2) When counting entities from the \"election\" table: count all rows using the canonical counting method for the table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM elections;",
            "SELECT COUNT(*) FROM election;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM election;"
        ]
    },
    "5138": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "What are the product names with average product price smaller than 1000000?",
        "ground_truth": "SELECT Product_Name FROM PRODUCTS GROUP BY Product_Name HAVING avg(Product_Price)  <  1000000",
        "amends": [
            "Do use `GROUP BY Product_Name` and `HAVING avg(Product_Price) < 1000000` instead of filtering individual rows with `WHERE price < 1000000`. Do reference the correct column name `Product_Price` in the aggregate function instead of the incorrect `price` column. Do include the aggregate function `avg()` to calculate average prices per product group instead of filtering raw price values. Do maintain the correct output column `Product_Name` while changing the filtering logic to operate on grouped aggregates rather than individual records. The amended query now correctly calculates average product prices by product name and filters groups where the average price is below the threshold, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"product names with average product price smaller than 1000000\": make sure to group results by \"Product_Name\" and calculate the average of \"Product_Price\" per group. 2) When filtering for average price below 1000000: apply the condition after grouping using \"HAVING avg(Product_Price) < 1000000\" instead of filtering individual rows. 3) When referencing price information: use the exact column name \"Product_Price\" from the Services table, not \"price\". 4) When computing averages: use the aggregate function avg() on \"Product_Price\" to calculate average prices per product group. 5) When producing output: maintain the correct output column \"Product_Name\" from the Services table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT product_name FROM products WHERE price < 1000000;",
            "SELECT Product_Name\nFROM Products\nGROUP BY Product_Name\nHAVING AVG(Product_Price) < 1000000"
        ],
        "rule_sql": [
            "SELECT Product_Name\nFROM Services\nGROUP BY Product_Name\nHAVING AVG(Product_Price) < 1000000"
        ]
    },
    "2560": {
        "db_id": "county_public_safety",
        "question": "Please show the police forces and the number of counties with each police force.",
        "ground_truth": "SELECT Police_force ,  COUNT(*) FROM county_public_safety GROUP BY Police_force",
        "amends": [
            "Do reference the correct table name `county_public_safety` instead of `counties` and use the correct column name `Police_force` instead of `police_force` to match the actual schema. The amended query now correctly counts records by police force from the appropriate data source."
        ],
        "rules": [
            "1) When answering about \"police forces and number of counties\": make sure the output order: Police_force first, then count. 2) When the question mentions \"counties\": \"counties\" actually means \"records in county_public_safety table\". 3) When the question asks for \"number of counties with each police force\": compute the count of records using the Police_force column as the grouping key. 4) When choosing identifier delimiters: use exact column name \"Police_force\" without quotes as shown in the schema. 5) When handling table names: use exact table name \"county_public_safety\" without quotes as referenced in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT police_force, COUNT(*) FROM counties GROUP BY police_force;",
            "SELECT Police_force, COUNT(*) AS number_of_counties FROM county_public_safety GROUP BY Police_force;"
        ],
        "rule_sql": [
            "SELECT Police_force, COUNT(*) AS count FROM county_public_safety GROUP BY Police_force"
        ]
    },
    "3379": {
        "db_id": "sports_competition",
        "question": "what are the name of players who get more than the average points.",
        "ground_truth": "SELECT name FROM player WHERE points  >  (SELECT avg(points) FROM player)",
        "amends": [
            "Do reference table `player` instead of `players` in both the main query and subquery. Do use lowercase `avg` function instead of uppercase `AVG` for consistency. Do remove the `ORDER BY name` clause instead of including it since the RIGHT_SQL does not specify any ordering. The amended query now correctly filters for players with points above the average from the same table without unnecessary sorting."
        ],
        "rules": [
            "1) When the question asks about \"players\": use the exact table name \"player\" instead of \"players\". 2) When computing average points: use the lowercase function \"avg\" instead of uppercase \"AVG\" for consistency. 3) When filtering for players with more than average points: do not include any ordering clause unless explicitly specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM players WHERE points > (SELECT AVG(points) FROM players) ORDER BY name;",
            "SELECT name FROM player WHERE Points > (SELECT avg(Points) FROM player)"
        ],
        "rule_sql": [
            "SELECT name FROM player WHERE Points > (SELECT avg(Points) FROM player)"
        ]
    },
    "5579": {
        "db_id": "products_gen_characteristics",
        "question": "Return the unit of measure for 'Herb' products.",
        "ground_truth": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  \"Herbs\"",
        "amends": [
            "Do select `unit_of_measure` instead of `product_name`. Do query from `ref_product_categories` instead of `products`. Do filter on `product_category_code = \"Herbs\"` instead of `category = 'Herb'`. The amended query now correctly retrieves the unit of measure from the appropriate reference table using the proper category code filter."
        ],
        "rules": [
            "1) When the question asks for \"unit of measure\": select the exact column \"unit_of_measure\" from the appropriate table. 2) When the question mentions products of type 'Herb': use the exact literal \"Herbs\" (with 's') for filtering instead of 'Herb'. 3) When filtering by product category: use the column \"product_category_code\" instead of \"category\". 4) When retrieving category-related information: query from table \"ref_product_categories\" instead of \"products\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT product_name FROM products WHERE category = 'Herb';",
            "SELECT unit_of_measure FROM Ref_Product_Categories WHERE product_category_code = 'Herbs';"
        ],
        "rule_sql": [
            "SELECT unit_of_measure FROM Ref_Product_Categories WHERE product_category_code = 'Herbs';"
        ]
    },
    "1271": {
        "db_id": "apartment_rentals",
        "question": "Which apartments have bookings with both status codes \"Provisional\" and \"Confirmed\"? Give me the apartment numbers.",
        "ground_truth": "SELECT T2.apt_number FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.booking_status_code  =  \"Confirmed\" INTERSECT SELECT T2.apt_number FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.booking_status_code  =  \"Provisional\"",
        "amends": [
            "Do select `T2.apt_number` from the `Apartments` table instead of `apartment_number` from a single table. Do join `Apartment_Bookings AS T1` with `Apartments AS T2` on `T1.apt_id = T2.apt_id` instead of querying only the `bookings` table. Do filter for `T1.booking_status_code = \"Confirmed\"` in one query and `T1.booking_status_code = \"Provisional\"` in another instead of using `AND status_code = 'Provisional' AND status_code = 'Confirmed'` which is logically impossible. Do use `INTERSECT` to find apartments with both statuses instead of the contradictory WHERE clause. Do properly reference table aliases `T1` and `T2` instead of unspecified column sources. The amended query now correctly identifies apartments that have both Confirmed and Provisional bookings through set intersection."
        ],
        "rules": [
            "1) When answering about apartments with both booking status codes: select T2.apt_number from the Apartments table instead of apartment_number from a single table. 2) When combining Apartment_Bookings and Apartments tables: join T1 (Apartment_Bookings) with T2 (Apartments) on T1.apt_id = T2.apt_id using exact key equality. 3) When filtering for both \"Confirmed\" and \"Provisional\" statuses: use separate queries with T1.booking_status_code = \"Confirmed\" and T1.booking_status_code = \"Provisional\" instead of contradictory AND conditions. 4) When finding apartments with both statuses: use INTERSECT operation between the two filtered result sets to get the intersection. 5) When referencing columns: use exact table aliases T1 and T2 with the correct column names as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT apartment_number FROM bookings WHERE status_code = 'Provisional' AND status_code = 'Confirmed';",
            "SELECT T2.apt_number\nFROM Apartment_Bookings AS T1\nJOIN Apartments AS T2 ON T1.apt_id = T2.apt_id\nWHERE T1.booking_status_code = 'Confirmed'\nINTERSECT\nSELECT T2.apt_number\nFROM Apartment_Bookings AS T1\nJOIN Apartments AS T2 ON T1.apt_id = T2.apt_id\nWHERE T1.booking_status_code = 'Provisional'"
        ],
        "rule_sql": [
            "SELECT T2.apt_number\nFROM Apartment_Bookings T1\nJOIN Apartments T2 ON T1.apt_id = T2.apt_id\nWHERE T1.booking_status_code = 'Confirmed'\nINTERSECT\nSELECT T2.apt_number\nFROM Apartment_Bookings T1\nJOIN Apartments T2 ON T1.apt_id = T2.apt_id\nWHERE T1.booking_status_code = 'Provisional'"
        ]
    },
    "5451": {
        "db_id": "voter_2",
        "question": "What is the oldest age among the students?",
        "ground_truth": "SELECT max(Age) FROM STUDENT",
        "amends": [
            "Do use `max` aggregate function instead of `min` to calculate the maximum value. Do reference the `Age` column instead of `age` to match the correct column name. Do query from the `STUDENT` table instead of `students` to use the correct table name. The amended query now correctly returns the maximum age from the STUDENT table instead of the minimum age from students."
        ],
        "rules": [
            "1) When the question asks for the \"oldest age\": use the MAX aggregate function to find the maximum value. 2) When referencing the age column: use the exact column name \"Age\" with proper case. 3) When querying student data: use the exact table name \"STUDENT\" instead of any variations. 4) When calculating maximum age from the STUDENT table: ensure the output column order shows the maximum age result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(age) FROM students;",
            "SELECT MAX(Age) FROM Student;"
        ],
        "rule_sql": [
            "SELECT MAX(Age) FROM STUDENT;"
        ]
    },
    "4847": {
        "db_id": "local_govt_and_lot",
        "question": "List the id and type of each thing, and the details of the organization that owns it.",
        "ground_truth": "SELECT T1.thing_id ,  T1.type_of_Thing_Code ,  T2.organization_details FROM Things AS T1 JOIN Organizations AS T2 ON T1.organization_id  =  T2.organization_id",
        "amends": [
            "Do select `thing_id`, `type_of_Thing_Code`, and `organization_details` instead of `id`, `type`, `name`, and `address`. Do use `JOIN` instead of `LEFT JOIN` to exclude records without matching organization. Do join on `organization_id = organization_id` instead of `organization_id = id` to correctly match the organization identifier. Do use table aliases `T1` and `T2` instead of `t` and `o` for better clarity. The amended query now correctly retrieves only things with associated organizations using the proper join condition and column selection."
        ],
        "rules": [
            "1) When selecting columns for things: use \"T1\".\"thing_id\" and \"T1\".\"type_of_Thing_Code\" instead of generic id and type columns. 2) When selecting columns for organizations: use \"T2\".\"organization_details\" instead of separate name and address columns. 3) When joining Things and Organizations tables: use INNER JOIN instead of LEFT JOIN to exclude records without matching organizations. 4) When matching organizations to things: join on \"T1\".\"organization_id\" = \"T2\".\"organization_id\" instead of using different column names. 5) When using table aliases: use \"T1\" for the Things table and \"T2\" for the Organizations table consistently."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.id, t.type, o.name, o.address FROM things t LEFT JOIN organizations o ON t.organization_id = o.id;",
            "SELECT T1.thing_id, T1.Type_of_Thing_Code, T2.organization_details FROM Things T1 JOIN Organizations T2 ON T1.organization_id = T2.organization_id"
        ],
        "rule_sql": [
            "SELECT T1.thing_id, T1.Type_of_Thing_Code, T2.organization_details FROM Things T1 INNER JOIN Organizations T2 ON T1.organization_id = T2.organization_id;"
        ]
    },
    "4889": {
        "db_id": "school_player",
        "question": "Order denominations in descending order of the count of schools with the denomination. Return each denomination with the count of schools.",
        "ground_truth": "SELECT Denomination ,  COUNT(*) FROM school GROUP BY Denomination ORDER BY COUNT(*) DESC",
        "amends": [
            "Do use `COUNT(*)` without an alias instead of `COUNT(*) as school_count`, and reference `Denomination` with proper capitalization instead of `denomination`. Do change the sort direction to `DESC` instead of `ASC` in the ORDER BY clause, and reference the aggregate function directly as `COUNT(*)` instead of using the alias `school_count`. Do reference the table as `school` instead of `schools` to match the correct table name. The amended query now correctly counts schools by denomination in descending order without unnecessary aliasing."
        ],
        "rules": [
            "1) When answering about \"count of schools with the denomination\": compute the number of rows using COUNT(*) without an alias. 2) When the question mentions \"denomination\": \"denomination\" actually means \"Denomination\" in schema with exact capitalization. 3) When the question asks for \"descending order of the count\": rank rows by COUNT(*) in descending direction. 4) When the question asks for results \"by denomination\": organize results by the exact token \"Denomination\". 5) When referencing the table: use the exact table name \"school\" instead of \"schools\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT denomination, COUNT(*) as school_count FROM schools GROUP BY denomination ORDER BY school_count ASC;",
            "SELECT Denomination, COUNT(*) FROM school GROUP BY Denomination ORDER BY COUNT(*) DESC;"
        ],
        "rule_sql": [
            "SELECT Denomination, COUNT(*) FROM school GROUP BY Denomination ORDER BY COUNT(*) DESC;"
        ]
    },
    "2899": {
        "db_id": "icfp_1",
        "question": "Which author has written the most papers? Find his or her last name.",
        "ground_truth": "SELECT t1.lname FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid GROUP BY t1.fname ,  t1.lname ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `authors AS t1` and `authorship AS t2` on `t1.authid = t2.authid` instead of omitting these tables, then join `papers AS t3` on `t2.paperid = t3.paperid` instead of querying `papers` directly. Do select `t1.lname` instead of `author_last_name` and group by both `t1.fname` and `t1.lname` instead of only `author_last_name` to properly count co-authored papers per unique author. The amended query now correctly identifies the author with the most papers by joining through the authorship relationship table."
        ],
        "rules": [
            "1) When answering about \"which author has written the most papers\": make sure the output order: t1.lname 2) When the question mentions \"author\" and \"papers\": use tables \"authors AS t1\", \"authorship AS t2\", and \"papers AS t3\" instead of querying papers directly 3) When combining tables for author-paper relationships: link rows where t1.authid = t2.authid and t2.paperid = t3.paperid, keeping only matching pairs (inner match) 4) When counting papers per author: group by both t1.fname and t1.lname to properly count co-authored papers per unique author 5) When selecting the author's last name: use t1.lname instead of author_last_name 6) When finding the author with the most papers: rank authors by paper count in descending order and keep the first 1 row"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT author_last_name FROM papers GROUP BY author_last_name ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT t1.lname\nFROM Authors AS t1\nJOIN Authorship AS t2 ON t1.authID = t2.authID\nJOIN Papers AS t3 ON t2.paperID = t3.paperID\nGROUP BY t1.fname, t1.lname\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t1.lname \nFROM Authors AS t1\nJOIN Authorship AS t2 ON t1.authID = t2.authID\nJOIN Papers AS t3 ON t2.paperID = t3.paperID\nGROUP BY t1.fname, t1.lname\nORDER BY COUNT(t3.paperID) DESC\nLIMIT 1;"
        ]
    },
    "6391": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "List all statement ids and statement details.",
        "ground_truth": "SELECT STATEMENT_ID ,  statement_details FROM Statements",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM statements;"
        ],
        "rule_sql": [
            "SELECT Statement_ID, Statement_Details FROM Statements;"
        ]
    },
    "6119": {
        "db_id": "customers_and_addresses",
        "question": "How many orders have detail \"Second time\"?",
        "ground_truth": "SELECT count(*) FROM customer_orders WHERE order_details  =  \"Second time\"",
        "amends": [
            "Do reference table `customer_orders` instead of `orders` and use column `order_details` instead of `detail` while maintaining the same filter condition for `'Second time'` values, with the aggregate function `count(*)` remaining unchanged in both queries."
        ],
        "rules": [
            "1) When the question asks about orders: use table \"customer_orders\" (not \"orders\") as the base table T1. 2) When the question mentions \"detail\": this refers to column \"order_details\" in table T1. 3) When filtering for \"Second time\" values: use the exact literal 'Second time' with matching case and spacing. 4) When counting orders: use count(*) to count all rows that match the filter condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE detail = 'Second time';",
            "SELECT COUNT(*) FROM Customer_Orders WHERE order_details = 'Second time';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Customer_Orders WHERE order_details = 'Second time'"
        ]
    },
    "30": {
        "db_id": "farm",
        "question": "List official names of cities in descending order of population.",
        "ground_truth": "SELECT Official_Name FROM city ORDER BY Population DESC",
        "amends": [
            "Do use `Official_Name` instead of `name` for the column selection. Do use `city` instead of `cities` as the table source. Do use `Population` instead of `population` for the ordering column. Do use `DESC` instead of `ASC` for the sort direction. The amended query now correctly selects the official name from the city table ordered by population in descending order."
        ],
        "rules": [
            "1) When selecting city names from the city table: use the exact column name \"Official_Name\" instead of \"name\". 2) When ordering by population: use the exact column name \"Population\" instead of \"population\". 3) When the question asks for descending order of population: sort by \"Population\" in descending order instead of ascending order. 4) When referring to the table containing city data: use the exact table name \"city\" instead of \"cities\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM cities ORDER BY population ASC;",
            "SELECT Official_Name FROM city ORDER BY Population DESC;"
        ],
        "rule_sql": [
            "SELECT Official_Name FROM city ORDER BY Population DESC;"
        ]
    },
    "2524": {
        "db_id": "movie_1",
        "question": "What are names of the movies that are either made after 2000 or reviewed by Brittany Harris?",
        "ground_truth": "SELECT DISTINCT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T3.name  =  'Brittany Harris' OR T2.year  >  2000",
        "amends": [
            "Do use `DISTINCT T2.title` instead of `title` to eliminate duplicates. Do add explicit table joins with `Rating AS T1 JOIN Movie AS T2 ON T1.mID = T2.mID JOIN Reviewer AS T3 ON T1.rID = T3.rID` instead of querying only the `movies` table. Do specify the correct column references with `T3.name = 'Brittany Harris'` instead of `reviewer = 'Brittany Harris'` and `T2.year > 2000` instead of `year > 2000`. The amended query now correctly joins the necessary tables to establish proper relationships between movies, ratings, and reviewers, ensuring accurate filtering based on both reviewer name and movie year."
        ],
        "rules": [
            "1) When answering about movie names: make sure the output order: T2.title. 2) When the question mentions \"movies made after 2000\": \"year > 2000\" actually means \"T2.year > 2000\" in schema. 3) When the question mentions \"reviewed by Brittany Harris\": \"reviewer = 'Brittany Harris'\" actually means \"T3.name = 'Brittany Harris'\" in schema. 4) When combining tables for shared entities: link rows where T1.mID = T2.mID and T1.rID = T3.rID; keep only matching pairs (inner match). 5) When eliminating duplicate movie titles: use DISTINCT T2.title to return unique movie names. 6) When the question asks for movies that satisfy either condition: use OR logic between T2.year > 2000 and T3.name = 'Brittany Harris'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM movies WHERE year > 2000 OR reviewer = 'Brittany Harris'",
            "SELECT DISTINCT T2.title\nFROM Rating AS T1\nJOIN Movie AS T2 ON T1.mID = T2.mID\nJOIN Reviewer AS T3 ON T1.rID = T3.rID\nWHERE T2.year > 2000 OR T3.name = 'Brittany Harris'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.title FROM Rating T1 JOIN Movie T2 ON T1.mID = T2.mID JOIN Reviewer T3 ON T1.rID = T3.rID WHERE T2.year > 2000 OR T3.name = 'Brittany Harris'"
        ]
    },
    "1319": {
        "db_id": "performance_attendance",
        "question": "Show the dates of performances with attending members whose roles are \"Violin\".",
        "ground_truth": "SELECT T3.Date FROM member_attendance AS T1 JOIN member AS T2 ON T1.Member_ID  =  T2.Member_ID JOIN performance AS T3 ON T1.Performance_ID  =  T3.Performance_ID WHERE T2.Role  =  \"Violin\"",
        "amends": [
            "Do use `T3.Date` instead of `performance_date` as the selected column. Do join `member_attendance AS T1` instead of querying only the `performances` table. Do add `JOIN member AS T2 ON T1.Member_ID = T2.Member_ID` to connect member information instead of omitting this relationship. Do add `JOIN performance AS T3 ON T1.Performance_ID = T3.Performance_ID` to properly link attendance to performances instead of directly querying performances. Do filter on `T2.Role = \"Violin\"` instead of `role = 'Violin'` to correctly reference the member's role rather than a performance attribute. The amended query now correctly retrieves performance dates for violin members through proper table relationships instead of making incorrect assumptions about where role data is stored."
        ],
        "rules": [
            "1) When answering about \"dates of performances with attending members whose roles are 'Violin'\": make sure the output order: T3.Date. 2) When the question mentions \"performances with attending members\": use member_attendance AS T1 as the base table instead of directly querying performances. 3) When combining member_attendance (T1) and member (T2) tables: link rows where T1.Member_ID = T2.Member_ID exactly and keep only matching pairs (inner match). 4) When combining member_attendance (T1) and performance (T3) tables: link rows where T1.Performance_ID = T3.Performance_ID exactly and keep only matching pairs (inner match). 5) When filtering for members with role \"Violin\": use T2.Role = \"Violin\" exactly (with double quotes) to reference the member's role attribute rather than a performance attribute."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT performance_date FROM performances WHERE role = 'Violin'",
            "SELECT T3.Date \nFROM member_attendance AS T1\nJOIN member AS T2 ON T1.Member_ID = T2.Member_ID\nJOIN performance AS T3 ON T1.Performance_ID = T3.Performance_ID\nWHERE T2.Role = \"Violin\""
        ],
        "rule_sql": [
            "SELECT DISTINCT T3.Date\nFROM member_attendance AS T1\nINNER JOIN member AS T2 ON T1.Member_ID = T2.Member_ID\nINNER JOIN performance AS T3 ON T1.Performance_ID = T3.Performance_ID\nWHERE T2.Role = \"Violin\""
        ]
    },
    "4388": {
        "db_id": "tracking_grants_for_research",
        "question": "How many tasks are there in total?",
        "ground_truth": "SELECT count(*) FROM Tasks",
        "amends": [
            "Do select from `Tasks` table instead of `employees` table. The amended query now correctly counts records from the Tasks table as specified in the target output."
        ],
        "rules": [
            "1) When answering about \"how many tasks are there in total\": count the number of rows using the canonical key from the Tasks table. 2) When the question mentions \"tasks\": \"tasks\" actually means records from the \"Tasks\" table in the schema. 3) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table names like \"Tasks\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees;",
            "SELECT COUNT(*) AS total_tasks FROM Tasks;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM \"Tasks\";"
        ]
    },
    "3211": {
        "db_id": "college_1",
        "question": "Find the count and code of the job has most employees.",
        "ground_truth": "SELECT emp_jobcode ,  count(*) FROM employee GROUP BY emp_jobcode ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use `emp_jobcode` instead of `job_code` for the column name and do not alias it in the SELECT list. Do use `employee` instead of `employees` for the table name. Do remove the `AS employee_count` alias and instead use `count(*)` directly in both SELECT and ORDER BY clauses. Do change the ORDER BY direction to `DESC` instead of the default ascending order to find the job code with the highest count instead of the lowest. The amended query now correctly identifies the job code with the most employees by counting occurrences per job code and sorting descending by count."
        ],
        "rules": [
            "1) When the question asks for \"count and code of the job has most employees\": use \"employee\" as the table name and \"emp_jobcode\" as the column name for job code. 2) When counting employees per job code: group by \"emp_jobcode\" and use count(*) without aliasing it as \"employee_count\". 3) When finding the job with the most employees: order the results by count(*) in descending direction and keep only the first row to get the maximum count."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS employee_count, job_code FROM employees GROUP BY job_code ORDER BY employee_count LIMIT 1;",
            "SELECT emp_jobcode, count(*) FROM employee GROUP BY emp_jobcode ORDER BY count(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT emp_jobcode, count(*) FROM employee GROUP BY emp_jobcode ORDER BY count(*) DESC LIMIT 1;"
        ]
    },
    "2502": {
        "db_id": "movie_1",
        "question": "For each director, return the director's name together with the title of the movie they directed that received the highest rating among all of their movies, and the value of that rating. Ignore movies whose director is NULL.",
        "ground_truth": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != \"null\" GROUP BY director",
        "amends": [
            "Do reference tables `Rating AS T1` and `Movie AS T2` instead of `directors d` and `movies m`. Do use join condition `T1.mID = T2.mID` instead of `d.director_id = m.director_id`. Do select columns `T2.title`, `T1.stars`, and `T2.director` instead of `d.name` and `m.title`. Do use aggregate `max(T1.stars)` instead of `MAX(m.rating)`. Do apply filter `director != \"null\"` instead of `d.name IS NOT NULL`. Do group by `director` instead of `d.name, m.title`. The amended query now correctly retrieves maximum ratings per director while filtering out null director values and matches the intended behavior.",
            "Do include `T2.title`, `T1.stars`, and `T2.director` in the SELECT list instead of omitting them, and do use `director != \"null\"` instead of `T2.director IS NOT NULL` for the WHERE filter. Do group by `director` instead of `T2.director` while keeping the same join condition `T1.mID = T2.mID`. The amended query now correctly includes all necessary columns and properly handles null string values while maintaining the same aggregation logic.",
            "Do include `T2.title`, `T1.stars`, and `T2.director` in the SELECT list instead of omitting them, and do include `T1.stars` in the GROUP BY clause instead of grouping only by `T2.director`. Do remove the alias `highest_rating` for the aggregate function instead of keeping it. The amended query now correctly displays individual movie details alongside maximum ratings per director while maintaining proper grouping semantics.",
            "Do include all columns `T2.title`, `T1.stars`, `T2.director`, and `max(T1.stars)` in the SELECT list instead of only `T2.director`, `T2.title`, and `T1.stars`. Do remove the HAVING clause `T1.stars = MAX(T1.stars)` instead of keeping it, as the maximum stars value is now properly included in the SELECT list. Do group by `director` instead of `T2.director` since the column reference can be simplified. The amended query now correctly displays all requested columns including the maximum stars value for each director without the problematic HAVING clause that would filter results incorrectly.",
            "Do include `T2.title` and `T1.stars` in the SELECT list instead of omitting them, and do remove the alias `highest_rating` from `MAX(T1.stars)` instead of keeping it. Do maintain the same FROM clause with `JOIN Movie AS T2 ON T1.mID = T2.mID` and the same WHERE filter `director != \"null\"` with identical GROUP BY `director`. The amended query now correctly returns all specified columns while maintaining the same aggregation logic and filtering behavior."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT d.name, m.title, MAX(m.rating) \nFROM directors d \nJOIN movies m ON d.director_id = m.director_id \nWHERE d.name IS NOT NULL \nGROUP BY d.name, m.title",
            "SELECT T2.director, T2.title, MAX(T1.stars) as highest_rating\nFROM Rating AS T1\nJOIN Movie AS T2 ON T1.mID = T2.mID\nWHERE T2.director IS NOT NULL\nGROUP BY T2.director",
            "SELECT T2.director, T2.title, MAX(T1.stars) as highest_rating\nFROM Rating AS T1\nJOIN Movie AS T2 ON T1.mID = T2.mID\nWHERE T2.director != \"null\"\nGROUP BY T2.director",
            "SELECT T2.director, T2.title, T1.stars\nFROM Rating AS T1\nJOIN Movie AS T2 ON T1.mID = T2.mID\nWHERE T2.director != \"null\"\nGROUP BY T2.director\nHAVING T1.stars = MAX(T1.stars)",
            "SELECT T2.director, T2.title, T1.stars, MAX(T1.stars) as highest_rating\nFROM Rating AS T1\nJOIN Movie AS T2 ON T1.mID = T2.mID\nWHERE director != \"null\"\nGROUP BY director",
            "SELECT T2.director, T2.title, T1.stars, MAX(T1.stars) \nFROM Rating AS T1 \nJOIN Movie AS T2 ON T1.mID = T2.mID \nWHERE director != \"null\" \nGROUP BY director"
        ],
        "rule_sql": []
    },
    "3602": {
        "db_id": "music_1",
        "question": "What are the maximum duration and resolution of all songs, for each language, ordered alphabetically by language?",
        "ground_truth": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages",
        "amends": [
            "Do specify `max(T1.duration)` and `max(T2.resolution)` with explicit table aliases instead of `MAX(duration)` and `MAX(resolution)` without table qualification. Do join `files AS T1` and `song AS T2` with `ON T1.f_id = T2.f_id` instead of querying only a single table. Do group by `T2.languages` instead of `language` to match the correct table source. Do order by `T2.languages` instead of `language` to maintain consistency with the grouped column. The amended query now correctly joins the tables and uses qualified column references to match the RIGHT_SQL's behavior.",
            "Do list columns in the order `max(T1.duration)`, `max(T2.resolution)`, and `T2.languages` instead of `T2.languages`, `MAX(T1.duration) AS max_duration`, and `MAX(T2.resolution) AS max_resolution`. Do remove the explicit column aliases `max_duration` and `max_resolution` instead of keeping them. The amended query now correctly matches the RIGHT_SQL's behavior with identical column selection and ordering."
        ],
        "rules": [
            "1) When joining tables files and song: link rows where T1.f_id equals T2.f_id exactly and keep only matching pairs (inner match). 2) When computing maximum duration: use max(T1.duration) with explicit table qualification. 3) When computing maximum resolution: use max(T2.resolution) with explicit table qualification. 4) When grouping by language: use T2.languages as the grouping column to match the correct table source. 5) When ordering results alphabetically by language: order by T2.languages in ascending order to maintain consistency with the grouped column.",
            "1) When answering about maximum duration and resolution of songs for each language: make sure the output order is max(T1.duration), max(T2.resolution), T2.languages\n2) When the question asks for maximum values grouped by language: compute MAX(T1.duration) and MAX(T2.resolution) for each T2.languages group\n3) When organizing results by language: group by T2.languages and order alphabetically by T2.languages\n4) When combining files and song tables: link rows where T1.f_id = T2.f_id and keep only matching pairs (inner match)\n5) When producing output columns: do not use explicit column aliases like max_duration or max_resolution"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT language, MAX(duration), MAX(resolution) FROM songs GROUP BY language ORDER BY language ASC;",
            "SELECT T2.languages, MAX(T1.duration) AS max_duration, MAX(T2.resolution) AS max_resolution FROM files AS T1 JOIN song AS T2 ON T1.f_id = T2.f_id GROUP BY T2.languages ORDER BY T2.languages",
            "SELECT MAX(T1.duration), MAX(T2.resolution), T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id = T2.f_id GROUP BY T2.languages ORDER BY T2.languages"
        ],
        "rule_sql": [
            "SELECT MAX(T1.duration), MAX(T2.resolution), T2.languages FROM files T1 INNER JOIN song T2 ON T1.f_id = T2.f_id GROUP BY T2.languages ORDER BY T2.languages ASC"
        ]
    },
    "4278": {
        "db_id": "club_1",
        "question": "Find the name of the club that has the most female students.",
        "ground_truth": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  \"F\" GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid = t2.clubid JOIN student AS t3 ON t2.stuid = t3.stuid` instead of just `FROM clubs`; do add `WHERE t3.sex = \"F\"` instead of omitting this filter; do change `GROUP BY t1.clubname` instead of grouping by the entire table; do use `t1.clubname` instead of `club_name`; and do maintain `ORDER BY count(*) DESC LIMIT 1` as the correct aggregation approach. The amended query now correctly identifies the club with the most female members instead of simply counting all club members."
        ],
        "rules": [
            "1) When answering about \"club with the most female students\": make sure the output order: t1.clubname. 2) When the question mentions \"female students\": \"female\" actually means \"sex = 'F'\" in the student table. 3) When combining tables for club membership information: link rows where t1.clubid = t2.clubid and t2.stuid = t3.stuid; keep only matching pairs (inner match). 4) When the question asks for \"count of female students per club\": compute the number of rows using the canonical key t3.stuid for students where t3.sex = 'F', grouped by t1.clubname. 5) When the question asks for \"the most\" (highest count): rank rows by count of female students in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT club_name FROM clubs ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT t1.ClubName\nFROM Club AS t1\nJOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID\nJOIN Student AS t3 ON t2.StuID = t3.StuID\nWHERE t3.Sex = 'F'\nGROUP BY t1.ClubName\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t1.ClubName\nFROM Club t1\nJOIN Member_of_club t2 ON t1.ClubID = t2.ClubID\nJOIN Student t3 ON t2.StuID = t3.StuID\nWHERE t3.Sex = 'F'\nGROUP BY t1.ClubName\nORDER BY COUNT(t3.StuID) DESC\nLIMIT 1;"
        ]
    },
    "3440": {
        "db_id": "hr_1",
        "question": "Which employees were hired after September 7th, 1987?",
        "ground_truth": "SELECT * FROM employees WHERE hire_date  >  '1987-09-07'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM employees WHERE hire_date > '1987-09-07';"
        ],
        "rule_sql": [
            "SELECT * FROM employees WHERE HIRE_DATE > '1987-09-07';"
        ]
    },
    "1649": {
        "db_id": "theme_gallery",
        "question": "How many artists do we have?",
        "ground_truth": "SELECT count(*) FROM artist",
        "amends": [
            "Do query the `artist` table instead of the `albums` table. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"how many artists\": query the \"artist\" table instead of the \"albums\" table. 2) When counting artists: count all rows from the \"artist\" table using the canonical key for artists."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM albums;",
            "SELECT COUNT(*) FROM artist;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM artist;"
        ]
    },
    "2496": {
        "db_id": "movie_1",
        "question": "Find the movies with the highest average rating. Return the movie titles and average rating.",
        "ground_truth": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT 1",
        "amends": [
            "Do join `Rating AS T1` with `Movie AS T2` on `T1.mID = T2.mID` instead of querying only the `movies` table. Do select `T2.title` and `avg(T1.stars)` instead of `movie_title` and `AVG(rating)`. Do group by `T1.mID` instead of `movie_title` to correctly aggregate ratings per movie. Do order by `avg(T1.stars)` instead of `average_rating` while maintaining the descending sort. The amended query now correctly joins rating data with movie information and aggregates by movie ID rather than title, matching the RIGHT_SQL's behavior.",
            "Do add `LIMIT 1` to return only the highest-rated movie instead of omitting it, and do use lowercase `avg` function instead of uppercase `AVG` for consistency. Do keep the same `SELECT` list with `T2.title` and `avg(T1.stars)` instead of using an alias, and maintain the same `FROM` clause with `JOIN Movie AS T2 ON T1.mID = T2.mID` instead of any join changes. Do preserve the same `GROUP BY T1.mID` and `ORDER BY avg(T1.stars) DESC` structure instead of modifying grouping or ordering. The amended query now matches RIGHT_SQL's behavior by correctly returning only the single highest-rated movie."
        ],
        "rules": [
            "1) When answering about \"movies with the highest average rating\": make sure the output order: T2.title, avg(T1.stars) 2) When combining Rating and Movie tables: link rows where T1.mID = T2.mID and keep only matching pairs (inner match) 3) When computing average rating per movie: group by T1.mID instead of movie title to correctly aggregate ratings per movie 4) When ordering results: rank rows by avg(T1.stars) in descending direction and keep the first 1 row 5) When selecting movie information: use T2.title instead of movie_title for the exact column token",
            "1) When answering about \"movies with the highest average rating\": make sure the output order: T2.title, avg(T1.stars). 2) When the question mentions \"highest average rating\": rank rows by avg(T1.stars) in descending order and keep the first 1 row. 3) When combining Rating as T1 and Movie as T2: link rows where T1.mID = T2.mID and keep only matching pairs (inner match). 4) When computing average rating per movie: organize results by T1.mID and compute avg(T1.stars) per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT movie_title, AVG(rating) as average_rating \nFROM movies \nGROUP BY movie_title \nORDER BY average_rating DESC \nLIMIT 1;",
            "SELECT T2.title, AVG(T1.stars) AS average_rating\nFROM Rating AS T1\nJOIN Movie AS T2 ON T1.mID = T2.mID\nGROUP BY T1.mID\nORDER BY AVG(T1.stars) DESC;",
            "SELECT T2.title, avg(T1.stars) \nFROM Rating AS T1 \nJOIN Movie AS T2 ON T1.mID = T2.mID \nGROUP BY T1.mID \nORDER BY avg(T1.stars) DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.title, AVG(T1.stars) \nFROM Rating AS T1 \nINNER JOIN Movie AS T2 ON T1.mID = T2.mID \nGROUP BY T1.mID \nORDER BY AVG(T1.stars) DESC \nLIMIT 1"
        ]
    },
    "4437": {
        "db_id": "network_2",
        "question": "What are the names of everybody sorted by age in descending order?",
        "ground_truth": "SELECT name FROM Person ORDER BY age DESC",
        "amends": [
            "Do reference table `Person` instead of `people` in the FROM clause. Do use `DESC` ordering instead of `ASC` for the age column in the ORDER BY clause. The amended query now correctly sorts by age in descending order from the Person table."
        ],
        "rules": [
            "1) When answering about \"names of everybody sorted by age in descending order\": make sure the output order: name. 2) When the question mentions \"everybody\": \"everybody\" actually means all rows from table \"Person\". 3) When the question mentions \"sorted by age in descending order\": rank rows by age in descending direction. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM people ORDER BY age ASC;",
            "SELECT name FROM Person ORDER BY age DESC;"
        ],
        "rule_sql": [
            "SELECT name FROM Person ORDER BY age DESC;"
        ]
    },
    "3534": {
        "db_id": "music_1",
        "question": "What are the names of all songs in English?",
        "ground_truth": "SELECT song_name FROM song WHERE languages  =  \"english\"",
        "amends": [
            "Do reference column `song_name` instead of `title` and table `song` instead of `songs`. Do use filter condition `languages = \"english\"` instead of `language = 'English'` to match the correct column name and case-insensitive value format. The amended query now correctly retrieves data from the proper table structure with accurate column references and filtering conditions."
        ],
        "rules": [
            "1) When the question asks for song names: use column \"song_name\" from table \"song\" instead of \"title\" from \"songs\". 2) When filtering for English songs: use condition \"languages = \\\"english\\\"\" with exact lowercase literal and double quotes around column name. 3) When the question mentions \"songs\": the correct table name is \"song\" (singular) not \"songs\" (plural)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM songs WHERE language = 'English';",
            "SELECT song_name FROM song WHERE languages = 'english';"
        ],
        "rule_sql": [
            "SELECT song_name FROM song WHERE languages = \"english\";"
        ]
    },
    "2369": {
        "db_id": "csu_1",
        "question": "How many degrees were conferred at San Jose State University in 2000?",
        "ground_truth": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  \"San Jose State University\" AND t2.year  =  2000",
        "amends": [
            "Do select `degrees` column instead of `COUNT(*)` aggregate. Do join `campuses` table with `degrees` table using `LEFT JOIN` on `t1.id = t2.campus` instead of querying only the `degrees` table. Do filter on `t1.campus = \"San Jose State University\"` instead of `university = 'San Jose State University'`. Do filter on `t2.year = 2000` instead of `year = 2000`. The amended query now correctly joins the campuses and degrees tables to retrieve the actual degrees count for the specified campus and year, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"degrees conferred at a university\": make sure the output order: degrees column from the degrees table. 2) When the question mentions \"San Jose State University\": \"San Jose State University\" actually means filtering on t1.campus = \"San Jose State University\" in the campuses table. 3) When the question mentions year 2000: filter on t2.year = 2000 in the degrees table. 4) When combining campuses table (T1) and degrees table (T2): link rows where t1.id = t2.campus using a left join to include all campuses even if they have no degrees. 5) When counting degrees: select the actual degrees column instead of using COUNT(*) aggregate."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM degrees WHERE university = 'San Jose State University' AND year = 2000;",
            "SELECT d.Degrees \nFROM Campuses c \nLEFT JOIN degrees d ON c.Id = d.Campus \nWHERE c.Campus = 'San Jose State University' \nAND d.Year = 2000"
        ],
        "rule_sql": [
            "SELECT d.Degrees \nFROM Campuses c \nLEFT JOIN degrees d ON c.Id = d.Campus \nWHERE c.Campus = 'San Jose State University' AND d.Year = 2000"
        ]
    },
    "516": {
        "db_id": "allergy_1",
        "question": "How many students have each different allergy?",
        "ground_truth": "SELECT Allergy ,  count(*) FROM Has_allergy GROUP BY Allergy",
        "amends": [
            "Do reference table `Has_allergy` instead of `students` and use column `Allergy` instead of `allergy` to match the correct table schema and column naming. Do maintain the same aggregate function `count(*)` and `GROUP BY Allergy` structure as the original query. The amended query now correctly queries from the Has_allergy table with proper column capitalization to match RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"how many students have each different allergy\": make sure the output order: \"Allergy\" first, then count. 2) When the question mentions \"allergy\": \"allergy\" actually means \"Allergy\" in schema from table \"Has_Allergy\". 3) When the question asks for \"count of students per allergy\": compute the number of rows using the canonical key for students from the \"Has_Allergy\" table, grouped by \"Allergy\". 4) When choosing identifier delimiters: do not replace the exact column name \"Allergy\" with lowercase \"allergy\" or any other variation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT allergy, COUNT(*) FROM students GROUP BY allergy;",
            "SELECT Allergy, COUNT(*) FROM Has_Allergy GROUP BY Allergy;"
        ],
        "rule_sql": [
            "SELECT Allergy, COUNT(StuID) AS count FROM Has_Allergy GROUP BY Allergy ORDER BY Allergy;"
        ]
    },
    "5012": {
        "db_id": "soccer_2",
        "question": "Find the average hours for the students whose tryout decision is no.",
        "ground_truth": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'no'",
        "amends": [
            "Do select `avg(T1.HS)` instead of `AVG(hours)` and use table alias `T1` instead of direct column reference. Do join table `player AS T1` with `tryout AS T2` on `T1.pID = T2.pID` instead of querying only the `students` table. Do filter on `T2.decision = 'no'` instead of `tryout_decision = 'yes'`, changing both the table reference and the conditional value. The amended query now correctly calculates average high school statistics from joined player and tryout tables for players with negative tryout decisions, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"average hours for students whose tryout decision is no\": make sure the output order: average of T1.HS. 2) When the question mentions \"hours\": \"hours\" actually means \"T1.HS in schema\". 3) When the question mentions \"tryout decision is no\": use condition T2.decision = 'no' with exact literal 'no'. 4) When combining player table as T1 and tryout table as T2: link rows where T1.pID = T2.pID exactly as shown; keep only matching pairs (inner match). 5) When computing average: calculate the average of T1.HS values for the filtered rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(hours) FROM students WHERE tryout_decision = 'yes';",
            "SELECT AVG(T1.HS) FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T2.decision = 'no'"
        ],
        "rule_sql": [
            "SELECT AVG(T1.HS) FROM Player T1 INNER JOIN Tryout T2 ON T1.pID = T2.pID WHERE T2.decision = 'no'"
        ]
    },
    "5439": {
        "db_id": "shop_membership",
        "question": "What are the total purchases for members rated at level 6?",
        "ground_truth": "SELECT count(*) FROM purchase AS T1 JOIN member AS T2 ON T1.member_id  =  T2.member_id WHERE T2.level  =  6",
        "amends": [
            "Do use `count(*)` instead of `SUM(purchase_amount)` for counting records. Do join `purchase` table with `member` table using `ON T1.member_id = T2.member_id` instead of querying only the `members` table. Do filter on `T2.level = 6` instead of `rating_level = 6` to reference the correct column name and table. Do remove the aggregation function `SUM()` and instead use `count(*)` to count the number of purchase records for members with level 6. The amended query now correctly counts purchases for members with level 6 by properly joining the relevant tables and using appropriate filtering conditions."
        ],
        "rules": [
            "1) When the question asks for \"total purchases\" meaning count of purchase records: use count(*) instead of SUM(purchase_amount) to count the number of records. 2) When combining purchase and member tables: link rows where T1.member_id = T2.member_id and keep only matching pairs (inner match). 3) When filtering for members rated at level 6: use T2.level = 6 instead of rating_level = 6 to reference the correct column name and table. 4) When counting purchase records for members: use count(*) to count the number of purchase records rather than summing purchase amounts."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(purchase_amount) FROM members WHERE rating_level = 6;",
            "SELECT COUNT(*) \nFROM purchase p\nJOIN member m ON p.Member_ID = m.Member_ID\nWHERE m.Level = 6"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS total_purchases\nFROM purchase p\nINNER JOIN member m ON p.Member_ID = m.Member_ID\nWHERE m.Level = 6"
        ]
    },
    "6973": {
        "db_id": "culture_company",
        "question": "Return the publisher that has published the most books.",
        "ground_truth": "SELECT publisher FROM book_club GROUP BY publisher ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do query from `book_club` table instead of `books` table. Do select only `publisher` column instead of both `publisher` and `COUNT(*) as book_count`. Do use `count(*)` directly in the `ORDER BY` clause instead of referencing an alias `book_count`. The amended query now correctly retrieves the publisher with the highest count from the book_club table."
        ],
        "rules": [
            "1) When answering about \"publisher that has published the most books\": make sure the output order: publisher only\n2) When counting books: use the book_club table instead of books table\n3) When ordering by count: use count(*) directly in the order by clause instead of referencing an alias\n4) When selecting columns: select only the publisher column, not both publisher and count\n5) When finding the publisher with highest count: order by count(*) in descending direction and keep the first 1 row"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT publisher, COUNT(*) as book_count FROM books GROUP BY publisher ORDER BY book_count DESC LIMIT 1;",
            "SELECT Publisher FROM book_club GROUP BY Publisher ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT publisher FROM book_club GROUP BY publisher ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "1222": {
        "db_id": "apartment_rentals",
        "question": "What are the booking start and end dates of the apartments with type code \"Duplex\"?",
        "ground_truth": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  \"Duplex\"",
        "amends": [
            "Do select `T1.booking_start_date` twice instead of `start_date` and `end_date`. Do use `FROM Apartment_Bookings AS T1 JOIN Apartments AS T2` instead of `FROM apartments` alone. Do add `ON T1.apt_id = T2.apt_id` join condition instead of omitting any join. Do use `WHERE T2.apt_type_code = \"Duplex\"` instead of `WHERE type = 'Duplex'`. The amended query now correctly joins the booking and apartment tables to filter by apartment type while retrieving booking dates."
        ],
        "rules": [
            "1) When the question asks for \"booking start and end dates\": select T1.booking_start_date and T1.booking_start_date (exact tokens from schema) instead of generic start_date and end_date. 2) When combining apartment booking and apartment information: use FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 with ON T1.apt_id = T2.apt_id to link rows where the apartment IDs match exactly. 3) When filtering by apartment type \"Duplex\": use WHERE T2.apt_type_code = \"Duplex\" with exact double quotes around the literal value and exact column name apt_type_code. 4) When the question mentions \"apartments with type code\": recognize that type code refers to T2.apt_type_code in the schema, not a generic \"type\" column."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT start_date, end_date FROM apartments WHERE type = 'Duplex';",
            "SELECT T1.booking_start_date, T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id = T2.apt_id WHERE T2.apt_type_code = \"Duplex\""
        ],
        "rule_sql": [
            "SELECT T1.booking_start_date, T1.booking_end_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id = T2.apt_id WHERE T2.apt_type_code = \"Duplex\""
        ]
    },
    "3544": {
        "db_id": "music_1",
        "question": "What are the names of the singers who sang the top 3 most highly rated songs and what countries do they hail from?",
        "ground_truth": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.rating DESC LIMIT 3",
        "amends": [
            "Do select `artist_name` and `country` instead of `name`, `country`, and `AVG(r.rating)`. Do use `FROM artist AS T1` instead of `FROM singers s`. Do use `JOIN song AS T2` instead of `JOIN songs so` and `JOIN ratings r`. Do join on `T1.artist_name = T2.artist_name` instead of `s.singer_id = so.singer_id` and `so.song_id = r.song_id`. Do remove `GROUP BY s.singer_id` instead of keeping it. Do order by `T2.rating DESC` instead of `avg_rating DESC`. The amended query now matches the intended behavior of selecting top artists by song rating without aggregation."
        ],
        "rules": [
            "1) When answering about \"top 3 most highly rated songs\": rank songs by their rating in descending order and keep the first 3 rows. 2) When the question mentions \"names of the singers\": \"names\" actually means \"artist_name\" in the schema. 3) When the question mentions \"countries do they hail from\": \"countries\" actually means \"country\" in the schema. 4) When combining artist and song tables: link rows where T1.artist_name = T2.artist_name exactly as shown in the amends; keep only matching pairs (inner match). 5) When ordering results: sort by T2.rating in descending direction as specified in the amends. 6) When producing output: make sure the output order is artist_name followed by country."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.name, s.country, AVG(r.rating) as avg_rating\nFROM singers s\nJOIN songs so ON s.singer_id = so.singer_id\nJOIN ratings r ON so.song_id = r.song_id\nGROUP BY s.singer_id\nORDER BY avg_rating DESC\nLIMIT 3;",
            "SELECT T1.artist_name, T1.country\nFROM artist AS T1\nJOIN song AS T2 ON T1.artist_name = T2.artist_name\nORDER BY T2.rating DESC\nLIMIT 3"
        ],
        "rule_sql": [
            "SELECT artist.artist_name, artist.country\nFROM artist\nJOIN song ON artist.artist_name = song.artist_name\nORDER BY song.rating DESC\nLIMIT 3;"
        ]
    },
    "58": {
        "db_id": "student_assessment",
        "question": "what is id of students who registered some courses but the least number of courses in these students?",
        "ground_truth": "SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do use table `student_course_registrations` instead of `registrations`. Do remove the `HAVING` clause with subquery instead of keeping it. Do add `ORDER BY count(*) LIMIT 1` instead of omitting it. The amended query now correctly identifies the student with the fewest course registrations by ordering and limiting rather than using a complex subquery comparison."
        ],
        "rules": [
            "1) When the question asks about student course registrations: use table \"student_course_registrations\" instead of any other table name. 2) When counting the number of courses per student: group by \"student_id\" and count the number of registrations for each student. 3) When finding the student with the least number of courses: order the results by the count in ascending order and take only the first result using LIMIT 1. 4) When selecting the student identifier: output only the \"student_id\" column from the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id \nFROM registrations \nGROUP BY student_id \nHAVING COUNT(course_id) = (SELECT MIN(COUNT(course_id)) FROM registrations GROUP BY student_id);",
            "SELECT student_id\nFROM Student_Course_Registrations\nGROUP BY student_id\nORDER BY COUNT(*) ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY COUNT(course_id) ASC LIMIT 1"
        ]
    },
    "1692": {
        "db_id": "epinions_1",
        "question": "How many users are there?",
        "ground_truth": "SELECT count(*) FROM useracct",
        "amends": [
            "Do reference the `useracct` table instead of the `users` table in the FROM clause. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for the aggregate function. The amended query now correctly counts records from the useracct table with the specified identifier, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"how many users\": make sure to reference the \"useracct\" table instead of \"users\" table. 2) When counting records: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" for the aggregate function. 3) When counting users: count all records from the useracct table without filtering by id = 1."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE id = 1;",
            "SELECT count(*) FROM useracct;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM useracct"
        ]
    },
    "3529": {
        "db_id": "music_1",
        "question": "What is the name of the song that was released in the most recent year?",
        "ground_truth": "SELECT song_name ,  releasedate FROM song ORDER BY releasedate DESC LIMIT 1",
        "amends": [
            "Do select `song_name` and `releasedate` instead of `name` and `year`. Do reference table `song` instead of `songs`. Do order by `releasedate` instead of `year`. The amended query now correctly retrieves the latest song based on release date from the appropriate table with the correct column names."
        ],
        "rules": [
            "1) When the question asks for the name of a song: use the exact column token \"song_name\" from table \"song\" instead of \"name\". 2) When the question asks about the most recent year of release: use the exact column token \"releasedate\" from table \"song\" instead of \"year\". 3) When the question asks for the song released in the most recent year: order by \"releasedate\" in descending order and take the first row to get the latest song. 4) When referencing the song table: use the exact table name \"song\" instead of \"songs\"."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM songs ORDER BY year DESC LIMIT 1;",
            "SELECT song_name, releasedate FROM song ORDER BY releasedate DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT song_name FROM song ORDER BY releasedate DESC LIMIT 1;"
        ]
    },
    "4226": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "Show the location codes and the number of documents in each location.",
        "ground_truth": "SELECT location_code ,  count(*) FROM Document_locations GROUP BY location_code",
        "amends": [
            "Do reference `Document_locations` table instead of `documents` table. Do group by `location_code` instead of `document_id` to count documents per location rather than per document. Do maintain the same column selection `location_code` and aggregate function `count(*)` but with corrected grouping logic. The amended query now correctly counts documents grouped by location code from the appropriate table."
        ],
        "rules": [
            "1) When answering about \"location codes and number of documents in each location\": use the \"Document_locations\" table as T1 instead of \"documents\" table. 2) When grouping by location to count documents per location: group by \"location_code\" instead of \"document_id\". 3) When selecting output columns: maintain \"location_code\" and count all rows using count(*)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location_code, COUNT(*) FROM documents GROUP BY document_id;",
            "SELECT Location_Code, COUNT(*) AS Number_of_Documents FROM Document_Locations GROUP BY Location_Code;"
        ],
        "rule_sql": [
            "SELECT Location_Code, COUNT(*) AS Number_of_Documents FROM Document_Locations GROUP BY Location_Code;"
        ]
    },
    "389": {
        "db_id": "flight_1",
        "question": "Show me the departure date and arrival date for all flights from Los Angeles to Honolulu.",
        "ground_truth": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  \"Los Angeles\" AND destination  =  \"Honolulu\"",
        "amends": [
            "Do reference table `Flight` instead of `flights` in the FROM clause. Do use column `origin` instead of `departure_city` for the departure city filter. Do use column `destination` instead of `arrival_city` for the arrival city filter. Do use double quotes around string literals \"Los Angeles\" and \"Honolulu\" instead of single quotes. The amended query now correctly references the proper table and column names to match the intended flight data schema."
        ],
        "rules": [
            "1) When answering about flights from Los Angeles to Honolulu: use table \"Flight\" as T1. 2) When the question mentions \"departure date\" and \"arrival date\": select columns \"departure_date\" and \"arrival_date\" from T1. 3) When the question mentions \"from Los Angeles\": filter rows where T1.\"origin\" equals \"Los Angeles\". 4) When the question mentions \"to Honolulu\": filter rows where T1.\"destination\" equals \"Honolulu\". 5) When handling text literals: use double quotes around \"Los Angeles\" and \"Honolulu\" exactly as shown."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT departure_date, arrival_date FROM flights WHERE departure_city = 'Los Angeles' AND arrival_city = 'Honolulu'",
            "SELECT departure_date, arrival_date FROM flight WHERE origin = \"Los Angeles\" AND destination = \"Honolulu\""
        ],
        "rule_sql": [
            "SELECT departure_date, arrival_date FROM flight AS T1 WHERE T1.origin = \"Los Angeles\" AND T1.destination = \"Honolulu\""
        ]
    },
    "6615": {
        "db_id": "train_station",
        "question": "Show the station name with greatest number of trains.",
        "ground_truth": "SELECT T2.name FROM train_station AS T1 JOIN station AS T2 ON T1.station_id  =  T2.station_id GROUP BY T1.station_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.name` from the `station` table instead of `station_name` from the `trains` table. Do join `train_station AS T1` with `station AS T2` on `T1.station_id = T2.station_id` instead of querying only the `trains` table. Do group by `T1.station_id` instead of `station_name`. The amended query now correctly retrieves station names by joining the appropriate tables and grouping by station identifier, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"station name with greatest number of trains\": make sure the output order: T2.name 2) When the question mentions \"station name\": \"station name\" actually means \"T2.name in schema\" 3) When combining T1 (train_station) and T2 (station) for shared entities: link rows where T1.station_id = T2.station_id exactly as shown in the amends; keep only matching pairs (inner match) 4) When the question asks for \"count of trains per station\": compute the number of rows using the canonical key token T1.station_id for grouping 5) When the question mentions \"greatest number\" or \"top\": rank rows by count of trains in descending direction and keep the first 1 row"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT station_name FROM trains GROUP BY station_name ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T2.Name\nFROM train_station AS T1\nJOIN station AS T2 ON T1.Station_ID = T2.Station_ID\nGROUP BY T1.Station_ID\nORDER BY COUNT(T1.Train_ID) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.Name\nFROM train_station T1\nJOIN station T2 ON T1.Station_ID = T2.Station_ID\nGROUP BY T1.Station_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "2862": {
        "db_id": "icfp_1",
        "question": "How many papers are published in total?",
        "ground_truth": "SELECT count(*) FROM papers",
        "amends": [
            "Do select from `papers` table instead of `authors` table. Do count rows from the correct table instead of counting from the wrong table. The amended query now correctly counts records from the papers table as intended."
        ],
        "rules": [
            "1) When answering about \"how many papers are published in total\": make sure to select from the \"papers\" table instead of the \"authors\" table. 2) When counting papers: count rows from the \"papers\" table using the canonical key for papers instead of counting from the wrong table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM authors;",
            "SELECT COUNT(*) FROM Papers;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Papers;"
        ]
    },
    "1681": {
        "db_id": "theme_gallery",
        "question": "Show all artist names who didn't have an exhibition in 2004.",
        "ground_truth": "SELECT name FROM artist EXCEPT SELECT T2.name FROM exhibition AS T1 JOIN artist AS T2 ON T1.artist_id  =  T2.artist_id WHERE T1.year  =  2004",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` subquery for better null handling and performance. Do reference the main table as `artist` instead of `artists` and the joined table as `exhibition` instead of `exhibitions`. Do add explicit table aliases `T1` for `exhibition` and `T2` for `artist` instead of omitting them. Do use `JOIN` with `ON T1.artist_id = T2.artist_id` instead of the correlated subquery approach. Do move the year filter `T1.year = 2004` to the second query's `WHERE` clause instead of keeping it in the subquery. The amended query now correctly handles potential null values in artist_id and matches the RIGHT_SQL's behavior using set operations."
        ],
        "rules": [
            "1) When answering about \"artists who didn't have an exhibition in 2004\": use EXCEPT set operation instead of NOT IN subquery for better null handling and performance. 2) When referencing the main table: use \"artist\" instead of \"artists\" and use alias T2 for this table. 3) When referencing the joined table: use \"exhibition\" instead of \"exhibitions\" and use alias T1 for this table. 4) When combining T1 and T2 for shared entities: link rows where T1.artist_id = T2.artist_id using an inner join. 5) When filtering for exhibitions in 2004: apply the condition T1.year = 2004 in the WHERE clause of the second query. 6) When selecting artist names: output the name column from T2 (the artist table)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM artists WHERE artist_id NOT IN (SELECT artist_id FROM exhibitions WHERE year = 2004);",
            "SELECT T2.Name\nFROM artist T2\nEXCEPT\nSELECT T2.Name\nFROM exhibition T1\nJOIN artist T2 ON T1.Artist_ID = T2.Artist_ID\nWHERE T1.Year = 2004"
        ],
        "rule_sql": [
            "SELECT T2.Name FROM artist T2\nEXCEPT\nSELECT T2.Name FROM artist T2\nINNER JOIN exhibition T1 ON T1.Artist_ID = T2.Artist_ID\nWHERE T1.Year = 2004"
        ]
    },
    "3305": {
        "db_id": "college_1",
        "question": "Find the name, address, number of students in the departments that have the top 3 highest number of students.",
        "ground_truth": "SELECT T2.dept_name ,  T2.dept_address ,  count(*) FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT 3",
        "amends": [
            "Do select `dept_name` and `dept_address` instead of `name` and `address`. Do join `student` with `department` on `dept_code` instead of querying `departments` alone. Do count all rows with `count(*)` instead of counting `student_id`. Do group by `dept_code` instead of `department_id`. Do order by `count(*)` instead of `num_students` alias. The amended query now correctly joins student and department tables to count students per department and matches the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"name\" and \"address\" of departments: use the exact column tokens \"dept_name\" and \"dept_address\" instead of generic \"name\" and \"address\". 2) When counting students in departments: join the \"student\" table with the \"department\" table using the exact key equality \"dept_code\" between both tables. 3) When counting the number of students per department: use \"count(*)\" to count all rows rather than counting a specific column like \"student_id\". 4) When grouping by department: use the exact grouping key \"dept_code\" instead of \"department_id\". 5) When ordering by the number of students: order by the exact aggregate expression \"count(*)\" instead of using an alias like \"num_students\". 6) When finding the top 3 departments by student count: rank departments by \"count(*)\" in descending order and keep the first 3 rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, address, COUNT(student_id) as num_students \nFROM departments \nGROUP BY department_id \nORDER BY num_students DESC \nLIMIT 3;",
            "SELECT d.DEPT_NAME, d.DEPT_ADDRESS, COUNT(*) AS num_students\nFROM DEPARTMENT d\nJOIN STUDENT s ON d.DEPT_CODE = s.DEPT_CODE\nGROUP BY d.DEPT_CODE\nORDER BY COUNT(*) DESC\nLIMIT 3;"
        ],
        "rule_sql": [
            "SELECT d.dept_name, d.dept_address, COUNT(*) \nFROM DEPARTMENT d\nJOIN STUDENT s ON d.DEPT_CODE = s.DEPT_CODE\nGROUP BY d.DEPT_CODE\nORDER BY COUNT(*) DESC\nLIMIT 3"
        ]
    },
    "3643": {
        "db_id": "baseball_1",
        "question": "What are the manager's first name, last name and id who won the most manager award?",
        "ground_truth": "SELECT T1.name_first ,  T1.name_last ,  T2.player_id FROM player AS T1 JOIN manager_award AS T2 ON T1.player_id  =  T2.player_id GROUP BY T2.player_id ORDER BY count(*) DESC LIMIT 1;",
        "amends": [
            "Do select `name_first`, `name_last`, and `player_id` instead of `first_name`, `last_name`, and `manager_id`. Do join `player` table as `T1` instead of `managers` table. Do join `manager_award` table as `T2` instead of `manager_awards` table. Do use join condition `T1.player_id = T2.player_id` instead of `managers.id = manager_awards.manager_id`. Do group by `T2.player_id` instead of `manager_id`. Do order by `count(*)` instead of `award_count` alias. The amended query now correctly retrieves player information with award counts from the appropriate tables using the correct join relationships and grouping.",
            "Do reference columns as `T1.name_first` and `T1.name_last` instead of `p.name_first` and `p.name_last`. Do select `T2.player_id` instead of `p.player_id` in the SELECT list. Do use table aliases `T1` and `T2` instead of `p` and `ma`. Do group by `T2.player_id` instead of `p.player_id`. Do order by `count(*)` instead of `award_count` alias. The amended query now correctly references the manager_award table's player_id for grouping and ordering while maintaining the same logical behavior."
        ],
        "rules": [
            "1) When answering about \"manager's first name, last name and id who won the most manager award\": make sure the output order: name_first, name_last, player_id. 2) When the question mentions \"first name\": \"first name\" actually means \"name_first in schema\". 3) When the question mentions \"last name\": \"last name\" actually means \"name_last in schema\". 4) When the question mentions \"id\": \"id\" actually means \"player_id in schema\". 5) When combining T1 (player) and T2 (manager_award) for shared entities: link rows where T1.player_id = T2.player_id; keep only matching pairs (inner match). 6) When the question asks for \"count of manager awards\": compute the number of rows using the canonical key T2.player_id. 7) When the question asks for \"most manager award\": rank rows by count(*) in descending direction and keep the first 1 row.",
            "1) When answering about \"manager's first name, last name and id who won the most manager award\": make sure the output order: name_first, name_last, player_id. 2) When the question mentions \"manager's first name\": \"first name\" actually means \"name_first in schema\". 3) When the question mentions \"manager's last name\": \"last name\" actually means \"name_last in schema\". 4) When the question mentions \"manager's id\": \"id\" actually means \"player_id in schema\". 5) When the question asks for \"most manager award\": rank rows by count of awards in descending order and keep the first 1 row. 6) When counting manager awards: compute the number of rows using the canonical key T2.player_id. 7) When combining T1 and T2 for shared entities: link rows where T1.player_id = T2.player_id; keep only matching pairs (inner match). 8) When grouping by manager: organize results by T2.player_id and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name, manager_id, COUNT(*) as award_count \nFROM managers \nJOIN manager_awards ON managers.id = manager_awards.manager_id \nGROUP BY manager_id \nORDER BY award_count DESC \nLIMIT 1;",
            "SELECT p.name_first, p.name_last, p.player_id, COUNT(*) as award_count\nFROM player p\nJOIN manager_award ma ON p.player_id = ma.player_id\nGROUP BY p.player_id\nORDER BY award_count DESC\nLIMIT 1;",
            "SELECT T1.name_first, T1.name_last, T2.player_id\nFROM player T1\nJOIN manager_award T2 ON T1.player_id = T2.player_id\nGROUP BY T2.player_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT p.name_first, p.name_last, p.player_id\nFROM player p\nJOIN manager_award ma ON p.player_id = ma.player_id\nGROUP BY p.player_id\nORDER BY COUNT(ma.player_id) DESC\nLIMIT 1;"
        ]
    },
    "5441": {
        "db_id": "shop_membership",
        "question": "What are the names of the branches that have some members with a hometown in Louisville, Kentucky and also those from Hiram, Goergia?",
        "ground_truth": "SELECT T2.name FROM membership_register_branch AS T1 JOIN branch AS T2 ON T1.branch_id  =  T2.branch_id JOIN member AS T3 ON T1.member_id  =  T3.member_id WHERE T3.Hometown  =  'Louisville ,  Kentucky' INTERSECT SELECT T2.name FROM membership_register_branch AS T1 JOIN branch AS T2 ON T1.branch_id  =  T2.branch_id JOIN member AS T3 ON T1.member_id  =  T3.member_id WHERE T3.Hometown  =  'Hiram ,  Georgia'",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `b` and `m`. Do reference correct table names `membership_register_branch`, `branch`, and `member` instead of `branches` and `members`. Do use proper join conditions `T1.branch_id = T2.branch_id` and `T1.member_id = T3.member_id` instead of `b.id = m.branch_id`. Do use `INTERSECT` with separate queries for each hometown instead of `OR` conditions in a single query. Do reference correct column names `branch_id`, `member_id`, and `Hometown` instead of `id` and `hometown`. Do include proper spacing in location values 'Louisville , Kentucky' and 'Hiram , Georgia' instead of compact formatting. Do remove `DISTINCT` since `INTERSECT` inherently eliminates duplicates. The amended query now correctly finds branches that have members from both specified hometowns using set intersection logic."
        ],
        "rules": [
            "1) When the question asks for branches with members from multiple specific hometowns: use INTERSECT between separate queries for each hometown instead of OR conditions in a single query. 2) When referencing table names: use exact tokens \"membership_register_branch\", \"branch\", and \"member\" instead of simplified names like \"branches\" or \"members\". 3) When joining tables: use proper join conditions T1.branch_id = T2.branch_id and T1.member_id = T3.member_id with table aliases T1, T2, T3. 4) When handling location values: use exact literals 'Louisville , Kentucky' and 'Hiram , Georgia' with proper spacing instead of compact formatting. 5) When the question asks for branch names that have members from both locations: do not use DISTINCT since INTERSECT inherently eliminates duplicates. 6) When filtering by hometown: use the exact column name \"Hometown\" from the member table with proper case sensitivity."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT b.name \nFROM branches b \nJOIN members m ON b.id = m.branch_id \nWHERE m.hometown = 'Louisville, Kentucky' \nOR m.hometown = 'Hiram, Georgia';",
            "SELECT T2.Name \nFROM membership_register_branch T1\nJOIN branch T2 ON T1.Branch_ID = T2.Branch_ID\nJOIN member T3 ON T1.Member_ID = T3.Member_ID\nWHERE T3.Hometown = 'Louisville , Kentucky'\nINTERSECT\nSELECT T2.Name \nFROM membership_register_branch T1\nJOIN branch T2 ON T1.Branch_ID = T2.Branch_ID\nJOIN member T3 ON T1.Member_ID = T3.Member_ID\nWHERE T3.Hometown = 'Hiram , Georgia'"
        ],
        "rule_sql": [
            "SELECT T2.Name\nFROM membership_register_branch T1\nJOIN branch T2 ON T1.Branch_ID = T2.Branch_ID\nJOIN member T3 ON T1.Member_ID = T3.Member_ID\nWHERE T3.Hometown = 'Louisville , Kentucky'\nINTERSECT\nSELECT T2.Name\nFROM membership_register_branch T1\nJOIN branch T2 ON T1.Branch_ID = T2.Branch_ID\nJOIN member T3 ON T1.Member_ID = T3.Member_ID\nWHERE T3.Hometown = 'Hiram , Georgia'"
        ]
    },
    "5737": {
        "db_id": "dorm_1",
        "question": "What is the average age for each dorm and what are the names of each dorm?",
        "ground_truth": "SELECT avg(T1.age) ,  T3.dorm_name FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid GROUP BY T3.dorm_name",
        "amends": [
            "Do specify `avg(T1.age)` with explicit table alias instead of `AVG(age)` without table qualification. Do add `T3.dorm_name` in SELECT list instead of `dorm_name` without table reference. Do change FROM clause to use explicit joins with `student AS T1 JOIN lives_in AS T2 ON T1.stuid = T2.stuid JOIN dorm AS T3 ON T3.dormid = T2.dormid` instead of single table `students`. Do correct GROUP BY to use `T3.dorm_name` instead of `dorm_id` to match the selected column. The amended query now properly joins the student, lives_in, and dorm tables to calculate average age by dorm name rather than attempting to group by a non-existent dorm_id column in the students table.",
            "Do place `T3.dorm_name` after the aggregate function instead of listing it first in the SELECT clause. Do use lowercase `avg` instead of uppercase `AVG` for the aggregate function. Do use lowercase `age` instead of uppercase `Age` for the column reference. Do remove the alias `average_age` instead of keeping it. The amended query now correctly calculates average student age by dormitory without unnecessary aliasing."
        ],
        "rules": [
            "1) When answering about \"average age for each dorm\": make sure the output order: T3.dorm_name, avg(T1.age) 2) When the question mentions \"dorm names\": \"dorm names\" actually means \"T3.dorm_name in schema\" 3) When the question asks for \"average age\": compute the average of T1.Age values 4) When the question says \"per dorm\"/\"by dorm\": organize results by T3.dorm_name and compute average age per group 5) When combining T1, T2, and T3 for shared entities: link rows where T1.stuid = T2.stuid and T3.dormid = T2.dormid; keep only matching pairs (inner match) 6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms 7) When handling text literals: do not change case, spacing, or punctuation 8) When referring to table roles: do not rename or swap the aliases T1 (Student), T2 (lives_in), T3 (dorm) once set for this schema",
            "1) When the question asks for average age per dorm: compute the average of the \"age\" column from table \"Student\" (aliased as T1) for each dorm group. 2) When the question asks for dorm names: include the \"dorm_name\" column from table \"Dorm\" (aliased as T3) in the output. 3) When organizing results by dorm: group the results by \"T3.dorm_name\" to get statistics per dormitory. 4) When presenting results: list the aggregate function result first followed by the dorm name in the output columns. 5) When using aggregate functions: use lowercase \"avg\" instead of uppercase \"AVG\" for the average function. 6) When referencing column names: use lowercase \"age\" instead of uppercase \"Age\" for the age column reference. 7) When calculating averages: do not assign aliases to the aggregate results unless explicitly required."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT dorm_name, AVG(age) FROM students GROUP BY dorm_id;",
            "SELECT T3.dorm_name, AVG(T1.Age) as average_age\nFROM Student AS T1\nJOIN Lives_in AS T2 ON T1.StuID = T2.stuid\nJOIN Dorm AS T3 ON T3.dormid = T2.dormid\nGROUP BY T3.dorm_name;",
            "SELECT avg(T1.age), T3.dorm_name FROM student AS T1 JOIN lives_in AS T2 ON T1.StuID = T2.stuid JOIN dorm AS T3 ON T3.dormid = T2.dormid GROUP BY T3.dorm_name"
        ],
        "rule_sql": [
            "SELECT avg(T1.age), T3.dorm_name FROM Student T1 JOIN Lives_in T2 ON T1.StuID = T2.stuid JOIN Dorm T3 ON T2.dormid = T3.dormid GROUP BY T3.dorm_name"
        ]
    },
    "347": {
        "db_id": "flight_1",
        "question": "Show ids for all aircrafts with more than 1000 distance.",
        "ground_truth": "SELECT aid FROM Aircraft WHERE distance  >  1000",
        "amends": [
            "Do reference column `aid` instead of `id` in the SELECT list. Do reference table `Aircraft` instead of `aircrafts` in the FROM clause. The amended query now correctly matches the RIGHT_SQL's behavior with the proper column and table references."
        ],
        "rules": [
            "1) When the question asks for \"ids\" of aircrafts: use the exact column token \"aid\" from the Aircraft table instead of \"id\". 2) When referencing the aircraft table: use the exact table name \"Aircraft\" instead of \"aircrafts\". 3) When filtering aircrafts by distance greater than 1000: use the condition \"distance > 1000\" with the exact literal value 1000."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM aircrafts WHERE distance > 1000",
            "SELECT aid FROM Aircraft WHERE distance > 1000"
        ],
        "rule_sql": [
            "SELECT aid FROM Aircraft WHERE distance > 1000"
        ]
    },
    "6728": {
        "db_id": "activity_1",
        "question": "Count the number of female Professors we have.",
        "ground_truth": "SELECT count(*) FROM Faculty WHERE Sex  =  'F' AND Rank  =  \"Professor\"",
        "amends": [
            "Do reference table `Faculty` instead of `professors` and use column `Sex` with value `'F'` instead of `gender` with value `'male'`. Do add filter condition `Rank = \"Professor\"` instead of omitting it. The amended query now correctly counts female professors from the Faculty table instead of counting all male individuals from the professors table."
        ],
        "rules": [
            "1) When answering about \"female Professors\": make sure the output order: count of female professors. 2) When the question mentions \"female\": \"female\" actually means \"Sex = 'F'\" in schema. 3) When the question mentions \"Professors\": \"Professors\" actually means \"Rank = 'Professor'\" in schema. 4) When counting professors: use the canonical key from Faculty table to count rows. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for column names like \"Rank\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM professors WHERE gender = 'male';",
            "SELECT COUNT(*) FROM Faculty WHERE Sex = 'F' AND Rank = 'Professor';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Faculty WHERE Sex = 'F' AND Rank = 'Professor';"
        ]
    },
    "499": {
        "db_id": "allergy_1",
        "question": "Show all advisors and corresponding number of students.",
        "ground_truth": "SELECT advisor ,  count(*) FROM Student GROUP BY advisor",
        "amends": [
            "Do reference the table as `Student` instead of `students` and use the column name `advisor` instead of `advisor_name` in both the SELECT list and GROUP BY clause, while maintaining the same aggregate function `count(*)` to preserve the intended behavior of counting students per advisor, resulting in a query that now correctly matches the structure and semantics of the target SQL."
        ],
        "rules": [
            "1) When the question asks for advisors and number of students: use the exact table name \"Student\" instead of \"students\". 2) When referring to advisor information: use the exact column name \"advisor\" instead of \"advisor_name\" in both the output columns and grouping clause. 3) When counting students per advisor: maintain the count(*) aggregate function to count all students associated with each advisor."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT advisor_name, COUNT(*) FROM students GROUP BY advisor_name;",
            "SELECT Advisor, COUNT(*) FROM Student GROUP BY Advisor;"
        ],
        "rule_sql": [
            "SELECT advisor, COUNT(*) FROM Student GROUP BY advisor;"
        ]
    },
    "3376": {
        "db_id": "sports_competition",
        "question": "What is the total number of points for all players?",
        "ground_truth": "SELECT sum(Points) FROM player",
        "amends": [
            "Do use the column name `Points` instead of `goals` in the SELECT clause. Do reference the table name `player` instead of `players` in the FROM clause. The amended query now correctly calculates the sum of points from the player table as intended."
        ],
        "rules": [
            "1) When answering about \"total number of points for all players\": use the exact column name \"Points\" from the player table. 2) When the question mentions \"players\": the correct table name is \"player\" (not \"players\"). 3) When computing the total sum: calculate the sum of all values in the \"Points\" column from the player table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(goals) FROM players;",
            "SELECT SUM(Points) AS total_points FROM player;"
        ],
        "rule_sql": [
            "SELECT SUM(Points) AS total_points FROM player;"
        ]
    },
    "1455": {
        "db_id": "college_2",
        "question": "How many students and instructors are in each department?",
        "ground_truth": "SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name",
        "amends": [
            "Do use `count(DISTINCT T2.id)` and `count(DISTINCT T3.id)` instead of `COUNT(*) as total_people` to count distinct IDs rather than all rows. Do join `department AS T1` with `student AS T2` on `T1.dept_name = T2.dept_name` instead of querying only the `students` table. Do add a second join to `instructor AS T3` on `T1.dept_name = T3.dept_name` instead of omitting instructor data. Do group by `T3.dept_name` instead of `department` to align with the joined table structure. The amended query now correctly counts distinct students and instructors per department while joining the necessary tables, matching the RIGHT_SQL's behavior.",
            "Do use `INNER JOIN` for both `student` and `instructor` tables instead of `LEFT JOIN` to exclude departments without matching records. Do select `T3.dept_name` instead of `T1.dept_name` for grouping consistency with the joined tables. Do remove the alias `dept_name` from the department table selection since it's not needed in the output. Do change the column order to place aggregate functions first followed by the grouping column instead of leading with the department name. The amended query now correctly counts distinct students and instructors per department while ensuring only departments with both student and instructor records are included."
        ],
        "rules": [
            "1) When counting students and instructors per department: use count(DISTINCT T2.id) for students and count(DISTINCT T3.id) for instructors instead of counting all rows. 2) When combining department information with student data: join department AS T1 with student AS T2 on T1.dept_name = T2.dept_name using an inner match. 3) When combining department information with instructor data: join department AS T1 with instructor AS T3 on T1.dept_name = T3.dept_name using an inner match. 4) When grouping results by department: use T3.dept_name as the grouping key to align with the joined table structure.",
            "1) When combining department table with student and instructor tables: use inner joins instead of left joins to exclude departments without matching records in both student and instructor tables. 2) When selecting the department name for grouping: use T3.dept_name instead of T1.dept_name for consistency with the joined tables. 3) When organizing output columns: place aggregate functions (student_count and instructor_count) first followed by the grouping column (dept_name) instead of leading with the department name. 4) When counting distinct students and instructors: count distinct T2.ID for students and distinct T3.ID for instructors using their respective ID columns. 5) When grouping results by department: group by dept_name to show counts per department."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department, COUNT(*) as total_people FROM students GROUP BY department",
            "SELECT \n    T1.dept_name,\n    COUNT(DISTINCT T2.ID) AS student_count,\n    COUNT(DISTINCT T3.ID) AS instructor_count\nFROM \n    department AS T1\nLEFT JOIN \n    student AS T2 ON T1.dept_name = T2.dept_name\nLEFT JOIN \n    instructor AS T3 ON T1.dept_name = T3.dept_name\nGROUP BY \n    T1.dept_name",
            "SELECT \n    COUNT(DISTINCT T2.ID) AS student_count,\n    COUNT(DISTINCT T3.ID) AS instructor_count,\n    T1.dept_name\nFROM \n    department AS T1\nINNER JOIN \n    student AS T2 ON T1.dept_name = T2.dept_name\nINNER JOIN \n    instructor AS T3 ON T1.dept_name = T3.dept_name\nGROUP BY \n    T1.dept_name"
        ],
        "rule_sql": [
            "SELECT \n    COUNT(DISTINCT T2.ID) AS student_count,\n    COUNT(DISTINCT T3.ID) AS instructor_count,\n    T3.dept_name\nFROM \n    department AS T1\nINNER JOIN \n    student AS T2 ON T1.dept_name = T2.dept_name\nINNER JOIN \n    instructor AS T3 ON T1.dept_name = T3.dept_name\nGROUP BY \n    T3.dept_name"
        ]
    },
    "4179": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "Find the document type name of the document named \"How to read a book\".",
        "ground_truth": "SELECT T2.document_type_name FROM All_documents AS T1 JOIN Ref_document_types AS T2 ON T1.document_type_code  =  T2.document_type_code WHERE T1.document_name  =  \"How to read a book\"",
        "amends": [
            "Do select `T2.document_type_name` instead of `document_name`. Do use `FROM All_documents AS T1 JOIN Ref_document_types AS T2` instead of `FROM documents`. Do add join condition `ON T1.document_type_code = T2.document_type_code` instead of omitting it. Do change filter to `WHERE T1.document_name = \"How to read a book\"` instead of `WHERE document_type = 'How to read a book'`. The amended query now correctly retrieves the document type name by joining the document tables and filtering on the document name rather than incorrectly filtering on the document type column."
        ],
        "rules": [
            "1) When the question asks for \"document type name\": select \"T2.document_type_name\" instead of \"document_name\". 2) When combining document information from multiple tables: use \"FROM All_documents AS T1 JOIN Ref_document_types AS T2\" with join condition \"ON T1.document_type_code = T2.document_type_code\" to link related records. 3) When filtering for a specific document name: use \"WHERE T1.document_name = \\\"How to read a book\\\"\" with exact case and punctuation as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_name FROM documents WHERE document_type = 'How to read a book';",
            "SELECT T2.Document_Type_Name\nFROM All_Documents AS T1\nJOIN Ref_Document_Types AS T2 ON T1.Document_Type_Code = T2.Document_Type_Code\nWHERE T1.Document_Name = 'How to read a book'"
        ],
        "rule_sql": [
            "SELECT T2.Document_Type_Name \nFROM All_Documents AS T1 \nJOIN Ref_Document_Types AS T2 ON T1.Document_Type_Code = T2.Document_Type_Code \nWHERE T1.Document_Name = \"How to read a book\""
        ]
    },
    "6354": {
        "db_id": "school_bus",
        "question": "Show the party with drivers from Hartford and drivers older than 40.",
        "ground_truth": "SELECT party FROM driver WHERE home_city  =  'Hartford' AND age  >  40",
        "amends": [
            "Do reference table `driver` instead of `parties` and select column `party` instead of `party_name`. Do use filter conditions `home_city = 'Hartford'` instead of `driver_city = 'Hartford'` and `age > 40` instead of `driver_age > 40`. The amended query now correctly retrieves drivers from Hartford over age 40 from the appropriate table with the correct column names and filter conditions."
        ],
        "rules": [
            "1) When answering about \"drivers from Hartford and drivers older than 40\": reference table \"driver\" instead of \"parties\". 2) When selecting the party information: select column \"party\" instead of \"party_name\". 3) When filtering for drivers from Hartford: use condition \"home_city = 'Hartford'\" instead of \"driver_city = 'Hartford'\". 4) When filtering for drivers older than 40: use condition \"age > 40\" instead of \"driver_age > 40\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT party_name FROM parties WHERE driver_city = 'Hartford' AND driver_age > 40;",
            "SELECT Party FROM driver WHERE Home_city = 'Hartford' AND Age > 40;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Party FROM driver WHERE Home_city = 'Hartford' AND Age > 40;"
        ]
    },
    "4504": {
        "db_id": "document_management",
        "question": "What are the codes of types of documents of which there are for or more?",
        "ground_truth": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4",
        "amends": [
            "Do reference `document_type_code` in both the SELECT list and GROUP BY clause instead of `type_code`. Do use the greater than operator `>` for the count comparison instead of greater than or equal to `>=`. The amended query now correctly identifies document types with more than 4 occurrences rather than 4 or more, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"codes of types of documents\": use the exact column token \"document_type_code\" from the Documents table. 2) When counting occurrences of document types: count using the canonical key \"document_type_code\" and use the greater than operator > for the threshold comparison. 3) When the question specifies \"four or more\": this actually means more than 4 (not 4 or more), so use the condition > 4."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type_code FROM documents GROUP BY type_code HAVING COUNT(*) >= 4",
            "SELECT document_type_code FROM Documents GROUP BY document_type_code HAVING COUNT(*) > 4"
        ],
        "rule_sql": [
            "SELECT document_type_code FROM Documents GROUP BY document_type_code HAVING COUNT(document_type_code) > 4"
        ]
    },
    "5270": {
        "db_id": "music_2",
        "question": "Find the number of songs in all the studio albums.",
        "ground_truth": "SELECT count(DISTINCT T3.title) FROM albums AS T1 JOIN tracklists AS T2 ON T1.aid  =  T2.albumid JOIN songs AS T3 ON T2.songid  =  T3.songid WHERE t1.type  =  \"Studio\"",
        "amends": [
            "Do count `DISTINCT T3.title` instead of `COUNT(*)` to count unique song titles rather than all rows. Do join `albums AS T1` with `tracklists AS T2` on `T1.aid = T2.albumid` instead of omitting these tables, and then join `songs AS T3` on `T2.songid = T3.songid` instead of querying songs directly. Do filter on `t1.type = \"Studio\"` instead of `album_type = 'studio'` to use the correct column name and table reference with proper case sensitivity. The amended query now correctly counts distinct song titles from studio albums by properly joining through the tracklists relationship table."
        ],
        "rules": [
            "1) When counting songs: count distinct T3.title instead of all rows to get unique song titles. 2) When combining albums and songs: join albums AS T1 with tracklists AS T2 on T1.aid = T2.albumid, then join songs AS T3 on T2.songid = T3.songid to properly navigate the relationship through tracklists. 3) When filtering for studio albums: use T1.type = \"Studio\" instead of album_type = 'studio' to use the correct column name and table reference with proper case sensitivity."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM songs WHERE album_type = 'studio';",
            "SELECT COUNT(DISTINCT T3.Title) \nFROM Albums AS T1 \nJOIN Tracklists AS T2 ON T1.AId = T2.AlbumId \nJOIN Songs AS T3 ON T2.SongId = T3.SongId \nWHERE T1.Type = 'Studio'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T3.Title) \nFROM Albums AS T1\nJOIN Tracklists AS T2 ON T1.AId = T2.AlbumId\nJOIN Songs AS T3 ON T2.SongId = T3.SongId\nWHERE T1.Type = 'Studio'"
        ]
    },
    "4264": {
        "db_id": "club_1",
        "question": "Find the number of members of club \"Pen and Paper Gaming\".",
        "ground_truth": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Pen and Paper Gaming\"",
        "amends": [
            "Do join `club AS t1`, `member_of_club AS t2`, and `student AS t3` with proper join conditions instead of querying only the `members` table. Do use `JOIN` with `t1.clubid = t2.clubid` and `t2.stuid = t3.stuid` instead of the incorrect single-table approach. Do filter on `t1.clubname = \"Pen and Paper Gaming\"` instead of the non-existent `club_name` column. Do count all joined records instead of counting from a single incorrect table. The amended query now correctly counts students who are members of the specified club by properly joining the club membership relationships."
        ],
        "rules": [
            "1) When the question asks about \"members of club\": join tables club AS T1, member_of_club AS T2, and student AS T3 using T1.clubid = T2.clubid and T2.stuid = T3.stuid to properly represent membership relationships. 2) When filtering for club \"Pen and Paper Gaming\": use T1.clubname = \"Pen and Paper Gaming\" exactly as specified. 3) When counting members: count all joined records from the three-table join to get the correct number of students who are members of the specified club."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM members WHERE club_name = 'Pen and Paper Gaming';",
            "SELECT COUNT(*) \nFROM Club AS t1\nJOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID\nJOIN Student AS t3 ON t2.StuID = t3.StuID\nWHERE t1.ClubName = 'Pen and Paper Gaming'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Club AS T1\nJOIN Member_of_club AS T2 ON T1.ClubID = T2.ClubID\nJOIN Student AS T3 ON T2.StuID = T3.StuID\nWHERE T1.ClubName = \"Pen and Paper Gaming\""
        ]
    },
    "5735": {
        "db_id": "dorm_1",
        "question": "How many students are older than average for each gender?",
        "ground_truth": "SELECT count(*) ,  sex FROM student WHERE age  >  (SELECT avg(age) FROM student) GROUP BY sex",
        "amends": [
            "Do use `sex` instead of `gender` for both the column reference and GROUP BY clause. Do reference table `student` instead of `students` in both the main query and subquery. Do place the `count(*)` column first in the SELECT list instead of second. Do use lowercase `avg(age)` in the subquery instead of uppercase `AVG(age)`. The amended query now correctly counts students by sex where age exceeds the average age from the same table, matching the intended behavior.",
            "Do place `count(*)` before `sex` in the SELECT list instead of after it. Do keep all other elements unchanged including the WHERE filter using the subquery `(SELECT avg(age) FROM student)` and GROUP BY `sex`, as the query logic remains identical with only column ordering adjusted in the output."
        ],
        "rules": [
            "1) When the question mentions \"gender\": use the exact column token \"sex\" instead of \"gender\" for both selection and grouping. 2) When referencing the student table: use the exact table name \"student\" instead of \"students\" in both main query and subquery. 3) When ordering output columns: place the count column first in the output order before the grouping column. 4) When computing average age in subquery: use lowercase \"avg(age)\" instead of uppercase \"AVG(age)\". 5) When counting students by sex where age exceeds average: compute the average age from the same \"student\" table and count students per sex where age is greater than this average value.",
            "1) When the question asks for \"count of students\" per gender: compute the number of rows using the canonical key for students. 2) When the question asks for students \"older than average\": filter rows where age is greater than the average age from all students. 3) When the question asks for results \"for each gender\": organize results by the sex column and compute counts per group. 4) When answering about \"how many students are older than average for each gender\": make sure the output order: count first, then sex."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT gender, COUNT(*) \nFROM students \nWHERE age > (SELECT AVG(age) FROM students) \nGROUP BY gender;",
            "SELECT sex, COUNT(*) \nFROM student \nWHERE age > (SELECT avg(age) FROM student) \nGROUP BY sex",
            "SELECT COUNT(*), Sex FROM Student WHERE Age > (SELECT avg(age) FROM Student) GROUP BY Sex"
        ],
        "rule_sql": [
            "SELECT COUNT(StuID), sex FROM student WHERE age > (SELECT avg(age) FROM student) GROUP BY sex"
        ]
    },
    "6823": {
        "db_id": "flight_4",
        "question": "How many different cities do have some airport in the country of Greenland?",
        "ground_truth": "SELECT count(DISTINCT city) FROM airports WHERE country  =  'Greenland'",
        "amends": [
            "Do `count(DISTINCT city)` instead of `COUNT(*)` to count distinct cities instead of all rows. Do keep the `WHERE country = 'Greenland'` filter unchanged. The amended query now correctly counts unique cities in Greenland rather than total airport records, matching the intended behavior."
        ],
        "rules": [
            "1) When counting different cities: use count(DISTINCT city) instead of COUNT(*) to count unique city values. 2) When filtering for airports in Greenland: keep the condition WHERE country = 'Greenland' unchanged with exact literal 'Greenland'. 3) When answering about how many different cities have airports in Greenland: ensure the output counts distinct city values from airports located in Greenland."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM airports WHERE country = 'Greenland';",
            "SELECT COUNT(DISTINCT city) FROM airports WHERE country = 'Greenland';"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT city) FROM airports WHERE country = 'Greenland';"
        ]
    },
    "5336": {
        "db_id": "manufactory_1",
        "question": "Select the name and price of all products with a price larger than or equal to $180, and sort first by price (in descending order), and then by name  (in ascending order).",
        "ground_truth": "SELECT name ,  price FROM products WHERE price  >=  180 ORDER BY price DESC ,  name ASC",
        "amends": [
            "Do use `>=` in the WHERE filter instead of `>` to include products priced exactly at 180 instead of excluding them. Do change the ORDER BY to `price DESC` instead of `price ASC` to sort prices in descending order instead of ascending. Do change the ORDER BY to `name ASC` instead of `name DESC` to sort names in ascending order instead of descending. The amended query now correctly includes the boundary price value and produces the intended descending price and ascending name sorting as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When filtering for products with price larger than or equal to $180: use price >= 180 instead of price > 180 to include products priced exactly at 180. 2) When sorting by price in descending order: use price DESC instead of price ASC. 3) When sorting by name in ascending order: use name ASC instead of name DESC."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, price FROM products WHERE price > 180 ORDER BY price ASC, name DESC",
            "SELECT Name, Price FROM Products WHERE Price >= 180 ORDER BY Price DESC, Name ASC;"
        ],
        "rule_sql": [
            "SELECT Name, Price FROM Products WHERE Price >= 180 ORDER BY Price DESC, Name ASC"
        ]
    },
    "5028": {
        "db_id": "soccer_2",
        "question": "Find the names of states that have some college students playing in goalie and mid positions.",
        "ground_truth": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'",
        "amends": [
            "Do use `INTERSECT` between two separate queries instead of a single query with `IN` filter. Do change the source tables to `college AS T1` and `tryout AS T2` instead of `states` and `players`. Do use `JOIN` on `T1.cName = T2.cName` instead of `JOIN` on `s.id = p.state_id`. Do filter with `T2.pPos = 'goalie'` in the first query and `T2.pPos = 'mid'` in the second query instead of `p.position IN ('goalie', 'mid')`. Do remove `DISTINCT` and `p.college IS NOT NULL` filter instead of keeping them. Do select `T1.state` instead of `s.name`. The amended query now correctly finds states that have both goalie and mid positions using set intersection instead of a single filter approach."
        ],
        "rules": [
            "1) When answering about states with college students in specific positions: use tables \"college\" as T1 and \"tryout\" as T2 instead of states and players tables. 2) When combining T1 and T2: link rows where T1.cName = T2.cName exactly and keep only matching pairs (inner match). 3) When the question asks for states with both goalie and mid positions: use INTERSECT between two separate queries instead of a single query with IN filter. 4) When filtering for goalie position: use T2.pPos = 'goalie' exactly as specified. 5) When filtering for mid position: use T2.pPos = 'mid' exactly as specified. 6) When selecting state information: select T1.state instead of other state identifiers. 7) When the question asks for states that have both positions: do not use DISTINCT or additional filters like college IS NOT NULL."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT s.name \nFROM states s \nJOIN players p ON s.id = p.state_id \nWHERE p.position IN ('goalie', 'mid') \nAND p.college IS NOT NULL",
            "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName = T2.cName WHERE T2.pPos = 'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName = T2.cName WHERE T2.pPos = 'mid'"
        ],
        "rule_sql": [
            "SELECT T1.state FROM College AS T1 JOIN Tryout AS T2 ON T1.cName = T2.cName WHERE T2.pPos = 'goalie' INTERSECT SELECT T1.state FROM College AS T1 JOIN Tryout AS T2 ON T1.cName = T2.cName WHERE T2.pPos = 'mid'"
        ]
    },
    "4088": {
        "db_id": "student_1",
        "question": "For each grade 0 classroom, report the total number of students.",
        "ground_truth": "SELECT classroom ,  count(*) FROM list WHERE grade  =  \"0\" GROUP BY classroom",
        "amends": [
            "Do reference table `list` instead of `students` in the FROM clause. Do use string literal `\"0\"` instead of numeric `0` for the grade filter in the WHERE condition. Do maintain the same SELECT list with `classroom` and `COUNT(*)` aggregation, and preserve the GROUP BY `classroom` clause. The amended query now correctly filters for grade as a string value and references the appropriate table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"grade 0 classroom\" and \"total number of students\": make sure the output order: classroom, count of students. 2) When the question mentions \"grade 0\": \"grade 0\" actually means \"grade = \\\"0\\\"\" in schema (using string literal). 3) When counting students: compute the number of rows using the canonical key from the list table. 4) When the question says \"per classroom\"/\"by classroom\": organize results by classroom and compute requested aggregates per group. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 6) When handling text literals: do not change case, spacing, or punctuation - use exact string literal \\\"0\\\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT classroom, COUNT(*) FROM students WHERE grade = 0 GROUP BY classroom;",
            "SELECT classroom, COUNT(*) FROM list WHERE Grade = \"0\" GROUP BY classroom"
        ],
        "rule_sql": [
            "SELECT \"Classroom\", COUNT(*) AS \"count of students\" FROM \"list\" WHERE \"Grade\" = \"0\" GROUP BY \"Classroom\" ORDER BY \"Classroom\""
        ]
    },
    "4233": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "What are the name and code of the location with the smallest number of documents?",
        "ground_truth": "SELECT T2.location_name ,  T1.location_code FROM Document_locations AS T1 JOIN Ref_locations AS T2 ON T1.location_code  =  T2.location_code GROUP BY T1.location_code ORDER BY count(*) ASC LIMIT 1",
        "amends": [
            "Do select `T2.location_name` and `T1.location_code` instead of `name` and `code`. Do use `FROM Document_locations AS T1 JOIN Ref_locations AS T2` instead of `FROM locations`. Do add join condition `ON T1.location_code = T2.location_code` instead of omitting it. Do add `GROUP BY T1.location_code` instead of omitting grouping. Do use `ORDER BY count(*) ASC` instead of `ORDER BY COUNT(documents) ASC`. The amended query now correctly joins the document and reference location tables, groups by location code, and counts documents per location to find the location with the fewest documents."
        ],
        "rules": [
            "1) When answering about \"name and code of the location with the smallest number of documents\": select T2.location_name and T1.location_code as output columns. 2) When combining Document_locations and Ref_locations tables: link rows where T1.location_code = T2.location_code and keep only matching pairs (inner match). 3) When counting documents per location: group by T1.location_code and count the number of rows using count(*). 4) When finding the location with the smallest number of documents: order the results by count(*) in ascending order and keep only the first row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, code FROM locations ORDER BY COUNT(documents) ASC LIMIT 1;",
            "SELECT T2.Location_Name, T1.Location_Code\nFROM Document_Locations AS T1\nJOIN Ref_Locations AS T2 ON T1.Location_Code = T2.Location_Code\nGROUP BY T1.Location_Code\nORDER BY COUNT(*) ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.Location_Name, T1.Location_Code\nFROM Document_Locations T1\nINNER JOIN Ref_Locations T2 ON T1.Location_Code = T2.Location_Code\nGROUP BY T1.Location_Code\nORDER BY COUNT(*) ASC\nLIMIT 1;"
        ]
    },
    "1584": {
        "db_id": "customers_and_invoices",
        "question": "Return the average, minimum, maximum, and total transaction amounts.",
        "ground_truth": "SELECT avg(transaction_amount) ,  min(transaction_amount) ,  max(transaction_amount) ,   sum(transaction_amount) FROM Financial_transactions",
        "amends": [
            "Do reference the `transaction_amount` column instead of `amount` to match the correct column name in the Financial_transactions table. Do use the table name `Financial_transactions` instead of `transactions` to query from the correct data source. The amended query now correctly calculates aggregates on the proper column from the intended table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about transaction amounts: use the exact column name \"transaction_amount\" from the Financial_transactions table. 2) When calculating aggregates on transaction amounts: compute the average, minimum, maximum, and sum of the \"transaction_amount\" column. 3) When querying from the financial transactions data source: use the exact table name \"Financial_transactions\" instead of any other table name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(amount), MIN(amount), MAX(amount), SUM(amount) FROM transactions",
            "SELECT \n    AVG(transaction_amount) AS average_amount,\n    MIN(transaction_amount) AS minimum_amount,\n    MAX(transaction_amount) AS maximum_amount,\n    SUM(transaction_amount) AS total_amount\nFROM Financial_Transactions;"
        ],
        "rule_sql": [
            "SELECT AVG(transaction_amount) AS average_amount, MIN(transaction_amount) AS minimum_amount, MAX(transaction_amount) AS maximum_amount, SUM(transaction_amount) AS total_amount FROM Financial_Transactions;"
        ]
    },
    "5197": {
        "db_id": "music_2",
        "question": "What is the last name of the musician who was in the most songs?",
        "ground_truth": "SELECT T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId GROUP BY lastname ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `Performance` with `Band` on `bandmate=id` and join `Songs` on `SongId=SongId` instead of querying only `musicians`. Do select `lastname` from `Band` instead of `last_name` from `musicians`. Do group by `lastname` instead of ordering by an aggregate without grouping. Do order by `count(*)` instead of `COUNT(song_id)`. The amended query now correctly identifies the musician with the most performances by joining the necessary tables and using proper aggregation."
        ],
        "rules": [
            "1) When answering about \"the last name of the musician who was in the most songs\": make sure the output order: lastname from Band. 2) When the question mentions \"musician\": \"musician\" actually means \"Band\" in schema. 3) When combining Performance and Band for shared entities: link rows where Performance.bandmate = Band.id exactly as shown in the amends; keep only matching pairs (inner match). 4) When combining Performance and Songs for shared entities: link rows where Performance.SongId = Songs.SongId exactly as shown in the amends; keep only matching pairs (inner match). 5) When the question asks for \"count of songs per musician\": organize results by lastname from Band and compute count(*) per group. 6) When the question asks for \"the most songs\": rank rows by count(*) in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM musicians ORDER BY COUNT(song_id) DESC LIMIT 1;",
            "SELECT b.Lastname\nFROM Performance p\nJOIN Band b ON p.Bandmate = b.Id\nGROUP BY b.Lastname\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT b.Lastname\nFROM Band b\nJOIN Performance p ON b.Id = p.Bandmate\nGROUP BY b.Id, b.Lastname\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "6191": {
        "db_id": "music_4",
        "question": "Show the famous titles of the artists with both volumes that lasted more than 2 weeks on top and volumes that lasted less than 2 weeks on top.",
        "ground_truth": "SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  >  2 INTERSECT SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  <  2",
        "amends": [
            "Do use `INTERSECT` to combine results from two separate queries instead of a single query with contradictory `WHERE` conditions. Do remove the `DISTINCT` modifier since `INTERSECT` inherently returns distinct values instead of keeping it. Do change the table aliases from `a` and `v` to `T1` and `T2` instead of the original aliases. Do split the contradictory condition `v.weeks_on_top > 2 AND v.weeks_on_top < 2` into separate queries with `T2.Weeks_on_Top > 2` and `T2.Weeks_on_Top < 2` instead of the impossible combined filter. Do use table names `artist` and `volume` instead of `artists` and `volumes`. The amended query now correctly finds artists with both weeks greater than 2 and less than 2 by using set intersection logic instead of the impossible single condition."
        ],
        "rules": [
            "1) When the question asks for artists with both conditions (volumes lasting more than 2 weeks and less than 2 weeks): use INTERSECT to combine results from two separate queries instead of a single query with contradictory conditions. 2) When using INTERSECT: remove the DISTINCT modifier since INTERSECT inherently returns distinct values. 3) When referring to tables: use table names \"artist\" and \"volume\" instead of \"artists\" and \"volumes\". 4) When using table aliases: use T1 for the artist table and T2 for the volume table. 5) When filtering for volumes lasting more than 2 weeks: use condition T2.Weeks_on_Top > 2. 6) When filtering for volumes lasting less than 2 weeks: use condition T2.Weeks_on_Top < 2. 7) When joining tables: link rows where T1.artist_id = T2.artist_id. 8) When selecting output: return T1.famous_title as the result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT a.famous_title\nFROM artists a\nJOIN volumes v ON a.artist_id = v.artist_id\nWHERE v.weeks_on_top > 2 AND v.weeks_on_top < 2;",
            "SELECT T1.Famous_Title\nFROM artist T1\nJOIN volume T2 ON T1.Artist_ID = T2.Artist_ID\nWHERE T2.Weeks_on_Top > 2\nINTERSECT\nSELECT T1.Famous_Title\nFROM artist T1\nJOIN volume T2 ON T1.Artist_ID = T2.Artist_ID\nWHERE T2.Weeks_on_Top < 2"
        ],
        "rule_sql": [
            "SELECT T1.Famous_Title FROM artist T1 JOIN volume T2 ON T1.Artist_ID = T2.Artist_ID WHERE T2.Weeks_on_Top > 2 INTERSECT SELECT T1.Famous_Title FROM artist T1 JOIN volume T2 ON T1.Artist_ID = T2.Artist_ID WHERE T2.Weeks_on_Top < 2"
        ]
    },
    "6417": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "List document type codes and the number of documents in each code.",
        "ground_truth": "SELECT document_type_code ,  count(*) FROM Documents GROUP BY document_type_code",
        "amends": [
            "Do select `document_type_code` instead of `document_type` and do group by `document_type_code` instead of `document_id` to correctly count documents by their type classification rather than by individual document identifiers."
        ],
        "rules": [
            "1) When the question asks for \"document type codes\": use the exact column token \"document_type_code\" instead of \"document_type\". 2) When counting documents per document type code: group by the exact column token \"document_type_code\" rather than by individual document identifiers. 3) When answering about \"number of documents in each code\": count the number of rows using the canonical document identifier (implied by the schema context) for each document type code group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_type, COUNT(*) FROM documents GROUP BY document_id;",
            "SELECT Document_Type_Code, COUNT(*) AS Number_of_Documents FROM Documents GROUP BY Document_Type_Code;"
        ],
        "rule_sql": [
            "SELECT document_type_code, COUNT(*) AS number_of_documents FROM Documents GROUP BY document_type_code;"
        ]
    },
    "4564": {
        "db_id": "company_office",
        "question": "Which buildings have more than one company offices? Give me the building names.",
        "ground_truth": "SELECT T2.name FROM Office_locations AS T1 JOIN buildings AS T2 ON T1.building_id  =  T2.id JOIN Companies AS T3 ON T1.company_id  =  T3.id GROUP BY T1.building_id HAVING COUNT(*)  >  1",
        "amends": [
            "Do select `T2.name` from the `buildings` table instead of `building_name` from `buildings` alone. Do add `Office_locations AS T1` and `Companies AS T3` as join sources instead of querying only the `buildings` table. Do use `JOIN buildings AS T2 ON T1.building_id = T2.id` and `JOIN Companies AS T3 ON T1.company_id = T3.id` instead of no joins. Do add `GROUP BY T1.building_id` to group by building identifier instead of no grouping. Do use `HAVING COUNT(*) > 1` to filter for buildings with multiple companies instead of `WHERE company_count = 1` which incorrectly assumed a direct column. The amended query now correctly identifies buildings with more than one company by joining through the Office_locations relationship table and counting company associations."
        ],
        "rules": [
            "1) When answering about \"buildings with more than one company offices\": select \"T2\".\"name\" from the buildings table instead of \"building_name\". 2) When combining tables for building-company relationships: add Office_locations as T1 and Companies as T3 as join sources, using JOIN buildings AS T2 ON T1.building_id = T2.id and JOIN Companies AS T3 ON T1.company_id = T3.id. 3) When counting companies per building: group by T1.building_id to organize results by building identifier. 4) When filtering for buildings with multiple companies: use HAVING COUNT(*) > 1 instead of assuming a direct company_count column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT building_name FROM buildings WHERE company_count = 1;",
            "SELECT T2.name \nFROM Office_locations AS T1\nJOIN buildings AS T2 ON T1.building_id = T2.id\nJOIN Companies AS T3 ON T1.company_id = T3.id\nGROUP BY T1.building_id\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T2.name \nFROM Office_locations AS T1\nJOIN buildings AS T2 ON T1.building_id = T2.id\nJOIN Companies AS T3 ON T1.company_id = T3.id\nGROUP BY T1.building_id\nHAVING COUNT(*) > 1"
        ]
    },
    "3944": {
        "db_id": "hospital_1",
        "question": "Find the number of medications prescribed for each brand.",
        "ground_truth": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand",
        "amends": [
            "Do select `count(*)` and `T1.name` instead of `brand` and `COUNT(*)`. Do join `medication AS T1` with `prescribes AS T2` on `T1.code = T2.medication` instead of querying only `medications` table. Do group by `T1.brand` instead of `medication_id`. The amended query now correctly counts prescriptions by medication brand rather than incorrectly grouping by medication ID.",
            "Do select `count(*)` without an alias and `T1.name` instead of `T1.Brand` with an alias `NumberOfPrescriptions`. Do group by `T1.brand` instead of `T1.Brand` to match the case sensitivity. The amended query now correctly returns the count of prescriptions along with medication names grouped by brand.",
            "Do select `count(*)` and `T1.name` instead of `T1.Brand` and `COUNT(*)`. Do group by `T1.brand` instead of `T1.Brand`. The amended query now correctly counts prescriptions while including medication names grouped by brand, matching the intended behavior.",
            "Do select `count(*)` and `T1.name` instead of `T1.Brand` and `COUNT(*)`. Do group by `T1.brand` instead of `T1.Brand`. The amended query now correctly counts prescriptions while including medication names grouped by brand, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT brand, COUNT(*) FROM medications GROUP BY medication_id;",
            "SELECT T1.Brand, COUNT(*) AS NumberOfPrescriptions\nFROM Medication AS T1\nJOIN Prescribes AS T2 ON T1.Code = T2.Medication\nGROUP BY T1.Brand",
            "SELECT T1.Brand, COUNT(*) \nFROM Medication AS T1 \nJOIN Prescribes AS T2 ON T1.Code = T2.Medication \nGROUP BY T1.Brand",
            "SELECT T1.Brand, COUNT(*) \nFROM Medication AS T1 \nJOIN Prescribes AS T2 ON T1.Code = T2.Medication \nGROUP BY T1.Brand",
            "SELECT T1.Brand, COUNT(*) FROM Medication AS T1 JOIN Prescribes AS T2 ON T1.Code = T2.Medication GROUP BY T1.Brand"
        ],
        "rule_sql": []
    },
    "3795": {
        "db_id": "e_learning",
        "question": "What are the names of all the subjects.",
        "ground_truth": "SELECT subject_name FROM SUBJECTS",
        "amends": [
            "Do select only `subject_name` instead of selecting all columns with `*`. Do query from `SUBJECTS` table instead of from `students` table. The amended query now correctly retrieves only subject names from the SUBJECTS table."
        ],
        "rules": [
            "1) When answering about \"names of all the subjects\": make sure the output order: subject_name. 2) When the question mentions \"subjects\": \"subjects\" actually means \"subject_name in table SUBJECTS\". 3) When selecting from the database: query from table \"SUBJECTS\" instead of \"students\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM students;",
            "SELECT subject_name FROM Subjects;"
        ],
        "rule_sql": [
            "SELECT subject_name FROM Subjects ORDER BY subject_name;"
        ]
    },
    "6081": {
        "db_id": "customers_and_addresses",
        "question": "Find the name of customers who are living in Colorado?",
        "ground_truth": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  \"Colorado\"",
        "amends": [
            "Do select `t1.customer_name` instead of `name` and add table aliases. Do add `JOIN customer_addresses AS t2` and `JOIN addresses AS t3` instead of querying only the `customers` table. Do use join conditions `ON t1.customer_id = t2.customer_id` and `ON t2.address_id = t3.address_id` instead of no joins. Do filter on `t3.state_province_county = \"Colorado\"` instead of `state = 'California'` to reference the correct column from the joined addresses table with proper state value. The amended query now correctly joins multiple tables to find customers based on their address location rather than assuming state information exists directly in the customers table."
        ],
        "rules": [
            "1) When answering about \"customers living in Colorado\": make sure the output order: t1.customer_name. 2) When the question mentions \"name\": \"name\" actually means \"t1.customer_name\" in schema. 3) When combining T1 (customers), T2 (customer_addresses), and T3 (addresses) for shared entities: link rows where t1.customer_id = t2.customer_id and t2.address_id = t3.address_id; keep only matching pairs (inner match). 4) When filtering for customers in Colorado: use t3.state_province_county = \"Colorado\" exactly as specified with double quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM customers WHERE state = 'California';",
            "SELECT t1.customer_name\nFROM Customers AS t1\nJOIN Customer_Addresses AS t2 ON t1.customer_id = t2.customer_id\nJOIN Addresses AS t3 ON t2.address_id = t3.address_id\nWHERE t3.state_province_county = 'Colorado'"
        ],
        "rule_sql": [
            "SELECT t1.customer_name\nFROM Customers t1\nINNER JOIN Customer_Addresses t2 ON t1.customer_id = t2.customer_id\nINNER JOIN Addresses t3 ON t2.address_id = t3.address_id\nWHERE t3.state_province_county = \"Colorado\""
        ]
    },
    "5517": {
        "db_id": "products_gen_characteristics",
        "question": "Count the number of products.",
        "ground_truth": "SELECT count(*) FROM products",
        "amends": [
            "Do reference the `products` table instead of the `customers` table in the FROM clause, changing the source of the count operation entirely. The amended query now correctly counts records from the products table instead of customers, matching the intended behavior."
        ],
        "rules": [
            "1) When counting the number of products: use the \"products\" table as the source for counting instead of the \"customers\" table. 2) When the question asks for \"count of products\": compute the number of rows from the \"products\" table using the canonical key for products."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers;",
            "SELECT COUNT(*) FROM Products;"
        ],
        "rule_sql": [
            "SELECT COUNT(product_id) FROM Products;"
        ]
    },
    "6487": {
        "db_id": "scientist_1",
        "question": "Find the total hours of the projects that scientists named Michael Rogers or Carol Smith are assigned to.",
        "ground_truth": "SELECT sum(T2.hours) FROM assignedto AS T1 JOIN projects AS T2 ON T1.project  =  T2.code JOIN scientists AS T3 ON T1.scientist  =  T3.SSN WHERE T3.name  =  'Michael Rogers' OR T3.name  =  'Carol Smith'",
        "amends": [
            "Do use explicit table aliases `T2.hours` instead of bare column `hours`. Do join three tables `assignedto AS T1`, `projects AS T2`, and `scientists AS T3` instead of querying only the `projects` table. Do use `JOIN` with proper join conditions `ON T1.project = T2.code` and `ON T1.scientist = T3.SSN` instead of no joins. Do filter on scientist names `T3.name = 'Michael Rogers' OR T3.name = 'Carol Smith'` in the WHERE clause instead of filtering directly on `scientist_name` in projects table. Do reference the correct relationship through the junction table `assignedto` instead of assuming direct scientist-project relationship. The amended query now correctly aggregates hours by joining through the proper many-to-many relationship structure."
        ],
        "rules": [
            "1) When answering about \"total hours of projects assigned to scientists named Michael Rogers or Carol Smith\": make sure the output order: SUM(T2.hours). 2) When the question mentions \"scientists named Michael Rogers or Carol Smith\": \"Michael Rogers\" and \"Carol Smith\" actually mean T3.name = 'Michael Rogers' OR T3.name = 'Carol Smith' in schema. 3) When combining tables for shared entities: link rows where T1.project = T2.code and T1.scientist = T3.SSN exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"total hours\": compute the sum of T2.hours using the exact token T2.hours. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 6) When handling text literals: do not change case, spacing, or punctuation for 'Michael Rogers' and 'Carol Smith'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(hours) FROM projects WHERE scientist_name IN ('Michael Rogers', 'Carol Smith')",
            "SELECT SUM(T2.Hours) \nFROM AssignedTo AS T1\nJOIN Projects AS T2 ON T1.Project = T2.Code\nJOIN Scientists AS T3 ON T1.Scientist = T3.SSN\nWHERE T3.Name = 'Michael Rogers' OR T3.Name = 'Carol Smith'"
        ],
        "rule_sql": [
            "SELECT SUM(T2.hours) FROM AssignedTo T1 JOIN Projects T2 ON T1.Project = T2.Code JOIN Scientists T3 ON T1.Scientist = T3.SSN WHERE T3.Name = 'Michael Rogers' OR T3.Name = 'Carol Smith'"
        ]
    },
    "310": {
        "db_id": "product_catalog",
        "question": "Which catalog publishers have substring \"Murray\" in their names?",
        "ground_truth": "SELECT distinct(catalog_publisher) FROM catalogs WHERE catalog_publisher LIKE \"%Murray%\"",
        "amends": [
            "Do select `catalog_publisher` instead of `*` from all columns. Do query from `catalogs` table instead of `catalog_publishers` table. Do use `DISTINCT` on `catalog_publisher` instead of omitting it to remove duplicates. Do apply the `LIKE` filter on `catalog_publisher` column instead of `name` column. The amended query now correctly retrieves unique publisher names matching the pattern from the catalogs table."
        ],
        "rules": [
            "1) When answering about catalog publishers with \"Murray\" in their names: select distinct \"catalog_publisher\" from \"Catalogs\" table. 2) When the question mentions \"substring 'Murray' in their names\": apply a pattern match using LIKE '%Murray%' on the \"catalog_publisher\" column. 3) When the question asks for catalog publishers: use the exact column name \"catalog_publisher\" from the \"Catalogs\" table, not a \"name\" column. 4) When selecting from the catalogs data: query from the \"Catalogs\" table instead of a \"catalog_publishers\" table. 5) When retrieving publisher names: use DISTINCT on \"catalog_publisher\" to remove duplicate entries."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM catalog_publishers WHERE name LIKE '%Murray%';",
            "SELECT DISTINCT catalog_publisher FROM Catalogs WHERE catalog_publisher LIKE '%Murray%'"
        ],
        "rule_sql": [
            "SELECT DISTINCT catalog_publisher FROM Catalogs WHERE catalog_publisher LIKE '%Murray%'"
        ]
    },
    "82": {
        "db_id": "student_assessment",
        "question": "For each course id, how many students are registered and what are the course names?",
        "ground_truth": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id",
        "amends": [
            "Do join `students` and `student_course_registrations` on `student_id` instead of omitting these tables entirely. Do join `courses` through `student_course_registrations.course_id` instead of querying `courses` directly without proper relationships. Do use `count(*)` instead of `COUNT(student_id)` to count all registrations rather than non-null student IDs. Do group by `T2.course_id` instead of `course_id` to ensure proper aggregation on the joining table's identifier. Do include `T3.course_name` in the SELECT list instead of `course_name` with proper table qualification. The amended query now correctly counts student course registrations by joining the necessary relationship tables.",
            "Do add the `students` table with a `JOIN` on `student_id` instead of omitting it, and do reference `course_name` from the `courses` table instead of selecting `course_id`. Do remove the explicit `ORDER BY` clause instead of keeping it. Do use `T3.course_name` in the `SELECT` list and `GROUP BY` instead of including both `scr.course_id` and `c.course_name`, and do aggregate with `count(*)` instead of `COUNT(*)` with an alias. The amended query now correctly joins the student records to count registrations per course and matches the RIGHT_SQL's behavior.",
            "Do reference `course_name` directly instead of selecting `course_id` alongside it. Do use table aliases `T1`, `T2`, and `T3` instead of full table names. Do join `students` as `T1` with `student_course_registrations` as `T2` on `T1.student_id = T2.student_id` instead of joining `Student_Course_Registrations` with `Students` on `scr.student_id = s.student_id`. Do join `courses` as `T3` with `student_course_registrations` on `T2.course_id = T3.course_id` instead of joining `Courses` with `Student_Course_Registrations` on `scr.course_id = c.course_id`. Do group by only `T2.course_id` instead of grouping by both `scr.course_id` and `c.course_name`. The amended query now correctly counts students per course while maintaining proper join relationships and grouping logic.",
            "Do remove `T2.course_id` from the SELECT list instead of including it, and do remove the alias `student_count` from the count aggregation instead of keeping it. Do remove `T3.course_name` from the GROUP BY clause instead of including it, as the grouping should only be on `T2.course_id` since course_id functionally determines course_name in a properly normalized schema. The amended query now correctly counts students per course while maintaining referential integrity through the joins."
        ],
        "rules": [
            "1) When answering about student registrations per course: join tables \"students\", \"student_course_registrations\", and \"courses\" using the relationships shown in the amends. 2) When combining \"students\" and \"student_course_registrations\": link rows where \"students\".\"student_id\" = \"student_course_registrations\".\"student_id\" exactly as shown in the amends. 3) When combining \"student_course_registrations\" and \"courses\": link rows where \"student_course_registrations\".\"course_id\" = \"courses\".\"course_id\" exactly as shown in the amends. 4) When counting student registrations: use count(*) to count all registration records rather than counting non-null student IDs. 5) When grouping by course: group by \"student_course_registrations\".\"course_id\" (as T2.course_id) to ensure proper aggregation on the joining table's identifier. 6) When selecting course information: include \"courses\".\"course_name\" (as T3.course_name) in the output with proper table qualification. 7) When organizing results: output columns in the order course_id, count of registrations, course_name.",
            "1) When answering about course registrations: combine tables Student_Course_Registrations (T1), students (T2), and Courses (T3) using inner matches where T1.student_id = T2.student_id and T1.course_id = T3.course_id. 2) When counting students registered per course: count all rows using count(*) and group by T3.course_name only. 3) When the question asks for course names: output T3.course_name instead of course_id. 4) When organizing results: do not apply explicit ordering unless specified in the question.",
            "1) When answering about \"how many students are registered and what are the course names\" for each course id: make sure the output order: course_id, course_name, student_count\n2) When combining tables for student course registrations: use T1 for students, T2 for student_course_registrations, and T3 for courses\n3) When joining students (T1) with student_course_registrations (T2): link rows where T1.student_id = T2.student_id and keep only matching pairs\n4) When joining courses (T3) with student_course_registrations (T2): link rows where T2.course_id = T3.course_id and keep only matching pairs\n5) When grouping by course: organize results by T2.course_id only instead of grouping by both course_id and course_name\n6) When counting students per course: compute the number of rows using the canonical key T2.student_id for counting students",
            "1) When answering about \"how many students are registered per course id\": make sure the output order: course_id, course_name, count of students. 2) When the question asks for \"count of students\": compute the number of rows using the canonical key token for students (T1.student_id). 3) When combining Students T1 and Student_Course_Registrations T2: link rows where T1.student_id = T2.student_id and keep only matching pairs (inner match). 4) When combining Student_Course_Registrations T2 and Courses T3: link rows where T2.course_id = T3.course_id and keep only matching pairs (inner match). 5) When grouping by course_id: organize results by T2.course_id and compute requested aggregates per group. 6) When course_id functionally determines course_name: do not include T3.course_name in the GROUP BY clause, only group by T2.course_id. 7) When producing output: do not include T2.course_id in the SELECT list, only include T3.course_name and the count of students."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT course_id, COUNT(student_id), course_name FROM courses GROUP BY course_id;",
            "SELECT \n    scr.course_id,\n    c.course_name,\n    COUNT(*) AS student_count\nFROM \n    Student_Course_Registrations scr\nJOIN \n    Courses c ON scr.course_id = c.course_id\nGROUP BY \n    scr.course_id, c.course_name\nORDER BY \n    scr.course_id;",
            "SELECT \n    scr.course_id,\n    c.course_name,\n    COUNT(*) AS student_count\nFROM \n    Student_Course_Registrations scr\nJOIN \n    Students s ON scr.student_id = s.student_id\nJOIN \n    Courses c ON scr.course_id = c.course_id\nGROUP BY \n    scr.course_id, c.course_name",
            "SELECT T2.course_id, T3.course_name, COUNT(*) AS student_count\nFROM Students T1\nJOIN Student_Course_Registrations T2 ON T1.student_id = T2.student_id\nJOIN Courses T3 ON T2.course_id = T3.course_id\nGROUP BY T2.course_id, T3.course_name",
            "SELECT T3.course_name, COUNT(*) \nFROM Students T1 \nJOIN Student_Course_Registrations T2 ON T1.student_id = T2.student_id \nJOIN Courses T3 ON T2.course_id = T3.course_id \nGROUP BY T2.course_id"
        ],
        "rule_sql": [
            "SELECT \n    T2.course_id,\n    T3.course_name,\n    COUNT(T1.student_id) AS student_count\nFROM \n    Students T1\nINNER JOIN \n    Student_Course_Registrations T2 ON T1.student_id = T2.student_id\nINNER JOIN \n    Courses T3 ON T2.course_id = T3.course_id\nGROUP BY \n    T2.course_id\nORDER BY \n    T2.course_id;"
        ]
    },
    "842": {
        "db_id": "chinook_1",
        "question": "Count the number of tracks that are part of the rock genre.",
        "ground_truth": "SELECT COUNT(*) FROM GENRE AS T1 JOIN TRACK AS T2 ON T1.GenreId  =  T2.GenreId WHERE T1.Name  =  \"Rock\"",
        "amends": [
            "Do join `GENRE` and `TRACK` tables on `GenreId` instead of querying only the `tracks` table. Do filter on `T1.Name = \"Rock\"` instead of filtering directly on `genre = 'Rock'`. Do use proper table aliases `T1` and `T2` instead of referencing columns without table context. The amended query now correctly counts tracks by joining the genre table and filtering on genre name rather than assuming the genre column exists directly in the tracks table, matching the intended behavior."
        ],
        "rules": [
            "1) When counting tracks by genre: join the TRACK table (T2) and GENRE table (T1) where T2.GenreId equals T1.GenreId to match tracks with their genres. 2) When filtering for rock genre: use T1.Name = \"Rock\" exactly as specified to identify the rock genre. 3) When counting tracks: use the canonical key from the TRACK table to count the number of tracks that match the specified genre condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM tracks WHERE genre = 'Rock';",
            "SELECT COUNT(*) \nFROM Track T2\nJOIN Genre T1 ON T2.GenreId = T1.GenreId\nWHERE T1.Name = 'Rock'"
        ],
        "rule_sql": [
            "SELECT COUNT(Track.TrackId) \nFROM Track \nJOIN Genre ON Track.GenreId = Genre.GenreId \nWHERE Genre.Name = 'Rock'"
        ]
    },
    "1464": {
        "db_id": "college_2",
        "question": "Find the names of all instructors in computer science department",
        "ground_truth": "SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'",
        "amends": [
            "Do reference table `instructor` instead of `instructors` and filter on column `dept_name` with value `'Comp. Sci.'` instead of column `department` with value `'physics'`."
        ],
        "rules": [
            "1) When the question asks about instructors: use table \"instructor\" instead of \"instructors\" as the base table. 2) When filtering by department in computer science: use column \"dept_name\" with exact literal value 'Comp. Sci.' instead of 'physics'. 3) When selecting instructor names: output the \"name\" column from the \"instructor\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM instructors WHERE department = 'physics'",
            "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.'"
        ],
        "rule_sql": [
            "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.'"
        ]
    },
    "1570": {
        "db_id": "customers_and_invoices",
        "question": "What are the the full names and ids for all customers, and how many accounts does each have?",
        "ground_truth": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id",
        "amends": [
            "Do use `INNER JOIN` between `Accounts` and `Customers` instead of `LEFT JOIN` from `customers` to `accounts`. Do reference `customer_first_name` and `customer_last_name` from the Customers table instead of `first_name` and `last_name`. Do use `count(*)` instead of `COUNT(a.account_id)` to count all joined rows. Do simplify the GROUP BY to only `customer_id` instead of including all customer name columns. Do use table aliases `T1` for Accounts and `T2` for Customers instead of single-letter aliases. The amended query now correctly performs an inner join to count accounts only for customers who actually have accounts, matching the RIGHT_SQL's behavior.",
            "Do include individual columns `T2.customer_first_name` and `T2.customer_last_name` instead of concatenating them as `full_name`. Do reference `T1.customer_id` in both SELECT and GROUP BY instead of `T2.customer_id` to ensure proper aggregation. Do use simple `JOIN` instead of `INNER JOIN` as they are functionally equivalent. Do remove the alias `account_count` from the count aggregation instead of keeping it. The amended query now correctly groups by the customer_id from the Accounts table and preserves individual name columns for proper result structure."
        ],
        "rules": [
            "1) When combining Accounts and Customers tables: use INNER JOIN between T1 (Accounts) and T2 (Customers) where T1.customer_id = T2.customer_id, keeping only customers who have accounts. 2) When selecting customer names: use T2.customer_first_name and T2.customer_last_name instead of first_name and last_name. 3) When counting accounts per customer: use count(*) to count all joined rows rather than counting specific account_id values. 4) When grouping by customer: group only by T2.customer_id instead of including all customer name columns in the GROUP BY clause. 5) When assigning table aliases: use T1 for Accounts table and T2 for Customers table consistently throughout the query.",
            "1) When answering about customer names and account counts: output individual columns T2.customer_first_name and T2.customer_last_name instead of concatenating them as full_name. 2) When counting accounts per customer: use T1.customer_id as the grouping key and counting key instead of T2.customer_id. 3) When combining Accounts and Customers tables: link rows where T1.customer_id = T2.customer_id using a simple JOIN (equivalent to INNER JOIN). 4) When performing aggregation: do not assign an alias to the COUNT(*) result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.customer_id, c.first_name, c.last_name, COUNT(a.account_id) \nFROM customers c \nLEFT JOIN accounts a ON c.customer_id = a.customer_id \nGROUP BY c.customer_id, c.first_name, c.last_name",
            "SELECT \n    T2.customer_id,\n    T2.customer_first_name || ' ' || T2.customer_last_name AS full_name,\n    COUNT(*) AS account_count\nFROM \n    Accounts T1\nINNER JOIN \n    Customers T2 ON T1.customer_id = T2.customer_id\nGROUP BY \n    T2.customer_id",
            "SELECT T2.customer_id, T2.customer_first_name, T2.customer_last_name, COUNT(*)\nFROM Accounts T1\nJOIN Customers T2 ON T1.customer_id = T2.customer_id\nGROUP BY T1.customer_id"
        ],
        "rule_sql": [
            "SELECT T2.customer_id, T2.customer_first_name, T2.customer_last_name, COUNT(*)\nFROM Accounts T1\nJOIN Customers T2 ON T1.customer_id = T2.customer_id\nGROUP BY T1.customer_id"
        ]
    },
    "265": {
        "db_id": "musical",
        "question": "Return the most frequent result across all musicals.",
        "ground_truth": "SELECT RESULT FROM musical GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do reference the table as `musical` instead of `musicals` to match the correct table name. Do select only `RESULT` instead of both `result` and `COUNT(*) as frequency` to return just the column values. Do move the aggregate function `COUNT(*)` to the `ORDER BY` clause instead of including it in the `SELECT` list to properly order by frequency without selecting it. Do use uppercase `RESULT` instead of lowercase `result` for column name consistency. The amended query now correctly returns the most frequent result value from the musical table ordered by count in descending order."
        ],
        "rules": [
            "1) When the question asks for the most frequent result: count occurrences of each RESULT value and order by count descending to find the highest frequency. 2) When referencing the musical results table: use the exact table name \"musical\" (not \"musicals\"). 3) When selecting the result column: use uppercase \"RESULT\" to match the schema's column naming. 4) When ordering by frequency: use COUNT(*) in the ORDER BY clause without including it in the SELECT list to return only the RESULT values. 5) When returning the most frequent value: take only the top result after ordering by frequency descending."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT result, COUNT(*) as frequency FROM musicals GROUP BY result ORDER BY frequency DESC LIMIT 1;",
            "SELECT RESULT FROM musical GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT RESULT FROM musical GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "1108": {
        "db_id": "match_season",
        "question": "Which college have both players with position midfielder and players with position defender?",
        "ground_truth": "SELECT College FROM match_season WHERE POSITION  =  \"Midfielder\" INTERSECT SELECT College FROM match_season WHERE POSITION  =  \"Defender\"",
        "amends": [
            "Do use `INTERSECT` between two separate queries instead of combining conditions with `AND` in a single query. Do reference `match_season` table instead of `players` table. Do use proper case for column names `College` and `POSITION` instead of lowercase `college` and `position`. Do use double quotes for string values `\"Midfielder\"` and `\"Defender\"` instead of single quotes. Do query for each position separately and find their intersection instead of trying to find rows where position equals both values simultaneously, which would never return results. The amended query now correctly finds colleges that have both midfielder and defender positions by using set intersection logic."
        ],
        "rules": [
            "1) When the question asks about colleges having both players with specific positions: use set intersection logic between separate queries for each position instead of combining conditions with AND in a single query. 2) When referencing the college information: use the \"College\" column from the \"match_season\" table instead of the \"players\" table. 3) When specifying position values: use exact string literals \"Midfielder\" and \"Defender\" with double quotes instead of single quotes. 4) When selecting the college column: use proper case \"College\" instead of lowercase \"college\". 5) When filtering by position: use proper case \"POSITION\" instead of lowercase \"position\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT college FROM players WHERE position = 'midfielder' AND position = 'defender';",
            "SELECT \"College\" FROM \"match_season\" WHERE \"Position\" = \"Midfielder\" INTERSECT SELECT \"College\" FROM \"match_season\" WHERE \"Position\" = \"Defender\""
        ],
        "rule_sql": [
            "SELECT DISTINCT m1.College\nFROM match_season m1\nWHERE m1.POSITION = \"Midfielder\"\nINTERSECT\nSELECT DISTINCT m2.College\nFROM match_season m2\nWHERE m2.POSITION = \"Defender\""
        ]
    },
    "5334": {
        "db_id": "manufactory_1",
        "question": "Compute the number of products with a price larger than or equal to $180.",
        "ground_truth": "SELECT count(*) FROM products WHERE price >= 180",
        "amends": [
            "Do use `>=` operator instead of `>` operator in the WHERE filter condition for the `price` column, which changes the comparison from strictly greater than 180 to greater than or equal to 180, ensuring that products priced exactly at 180 are included in the count instead of being excluded. The amended query now matches RIGHT_SQL's behavior by including the boundary value in the count calculation."
        ],
        "rules": [
            "1) When the question asks for products with price larger than or equal to $180: use the >= operator to include products priced exactly at 180 in the count. 2) When counting products: use the canonical key for counting (all rows in the products table). 3) When handling numeric comparisons: preserve the exact literal value 180 without quotes or currency symbols."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM products WHERE price > 180;",
            "SELECT COUNT(*) FROM Products WHERE Price >= 180;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Products WHERE Price >= 180"
        ]
    },
    "5951": {
        "db_id": "cre_Theme_park",
        "question": "Show different tourist attractions' names, ids, and the corresponding number of visits.",
        "ground_truth": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID",
        "amends": [
            "Do add `JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID` instead of querying only the `tourist_attractions` table. Do use `T1.Name` and `T2.Tourist_Attraction_ID` in the SELECT list instead of `name` and `id`. Do reference the joined table with proper aliases `T1` and `T2` instead of unaliased table names. Do group by `T2.Tourist_Attraction_ID` instead of grouping by both `name` and `id`. The amended query now correctly joins the two tables and counts visits per tourist attraction, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about tourist attractions and their visits: combine tables tourist_attractions as T1 and VISITS as T2 using the exact key equality T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID, keeping only matching pairs (inner match). 2) When the question asks for \"number of visits\": compute the count of rows using the joined relationship between T1 and T2. 3) When the question asks for tourist attraction details: include T1.Name and T2.Tourist_Attraction_ID in the output columns. 4) When grouping results by tourist attraction: organize results by T2.Tourist_Attraction_ID instead of grouping by both name and id separately."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, id, COUNT(*) FROM tourist_attractions GROUP BY name, id",
            "SELECT T1.Name, T1.Tourist_Attraction_ID, COUNT(T2.Visit_ID) AS NumberOfVisits\nFROM Tourist_Attractions T1\nJOIN Visits T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID\nGROUP BY T2.Tourist_Attraction_ID"
        ],
        "rule_sql": [
            "SELECT T1.Name, T1.Tourist_Attraction_ID, COUNT(T2.Visit_ID) AS Number_of_Visits\nFROM Tourist_Attractions T1\nINNER JOIN Visits T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID\nGROUP BY T2.Tourist_Attraction_ID\nORDER BY Number_of_Visits DESC;"
        ]
    },
    "5984": {
        "db_id": "game_1",
        "question": "What are the types of video games and how many are in each type?",
        "ground_truth": "SELECT gtype ,  count(*) FROM Video_games GROUP BY gtype",
        "amends": [
            "Do use column name `gtype` instead of `type` in the SELECT list and GROUP BY clause. Do reference table name `Video_games` instead of `video_games` to match the correct case sensitivity. The amended query now correctly groups and counts records by the `gtype` column as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for \"types of video games\": use the exact column name \"gtype\" from table \"Video_games\" to represent game types. 2) When counting video games per type: count the number of records using the canonical key for video games (the primary identifier of the Video_games table) grouped by \"gtype\". 3) When referencing the video games table: use the exact table name \"Video_games\" with the correct case sensitivity as shown in the schema. 4) When organizing results by game type: group the output by the \"gtype\" column to show counts for each distinct game type."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type, COUNT(*) FROM video_games GROUP BY type;",
            "SELECT GType, COUNT(*) AS count FROM Video_Games GROUP BY GType;"
        ],
        "rule_sql": [
            "SELECT GType, COUNT(GameID) AS Count FROM Video_Games GROUP BY GType;"
        ]
    },
    "780": {
        "db_id": "race_track",
        "question": "What are the names of different tracks, and how many races has each had?",
        "ground_truth": "SELECT T2.name ,  count(*) FROM race AS T1 JOIN track AS T2 ON T1.track_id  =  T2.track_id GROUP BY T1.track_id",
        "amends": [
            "Do join `track AS T2` instead of omitting it, and do use `JOIN` with `ON T1.track_id = T2.track_id` instead of querying only the `races` table. Do select `T2.name` instead of `track_name`, and do use `count(*)` instead of `COUNT(race_id)`. Do group by `T1.track_id` instead of `track_name` to ensure proper aggregation with the joined table structure. The amended query now correctly correlates race and track data through the appropriate foreign key relationship."
        ],
        "rules": [
            "1) When answering about \"names of different tracks and how many races each had\": make sure the output order: T2.name first, then count of races. 2) When combining races table (T1) and track table (T2): link rows where T1.track_id = T2.track_id and keep only matching pairs (inner match). 3) When counting races per track: compute the number of rows using count(*) instead of counting a specific column. 4) When grouping by track: organize results by T1.track_id instead of track_name to ensure proper aggregation with the joined table structure. 5) When selecting track names: use T2.name instead of track_name from the races table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT track_name, COUNT(race_id) FROM races GROUP BY track_name;",
            "SELECT T2.Name, COUNT(*) AS race_count FROM race AS T1 JOIN track AS T2 ON T1.Track_ID = T2.Track_ID GROUP BY T1.Track_ID"
        ],
        "rule_sql": [
            "SELECT T2.Name, COUNT(*) AS race_count FROM race T1 INNER JOIN track T2 ON T1.Track_ID = T2.Track_ID GROUP BY T1.Track_ID ORDER BY T2.Name, race_count;"
        ]
    },
    "3709": {
        "db_id": "baseball_1",
        "question": "Which park had most attendances in 2008?",
        "ground_truth": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;",
        "amends": [
            "Do select `T2.park_name` instead of `park_name, MAX(attendance)` and remove the aggregate function. Do use `FROM home_game AS T1 JOIN park AS T2` instead of `FROM parks` with proper table aliases and join. Do specify the join condition `ON T1.park_id = T2.park_id` instead of missing the table relationship entirely. Do filter with `WHERE T1.year = 2008` instead of `WHERE year = 2008` with proper table qualification. Do remove `GROUP BY park_name` since no aggregation is needed. Do order by `T1.attendance DESC` instead of `attendance DESC` with proper table qualification. The amended query now correctly retrieves the park with highest attendance in 2008 by joining the relevant tables and preserves the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"which park had most attendances in 2008\": make sure the output order: T2.park_name. 2) When combining home_game as T1 and park as T2: link rows where T1.park_id = T2.park_id and keep only matching pairs (inner match). 3) When filtering for year 2008: use T1.year = 2008 with exact literal value 2008. 4) When the question mentions \"most attendances\" or \"highest\": rank rows by T1.attendance in descending order and keep the first 1 row. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT park_name, MAX(attendance) FROM parks WHERE year = 2008 GROUP BY park_name ORDER BY attendance DESC LIMIT 1;",
            "SELECT T2.park_name\nFROM home_game AS T1\nJOIN park AS T2 ON T1.park_id = T2.park_id\nWHERE T1.year = 2008\nORDER BY T1.attendance DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.park_name\nFROM home_game AS T1\nINNER JOIN park AS T2 ON T1.park_id = T2.park_id\nWHERE T1.year = 2008\nORDER BY T1.attendance DESC\nLIMIT 1"
        ]
    },
    "5308": {
        "db_id": "manufactory_1",
        "question": "Find the name and revenue of the company that earns the highest revenue in each city.",
        "ground_truth": "SELECT name ,  max(revenue) ,  Headquarter FROM manufacturers GROUP BY Headquarter",
        "amends": [
            "Do select `name` and `max(revenue)` instead of `name` and `revenue`, and do select `Headquarter` instead of `city`. Do group by `Headquarter` instead of `city`, and do use `max(revenue)` aggregate instead of non-aggregated `revenue` in the SELECT list. The amended query now correctly aggregates maximum revenue by headquarters location instead of attempting to select non-aggregated columns with grouping."
        ],
        "rules": [
            "1) When the question asks for \"highest revenue in each city\": use \"Headquarter\" instead of \"city\" as the grouping column. 2) When computing maximum revenue per group: use max(revenue) aggregate function instead of selecting non-aggregated revenue. 3) When selecting columns with grouping: include both the company name and the maximum revenue value in the output. 4) When organizing results by headquarters location: group by the exact column \"Headquarter\" to compute aggregates per city."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, revenue, city FROM companies GROUP BY city ORDER BY revenue DESC;",
            "SELECT m.Name, MAX(m.Revenue) as max_revenue, m.Headquarter FROM Manufacturers m GROUP BY m.Headquarter"
        ],
        "rule_sql": [
            "SELECT m.Name, MAX(m.Revenue) as MaxRevenue, m.Headquarter \nFROM Manufacturers m\nGROUP BY m.Headquarter\nORDER BY m.Headquarter;"
        ]
    },
    "474": {
        "db_id": "allergy_1",
        "question": "How many students are 18 years old?",
        "ground_truth": "SELECT count(*) FROM Student WHERE age  =  18",
        "amends": [
            "Do reference the table as `Student` instead of `students` to match the correct schema. Do use the equality filter `age = 18` instead of the inequality `age != 18` to count students who are exactly 18 years old rather than excluding them. The amended query now correctly counts students with age equal to 18, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"students\": use the exact table name \"Student\" as shown in the schema. 2) When counting students who are 18 years old: use the equality condition \"age = 18\" to include only students with exactly 18 years of age. 3) When the question asks \"how many students\": count the number of rows using the canonical key for students (typically a student ID or primary key), though the specific key isn't specified in this simple case."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE age != 18;",
            "SELECT COUNT(*) FROM Student WHERE Age = 18;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Student WHERE Age = 18;"
        ]
    },
    "3630": {
        "db_id": "baseball_1",
        "question": "Find the full name and id of the college that has the most baseball players.",
        "ground_truth": "SELECT T1.name_full ,  T1.college_id FROM college AS T1 JOIN player_college AS T2 ON T1.college_id  =  T2.college_id GROUP BY T1.college_id ORDER BY count(*) DESC LIMIT 1;",
        "amends": [
            "Do select `name_full` and `college_id` instead of `name` and `id`. Do join `college` as `T1` with `player_college` as `T2` on `T1.college_id = T2.college_id` instead of using a correlated subquery with `players.college_id = colleges.id`. Do group by `T1.college_id` instead of ordering by a subquery count. Do order by `count(*)` descending instead of ordering by a baseball-specific subquery count. Do remove the `sport = 'baseball'` filter instead of keeping it, making the query count all players rather than just baseball players. The amended query now correctly joins the college and player_college tables and counts all associated players to find the college with the most players overall."
        ],
        "rules": [
            "1) When selecting college information: use \"name_full\" and \"college_id\" columns from the college table instead of \"name\" and \"id\". 2) When combining college and player data: join table \"college\" as T1 with table \"player_college\" as T2 on T1.college_id = T2.college_id using inner match. 3) When counting players per college: group by T1.college_id and count all rows in each group. 4) When finding the college with the most players: order the results by the player count in descending order and take the first row. 5) When the question mentions \"baseball players\": note that the correct approach counts all players regardless of sport, not just baseball players specifically."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, id FROM colleges ORDER BY (SELECT COUNT(*) FROM players WHERE players.college_id = colleges.id AND sport = 'baseball') DESC LIMIT 1;",
            "SELECT T1.name_full, T1.college_id\nFROM college T1\nJOIN player_college T2 ON T1.college_id = T2.college_id\nGROUP BY T1.college_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.name_full, T1.college_id\nFROM college T1\nINNER JOIN player_college T2 ON T1.college_id = T2.college_id\nGROUP BY T1.college_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "3748": {
        "db_id": "program_share",
        "question": "how many programs are broadcast in each time section of the day?",
        "ground_truth": "SELECT count(*) ,  time_of_day FROM broadcast GROUP BY time_of_day",
        "amends": [
            "Do select `count(*)` and include `time_of_day` in the SELECT list instead of omitting the grouping column. Do query from `broadcast` table instead of `programs` table. Do group by `time_of_day` instead of `time_section`. The amended query now correctly returns both the count and the grouping column from the appropriate table.",
            "Do place the `time_of_day` column after the aggregate function `count(*)` in the SELECT list instead of listing it first. Do maintain the same GROUP BY clause with `time_of_day` to preserve the grouping logic. The amended query now correctly positions the aggregate function first while maintaining identical output behavior and matching the RIGHT_SQL's structure."
        ],
        "rules": [
            "1) When answering about \"how many programs are broadcast in each time section of the day\": make sure the output order: time_of_day, count(*) 2) When the question mentions \"programs\": \"programs\" actually means \"broadcast\" in schema 3) When the question mentions \"time section\": \"time section\" actually means \"time_of_day\" in schema 4) When the question asks for \"count of programs per time section\": compute the number of rows using the canonical key from the broadcast table and group by time_of_day",
            "1) When answering about \"how many programs are broadcast in each time section of the day\": make sure the output order: count(*) first, then time_of_day. 2) When the question asks for \"count of programs\" per time section: compute the number of rows using the canonical key for programs. 3) When the question says \"per time section\" or \"by time section\": organize results by time_of_day and compute the count per group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM programs GROUP BY time_section;",
            "SELECT time_of_day, COUNT(*) FROM broadcast GROUP BY time_of_day;",
            "SELECT count(*), time_of_day FROM broadcast GROUP BY time_of_day"
        ],
        "rule_sql": [
            "SELECT time_of_day, COUNT(*) FROM broadcast GROUP BY time_of_day ORDER BY COUNT(*) DESC, time_of_day;"
        ]
    },
    "336": {
        "db_id": "product_catalog",
        "question": "Which catalog contents has price above 700 dollars? Show their catalog entry names and capacities.",
        "ground_truth": "SELECT catalog_entry_name ,  capacity FROM Catalog_Contents WHERE price_in_dollars  >  700",
        "amends": [
            "Do reference column `price_in_dollars` in the WHERE filter instead of `price`, as the correct column name reflects the monetary unit specification. Do maintain the same SELECT list with `catalog_entry_name` and `capacity` columns without changes. Do preserve the FROM clause sourcing from `Catalog_Contents` table (note the case difference is cosmetic and ignorable). The amended query now correctly filters by dollar-based pricing and matches the RIGHT_SQL behavior."
        ],
        "rules": [
            "1) When the question mentions \"price above 700 dollars\": use the exact column \"price_in_dollars\" with comparison > 700 instead of \"price\". 2) When answering about catalog contents with price above 700 dollars: make sure the output order is \"catalog_entry_name\" then \"capacity\". 3) When selecting from the catalog contents table: use the exact table name \"Catalog_Contents\" as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT catalog_entry_name, capacity FROM catalog_contents WHERE price > 700",
            "SELECT catalog_entry_name, capacity FROM Catalog_Contents WHERE price_in_dollars > 700"
        ],
        "rule_sql": [
            "SELECT catalog_entry_name, capacity FROM Catalog_Contents WHERE price_in_dollars > 700 ORDER BY catalog_entry_name, capacity;"
        ]
    },
    "3624": {
        "db_id": "music_1",
        "question": "What is the duration, file size, and song format for every pop song, ordered by title alphabetically?",
        "ground_truth": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  \"pop\" ORDER BY T2.song_name",
        "amends": [
            "Do reference columns with table aliases `T1.duration`, `T1.file_size`, and `T1.formats` instead of unqualified `duration`, `file_size`, and `song_format`. Do use table `files AS T1` joined with `song AS T2` on `T1.f_id = T2.f_id` instead of single table `songs`. Do filter on `T2.genre_is = \"pop\"` instead of `genre = 'pop'`. Do order by `T2.song_name` instead of `artist`. The amended query now correctly joins the files and song tables to retrieve pop songs ordered by song name."
        ],
        "rules": [
            "1) When answering about pop songs: use table \"files\" as T1 and table \"song\" as T2, joining them where T1.f_id = T2.f_id to get matching file and song information. 2) When filtering for pop songs: use the condition T2.genre_is = \"pop\" exactly as specified. 3) When selecting output columns: use T1.duration, T1.file_size, and T1.formats (not song_format) for the requested information. 4) When ordering results alphabetically by title: order by T2.song_name instead of artist to get the correct alphabetical ordering by song title."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT duration, file_size, song_format FROM songs WHERE genre = 'pop' ORDER BY artist;",
            "SELECT T1.duration, T1.file_size, T1.formats\nFROM files AS T1\nJOIN song AS T2 ON T1.f_id = T2.f_id\nWHERE T2.genre_is = 'pop'\nORDER BY T2.song_name"
        ],
        "rule_sql": [
            "SELECT T1.duration, T1.file_size, T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id = T2.f_id WHERE T2.genre_is = 'pop' ORDER BY T2.song_name ASC;"
        ]
    },
    "6404": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "What are the ids and names for each of the documents?",
        "ground_truth": "SELECT document_id ,  document_name FROM Documents",
        "amends": [
            "Do use `document_id` and `document_name` instead of `id` and `name` to match the correct column names. Do reference the `Documents` table instead of `documents` to use the proper table name with correct casing. Do remove the `WHERE id IS NULL` filter instead of keeping it, as the right query returns all records without any filtering condition. The amended query now correctly selects all document records with the appropriate column names and table reference."
        ],
        "rules": [
            "1) When selecting document identifiers and names: use \"document_id\" and \"document_name\" as the exact column names instead of \"id\" and \"name\". 2) When referencing the documents table: use \"Documents\" with exact casing instead of \"documents\". 3) When the question asks for all documents: do not apply any filtering condition and return all records from the Documents table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, name FROM documents WHERE id IS NULL;",
            "SELECT document_id, document_name FROM Documents"
        ],
        "rule_sql": [
            "SELECT document_id, document_name FROM Documents;"
        ]
    },
    "5490": {
        "db_id": "voter_2",
        "question": "Find the average age of students who live in the city with code \"NYC\" and have secretary votes in the spring election cycle.",
        "ground_truth": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  \"NYC\" AND T2.Election_Cycle  =  \"Spring\"",
        "amends": [
            "Do join `STUDENT AS T1` with `VOTING_RECORD AS T2` on `T1.StuID = SECRETARY_Vote` instead of querying only the `students` table without any join. Do reference the age column as `T1.Age` instead of just `age` and use table alias `T1` for clarity. Do filter on `T2.Election_Cycle = \"Spring\"` instead of `election_cycle = 'spring'` to use the correct table source and case. Do remove the filter `secretary_votes > 0` instead of keeping it, as the join condition now properly handles the voting relationship. Do use double quotes around \"NYC\" and \"Spring\" instead of single quotes for string literals. The amended query now correctly joins the student and voting record tables to calculate average age only for students with voting records in the specified election cycle, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about students with secretary votes: join STUDENT as T1 with VOTING_RECORD as T2 on T1.StuID = SECRETARY_Vote to establish the voting relationship. 2) When filtering for city code: use T1.city_code = \"NYC\" with double quotes around the literal. 3) When filtering for election cycle: use T2.Election_Cycle = \"Spring\" with double quotes and exact case. 4) When calculating average age: use T1.Age as the column reference. 5) When combining tables: perform an inner join to keep only students who have voting records in the specified election cycle."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age) FROM students WHERE city_code = 'NYC' AND secretary_votes > 0 AND election_cycle = 'spring';",
            "SELECT AVG(T1.Age) \nFROM Student AS T1\nJOIN Voting_record AS T2 ON T1.StuID = T2.Secretary_Vote\nWHERE T1.city_code = \"NYC\" AND T2.Election_Cycle = \"Spring\""
        ],
        "rule_sql": [
            "SELECT AVG(T1.Age) \nFROM Student AS T1 \nINNER JOIN Voting_record AS T2 ON T1.StuID = T2.Secretary_Vote \nWHERE T1.city_code = \"NYC\" AND T2.Election_Cycle = \"Spring\""
        ]
    },
    "2269": {
        "db_id": "entrepreneur",
        "question": "What is the average money requested by all entrepreneurs?",
        "ground_truth": "SELECT avg(Money_Requested) FROM entrepreneur",
        "amends": [
            "Do reference the `entrepreneur` table instead of `entrepreneurs`. Do use the column `Money_Requested` instead of `money`. Do remove the `WHERE money IS NOT NULL` filter instead of keeping it, as the AVG function inherently ignores NULL values. The amended query now correctly calculates the average of Money_Requested from the entrepreneur table."
        ],
        "rules": [
            "1) When the question mentions \"entrepreneurs\": use the exact table name \"entrepreneur\" instead of \"entrepreneurs\". 2) When the question asks for \"money requested\": use the exact column name \"Money_Requested\" instead of \"money\". 3) When calculating averages: do not add explicit NULL filtering conditions as the AVG function inherently ignores NULL values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(money) FROM entrepreneurs WHERE money IS NOT NULL;",
            "SELECT AVG(Money_Requested) FROM entrepreneur"
        ],
        "rule_sql": [
            "SELECT AVG(Money_Requested) FROM entrepreneur"
        ]
    },
    "6010": {
        "db_id": "game_1",
        "question": "What is the total number of all football games played by scholarship students?",
        "ground_truth": "SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  \"Football\" AND onscholarship  =  'Y'",
        "amends": [
            "Do use `sum(gamesplayed)` instead of `COUNT(*)` to aggregate actual game counts rather than row counts. Do reference table `Sportsinfo` instead of `games` as the data source. Do filter on `sportname = \"Football\"` instead of `sport = 'football'` to match the correct column name and value format. Do filter on `onscholarship = 'Y'` instead of `player_type = 'scholarship'` to use the proper boolean indicator column. The amended query now correctly calculates total games played by scholarship football players instead of counting rows, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"total number of all football games played by scholarship students\": use sum(\"gamesplayed\") instead of COUNT(*) to aggregate actual game counts. 2) When the question mentions \"football games\": filter on \"sportname\" = \"Football\" (exact case and quotes). 3) When the question mentions \"scholarship students\": filter on \"onscholarship\" = 'Y' (exact value). 4) When selecting data source: use table \"Sportsinfo\" instead of \"games\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE player_type = 'scholarship' AND sport = 'football';",
            "SELECT SUM(GamesPlayed) FROM SportsInfo WHERE SportName = 'Football' AND OnScholarship = 'Y'"
        ],
        "rule_sql": [
            "SELECT SUM(GamesPlayed) FROM SportsInfo WHERE SportName = 'Football' AND OnScholarship = 'Y'"
        ]
    },
    "3701": {
        "db_id": "baseball_1",
        "question": "Which team had the least number of attendances in home games in 1980?",
        "ground_truth": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;",
        "amends": [
            "Do select `T2.name` instead of `team_name` and `COUNT(*) as home_attendances`. Do use `FROM home_game AS T1 JOIN team AS T2` instead of `FROM games` with a single table. Do apply join condition `ON T1.team_id = T2.team_id_br` instead of filtering `WHERE home_team = team_name`. Do filter `WHERE T1.year = 1980` instead of `year = 1980`. Do remove `GROUP BY team_name` and aggregation instead of keeping them. Do order by `T1.attendance ASC` instead of `home_attendances DESC`. Do keep `LIMIT 1` but change the sorting direction. The amended query now correctly retrieves the team with the lowest attendance in 1980 using proper table joins and eliminates the incorrect self-join logic.",
            "Do remove `T1.attendance` from the SELECT list instead of including it, as the RIGHT_SQL only selects `T2.name` while preserving the same FROM clause with `JOIN` on `T1.team_id = T2.team_id_br`, WHERE filter on `T1.year = 1980`, ORDER BY `T1.attendance ASC`, and LIMIT 1. The amended query now matches RIGHT_SQL's behavior by selecting only the team name while maintaining the same filtering and ordering logic."
        ],
        "rules": [
            "1) When answering about team attendances in home games: use table \"home_game\" as T1 and table \"team\" as T2. 2) When combining home_game and team tables: link rows where T1.team_id equals T2.team_id_br and keep only matching pairs. 3) When filtering for year 1980: include only rows where T1.year equals 1980. 4) When the question asks for \"least number of attendances\": order rows by T1.attendance in ascending order and keep only the first row. 5) When selecting output columns: include T2.name and the count of attendances as home_attendances.",
            "1) When answering about \"team with least number of attendances in home games in 1980\": make sure the output order includes only T2.name. 2) When the question asks for the \"least number of attendances\": rank rows by T1.attendance in ascending order and keep the first 1 row. 3) When combining home_game (T1) and team (T2) tables: link rows where T1.team_id = T2.team_id_br and keep only matching pairs (inner match). 4) When filtering for games in 1980: include only rows where T1.year = 1980."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT team_name, COUNT(*) as home_attendances \nFROM games \nWHERE year = 1980 AND home_team = team_name \nGROUP BY team_name \nORDER BY home_attendances DESC \nLIMIT 1;",
            "SELECT T2.name, T1.attendance\nFROM home_game AS T1\nJOIN team AS T2 ON T1.team_id = T2.team_id_br\nWHERE T1.year = 1980\nORDER BY T1.attendance ASC\nLIMIT 1;",
            "SELECT T2.name\nFROM home_game AS T1\nJOIN team AS T2 ON T1.team_id = T2.team_id_br\nWHERE T1.year = 1980\nORDER BY T1.attendance ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.name\nFROM home_game AS T1\nINNER JOIN team AS T2 ON T1.team_id = T2.team_id_br\nWHERE T1.year = 1980\nORDER BY T1.attendance ASC\nLIMIT 1;"
        ]
    },
    "6096": {
        "db_id": "customers_and_addresses",
        "question": "Which contact channel codes were used less than 5 times?",
        "ground_truth": "SELECT channel_code FROM customer_contact_channels GROUP BY channel_code HAVING count(customer_id)  <  5",
        "amends": [
            "Do query from `customer_contact_channels` instead of `contacts` table. Do use `count(customer_id)` instead of `COUNT(*)` in the HAVING clause. Do filter for `count(customer_id) < 5` instead of `usage_count > 5` to find channels with fewer than 5 customer contacts. Do remove the `usage_count` alias from the SELECT list instead of including it. The amended query now correctly identifies channel codes with less than 5 customer contacts from the appropriate table."
        ],
        "rules": [
            "1) When answering about \"contact channel codes used less than 5 times\": use the \"customer_contact_channels\" table instead of \"contacts\" table. 2) When counting customer contacts per channel: use count(customer_id) instead of COUNT(*) to count the number of unique customer contacts. 3) When filtering for channels with fewer than 5 customer contacts: apply the condition count(customer_id) < 5 instead of usage_count > 5. 4) When selecting output columns: include only channel_code in the SELECT list and remove any usage_count alias."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT channel_code, COUNT(*) as usage_count FROM contacts GROUP BY channel_code HAVING usage_count > 5;",
            "SELECT channel_code\nFROM Customer_Contact_Channels\nGROUP BY channel_code\nHAVING COUNT(customer_id) < 5"
        ],
        "rule_sql": [
            "SELECT channel_code FROM Customer_Contact_Channels GROUP BY channel_code HAVING COUNT(customer_id) < 5"
        ]
    },
    "2493": {
        "db_id": "movie_1",
        "question": "What are the names of all directors who have made one movie except for the director named NULL?",
        "ground_truth": "SELECT director FROM Movie WHERE director != \"null\" GROUP BY director HAVING count(*)  =  1",
        "amends": [
            "Do reference the table as `Movie` instead of `movies` and use double quotes for the string literal `\"null\"` instead of single quotes with uppercase `'NULL'`. Do maintain the same logic of filtering out null director values with `director != \"null\"`, grouping by `director`, and having `count(*) = 1` to find directors with exactly one movie. The amended query now correctly matches the RIGHT_SQL's behavior with proper table reference and string literal formatting."
        ],
        "rules": [
            "1) When referencing the table containing director information: use the exact table name \"Movie\" instead of \"movies\". 2) When filtering out null director values: use the exact string literal \"null\" (lowercase, double quotes) instead of 'NULL'. 3) When counting movies per director: group by the \"director\" column and count all rows (count(*)) to find directors with exactly one movie. 4) When answering about directors who made one movie except null: filter out rows where director equals \"null\" using director != \"null\" before grouping and counting."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT director FROM movies WHERE director != 'NULL' GROUP BY director HAVING COUNT(*) = 1;",
            "SELECT director FROM Movie WHERE director != \"null\" GROUP BY director HAVING COUNT(*) = 1"
        ],
        "rule_sql": [
            "SELECT director FROM Movie WHERE director != \"null\" GROUP BY director HAVING COUNT(*) = 1"
        ]
    },
    "4580": {
        "db_id": "company_office",
        "question": "How many companies are in either \"Banking\" industry or \"Conglomerate\" industry?",
        "ground_truth": "SELECT count(*) FROM Companies WHERE Industry  =  \"Banking\" OR Industry  =  \"Conglomerate\"",
        "amends": [
            "Do use `OR` operator between industry conditions instead of `AND` operator, which would incorrectly require both values simultaneously. Do use consistent case for table name `Companies` and column name `Industry` instead of lowercase versions. Do use double quotes for string literals instead of single quotes. The amended query now correctly counts companies that are in either Banking OR Conglomerate industries instead of incorrectly requiring both conditions to be true simultaneously."
        ],
        "rules": [
            "1) When the question asks about companies in either \"Banking\" or \"Conglomerate\" industry: use the OR operator between industry conditions instead of AND operator. 2) When referring to the table and column names: use exact case \"Companies\" for table name and \"Industry\" for column name instead of lowercase versions. 3) When using string literals for industry values: use double quotes for \"Banking\" and \"Conglomerate\" instead of single quotes. 4) When counting companies that satisfy either industry condition: count rows where \"Industry\" equals \"Banking\" OR \"Industry\" equals \"Conglomerate\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM companies WHERE industry = 'Banking' AND industry = 'Conglomerate';",
            "SELECT COUNT(*) FROM \"Companies\" WHERE \"Industry\" = \"Banking\" OR \"Industry\" = \"Conglomerate\""
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Companies WHERE Industry = \"Banking\" OR Industry = \"Conglomerate\";"
        ]
    },
    "3569": {
        "db_id": "music_1",
        "question": "Find the distinct names of all songs that have a higher resolution than some songs in English.",
        "ground_truth": "SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  \"english\")",
        "amends": [
            "Do reference `song_name` instead of `name` and use table `song` instead of `songs`. Do use filter `languages = \"english\"` instead of `language = 'English'` and reference column `languages` instead of `language`. Do remove the unnecessary DISTINCT modifier instead of keeping it, as the subquery comparison already ensures uniqueness. The amended query now correctly filters for English language songs with resolution greater than the minimum resolution of English songs."
        ],
        "rules": [
            "1) When the question asks for song names: use the exact column token \"song_name\" from table \"song\" instead of \"name\" or \"songs\". 2) When filtering for English language songs: use the exact literal \"english\" (lowercase) and column \"languages\" instead of \"language\" or 'English'. 3) When comparing song resolutions: ensure the comparison is against the minimum resolution of English songs using the condition resolution > (SELECT MIN(resolution) FROM song WHERE languages = \"english\"). 4) When selecting distinct song names: do not use DISTINCT modifier as the subquery comparison already ensures uniqueness."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT name FROM songs WHERE resolution > (SELECT MIN(resolution) FROM songs WHERE language = 'English')",
            "SELECT song_name FROM song WHERE resolution > (SELECT MIN(resolution) FROM song WHERE languages = 'english')"
        ],
        "rule_sql": [
            "SELECT song_name FROM song WHERE resolution > (SELECT MIN(resolution) FROM song WHERE languages = 'english')"
        ]
    },
    "1247": {
        "db_id": "apartment_rentals",
        "question": "What apartment type codes and apartment numbers do the buildings managed by \"Kyle\" have?",
        "ground_truth": "SELECT T2.apt_type_code ,  T2.apt_number FROM Apartment_Buildings AS T1 JOIN Apartments AS T2 ON T1.building_id  =  T2.building_id WHERE T1.building_manager  =  \"Kyle\"",
        "amends": [
            "Do reference `T2.apt_type_code` and `T2.apt_number` instead of `apartment_type_code` and `apartment_number`. Do join `Apartment_Buildings AS T1` with `Apartments AS T2` on `T1.building_id = T2.building_id` instead of querying only the `buildings` table. Do filter on `T1.building_manager = \"Kyle\"` instead of `manager_name = 'Kyle'`. The amended query now correctly joins the building and apartment tables to retrieve apartment details for buildings managed by Kyle, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for apartment type codes and apartment numbers: use T2.apt_type_code and T2.apt_number as the output columns. 2) When combining building and apartment information: join Apartment_Buildings AS T1 with Apartments AS T2 on T1.building_id = T2.building_id using an inner match. 3) When filtering for buildings managed by \"Kyle\": use the condition T1.building_manager = \"Kyle\" exactly as specified. 4) When answering about apartment details for buildings managed by \"Kyle\": make sure the output order is T2.apt_type_code followed by T2.apt_number."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT apartment_type_code, apartment_number FROM buildings WHERE manager_name = 'Kyle';",
            "SELECT T2.apt_type_code, T2.apt_number\nFROM Apartment_Buildings AS T1\nJOIN Apartments AS T2 ON T1.building_id = T2.building_id\nWHERE T1.building_manager = 'Kyle'"
        ],
        "rule_sql": [
            "SELECT T2.apt_type_code, T2.apt_number\nFROM Apartment_Buildings AS T1\nINNER JOIN Apartments AS T2 ON T1.building_id = T2.building_id\nWHERE T1.building_manager = 'Kyle'\nORDER BY T2.apt_type_code, T2.apt_number;"
        ]
    },
    "3705": {
        "db_id": "baseball_1",
        "question": "How many team franchises are active, with active value 'Y'?",
        "ground_truth": "SELECT count(*) FROM team_franchise WHERE active = 'Y';",
        "amends": [
            "Do reference table `team_franchise` instead of `team_franchises` and filter on `active = 'Y'` instead of `active = 'N'`."
        ],
        "rules": [
            "1) When answering about \"How many team franchises are active, with active value 'Y'\": make sure the output order: count of active team franchises with active = 'Y'. 2) When the question mentions \"team franchises\": \"team franchises\" actually means \"team_franchise\" in schema. 3) When the question asks for \"count of team franchises\": compute the number of rows using the canonical key for team_franchise. 4) When filtering for active status: filter rows where the exact token \"active\" equals the exact literal 'Y' (not 'N')."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM team_franchises WHERE active = 'N';",
            "SELECT COUNT(*) FROM team_franchise WHERE active = 'Y';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS count_active_franchises FROM team_franchise WHERE active = 'Y';"
        ]
    },
    "4661": {
        "db_id": "college_3",
        "question": "List the course name of courses sorted by credits.",
        "ground_truth": "SELECT CName FROM COURSE ORDER BY Credits",
        "amends": [
            "Do select `CName` instead of `course_name` in the SELECT list. Do order by `Credits` instead of `course_name` in the ORDER BY clause. The amended query now correctly retrieves course names ordered by credit values as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for \"course name\": use the exact column token \"CName\" from the Course table. 2) When the question asks to sort by \"credits\": use the exact column token \"Credits\" from the Course table for ordering. 3) When answering about \"courses sorted by credits\": make sure the output order: \"CName\" sorted by \"Credits\" values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_name FROM courses ORDER BY course_name;",
            "SELECT CName FROM Course ORDER BY Credits;"
        ],
        "rule_sql": [
            "SELECT CName FROM Course ORDER BY Credits;"
        ]
    },
    "5874": {
        "db_id": "tracking_share_transactions",
        "question": "Show the number of transactions for different investors.",
        "ground_truth": "SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS GROUP BY investor_id",
        "amends": [
            "Do reference `investor_id` in the SELECT list instead of `investor_name` to ensure the GROUP BY clause correctly matches the selected columns. Do maintain the same aggregate function `COUNT(*)` and table source `transactions` without changes. The amended query now correctly groups by the same column that appears in the SELECT clause, ensuring the result set matches the expected behavior where each row shows the investor ID with their corresponding transaction count."
        ],
        "rules": [
            "1) When the question asks for \"number of transactions for different investors\": group by the exact column token \"investor_id\" from the \"transactions\" table. 2) When counting transactions per investor: use COUNT(*) to count all rows in each investor group. 3) When selecting output columns: include \"investor_id\" in the SELECT list to match the GROUP BY clause. 4) When organizing results by investor: ensure the output shows investor_id followed by the transaction count in that order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT investor_name, COUNT(*) FROM transactions GROUP BY investor_id;",
            "SELECT investor_id, COUNT(*) AS transaction_count FROM Transactions GROUP BY investor_id"
        ],
        "rule_sql": [
            "SELECT investor_id, COUNT(*) AS transaction_count FROM Transactions GROUP BY investor_id ORDER BY investor_id;"
        ]
    },
    "6170": {
        "db_id": "music_4",
        "question": "Return the issue dates of volumes that are by the artist named Gorgoroth.",
        "ground_truth": "SELECT T2.Issue_Date FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T1.Artist  =  \"Gorgoroth\"",
        "amends": [
            "Do join `artist AS T1` and `volume AS T2` with `ON T1.Artist_ID = T2.Artist_ID` instead of querying only the `volumes` table. Do select `T2.Issue_Date` instead of `issue_date` from the wrong table. Do filter on `T1.Artist = \"Gorgoroth\"` instead of `artist = 'Gorgoroth'` from the incorrect table. Do use proper table aliases and join relationships instead of assuming the artist column exists in the volumes table. The amended query now correctly retrieves issue dates by joining artist and volume tables through their relationship."
        ],
        "rules": [
            "1) When answering about \"issue dates of volumes by artist named Gorgoroth\": make sure the output order: T2.Issue_Date. 2) When the question mentions \"artist named Gorgoroth\": \"Gorgoroth\" actually means T1.Artist = \"Gorgoroth\" in schema. 3) When combining T1 (artist) and T2 (volume) for shared entities: link rows where T1.Artist_ID = T2.Artist_ID; keep only matching pairs (inner match). 4) When selecting issue dates: use T2.Issue_Date from the volume table instead of issue_date from the wrong table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT issue_date FROM volumes WHERE artist = 'Gorgoroth';",
            "SELECT T2.Issue_Date FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID = T2.Artist_ID WHERE T1.Artist = 'Gorgoroth'"
        ],
        "rule_sql": [
            "SELECT T2.Issue_Date FROM artist T1 JOIN volume T2 ON T1.Artist_ID = T2.Artist_ID WHERE T1.Artist = 'Gorgoroth' ORDER BY T2.Issue_Date;"
        ]
    },
    "2635": {
        "db_id": "inn_1",
        "question": "What are the name of rooms that cost more than the average.",
        "ground_truth": "SELECT roomName FROM Rooms WHERE basePrice  >  ( SELECT avg(basePrice) FROM Rooms );",
        "amends": [
            "Do reference `roomName` instead of `name` in the SELECT list. Do reference `basePrice` instead of `cost` in both the main filter and subquery. Do reference `Rooms` (capitalized) instead of `rooms` as the table name in both the main query and subquery. Do use `avg(basePrice)` instead of `AVG(cost)` in the subquery's aggregate function. The amended query now correctly matches the intended behavior of filtering for rooms where the base price exceeds the average base price across all rooms."
        ],
        "rules": [
            "1) When the question asks for room names: use the exact column token \"roomName\" from the Rooms table. 2) When comparing room prices to the average: use the exact column token \"basePrice\" instead of \"cost\" for price values. 3) When referencing the table containing room information: use the exact table name \"Rooms\" (capitalized) instead of \"rooms\". 4) When calculating the average price across all rooms: use the aggregate function avg(basePrice) to compute the average base price."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM rooms WHERE cost > (SELECT AVG(cost) FROM rooms);",
            "SELECT roomName FROM Rooms WHERE basePrice > (SELECT AVG(basePrice) FROM Rooms)"
        ],
        "rule_sql": [
            "SELECT roomName FROM Rooms WHERE basePrice > (SELECT AVG(basePrice) FROM Rooms);"
        ]
    },
    "821": {
        "db_id": "chinook_1",
        "question": "Hom many albums does the artist \"Metallica\" have?",
        "ground_truth": "SELECT COUNT(*) FROM ALBUM AS T1 JOIN ARTIST AS T2 ON T1.ArtistId  =  T2.ArtistId WHERE T2.Name  =  \"Metallica\"",
        "amends": [
            "Do join `ALBUM AS T1` with `ARTIST AS T2` on `T1.ArtistId = T2.ArtistId` instead of querying only the `artists` table. Do filter on `T2.Name = \"Metallica\"` instead of `name = 'Metallica'` to count albums by the specific artist rather than counting the artist record itself. The amended query now correctly counts albums by Metallica instead of just checking if the artist exists."
        ],
        "rules": [
            "1) When answering about \"how many albums does the artist Metallica have\": make sure the output order: COUNT of albums\n2) When the question mentions \"Metallica\": \"Metallica\" actually means \"T2.Name = 'Metallica'\" in schema\n3) When combining T1 and T2 for shared entities: link rows where T1.ArtistId = T2.ArtistId; keep only matching pairs (inner match)\n4) When counting albums: compute the number of rows using the canonical key token for albums (T1.AlbumId)\n5) When handling text literals: do not change case, spacing, or punctuation - use exact literal 'Metallica'"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM artists WHERE name = 'Metallica';",
            "SELECT COUNT(*) FROM Album AS T1 JOIN Artist AS T2 ON T1.ArtistId = T2.ArtistId WHERE T2.Name = \"Metallica\""
        ],
        "rule_sql": [
            "SELECT COUNT(Album.AlbumId) \nFROM Album \nJOIN Artist ON Album.ArtistId = Artist.ArtistId \nWHERE Artist.Name = 'Metallica'"
        ]
    },
    "1946": {
        "db_id": "cinema",
        "question": "What are the title and director of each film?",
        "ground_truth": "SELECT title ,  directed_by FROM film",
        "amends": [
            "Do select `directed_by` instead of `actor` to retrieve the correct column. Do reference table `film` instead of `films` to use the proper table name. The amended query now correctly retrieves film titles with their directors instead of actors, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"title and director of each film\": select \"title\" and \"directed_by\" columns from the \"film\" table. 2) When the question mentions \"film\": use the exact table name \"film\" (not \"films\"). 3) When the question asks for \"director\": the exact column name is \"directed_by\" (not \"actor\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title, actor FROM films;",
            "SELECT Title, Directed_by FROM film;"
        ],
        "rule_sql": [
            "SELECT Title, Directed_by FROM film;"
        ]
    },
    "5723": {
        "db_id": "dorm_1",
        "question": "What is the average and oldest age for each gender of student?",
        "ground_truth": "SELECT avg(age) ,  max(age) ,  sex FROM student GROUP BY sex",
        "amends": [
            "Do use `avg(age)` without an alias instead of `AVG(age) as average_age`, and do use `max(age)` instead of `MIN(age) as oldest_age` to correctly calculate maximum age. Do reference column `sex` instead of `gender` and table `student` instead of `students` to match the correct schema. Do remove the alias assignments for the aggregate functions instead of keeping them, as the right query uses unaliased expressions. The amended query now correctly calculates average and maximum age grouped by sex instead of incorrectly calculating minimum age as oldest age.",
            "Do move the `sex` column to the end of the SELECT list instead of placing it first, maintaining the same GROUP BY clause and aggregate functions `avg(age)` and `max(age)` to preserve identical grouping logic and result set content. The amended query now matches RIGHT_SQL's behavior with identical output despite the column ordering difference."
        ],
        "rules": [
            "1) When the question mentions \"gender\": \"gender\" actually means \"sex\" in schema. 2) When the question asks for \"oldest age\": use max(age) instead of min(age) to correctly calculate maximum age. 3) When the question asks for aggregates \"for each gender\": organize results by sex and compute requested aggregates per group. 4) When producing output: do not assign aliases to aggregate functions like avg(age) and max(age). 5) When referencing the student table: use table \"student\" instead of \"students\" to match the correct schema.",
            "1) When answering about \"average and oldest age for each gender of student\": make sure the output order: avg(age), max(age), sex\n2) When the question asks for \"each gender of student\": organize results by the token for gender (sex) and compute requested aggregates per group\n3) When the question asks for \"average age\": compute the average of the exact token age\n4) When the question asks for \"oldest age\": compute the maximum of the exact token age"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT gender, AVG(age) as average_age, MIN(age) as oldest_age FROM students GROUP BY gender;",
            "SELECT sex, avg(age), max(age) FROM Student GROUP BY sex",
            "SELECT avg(age), max(age), sex FROM Student GROUP BY sex"
        ],
        "rule_sql": [
            "SELECT AVG(Age), MAX(Age), Sex FROM Student GROUP BY Sex;"
        ]
    },
    "4575": {
        "db_id": "company_office",
        "question": "List the names of buildings that have no company office.",
        "ground_truth": "SELECT name FROM buildings WHERE id NOT IN (SELECT building_id FROM Office_locations)",
        "amends": [
            "Do reference `id` in the main filter instead of `building_id` to correctly identify building records. Do use `Office_locations` as the subquery source table instead of `companies` to properly check for building occupancy. Do maintain the `NOT IN` logic structure but with the corrected column and table references to ensure the query accurately identifies unoccupied buildings by checking against the office locations table rather than a companies table."
        ],
        "rules": [
            "1) When answering about \"buildings that have no company office\": use the \"id\" column from the \"buildings\" table as the main identifier instead of \"building_id\". 2) When checking for building occupancy: reference the \"Office_locations\" table instead of the \"companies\" table to properly identify buildings with offices. 3) When filtering for buildings without offices: use the NOT IN logic structure with the corrected column and table references to ensure accurate identification of unoccupied buildings."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM buildings WHERE building_id NOT IN (SELECT building_id FROM companies)",
            "SELECT name FROM buildings WHERE id NOT IN (SELECT building_id FROM Office_locations)"
        ],
        "rule_sql": [
            "SELECT name FROM buildings WHERE id NOT IN (SELECT building_id FROM Office_locations);"
        ]
    },
    "3126": {
        "db_id": "assets_maintenance",
        "question": "Which assets have 2 parts and have less than 2 fault logs? List the asset id and detail.",
        "ground_truth": "SELECT T1.asset_id ,  T1.asset_details FROM Assets AS T1 JOIN Asset_Parts AS T2 ON T1.asset_id  =  T2.asset_id GROUP BY T1.asset_id HAVING count(*)  =  2 INTERSECT SELECT T1.asset_id ,  T1.asset_details FROM Assets AS T1 JOIN Fault_Log AS T2 ON T1.asset_id  =  T2.asset_id GROUP BY T1.asset_id HAVING count(*)  <  2",
        "amends": [
            "Do use `INTERSECT` with two separate grouped queries instead of a single `WHERE` clause with multiple conditions. Do join `Assets AS T1` with `Asset_Parts AS T2` on `T1.asset_id = T2.asset_id` and group by `T1.asset_id` with `HAVING count(*) = 2` instead of filtering `parts_count = 2`. Do join `Assets AS T1` with `Fault_Log AS T2` on `T1.asset_id = T2.asset_id` and group by `T1.asset_id` with `HAVING count(*) < 2` instead of filtering `fault_logs_count >= 2`. Do select `T1.asset_details` instead of `detail` and use proper table aliasing throughout. The amended query now correctly identifies assets with exactly 2 parts and fewer than 2 fault logs using set intersection logic instead of incorrect conditional filtering."
        ],
        "rules": [
            "1) When answering about assets with exactly 2 parts: join Assets as T1 with Asset_Parts as T2 on T1.asset_id = T2.asset_id, group by T1.asset_id, and keep only groups where the count of rows equals 2. 2) When answering about assets with fewer than 2 fault logs: join Assets as T1 with Fault_Log as T2 on T1.asset_id = T2.asset_id, group by T1.asset_id, and keep only groups where the count of rows is less than 2. 3) When combining multiple conditions on the same entity: use set intersection between the results of the two grouped queries instead of a single WHERE clause with multiple conditions. 4) When selecting asset details: use T1.asset_details instead of detail as the output column. 5) When counting parts or fault logs: count the number of rows in the joined tables using count(*) rather than relying on pre-aggregated columns like parts_count or fault_logs_count."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT asset_id, detail FROM assets WHERE parts_count = 2 AND fault_logs_count >= 2;",
            "SELECT T1.asset_id, T1.asset_details\nFROM Assets AS T1\nJOIN Asset_Parts AS T2 ON T1.asset_id = T2.asset_id\nGROUP BY T1.asset_id\nHAVING COUNT(*) = 2\n\nINTERSECT\n\nSELECT T1.asset_id, T1.asset_details\nFROM Assets AS T1\nJOIN Fault_Log AS T2 ON T1.asset_id = T2.asset_id\nGROUP BY T1.asset_id\nHAVING COUNT(*) < 2"
        ],
        "rule_sql": [
            "SELECT T1.asset_id, T1.asset_details\nFROM (\n    SELECT a.asset_id, a.asset_details\n    FROM Assets a\n    JOIN Asset_Parts ap ON a.asset_id = ap.asset_id\n    GROUP BY a.asset_id\n    HAVING COUNT(*) = 2\n) T1\nINNER JOIN (\n    SELECT a.asset_id\n    FROM Assets a\n    LEFT JOIN Fault_Log fl ON a.asset_id = fl.asset_id\n    GROUP BY a.asset_id\n    HAVING COUNT(*) < 2\n) T2 ON T1.asset_id = T2.asset_id;"
        ]
    },
    "6157": {
        "db_id": "music_4",
        "question": "What are the maximum and minimum week on top of all volumes?",
        "ground_truth": "SELECT max(Weeks_on_Top) ,  min(Weeks_on_Top) FROM volume",
        "amends": [
            "Do use column name `Weeks_on_Top` instead of `week` in both aggregate functions. Do reference table `volume` instead of `volumes` as the data source. The amended query now correctly calculates the maximum and minimum values from the Weeks_on_Top column in the volume table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for maximum and minimum values of \"week on top of all volumes\": use the exact column name \"Weeks_on_Top\" from the volume table. 2) When referencing the data source for volume information: use the exact table name \"volume\" (not \"volumes\"). 3) When computing aggregate functions on the \"Weeks_on_Top\" column: calculate both MAX(\"Weeks_on_Top\") and MIN(\"Weeks_on_Top\") to find the maximum and minimum values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(week) AS max_week, MIN(week) AS min_week FROM volumes;",
            "SELECT MAX(Weeks_on_Top) AS max_weeks, MIN(Weeks_on_Top) AS min_weeks FROM volume;"
        ],
        "rule_sql": [
            "SELECT MAX(\"Weeks_on_Top\") AS max_weeks, MIN(\"Weeks_on_Top\") AS min_weeks FROM \"volume\";"
        ]
    },
    "388": {
        "db_id": "flight_1",
        "question": "What are the origins of all flights that are headed to Honolulu?",
        "ground_truth": "SELECT origin FROM Flight WHERE destination  =  \"Honolulu\"",
        "amends": [
            "Do reference the table as `Flight` instead of `flights` to match the correct table name. Do use double quotes `\"Honolulu\"` instead of single quotes `'Honolulu'` for the string literal in the WHERE filter. The amended query now correctly references the intended table and uses consistent string quoting to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about flight origins headed to Honolulu: use the table name \"Flight\" exactly as specified in the schema. 2) When filtering for destination Honolulu: use the exact string literal \"Honolulu\" with double quotes as shown in the amends. 3) When selecting origin information: ensure the output column is \"origin\" from the \"Flight\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT origin FROM flights WHERE destination = 'Honolulu';",
            "SELECT origin FROM flight WHERE destination = \"Honolulu\""
        ],
        "rule_sql": [
            "SELECT origin FROM Flight WHERE destination = \"Honolulu\""
        ]
    },
    "914": {
        "db_id": "insurance_fnol",
        "question": "List all the policy types used by the customer enrolled in the most policies.",
        "ground_truth": "SELECT DISTINCT t3.policy_type_code FROM customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id  =  t2.customer_id JOIN available_policies AS t3 ON t2.policy_id  =  t3.policy_id WHERE t1.customer_name  =  (SELECT t1.customer_name FROM customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_name ORDER BY count(*) DESC LIMIT 1)",
        "amends": [
            "Do use explicit table joins with `customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id = t2.customer_id JOIN available_policies AS t3 ON t2.policy_id = t3.policy_id` instead of querying only the `policies` table. Do reference `t3.policy_type_code` instead of `policy_type` from an unspecified source. Do filter by `t1.customer_name = (subquery)` instead of `customer_id = (subquery)`. Do use a subquery that groups by `t1.customer_name` and orders by `count(*) DESC` instead of grouping by `customer_id`. Do maintain the `DISTINCT` selection but apply it to the correct column from the joined tables. The amended query now correctly identifies policy types for the customer with the most policies by joining the necessary tables and using the appropriate correlation through customer names rather than IDs."
        ],
        "rules": [
            "1) When answering about \"policy types used by the customer enrolled in the most policies\": make sure the output order: t3.policy_type_code\n2) When combining tables for customer policy information: link rows where t1.customer_id = t2.customer_id and t2.policy_id = t3.policy_id; keep only matching pairs (inner match).\n3) When the question mentions \"customer enrolled in the most policies\": find the customer with maximum policy count by grouping by t1.customer_name and ordering by count(*) DESC.\n4) When filtering for the top customer: use t1.customer_name = (subquery) instead of customer_id filtering.\n5) When selecting policy types: use t3.policy_type_code instead of policy_type from an unspecified source.\n6) When the question asks for distinct policy types: compute the number of unique values of t3.policy_type_code."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT policy_type \nFROM policies \nWHERE customer_id = (SELECT customer_id FROM policies GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1);",
            "SELECT DISTINCT t3.policy_type_code\nFROM customers AS t1\nJOIN customers_policies AS t2 ON t1.customer_id = t2.customer_id\nJOIN available_policies AS t3 ON t2.policy_id = t3.policy_id\nWHERE t1.customer_name = (\n    SELECT t1.customer_name\n    FROM customers AS t1\n    JOIN customers_policies AS t2 ON t1.customer_id = t2.customer_id\n    GROUP BY t1.customer_name\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)"
        ],
        "rule_sql": [
            "SELECT DISTINCT t3.policy_type_code\nFROM Customers t1\nJOIN Customers_Policies t2 ON t1.Customer_ID = t2.Customer_ID\nJOIN Available_Policies t3 ON t2.Policy_ID = t3.Policy_ID\nWHERE t1.Customer_name = (\n    SELECT t1.Customer_name\n    FROM Customers t1\n    JOIN Customers_Policies t2 ON t1.Customer_ID = t2.Customer_ID\n    GROUP BY t1.Customer_name\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)\nORDER BY t3.policy_type_code;"
        ]
    },
    "6810": {
        "db_id": "flight_4",
        "question": "What is the number of airlines based in Russia?",
        "ground_truth": "SELECT count(*) FROM airlines WHERE country  =  'Russia'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM airlines WHERE country = 'Russia';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM airlines WHERE country = 'Russia';"
        ]
    },
    "4324": {
        "db_id": "tracking_grants_for_research",
        "question": "What is the total grant amount of the organisations described as research?",
        "ground_truth": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'",
        "amends": [
            "Do join `Grants AS T1` and `Organisations AS T2` on `T1.organisation_id = T2.organisation_id` instead of querying only the `organisations` table. Do add a second join to `organisation_Types AS T3` on `T2.organisation_type = T3.organisation_type` instead of omitting this relationship. Do filter on `T3.organisation_type_description = 'Research'` instead of filtering on `description = 'research'` which used the wrong column and case sensitivity. Do aggregate `sum(grant_amount)` from the Grants table instead of summing from the Organisations table where this column doesn't exist. The amended query now correctly joins across three tables to filter by organization type description and sum grant amounts from the appropriate table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about total grant amount of organisations described as research: make sure the output order: sum of grant_amount from Grants table. 2) When the question mentions \"organisations described as research\": \"research\" actually means \"Research\" in schema with exact case sensitivity. 3) When combining Grants AS T1 and Organisations AS T2: link rows where T1.organisation_id = T2.organisation_id and keep only matching pairs (inner match). 4) When combining Organisations AS T2 and organisation_Types AS T3: link rows where T2.organisation_type = T3.organisation_type and keep only matching pairs (inner match). 5) When filtering for research organisations: use T3.organisation_type_description = 'Research' with exact case and spacing. 6) When aggregating grant amounts: sum T1.grant_amount from the Grants table instead of any other table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(grant_amount) FROM organisations WHERE description = 'research';",
            "SELECT SUM(T1.grant_amount) AS total_grant_amount\nFROM Grants AS T1\nJOIN Organisations AS T2 ON T1.organisation_id = T2.organisation_id\nJOIN Organisation_Types AS T3 ON T2.organisation_type = T3.organisation_type\nWHERE T3.organisation_type_description = 'Research'"
        ],
        "rule_sql": [
            "SELECT SUM(T1.grant_amount) \nFROM Grants AS T1\nINNER JOIN Organisations AS T2 ON T1.organisation_id = T2.organisation_id\nINNER JOIN Organisation_Types AS T3 ON T2.organisation_type = T3.organisation_type\nWHERE T3.organisation_type_description = 'Research'"
        ]
    },
    "1620": {
        "db_id": "customers_and_invoices",
        "question": "How many distinct order ids correspond to each product?",
        "ground_truth": "SELECT product_id ,  count(DISTINCT order_id) FROM Order_items GROUP BY product_id",
        "amends": [
            "Do reference the `Order_items` table instead of the `orders` table. Do count `DISTINCT order_id` instead of using `COUNT(*)` without distinct. Do add the `order_id` column reference in the aggregate function instead of omitting it. The amended query now correctly counts unique orders per product from the appropriate table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"distinct order ids per product\": make sure the output order: product_id first, then count of distinct order_ids. 2) When the question mentions \"order ids\": \"order ids\" actually means \"order_id in Order_Items table\". 3) When the question asks for \"distinct order ids\": compute the number of unique values of the exact token \"order_id\". 4) When the question says \"per product\": organize results by \"product_id\" and compute requested aggregates per group. 5) When counting distinct order ids: use the exact column token \"order_id\" from the Order_Items table as the counting key."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT product_id, COUNT(*) FROM orders GROUP BY product_id;",
            "SELECT product_id, COUNT(DISTINCT order_id) AS distinct_order_count FROM Order_Items GROUP BY product_id;"
        ],
        "rule_sql": [
            "SELECT product_id, COUNT(DISTINCT order_id) AS distinct_order_count FROM Order_Items GROUP BY product_id ORDER BY product_id;"
        ]
    },
    "2707": {
        "db_id": "storm_record",
        "question": "What are the names and damage in millions for storms, ordered by their max speeds descending?",
        "ground_truth": "SELECT name ,  damage_millions_USD FROM storm ORDER BY max_speed DESC",
        "amends": [
            "Do select `damage_millions_USD` instead of `damage` to use the correct column name. Do reference table `storm` instead of `storms` to use the proper table name. Do order by `max_speed DESC` instead of `max_speed ASC` to sort in descending order rather than ascending. The amended query now correctly retrieves storm names with damage in millions of USD from the storm table, sorted by maximum wind speed from highest to lowest."
        ],
        "rules": [
            "1) When the question asks for \"damage in millions\": use the exact column name \"damage_millions_USD\" from the storm table. 2) When the question refers to \"storms\": use the exact table name \"storm\" (singular form). 3) When the question specifies \"ordered by their max speeds descending\": sort the results by \"max_speed\" column in descending order (highest to lowest). 4) When answering about storm names and damage: make sure the output order is \"name\" followed by \"damage_millions_USD\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, damage FROM storms ORDER BY max_speed ASC;",
            "SELECT Name, Damage_millions_USD FROM storm ORDER BY Max_speed DESC;"
        ],
        "rule_sql": [
            "SELECT Name, Damage_millions_USD FROM storm ORDER BY Max_speed DESC;"
        ]
    },
    "1736": {
        "db_id": "gymnast",
        "question": "How many gymnasts are there?",
        "ground_truth": "SELECT count(*) FROM gymnast",
        "amends": [
            "Do query the `gymnast` table instead of the `athletes` table. Do count all records without filtering by sport instead of filtering for `sport = 'basketball'`. The amended query now correctly counts all gymnasts rather than filtering for basketball athletes in the wrong table."
        ],
        "rules": [
            "1) When answering about \"How many gymnasts are there?\": query the \"gymnast\" table instead of the \"athletes\" table. 2) When counting all gymnasts: count all records without filtering by sport instead of filtering for 'basketball'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM athletes WHERE sport = 'basketball';",
            "SELECT COUNT(*) FROM gymnast;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM gymnast;"
        ]
    },
    "2144": {
        "db_id": "local_govt_in_alabama",
        "question": "List the service id and details for the events.",
        "ground_truth": "SELECT service_id ,  event_details FROM EVENTS",
        "amends": [
            "Do use column alias `event_details` instead of `details` to match the correct column name. Do reference the table as `EVENTS` instead of `events` to maintain proper case sensitivity. The amended query now correctly selects the appropriate columns and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting from the events table: use the exact table name \"EVENTS\" with uppercase letters to maintain case sensitivity. 2) When retrieving event details: use the column alias \"event_details\" instead of \"details\" to match the correct column name in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT service_id, details FROM events",
            "SELECT Service_ID, Event_Details FROM Events;"
        ],
        "rule_sql": [
            "SELECT Service_ID, Event_Details AS event_details FROM EVENTS"
        ]
    },
    "4975": {
        "db_id": "soccer_2",
        "question": "What are the names and enrollment numbers for colleges that have more than 10000 enrolled and are located in Louisiana?",
        "ground_truth": "SELECT cName ,  enr FROM College WHERE enr  >  10000 AND state = \"LA\"",
        "amends": [
            "Do use table alias `College` instead of `colleges` and column aliases `cName` and `enr` instead of `name` and `enrollment`. Do use state code `\"LA\"` instead of full state name `'Louisiana'` while keeping the same enrollment filter `> 10000`. The amended query now correctly references the actual table and column names with proper state abbreviation formatting."
        ],
        "rules": [
            "1) When answering about college names and enrollment numbers: use table alias \"College\" and column aliases \"cName\" and \"enr\" for output columns in that order. 2) When filtering by enrollment numbers greater than 10000: apply the condition \"enr\" > 10000. 3) When filtering by state location in Louisiana: use state code \"LA\" instead of the full state name 'Louisiana'. 4) When selecting from the College table: use the exact table name \"College\" with proper double quotes as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, enrollment FROM colleges WHERE enrollment > 10000 AND state = 'Louisiana';",
            "SELECT cName, enr FROM College WHERE state = 'LA' AND enr > 10000;"
        ],
        "rule_sql": [
            "SELECT \"cName\" AS \"cName\", \"enr\" AS \"enr\" FROM \"College\" WHERE \"enr\" > 10000 AND \"state\" = 'LA';"
        ]
    },
    "5042": {
        "db_id": "soccer_2",
        "question": "Find names of all colleges whose enrollment is greater than that of all colleges in the FL state.",
        "ground_truth": "SELECT cName FROM college WHERE enr  >  (SELECT max(enr) FROM college WHERE state  =  'FL')",
        "amends": [
            "Do use column name `cName` instead of `name` and table name `college` instead of `colleges` to match the correct schema. Do use column alias `enr` instead of `enrollment` for the enrollment field in both the main query and subquery. Do maintain the same subquery structure with `max(enr)` instead of `MAX(enrollment)` but keep the same logical comparison of enrollment values greater than the maximum enrollment in Florida. The corrected query preserves the original intent of finding colleges with enrollment greater than the maximum enrollment in Florida while using the proper column and table names from the schema."
        ],
        "rules": [
            "1) When the question asks for college names: use column \"cName\" from the correct table structure. 2) When referring to the colleges table: use table name \"college\" instead of \"colleges\" to match the schema. 3) When accessing enrollment data: use column alias \"enr\" instead of \"enrollment\" in both main query and subqueries. 4) When comparing enrollment values: use the maximum enrollment value from Florida colleges as the comparison threshold. 5) When filtering for Florida colleges: use the literal value 'FL' exactly as specified to identify colleges in that state."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM colleges WHERE enrollment > (SELECT MAX(enrollment) FROM colleges WHERE state = 'FL');",
            "SELECT cName FROM College WHERE enr > (SELECT MAX(enr) FROM College WHERE state = 'FL')"
        ],
        "rule_sql": [
            "SELECT cName FROM College WHERE enr > (SELECT MAX(enr) FROM College WHERE state = 'FL')"
        ]
    },
    "171": {
        "db_id": "bike_1",
        "question": "What are names of stations that have average bike availability above 10 and are not located in San Jose city?",
        "ground_truth": "SELECT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available)  >  10 EXCEPT SELECT name FROM station WHERE city  =  \"San Jose\"",
        "amends": [
            "Do add table `status AS T2` with a `JOIN` on `T1.id = T2.station_id` instead of querying only the `stations` table. Do change the aggregate calculation to use `avg(bikes_available)` in the `HAVING` clause instead of the non-aggregate column `avg_bikes_available` in the `WHERE` clause. Do use `GROUP BY T2.station_id` to support the aggregate function instead of no grouping. Do replace the simple `WHERE city != 'San Jose'` filter with an `EXCEPT` clause that excludes stations where `city = \"San Jose\"` instead of using inequality comparison. Do reference the table as `station AS T1` instead of `stations` and select `T1.name` instead of just `name`. The amended query now correctly calculates average bike availability from the status table and properly excludes San Jose stations using set operations."
        ],
        "rules": [
            "1) When answering about station names with average bike availability above 10: calculate the average of bikes_available from table status AS T2 grouped by station_id instead of using a direct column avg_bikes_available. 2) When combining station and status tables: link rows where T1.id = T2.station_id and keep only matching pairs (inner match). 3) When the question asks for stations not located in San Jose city: exclude stations where city = \"San Jose\" using set operations instead of inequality comparison. 4) When selecting station names: reference the table as station AS T1 and select T1.name instead of just name. 5) When computing aggregates: use GROUP BY T2.station_id to support the average calculation in the HAVING clause."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM stations WHERE avg_bikes_available > 10 AND city != 'San Jose';",
            "SELECT T1.name\nFROM station AS T1\nJOIN status AS T2 ON T1.id = T2.station_id\nGROUP BY T2.station_id\nHAVING AVG(T2.bikes_available) > 10\nEXCEPT\nSELECT T1.name\nFROM station AS T1\nWHERE T1.city = 'San Jose'"
        ],
        "rule_sql": [
            "SELECT T1.name \nFROM station AS T1 \nINNER JOIN status AS T2 ON T1.id = T2.station_id \nWHERE T1.city != 'San Jose' \nGROUP BY T2.station_id \nHAVING AVG(T2.bikes_available) > 10"
        ]
    },
    "6003": {
        "db_id": "game_1",
        "question": "List ids for all student who are on scholarship.",
        "ground_truth": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'",
        "amends": [
            "Do select `StuID` instead of `id` and use table `Sportsinfo` instead of `students`. Do filter on `onscholarship = 'Y'` instead of `scholarship = 'no'` to correctly identify scholarship recipients. The amended query now matches the intended behavior of selecting student IDs from the sports information table where students are on scholarship."
        ],
        "rules": [
            "1) When answering about \"student who are on scholarship\": select \"StuID\" from table \"Sportsinfo\" instead of \"id\" from table \"students\". 2) When filtering for scholarship recipients: use condition \"onscholarship = 'Y'\" instead of \"scholarship = 'no'\". 3) When the question mentions \"scholarship\": it actually means \"onscholarship\" column in the schema with literal value 'Y'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM students WHERE scholarship = 'no';",
            "SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Y'"
        ],
        "rule_sql": [
            "SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Y'"
        ]
    },
    "4600": {
        "db_id": "entertainment_awards",
        "question": "List the name of artworks whose type is not \"Program Talent Show\".",
        "ground_truth": "SELECT Name FROM artwork WHERE TYPE != \"Program Talent Show\"",
        "amends": [
            "Do use `Name` instead of `name` for the column selection to match the correct column name. Do reference `artwork` instead of `artworks` as the table name to use the correct table. Do use `!=` instead of `=` in the WHERE clause to filter for records where TYPE is not equal to 'Program Talent Show' instead of equal to it. Do use single quotes `'Program Talent Show'` instead of double quotes for the string literal to maintain proper SQL syntax. The amended query now correctly selects names from the artwork table where the type is not 'Program Talent Show', matching the right SQL's behavior."
        ],
        "rules": [
            "1) When selecting the name of artworks: use the exact column token \"Name\" from the artwork table. 2) When filtering by artwork type: use the exact literal 'Program Talent Show' with single quotes and proper case. 3) When excluding records of a specific type: use the inequality operator (!=) to filter for records where TYPE is not equal to the specified literal. 4) When referencing the artwork table: use the exact table name \"artwork\" instead of \"artworks\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM artworks WHERE type = 'Program Talent Show'",
            "SELECT Name FROM artwork WHERE Type != 'Program Talent Show'"
        ],
        "rule_sql": [
            "SELECT Name FROM artwork WHERE Type != 'Program Talent Show';"
        ]
    },
    "3924": {
        "db_id": "hospital_1",
        "question": "Find the patient who most recently stayed in room 111.",
        "ground_truth": "SELECT patient FROM stay WHERE room  =  111 ORDER BY staystart DESC LIMIT 1",
        "amends": [
            "Do select `patient` instead of `*` and from `stay` instead of `patients`. Do filter with `room = 111` instead of `room_number = 111` and move this filter to the `WHERE` clause instead of placing it after `LIMIT`. Do order by `staystart DESC` instead of `admission_date DESC` while keeping `LIMIT 1`. The amended query now correctly retrieves the most recent patient in room 111 from the stay table."
        ],
        "rules": [
            "1) When answering about \"the patient who most recently stayed in room 111\": make sure the output order: patient\n2) When the question mentions \"stayed in room 111\": \"room 111\" actually means \"room = 111 in schema\" and this filter must be placed in the WHERE clause\n3) When the question mentions \"most recently\": order rows by staystart in descending direction and keep the first 1 row\n4) When selecting from tables: use the stay table instead of patients table\n5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms\n6) When handling text literals: do not change case, spacing, or punctuation"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM patients ORDER BY admission_date DESC LIMIT 1 WHERE room_number = 111;",
            "SELECT patient FROM Stay WHERE room = 111 ORDER BY StayStart DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Patient FROM Stay WHERE Room = 111 ORDER BY StayStart DESC LIMIT 1"
        ]
    },
    "1673": {
        "db_id": "theme_gallery",
        "question": "What is the theme and artist name for the exhibition with a ticket price higher than the average?",
        "ground_truth": "SELECT T1.theme ,  T2.name FROM exhibition AS T1 JOIN artist AS T2 ON T1.artist_id  =  T2.artist_id WHERE T1.ticket_price  >  (SELECT avg(ticket_price) FROM exhibition)",
        "amends": [
            "Do join `artist AS T2` on `T1.artist_id = T2.artist_id` instead of querying only the `exhibitions` table. Do select `T2.name` instead of `artist_name` and use `T1.theme` instead of `theme`. Do reference the table as `exhibition AS T1` instead of `exhibitions` in both the main query and subquery. Do use the correct table alias `T1` for column references instead of direct column names without qualification. The amended query now correctly joins artist data and uses proper table aliasing to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"exhibition theme and artist name\": make sure the output order: T1.theme, T2.name\n2) When combining exhibition and artist tables: link rows where T1.artist_id = T2.artist_id and keep only matching pairs (inner match).\n3) When filtering for ticket prices higher than average: compare T1.ticket_price against the average of T1.ticket_price from all exhibitions.\n4) When selecting artist information: use T2.name instead of artist_name column from exhibitions table.\n5) When referencing exhibition table: use exhibition AS T1 instead of exhibitions and qualify all column references with T1 alias.\n6) When computing average ticket price: calculate AVG(T1.ticket_price) from the exhibition table in the subquery."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT theme, artist_name FROM exhibitions WHERE ticket_price > (SELECT AVG(ticket_price) FROM exhibitions);",
            "SELECT T1.Theme, T2.Name\nFROM exhibition AS T1\nJOIN artist AS T2 ON T1.Artist_ID = T2.Artist_ID\nWHERE T1.Ticket_Price > (\n    SELECT AVG(Ticket_Price)\n    FROM exhibition\n)"
        ],
        "rule_sql": [
            "SELECT T1.Theme, T2.Name\nFROM exhibition AS T1\nINNER JOIN artist AS T2 ON T1.Artist_ID = T2.Artist_ID\nWHERE T1.Ticket_Price > (SELECT AVG(T1_inner.Ticket_Price) FROM exhibition AS T1_inner)"
        ]
    },
    "2396": {
        "db_id": "candidate_poll",
        "question": "Which poll resource provided the most number of candidate information?",
        "ground_truth": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use `poll_source` instead of `poll_resource` for the column name in both the SELECT list and GROUP BY clause. Do use table name `candidate` instead of `candidates` as the data source. Do remove the explicit column alias `candidate_count` and instead use the aggregate function `count(*)` directly in the ORDER BY clause instead of referencing an alias. The amended query now correctly references the proper column and table names while maintaining the same aggregation and ordering logic to identify the poll source with the highest candidate count.",
            "Do use lowercase `poll_source` in both the SELECT list and GROUP BY clause instead of mixed-case `Poll_Source`. Do maintain the aggregate function `count(*)` in the ORDER BY clause instead of changing its case. The amended query now correctly uses consistent lowercase column naming throughout while preserving the same logical behavior of identifying the most frequent poll source.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, as the query only needs to return the poll_source value with the highest count rather than displaying both the source and its count. Do keep the `GROUP BY poll_source` and `ORDER BY count(*) DESC LIMIT 1` unchanged since they correctly identify the poll_source with the maximum occurrence count. The amended query now matches RIGHT_SQL's behavior by returning only the poll_source value with the highest frequency."
        ],
        "rules": [
            "1) When the question mentions \"poll resource\": \"poll resource\" actually means \"poll_source\" in schema. 2) When the question asks about candidate information: use table \"candidate\" instead of \"candidates\" as the data source. 3) When counting entities: use count(*) to compute the number of rows. 4) When the question asks for \"most number\" or \"highest count\": rank rows by count(*) in descending order and keep the first 1 row. 5) When grouping by poll_source: organize results by poll_source and compute count(*) per group. 6) When producing output: include poll_source and count(*) in the output columns.",
            "1) When the question asks about \"poll resource\": use the exact column name \"poll_source\" in lowercase as shown in the schema. 2) When counting entities in the candidate table: use count(*) to count all rows. 3) When grouping by poll_source: organize results by the \"poll_source\" column and compute counts per group. 4) When the question asks for \"the most number\": rank groups by count in descending order and keep only the top result. 5) When producing output: maintain the column order with poll_source first followed by the count.",
            "1) When answering about \"which poll resource provided the most number of candidate information\": make sure the output order: only return the poll_source value with the highest count. 2) When counting candidate information per poll resource: compute the number of rows using the canonical counting method (COUNT(*)) for each poll_source group. 3) When the question asks for the \"most\" or \"highest\" count: rank rows by the count in descending order and keep only the first row (top result). 4) When grouping by poll_source: organize results by the poll_source column and compute the count per group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT poll_resource, COUNT(*) as candidate_count FROM candidates GROUP BY poll_resource ORDER BY candidate_count DESC LIMIT 1;",
            "SELECT Poll_Source, COUNT(*) FROM candidate GROUP BY Poll_Source ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT poll_source, COUNT(*) FROM candidate GROUP BY poll_source ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT poll_source, COUNT(*) AS count\nFROM candidate\nGROUP BY poll_source\nORDER BY count DESC\nLIMIT 1;"
        ]
    },
    "5744": {
        "db_id": "dorm_1",
        "question": "Find the average age of students who are living in the dorm with the largest capacity.",
        "ground_truth": "SELECT avg(T1.age) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.student_capacity  =  (SELECT max(student_capacity) FROM dorm)",
        "amends": [
            "Do use explicit table aliases `T1`, `T2`, and `T3` instead of no aliases. Do join `student AS T1` with `lives_in AS T2` on `T1.stuid = T2.stuid` instead of querying only the `students` table. Do add a second join to `dorm AS T3` on `T3.dormid = T2.dormid` instead of directly referencing `dorm_id` from the students table. Do filter on `T3.student_capacity = (SELECT max(student_capacity) FROM dorm)` instead of `dorm_id = (SELECT dorm_id FROM dorms ORDER BY capacity DESC LIMIT 1)`. Do reference `T1.age` in the SELECT clause instead of just `age`. The amended query now correctly identifies students in the dorm with maximum capacity through proper table relationships."
        ],
        "rules": [
            "1) When answering about students living in dorms: join student AS T1 with lives_in AS T2 on T1.stuid = T2.stuid to connect students to their dorm assignments. 2) When connecting dorm information: join T2 with dorm AS T3 on T3.dormid = T2.dormid to access dorm capacity data. 3) When finding the dorm with largest capacity: filter for T3.student_capacity = (SELECT max(student_capacity) FROM dorm) instead of using ORDER BY and LIMIT. 4) When calculating average age: reference T1.age in the SELECT clause to get the age from the student table. 5) When combining tables: use inner joins on the exact key equalities T1.stuid = T2.stuid and T3.dormid = T2.dormid to keep only matching pairs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age) FROM students WHERE dorm_id = (SELECT dorm_id FROM dorms ORDER BY capacity DESC LIMIT 1);",
            "SELECT AVG(T1.Age) \nFROM Student AS T1\nJOIN Lives_in AS T2 ON T1.StuID = T2.stuid\nJOIN Dorm AS T3 ON T3.dormid = T2.dormid\nWHERE T3.student_capacity = (SELECT MAX(student_capacity) FROM Dorm)"
        ],
        "rule_sql": [
            "SELECT AVG(T1.Age) \nFROM Student AS T1\nINNER JOIN Lives_in AS T2 ON T1.StuID = T2.stuid\nINNER JOIN Dorm AS T3 ON T3.dormid = T2.dormid\nWHERE T3.student_capacity = (SELECT MAX(student_capacity) FROM Dorm)"
        ]
    },
    "5653": {
        "db_id": "customers_and_products_contacts",
        "question": "How many addresses are there in country USA?",
        "ground_truth": "SELECT count(*) FROM addresses WHERE country  =  'USA'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM addresses WHERE country = 'USA';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Addresses WHERE country = 'USA';"
        ]
    },
    "2340": {
        "db_id": "csu_1",
        "question": "Find the count of universities whose campus fee is greater than the average campus fee.",
        "ground_truth": "SELECT count(*) FROM csu_fees WHERE campusfee  >  (SELECT avg(campusfee) FROM csu_fees)",
        "amends": [
            "Do reference table `csu_fees` instead of `universities` in both the main query and subquery. Do use column `campusfee` instead of `campus_fee` for both the comparison and average calculation. Do maintain the same aggregate function structure with `count(*)` and `avg(campusfee)` instead of `COUNT(*)` and `AVG(campus_fee)`. The amended query now correctly references the actual table and column names while preserving the logic of counting records where campus fee exceeds the average."
        ],
        "rules": [
            "1) When answering about \"count of universities whose campus fee is greater than the average campus fee\": use table \"csu_fees\" instead of \"universities\". 2) When the question mentions \"campus fee\": \"campus fee\" actually means column \"campusfee\" in schema. 3) When computing the average campus fee: calculate the average of column \"campusfee\" from table \"csu_fees\". 4) When counting records where campus fee exceeds the average: count rows from \"csu_fees\" where \"campusfee\" is greater than the computed average of \"campusfee\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM universities WHERE campus_fee > (SELECT AVG(campus_fee) FROM universities);",
            "SELECT COUNT(*) FROM csu_fees WHERE campusfee > (SELECT AVG(campusfee) FROM csu_fees)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM csu_fees \nWHERE CampusFee > (SELECT AVG(CampusFee) FROM csu_fees)"
        ]
    },
    "2084": {
        "db_id": "pilot_record",
        "question": "List the names of pilots in ascending order of rank.",
        "ground_truth": "SELECT Pilot_name FROM pilot ORDER BY Rank ASC",
        "amends": [
            "Do select `Pilot_name` instead of `name` and use `Rank ASC` ordering instead of `rank DESC`. Do reference table `pilot` instead of `pilots`. The amended query now correctly retrieves pilot names in ascending rank order from the appropriate table."
        ],
        "rules": [
            "1) When the question asks for \"names of pilots\": use the exact column token \"Pilot_name\" from table \"pilot\" instead of \"name\". 2) When the question specifies \"ascending order of rank\": order by \"Rank\" in ascending (ASC) direction instead of descending (DESC). 3) When referencing the table containing pilot information: use table \"pilot\" instead of \"pilots\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM pilots ORDER BY rank DESC;",
            "SELECT Pilot_name FROM pilot ORDER BY Rank ASC;"
        ],
        "rule_sql": [
            "SELECT Pilot_name FROM pilot ORDER BY Rank ASC;"
        ]
    },
    "4814": {
        "db_id": "aircraft",
        "question": "What are the names of all pilots 30 years old or young in descending alphabetical order?",
        "ground_truth": "SELECT Name FROM pilot WHERE Age  <=  30 ORDER BY Name DESC",
        "amends": [
            "Do use column name `Name` instead of `name` and table name `pilot` instead of `pilots`. Do change the filter to `Age <= 30` instead of `age > 30` to select younger pilots. Do change the sort order to `DESC` instead of `ASC` for descending alphabetical order. The amended query now correctly selects pilot names from the pilot table where age is 30 or younger, ordered by name in descending order."
        ],
        "rules": [
            "1) When the question asks for pilot names: use column \"Name\" from table \"pilot\" exactly as shown in the schema. 2) When filtering for pilots 30 years old or younger: use condition \"Age <= 30\" to include pilots with age exactly 30 or less. 3) When ordering results in descending alphabetical order: sort by \"Name\" in descending order (Z to A)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM pilots WHERE age > 30 ORDER BY name ASC;",
            "SELECT Name FROM pilot WHERE Age <= 30 ORDER BY Name DESC;"
        ],
        "rule_sql": [
            "SELECT Name FROM pilot WHERE Age <= 30 ORDER BY Name DESC;"
        ]
    },
    "1111": {
        "db_id": "climbing",
        "question": "Count the number of climbers.",
        "ground_truth": "SELECT count(*) FROM climber",
        "amends": [
            "Do query the `climber` table instead of the `mountains` table. Do count all rows from the correct data source instead of counting from an incorrect table. The amended query now correctly counts records from the climber table as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When counting the number of climbers: query the \"climber\" table instead of the \"mountains\" table. 2) When counting all rows from the correct data source: count all rows from the \"climber\" table instead of counting from an incorrect table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM mountains;",
            "SELECT COUNT(*) FROM climber;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM climber;"
        ]
    },
    "4583": {
        "db_id": "solvency_ii",
        "question": "How many products are there?",
        "ground_truth": "SELECT count(*) FROM Products",
        "amends": [
            "Do select from `Products` instead of `customers` as the table source. The amended query now correctly counts records from the Products table instead of the customers table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"how many products\": make sure to count from the \"Products\" table instead of the \"customers\" table. 2) When counting products: use the canonical key from the Products table to count the number of product records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers;",
            "SELECT COUNT(*) FROM Products;"
        ],
        "rule_sql": [
            "SELECT COUNT(Product_ID) FROM Products;"
        ]
    },
    "4277": {
        "db_id": "club_1",
        "question": "Find the club which has the largest number of members majoring in \"600\".",
        "ground_truth": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  \"600\" GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `t1.clubname` instead of `club_name`. Do join `club AS t1` instead of querying `clubs` alone. Do add `JOIN member_of_club AS t2 ON t1.clubid = t2.clubid` and `JOIN student AS t3 ON t2.stuid = t3.stuid` instead of omitting these table relationships. Do filter on `t3.major = \"600\"` instead of `major = '600'`. Do add `GROUP BY t1.clubname` and change the ordering to `count(*) DESC` instead of `member_count DESC` to count actual members per club. The amended query now correctly identifies the club with the most students majoring in 600 by joining through the membership bridge table."
        ],
        "rules": [
            "1) When answering about \"club with largest number of members majoring in '600'\": make sure the output order: t1.clubname. 2) When the question mentions \"club\": \"club\" actually means \"t1.clubname in schema\". 3) When combining tables for club membership relationships: link rows where t1.clubid = t2.clubid and t2.stuid = t3.stuid; keep only matching pairs (inner match). 4) When filtering for students majoring in \"600\": use exact literal \"600\" with t3.major = \"600\". 5) When counting members per club: organize results by t1.clubname and compute count(*) per group. 6) When the question mentions \"largest number\": rank rows by count(*) in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT club_name FROM clubs WHERE major = '600' ORDER BY member_count DESC LIMIT 1;",
            "SELECT t1.ClubName\nFROM Club AS t1\nJOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID\nJOIN Student AS t3 ON t2.StuID = t3.StuID\nWHERE t3.Major = '600'\nGROUP BY t1.ClubName\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t1.ClubName\nFROM Club t1\nJOIN Member_of_club t2 ON t1.ClubID = t2.ClubID\nJOIN Student t3 ON t2.StuID = t3.StuID\nWHERE t3.Major = '600'\nGROUP BY t1.ClubName\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "93": {
        "db_id": "student_assessment",
        "question": "Find distinct cities of address of students?",
        "ground_truth": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id",
        "amends": [
            "Do use `DISTINCT T1.city` instead of `city` to eliminate duplicates. Do join `addresses AS T1` and `people_addresses AS T2` on `T1.address_id = T2.address_id` instead of querying `students` directly. Do add a second join to `students AS T3` on `T2.person_id = T3.student_id` instead of filtering with `WHERE address IS NOT NULL`. Do remove the `WHERE` clause entirely instead of keeping the incorrect filter. The amended query now correctly retrieves distinct cities by properly navigating the relationship between addresses and students through the join structure, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"distinct cities\": use DISTINCT T1.city to eliminate duplicate city values. 2) When combining address and student information: join addresses AS T1 and people_addresses AS T2 on T1.address_id = T2.address_id to link addresses to people. 3) When connecting people to students: join people_addresses AS T2 to students AS T3 on T2.person_id = T3.student_id to identify student addresses. 4) When retrieving city information: use T1.city from the addresses table instead of querying students directly. 5) When filtering for students with addresses: do not use a WHERE clause for address existence since the join structure naturally includes only students with addresses through the inner joins."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city FROM students WHERE address IS NOT NULL",
            "SELECT DISTINCT T1.city\nFROM Addresses AS T1\nJOIN People_Addresses AS T2 ON T1.address_id = T2.address_id\nJOIN Students AS T3 ON T2.person_id = T3.student_id;"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.city\nFROM Addresses AS T1\nJOIN People_Addresses AS T2 ON T1.address_id = T2.address_id\nJOIN Students AS T3 ON T2.person_id = T3.student_id;"
        ]
    },
    "4960": {
        "db_id": "soccer_2",
        "question": "What are the unique types of player positions in the tryout?",
        "ground_truth": "SELECT count(DISTINCT pPos) FROM tryout",
        "amends": [
            "Do use `count(DISTINCT pPos)` instead of `SELECT DISTINCT position` to count distinct positions rather than listing them. Do query from `tryout` table instead of `tryout_players` to access the correct data source. Do remove the unnecessary DISTINCT modifier from the SELECT clause since the aggregate function handles uniqueness. The amended query now correctly counts distinct player positions from the tryout table instead of listing distinct position values from an incorrect table."
        ],
        "rules": [
            "1) When counting distinct player positions from the tryout: use the exact column token \"pPos\" from the tryout table. 2) When the question asks for unique types of player positions: compute the count of distinct values using the exact column token \"pPos\". 3) When accessing data about player positions: use the \"tryout\" table as the data source, not \"tryout_players\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT position FROM tryout_players;",
            "SELECT COUNT(DISTINCT pPos) FROM Tryout"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT pPos) FROM Tryout;"
        ]
    },
    "6463": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "How many documents do not have any expense?",
        "ground_truth": "SELECT count(*) FROM Documents WHERE document_id NOT IN ( SELECT document_id FROM Documents_with_expenses )",
        "amends": [
            "Do use a subquery with `NOT IN` to filter documents that don't exist in the `Documents_with_expenses` table instead of checking for `expense_id IS NULL`. Do reference the correct table name `Documents` (capitalized) instead of lowercase `documents`. Do remove the direct NULL check on `expense_id` instead of relying on it, as the correct logic requires identifying documents completely missing from the expense tracking table rather than those with NULL expense values. The amended query now correctly identifies documents without any expense association by checking against the separate expense tracking table."
        ],
        "rules": [
            "1) When answering about \"documents without any expense\": use a subquery with NOT IN to filter documents that don't exist in the Documents_with_expenses table instead of checking for expense_id IS NULL. 2) When referring to the documents table: use the exact table name \"Documents\" (capitalized) instead of lowercase \"documents\". 3) When identifying documents without expense association: remove direct NULL checks on expense_id and instead check against the separate expense tracking table to find documents completely missing from expense tracking."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM documents WHERE expense_id IS NULL;",
            "SELECT COUNT(*) \nFROM Documents \nWHERE Document_ID NOT IN (SELECT Document_ID FROM Documents_with_Expenses)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Documents \nWHERE Document_ID NOT IN (SELECT Document_ID FROM Documents_with_Expenses)"
        ]
    },
    "3150": {
        "db_id": "assets_maintenance",
        "question": "List the all the assets make, model, details by the disposed date ascendingly.",
        "ground_truth": "SELECT asset_make ,  asset_model ,  asset_details FROM Assets ORDER BY asset_disposed_date ASC",
        "amends": [
            "Do use column names `asset_make`, `asset_model`, and `asset_details` instead of `make`, `model`, and `details` to match the actual table schema. Do reference the table as `Assets` instead of `assets` to use the correct case-sensitive table name. Do order by `asset_disposed_date` instead of `disposed_date` to reference the correct column name for the disposal date. Do use `ASC` ordering instead of `DESC` to sort in ascending order rather than descending. The amended query now correctly selects the appropriate columns with proper naming conventions and applies the intended ascending sort order on the disposal date."
        ],
        "rules": [
            "1) When the question asks for \"make\": use the exact column name \"asset_make\" from the Assets table. 2) When the question asks for \"model\": use the exact column name \"asset_model\" from the Assets table. 3) When the question asks for \"details\": use the exact column name \"asset_details\" from the Assets table. 4) When the question asks to order by \"disposed date\": use the exact column name \"asset_disposed_date\" from the Assets table. 5) When the question specifies \"ascendingly\" ordering: sort the results in ascending order using ASC direction. 6) When referencing the Assets table: use the exact case-sensitive table name \"Assets\" (not lowercase \"assets\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT make, model, details FROM assets ORDER BY disposed_date DESC;",
            "SELECT asset_make, asset_model, asset_details FROM Assets ORDER BY asset_disposed_date ASC;"
        ],
        "rule_sql": [
            "SELECT asset_make, asset_model, asset_details FROM Assets ORDER BY asset_disposed_date ASC;"
        ]
    },
    "6033": {
        "db_id": "game_1",
        "question": "How many students play video games?",
        "ground_truth": "SELECT count(DISTINCT StuID) FROM Plays_games",
        "amends": [
            "Do count `DISTINCT StuID` instead of `COUNT(*)` to count unique students rather than all rows. Do query from `Plays_games` table instead of `students` table to access the correct data source. Do remove the `WHERE hobby = 'video games'` filter instead of keeping it, as the Plays_games table inherently contains only relevant gaming data. The amended query now correctly counts distinct student IDs who play games, matching the intended behavior."
        ],
        "rules": [
            "1) When counting students who play video games: count distinct \"StuID\" values instead of counting all rows. 2) When accessing data about students playing games: use the \"Plays_games\" table instead of the \"students\" table. 3) When the Plays_games table inherently contains only gaming data: do not apply additional filtering conditions like WHERE hobby = 'video games'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE hobby = 'video games';",
            "SELECT COUNT(DISTINCT StuID) FROM Plays_Games;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT StuID) FROM Plays_Games"
        ]
    },
    "1371": {
        "db_id": "college_2",
        "question": "What are the names of the 3 departments with the most courses?",
        "ground_truth": "SELECT dept_name FROM course GROUP BY dept_name ORDER BY count(*) DESC LIMIT 3",
        "amends": [
            "Do reference the table as `course` instead of `courses` and use the column `dept_name` instead of `department_name` in both the SELECT list and GROUP BY clause. Do remove the explicit column alias `course_count` and instead use the aggregate function `count(*)` directly in the ORDER BY clause instead of referencing the alias. Do maintain the same GROUP BY aggregation and LIMIT 3 functionality while correcting the table and column references to match the actual schema. The amended query now correctly identifies the top 3 departments by course count using the proper table and column names.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, as the query only needs to return department names. Do keep the `GROUP BY dept_name` clause to group by department. Do maintain the `ORDER BY count(*) DESC` to order by the count of courses in descending order. Do preserve the `LIMIT 3` to return only the top 3 departments. The amended query now correctly returns only the department names with the highest course counts, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for department names: use the exact column token \"dept_name\" from the course table. 2) When counting courses per department: group by \"dept_name\" and count all rows using count(*). 3) When the question asks for the top 3 departments with most courses: order the results by count(*) in descending order and keep only the first 3 rows. 4) When referencing the course table: use the exact table name \"course\" (not \"courses\"). 5) When ordering by aggregate results: use the aggregate function count(*) directly in the ORDER BY clause instead of referencing an alias.",
            "1) When answering about \"names of the 3 departments with the most courses\": make sure the output order: dept_name. 2) When the question asks for \"count of courses\" per department: compute the number of rows using the canonical key for courses. 3) When the question mentions \"top 3 departments with the most courses\": rank departments by course count in descending order and keep the first 3 rows. 4) When the question says \"by department\": organize results by dept_name and compute course counts per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department_name, COUNT(*) as course_count FROM courses GROUP BY department_name ORDER BY course_count DESC LIMIT 3;",
            "SELECT dept_name, COUNT(*) FROM course GROUP BY dept_name ORDER BY COUNT(*) DESC LIMIT 3;",
            "SELECT dept_name FROM course GROUP BY dept_name ORDER BY COUNT(*) DESC LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT dept_name FROM course GROUP BY dept_name ORDER BY COUNT(*) DESC LIMIT 3;"
        ]
    },
    "1396": {
        "db_id": "college_2",
        "question": "Find the title of the course that is offered by more than one department.",
        "ground_truth": "SELECT title FROM course GROUP BY title HAVING count(*)  >  1",
        "amends": [
            "Do reference the table as `course` instead of `courses` in the FROM clause, and do use lowercase `count(*)` instead of uppercase `COUNT(*)` in the HAVING clause, while maintaining the same grouping on `title` and filtering for duplicate counts greater than 1. The amended query now correctly references the singular table name and uses consistent lowercase function naming while preserving the identical logical behavior."
        ],
        "rules": [
            "1) When answering about \"course titles offered by more than one department\": make sure the output order: title\n2) When the question mentions \"course\": use the exact table name \"course\" (not \"courses\") in the FROM clause\n3) When counting entities: use lowercase \"count(*)\" (not uppercase \"COUNT(*)\") to count the number of rows\n4) When grouping by course titles: group by the exact column \"title\" and filter for groups having count greater than 1\n5) When producing output: return only the \"title\" column"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM courses GROUP BY title HAVING COUNT(*) > 1;",
            "SELECT title FROM course GROUP BY title HAVING count(*) > 1"
        ],
        "rule_sql": [
            "SELECT title FROM course GROUP BY title HAVING count(*) > 1"
        ]
    },
    "452": {
        "db_id": "allergy_1",
        "question": "How many animal type allergies exist?",
        "ground_truth": "SELECT count(*) FROM Allergy_type WHERE allergytype  =  \"animal\"",
        "amends": [
            "Do reference the `Allergy_type` table instead of the `allergies` table. Do filter with `allergytype = \"animal\"` instead of `animal_type IS NOT NULL`. Do use consistent lowercase `count(*)` instead of uppercase `COUNT(*)`. The amended query now correctly counts records from the appropriate table with the specific animal allergy filter."
        ],
        "rules": [
            "1) When answering about \"animal type allergies\": reference the \"Allergy_type\" table instead of the \"allergies\" table. 2) When filtering for animal allergies: use the exact literal value \"animal\" for the \"allergytype\" column. 3) When counting records: use lowercase \"count(*)\" for consistency with the schema requirements."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM allergies WHERE animal_type IS NOT NULL;",
            "SELECT count(*) FROM Allergy_Type WHERE allergytype = 'animal'"
        ],
        "rule_sql": [
            "SELECT count(*) FROM Allergy_Type WHERE AllergyType = 'animal';"
        ]
    },
    "287": {
        "db_id": "twitter_1",
        "question": "Find the names of users who have more than one tweet.",
        "ground_truth": "SELECT T1.name FROM user_profiles AS T1 JOIN tweets AS T2 ON T1.uid  =  T2.uid GROUP BY T2.uid HAVING count(*)  >  1",
        "amends": [
            "Do use `user_profiles AS T1` as the main table instead of `users`, and add `tweets AS T2` with a `JOIN` on `T1.uid = T2.uid` instead of omitting the join. Do move the aggregate condition to `HAVING count(*) > 1` instead of incorrectly placing `COUNT(tweets.id) > 1` in the `WHERE` clause. Do include `GROUP BY T2.uid` instead of omitting the grouping, and specify `T1.name` in the `SELECT` list instead of just `name`. The amended query now correctly aggregates tweet counts per user and filters with HAVING instead of the invalid WHERE clause usage, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"names of users who have more than one tweet\": use \"user_profiles\" as T1 and \"tweets\" as T2 instead of just \"users\". 2) When combining T1 and T2 for shared entities: link rows where T1.uid = T2.uid and keep only matching pairs (inner match). 3) When the question asks for \"count of tweets per user\": compute the number of rows using T2.uid as the grouping key and count all matching rows. 4) When filtering for users with more than one tweet: apply the condition count(*) > 1 after grouping instead of in the initial row filtering. 5) When selecting user names: specify T1.name in the output instead of just name to avoid ambiguity."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM users WHERE COUNT(tweets.id) > 1",
            "SELECT T1.name FROM user_profiles AS T1 JOIN tweets AS T2 ON T1.uid = T2.uid GROUP BY T2.uid HAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T1.name FROM user_profiles AS T1 INNER JOIN tweets AS T2 ON T1.uid = T2.uid GROUP BY T2.uid HAVING COUNT(*) > 1"
        ]
    },
    "2834": {
        "db_id": "restaurant_1",
        "question": "Which student's age is older than 18 and is majoring in 600? List each student's first and last name.",
        "ground_truth": "SELECT Fname , Lname FROM Student WHERE Age  >  18 AND Major = 600;",
        "amends": [
            "Do use column names `Fname` and `Lname` instead of `first_name` and `last_name`. Do reference table `Student` instead of `students`. Do use column name `Age` instead of `age` and `Major` instead of `major`. Do remove quotes around the numeric value `600` instead of treating it as a string literal. The amended query now correctly matches the intended behavior by using proper column and table names while handling the numeric major code appropriately."
        ],
        "rules": [
            "1) When the question asks for student's first and last name: use column names \"Fname\" and \"Lname\" from table \"Student\" instead of \"first_name\" and \"last_name\". 2) When the question refers to students: use table name \"Student\" instead of \"students\". 3) When filtering by age: use column name \"Age\" instead of \"age\" and compare with numeric value 18 using greater than comparison. 4) When filtering by major: use column name \"Major\" instead of \"major\" and compare with numeric value 600 without quotes around it."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM students WHERE age > 18 AND major = '600';",
            "SELECT Fname, Lname FROM Student WHERE Age > 18 AND Major = 600;"
        ],
        "rule_sql": [
            "SELECT Fname, Lname FROM Student WHERE Age > 18 AND Major = 600;"
        ]
    },
    "3811": {
        "db_id": "e_learning",
        "question": "What are the names of the courses taught by the tutor whose personal name is \"Julio\"?",
        "ground_truth": "SELECT T2.course_name FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id WHERE T1.personal_name  =  \"Julio\"",
        "amends": [
            "Do join `Course_Authors_and_Tutors AS T1` to `Courses AS T2` on `T1.author_id = T2.author_id` instead of querying `courses` directly with a subquery on `tutors`. Do reference `T2.course_name` instead of just `course_name` to specify the table source. Do use `T1.personal_name = \"Julio\"` as a direct join filter instead of a subquery that matches `tutor_id` from a separate `tutors` table. Do remove the subquery entirely instead of using nested selection. The amended query now correctly joins the author/tutor table to courses using author_id and filters by personal_name directly, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about courses taught by a tutor: join \"Course_Authors_and_Tutors\" as T1 to \"Courses\" as T2 on T1.author_id = T2.author_id to link tutors with their courses. 2) When the question mentions \"tutor whose personal name is 'Julio'\": use T1.personal_name = \"Julio\" as a direct filter condition. 3) When selecting course names: reference T2.course_name to specify the exact source table column. 4) When combining tutor and course information: perform an inner match where T1.author_id equals T2.author_id to ensure only matching tutor-course pairs are included."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_name FROM courses WHERE tutor_id = (SELECT tutor_id FROM tutors WHERE personal_name = 'Julio');",
            "SELECT T2.course_name \nFROM Course_Authors_and_Tutors AS T1\nJOIN Courses AS T2 ON T1.author_id = T2.author_id\nWHERE T1.personal_name = 'Julio'"
        ],
        "rule_sql": [
            "SELECT T2.course_name \nFROM Course_Authors_and_Tutors AS T1\nINNER JOIN Courses AS T2 ON T1.author_id = T2.author_id\nWHERE T1.personal_name = 'Julio'"
        ]
    },
    "3738": {
        "db_id": "program_share",
        "question": "List the name, origin and owner of each program.",
        "ground_truth": "SELECT name ,  origin ,  OWNER FROM program",
        "amends": [
            "Do add `OWNER` to the SELECT list instead of omitting it. Do use the correct table name `program` instead of `programs`. The amended query now correctly includes all required columns and references the proper table."
        ],
        "rules": [
            "1) When the question asks for \"name, origin and owner of each program\": make sure the output order: name, origin, owner. 2) When referring to the program table: use the exact table name \"program\" instead of \"programs\". 3) When selecting columns for program information: include all three columns - name, origin, and owner - in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, origin FROM programs;",
            "SELECT Name, Origin, Owner FROM program;"
        ],
        "rule_sql": [
            "SELECT name, origin, owner FROM program;"
        ]
    },
    "6814": {
        "db_id": "flight_4",
        "question": "What are the names of all airports in Cuba or Argentina?",
        "ground_truth": "SELECT name FROM airports WHERE country  =  'Cuba' OR country  =  'Argentina'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM airports WHERE country = 'Cuba' OR country = 'Argentina';"
        ],
        "rule_sql": [
            "SELECT name FROM airports WHERE country = 'Cuba' OR country = 'Argentina';"
        ]
    },
    "1669": {
        "db_id": "theme_gallery",
        "question": "What is the name and country for the artist with most number of exhibitions?",
        "ground_truth": "SELECT T2.name , T2.country FROM exhibition AS T1 JOIN artist AS T2 ON T1.artist_id  =  T2.artist_id GROUP BY T1.artist_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.name` and `T2.country` from the `artist` table instead of `name` and `country` from `artists`. Do join `exhibition AS T1` with `artist AS T2` on `T1.artist_id = T2.artist_id` instead of querying a single table. Do add `GROUP BY T1.artist_id` to group by artist instead of omitting grouping. Do order by `count(*) DESC` to sort by exhibition count instead of `id DESC`. Do keep `LIMIT 1` to return only the top result. The amended query now correctly identifies the artist with the most exhibitions by joining exhibition and artist tables and counting exhibitions per artist."
        ],
        "rules": [
            "1) When answering about \"artist with most number of exhibitions\": make sure the output order: T2.name, T2.country 2) When the question mentions \"artist\": use table \"artist\" as T2 with columns \"name\" and \"country\" 3) When the question mentions \"exhibitions\": use table \"exhibition\" as T1 4) When combining T1 and T2 for shared entities: link rows where T1.artist_id = T2.artist_id and keep only matching pairs (inner match) 5) When the question asks for \"most number of exhibitions\": group by T1.artist_id and count the number of rows using T1.artist_id as the counting key 6) When the question asks for \"artist with most\": rank rows by count(*) in descending order and keep the first 1 row 7) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, country FROM artists ORDER BY id DESC LIMIT 1;",
            "SELECT T2.Name, T2.Country\nFROM exhibition AS T1\nJOIN artist AS T2 ON T1.Artist_ID = T2.Artist_ID\nGROUP BY T1.Artist_ID\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.\"Name\", T2.\"Country\"\nFROM \"exhibition\" AS T1\nINNER JOIN \"artist\" AS T2 ON T1.\"Artist_ID\" = T2.\"Artist_ID\"\nGROUP BY T1.\"Artist_ID\"\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "479": {
        "db_id": "allergy_1",
        "question": "Who is the advisor of student with ID 1004?",
        "ground_truth": "SELECT Advisor FROM Student WHERE StuID  =  1004",
        "amends": [
            "Do reference the `Advisor` column instead of `advisor_name` to match the correct column name. Do reference the `Student` table instead of `students` to use the correct table name. Do reference the `StuID` column instead of `student_id` for the filter condition to align with the correct column identifier. The amended query now correctly retrieves advisor information from the proper table structure."
        ],
        "rules": [
            "1) When the question asks about a student with ID 1004: use the exact literal value 1004 for filtering. 2) When the question mentions \"advisor\": the column name is exactly \"Advisor\" in table \"Student\". 3) When the question mentions \"student with ID\": the column name for student ID is exactly \"StuID\" in table \"Student\". 4) When retrieving information about a specific student: filter the \"Student\" table where \"StuID\" equals the exact student ID value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT advisor_name FROM students WHERE student_id = 1004;",
            "SELECT Advisor FROM Student WHERE StuID = 1004;"
        ],
        "rule_sql": [
            "SELECT Advisor FROM Student WHERE StuID = 1004;"
        ]
    },
    "2960": {
        "db_id": "sakila_1",
        "question": "Which customer, who has made at least one payment, has spent the least money? List his or her first name, last name, and the id.",
        "ground_truth": "SELECT T1.first_name ,  T1.last_name ,  T1.customer_id FROM customer AS T1 JOIN payment AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY sum(amount) ASC LIMIT 1",
        "amends": [
            "Do remove `SUM(p.amount) as total_spent` from the SELECT list instead of including it. Do change the ORDER BY clause to use `sum(amount) ASC` instead of `total_spent DESC`. Do remove the alias `total_spent` from the ORDER BY clause instead of referencing it. The amended query now correctly orders by the ascending sum of payment amounts rather than descending total spent, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"which customer has spent the least money\": make sure the output order includes only first_name, last_name, and customer_id. 2) When computing total spending for customers: calculate the sum of payment amounts for each customer. 3) When ordering customers by spending: sort by the sum of payment amounts in ascending order to find the customer with the least spending. 4) When the question specifies \"who has made at least one payment\": only include customers that have at least one payment record. 5) When selecting the customer with the least spending: take only the first row after ordering by ascending sum of payment amounts."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.first_name, c.last_name, c.customer_id, SUM(p.amount) as total_spent\nFROM customer c\nJOIN payment p ON c.customer_id = p.customer_id\nGROUP BY c.customer_id\nORDER BY total_spent DESC\nLIMIT 1;",
            "SELECT c.first_name, c.last_name, c.customer_id\nFROM customer c\nJOIN payment p ON c.customer_id = p.customer_id\nGROUP BY c.customer_id\nHAVING COUNT(p.payment_id) >= 1\nORDER BY SUM(p.amount) ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT c.first_name, c.last_name, c.customer_id\nFROM customer c\nJOIN payment p ON c.customer_id = p.customer_id\nGROUP BY c.customer_id\nHAVING COUNT(p.payment_id) >= 1\nORDER BY SUM(p.amount) ASC\nLIMIT 1;"
        ]
    },
    "5069": {
        "db_id": "device",
        "question": "What are the names of device shops, and what are the carriers that they carry devices in stock for?",
        "ground_truth": "SELECT T3.Shop_Name ,  T2.Carrier FROM stock AS T1 JOIN device AS T2 ON T1.Device_ID  =  T2.Device_ID JOIN shop AS T3 ON T1.Shop_ID  =  T3.Shop_ID",
        "amends": [
            "Do select `T3.Shop_Name` and `T2.Carrier` instead of `shop_name` and `carrier_name`. Do use `stock AS T1 JOIN device AS T2 ON T1.Device_ID = T2.Device_ID JOIN shop AS T3 ON T1.Shop_ID = T3.Shop_ID` instead of `device_shops JOIN carriers ON device_shops.shop_id = carriers.carrier_id`. Do remove the incorrect join condition `device_shops.shop_id = carriers.carrier_id` instead of keeping it, as the original logic incorrectly joined unrelated tables. The amended query now correctly joins through the stock table to relate devices to shops and retrieves the appropriate columns from the proper tables, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about device shops and their carriers: make sure the output order: T3.Shop_Name, T2.Carrier\n2) When combining tables for device stock information: link rows where T1.Device_ID = T2.Device_ID and T1.Shop_ID = T3.Shop_ID, keeping only matching pairs (inner match)\n3) When selecting shop names: use T3.Shop_Name instead of shop_name\n4) When selecting carrier information: use T2.Carrier instead of carrier_name\n5) When joining tables: use stock AS T1, device AS T2, and shop AS T3 as the canonical aliases with their respective roles"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT shop_name, carrier_name FROM device_shops JOIN carriers ON device_shops.shop_id = carriers.carrier_id;",
            "SELECT T3.Shop_Name, T2.Carrier\nFROM stock AS T1\nJOIN device AS T2 ON T1.Device_ID = T2.Device_ID\nJOIN shop AS T3 ON T1.Shop_ID = T3.Shop_ID\nGROUP BY T3.Shop_Name, T2.Carrier;"
        ],
        "rule_sql": [
            "SELECT T3.Shop_Name, T2.Carrier\nFROM stock AS T1\nINNER JOIN device AS T2 ON T1.Device_ID = T2.Device_ID\nINNER JOIN shop AS T3 ON T1.Shop_ID = T3.Shop_ID\nWHERE T1.Quantity > 0\nGROUP BY T3.Shop_Name, T2.Carrier\nORDER BY T3.Shop_Name, T2.Carrier"
        ]
    },
    "4370": {
        "db_id": "tracking_grants_for_research",
        "question": "Find the organisation type description of the organisation detailed as 'quo'.",
        "ground_truth": "SELECT T1.organisation_type_description FROM organisation_Types AS T1 JOIN Organisations AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_details  =  'quo'",
        "amends": [
            "Do add table `Organisations AS T2` with a `JOIN` on `T1.organisation_type = T2.organisation_type` instead of querying only `organisation_types`. Do change the SELECT list to `T1.organisation_type_description` instead of `description`. Do move the filter condition to `T2.organisation_details = 'quo'` instead of `organisation_type = 'quo'`. Do add table alias `T1` for `organisation_types` instead of no alias. The amended query now correctly joins the two tables and filters on organization details rather than organization type, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"organisation type description of the organisation detailed as 'quo'\": make sure the output order: T1.organisation_type_description. 2) When the question mentions \"organisation detailed as 'quo'\": \"organisation detailed\" actually means \"T2.organisation_details in schema\" with exact literal value 'quo'. 3) When combining T1 (organisation_types) and T2 (Organisations) for shared entities: link rows where T1.organisation_type = T2.organisation_type exactly as shown in the amends; keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 5) When handling text literals: do not change case, spacing, or punctuation of 'quo'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description FROM organisation_types WHERE organisation_type = 'quo';",
            "SELECT T1.organisation_type_description \nFROM Organisation_Types AS T1\nJOIN Organisations AS T2 ON T1.organisation_type = T2.organisation_type\nWHERE T2.organisation_details = 'quo'"
        ],
        "rule_sql": [
            "SELECT T1.organisation_type_description\nFROM Organisation_Types T1\nINNER JOIN Organisations T2 ON T1.organisation_type = T2.organisation_type\nWHERE T2.organisation_details = 'quo'"
        ]
    },
    "1828": {
        "db_id": "browser_web",
        "question": "List the ids, names and market shares of all browsers.",
        "ground_truth": "SELECT id ,  name ,  market_share FROM browser",
        "amends": [
            "Do reference the correct table name `browser` instead of the incorrect pluralized `browsers` table name. The amended query now correctly queries the `browser` table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question mentions \"browsers\": use the exact table name \"browser\" instead of the pluralized form. 2) When answering about \"market shares of all browsers\": include all rows from the browser table without filtering by market_share > 100."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, name, market_share FROM browsers WHERE market_share > 100;",
            "SELECT id, name, market_share FROM browser;"
        ],
        "rule_sql": [
            "SELECT id, name, market_share FROM browser;"
        ]
    },
    "5299": {
        "db_id": "manufactory_1",
        "question": "What are the names, headquarters and revenues for manufacturers, sorted by revenue descending?",
        "ground_truth": "SELECT name ,  headquarter ,  revenue FROM manufacturers ORDER BY revenue DESC",
        "amends": [
            "Do use column name `headquarter` instead of `headquarters` in the SELECT list. Do change the sort direction to `DESC` instead of `ASC` in the ORDER BY clause. The amended query now correctly selects the headquarter column and sorts manufacturers by revenue in descending order, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"headquarters\": use the exact column name \"headquarter\" instead of \"headquarters\" in the output. 2) When the question asks to sort by revenue descending: order the results by the revenue column in descending order (highest to lowest)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, headquarters, revenue FROM manufacturers ORDER BY revenue ASC;",
            "SELECT Name, Headquarter, Revenue FROM Manufacturers ORDER BY Revenue DESC;"
        ],
        "rule_sql": [
            "SELECT Name, Headquarter, Revenue FROM Manufacturers ORDER BY Revenue DESC;"
        ]
    },
    "2994": {
        "db_id": "sakila_1",
        "question": "What is the first name and the last name of the customer who made the earliest rental?",
        "ground_truth": "SELECT T1.first_name ,  T1.last_name FROM customer AS T1 JOIN rental AS T2 ON T1.customer_id  =  T2.customer_id ORDER BY T2.rental_date ASC LIMIT 1",
        "amends": [
            "Do add `JOIN rental AS T2 ON T1.customer_id = T2.customer_id` instead of omitting the rental table join. Do reference `T2.rental_date` in the ORDER BY instead of the non-existent `rental_date` column. Do add table aliases `T1` and `T2` for clarity instead of using unqualified column references. Do qualify columns as `T1.first_name` and `T1.last_name` instead of bare column names. The amended query now correctly joins customer and rental tables to access rental_date for sorting and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"the customer who made the earliest rental\": make sure the output order: T1.first_name, T1.last_name. 2) When the question mentions \"earliest rental\": this means the minimum T2.rental_date value. 3) When combining customer table T1 and rental table T2: link rows where T1.customer_id = T2.customer_id and keep only matching pairs (inner match). 4) When ordering by rental date to find the earliest: sort rows by T2.rental_date in ascending order and keep the first row. 5) When selecting customer attributes: use T1.first_name and T1.last_name from the customer table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM customer ORDER BY rental_date ASC LIMIT 1;",
            "SELECT T1.first_name, T1.last_name\nFROM customer AS T1\nJOIN rental AS T2 ON T1.customer_id = T2.customer_id\nORDER BY T2.rental_date ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.last_name\nFROM customer T1\nINNER JOIN rental T2 ON T1.customer_id = T2.customer_id\nORDER BY T2.rental_date ASC\nLIMIT 1;"
        ]
    },
    "1878": {
        "db_id": "wrestler",
        "question": "Show the teams that have both wrestlers eliminated by \"Orton\" and wrestlers eliminated by \"Benjamin\".",
        "ground_truth": "SELECT Team FROM Elimination WHERE Eliminated_By  =  \"Orton\" INTERSECT SELECT Team FROM Elimination WHERE Eliminated_By  =  \"Benjamin\"",
        "amends": [
            "Do use `INTERSECT` to find teams eliminated by both wrestlers instead of `AND` conditions that cannot both be true simultaneously. Do query the `Elimination` table instead of the `wrestlers` table. Do select the `Team` column instead of `team_name`. Do use separate queries for each elimination condition instead of trying to combine them in a single WHERE clause. Do use double quotes for string literals instead of single quotes. The amended query now correctly identifies teams that were eliminated by both Orton and Benjamin by finding the intersection of teams eliminated by each wrestler separately."
        ],
        "rules": [
            "1) When the question asks for teams eliminated by multiple specific wrestlers: use INTERSECT to combine results from separate queries for each wrestler instead of AND conditions that cannot both be true simultaneously. 2) When querying about eliminations: use the Elimination table instead of wrestlers table. 3) When selecting team information from the Elimination table: select the Team column instead of team_name. 4) When using string literals for wrestler names: use double quotes instead of single quotes (e.g., \"Orton\" and \"Benjamin\"). 5) When finding teams eliminated by both \"Orton\" and \"Benjamin\": execute separate queries for each wrestler's eliminations and find their intersection."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT team_name \nFROM wrestlers \nWHERE eliminated_by = 'Orton' \nAND eliminated_by = 'Benjamin';",
            "SELECT Team FROM Elimination WHERE Eliminated_By = \"Orton\" INTERSECT SELECT Team FROM Elimination WHERE Eliminated_By = \"Benjamin\""
        ],
        "rule_sql": [
            "SELECT Team FROM Elimination WHERE Eliminated_By = \"Orton\" INTERSECT SELECT Team FROM Elimination WHERE Eliminated_By = \"Benjamin\""
        ]
    },
    "5494": {
        "db_id": "voter_2",
        "question": "Find the distinct first names of all the students who have vice president votes and whose city code is not PIT.",
        "ground_truth": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  \"PIT\"",
        "amends": [
            "Do use `T1.Fname` instead of `first_name` and reference table `STUDENT AS T1` instead of `students`. Do add `JOIN VOTING_RECORD AS T2 ON T1.StuID = T2.VICE_PRESIDENT_Vote` instead of filtering directly on `vice_president_votes > 0`. Do remove the `WHERE city_code = 'PIT'` filter from the main query and instead use `EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code = \"PIT\"` to exclude those records. Do maintain `DISTINCT` in both query parts instead of applying it only once. The amended query now correctly identifies students who voted for vice president while excluding those from Pittsburgh, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"distinct first names of students who have vice president votes and whose city code is not PIT\": make sure the output order: T1.Fname. 2) When the question mentions \"first names\": \"first names\" actually means \"T1.Fname in schema\". 3) When the question mentions \"students who have vice president votes\": this requires joining T1 (STUDENT) and T2 (VOTING_RECORD) where T1.StuID = T2.VICE_PRESIDENT_Vote to find students with vice president votes. 4) When the question mentions \"city code is not PIT\": exclude records where T1.city_code = \"PIT\" using an EXCEPT operation. 5) When the question asks for \"distinct first names\": compute the number of unique values of T1.Fname and maintain DISTINCT in both query parts. 6) When combining T1 and T2 for shared entities: link rows where T1.StuID = T2.VICE_PRESIDENT_Vote exactly as shown in the amends; keep only matching pairs (inner match). 7) When handling text literals: do not change case, spacing, or punctuation - use exact literal \"PIT\" for city code comparison."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT first_name FROM students WHERE vice_president_votes > 0 AND city_code = 'PIT';",
            "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID = T2.VICE_PRESIDENT_Vote WHERE T1.city_code != 'PIT'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Fname\nFROM Student T1\nJOIN Voting_record T2 ON T1.StuID = T2.Vice_President_Vote\nWHERE T1.city_code != 'PIT'\nORDER BY T1.Fname"
        ]
    },
    "3572": {
        "db_id": "music_1",
        "question": "What are the names of the songs that have a lower rating than at least one blues song?",
        "ground_truth": "SELECT song_name FROM song WHERE rating  <  (SELECT max(rating) FROM song WHERE genre_is  =  \"blues\")",
        "amends": [
            "Do reference `song_name` instead of `name` and use table `song` instead of `songs`. Do use `max(rating)` instead of `MAX(rating)` and reference `genre_is` instead of `genre` with double quotes around 'blues' instead of single quotes. The amended query now correctly references the schema and matches the intended behavior."
        ],
        "rules": [
            "1) When the question asks for song names: use the exact column token \"song_name\" from table \"song\" instead of \"name\" or \"songs\". 2) When comparing ratings against blues songs: use \"genre_is\" = 'blues' (with single quotes) to identify blues genre songs. 3) When finding maximum rating for comparison: use max(rating) (lowercase) instead of MAX(rating) (uppercase). 4) When filtering songs with lower ratings: ensure the comparison uses rating < (subquery result) to find songs with ratings lower than at least one blues song."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM songs WHERE rating < (SELECT MAX(rating) FROM songs WHERE genre = 'blues')",
            "SELECT song_name FROM song WHERE rating < (SELECT max(rating) FROM song WHERE genre_is = \"blues\")"
        ],
        "rule_sql": [
            "SELECT song_name FROM song WHERE rating < (SELECT max(rating) FROM song WHERE genre_is = 'blues')"
        ]
    },
    "998": {
        "db_id": "university_basketball",
        "question": "What are the enrollment and primary conference for the university which was founded the earliest?",
        "ground_truth": "SELECT enrollment ,  primary_conference FROM university ORDER BY founded LIMIT 1",
        "amends": [
            "Do reference table `university` instead of `universities` in the FROM clause. Do order by column `founded` instead of `founded_year`. The amended query now correctly retrieves the enrollment and primary conference from the university table ordered by the founded date."
        ],
        "rules": [
            "1) When answering about \"the university which was founded the earliest\": order rows by the \"founded\" column in ascending order and keep the first row. 2) When the question mentions \"enrollment and primary conference\": select the exact columns \"enrollment\" and \"primary_conference\" from the \"university\" table. 3) When the question mentions \"founded the earliest\": use the column \"founded\" instead of \"founded_year\" for ordering by foundation date."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT enrollment, primary_conference FROM universities ORDER BY founded_year DESC LIMIT 1;",
            "SELECT Enrollment, Primary_conference FROM university ORDER BY Founded ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT enrollment, primary_conference FROM university ORDER BY founded ASC LIMIT 1;"
        ]
    },
    "176": {
        "db_id": "bike_1",
        "question": "What is the date, average temperature and mean humidity for the days with the 3 largest maximum gust speeds?",
        "ground_truth": "SELECT date ,  mean_temperature_f ,  mean_humidity FROM weather ORDER BY max_gust_speed_mph DESC LIMIT 3",
        "amends": [
            "Do select specific columns `date`, `mean_temperature_f`, and `mean_humidity` instead of calculating aggregates `AVG(temperature)` and `AVG(humidity)` with custom aliases. Do reference table `weather` instead of `weather_data`. Do order by `max_gust_speed_mph` instead of `gust_speed`. The amended query now correctly selects pre-calculated metrics from the appropriate table and sorts by the intended gust speed column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"date, average temperature and mean humidity for the days with the 3 largest maximum gust speeds\": make sure the output order: date, mean_temperature_f, mean_humidity. 2) When the question mentions \"average temperature\": \"average temperature\" actually means \"mean_temperature_f in schema\". 3) When the question mentions \"mean humidity\": \"mean humidity\" actually means \"mean_humidity in schema\". 4) When the question mentions \"maximum gust speeds\": \"maximum gust speeds\" actually means \"max_gust_speed_mph in schema\". 5) When the question mentions \"top 3\" or \"largest 3\" by maximum gust speed: rank rows by max_gust_speed_mph in descending order and keep the first 3 rows. 6) When selecting from the weather table: use table weather instead of weather_data. 7) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT date, AVG(temperature) as avg_temperature, AVG(humidity) as mean_humidity \nFROM weather_data \nORDER BY gust_speed DESC \nLIMIT 3;",
            "SELECT date, mean_temperature_f, mean_humidity FROM weather ORDER BY max_gust_speed_mph DESC LIMIT 3"
        ],
        "rule_sql": [
            "SELECT date, mean_temperature_f, mean_humidity FROM weather ORDER BY max_gust_speed_mph DESC LIMIT 3"
        ]
    },
    "5387": {
        "db_id": "tracking_software_problems",
        "question": "For which product was there a problem reported by Christop Berge, with closure authorised by Ashley Medhurst? Return the product ids.",
        "ground_truth": "SELECT product_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE T2.staff_first_name = \"Christop\" AND T2.staff_last_name = \"Berge\" INTERSECT SELECT product_id FROM problems AS T1 JOIN staff AS T2 ON T1.closure_authorised_by_staff_id = T2.staff_id WHERE T2.staff_first_name = \"Ashley\" AND T2.staff_last_name = \"Medhurst\"",
        "amends": [
            "Do join `problems` with `staff` on `reported_by_staff_id` instead of directly filtering by name strings. Do filter by `staff_first_name` and `staff_last_name` for \"Christop Berge\" instead of using a single `reported_by` column. Do add a second query with `INTERSECT` to also join on `closure_authorised_by_staff_id` for \"Ashley Medhurst\" instead of using a single `authorised_by` column. Do use proper relational joins through staff IDs instead of storing and filtering by full names directly in the problems table. The amended query now correctly finds products reported by Christop Berge and authorized by Ashley Medhurst using proper staff table relationships."
        ],
        "rules": [
            "1) When the question mentions \"Christop Berge\": this refers to matching both \"staff_first_name\" = 'Christop' and \"staff_last_name\" = 'Berge' in the Staff table. 2) When the question mentions \"Ashley Medhurst\": this refers to matching both \"staff_first_name\" = 'Ashley' and \"staff_last_name\" = 'Medhurst' in the Staff table. 3) When finding problems reported by a specific staff member: join Problems table (T1) with Staff table (T2) on T1.\"reported_by_staff_id\" = T2.\"staff_id\" to find the reporting staff details. 4) When finding problems authorized by a specific staff member: join Problems table (T1) with Staff table (T3) on T1.\"closure_authorised_by_staff_id\" = T3.\"staff_id\" to find the authorizing staff details. 5) When combining both conditions for the same problem: use INTERSECT to find problems that satisfy both the reporting staff condition and the authorizing staff condition. 6) When returning product ids: select the \"product_id\" column from the Problems table as the final output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT product_id FROM problems WHERE reported_by = 'Christop Berge' AND authorised_by = 'Ashley Medhurst';",
            "SELECT p.product_id\nFROM Problems p\nJOIN Staff s1 ON p.reported_by_staff_id = s1.staff_id\nJOIN Staff s2 ON p.closure_authorised_by_staff_id = s2.staff_id\nWHERE s1.staff_first_name = 'Christop' AND s1.staff_last_name = 'Berge'\nAND s2.staff_first_name = 'Ashley' AND s2.staff_last_name = 'Medhurst'"
        ],
        "rule_sql": [
            "SELECT product_id FROM Problems\nWHERE problem_id IN (\n    SELECT p1.problem_id FROM Problems p1\n    JOIN Staff s1 ON p1.reported_by_staff_id = s1.staff_id\n    WHERE s1.staff_first_name = 'Christop' AND s1.staff_last_name = 'Berge'\n    INTERSECT\n    SELECT p2.problem_id FROM Problems p2\n    JOIN Staff s2 ON p2.closure_authorised_by_staff_id = s2.staff_id\n    WHERE s2.staff_first_name = 'Ashley' AND s2.staff_last_name = 'Medhurst'\n)"
        ]
    },
    "3974": {
        "db_id": "hospital_1",
        "question": "Find the physician who was trained in the most expensive procedure?",
        "ground_truth": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1",
        "amends": [
            "Do join `trained_in AS T2` on `T1.employeeid = T2.physician` instead of directly joining `procedures` on `p.procedure_id = pr.id`. Do join `procedures AS T3` on `T3.code = T2.treatment` instead of the direct physician-procedure relationship. Do reference `T1.name` from `physician AS T1` instead of `p.name` from `physicians p`. Do use the correct table alias `T1` for physician table instead of `p`. The amended query now correctly models the relationship through the trained_in bridge table and matches the intended behavior."
        ],
        "rules": [
            "1) When joining physician and trained_in tables: link rows where T1.employeeid equals T2.physician exactly as shown in the amends. 2) When joining trained_in and procedures tables: link rows where T3.code equals T2.treatment exactly as shown in the amends. 3) When answering about physicians trained in procedures: use the bridge table trained_in (T2) to connect physicians (T1) to procedures (T3) instead of a direct relationship. 4) When selecting physician names: reference T1.name from the physician table with alias T1. 5) When finding the most expensive procedure: order by T3.cost in descending direction and keep only the top row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.name \nFROM physicians p\nJOIN procedures pr ON p.procedure_id = pr.id\nORDER BY pr.cost DESC\nLIMIT 1;",
            "SELECT T1.Name\nFROM Physician AS T1\nJOIN Trained_In AS T2 ON T1.EmployeeID = T2.Physician\nJOIN Procedures AS T3 ON T2.Treatment = T3.Code\nWHERE T3.Cost = (SELECT MAX(Cost) FROM Procedures);"
        ],
        "rule_sql": [
            "SELECT T1.Name\nFROM Physician T1\nJOIN Trained_In T2 ON T1.EmployeeID = T2.Physician\nJOIN Procedures T3 ON T3.Code = T2.Treatment\nORDER BY T3.Cost DESC\nLIMIT 1;"
        ]
    },
    "2286": {
        "db_id": "entrepreneur",
        "question": "Return the weights of entrepreneurs, ordered descending by amount of money requested.",
        "ground_truth": "SELECT T2.Weight FROM entrepreneur AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T1.Money_Requested DESC",
        "amends": [
            "Do select `T2.Weight` from the `people` table instead of `weight` from the `entrepreneurs` table. Do join `entrepreneur AS T1` with `people AS T2` on `T1.People_ID = T2.People_ID` instead of querying only the `entrepreneurs` table. Do order by `T1.Money_Requested DESC` instead of `money_requested ASC` to sort in descending order. The amended query now correctly retrieves weight data from the related people table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"weights of entrepreneurs\": select \"T2.Weight\" from the \"people\" table instead of \"weight\" from the \"entrepreneurs\" table. 2) When combining entrepreneur and people tables: join \"entrepreneur AS T1\" with \"people AS T2\" on \"T1.People_ID = T2.People_ID\" using inner match. 3) When ordering by amount of money requested: sort by \"T1.Money_Requested\" in descending order instead of ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT weight FROM entrepreneurs ORDER BY money_requested ASC;",
            "SELECT T2.Weight \nFROM entrepreneur AS T1\nJOIN people AS T2 ON T1.People_ID = T2.People_ID\nORDER BY T1.Money_Requested DESC"
        ],
        "rule_sql": [
            "SELECT T2.Weight FROM entrepreneur AS T1 INNER JOIN people AS T2 ON T1.People_ID = T2.People_ID ORDER BY T1.Money_Requested DESC"
        ]
    },
    "2412": {
        "db_id": "candidate_poll",
        "question": "Find the average and minimum weight for each gender.",
        "ground_truth": "SELECT avg(weight) ,  min(weight) ,  sex FROM people GROUP BY sex",
        "amends": [
            "Do use `sex` instead of `gender` as the grouping column. Do calculate `avg(weight)` and `min(weight)` instead of `AVG(weight)` and incorrectly labeled `MAX(weight) as min_weight`. Do remove the column aliases `average_weight` and `min_weight` instead of keeping them. The amended query now correctly calculates the average and minimum weight grouped by sex, matching the intended behavior.",
            "Do place the `sex` column at the end of the SELECT list instead of at the beginning, and do use lowercase function names `avg` and `min` instead of uppercase `AVG` and `MIN`, while maintaining the same aggregation logic with GROUP BY `sex`. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question mentions \"gender\": use the exact column token \"sex\" for grouping instead. 2) When calculating the average weight: compute avg(weight) without column aliases. 3) When calculating the minimum weight: compute min(weight) instead of MAX(weight) and do not use column aliases. 4) When grouping by gender (sex): organize results by the \"sex\" column and compute requested aggregates per group.",
            "1) When the question asks for \"average and minimum weight for each gender\": make sure the output order is: average weight, minimum weight, then gender (sex column). 2) When computing aggregate functions: use lowercase function names \"avg\" and \"min\" instead of uppercase \"AVG\" and \"MIN\". 3) When grouping by gender: use the \"sex\" column for grouping and maintain the same aggregation logic with GROUP BY \"sex\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT gender, AVG(weight) as average_weight, MAX(weight) as min_weight FROM people GROUP BY gender;",
            "SELECT sex, AVG(weight), MIN(weight) FROM people GROUP BY sex;",
            "SELECT avg(weight), min(weight), sex FROM people GROUP BY sex;"
        ],
        "rule_sql": [
            "SELECT avg(Weight), min(Weight), Sex FROM people GROUP BY Sex"
        ]
    },
    "1285": {
        "db_id": "game_injury",
        "question": "How many different kinds of information sources are there for injury accidents?",
        "ground_truth": "SELECT count(DISTINCT SOURCE) FROM injury_accident",
        "amends": [
            "Do use `count(DISTINCT SOURCE)` instead of `COUNT(*)` to count distinct sources rather than all rows. Do reference table `injury_accident` instead of `information_sources` to query the correct data source. Do remove the `WHERE accident_type = 'injury'` filter instead of keeping it since the table name already implies the injury context. The amended query now correctly counts distinct sources from the injury accident table, matching the intended behavior."
        ],
        "rules": [
            "1) When counting different kinds of information sources: use count(DISTINCT SOURCE) instead of COUNT(*) to count distinct sources rather than all rows. 2) When answering about injury accidents: reference table injury_accident instead of information_sources to query the correct data source. 3) When the table name already implies the injury context: remove any WHERE accident_type = 'injury' filter since it's redundant."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM information_sources WHERE accident_type = 'injury';",
            "SELECT COUNT(DISTINCT Source) FROM injury_accident"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Source) FROM injury_accident;"
        ]
    },
    "2728": {
        "db_id": "storm_record",
        "question": "Show the region name with at least two storms.",
        "ground_truth": "SELECT T1.region_name FROM region AS T1 JOIN affected_region AS T2 ON T1.region_id = T2.region_id GROUP BY T1.region_id HAVING count(*)  >=  2",
        "amends": [
            "Do select `T1.region_name` with table alias instead of just `region_name` without qualification. Do add `FROM region AS T1 JOIN affected_region AS T2` with explicit table aliases and join instead of just `FROM storms` without joins. Do use join condition `ON T1.region_id = T2.region_id` instead of no join condition. Do group by `T1.region_id` instead of `region_name` to ensure proper aggregation. Do use `>= 2` threshold instead of `> 1` for counting at least two occurrences. The amended query now correctly joins the region and affected_region tables to count storm occurrences per region and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"region name with at least two storms\": make sure the output order: T1.region_name. 2) When combining T1 (region) and T2 (affected_region) for shared entities: link rows where T1.region_id = T2.region_id exactly as shown; keep only matching pairs (inner match). 3) When the question asks for \"at least two storms\": organize results by T1.region_id and compute count of storm occurrences per group using >= 2 threshold. 4) When grouping by region: use T1.region_id as the grouping key instead of region_name to ensure proper aggregation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT region_name FROM storms GROUP BY region_name HAVING COUNT(*) > 1",
            "SELECT T1.Region_name \nFROM region AS T1 \nJOIN affected_region AS T2 ON T1.Region_id = T2.Region_id \nGROUP BY T1.Region_id \nHAVING COUNT(T2.Storm_ID) >= 2"
        ],
        "rule_sql": [
            "SELECT T1.region_name FROM region T1 JOIN affected_region T2 ON T1.region_id = T2.region_id GROUP BY T1.region_id HAVING COUNT(T2.Storm_ID) >= 2 ORDER BY T1.region_name;"
        ]
    },
    "1055": {
        "db_id": "match_season",
        "question": "What are the names and capitals of each country?",
        "ground_truth": "SELECT Country_name ,  Capital FROM country",
        "amends": [
            "Do use `Country_name` and `Capital` column names instead of `name` and `capital`. Do reference the `country` table instead of `countries`. Do remove the `WHERE population > 1000000000` filter instead of keeping it. The amended query now matches the RIGHT_SQL's behavior by selecting all records from the country table with the correct column names."
        ],
        "rules": [
            "1) When answering about \"names and capitals of each country\": make sure the output order: Country_name, Capital. 2) When the question mentions \"names\": \"names\" actually means \"Country_name in schema\". 3) When the question mentions \"capitals\": \"capitals\" actually means \"Capital in schema\". 4) When the question refers to \"countries\": use the table \"country\" instead of \"countries\". 5) When the question asks for \"each country\": include all records from the country table without any population filter."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, capital FROM countries WHERE population > 1000000000;",
            "SELECT Country_name, Capital FROM country;"
        ],
        "rule_sql": [
            "SELECT Country_name, Capital FROM country;"
        ]
    },
    "2301": {
        "db_id": "entrepreneur",
        "question": "Show the company of the tallest entrepreneur.",
        "ground_truth": "SELECT T1.Company FROM entrepreneur AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Height DESC LIMIT 1",
        "amends": [
            "Do join `entrepreneur AS T1` with `people AS T2` on `T1.People_ID = T2.People_ID` instead of querying only the `entrepreneurs` table without any join. Do select `T1.Company` instead of just `company` to specify the table source. Do order by `T2.Height DESC` instead of `height DESC` to reference the height from the correct joined table. The amended query now correctly retrieves the company associated with the tallest person by properly joining the entrepreneur and people tables on their relationship key."
        ],
        "rules": [
            "1) When answering about \"the tallest entrepreneur\": join table \"entrepreneur\" as T1 with table \"people\" as T2 using the exact key equality T1.People_ID = T2.People_ID to link entrepreneur records with their corresponding person data. 2) When selecting the company: use T1.Company to specify the exact column from the entrepreneur table. 3) When ordering by height: use T2.Height DESC to reference the height column from the people table in descending order. 4) When retrieving the top result: keep only the first row after ordering to get the tallest entrepreneur's company."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT company FROM entrepreneurs ORDER BY height DESC LIMIT 1;",
            "SELECT T1.Company FROM entrepreneur AS T1 JOIN people AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Height DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Company FROM entrepreneur AS T1 JOIN people AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Height DESC LIMIT 1;"
        ]
    },
    "4955": {
        "db_id": "soccer_2",
        "question": "How many hours do the players train on average?",
        "ground_truth": "SELECT avg(HS) FROM Player",
        "amends": [
            "Do use `avg(HS)` instead of `AVG(training_hours)` to reference the correct column name and table. Do reference table `Player` instead of `players` to use the correct table name. The amended query now correctly calculates the average of the HS column from the Player table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for average training hours: use the exact column name \"HS\" from the Player table instead of \"training_hours\". 2) When referencing the player data table: use the exact table name \"Player\" instead of \"players\". 3) When calculating average training hours: compute the average of the \"HS\" column from the Player table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(training_hours) FROM players;",
            "SELECT AVG(HS) FROM Player;"
        ],
        "rule_sql": [
            "SELECT AVG(HS) FROM Player;"
        ]
    },
    "6603": {
        "db_id": "train_station",
        "question": "Show the names and main services for train stations that have the top three total number of passengers.",
        "ground_truth": "SELECT name ,  main_services FROM station ORDER BY total_passengers DESC LIMIT 3",
        "amends": [
            "Do select `name, main_services` instead of `name, main_service, SUM(passengers) as total_passengers`. Do use `FROM station` instead of `FROM train_stations`. Do remove `GROUP BY name, main_service` instead of keeping it. Do keep `ORDER BY total_passengers DESC LIMIT 3` unchanged. The amended query now matches RIGHT_SQL's behavior by selecting the correct columns from the proper table source without unnecessary aggregation."
        ],
        "rules": [
            "1) When answering about \"train stations that have the top three total number of passengers\": make sure the output order: name, main_services. 2) When the question mentions \"train stations\": \"train stations\" actually means \"station\" in schema. 3) When the question mentions \"top three\" by total passengers: rank rows by total_passengers in descending order and keep the first 3 rows. 4) When selecting columns: do not include SUM(passengers) as total_passengers in the output columns. 5) When grouping data: do not group by name and main_service since the question asks for individual station records with their passenger counts."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, main_service, SUM(passengers) as total_passengers \nFROM train_stations \nGROUP BY name, main_service \nORDER BY total_passengers DESC \nLIMIT 3;",
            "SELECT Name, Main_Services FROM station ORDER BY Total_Passengers DESC LIMIT 3"
        ],
        "rule_sql": [
            "SELECT Name, Main_Services FROM station ORDER BY Total_Passengers DESC LIMIT 3"
        ]
    },
    "1746": {
        "db_id": "gymnast",
        "question": "What are the names of gymnasts?",
        "ground_truth": "SELECT T2.Name FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID",
        "amends": [
            "Do select `T2.Name` from the `people` table instead of `name` from the `gymnasts` table. Do join `gymnast AS T1` with `people AS T2` using `T1.Gymnast_ID = T2.People_ID` instead of querying only the `gymnasts` table. Do remove the `WHERE age > 30` filter instead of keeping it, as the join condition now properly relates gymnast records to people data. The amended query correctly retrieves gymnast names from the associated people table rather than assuming the name field exists directly in the gymnasts table."
        ],
        "rules": [
            "1) When answering about \"names of gymnasts\": make sure the output order: T2.Name 2) When the question mentions \"gymnasts\": \"gymnasts\" actually means \"T1.gymnast table\" in schema 3) When combining T1 and T2 for shared entities: link rows where T1.Gymnast_ID = T2.People_ID exactly as shown in the amends; keep only matching pairs (inner match) 4) When the question asks for names: select T2.Name from the people table instead of name from the gymnasts table 5) When the question does not specify any age filter: do not apply any WHERE age > 30 filter"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM gymnasts WHERE age > 30;",
            "SELECT T2.Name FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID = T2.People_ID"
        ],
        "rule_sql": [
            "SELECT T2.Name FROM gymnast T1 INNER JOIN people T2 ON T1.Gymnast_ID = T2.People_ID ORDER BY T2.Name"
        ]
    },
    "6439": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "How many budget types do we have?",
        "ground_truth": "SELECT count(*) FROM Ref_budget_codes",
        "amends": [
            "Do reference the `Ref_budget_codes` table instead of the `budget_types` table in the FROM clause. Do count all rows from the correct table instead of the incorrect one. The amended query now correctly counts records from the appropriate reference table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"how many budget types\": make sure to reference the \"Ref_budget_codes\" table instead of \"budget_types\" table. 2) When counting all budget types: count all rows from the \"Ref_budget_codes\" table using the table's complete set of records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM budget_types;",
            "SELECT COUNT(*) FROM Ref_Budget_Codes;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Ref_Budget_Codes;"
        ]
    },
    "138": {
        "db_id": "bike_1",
        "question": "What is the number of days that had an average humity above 50 and an average visibility above 8?",
        "ground_truth": "SELECT COUNT(*) FROM weather WHERE mean_humidity  >  50 AND mean_visibility_miles  >  8",
        "amends": [
            "Do reference table `weather` instead of `weather_data`. Do use column `mean_humidity` instead of `humidity` for the humidity filter. Do use column `mean_visibility_miles` instead of `visibility` for the visibility filter. The amended query now correctly counts records from the weather table where both mean humidity exceeds 50 and mean visibility exceeds 8 miles."
        ],
        "rules": [
            "1) When the question asks about \"weather data\": use table \"weather\" instead of \"weather_data\". 2) When filtering for humidity above 50: use column \"mean_humidity\" instead of \"humidity\" and apply the condition > 50. 3) When filtering for visibility above 8: use column \"mean_visibility_miles\" instead of \"visibility\" and apply the condition > 8. 4) When counting days that meet both humidity and visibility conditions: count the number of rows in table \"weather\" where both \"mean_humidity\" > 50 and \"mean_visibility_miles\" > 8."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM weather_data WHERE humidity > 50 AND visibility > 8",
            "SELECT COUNT(*) AS number_of_days\nFROM weather\nWHERE mean_humidity > 50 AND mean_visibility_miles > 8;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM weather WHERE mean_humidity > 50 AND mean_visibility_miles > 8;"
        ]
    },
    "851": {
        "db_id": "chinook_1",
        "question": "What city does the employee who helps the customer with postal code 70174 live in?",
        "ground_truth": "SELECT T2.City FROM CUSTOMER AS T1 JOIN EMPLOYEE AS T2 ON T1.SupportRepId  =  T2.EmployeeId WHERE T1.PostalCode  =  \"70174\"",
        "amends": [
            "Do select `T2.City` from the `CUSTOMER` table instead of `city` from the `employees` table. Do join `EMPLOYEE AS T2` on `T1.SupportRepId = T2.EmployeeId` instead of querying only the `employees` table. Do filter on `T1.PostalCode = \"70174\"` instead of `postal_code = '70174'` to reference the customer's postal code rather than the employee's. Do use double quotes around the postal code value instead of single quotes. The amended query now correctly retrieves customer cities by joining customer and employee tables based on support representative relationships."
        ],
        "rules": [
            "1) When answering about \"What city does the employee who helps the customer with postal code 70174 live in?\": make sure the output order: T2.City. 2) When the question mentions \"postal code 70174\": \"postal code 70174\" actually means \"T1.PostalCode = \\\"70174\\\" in schema\". 3) When combining T1 (CUSTOMER) and T2 (EMPLOYEE) for shared entities: link rows where T1.SupportRepId = T2.EmployeeId exactly as shown in the amends; keep only matching pairs (inner match). 4) When handling text literals: do not change case, spacing, or punctuation - use exactly \\\"70174\\\" with double quotes. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms - use \\\"70174\\\" exactly as specified."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city FROM employees WHERE postal_code = '70174';",
            "SELECT T2.City \nFROM Customer AS T1 \nJOIN Employee AS T2 ON T1.SupportRepId = T2.EmployeeId \nWHERE T1.PostalCode = \"70174\""
        ],
        "rule_sql": [
            "SELECT T2.City FROM Customer T1 JOIN Employee T2 ON T1.SupportRepId = T2.EmployeeId WHERE T1.PostalCode = \"70174\""
        ]
    },
    "2559": {
        "db_id": "county_public_safety",
        "question": "What are the crime rates of counties that contain cities that have white percentages of over 90?",
        "ground_truth": "SELECT T2.Crime_rate FROM city AS T1 JOIN county_public_safety AS T2 ON T1.County_ID  =  T2.County_ID WHERE T1.White  >  90",
        "amends": [
            "Do select only `T2.Crime_rate` instead of selecting both `county` and `crime_rate`. Do use `city AS T1` joined with `county_public_safety AS T2` instead of querying only from `counties`. Do use `JOIN` with `T1.County_ID = T2.County_ID` instead of the subquery approach. Do filter directly with `T1.White > 90` instead of using a subquery with `white_percentage > 90`. Do remove the subquery entirely instead of maintaining the IN clause structure. The amended query now correctly retrieves crime rates from the appropriate tables using proper join relationships and direct filtering."
        ],
        "rules": [
            "1) When answering about crime rates of counties: make sure the output order: T2.Crime_rate only\n2) When combining city and county_public_safety tables: link rows where T1.County_ID = T2.County_ID and keep only matching pairs (inner match)\n3) When the question mentions \"white percentages of over 90\": \"white percentages\" actually means \"T1.White > 90\" in schema\n4) When selecting output columns: do not include county name, only include T2.Crime_rate"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT county, crime_rate \nFROM counties \nWHERE city IN (\n    SELECT city \n    FROM cities \n    WHERE white_percentage > 90\n)",
            "SELECT T2.Crime_rate \nFROM city AS T1 \nJOIN county_public_safety AS T2 ON T1.County_ID = T2.County_ID \nWHERE T1.White > 90"
        ],
        "rule_sql": [
            "SELECT T2.Crime_rate \nFROM city T1\nINNER JOIN county_public_safety T2 ON T1.County_ID = T2.County_ID\nWHERE T1.White > 90\nORDER BY T2.Crime_rate"
        ]
    },
    "2814": {
        "db_id": "news_report",
        "question": "Show the names of journalists and the number of events they reported.",
        "ground_truth": "SELECT T3.Name ,  COUNT(*) FROM news_report AS T1 JOIN event AS T2 ON T1.Event_ID  =  T2.Event_ID JOIN journalist AS T3 ON T1.journalist_ID  =  T3.journalist_ID GROUP BY T3.Name",
        "amends": [
            "Do join `news_report AS T1` and `event AS T2` on `T1.Event_ID = T2.Event_ID` instead of querying only `events` table. Do add join to `journalist AS T3` on `T1.journalist_ID = T3.journalist_ID` instead of omitting journalist table. Do select `T3.Name` instead of `journalist_name` since the column comes from the journalist table. Do use proper table aliases and qualified column references throughout instead of unqualified column names. The amended query now correctly joins the three related tables to count events per journalist by establishing the proper relationships through foreign keys."
        ],
        "rules": [
            "1) When answering about \"journalists and the number of events they reported\": make sure the output order: journalist name, then count of events. 2) When the question mentions \"journalists\": \"journalists\" actually means \"journalist AS T3\" in schema. 3) When the question mentions \"events\": \"events\" actually means \"event AS T2\" in schema. 4) When combining news_report AS T1 and event AS T2 for shared entities: link rows where T1.Event_ID = T2.Event_ID exactly as shown; keep only matching pairs (inner match). 5) When combining news_report AS T1 and journalist AS T3 for shared entities: link rows where T1.journalist_ID = T3.journalist_ID exactly as shown; keep only matching pairs (inner match). 6) When the question asks for \"names of journalists\": select T3.Name instead of journalist_name since the column comes from the journalist table. 7) When the question asks for \"number of events they reported\": compute the count using the canonical key from the event table per journalist. 8) When the question says \"per journalist\": organize results by T3.Name and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT journalist_name, COUNT(*) FROM events GROUP BY journalist_name;",
            "SELECT T3.Name, COUNT(T1.Event_ID) AS NumberOfEvents\nFROM news_report AS T1\nJOIN event AS T2 ON T1.Event_ID = T2.Event_ID\nJOIN journalist AS T3 ON T1.journalist_ID = T3.journalist_ID\nGROUP BY T3.journalist_ID, T3.Name\nORDER BY NumberOfEvents DESC;"
        ],
        "rule_sql": [
            "SELECT T3.Name, COUNT(T2.Event_ID) AS NumberOfEvents FROM news_report AS T1 INNER JOIN event AS T2 ON T1.Event_ID = T2.Event_ID INNER JOIN journalist AS T3 ON T1.journalist_ID = T3.journalist_ID GROUP BY T3.Name ORDER BY T3.Name, NumberOfEvents;"
        ]
    },
    "4195": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "What is the description of the role named \"Proof Reader\"?",
        "ground_truth": "SELECT role_description FROM ROLES WHERE role_name  =  \"Proof Reader\"",
        "amends": [
            "Do select `role_description` instead of `description` and use `role_name` instead of `name` in the WHERE clause. Do use double quotes around the string literal `\"Proof Reader\"` instead of single quotes. The amended query now correctly references the appropriate column names and string formatting to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for description of a role: use the exact column token \"role_description\" instead of \"description\". 2) When filtering by role name: use the exact column token \"role_name\" instead of \"name\" in the condition. 3) When comparing to the literal value \"Proof Reader\": use double quotes around the exact string literal \"Proof Reader\" instead of single quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description FROM roles WHERE name = 'Proof Reader';",
            "SELECT role_description FROM Roles WHERE role_name = \"Proof Reader\";"
        ],
        "rule_sql": [
            "SELECT role_description FROM Roles WHERE role_name = \"Proof Reader\";"
        ]
    },
    "2308": {
        "db_id": "perpetrator",
        "question": "What are the names of people in ascending order of height?",
        "ground_truth": "SELECT Name FROM People ORDER BY Height ASC",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM people ORDER BY height DESC;"
        ],
        "rule_sql": [
            "SELECT Name FROM people ORDER BY Height ASC;"
        ]
    },
    "2404": {
        "db_id": "candidate_poll",
        "question": "which poll source does the highest oppose rate come from?",
        "ground_truth": "SELECT poll_source FROM candidate ORDER BY oppose_rate DESC LIMIT 1",
        "amends": [
            "Do select `poll_source` instead of `source, MAX(oppose_rate)` and remove the aggregate function. Do query from `candidate` table instead of `polls` table with `GROUP BY source`. Do remove the `GROUP BY` clause entirely instead of grouping by `source`. Do keep `ORDER BY oppose_rate DESC` and `LIMIT 1` but apply them directly to the candidate table instead of after aggregation. The amended query now correctly retrieves the single candidate with the highest oppose rate directly from the candidate table rather than attempting to aggregate poll data, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"which poll source does the highest oppose rate come from\": make sure the output order: poll_source. 2) When the question mentions \"poll source\": \"poll source\" actually means \"poll_source in schema\". 3) When the question mentions \"highest oppose rate\": rank rows by oppose_rate in descending direction and keep the first 1 row. 4) When querying from the candidate table: do not use GROUP BY clauses or aggregate functions like MAX()."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT source, MAX(oppose_rate) FROM polls GROUP BY source ORDER BY oppose_rate DESC LIMIT 1;",
            "SELECT Poll_Source FROM candidate ORDER BY Oppose_rate DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Poll_Source FROM candidate ORDER BY Oppose_rate DESC LIMIT 1;"
        ]
    },
    "5846": {
        "db_id": "tracking_share_transactions",
        "question": "Show all distinct lot details.",
        "ground_truth": "SELECT DISTINCT lot_details FROM LOTS",
        "amends": [
            "Do select only `lot_details` instead of all columns with `*`. Do add `DISTINCT` to remove duplicate rows instead of returning all records. Do use the correct table name `LOTS` instead of `lots` to match the schema. The amended query now correctly returns unique lot details from the LOTS table as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for \"distinct lot details\": select only the \"lot_details\" column instead of all columns with *. 2) When the question asks for \"distinct lot details\": add DISTINCT to remove duplicate rows instead of returning all records. 3) When referring to the table containing lot details: use the exact table name \"LOTS\" instead of \"lots\" to match the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM lots;",
            "SELECT DISTINCT lot_details FROM Lots;"
        ],
        "rule_sql": [
            "SELECT DISTINCT lot_details FROM Lots;"
        ]
    },
    "1875": {
        "db_id": "wrestler",
        "question": "Which locations are shared by more than two wrestlers?",
        "ground_truth": "SELECT LOCATION FROM wrestler GROUP BY LOCATION HAVING COUNT(*)  >  2",
        "amends": [
            "Do use `COUNT(*)` instead of `COUNT(wrestler_id)` to count all rows including those with NULL values. Do change the threshold to `> 2` instead of `> 1` to filter for locations with more than two wrestlers. Do remove the `wrestler_count` alias from the SELECT list instead of including it since it's not needed in the output. The amended query now correctly identifies locations with more than two wrestlers by counting all records and using the appropriate threshold."
        ],
        "rules": [
            "1) When counting locations shared by wrestlers: count all rows using COUNT(*) instead of counting a specific column to include records with NULL values. 2) When filtering for locations with more than two wrestlers: use a threshold of > 2 instead of > 1. 3) When producing output for locations shared by wrestlers: only include the location column in the output and exclude any count aliases like wrestler_count."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location, COUNT(wrestler_id) as wrestler_count\nFROM wrestlers\nGROUP BY location\nHAVING wrestler_count > 1;",
            "SELECT Location FROM wrestler GROUP BY Location HAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT Location FROM wrestler GROUP BY Location HAVING COUNT(*) > 2;"
        ]
    },
    "5164": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "Show the names of all the clients with no booking.",
        "ground_truth": "SELECT Customer_Name FROM Clients EXCEPT SELECT T2.Customer_Name FROM Bookings AS T1 JOIN Clients AS T2 ON T1.Customer_ID  =  T2.Client_ID",
        "amends": [
            "Do select `Customer_Name` instead of `name` and use `EXCEPT` to find customers without bookings instead of checking `booking_id IS NULL`. Do add a join between `Bookings` and `Clients` on `Customer_ID = Client_ID` instead of omitting the Bookings table entirely. Do reference the joined table with alias `T2` instead of directly querying the base table. Do remove the `WHERE` filter on `booking_id` instead of keeping it, as the EXCEPT operation now correctly identifies customers without bookings by comparing the full customer sets. The amended query now matches the RIGHT_SQL's behavior of properly finding customers who have never made any bookings."
        ],
        "rules": [
            "1) When the question asks for client names: use the exact column token \"Customer_Name\" instead of \"name\". 2) When finding clients with no bookings: use EXCEPT operation to compare all customers against those with bookings instead of checking for NULL booking_id. 3) When combining Customers and Bookings tables: link rows where \"Customer_ID\" equals \"Client_ID\" exactly as specified. 4) When referencing the joined Bookings table: use alias T2 as established in the amends. 5) When the question asks for clients without bookings: remove any WHERE filter on booking_id since the EXCEPT operation correctly identifies customers without bookings by set comparison."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM clients WHERE booking_id IS NULL;",
            "SELECT Customer_Name FROM Clients\nEXCEPT\nSELECT c.Customer_Name FROM Clients c\nJOIN Bookings b ON c.Client_ID = b.Customer_ID"
        ],
        "rule_sql": [
            "SELECT Customer_Name FROM Clients\nEXCEPT\nSELECT c.Customer_Name FROM Clients c\nJOIN Bookings b ON c.Client_ID = b.Customer_ID"
        ]
    },
    "757": {
        "db_id": "race_track",
        "question": "Show the name, location, open year for all tracks with a seating higher than the average.",
        "ground_truth": "SELECT name ,  LOCATION ,  year_opened FROM track WHERE seating  >  (SELECT avg(seating) FROM track)",
        "amends": [
            "Do reference table `track` instead of `tracks` in both the main query and subquery. Do use column `year_opened` instead of `open_year` in the SELECT list. Do use lowercase `avg(seating)` instead of uppercase `AVG(seating)` in the subquery. Do maintain the same WHERE filter logic with `seating > (SELECT avg(seating) FROM track)` instead of the incorrect table reference. The amended query now correctly references the track table schema and matches the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"tracks\": use the exact table name \"track\" instead of \"tracks\". 2) When the question asks for \"open year\": use the exact column name \"year_opened\" instead of \"open_year\". 3) When computing average seating: use lowercase \"avg(seating)\" instead of uppercase \"AVG(seating)\" in the subquery. 4) When filtering for seating higher than average: maintain the same WHERE filter logic with \"seating > (SELECT avg(seating) FROM track)\" using the correct table reference."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, location, open_year FROM tracks WHERE seating > (SELECT AVG(seating) FROM tracks);",
            "SELECT Name, Location, Year_Opened FROM track WHERE seating > (SELECT avg(seating) FROM track)"
        ],
        "rule_sql": [
            "SELECT Name, Location, Year_Opened FROM track WHERE seating > (SELECT avg(seating) FROM track)"
        ]
    },
    "4131": {
        "db_id": "film_rank",
        "question": "What are the titles of films and corresponding types of market estimations?",
        "ground_truth": "SELECT T1.Title ,  T2.Type FROM film AS T1 JOIN film_market_estimation AS T2 ON T1.Film_ID  =  T2.Film_ID",
        "amends": [
            "Do specify columns `T1.Title` and `T2.Type` with table aliases instead of `title` and `market_estimation` without table references. Do add table `film_market_estimation` as `T2` instead of omitting it. Do use `JOIN` with `ON T1.Film_ID = T2.Film_ID` instead of no join condition. Do add table alias `AS T1` for `film` instead of no alias. The amended query now correctly joins the film and film_market_estimation tables to retrieve the appropriate columns with proper table references."
        ],
        "rules": [
            "1) When answering about film titles and market estimation types: make sure the output order: T1.Title, T2.Type\n2) When combining film and film_market_estimation tables: link rows where T1.Film_ID = T2.Film_ID and keep only matching pairs (inner match)\n3) When referring to table roles: use T1 for film table and T2 for film_market_estimation table\n4) When selecting columns: use T1.Title for film titles and T2.Type for market estimation types instead of unqualified column names"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title, market_estimation FROM films;",
            "SELECT T1.Title, T2.Type FROM film AS T1 JOIN film_market_estimation AS T2 ON T1.Film_ID = T2.Film_ID"
        ],
        "rule_sql": [
            "SELECT T1.Title, T2.Type FROM film T1 INNER JOIN film_market_estimation T2 ON T1.Film_ID = T2.Film_ID ORDER BY T1.Title, T2.Type;"
        ]
    },
    "3984": {
        "db_id": "hospital_1",
        "question": "Find the names of all procedures such that the cost is less than 5000 and physician John Wen was trained in.",
        "ground_truth": "SELECT name FROM procedures WHERE cost  <  5000 INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  \"John Wen\"",
        "amends": [
            "Do select only `name` instead of `p.name` with table alias. Do use `INTERSECT` instead of multiple joins to find procedures meeting both criteria. Do filter `cost < 5000` directly in the first SELECT instead of in WHERE with joins. Do use table aliases `T1`, `T2`, `T3` instead of `ph`, `pt`, `p`. Do join `physician AS T1` with `trained_in AS T2` on `T1.employeeid = T2.physician` instead of joining `physicians` with `physician_training` on `physician_id`. Do join `procedures AS T3` with `trained_in AS T2` on `T3.code = T2.treatment` instead of joining on `procedure_id`. Do filter by `T1.name = \"John Wen\"` instead of separate `first_name` and `last_name` conditions. The amended query now correctly uses INTERSECT to find procedures that are both low-cost and performed by the specified physician, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting column names from a single table: use just the column name without table alias (e.g., \"name\" instead of \"p.name\"). 2) When finding entities that must satisfy multiple independent criteria: use INTERSECT to combine results from separate queries rather than joining tables. 3) When filtering by cost criteria: apply the cost filter directly in the SELECT statement where the cost column is available (e.g., \"cost < 5000\" in the procedures query). 4) When using table aliases: use T1 for physician table, T2 for trained_in table, and T3 for procedures table as canonical aliases. 5) When joining physician and trained_in tables: link them using T1.employeeid = T2.physician instead of physician_id columns. 6) When joining procedures and trained_in tables: link them using T3.code = T2.treatment instead of procedure_id columns. 7) When filtering by physician name: use T1.name = \"John Wen\" as a single condition instead of separate first_name and last_name filters."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.name \nFROM procedures p\nJOIN physician_training pt ON p.procedure_id = pt.procedure_id\nJOIN physicians ph ON pt.physician_id = ph.physician_id\nWHERE p.cost < 5000 \nAND ph.first_name = 'John' \nAND ph.last_name = 'Wen';",
            "SELECT Name FROM Procedures WHERE Cost < 5000\nINTERSECT\nSELECT T3.Name FROM Physician AS T1\nJOIN Trained_In AS T2 ON T1.EmployeeID = T2.Physician\nJOIN Procedures AS T3 ON T3.Code = T2.Treatment\nWHERE T1.Name = 'John Wen'"
        ],
        "rule_sql": [
            "SELECT name FROM Procedures WHERE cost < 5000\nINTERSECT\nSELECT T3.name FROM Procedures T3\nJOIN Trained_In T2 ON T3.code = T2.treatment\nJOIN Physician T1 ON T1.employeeid = T2.physician\nWHERE T1.name = \"John Wen\""
        ]
    },
    "560": {
        "db_id": "store_1",
        "question": "What are the total amount of money in the invoices billed from Chicago, Illinois?",
        "ground_truth": "SELECT sum(total) FROM invoices WHERE billing_city  =  \"Chicago\" AND billing_state  =  \"IL\";",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(total) FROM invoices WHERE billing_city = 'Chicago' AND billing_state = 'IL';"
        ],
        "rule_sql": [
            "SELECT SUM(total) AS total_amount FROM invoices WHERE billing_city = 'Chicago' AND billing_state = 'Illinois'",
            "SELECT SUM(total) AS total_amount FROM invoices WHERE billing_city = 'Chicago' AND billing_state = 'Illinois'"
        ]
    },
    "5497": {
        "db_id": "voter_2",
        "question": "What are the distinct last names of the students who have president votes but do not have 2192 as the advisor?",
        "ground_truth": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  \"2192\"",
        "amends": [
            "Do select `T1.LName` from the `STUDENT` table instead of `last_name` from `students`. Do join with `VOTING_RECORD` table on `T1.StuID = PRESIDENT_Vote` instead of filtering with `president_votes > 0`. Do use `EXCEPT` to exclude records instead of filtering with `AND advisor != 2192`. Do reference `Advisor = \"2192\"` with quotes instead of numeric comparison. Do maintain `DISTINCT` selection but apply it to the correct column and table structure. The amended query now correctly identifies students who voted for president while excluding those with advisor 2192, matching the intended behavior."
        ],
        "rules": [
            "1) When selecting student last names: use \"T1.LName\" from the \"STUDENT\" table instead of \"last_name\" from \"students\". 2) When identifying students who have president votes: join \"STUDENT\" (T1) with \"VOTING_RECORD\" table where \"T1.StuID = PRESIDENT_Vote\" instead of filtering with \"president_votes > 0\". 3) When excluding students with advisor 2192: use EXCEPT operation to remove records where \"Advisor = \"2192\"\" (with quotes) instead of numeric comparison \"advisor != 2192\". 4) When maintaining distinct results: apply DISTINCT selection to the correct column \"T1.LName\" from the joined table structure."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT last_name FROM students WHERE president_votes > 0 AND advisor != 2192;",
            "SELECT DISTINCT T1.LName \nFROM Student T1\nJOIN Voting_record T2 ON T1.StuID = T2.President_Vote\nEXCEPT\nSELECT DISTINCT T1.LName \nFROM Student T1\nJOIN Voting_record T2 ON T1.StuID = T2.President_Vote\nWHERE T1.Advisor = \"2192\""
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.LName\nFROM Student T1\nJOIN Voting_record ON T1.StuID = Voting_record.President_Vote\nEXCEPT\nSELECT T1.LName\nFROM Student T1\nWHERE T1.Advisor = \"2192\""
        ]
    },
    "4469": {
        "db_id": "network_2",
        "question": "Which friend of Zach has the longest-lasting friendship?",
        "ground_truth": "SELECT friend FROM PersonFriend WHERE name =  'Zach' AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  'Zach')",
        "amends": [
            "Do select `friend` instead of `friend_name` and use the correct table name `PersonFriend` instead of `friendships`. Do add the condition `YEAR = (SELECT max(YEAR) FROM PersonFriend WHERE name = 'Zach')` instead of omitting this year-based filtering logic. Do remove `ORDER BY friendship_start_date ASC LIMIT 1` instead of keeping this date-based limiting approach, as the correct logic requires filtering by maximum year rather than earliest date. The amended query now correctly retrieves the friend associated with the most recent year for Zach, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"friend of Zach\": use the exact table name \"PersonFriend\" and column \"friend\" with exact literal 'Zach' for the name condition. 2) When determining the longest-lasting friendship: filter to only include records where YEAR equals the maximum YEAR value for records where name = 'Zach'. 3) When selecting output: return the \"friend\" column value from the filtered results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT friend_name FROM friendships WHERE person_name = 'Zach' ORDER BY friendship_start_date ASC LIMIT 1;",
            "SELECT friend FROM PersonFriend WHERE name = 'Zach' AND year = (SELECT MAX(year) FROM PersonFriend WHERE name = 'Zach')"
        ],
        "rule_sql": [
            "SELECT friend FROM PersonFriend WHERE name = 'Zach' AND year = (SELECT MAX(year) FROM PersonFriend WHERE name = 'Zach')"
        ]
    },
    "5508": {
        "db_id": "voter_2",
        "question": "Which major has the most students?",
        "ground_truth": "SELECT Major FROM STUDENT GROUP BY major ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference the table as `STUDENT` instead of `students` to match the correct schema. Do capitalize `Major` in the SELECT list instead of lowercase `major` to align with the column name. Do maintain the same aggregation `COUNT(*)` and grouping by `major` without change. Do preserve the ordering by `count(*) DESC` and `LIMIT 1` without modification. The amended query now correctly references the table and column names to match the intended schema while maintaining identical aggregation logic.",
            "Do select only `Major` instead of selecting both `Major` and `COUNT(*) AS count`. Do order by `count(*) DESC` instead of ordering by the alias `count DESC`. The amended query now correctly returns only the major with the highest count of students, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"which major has the most students\": make sure the output order: Major, count of students. 2) When the question mentions \"students\": \"students\" actually means \"STUDENT\" in schema. 3) When the question mentions \"major\": \"major\" actually means \"Major\" in schema. 4) When the question asks for \"most students\" or \"largest count\": rank rows by count of students in descending order and keep the first 1 row. 5) When the question asks for \"count of students\": compute the number of rows using the canonical key for students (STUDENT table records). 6) When the question says \"by major\": organize results by Major and compute count per group.",
            "1) When answering about \"which major has the most students\": make sure the output order: Major only. 2) When counting students per major: compute the number of rows using the canonical key for Student entity. 3) When the question mentions \"most students\": rank rows by count(*) in descending direction and keep the first 1 row. 4) When ordering by count: use count(*) DESC instead of any alias name for the count."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT major, COUNT(*) FROM students GROUP BY major ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT Major, COUNT(*) AS count FROM Student GROUP BY Major ORDER BY count DESC LIMIT 1;",
            "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "651": {
        "db_id": "journal_committee",
        "question": "What are the names and ages of editors?",
        "ground_truth": "SELECT Name ,  Age FROM editor",
        "amends": [
            "Do reference the `editor` table instead of `editors` to use the correct table name. Do use proper column names `Name` and `Age` instead of lowercase `name` and `age` to match the actual schema. The amended query now correctly selects from the intended table with proper column references."
        ],
        "rules": [
            "1) When the question asks about \"editors\": use the table \"editor\" instead of \"editors\" to match the correct table name in the schema. 2) When selecting column names: use exact column tokens \"Name\" and \"Age\" with proper capitalization instead of lowercase \"name\" and \"age\" to match the actual schema columns. 3) When answering about names and ages of editors: make sure the output order is \"Name\" followed by \"Age\" as implied by the question structure."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, age FROM editors WHERE age > 30;",
            "SELECT Name, Age FROM editor;"
        ],
        "rule_sql": [
            "SELECT Name, Age FROM editor;"
        ]
    },
    "3385": {
        "db_id": "sports_competition",
        "question": "which countries did participated in both Friendly and Tournament type competitions.",
        "ground_truth": "SELECT country FROM competition WHERE competition_type  =  'Friendly' INTERSECT SELECT country FROM competition WHERE competition_type  =  'Tournament'",
        "amends": [
            "Do use `INTERSECT` to find countries that host both competition types instead of incorrectly using `AND` with contradictory conditions. Do query from the `competition` table instead of joining `countries` and `competitions` tables. Do select the `country` column directly instead of selecting `country_name` from a separate countries table. Do remove the `DISTINCT` keyword since `INTERSECT` inherently returns unique results instead of keeping it. Do use separate queries for each competition type condition instead of trying to apply both conditions to the same row. The amended query now correctly identifies countries that host both Friendly and Tournament competitions by using set intersection logic."
        ],
        "rules": [
            "1) When answering about countries that participated in both Friendly and Tournament type competitions: use set intersection logic instead of joining tables with contradictory conditions. 2) When the question mentions \"countries\": \"countries\" actually means the \"country\" column in the competition table. 3) When finding entities that satisfy multiple conditions separately: use separate queries for each condition (Friendly and Tournament) and intersect the results. 4) When using set operations like INTERSECT: do not include DISTINCT keyword as set operations inherently return unique results. 5) When querying from the competition table: select the \"country\" column directly instead of joining with a separate countries table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT c.country_name \nFROM countries c \nJOIN competitions comp ON c.country_id = comp.host_country_id \nWHERE comp.type = 'Friendly' \nAND comp.type = 'Tournament'",
            "SELECT Country FROM competition WHERE Competition_type = 'Friendly' INTERSECT SELECT Country FROM competition WHERE Competition_type = 'Tournament'"
        ],
        "rule_sql": [
            "SELECT country FROM competition WHERE Competition_type = 'Friendly' INTERSECT SELECT country FROM competition WHERE Competition_type = 'Tournament'"
        ]
    },
    "3419": {
        "db_id": "hr_1",
        "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.",
        "ground_truth": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id",
        "amends": [
            "Do use `NOT LIKE '%M%'` in the WHERE filter instead of `LIKE '%M%'` to exclude employees whose first names contain the letter M rather than including them. The amended query now correctly matches the RIGHT_SQL's behavior by filtering for employees without 'M' in their first names while maintaining the same column selection and ordering by department_id.",
            "Do use separate columns `first_name` and `last_name` instead of concatenating them with `FIRST_NAME || ' ' || LAST_NAME AS full_name`. Do maintain the same `WHERE first_name NOT LIKE '%M%'` filter instead of changing it. Do preserve the same `ORDER BY department_id` clause instead of modifying it. The amended query now correctly returns individual name columns instead of a concatenated full name while maintaining the same filtering and sorting behavior."
        ],
        "rules": [
            "1) When filtering for employees whose first name does not contain the letter M: use NOT LIKE '%M%' condition on the first_name column instead of LIKE '%M%' to exclude rather than include employees with 'M' in their first name. 2) When ordering results by department number: sort in ascending order using department_id column. 3) When selecting employee information: include first_name, last_name, hire_date, salary, and department_id columns in the output.",
            "1) When the question asks for \"full name (first and last)\": return separate columns \"first_name\" and \"last_name\" instead of concatenating them. 2) When filtering for employees whose first name does not contain the letter M: apply the condition \"first_name NOT LIKE '%M%'\" exactly as specified. 3) When ordering the result set: sort by \"department_id\" in ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name, hire_date, salary, department_id \nFROM employees \nWHERE first_name LIKE '%M%' \nORDER BY department_id ASC;",
            "SELECT FIRST_NAME || ' ' || LAST_NAME AS full_name, HIRE_DATE, SALARY, DEPARTMENT_ID\nFROM employees\nWHERE FIRST_NAME NOT LIKE '%M%'\nORDER BY DEPARTMENT_ID ASC;",
            "SELECT first_name, last_name, hire_date, salary, department_id \nFROM employees \nWHERE first_name NOT LIKE '%M%' \nORDER BY department_id ASC"
        ],
        "rule_sql": [
            "SELECT first_name, last_name, hire_date, salary, department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id ASC;"
        ]
    },
    "5646": {
        "db_id": "railway",
        "question": "Show different locations of railways along with the corresponding number of railways at each location.",
        "ground_truth": "SELECT LOCATION ,  COUNT(*) FROM railway GROUP BY LOCATION",
        "amends": [
            "Do reference the correct table name `railway` instead of the incorrect `railways` table. Do remove the alias `railway_count` from the count column instead of keeping it, as the right query uses an unaliased count. Do maintain the same `GROUP BY LOCATION` clause and case-insensitive column references throughout. The amended query now correctly counts records from the railway table grouped by location, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When referencing the table for railway information: use the exact table name \"railway\" instead of \"railways\". 2) When counting railways per location: compute the count without adding an alias to the result column. 3) When grouping results by location: use the \"location\" column for grouping to show different locations with their corresponding railway counts."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location, COUNT(*) as railway_count FROM railways GROUP BY location;",
            "SELECT Location, COUNT(*) FROM railway GROUP BY Location;"
        ],
        "rule_sql": [
            "SELECT location, COUNT(*) FROM railway GROUP BY location;"
        ]
    },
    "1963": {
        "db_id": "products_for_hire",
        "question": "What are the id and the amount of refund of the booking that incurred the most times of payments?",
        "ground_truth": "SELECT T1.booking_id ,  T1.amount_of_refund FROM Bookings AS T1 JOIN Payments AS T2 ON T1.booking_id  =  T2.booking_id GROUP BY T1.booking_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.booking_id` and `T1.amount_of_refund` instead of `booking_id` and `amount`. Do join `Bookings AS T1` with `Payments AS T2` on `T1.booking_id = T2.booking_id` instead of querying only the `refunds` table. Do add `GROUP BY T1.booking_id` instead of omitting grouping. Do order by `count(*) DESC` instead of `amount DESC` while keeping the `LIMIT 1` clause. The amended query now correctly identifies the booking with the most payment records instead of simply the largest refund amount, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"id and amount of refund of the booking that incurred the most times of payments\": make sure the output order: T1.booking_id, T1.amount_of_refund. 2) When the question mentions \"booking\": use table \"Bookings AS T1\" with exact column \"T1.booking_id\". 3) When the question mentions \"refund\": \"amount of refund\" actually means \"T1.amount_of_refund\" in schema. 4) When the question asks for \"most times of payments\": count the number of payment records using \"count(*)\" and rank by this count in descending order. 5) When combining Bookings (T1) and Payments (T2): link rows where T1.booking_id = T2.booking_id and keep only matching pairs (inner match). 6) When grouping by booking: organize results by T1.booking_id and compute aggregates per booking group. 7) When ranking for \"most times\": keep only the first 1 row after ordering by count(*) DESC."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT booking_id, amount FROM refunds ORDER BY amount DESC LIMIT 1;",
            "SELECT T1.booking_id, T1.amount_of_refund\nFROM Bookings AS T1\nJOIN Payments AS T2 ON T1.booking_id = T2.booking_id\nGROUP BY T1.booking_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.booking_id, T1.amount_of_refund\nFROM Bookings AS T1\nINNER JOIN Payments AS T2 ON T1.booking_id = T2.booking_id\nGROUP BY T1.booking_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "5889": {
        "db_id": "cre_Theme_park",
        "question": "Show all distinct location names.",
        "ground_truth": "SELECT DISTINCT Location_Name FROM LOCATIONS",
        "amends": [
            "Do select `Location_Name` instead of `location` and use `DISTINCT` instead of omitting it. Do reference table `LOCATIONS` instead of `table_name`. The amended query now correctly retrieves unique location names from the appropriate table."
        ],
        "rules": [
            "1) When the question asks for \"location names\": use the exact column token \"Location_Name\" from the schema. 2) When the question asks for \"distinct\" values: ensure only unique values of \"Location_Name\" are returned. 3) When referencing the table containing location data: use the exact table name \"LOCATIONS\" as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location FROM table_name;",
            "SELECT DISTINCT Location_Name FROM Locations;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Location_Name FROM Locations;"
        ]
    },
    "1514": {
        "db_id": "insurance_and_eClaims",
        "question": "Which types of policy are chosen by more than 2 customers? Give me the policy type codes.",
        "ground_truth": "SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING COUNT(customer_id) > 2;"
        ],
        "rule_sql": [
            "SELECT Policy_Type_Code\nFROM Policies\nGROUP BY Policy_Type_Code\nHAVING COUNT(DISTINCT Customer_ID) > 2;"
        ]
    },
    "753": {
        "db_id": "race_track",
        "question": "What is the name, location and seating for the most recently opened track?",
        "ground_truth": "SELECT name ,  LOCATION ,  seating FROM track ORDER BY year_opened DESC LIMIT 1",
        "amends": [
            "Do reference table `track` instead of `tracks` in the FROM clause. Do order by `year_opened DESC` instead of `opened DESC` to use the correct column name for sorting by opening year. The amended query now correctly retrieves the most recently opened track information from the proper table with the appropriate sorting column."
        ],
        "rules": [
            "1) When answering about \"most recently opened track\": order rows by \"year_opened\" in descending direction and keep the first 1 row. 2) When the question mentions \"name, location and seating\": make sure the output order: \"name\", \"location\", \"seating\". 3) When the question refers to \"tracks\": use the exact table name \"track\" instead of \"tracks\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, location, seating FROM tracks ORDER BY opened DESC LIMIT 1;",
            "SELECT Name, Location, Seating FROM track ORDER BY Year_Opened DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name, Location, Seating FROM track ORDER BY Year_Opened DESC LIMIT 1"
        ]
    },
    "53": {
        "db_id": "farm",
        "question": "What are the official names of cities that have population over 1500 or less than 500?",
        "ground_truth": "SELECT Official_Name FROM city WHERE Population  >  1500 OR Population  <  500",
        "amends": [
            "Do use table alias `city` instead of `cities` and column `Official_Name` instead of `name`. Do use column `Population` instead of `population` with proper capitalization. Do change the logical operator to `OR` instead of `AND` between the population conditions, allowing records where either condition is true rather than requiring both conditions to be met simultaneously. Do remove the redundant space formatting around operators while maintaining the same population threshold values of 1500 and 500. The amended query now correctly retrieves city names based on the intended population criteria."
        ],
        "rules": [
            "1) When the question asks for \"official names of cities\": use column \"Official_Name\" from table \"city\" instead of \"name\" from \"cities\". 2) When the question mentions \"population over 1500 or less than 500\": use column \"Population\" with proper capitalization and apply conditions \"Population > 1500 OR Population < 500\" instead of using \"AND\" between the conditions. 3) When formatting the query: remove redundant space formatting around operators while maintaining the exact population threshold values of 1500 and 500."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM cities WHERE population > 1500 AND population < 500;",
            "SELECT Official_Name FROM city WHERE Population > 1500 OR Population < 500"
        ],
        "rule_sql": [
            "SELECT Official_Name FROM city WHERE Population > 1500 OR Population < 500"
        ]
    },
    "5670": {
        "db_id": "dorm_1",
        "question": "Find the name of dorms that can accommodate more than 300 students.",
        "ground_truth": "SELECT dorm_name FROM dorm WHERE student_capacity  >  300",
        "amends": [
            "Do select `dorm_name` instead of `name` and use `student_capacity > 300` instead of `capacity < 300`. Do reference table `dorm` instead of `dorms` to match the correct schema. The amended query now correctly selects dormitory names where student capacity exceeds 300 instead of those with capacity below 300, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"name of dorms\": select \"dorm_name\" from table \"Dorm\" instead of \"name\" from \"dorms\". 2) When the question specifies \"more than 300 students\": use condition \"student_capacity > 300\" instead of \"capacity < 300\". 3) When referencing the dormitory table: use table name \"Dorm\" instead of \"dorms\" to match the correct schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM dorms WHERE capacity < 300;",
            "SELECT dorm_name FROM Dorm WHERE student_capacity > 300;"
        ],
        "rule_sql": [
            "SELECT dorm_name FROM Dorm WHERE student_capacity > 300;"
        ]
    },
    "3360": {
        "db_id": "sports_competition",
        "question": "What is the average number of points for players from the \"AIB\" club?",
        "ground_truth": "SELECT avg(T2.Points) FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID WHERE T1.name  =  \"AIB\"",
        "amends": [
            "Do reference `avg(T2.Points)` from the `player` table instead of `AVG(goals)` from an unspecified source. Do join `club AS T1` with `player AS T2` on `T1.Club_ID = T2.Club_ID` instead of querying a single table. Do filter on `T1.name = \"AIB\"` in the WHERE clause instead of filtering directly on `club = 'AIB'`. The amended query now correctly aggregates points from players belonging to the specified club by establishing the proper table relationship through the join condition."
        ],
        "rules": [
            "1) When answering about average number of points for players from a specific club: make sure the output order: average points\n2) When the question mentions \"AIB\" club: \"AIB\" actually means T1.name = \"AIB\" in the schema\n3) When combining club table (T1) and player table (T2) for shared entities: link rows where T1.Club_ID = T2.Club_ID exactly as shown in the amends; keep only matching pairs (inner match)\n4) When computing average points: use avg(T2.Points) from the player table instead of goals from an unspecified source\n5) When filtering for a specific club: use T1.name = \"AIB\" in the WHERE clause instead of filtering directly on club = 'AIB'"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(goals) FROM players WHERE club = 'AIB';",
            "SELECT AVG(T2.Points) \nFROM club AS T1 \nJOIN player AS T2 ON T1.Club_ID = T2.Club_ID \nWHERE T1.name = 'AIB'"
        ],
        "rule_sql": [
            "SELECT AVG(T2.Points) AS \"average points\"\nFROM club T1\nINNER JOIN player T2 ON T1.Club_ID = T2.Club_ID\nWHERE T1.name = \"AIB\""
        ]
    },
    "6236": {
        "db_id": "ship_1",
        "question": "What are the average and minimum age of captains in different class?",
        "ground_truth": "SELECT avg(age) ,  min(age) ,  CLASS FROM captain GROUP BY CLASS",
        "amends": [
            "Do use `avg(age)` and `min(age)` without aliases instead of `AVG(age) as average_age` and `MAX(age) as minimum_age` with incorrect aggregate function and misleading aliases. Do reference table `captain` instead of `captains` with the wrong table name. Do place `CLASS` at the end of the SELECT list instead of at the beginning. The amended query now correctly calculates the minimum age instead of incorrectly using MAX for minimum calculation and uses the proper table reference."
        ],
        "rules": [
            "1) When the question asks for \"average and minimum age\": use avg(age) for average calculation and min(age) for minimum calculation instead of MAX(age) for minimum. 2) When referencing the table containing captain data: use the exact table name \"captain\" instead of \"captains\". 3) When organizing results by class: place the CLASS column at the end of the output columns instead of at the beginning."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT class, AVG(age) as average_age, MAX(age) as minimum_age FROM captains GROUP BY class;",
            "SELECT avg(age), min(age), Class FROM captain GROUP BY Class;"
        ],
        "rule_sql": [
            "SELECT AVG(age) AS average_age, MIN(age) AS minimum_age, Class FROM captain GROUP BY Class;"
        ]
    },
    "1400": {
        "db_id": "college_2",
        "question": "Find the minimum salary for the departments whose average salary is above the average payment of all instructors.",
        "ground_truth": "SELECT min(salary) ,  dept_name FROM instructor GROUP BY dept_name HAVING avg(salary)  >  (SELECT avg(salary) FROM instructor)",
        "amends": [
            "Do use `min(salary)` and `dept_name` in the SELECT list instead of `MIN(salary)` and `department`. Do reference table `instructor` instead of `instructors`. Do move the aggregate filter `avg(salary) > (SELECT avg(salary) FROM instructor)` to the HAVING clause instead of the WHERE clause. Do remove the incorrect WHERE clause that attempted to use AVG() without GROUP BY context. Do use consistent lowercase function names `min()` and `avg()` instead of mixed case. The amended query now correctly filters groups based on their average salary compared to the overall average, matching the RIGHT_SQL's behavior.",
            "Do place `min(salary)` before `dept_name` in the SELECT list instead of the reverse order. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"minimum salary for departments\": make sure the output order: dept_name, min(salary). 2) When the question mentions \"department\": \"department\" actually means \"dept_name in schema\". 3) When the question mentions \"instructors\": \"instructors\" actually means \"instructor in schema\". 4) When filtering groups based on aggregate conditions: apply the condition avg(salary) > (SELECT avg(salary) FROM instructor) in the HAVING clause instead of WHERE clause. 5) When using aggregate functions: use lowercase function names min() and avg() instead of mixed case. 6) When the question asks for \"minimum salary\" per department: compute min(salary) grouped by dept_name.",
            "1) When answering about \"minimum salary for departments with average salary above overall average\": make sure the output order: min(salary) before dept_name. 2) When the question asks for \"minimum salary for the departments whose average salary is above the average payment of all instructors\": compute the minimum salary per department group where the average salary per department is greater than the overall average salary from all instructors."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT department, MIN(salary) \nFROM instructors \nWHERE AVG(salary) > (SELECT AVG(salary) FROM instructors) \nGROUP BY department;",
            "SELECT dept_name, min(salary) FROM instructor GROUP BY dept_name HAVING avg(salary) > (SELECT avg(salary) FROM instructor)",
            "SELECT min(salary), dept_name FROM instructor GROUP BY dept_name HAVING avg(salary) > (SELECT avg(salary) FROM instructor)"
        ],
        "rule_sql": [
            "SELECT dept_name, min(salary) \nFROM instructor \nGROUP BY dept_name \nHAVING avg(salary) > (SELECT avg(salary) FROM instructor)"
        ]
    },
    "5107": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "Find the marketing region description of China?",
        "ground_truth": "SELECT Marketing_Region_Descriptrion FROM Marketing_Regions WHERE Marketing_Region_Name  =  \"China\"",
        "amends": [
            "Do reference `Marketing_Region_Descriptrion` instead of `region_name` in the SELECT list. Do query from `Marketing_Regions` instead of `countries` as the data source. Do filter on `Marketing_Region_Name = \"China\"` instead of `country = 'China'` as the predicate condition. Do use double quotes around string literals instead of single quotes for consistency. The amended query now correctly retrieves marketing region descriptions from the appropriate table using the correct column names and filtering criteria."
        ],
        "rules": [
            "1) When answering about \"marketing region description of China\": make sure the output order: Marketing_Region_Descriptrion. 2) When the question mentions \"China\": \"China\" actually means \"Marketing_Region_Name = \\\"China\\\"\" in schema. 3) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 4) When handling text literals: do not change case, spacing, or punctuation - use exact literal \\\"China\\\" with double quotes. 5) When querying for marketing region data: use table Marketing_Regions as the data source instead of countries."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT region_name FROM countries WHERE country = 'China';",
            "SELECT Marketing_Region_Descriptrion FROM Marketing_Regions WHERE Marketing_Region_Name = \"China\""
        ],
        "rule_sql": [
            "SELECT Marketing_Region_Descriptrion FROM Marketing_Regions WHERE Marketing_Region_Name = \"China\";"
        ]
    },
    "4680": {
        "db_id": "college_3",
        "question": "What are the full names of the 3 instructors who teach the most courses?",
        "ground_truth": "SELECT T2.Fname ,  T2.Lname FROM COURSE AS T1 JOIN FACULTY AS T2 ON T1.Instructor  =  T2.FacID GROUP BY T1.Instructor ORDER BY count(*) DESC LIMIT 3",
        "amends": [
            "Do select `T2.Fname` and `T2.Lname` instead of `i.first_name` and `i.last_name`. Do use `FROM COURSE AS T1 JOIN FACULTY AS T2` instead of `FROM instructors i JOIN courses c`. Do join on `T1.Instructor = T2.FacID` instead of `i.instructor_id = c.instructor_id`. Do group by `T1.Instructor` instead of `i.instructor_id`. Do order by `count(*) DESC` instead of `course_count ASC`. The amended query now correctly counts courses per instructor and returns the top 3 instructors with the most courses in descending order."
        ],
        "rules": [
            "1) When answering about \"instructors who teach the most courses\": make sure the output order: T2.Fname, T2.Lname. 2) When the question mentions \"instructors\": \"instructors\" actually means \"FACULTY as T2\" in schema. 3) When the question mentions \"courses\": \"courses\" actually means \"COURSE as T1\" in schema. 4) When combining T1 and T2 for shared entities: link rows where T1.Instructor = T2.FacID exactly as shown; keep only matching pairs (inner match). 5) When the question asks for \"count of courses per instructor\": compute the number of rows using T1.Instructor as the grouping key. 6) When the question mentions \"top 3\" by course count: rank rows by course count in descending direction and keep the first 3 rows. 7) When grouping by instructor: organize results by T1.Instructor and compute count per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT i.first_name, i.last_name, COUNT(c.course_id) as course_count\nFROM instructors i\nJOIN courses c ON i.instructor_id = c.instructor_id\nGROUP BY i.instructor_id\nORDER BY course_count ASC\nLIMIT 3;",
            "SELECT T2.Fname, T2.Lname\nFROM Course AS T1\nJOIN Faculty AS T2 ON T1.Instructor = T2.FacID\nGROUP BY T1.Instructor\nORDER BY COUNT(*) DESC\nLIMIT 3"
        ],
        "rule_sql": [
            "SELECT T2.Fname, T2.Lname\nFROM Course AS T1\nINNER JOIN Faculty AS T2 ON T1.Instructor = T2.FacID\nGROUP BY T1.Instructor\nORDER BY COUNT(*) DESC\nLIMIT 3"
        ]
    },
    "1207": {
        "db_id": "apartment_rentals",
        "question": "Give me the minimum and maximum bathroom count among all the apartments.",
        "ground_truth": "SELECT min(bathroom_count) ,  max(bathroom_count) FROM Apartments",
        "amends": [
            "Do select `min(bathroom_count)` and `max(bathroom_count)` instead of `MIN(bedroom_count)` and `MAX(bedroom_count)`. Do reference table `Apartments` instead of `apartments`. The amended query now correctly calculates bathroom statistics instead of bedroom statistics."
        ],
        "rules": [
            "1) When the question asks for bathroom count statistics: use the exact column name \"bathroom_count\" instead of \"bedroom_count\". 2) When referencing the apartments table: use the exact table name \"Apartments\" with proper capitalization as shown in the schema. 3) When calculating minimum and maximum values: compute min(bathroom_count) and max(bathroom_count) to get the bathroom statistics requested in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(bedroom_count), MAX(bedroom_count) FROM apartments;",
            "SELECT MIN(bathroom_count) AS min_bathroom_count, MAX(bathroom_count) AS max_bathroom_count FROM Apartments;"
        ],
        "rule_sql": [
            "SELECT MIN(bathroom_count) AS min_bathroom_count, MAX(bathroom_count) AS max_bathroom_count FROM Apartments;"
        ]
    },
    "1465": {
        "db_id": "college_2",
        "question": "What are the names of all instructors in the Comp. Sci. department?",
        "ground_truth": "SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'",
        "amends": [
            "Do reference table `instructor` instead of `instructors` and use column `dept_name` instead of `department` with filter value `'Comp. Sci.'` instead of `'Computer Science'`."
        ],
        "rules": [
            "1) When the question asks about instructors: use table \"instructor\" instead of \"instructors\". 2) When filtering by department: use column \"dept_name\" instead of \"department\". 3) When the question specifies \"Comp. Sci. department\": use the exact literal value 'Comp. Sci.' instead of 'Computer Science'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM instructors WHERE department = 'Computer Science';",
            "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.'"
        ],
        "rule_sql": [
            "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.'"
        ]
    },
    "2172": {
        "db_id": "formula_1",
        "question": "How many drivers were in the Australian Grand Prix held in 2009?",
        "ground_truth": "SELECT count(*) FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid WHERE T2.name = \"Australian Grand Prix\" AND YEAR = 2009",
        "amends": [
            "Do join `results AS T1` and `races AS T2` on `T1.raceid = T2.raceid` instead of querying only the `drivers` table. Do filter on `T2.name = \"Australian Grand Prix\"` instead of `grand_prix = 'Australian Grand Prix'`. Do keep the `year = 2009` filter but apply it to the joined tables instead of a single table. The amended query now correctly counts results from the specified race by joining the appropriate tables and matches the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"drivers in a specific Grand Prix\": join \"results AS T1\" and \"races AS T2\" on \"T1.raceid = T2.raceid\" to link race results with race information. 2) When the question mentions \"Australian Grand Prix\": use \"T2.name = 'Australian Grand Prix'\" as the filter condition. 3) When the question specifies year 2009: apply \"year = 2009\" filter to the joined tables. 4) When counting drivers in a race: count the number of rows using the joined tables that match both the race name and year criteria."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM drivers WHERE grand_prix = 'Australian Grand Prix' AND year = 2009;",
            "SELECT COUNT(DISTINCT T1.driverId) \nFROM results AS T1 \nJOIN races AS T2 ON T1.raceId = T2.raceId \nWHERE T2.name = 'Australian Grand Prix' AND T2.year = 2009"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.driverId) \nFROM results AS T1 \nJOIN races AS T2 ON T1.raceId = T2.raceId \nWHERE T2.name = 'Australian Grand Prix' \nAND T2.year = 2009"
        ]
    },
    "6371": {
        "db_id": "flight_company",
        "question": "What are the names and types of the companies that have ever operated a flight?",
        "ground_truth": "SELECT T1.name ,  T1.type FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id",
        "amends": [
            "Do specify table aliases `T1.name` and `T1.type` instead of unqualified `name` and `type`. Do change the FROM source to `operate_company AS T1 JOIN flight AS t2` instead of just `companies`. Do add a JOIN condition `ON T1.id = T2.company_id` instead of using a WHERE filter. Do remove the WHERE clause `flight_id IS NOT NULL` instead of keeping it, as the join condition now properly filters the relationship. The amended query correctly establishes the relationship between operate_company and flight tables through the company_id foreign key, ensuring only companies that operate flights are returned."
        ],
        "rules": [
            "1) When answering about companies that have operated flights: use table \"operate_company\" as T1 and join with table \"flight\" as T2. 2) When combining operate_company and flight tables: link rows where T1.id = T2.company_id and keep only matching pairs (inner match). 3) When selecting company information: output T1.name and T1.type as the result columns. 4) When the question asks for companies that have \"ever operated a flight\": the join condition T1.id = T2.company_id already ensures only companies with associated flights are returned, so no additional WHERE filter is needed."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, type FROM companies WHERE flight_id IS NOT NULL",
            "SELECT T1.name, T1.Type FROM operate_company AS T1 JOIN flight AS T2 ON T1.id = T2.company_id"
        ],
        "rule_sql": [
            "SELECT T1.name, T1.Type FROM operate_company AS T1 INNER JOIN flight AS T2 ON T1.id = T2.company_id"
        ]
    },
    "6522": {
        "db_id": "wine_1",
        "question": "What are the names of all wines produced in 2008?",
        "ground_truth": "SELECT Name FROM WINE WHERE YEAR  =  \"2008\"",
        "amends": [
            "Do reference table `WINE` instead of `wines` and use column `Name` instead of `name`. Do filter with `YEAR = \"2008\"` instead of `year = 2007` to query the correct year data. The amended query now correctly retrieves wine names from the WINE table for the year 2008."
        ],
        "rules": [
            "1) When answering about \"names of all wines produced in 2008\": make sure the output order: \"Name\" from table \"WINE\". 2) When the question mentions \"wines\": \"wines\" actually means table \"WINE\" in schema. 3) When the question mentions \"produced in 2008\": filter rows where column \"YEAR\" equals literal \"2008\" exactly. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for identifiers like \"WINE\", \"Name\", and \"YEAR\". 5) When handling text literals: do not change case, spacing, or punctuation for the year value \"2008\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM wines WHERE year = 2007;",
            "SELECT Name FROM WINE WHERE Year = \"2008\""
        ],
        "rule_sql": [
            "SELECT \"Name\" FROM \"wine\" WHERE \"Year\" = 2008 ORDER BY \"Name\";"
        ]
    },
    "4409": {
        "db_id": "network_2",
        "question": "What is the name of the person who is the oldest?",
        "ground_truth": "SELECT name FROM Person WHERE age  =  (SELECT max(age) FROM person)",
        "amends": [
            "Do use a subquery `(SELECT max(age) FROM person)` in the WHERE clause instead of ORDER BY with LIMIT 1. Do add a WHERE filter `age = (SELECT max(age) FROM person)` instead of ordering and limiting. Do reference the correct table name `Person` instead of `persons`. The amended query now correctly finds the person with the maximum age by comparing against the maximum value directly rather than relying on sort order and limit."
        ],
        "rules": [
            "1) When the question asks for the oldest person: use the maximum age value from the Person table to identify the correct person. 2) When finding the person with maximum age: compare each person's age against the maximum age value calculated from the entire Person table. 3) When referencing the Person table: use the exact table name \"Person\" (not \"persons\"). 4) When outputting results: include the name column from the Person table for the person matching the maximum age condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM persons ORDER BY age ASC LIMIT 1;",
            "SELECT name FROM Person WHERE age = (SELECT MAX(age) FROM Person)"
        ],
        "rule_sql": [
            "SELECT name FROM Person WHERE age = (SELECT MAX(age) FROM Person);"
        ]
    },
    "845": {
        "db_id": "chinook_1",
        "question": "What is the first name and last name of the customer that has email \"luisg@embraer.com.br\"?",
        "ground_truth": "SELECT FirstName ,  LastName FROM CUSTOMER WHERE Email  =  \"luisg@embraer.com.br\"",
        "amends": [
            "Do use column names `FirstName` and `LastName` instead of `first_name` and `last_name`. Do reference table `CUSTOMER` instead of `customers`. Do use double quotes `\"luisg@embraer.com.br\"` instead of single quotes for the email filter value. The amended query now correctly matches the RIGHT_SQL's behavior with proper column and table references."
        ],
        "rules": [
            "1) When the question asks for first name and last name: use column names \"FirstName\" and \"LastName\" exactly as shown in the schema. 2) When referencing the customer table: use table name \"CUSTOMER\" instead of \"customers\". 3) When filtering by email value \"luisg@embraer.com.br\": use double quotes around the literal value exactly as \"luisg@embraer.com.br\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM customers WHERE email = 'luisg@embraer.com.br';",
            "SELECT FirstName, LastName FROM Customer WHERE Email = \"luisg@embraer.com.br\""
        ],
        "rule_sql": [
            "SELECT FirstName, LastName FROM CUSTOMER WHERE Email = \"luisg@embraer.com.br\""
        ]
    },
    "1833": {
        "db_id": "browser_web",
        "question": "What are the ids and names of the web accelerators that are compatible with two or more browsers?",
        "ground_truth": "SELECT T1.id ,  T1.Name FROM web_client_accelerator AS T1 JOIN accelerator_compatible_browser AS T2 ON T2.accelerator_id  =  T1.id GROUP BY T1.id HAVING count(*)  >=  2",
        "amends": [
            "Do specify table aliases `T1.id` and `T1.Name` instead of bare column names `id` and `name`. Do change the FROM source to `web_client_accelerator AS T1` instead of `web_accelerators`. Do add a `JOIN` with `accelerator_compatible_browser AS T2` on `T2.accelerator_id = T1.id` instead of omitting this table. Do remove the WHERE clause filter `browser_count >= 2` instead of keeping it. Do add GROUP BY `T1.id` instead of omitting aggregation. Do move the count filter to HAVING `count(*) >= 2` instead of WHERE, as it correctly filters aggregated results rather than individual rows. The amended query now matches RIGHT_SQL's behavior by properly counting browser compatibility relationships through the join and grouping structure."
        ],
        "rules": [
            "1) When answering about web accelerators compatible with two or more browsers: use table alias T1 for web_client_accelerator and T2 for accelerator_compatible_browser. 2) When combining web accelerators with their browser compatibility: link rows where T2.accelerator_id = T1.id and keep only matching pairs (inner match). 3) When counting compatible browsers per accelerator: group by T1.id and count the number of rows using count(*). 4) When filtering for two or more compatible browsers: apply the condition count(*) >= 2 after grouping (HAVING clause equivalent). 5) When selecting output columns: return T1.id and T1.Name in that order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, name FROM web_accelerators WHERE browser_count >= 2;",
            "SELECT T1.id, T1.name\nFROM Web_client_accelerator AS T1\nJOIN accelerator_compatible_browser AS T2 ON T2.accelerator_id = T1.id\nGROUP BY T1.id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T1.id, T1.name FROM Web_client_accelerator T1 INNER JOIN accelerator_compatible_browser T2 ON T2.accelerator_id = T1.id GROUP BY T1.id, T1.name HAVING COUNT(*) >= 2"
        ]
    },
    "1635": {
        "db_id": "wedding",
        "question": "Show the name and opening year for three churches that opened most recently.",
        "ground_truth": "SELECT name ,  open_date FROM church ORDER BY open_date DESC LIMIT 3",
        "amends": [
            "Do select `open_date` instead of `opening_year` and use table `church` instead of `churches`. Do order by `open_date` instead of `opening_year` while maintaining the same DESC limit behavior. The amended query now correctly retrieves the latest churches based on the open_date field from the appropriate table."
        ],
        "rules": [
            "1) When the question asks for \"opening year\": use the exact column token \"open_date\" instead of \"opening_year\". 2) When the question refers to \"churches\": use the exact table token \"church\" instead of \"churches\". 3) When the question asks for \"three churches that opened most recently\": rank rows by \"open_date\" in descending order and keep the first 3 rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, opening_year FROM churches ORDER BY opening_year DESC LIMIT 3;",
            "SELECT Name, Open_Date FROM church ORDER BY Open_Date DESC LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT Name, Open_Date FROM church ORDER BY Open_Date DESC LIMIT 3"
        ]
    },
    "6526": {
        "db_id": "wine_1",
        "question": "What are the names and scores of all wines?",
        "ground_truth": "SELECT Name ,  Score FROM WINE",
        "amends": [
            "Do use table name `WINE` instead of `wines` and capitalize column names `Name` and `Score` instead of lowercase `name` and `score` to match the correct schema. Do remove the `WHERE score > 100` filter instead of keeping it, as the right query returns all records without filtering. The amended query now correctly selects all records from the WINE table with proper column capitalization."
        ],
        "rules": [
            "1) When the question asks for wine names and scores: use table \"WINE\" instead of \"wines\" and columns \"Name\" and \"Score\" instead of lowercase \"name\" and \"score\". 2) When selecting all records without filtering: do not apply any WHERE clause conditions like \"score > 100\" as the question requests all wines regardless of score."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, score FROM wines WHERE score > 100;",
            "SELECT Name, Score FROM wine"
        ],
        "rule_sql": [
            "SELECT Name, Score FROM wine;"
        ]
    },
    "6052": {
        "db_id": "game_1",
        "question": "What are the first names and ages of all students who are playing both Football and Lacrosse?",
        "ground_truth": "SELECT fname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Sportsinfo WHERE SportName  =  \"Football\" INTERSECT SELECT StuID FROM Sportsinfo WHERE SportName  =  \"Lacrosse\")",
        "amends": [
            "Do select `fname` and `age` instead of `first_name` and `age`. Do use table `Student` instead of `students`. Do remove the incorrect `WHERE sport = 'Football' AND sport = 'Lacrosse'` condition that could never return results. Do add a subquery with `INTERSECT` to find students who play both `Football` and `Lacrosse` by querying the `Sportsinfo` table twice with different `SportName` filters and intersecting the `StuID` results instead of trying to check both sports in a single impossible condition. The amended query now correctly identifies students who participate in both sports by using set intersection logic rather than the contradictory filter that could never be satisfied."
        ],
        "rules": [
            "1) When the question asks for \"first names\" and \"ages\": use columns \"fname\" and \"age\" from table \"Student\" instead of \"first_name\" and \"age\". 2) When the question asks about students playing both Football and Lacrosse: use the \"SportsInfo\" table to find students who participate in both sports by intersecting the \"StuID\" values where \"SportName\" equals 'Football' with those where \"SportName\" equals 'Lacrosse'. 3) When combining student information with sports participation: link \"Student\" table with the intersected \"StuID\" results from \"SportsInfo\" using the exact key \"StuID\" to find matching students. 4) When the question mentions specific sports 'Football' and 'Lacrosse': use the exact literals 'Football' and 'Lacrosse' with correct case and spelling when filtering the \"SportName\" column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, age FROM students WHERE sport = 'Football' AND sport = 'Lacrosse';",
            "SELECT s.Fname, s.Age\nFROM Student s\nWHERE s.StuID IN (\n    SELECT StuID FROM SportsInfo WHERE SportName = 'Football'\n    INTERSECT\n    SELECT StuID FROM SportsInfo WHERE SportName = 'Lacrosse'\n)"
        ],
        "rule_sql": [
            "SELECT s.fname, s.age\nFROM Student s\nWHERE s.StuID IN (\n    SELECT StuID FROM SportsInfo WHERE SportName = 'Football'\n    INTERSECT\n    SELECT StuID FROM SportsInfo WHERE SportName = 'Lacrosse'\n)"
        ]
    },
    "2766": {
        "db_id": "election",
        "question": "Show the delegates and the names of the party they belong to.",
        "ground_truth": "SELECT T1.Delegate ,  T2.Party FROM election AS T1 JOIN party AS T2 ON T1.Party  =  T2.Party_ID",
        "amends": [
            "Do reference tables as `election` and `party` instead of `delegates` and `parties`. Do select columns `Delegate` and `Party` instead of `delegate_name` and `party_name`. Do join on `T1.Party = T2.Party_ID` instead of `delegates.party_id = parties.id`. The amended query now correctly matches the intended table structure and join logic."
        ],
        "rules": [
            "1) When answering about \"delegates and the names of the party they belong to\": make sure the output order: \"Delegate\", \"Party\" 2) When the question mentions \"delegates\": \"delegates\" actually means \"election\" in schema 3) When the question mentions \"party\": \"party\" actually means \"party\" in schema 4) When selecting delegate information: use column \"Delegate\" from table \"election\" 5) When selecting party information: use column \"Party\" from table \"election\" 6) When combining election and party tables for shared entities: link rows where \"T1.Party = T2.Party_ID\" exactly as shown; keep only matching pairs (inner match)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT delegate_name, party_name FROM delegates JOIN parties ON delegates.party_id = parties.id",
            "SELECT election.Delegate, party.Party FROM election JOIN party ON election.Party = party.Party_ID;"
        ],
        "rule_sql": [
            "SELECT e.Delegate, p.Party FROM election e JOIN party p ON e.Party = p.Party_ID ORDER BY e.Delegate, p.Party;"
        ]
    },
    "454": {
        "db_id": "allergy_1",
        "question": "What are the allergy types and how many allergies correspond to each one?",
        "ground_truth": "SELECT allergytype ,  count(*) FROM Allergy_type GROUP BY allergytype",
        "amends": [
            "Do use the correct table name `Allergy_type` instead of the incorrect `allergies` table. Do use the correct column name `allergytype` instead of `allergy_type` in both the SELECT list and GROUP BY clause. The amended query now correctly references the proper table and column names to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks about allergy types and their counts: use the table \"Allergy_type\" instead of \"allergies\". 2) When referring to allergy types in both selection and grouping: use the column \"allergytype\" instead of \"allergy_type\". 3) When counting allergies per type: count all rows in the \"Allergy_type\" table grouped by \"allergytype\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT allergy_type, COUNT(*) FROM allergies GROUP BY allergy_type;",
            "SELECT AllergyType, COUNT(*) AS allergy_count FROM Allergy_Type GROUP BY AllergyType;"
        ],
        "rule_sql": [
            "SELECT AllergyType, COUNT(*) AS allergy_count FROM Allergy_Type GROUP BY AllergyType;"
        ]
    },
    "1027": {
        "db_id": "phone_1",
        "question": "What is maximum and minimum RAM size of phone produced by company named \"Nokia Corporation\"?",
        "ground_truth": "SELECT max(T1.RAM_MiB) ,  min(T1.RAM_MiB) FROM chip_model AS T1 JOIN phone AS T2 ON T1.Model_name  =  T2.chip_model WHERE T2.Company_name = \"Nokia Corporation\";",
        "amends": [
            "Do join `chip_model AS T1` and `phone AS T2` instead of querying only `phones` table. Do use `ON T1.Model_name = T2.chip_model` instead of no join condition. Do reference columns `T1.RAM_MiB` instead of `ram_size`. Do filter on `T2.Company_name = \"Nokia Corporation\"` instead of `company = 'Nokia Corporation'`. Do use proper table aliases `T1` and `T2` instead of direct column references. The amended query now correctly joins the chip_model and phone tables to retrieve RAM statistics for Nokia Corporation phones."
        ],
        "rules": [
            "1) When answering about maximum and minimum RAM size of phones: make sure the output order: MAX(T1.RAM_MiB), MIN(T1.RAM_MiB) 2) When the question mentions \"company named 'Nokia Corporation'\": \"company\" actually means \"T2.Company_name in schema\" and use exact literal \"Nokia Corporation\" 3) When combining chip_model AS T1 and phone AS T2: link rows where T1.Model_name = T2.chip_model and keep only matching pairs (inner match) 4) When referring to RAM size: \"ram_size\" actually means \"T1.RAM_MiB in schema\" 5) When filtering for specific company: use T2.Company_name = \"Nokia Corporation\" with exact case and double quotes"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(ram_size), MIN(ram_size) FROM phones WHERE company = 'Nokia Corporation';",
            "SELECT MAX(T1.RAM_MiB) AS max_ram, MIN(T1.RAM_MiB) AS min_ram FROM chip_model AS T1 JOIN phone AS T2 ON T1.Model_name = T2.chip_model WHERE T2.Company_name = 'Nokia Corporation'"
        ],
        "rule_sql": [
            "SELECT MAX(T1.RAM_MiB), MIN(T1.RAM_MiB) FROM chip_model AS T1 INNER JOIN phone AS T2 ON T1.Model_name = T2.chip_model WHERE T2.Company_name = \"Nokia Corporation\""
        ]
    },
    "1707": {
        "db_id": "epinions_1",
        "question": "Find the name and id of the item with the highest average rating.",
        "ground_truth": "SELECT T1.title ,  T1.i_id FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id GROUP BY T2.i_id ORDER BY avg(T2.rating) DESC LIMIT 1",
        "amends": [
            "Do select `title` and `i_id` from the `item` table instead of `name` and `id` from `items`. Do add a `JOIN` with the `review` table on `i_id` instead of querying a single table. Do add `GROUP BY T2.i_id` to aggregate reviews instead of no grouping. Do order by `avg(T2.rating)` instead of `rating` to use the average rating from reviews rather than a direct column. Do reference tables with aliases `T1` and `T2` instead of no aliases. The amended query now correctly finds the item with the highest average review rating instead of just the highest individual rating."
        ],
        "rules": [
            "1) When the question asks for \"name and id of the item\": use \"title\" from table \"item\" (as T1) and \"i_id\" from table \"item\" (as T1) instead of \"name\" and \"id\". 2) When computing average rating: join table \"item\" (as T1) with table \"review\" (as T2) where T1.i_id = T2.i_id to access review ratings. 3) When finding the highest average rating: group by T1.i_id to aggregate reviews per item and compute average of T2.rating. 4) When ranking items by average rating: order by the computed average rating in descending direction and keep only the top 1 row. 5) When producing output: return columns in the order title then i_id."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, id FROM items ORDER BY rating DESC LIMIT 1;",
            "SELECT T1.title, T1.i_id FROM item T1 JOIN review T2 ON T1.i_id = T2.i_id GROUP BY T2.i_id ORDER BY AVG(T2.rating) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.title, T1.i_id\nFROM item AS T1\nJOIN review AS T2 ON T1.i_id = T2.i_id\nGROUP BY T1.i_id\nORDER BY AVG(T2.rating) DESC\nLIMIT 1;"
        ]
    },
    "511": {
        "db_id": "allergy_1",
        "question": "How many students have a food allergy?",
        "ground_truth": "SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  \"food\"",
        "amends": [
            "Do use `JOIN` between `Has_allergy` and `Allergy_type` tables with `ON T1.allergy = T2.allergy` instead of querying only the `students` table. Do filter with `WHERE T2.allergytype = \"food\"` instead of `WHERE food_allergy = 'no'`. Do count from the joined allergy tables instead of counting directly from students. The amended query now correctly identifies food allergies through table relationships instead of relying on a potentially incorrect direct column check.",
            "Do use `count(*)` instead of `COUNT(DISTINCT ha.StuID)` to count all matching rows rather than distinct student IDs. Do use table aliases `T1` and `T2` instead of `ha` and `at` for consistency. Do use double quotes `\"food\"` instead of single quotes `'food'` for the string literal. Do remove the `DISTINCT` modifier from the count function instead of keeping it, as the requirement is to count all food allergy records regardless of student uniqueness. The amended query now correctly counts all food allergy instances rather than distinct students with food allergies, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"students with food allergy\": make sure to join \"Has_allergy\" as T1 and \"Allergy_type\" as T2 using T1.allergy = T2.allergy instead of querying only the students table. 2) When filtering for food allergies: use WHERE T2.allergytype = \"food\" instead of checking food_allergy = 'no'. 3) When counting students with food allergies: count from the joined allergy tables instead of counting directly from students.",
            "1) When counting all food allergy records: use count(*) instead of counting distinct student IDs. 2) When referring to the Has_Allergy table: use alias T1 instead of ha. 3) When referring to the Allergy_Type table: use alias T2 instead of at. 4) When filtering for food allergy type: use the exact literal \"food\" with double quotes instead of 'food'. 5) When the question asks for count of students with food allergy: count all matching rows rather than distinct students, as the requirement is to count all food allergy instances."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE food_allergy = 'no';",
            "SELECT COUNT(DISTINCT ha.StuID) \nFROM Has_Allergy ha\nJOIN Allergy_Type at ON ha.Allergy = at.Allergy\nWHERE at.AllergyType = 'food'",
            "SELECT COUNT(*) \nFROM Has_Allergy T1 \nJOIN Allergy_Type T2 ON T1.Allergy = T2.Allergy \nWHERE T2.AllergyType = \"food\""
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType = \"food\""
        ]
    },
    "2858": {
        "db_id": "icfp_1",
        "question": "How many authors are there?",
        "ground_truth": "SELECT count(*) FROM authors",
        "amends": [
            "Do query the `authors` table instead of the `books` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the authors table instead of the books table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"how many authors\": query the \"authors\" table instead of the \"books\" table. 2) When counting records: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" for consistency."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM books;",
            "SELECT count(*) FROM Authors;"
        ],
        "rule_sql": [
            "select count(*) from Authors"
        ]
    },
    "1086": {
        "db_id": "match_season",
        "question": "How many distinct colleges are associated with players from the team with name \"Columbus Crew\".",
        "ground_truth": "SELECT count(DISTINCT T1.College) FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id WHERE T2.Name  =  \"Columbus Crew\"",
        "amends": [
            "Do join `match_season AS T1` with `team AS T2` on `T1.Team = T2.Team_id` instead of querying only the `players` table. Do filter on `T2.Name = \"Columbus Crew\"` instead of `team_name = 'Columbus Crew'`. Do count distinct `T1.College` instead of `college` from the joined tables. The amended query now correctly retrieves distinct colleges from match_season data joined with team information, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about distinct colleges associated with players from a specific team: join match_season as T1 with team as T2 on T1.Team = T2.Team_id to combine player and team information. 2) When filtering for the team with name \"Columbus Crew\": use T2.Name = \"Columbus Crew\" exactly as specified, preserving the double quotes and exact spelling. 3) When counting distinct colleges: count distinct T1.College values from the joined tables. 4) When combining tables for shared entities: perform an inner match where T1.Team = T2.Team_id to keep only matching player-team pairs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT college) FROM players WHERE team_name = 'Columbus Crew';",
            "SELECT COUNT(DISTINCT T1.College) \nFROM match_season AS T1 \nJOIN team AS T2 ON T1.Team = T2.Team_id \nWHERE T2.Name = 'Columbus Crew'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.College) \nFROM match_season T1 \nINNER JOIN team T2 ON T1.Team = T2.Team_id \nWHERE T2.Name = \"Columbus Crew\""
        ]
    },
    "2710": {
        "db_id": "storm_record",
        "question": "Show the name for regions not affected.",
        "ground_truth": "SELECT region_name FROM region WHERE region_id NOT IN (SELECT region_id FROM affected_region)",
        "amends": [
            "Do select `region_name` instead of `name` and change the source table to `region` instead of `regions`. Do use a subquery with `NOT IN` condition on `region_id` instead of a direct `WHERE affected = 'yes'` filter. Do remove the simple equality filter and instead implement exclusion logic through a correlated subquery that checks against the `affected_region` table. The amended query now correctly identifies regions not present in the affected regions list rather than relying on a direct boolean flag, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"name\" of regions: use the exact column token \"region_name\" instead of \"name\". 2) When the question refers to \"regions\": use the exact table token \"region\" instead of \"regions\". 3) When identifying regions not affected: use a subquery with NOT IN condition on \"region_id\" to exclude regions present in the \"affected_region\" table, rather than using a direct boolean filter."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM regions WHERE affected = 'yes';",
            "SELECT region_name FROM region WHERE Region_id NOT IN (SELECT Region_id FROM affected_region)"
        ],
        "rule_sql": [
            "SELECT region_name FROM region WHERE Region_id NOT IN (SELECT Region_id FROM affected_region)"
        ]
    },
    "4471": {
        "db_id": "network_2",
        "question": "What are the ages of all of Zach's friends who are in the longest relationship?",
        "ground_truth": "SELECT T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T2.name =  'Zach' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  'Zach')",
        "amends": [
            "Do select `T1.age` from the `Person` table instead of `age` from the `friends` table. Do join `PersonFriend AS T2` with the condition `T1.name = T2.friend` instead of querying a single table. Do filter on `T2.name = 'Zach'` instead of `name = 'Zach'`. Do use the subquery `(SELECT max(YEAR) FROM PersonFriend WHERE name = 'Zach')` for comparison instead of `(SELECT MAX(relationship_duration) FROM friends)`. The amended query now correctly retrieves the age of Zach's friends by joining the appropriate tables and using the correct filtering logic."
        ],
        "rules": [
            "1) When answering about \"ages of all of Zach's friends\": select T1.age from the Person table. 2) When the question mentions \"Zach's friends\": join PersonFriend AS T2 where T2.name = 'Zach' and link using T1.name = T2.friend. 3) When the question asks about \"longest relationship\": filter using the maximum YEAR value from PersonFriend where name = 'Zach' with the exact comparison T2.YEAR = (SELECT max(YEAR) FROM PersonFriend WHERE name = 'Zach'). 4) When combining Person and PersonFriend tables: perform an inner match where T1.name = T2.friend to keep only valid friend relationships."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT age FROM friends WHERE name = 'Zach' AND relationship_duration = (SELECT MAX(relationship_duration) FROM friends);",
            "SELECT T1.age \nFROM Person AS T1\nJOIN PersonFriend AS T2 ON T1.name = T2.friend\nWHERE T2.name = 'Zach' \nAND T2.year = (SELECT MAX(year) FROM PersonFriend WHERE name = 'Zach')"
        ],
        "rule_sql": [
            "SELECT T1.age \nFROM Person AS T1\nINNER JOIN PersonFriend AS T2 ON T1.name = T2.friend\nWHERE T2.name = 'Zach' \nAND T2.YEAR = (SELECT max(YEAR) FROM PersonFriend WHERE name = 'Zach')"
        ]
    },
    "106": {
        "db_id": "student_assessment",
        "question": "What are the ids of the students who registered course statistics by order of registration date?",
        "ground_truth": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = \"statistics\" ORDER BY T2.registration_date",
        "amends": [
            "Do select `T2.student_id` from the joined table instead of `student_id` directly from the original table. Do use `FROM courses AS T1 JOIN student_course_registrations AS T2` with proper table aliases instead of querying only the `registrations` table. Do add the join condition `ON T1.course_id = T2.course_id` to properly link the tables instead of missing this relationship. Do filter on `T1.course_name = \"statistics\"` through the courses table instead of filtering directly on a non-existent `course_name` column in registrations. Do order by `T2.registration_date` with proper table qualification instead of just `registration_date`. The amended query now correctly joins the courses and registration tables to find students enrolled in statistics courses."
        ],
        "rules": [
            "1) When the question asks for student ids who registered a specific course: select \"T2.student_id\" from the joined tables instead of directly from a single table. 2) When combining course and registration information: use FROM courses AS T1 JOIN student_course_registrations AS T2 with the join condition ON T1.course_id = T2.course_id to properly link the tables. 3) When filtering for a specific course name like \"statistics\": use T1.course_name = \"statistics\" through the courses table instead of filtering on a non-existent column in registrations. 4) When ordering by registration date: use T2.registration_date with proper table qualification instead of just registration_date."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id FROM registrations WHERE course_name = 'statistics' ORDER BY registration_date;",
            "SELECT T2.student_id\nFROM courses AS T1\nJOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id\nWHERE T1.course_name = 'statistics'\nORDER BY T2.registration_date;"
        ],
        "rule_sql": [
            "SELECT T2.student_id \nFROM Courses AS T1 \nJOIN Student_Course_Registrations AS T2 ON T1.course_id = T2.course_id \nWHERE T1.course_name = 'statistics' \nORDER BY T2.registration_date"
        ]
    },
    "3343": {
        "db_id": "sports_competition",
        "question": "What are the types and countries of competitions?",
        "ground_truth": "SELECT Competition_type ,  Country FROM competition",
        "amends": [
            "Do use `Competition_type` instead of `type` for the column name in the SELECT list. Do use `Country` instead of `country` for the column name in the SELECT list. Do reference the table as `competition` instead of `competitions` in the FROM clause. Do remove the WHERE filter `type = 'national'` instead of keeping it. The amended query now correctly selects all records from the competition table with the proper column names and without unnecessary filtering."
        ],
        "rules": [
            "1) When selecting competition types: use the exact column name \"Competition_type\" instead of \"type\". 2) When selecting competition countries: use the exact column name \"Country\" instead of \"country\". 3) When referencing the competition table: use the exact table name \"competition\" instead of \"competitions\". 4) When the question asks for all types and countries of competitions: do not apply any WHERE filter conditions like 'type = \\'national\\''."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type, country FROM competitions WHERE type = 'national'",
            "SELECT Competition_type, Country FROM competition;"
        ],
        "rule_sql": [
            "SELECT Competition_type, Country FROM competition;"
        ]
    },
    "6390": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "Count the number of statements.",
        "ground_truth": "SELECT count(*) FROM Statements",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM statements;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Statements;"
        ]
    },
    "5167": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "Check the invoices record and compute the average quantities ordered with the payment method \"MasterCard\".",
        "ground_truth": "SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code  =  \"MasterCard\"",
        "amends": [
            "Do use the correct column name `Order_Quantity` instead of `quantity` for the average calculation. Do use the correct column name `payment_method_code` instead of `payment_method` in the WHERE filter. Do use lowercase `avg` function instead of uppercase `AVG` for consistency. Do use double quotes `\"MasterCard\"` instead of single quotes `'MasterCard'` for the string literal. The amended query now correctly calculates the average order quantity for MasterCard payments using the proper column names and syntax."
        ],
        "rules": [
            "1) When the question asks for average quantities ordered: use the exact column name \"Order_Quantity\" from the Invoice_Items table for the average calculation. 2) When filtering by payment method \"MasterCard\": use the exact column name \"payment_method_code\" from the Invoices table and the exact string literal \"MasterCard\" with double quotes. 3) When combining data from multiple tables: ensure proper table relationships are established between Invoices and Invoice_Items tables using their canonical keys as referenced in the schema."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(quantity) FROM invoices WHERE payment_method = 'MasterCard';",
            "SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code = \"MasterCard\";"
        ],
        "rule_sql": [
            "SELECT AVG(CAST(ii.Order_Quantity AS REAL)) AS average_quantity\nFROM Invoice_Items ii\nJOIN Invoices i ON ii.Invoice_ID = i.Invoice_ID\nWHERE i.payment_method_code = \"MasterCard\";"
        ]
    },
    "3224": {
        "db_id": "college_1",
        "question": "Which department has the highest average student GPA, and what is the average gpa?",
        "ground_truth": "SELECT T2.dept_name ,  avg(T1.stu_gpa) FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.dept_code ORDER BY avg(T1.stu_gpa) DESC LIMIT 1",
        "amends": [
            "Do join `department` table as `T2` instead of querying only the `students` table. Do use `T1.dept_code = T2.dept_code` as the join condition instead of missing the table relationship entirely. Do reference `T2.dept_name` in the SELECT list instead of just `department` without table specification. Do use `T1.stu_gpa` for the average calculation instead of `GPA` without table alias. Do group by `T1.dept_code` instead of `department` to ensure proper aggregation. Do order by `avg(T1.stu_gpa)` instead of the alias `average_gpa` for explicit column reference. The amended query now correctly joins the student and department tables to calculate average GPA by department name while maintaining the same limit behavior."
        ],
        "rules": [
            "1) When answering about \"highest average student GPA by department\": make sure the output order: department name first, then average GPA. 2) When combining student and department tables: link rows where T1.dept_code = T2.dept_code exactly as shown and keep only matching pairs (inner match). 3) When calculating average GPA: use T1.stu_gpa for the average calculation instead of GPA without table alias. 4) When grouping by department: group by T1.dept_code to ensure proper aggregation instead of department without table specification. 5) When selecting department name: reference T2.dept_name in the SELECT list instead of just department without table specification. 6) When ordering for highest average: order by avg(T1.stu_gpa) in descending direction instead of using the alias average_gpa. 7) When finding the single highest department: keep only the first row after ordering by average GPA in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department, AVG(GPA) as average_gpa FROM students GROUP BY department ORDER BY average_gpa DESC LIMIT 1;",
            "SELECT T2.DEPT_NAME, AVG(T1.STU_GPA) as average_gpa \nFROM STUDENT T1 \nJOIN DEPARTMENT T2 ON T1.DEPT_CODE = T2.DEPT_CODE \nGROUP BY T1.DEPT_CODE \nORDER BY AVG(T1.STU_GPA) DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT d.DEPT_NAME, AVG(s.STU_GPA) as average_gpa\nFROM STUDENT s\nINNER JOIN DEPARTMENT d ON s.DEPT_CODE = d.DEPT_CODE\nGROUP BY s.DEPT_CODE\nORDER BY AVG(s.STU_GPA) DESC\nLIMIT 1;"
        ]
    },
    "1125": {
        "db_id": "climbing",
        "question": "Return the name of the mountain with the greatest height.",
        "ground_truth": "SELECT Name FROM mountain ORDER BY Height DESC LIMIT 1",
        "amends": [
            "Do reference table `mountain` instead of `mountains` in the FROM clause. Do select column `Name` instead of `name` in the SELECT list. Do add `DESC` to the ORDER BY clause for `Height` instead of using the default ascending order. Do reference column `Height` instead of `height` in the ORDER BY clause. The amended query now correctly retrieves the highest mountain by using descending order and matches the intended behavior."
        ],
        "rules": [
            "1) When answering about \"the mountain with the greatest height\": make sure the output order: \"Name\" from table \"mountain\". 2) When the question mentions \"name\": \"name\" actually means \"Name\" in schema. 3) When the question mentions \"height\": \"height\" actually means \"Height\" in schema. 4) When the question asks for \"greatest height\": rank rows by \"Height\" in descending order and keep the first 1 row. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM mountains ORDER BY height LIMIT 1;",
            "SELECT Name FROM mountain ORDER BY Height DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT \"Name\" FROM \"mountain\" ORDER BY \"Height\" DESC LIMIT 1"
        ]
    },
    "3053": {
        "db_id": "loan_1",
        "question": "What is the name of the customer who has greatest total loan amount?",
        "ground_truth": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id GROUP BY T1.cust_name ORDER BY sum(T2.amount) DESC LIMIT 1",
        "amends": [
            "Do select `T1.cust_name` instead of `name` and add aggregation with `sum(T2.amount)` instead of referencing `loan_amount` directly. Do join `customer AS T1` with `loan AS T2` on `T1.cust_id = T2.cust_id` instead of querying only the `customers` table. Do add `GROUP BY T1.cust_name` instead of omitting grouping. Do order by `sum(T2.amount) DESC` instead of `loan_amount DESC` to properly aggregate loan amounts per customer. The amended query now correctly calculates the customer with the highest total loan amount by joining customer and loan tables, grouping by customer name, and summing individual loan amounts."
        ],
        "rules": [
            "1) When answering about \"customer who has greatest total loan amount\": make sure the output order: T1.cust_name. 2) When the question mentions \"total loan amount\": \"total loan amount\" actually means \"sum(T2.amount) in schema\". 3) When combining T1 and T2 for shared entities: link rows where T1.cust_id = T2.cust_id; keep only matching pairs (inner match). 4) When the question asks for \"greatest total loan amount\": rank rows by sum(T2.amount) in descending direction and keep the first 1 row. 5) When the question says \"per customer\": organize results by T1.cust_name and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM customers ORDER BY loan_amount DESC LIMIT 1;",
            "SELECT T1.cust_name\nFROM customer AS T1\nJOIN loan AS T2 ON T1.cust_ID = T2.cust_ID\nGROUP BY T1.cust_name\nORDER BY SUM(T2.amount) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.cust_name\nFROM customer T1\nJOIN loan T2 ON T1.cust_ID = T2.cust_ID\nGROUP BY T1.cust_name\nORDER BY SUM(T2.amount) DESC\nLIMIT 1;"
        ]
    },
    "4397": {
        "db_id": "tracking_grants_for_research",
        "question": "What is the most common role for the staff?",
        "ground_truth": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `role_code` instead of `role` and remove the `COUNT(*) as count` alias instead of keeping it. Do use `Project_Staff` as the FROM source instead of `staff`. Do remove the GROUP BY clause instead of grouping by `role`. Do order by `count(*) DESC` instead of `count ASC` and keep the `LIMIT 1` unchanged. The amended query now correctly selects the most frequent role code by count from the Project_Staff table."
        ],
        "rules": [
            "1) When answering about \"most common role for the staff\": select \"role_code\" from table \"Project_Staff\" instead of \"role\" from table \"staff\". 2) When counting occurrences to find the most common: count all rows without aliasing the count result instead of using \"COUNT(*) as count\". 3) When finding the most frequent value: order by the count in descending direction instead of ascending direction. 4) When limiting to the top result: keep only the first row using LIMIT 1. 5) When the question mentions \"role\": \"role\" actually means \"role_code\" in the \"Project_Staff\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT role, COUNT(*) as count FROM staff GROUP BY role ORDER BY count ASC LIMIT 1;",
            "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "2546": {
        "db_id": "county_public_safety",
        "question": "List the name of the county with the largest population.",
        "ground_truth": "SELECT Name FROM county_public_safety ORDER BY Population DESC LIMIT 1",
        "amends": [
            "Do reference table `county_public_safety` instead of `counties`. Do select column `Name` instead of `name`. Do order by `Population` instead of `population`. Do use `DESC` ordering instead of `ASC`. The amended query now correctly retrieves from the intended table with proper column names and sorting direction to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about county information: use table \"county_public_safety\" instead of \"counties\". 2) When selecting the county name: use column \"Name\" instead of \"name\". 3) When ordering by population to find the largest value: use column \"Population\" with descending order (DESC) instead of ascending order (ASC)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM counties ORDER BY population ASC LIMIT 1;",
            "SELECT Name FROM county_public_safety ORDER BY Population DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name FROM county_public_safety ORDER BY Population DESC LIMIT 1;"
        ]
    },
    "1085": {
        "db_id": "match_season",
        "question": "Return the positions of players on the team Ryley Goldner.",
        "ground_truth": "SELECT T1.Position FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id WHERE T2.Name  =  \"Ryley Goldner\"",
        "amends": [
            "Do join `match_season AS T1` and `team AS T2` with `ON T1.Team = T2.Team_id` instead of querying `players` table directly. Do filter on `T2.Name = \"Ryley Goldner\"` instead of filtering directly on `team = 'Ryley Goldner'`. Do select `T1.Position` from the joined tables instead of selecting `position` from a single table. The amended query now correctly retrieves position information by properly joining the team reference table to resolve the team name to team ID relationship, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"positions of players on the team Ryley Goldner\": make sure the output order: T1.Position. 2) When the question mentions \"team Ryley Goldner\": \"Ryley Goldner\" actually means T2.Name = \"Ryley Goldner\" in schema. 3) When combining match_season AS T1 and team AS T2 for shared entities: link rows where T1.Team = T2.Team_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When filtering for the specific team: use T2.Name = \"Ryley Goldner\" instead of filtering directly on team column with literal 'Ryley Goldner'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT position FROM players WHERE team = 'Ryley Goldner';",
            "SELECT T1.Position FROM match_season AS T1 JOIN team AS T2 ON T1.Team = T2.Team_id WHERE T2.Name = 'Ryley Goldner'"
        ],
        "rule_sql": [
            "SELECT T1.Position\nFROM match_season AS T1\nINNER JOIN team AS T2 ON T1.Team = T2.Team_id\nWHERE T2.Name = 'Ryley Goldner'\nORDER BY T1.Position"
        ]
    },
    "5784": {
        "db_id": "customer_complaints",
        "question": "Find the phone number of all the customers and staff.",
        "ground_truth": "SELECT phone_number FROM customers UNION SELECT phone_number FROM staff",
        "amends": [
            "Do reference `phone_number` column instead of `phone` in both SELECT clauses to match the actual column name in the tables. Do maintain the UNION operation between the customer and staff phone number queries instead of changing the set operation. The amended query now correctly retrieves phone numbers from both tables using the proper column name and preserves the UNION behavior to combine results without duplicates."
        ],
        "rules": [
            "1) When the question asks for phone numbers from customers and staff: use the exact column name \"phone_number\" instead of \"phone\" to match the schema. 2) When combining results from multiple tables: use UNION operation to combine phone numbers from both tables without duplicates. 3) When selecting from the Customers table: reference the \"phone_number\" column exactly as specified in the schema. 4) When selecting from the Staff table: reference the \"phone_number\" column exactly as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT phone FROM customers UNION SELECT phone FROM staff;",
            "SELECT phone_number FROM Customers\nUNION\nSELECT phone_number FROM Staff;"
        ],
        "rule_sql": [
            "SELECT phone_number FROM Customers\nUNION\nSELECT phone_number FROM Staff;"
        ]
    },
    "5740": {
        "db_id": "dorm_1",
        "question": "Find the number of students who is older than 20 in each dorm.",
        "ground_truth": "SELECT count(*) ,  T3.dorm_name FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T1.age  >  20 GROUP BY T3.dorm_name",
        "amends": [
            "Do use explicit table aliases `T1`, `T2`, and `T3` instead of bare table names. Do specify the count column as `count(*)` without an alias instead of `COUNT(*)`. Do add proper table joins with `JOIN lives_in AS T2 ON T1.stuid = T2.stuid` and `JOIN dorm AS T3 ON T3.dormid = T2.dormid` instead of querying a single table. Do reference the dorm column as `T3.dorm_name` instead of just `dorm`. Do qualify the age filter with `T1.age > 20` instead of `age > 20`. Do group by `T3.dorm_name` instead of `dorm`. The amended query now correctly joins multiple tables to count students by dorm name for those over age 20, matching the right SQL's behavior.",
            "Do place `count(*)` before `T3.dorm_name` in the SELECT list instead of after it. Do use lowercase `stuid` and `age` column references instead of uppercase `StuID` and `Age`. Do add spaces around the equals operators in the JOIN conditions instead of omitting them. The amended query now correctly counts students over age 20 grouped by dormitory name with proper column casing and spacing."
        ],
        "rules": [
            "1) When answering about \"number of students who is older than 20 in each dorm\": make sure the output order: T3.dorm_name, count(*) 2) When the question mentions \"dorm\": \"dorm\" actually means \"T3.dorm_name in schema\" 3) When the question mentions \"students older than 20\": use the condition T1.Age > 20 4) When combining Student (T1), Lives_in (T2), and dorm (T3) for shared entities: link rows where T1.StuID = T2.stuid and T3.dormid = T2.dormid; keep only matching pairs (inner match) 5) When the question asks for \"count of students\": compute the number of rows using the canonical key token T1.StuID 6) When the question says \"per dorm\"/\"by dorm\": organize results by T3.dorm_name and compute count per group",
            "1) When the question asks for \"number of students\" per dorm: place the count before the dorm name in the output order. 2) When referencing the student ID column from the Student table: use the exact token \"StuID\" with uppercase 'S' and 'ID'. 3) When referencing the student ID column from the Lives_in table: use the exact token \"stuid\" with all lowercase letters. 4) When referencing the age column from the Student table: use the exact token \"age\" with all lowercase letters. 5) When joining tables using equality conditions: include spaces around the equals operators for readability. 6) When counting students older than 20 per dorm: use the canonical key \"stuid\" from the Lives_in table for counting, as it represents the student entity in this context."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT dorm, COUNT(*) FROM students WHERE age > 20 GROUP BY dorm;",
            "SELECT T3.dorm_name, count(*) \nFROM Student AS T1 \nJOIN Lives_in AS T2 ON T1.StuID = T2.stuid \nJOIN Dorm AS T3 ON T3.dormid = T2.dormid \nWHERE T1.Age > 20 \nGROUP BY T3.dorm_name",
            "SELECT count(*), T3.dorm_name FROM Student AS T1 JOIN Lives_in AS T2 ON T1.stuid = T2.stuid JOIN Dorm AS T3 ON T3.dormid = T2.dormid WHERE T1.age > 20 GROUP BY T3.dorm_name"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.stuid), T3.dorm_name \nFROM Student T1\nJOIN Lives_in T2 ON T1.StuID = T2.stuid\nJOIN Dorm T3 ON T3.dormid = T2.dormid\nWHERE T1.Age > 20\nGROUP BY T3.dorm_name"
        ]
    },
    "6459": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "Show ids for all documents in type CV without expense budgets.",
        "ground_truth": "SELECT document_id FROM Documents WHERE document_type_code  =  \"CV\" EXCEPT SELECT document_id FROM Documents_with_expenses",
        "amends": [
            "Do select `document_id` instead of `id` and use `document_type_code` instead of `type`. Do use `EXCEPT` to exclude documents found in `Documents_with_expenses` instead of checking for `expense_budget IS NULL`. Do reference table `Documents` instead of `documents` and use double quotes around `\"CV\"` instead of single quotes. The amended query now correctly excludes documents with expenses by using the EXCEPT operator against the Documents_with_expenses table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting document identifiers: use \"document_id\" instead of \"id\" as the output column. 2) When filtering by document type: use \"document_type_code\" instead of \"type\" as the column name. 3) When checking for documents without expense budgets: use EXCEPT to exclude documents found in the \"Documents_with_expenses\" table instead of checking for NULL values. 4) When referencing the main documents table: use \"Documents\" instead of \"documents\" with proper capitalization. 5) When filtering for CV type documents: use double quotes around \"CV\" instead of single quotes for the literal value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM documents WHERE type = 'CV' AND expense_budget IS NULL;",
            "SELECT document_id FROM Documents WHERE document_type_code = \"CV\" EXCEPT SELECT Document_ID FROM Documents_with_Expenses"
        ],
        "rule_sql": [
            "SELECT document_id FROM Documents WHERE document_type_code = \"CV\" EXCEPT SELECT Document_ID FROM Documents_with_Expenses"
        ]
    },
    "1871": {
        "db_id": "wrestler",
        "question": "Return the names of wrestlers with fewer than 100 days held.",
        "ground_truth": "SELECT Name FROM wrestler WHERE Days_held  <  100",
        "amends": [
            "Do reference the table as `wrestler` instead of `wrestlers` to match the correct table name. Do use the column name `Name` instead of `name` to match the correct column casing. Do change the filter condition to `Days_held < 100` instead of `days_held > 100` to correctly select records with fewer than 100 days held rather than more than 100 days held. The amended query now correctly filters for wrestlers with less than 100 days held using the proper table and column names."
        ],
        "rules": [
            "1) When the question asks about wrestlers: use the exact table name \"wrestler\" (not \"wrestlers\"). 2) When selecting wrestler names: use the exact column name \"Name\" with proper casing. 3) When filtering for wrestlers with fewer than 100 days held: use the condition \"Days_held < 100\" to select records where the days held value is less than 100."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM wrestlers WHERE days_held > 100;",
            "SELECT Name FROM wrestler WHERE Days_held < 100"
        ],
        "rule_sql": [
            "SELECT Name FROM wrestler WHERE Days_held < 100;"
        ]
    },
    "181": {
        "db_id": "bike_1",
        "question": "Find the zip code in which the average mean visibility is lower than 10.",
        "ground_truth": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_visibility_miles)  <  10",
        "amends": [
            "Do reference the `weather` table instead of `weather_data` in the FROM clause. Do use `HAVING avg(mean_visibility_miles) < 10` instead of `WHERE visibility < 10` to filter after aggregation rather than before. Do aggregate the `mean_visibility_miles` column with an average function instead of using the raw `visibility` column. The amended query now correctly calculates average visibility per zip code and filters groups where the average falls below 10 miles, matching the intended behavior.",
            "Do remove `AVG(mean_visibility_miles) as avg_visibility` from the SELECT list instead of including it, as the RIGHT_SQL only needs to return zip codes that meet the filtering criteria. Do keep the `HAVING avg(mean_visibility_miles) < 10` condition instead of the identical logic, maintaining the same aggregation filter to identify zip codes with average visibility below 10 miles. The amended query now correctly returns only zip codes without the unnecessary average visibility calculation in the output, matching RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"average mean visibility per zip code\": compute the average of \"mean_visibility_miles\" column for each \"zip_code\" group. 2) When filtering groups based on average visibility: apply the condition \"avg(mean_visibility_miles) < 10\" after aggregation using HAVING clause. 3) When the question mentions \"zip code\": use the exact column token \"zip_code\" from the weather table. 4) When the question mentions \"mean visibility\": use the exact column token \"mean_visibility_miles\" from the weather table. 5) When the question asks for results where average visibility is lower than 10: filter groups where the average of \"mean_visibility_miles\" is strictly less than 10.",
            "1) When the question asks for zip codes meeting a condition on aggregated visibility: return only the zip_code column without including the aggregate value in the output. 2) When filtering for average mean visibility lower than 10: apply the condition HAVING AVG(mean_visibility_miles) < 10 to identify zip codes where the average visibility is below 10 miles. 3) When grouping by zip code to compute average visibility: use GROUP BY zip_code to organize weather data by zip code before applying the aggregation filter."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT zip_code FROM weather_data WHERE visibility < 10 GROUP BY zip_code;",
            "SELECT zip_code, AVG(mean_visibility_miles) as avg_visibility\nFROM weather\nGROUP BY zip_code\nHAVING AVG(mean_visibility_miles) < 10",
            "SELECT zip_code FROM weather GROUP BY zip_code HAVING AVG(mean_visibility_miles) < 10"
        ],
        "rule_sql": [
            "SELECT zip_code FROM weather GROUP BY zip_code HAVING AVG(mean_visibility_miles) < 10;"
        ]
    },
    "1672": {
        "db_id": "theme_gallery",
        "question": "What are the names of artists that have not had any exhibitions?",
        "ground_truth": "SELECT name FROM artist WHERE artist_id NOT IN (SELECT artist_id FROM exhibition)",
        "amends": [
            "Do reference table `artist` instead of `artists` in the FROM clause. Do reference table `exhibition` instead of `exhibitions` in the subquery. The amended query now correctly matches the intended behavior by using the proper table names."
        ],
        "rules": [
            "1) When answering about \"artists that have not had any exhibitions\": use table \"artist\" as T1 instead of \"artists\" in the FROM clause. 2) When checking for artists without exhibitions in the subquery: use table \"exhibition\" as T2 instead of \"exhibitions\" in the NOT IN condition. 3) When matching artists to exhibitions: use the exact key equality T1.artist_id = T2.artist_id as implied by the subquery structure."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM artists WHERE artist_id NOT IN (SELECT artist_id FROM exhibitions);",
            "SELECT Name FROM artist WHERE Artist_ID NOT IN (SELECT Artist_ID FROM exhibition)"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM artist AS T1 WHERE T1.Artist_ID NOT IN (SELECT T2.Artist_ID FROM exhibition AS T2 WHERE T1.Artist_ID = T2.Artist_ID)"
        ]
    },
    "2981": {
        "db_id": "sakila_1",
        "question": "Count the number of stores.",
        "ground_truth": "SELECT count(*) FROM store",
        "amends": [
            "Do query from `store` table instead of `products` table. The amended query now correctly counts records from the store table as intended."
        ],
        "rules": [
            "1) When counting the number of stores: use the \"store\" table instead of the \"products\" table. 2) When counting entities: count records from the table that directly represents the entity being counted (stores from \"store\" table)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM products;",
            "SELECT COUNT(*) FROM store;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM store;"
        ]
    },
    "4314": {
        "db_id": "club_1",
        "question": "What is the average age of the members of the club \"Bootup Baltimore\"?",
        "ground_truth": "SELECT avg(t3.age) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\"",
        "amends": [
            "Do specify the full table-qualified column `avg(t3.age)` instead of the unqualified `AVG(age)`. Do join three tables `club AS t1`, `member_of_club AS t2`, and `student AS t3` with explicit `JOIN` conditions instead of querying a single table. Do use the correct join predicates `t1.clubid = t2.clubid` and `t2.stuid = t3.stuid` to establish proper relationships between tables instead of missing these connections. Do filter on the correct column name `t1.clubname` with double quotes instead of `club_name` with single quotes. The amended query now correctly calculates the average age of students in the specified club by properly joining the necessary tables with appropriate relationships."
        ],
        "rules": [
            "1) When answering about \"average age of members of a club\": make sure the output order: average age of students in the specified club. 2) When the question mentions \"Bootup Baltimore\": \"Bootup Baltimore\" actually means \"t1.clubname\" in schema with exact literal 'Bootup Baltimore'. 3) When combining tables for club membership information: link rows where t1.clubid = t2.clubid and t2.stuid = t3.stuid to establish proper relationships between club, member_of_club, and student tables; keep only matching pairs (inner match). 4) When computing average age: use the full table-qualified column avg(t3.age) instead of unqualified AVG(age). 5) When filtering for a specific club: use the correct column name t1.clubname with double quotes instead of club_name with single quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age) FROM members WHERE club_name = 'Bootup Baltimore';",
            "SELECT AVG(t3.age) AS average_age\nFROM club AS t1\nJOIN member_of_club AS t2 ON t1.ClubID = t2.ClubID\nJOIN student AS t3 ON t2.StuID = t3.StuID\nWHERE t1.ClubName = \"Bootup Baltimore\";"
        ],
        "rule_sql": [
            "SELECT AVG(t3.age) \nFROM Club t1\nJOIN Member_of_club t2 ON t1.ClubID = t2.ClubID\nJOIN Student t3 ON t2.StuID = t3.StuID\nWHERE t1.ClubName = 'Bootup Baltimore'"
        ]
    },
    "1372": {
        "db_id": "college_2",
        "question": "Find the name of the department that offers the highest total credits?",
        "ground_truth": "SELECT dept_name FROM course GROUP BY dept_name ORDER BY sum(credits) DESC LIMIT 1",
        "amends": [
            "Do select `dept_name` instead of `department_name` and do aggregate with `sum(credits)` instead of referencing `total_credits` directly. Do use `FROM course` instead of `FROM departments` and add `GROUP BY dept_name` instead of omitting it. Do order by `sum(credits) DESC` instead of `total_credits DESC`. The amended query now correctly aggregates course credits by department name and returns the department with the highest total credits, matching the intended behavior.",
            "Do remove the `SUM(credits) as total_credits` column from the SELECT list instead of including it, and do reference the aggregate function directly in the ORDER BY clause as `sum(credits)` instead of using the alias `total_credits`. The amended query now correctly returns only department names while ordering by the sum of credits, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the department name: use the exact column token \"dept_name\" from the course table. 2) When the question asks for highest total credits: compute the sum of \"credits\" column grouped by \"dept_name\" instead of using a direct \"total_credits\" column. 3) When aggregating credits by department: group results by \"dept_name\" to organize courses by their department. 4) When ranking departments by total credits: order results by the computed sum(credits) in descending order to find the highest value. 5) When selecting the top department: return only the first row after ordering by the aggregated sum of credits in descending order.",
            "1) When answering about \"the department that offers the highest total credits\": make sure the output order includes only \"dept_name\" and excludes aggregate columns like \"SUM(credits)\" from the final result. 2) When ordering by an aggregate value to find the highest total: use the aggregate function \"sum(credits)\" directly in the ORDER BY clause instead of referencing an alias. 3) When the question asks for the \"highest\" total credits: rank departments by \"sum(credits)\" in descending order and keep only the first row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department_name FROM departments ORDER BY total_credits DESC LIMIT 1;",
            "SELECT dept_name, SUM(credits) as total_credits\nFROM course\nGROUP BY dept_name\nORDER BY total_credits DESC\nLIMIT 1;",
            "SELECT dept_name FROM course GROUP BY dept_name ORDER BY sum(credits) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT dept_name FROM course GROUP BY dept_name ORDER BY SUM(credits) DESC LIMIT 1;"
        ]
    },
    "6572": {
        "db_id": "wine_1",
        "question": "Give the average price and case of wines made from Zinfandel grapes in the year 2009.",
        "ground_truth": "SELECT AVG(Price) ,  AVG(Cases) FROM WINE WHERE YEAR  =  2009 AND Grape  =  \"Zinfandel\"",
        "amends": [
            "Do include both `AVG(Price)` and `AVG(Cases)` in the SELECT list instead of only `AVG(price)` with an incomplete `case` expression. Do reference the correct table name `WINE` instead of `wines`. Do use the correct column capitalization `Price` and `Cases` instead of lowercase `price` and incomplete `case`. Do place the filter conditions in the order `YEAR = 2009 AND Grape = \"Zinfandel\"` instead of `grape = 'Zinfandel' AND year = 2009`, while maintaining the same logical filtering. The amended query now correctly calculates average price and average cases for Zinfandel wines from 2009, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about average price and case of wines: make sure to compute both AVG(Price) and AVG(Cases) as separate output columns. 2) When the question mentions \"wines\": use the exact table name \"WINE\" instead of \"wines\". 3) When referring to price and case columns: use the exact column names \"Price\" and \"Cases\" with proper capitalization. 4) When filtering for Zinfandel grapes and year 2009: use the exact condition order YEAR = 2009 AND Grape = \"Zinfandel\" with double quotes around \"Zinfandel\". 5) When computing averages for Zinfandel wines from 2009: ensure the filter conditions YEAR = 2009 AND Grape = \"Zinfandel\" are applied to select the correct subset of records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(price), case FROM wines WHERE grape = 'Zinfandel' AND year = 2009;",
            "SELECT AVG(Price) AS AveragePrice, AVG(Cases) AS AverageCases FROM wine WHERE Year = 2009 AND Grape = 'Zinfandel'"
        ],
        "rule_sql": [
            "SELECT AVG(Price) AS AveragePrice, AVG(Cases) AS AverageCases FROM wine WHERE Year = 2009 AND Grape = \"Zinfandel\""
        ]
    },
    "3281": {
        "db_id": "college_1",
        "question": "Find the last name and hire date of the professor who is in office DRE 102.",
        "ground_truth": "SELECT T1.emp_lname ,  T1.emp_hiredate FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num WHERE T2.prof_office  =  'DRE 102'",
        "amends": [
            "Do select `emp_lname` and `emp_hiredate` from the `employee` table instead of `last_name` and `hire_date` from `professors`. Do join `employee AS T1` with `professor AS T2` on `T1.emp_num = T2.emp_num` instead of querying only the `professors` table. Do filter on `T2.prof_office = 'DRE 102'` instead of `office = 'DRE 102'`. Do remove the `ORDER BY hire_date ASC LIMIT 1` clause instead of keeping it, as the join relationship ensures proper data retrieval without limiting to a single record. The amended query now correctly retrieves employee details by joining the employee and professor tables and filtering on the professor's office location, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"last name\" and \"hire date\": use the exact column tokens \"emp_lname\" and \"emp_hiredate\" from the employee table. 2) When combining employee and professor data: join \"employee AS T1\" with \"professor AS T2\" where \"T1.emp_num = T2.emp_num\" and keep only matching pairs (inner match). 3) When filtering by office location: use the exact condition \"T2.prof_office = 'DRE 102'\" with the literal value exactly as specified. 4) When the question does not specify ordering or limiting: do not apply any ORDER BY or LIMIT clauses to the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name, hire_date FROM professors WHERE office = 'DRE 102' ORDER BY hire_date ASC LIMIT 1;",
            "SELECT T1.emp_lname, T1.emp_hiredate FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num = T2.emp_num WHERE T2.prof_office = 'DRE 102'"
        ],
        "rule_sql": [
            "SELECT T1.emp_lname, T1.emp_hiredate FROM employee AS T1 INNER JOIN professor AS T2 ON T1.emp_num = T2.emp_num WHERE T2.prof_office = 'DRE 102'"
        ]
    },
    "2935": {
        "db_id": "sakila_1",
        "question": "What are the city name, id, and number of addresses corresponding to the city with the most addressed?",
        "ground_truth": "SELECT T2.city ,  count(*) ,  T1.city_id FROM address AS T1 JOIN city AS T2 ON T1.city_id  =  T2.city_id GROUP BY T1.city_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `city AS T2` instead of omitting it, and use `JOIN` on `T1.city_id = T2.city_id` instead of querying only the addresses table. Do select `T2.city` and `T1.city_id` instead of just `city` and `city_id` without table qualification. Do use `count(*)` instead of `COUNT(address_id)` for the aggregate. Do group by `T1.city_id` instead of grouping by `city_id` without table specification. Do order by `count(*) DESC` instead of `address_count ASC` to find the city with the highest rather than lowest address count. Do remove the alias `address_count` instead of keeping it since the ORDER BY clause directly references the aggregate function. The amended query now correctly joins the city table to retrieve city names and finds the city with the maximum number of addresses, matching the RIGHT_SQL's behavior.",
            "Do include `T2.city` in the SELECT list instead of omitting it, and do place `count(*)` before `T1.city_id` in the output order instead of after it. The amended query now correctly displays the city name alongside the count and city_id, matching the RIGHT_SQL's behavior.",
            "Do include `T2.city` in the SELECT list instead of omitting it, and do add `T1.city_id` to the SELECT list instead of having it only in GROUP BY. Do maintain the same FROM clause with `JOIN` on `T1.city_id = T2.city_id` instead of changing it. Do keep the same GROUP BY on `T1.city_id` instead of altering it. Do preserve the same ORDER BY on `count(*) DESC` and LIMIT 1 instead of modifying them. The amended query now correctly includes all necessary columns in the SELECT list while maintaining the same aggregation logic and result ordering.",
            "Do include `T2.city` in the SELECT list instead of omitting it, and do add `T1.city_id` to the SELECT list instead of having it only in GROUP BY. Do maintain the same FROM clause with `JOIN` on `T1.city_id = T2.city_id` instead of changing it. Do keep the same GROUP BY on `T1.city_id` instead of modifying it. Do preserve the same ORDER BY on `count(*) DESC` and LIMIT 1 instead of altering them. The amended query now correctly includes all necessary columns in the SELECT list while maintaining the same aggregation logic and result ordering.",
            "Do include `T2.city` in the SELECT list instead of omitting it, and do add `T1.city_id` to the SELECT list instead of having it only in GROUP BY. Do maintain the same FROM clause with `JOIN` on `T1.city_id = T2.city_id` instead of changing it. Do keep the same GROUP BY on `T1.city_id` instead of modifying it. Do preserve the same ORDER BY on `count(*) DESC` and LIMIT 1 instead of altering them. The amended query now correctly includes all necessary columns in the SELECT list while maintaining the same aggregation logic and result ordering."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, city_id, COUNT(address_id) as address_count \nFROM addresses \nGROUP BY city_id \nORDER BY address_count ASC \nLIMIT 1;",
            "SELECT T2.city, T1.city_id, COUNT(*) \nFROM address AS T1 \nJOIN city AS T2 ON T1.city_id = T2.city_id \nGROUP BY T1.city_id \nORDER BY COUNT(*) DESC \nLIMIT 1",
            "SELECT T2.city, T1.city_id, count(*)\nFROM address AS T1\nJOIN city AS T2 ON T1.city_id = T2.city_id\nGROUP BY T1.city_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T2.city, T1.city_id, count(*)\nFROM address AS T1\nJOIN city AS T2 ON T1.city_id = T2.city_id\nGROUP BY T1.city_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T2.city, T1.city_id, count(*)\nFROM address AS T1\nJOIN city AS T2 ON T1.city_id = T2.city_id\nGROUP BY T1.city_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T2.city, T1.city_id, count(*)\nFROM address AS T1\nJOIN city AS T2 ON T1.city_id = T2.city_id\nGROUP BY T1.city_id\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "1199": {
        "db_id": "apartment_rentals",
        "question": "Give me a list of all the distinct building descriptions.",
        "ground_truth": "SELECT DISTINCT building_description FROM Apartment_Buildings",
        "amends": [
            "Do reference `building_description` from the `Apartment_Buildings` table instead of `building` from the `descriptions` table. Do maintain the `DISTINCT` clause to return unique values as in the original query. The amended query now correctly selects distinct building descriptions from the appropriate table structure, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"building descriptions\": use the exact column token \"building_description\" from the \"Apartment_Buildings\" table. 2) When selecting distinct values for building descriptions: maintain the DISTINCT clause to return only unique values from the \"building_description\" column. 3) When referencing the table containing building descriptions: use the \"Apartment_Buildings\" table as the source table (T1)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT building FROM descriptions;",
            "SELECT DISTINCT building_description FROM Apartment_Buildings;"
        ],
        "rule_sql": [
            "SELECT DISTINCT building_description FROM Apartment_Buildings;"
        ]
    },
    "603": {
        "db_id": "store_1",
        "question": "Find the number of employees whose title is IT Staff from each city?",
        "ground_truth": "SELECT count(*) ,  city FROM employees WHERE title  =  'IT Staff' GROUP BY city",
        "amends": [
            "Do place `city` after `count(*)` in the SELECT list instead of before it, maintaining the same aggregation logic and filtering condition. The amended query now matches RIGHT_SQL's behavior with identical results."
        ],
        "rules": [
            "1) When the question asks for \"number of employees whose title is IT Staff from each city\": compute the count using the canonical key for employees and group by the exact token \"city\". 2) When ordering output columns: place the count result before the city column in the output. 3) When filtering for title: use the exact literal 'IT Staff' with case and spacing preserved. 4) When referring to the city column: use the exact identifier \"city\" without quotes as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, COUNT(*) FROM employees WHERE title = 'IT Staff' GROUP BY city;",
            "SELECT COUNT(*) AS employee_count, city FROM employees WHERE title = 'IT Staff' GROUP BY city;"
        ],
        "rule_sql": [
            "SELECT COUNT(id) AS employee_count, city FROM employees WHERE title = 'IT Staff' GROUP BY city"
        ]
    },
    "4078": {
        "db_id": "student_1",
        "question": "Find the last names of the students in third grade that are not taught by COVIN JEROME.",
        "ground_truth": "SELECT DISTINCT T1.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.grade  =  3 AND T2.firstname != \"COVIN\" AND T2.lastname != \"JEROME\"",
        "amends": [
            "Do select `DISTINCT T1.lastname` instead of `last_name` and use table aliases instead of bare column references. Do join `teachers AS T2` on `T1.classroom = T2.classroom` instead of omitting the join entirely. Do filter on `T1.grade = 3` instead of just `grade = 3` with proper table qualification. Do change the teacher filter to `T2.firstname != \"COVIN\" AND T2.lastname != \"JEROME\"` instead of `teacher != 'COVIN JEROME'` to properly separate first and last name comparisons. The amended query now correctly joins student and teacher data and matches the intended filtering logic."
        ],
        "rules": [
            "1) When selecting student last names: use DISTINCT T1.lastname instead of last_name to ensure unique results. 2) When combining student and teacher data: join teachers AS T2 on T1.classroom = T2.classroom to link students with their teachers. 3) When filtering for third grade students: use T1.grade = 3 with proper table qualification. 4) When excluding students taught by COVIN JEROME: use T2.firstname != \"COVIN\" AND T2.lastname != \"JEROME\" to properly separate first and last name comparisons instead of comparing against a single combined teacher name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM students WHERE grade = 3 AND teacher != 'COVIN JEROME';",
            "SELECT DISTINCT T1.LastName\nFROM list AS T1\nJOIN teachers AS T2 ON T1.Classroom = T2.Classroom\nWHERE T1.Grade = 3\nAND (T2.FirstName != 'COVIN' OR T2.LastName != 'JEROME')"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.LastName FROM list AS T1 JOIN teachers AS T2 ON T1.Classroom = T2.Classroom WHERE T1.Grade = 3 AND (T2.FirstName != 'COVIN' OR T2.LastName != 'JEROME')"
        ]
    },
    "3492": {
        "db_id": "hr_1",
        "question": "what are the employee ids and job titles for employees in department 80?",
        "ground_truth": "SELECT T1.employee_id ,  T2.job_title FROM employees AS T1 JOIN jobs AS T2 ON T1.job_id  =  T2.job_id WHERE T1.department_id = 80",
        "amends": [
            "Do add table `jobs AS T2` with a `JOIN` on `T1.job_id = T2.job_id` instead of querying only the `employees` table. Do specify `T1.employee_id` and `T2.job_title` with table aliases instead of selecting columns without table qualification. Do keep the `WHERE T1.department_id = 80` filter instead of changing it. The amended query now correctly joins the employees and jobs tables to retrieve job titles from the appropriate source table."
        ],
        "rules": [
            "1) When answering about \"employee ids and job titles for employees in department 80\": make sure the output order: T1.employee_id, T2.job_title\n2) When combining employees and jobs tables: link rows where T1.job_id = T2.job_id and keep only matching pairs (inner match)\n3) When filtering for department 80: include only rows where T1.department_id = 80\n4) When selecting columns from multiple tables: specify table aliases for all columns (T1.employee_id, T2.job_title) instead of using unqualified column names"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT employee_id, job_title FROM employees WHERE department_id = 80",
            "SELECT T1.employee_id, T2.job_title FROM employees AS T1 JOIN jobs AS T2 ON T1.job_id = T2.job_id WHERE T1.department_id = 80"
        ],
        "rule_sql": [
            "SELECT T1.EMPLOYEE_ID, T2.JOB_TITLE \nFROM employees T1 \nINNER JOIN jobs T2 ON T1.JOB_ID = T2.JOB_ID \nWHERE T1.DEPARTMENT_ID = 80"
        ]
    },
    "4362": {
        "db_id": "tracking_grants_for_research",
        "question": "Show the role description and the id of the project staff involved in most number of project outcomes?",
        "ground_truth": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `Staff_Roles AS T1` and `Project_Staff AS T2` on `T1.role_code = T2.role_code` instead of querying only `project_staff` table. Do add `Project_outcomes AS T3` joined on `T2.project_id = T3.project_id` instead of omitting it. Do select `T1.role_description` and `T2.staff_id` instead of `role_description` and `project_staff_id`. Do add `GROUP BY T2.staff_id` instead of omitting grouping. Do order by `count(*)` instead of `COUNT(project_outcome_id)` to count joined outcomes per staff. The amended query now correctly identifies staff with the most project outcomes by joining necessary tables and grouping appropriately."
        ],
        "rules": [
            "1) When answering about \"project staff involved in most number of project outcomes\": make sure the output order: T1.role_description, T2.staff_id\n2) When combining Staff_Roles and Project_Staff: link rows where T1.role_code = T2.role_code and keep only matching pairs (inner match)\n3) When combining Project_Staff and Project_outcomes: link rows where T2.project_id = T3.project_id and keep only matching pairs (inner match)\n4) When the question asks for \"count of project outcomes per staff\": compute the number of rows using the joined outcomes from T3 per T2.staff_id\n5) When the question mentions \"most number\": rank rows by count of outcomes in descending order and keep the first 1 row\n6) When grouping by staff: organize results by T2.staff_id and compute count of outcomes per group"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT role_description, project_staff_id \nFROM project_staff \nORDER BY COUNT(project_outcome_id) DESC \nLIMIT 1;",
            "SELECT T1.role_description, T2.staff_id\nFROM Staff_Roles AS T1\nJOIN Project_Staff AS T2 ON T1.role_code = T2.role_code\nJOIN Project_Outcomes AS T3 ON T2.project_id = T3.project_id\nGROUP BY T2.staff_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.role_description, T2.staff_id\nFROM Staff_Roles T1\nINNER JOIN Project_Staff T2 ON T1.role_code = T2.role_code\nINNER JOIN Project_Outcomes T3 ON T2.project_id = T3.project_id\nGROUP BY T2.staff_id\nORDER BY COUNT(T3.outcome_code) DESC\nLIMIT 1;"
        ]
    },
    "5019": {
        "db_id": "soccer_2",
        "question": "What college has a student who successfully made the team in the role of a goalie?",
        "ground_truth": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'",
        "amends": [
            "Do select `cName` instead of `college` and use table `tryout` instead of `students`. Do filter on `decision = 'yes'` instead of `team_status = 'successful'` while keeping the `pPos = 'goalie'` condition instead of `role = 'goalie'`. The amended query now correctly selects from the appropriate table with the proper column names and filtering conditions to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"college with a student who successfully made the team as goalie\": select \"cName\" instead of \"college\" as the output column. 2) When the question mentions \"college\": use table \"tryout\" instead of \"students\". 3) When the question mentions \"successfully made the team\": filter on \"decision = 'yes'\" instead of \"team_status = 'successful'\". 4) When the question mentions \"goalie\" role: filter on \"pPos = 'goalie'\" instead of \"role = 'goalie'\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT college FROM students WHERE role = 'goalie' AND team_status = 'successful';",
            "SELECT cName FROM Tryout WHERE pPos = 'goalie' AND decision = 'yes';"
        ],
        "rule_sql": [
            "SELECT cName FROM Tryout WHERE decision = 'yes' AND pPos = 'goalie';"
        ]
    },
    "3834": {
        "db_id": "e_learning",
        "question": "List the dates of enrollment and completion of the student with family name \"Zieme\" and personal name \"Bernie\".",
        "ground_truth": "SELECT T1.date_of_enrolment ,  T1.date_of_completion FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id WHERE T2.family_name  =  \"Zieme\" AND T2.personal_name  =  \"Bernie\"",
        "amends": [
            "Do select `T1.date_of_enrolment` and `T1.date_of_completion` from the `Student_Course_Enrolment` table instead of `enrollment_date` and `completion_date` from the `students` table. Do add a `JOIN` between `Student_Course_Enrolment AS T1` and `Students AS T2` with the predicate `T1.student_id = T2.student_id` instead of querying only the `students` table. Do apply the filters `T2.family_name = \"Zieme\"` and `T2.personal_name = \"Bernie\"` to the joined `Students` table instead of directly to the base table. The amended query now correctly retrieves enrollment and completion dates from the enrollment table while filtering by student names through the proper join relationship, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about enrollment and completion dates: select \"T1\".\"date_of_enrolment\" and \"T1\".\"date_of_completion\" from the \"Student_Course_Enrolment\" table as T1. 2) When filtering by student name attributes: join \"Student_Course_Enrolment\" AS T1 with \"Students\" AS T2 using the condition \"T1\".\"student_id\" = \"T2\".\"student_id\". 3) When the question mentions family name \"Zieme\" and personal name \"Bernie\": apply filters \"T2\".\"family_name\" = \"Zieme\" and \"T2\".\"personal_name\" = \"Bernie\" to the joined \"Students\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT enrollment_date, completion_date FROM students WHERE family_name = 'Zieme' AND personal_name = 'Bernie';",
            "SELECT T1.date_of_enrolment, T1.date_of_completion \nFROM Student_Course_Enrolment AS T1\nJOIN Students AS T2 ON T1.student_id = T2.student_id\nWHERE T2.family_name = 'Zieme' AND T2.personal_name = 'Bernie'"
        ],
        "rule_sql": [
            "SELECT T1.date_of_enrolment, T1.date_of_completion FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id = T2.student_id WHERE T2.family_name = 'Zieme' AND T2.personal_name = 'Bernie'"
        ]
    },
    "6430": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "Return the type name, type description, and date of creation for each document.",
        "ground_truth": "SELECT T1.document_type_name ,  T1.document_type_description ,  T2.Document_date FROM Ref_document_types AS T1 JOIN Documents AS T2 ON T1.document_type_code  =  T2.document_type_code",
        "amends": [
            "Do specify table aliases `T1.document_type_name`, `T1.document_type_description`, and `T2.Document_date` instead of unqualified column names `type_name`, `type_description`, and `date_created`. Do join `Ref_document_types AS T1` with `Documents AS T2` instead of querying only the `documents` table. Do use the join condition `T1.document_type_code = T2.document_type_code` instead of no join condition. The amended query now correctly retrieves document type information from the reference table joined with document details using the appropriate relationship key."
        ],
        "rules": [
            "1) When answering about document types and creation dates: make sure to join Ref_document_types as T1 with Documents as T2 using the condition T1.document_type_code = T2.document_type_code instead of querying only one table. 2) When selecting document type information: use T1.document_type_name and T1.document_type_description instead of unqualified column names. 3) When selecting document creation date: use T2.Document_date instead of date_created. 4) When combining T1 and T2 for shared document types: link rows where T1.document_type_code = T2.document_type_code and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type_name, type_description, date_created FROM documents",
            "SELECT T1.Document_Type_Name, T1.Document_Type_Description, T2.Document_Date\nFROM Ref_Document_Types AS T1\nJOIN Documents AS T2 ON T1.Document_Type_Code = T2.Document_Type_Code;"
        ],
        "rule_sql": [
            "SELECT T1.Document_Type_Name, T1.Document_Type_Description, T2.Document_Date\nFROM Ref_Document_Types AS T1\nINNER JOIN Documents AS T2 ON T1.Document_Type_Code = T2.Document_Type_Code;"
        ]
    },
    "5313": {
        "db_id": "manufactory_1",
        "question": "What are the average prices of products for each manufacturer?",
        "ground_truth": "SELECT avg(T1.price) ,  T2.name FROM products AS T1 JOIN manufacturers AS T2 ON T1.Manufacturer  =  T2.code GROUP BY T2.name",
        "amends": [
            "Do add `T2.name` in the SELECT list instead of omitting it, and change the aggregate function to reference the table alias as `avg(T1.price)` instead of `AVG(price)`. Do join `manufacturers AS T2` instead of querying only the products table, using `ON T1.Manufacturer = T2.code` instead of the missing join condition. Do change the GROUP BY clause to `T2.name` instead of `manufacturer` to group by the manufacturer name rather than the manufacturer code. The amended query now correctly joins the manufacturers table to display manufacturer names and calculates average prices per manufacturer, matching the RIGHT_SQL's behavior.",
            "Do use `avg(T1.price)` without an alias instead of `AVG(T1.Price) AS AveragePrice` with an alias. Do place `T2.name` after the aggregate instead of before it in the SELECT list. Do use lowercase `avg` and `price` instead of uppercase `AVG` and `Price`. The amended query now matches RIGHT_SQL's behavior with identical logic and output structure.",
            "Do place `avg(T1.price)` first in the SELECT list instead of `T2.name` first, but maintain the same column order in GROUP BY. Do keep the same FROM clause with `JOIN` on `T1.Manufacturer = T2.code` and identical GROUP BY `T2.name`. The amended query now correctly calculates the average price per manufacturer name while maintaining the same logical behavior as the right SQL."
        ],
        "rules": [
            "1) When the question asks for average prices of products for each manufacturer: join the products table (T1) with the manufacturers table (T2) using the condition T1.Manufacturer = T2.code to link products to their manufacturers. 2) When grouping results by manufacturer: use T2.name as the grouping key instead of the manufacturer code to display manufacturer names. 3) When calculating average prices: compute the average of T1.price using the exact column reference with table alias. 4) When selecting output columns: include both T2.name and the average price calculation in the result set.",
            "1) When answering about \"average prices of products for each manufacturer\": make sure the output order: average price calculation first, then manufacturer name. 2) When computing average price: use avg(T1.price) without an alias instead of AVG(T1.Price) AS AveragePrice. 3) When selecting columns: place T2.name after the aggregate function instead of before it in the output. 4) When using function names and column names: use lowercase avg and price instead of uppercase AVG and Price.",
            "1) When answering about \"average prices of products for each manufacturer\": make sure the output order: average price first, then manufacturer name. 2) When combining Products (T1) and Manufacturers (T2) for shared entities: link rows where T1.Manufacturer = T2.code exactly as shown; keep only matching pairs (inner match). 3) When the question says \"per manufacturer\" or \"for each manufacturer\": organize results by T2.name and compute average price per group. 4) When computing average price: use T1.price as the exact column for price values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT manufacturer, AVG(price) FROM products GROUP BY manufacturer;",
            "SELECT T2.Name, AVG(T1.Price) AS AveragePrice FROM Products AS T1 JOIN Manufacturers AS T2 ON T1.Manufacturer = T2.Code GROUP BY T2.Name",
            "SELECT T2.name, avg(T1.price) FROM Products AS T1 JOIN Manufacturers AS T2 ON T1.Manufacturer = T2.code GROUP BY T2.name",
            "SELECT avg(T1.price), T2.name FROM Products AS T1 JOIN Manufacturers AS T2 ON T1.Manufacturer = T2.code GROUP BY T2.name"
        ],
        "rule_sql": [
            "SELECT avg(T1.price), T2.name FROM Products T1 JOIN Manufacturers T2 ON T1.Manufacturer = T2.code GROUP BY T2.name"
        ]
    },
    "2086": {
        "db_id": "pilot_record",
        "question": "List the distinct positions of pilots older than 30.",
        "ground_truth": "SELECT DISTINCT POSITION FROM pilot WHERE Age  >  30",
        "amends": [
            "Do reference table `pilot` instead of `pilots` and use column `Age` instead of `age` while maintaining the same `DISTINCT` selection of `POSITION` and keeping the filter `> 30` unchanged, with all other elements preserved to match the corrected query's behavior."
        ],
        "rules": [
            "1) When the question mentions \"pilots\": use table \"pilot\" instead of \"pilots\" exactly as specified in the schema. 2) When the question mentions \"age\": use column \"Age\" instead of \"age\" exactly as specified in the schema. 3) When filtering for pilots older than 30: apply the condition > 30 to column \"Age\". 4) When selecting distinct positions: use DISTINCT selection on column \"POSITION\" to get unique values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT position FROM pilots WHERE age > 30;",
            "SELECT DISTINCT Position FROM pilot WHERE Age > 30;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Position FROM pilot WHERE Age > 30;"
        ]
    },
    "6469": {
        "db_id": "scientist_1",
        "question": "Find the total number of scientists.",
        "ground_truth": "SELECT count(*) FROM scientists",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM scientists WHERE name IS NOT NULL;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Scientists;"
        ]
    },
    "6748": {
        "db_id": "activity_1",
        "question": "How many male and female assistant professors do we have?",
        "ground_truth": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  \"AsstProf\" GROUP BY sex",
        "amends": [
            "Do use table name `Faculty` instead of `professors` and column name `sex` instead of `gender`. Do use filter condition `rank = \"AsstProf\"` instead of `title = 'Assistant Professor'` while maintaining the same COUNT(*) aggregation and GROUP BY logic. The amended query now correctly references the appropriate table and column names to match the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"professors\": use the table name \"Faculty\" instead. 2) When the question mentions \"gender\": use the column name \"sex\" instead. 3) When the question mentions \"assistant professors\": use the filter condition rank = \"AsstProf\" instead of title = 'Assistant Professor'. 4) When counting professors: use COUNT(*) aggregation and group by the sex column to get counts per gender category."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT gender, COUNT(*) FROM professors WHERE title = 'Assistant Professor' GROUP BY gender;",
            "SELECT sex, COUNT(*) FROM Faculty WHERE rank = \"AsstProf\" GROUP BY sex;"
        ],
        "rule_sql": [
            "SELECT sex, COUNT(*) FROM Faculty WHERE rank = 'AsstProf' GROUP BY sex;"
        ]
    },
    "6800": {
        "db_id": "activity_1",
        "question": "What are the first names of the faculty members playing both Canoeing and Kayaking?",
        "ground_truth": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Kayaking'",
        "amends": [
            "Do select `T1.lname` from the `Faculty` table instead of `first_name` from `faculty`. Do join `Faculty_participates_in` as `T2` on `T1.facID = T2.facID` and `activity` as `T3` on `T2.actid = T3.actid` instead of querying a single table. Do filter for `T3.activity_name = 'Canoeing'` in one branch and `T3.activity_name = 'Kayaking'` in another instead of using contradictory `AND` conditions with the same column. Do use `INTERSECT` to find faculty who participate in both activities instead of trying to match both values simultaneously in a single WHERE clause. Do properly reference the `actid` column as `T2.actid = T3.actid` instead of the incorrect self-join condition `T2.actid = T2.actid`. The amended query now correctly identifies faculty who participate in both Canoeing and Kayaking activities by using intersection logic across two separate queries.",
            "Do select `T1.lname` instead of `T1.Fname` in both SELECT clauses. Do use `T2.actid = T2.actid` instead of `T2.actid = T3.actid` in the JOIN condition between T2 and T3 tables, which creates a self-join condition that may produce different results. The amended query now correctly retrieves last names of faculty who participate in both Canoeing and Kayaking activities using the proper join logic.",
            "Do use consistent lowercase column names `lname` instead of mixed case `Lname` throughout both query parts. Do fix the JOIN condition from `T2.actid = T3.actid` to `T2.actid = T2.actid` in both activity joins, though this appears to be a self-join condition that may need further verification. Do maintain the INTERSECT operation to find faculty who participate in both 'Canoeing' and 'Kayaking' activities. The amended query now correctly identifies faculty members who participate in both specified activities.",
            "Do use `T2.actid = T2.actid` instead of `T2.actid = T3.actid` in both JOIN conditions, which creates a self-join condition that matches the same table's actid values rather than joining between different tables. The amended query now correctly uses identical join predicates in both INTERSECT branches, ensuring the query returns faculty who participate in both Canoeing and Kayaking activities as intended.",
            "Do use `T2.actid = T2.actid` instead of `T2.actid = T3.actid` in both JOIN conditions, which creates a self-join condition that filters for faculty who participate in both activities through the same activity ID. Do maintain the identical `SELECT T1.lname` and `WHERE T3.activity_name` filters for 'Canoeing' and 'Kayaking' respectively, preserving the INTERSECT operation to find faculty who participate in both activities. The amended query now correctly identifies faculty members who have the same activity participation record for both Canoeing and Kayaking, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM faculty WHERE sport = 'Canoeing' AND sport = 'Kayaking';",
            "SELECT T1.Fname FROM Faculty T1\nJOIN Faculty_Participates_in T2 ON T1.FacID = T2.FacID\nJOIN Activity T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Canoeing'\nINTERSECT\nSELECT T1.Fname FROM Faculty T1\nJOIN Faculty_Participates_in T2 ON T1.FacID = T2.FacID\nJOIN Activity T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Kayaking'",
            "SELECT T1.Lname \nFROM Faculty T1\nJOIN Faculty_Participates_in T2 ON T1.FacID = T2.FacID\nJOIN Activity T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Canoeing'\nINTERSECT\nSELECT T1.Lname \nFROM Faculty T1\nJOIN Faculty_Participates_in T2 ON T1.FacID = T2.FacID\nJOIN Activity T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Kayaking'",
            "SELECT T1.lname \nFROM Faculty AS T1\nJOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID\nJOIN Activity AS T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Canoeing'\nINTERSECT\nSELECT T1.lname \nFROM Faculty AS T1\nJOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID\nJOIN Activity AS T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Kayaking'",
            "SELECT T1.lname \nFROM Faculty AS T1\nJOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID\nJOIN Activity AS T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Canoeing'\nINTERSECT\nSELECT T1.lname \nFROM Faculty AS T1\nJOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID\nJOIN Activity AS T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Kayaking'",
            "SELECT T1.lname\nFROM Faculty AS T1\nJOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID\nJOIN Activity AS T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Canoeing'\nINTERSECT\nSELECT T1.lname\nFROM Faculty AS T1\nJOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID\nJOIN Activity AS T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Kayaking'"
        ],
        "rule_sql": []
    },
    "2035": {
        "db_id": "gas_company",
        "question": "find the rank, company names, market values of the companies in the banking industry order by their sales and profits in billion.",
        "ground_truth": "SELECT rank ,  company ,  market_value FROM company WHERE main_industry  =  'Banking' ORDER BY sales_billion ,  profits_billion",
        "amends": [
            "Do reference the `company` table instead of `companies` and use column `company` instead of `company_name` in the SELECT list. Do filter on `main_industry = 'Banking'` instead of `industry = 'banking'` with proper case sensitivity. Do order by `sales_billion` and `profits_billion` columns instead of `sales` and `profits` to match the correct column names. The amended query now correctly references the appropriate table and columns to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks about companies: use the table \"company\" instead of \"companies\". 2) When the question mentions \"company names\": use the column \"company\" instead of \"company_name\" in the output. 3) When filtering for companies in the banking industry: use the condition \"main_industry = 'Banking'\" with exact case sensitivity. 4) When ordering by sales and profits in billion: use columns \"sales_billion\" and \"profits_billion\" instead of \"sales\" and \"profits\". 5) When answering about rank, company names, and market values: make sure the output order is: rank, company, market_value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT rank, company_name, market_value FROM companies WHERE industry = 'banking' ORDER BY sales DESC, profits DESC;",
            "SELECT Rank, Company, Market_Value FROM company WHERE Main_Industry = 'Banking' ORDER BY Sales_billion, Profits_billion;"
        ],
        "rule_sql": [
            "SELECT Rank, Company, Market_Value FROM company WHERE Main_Industry = 'Banking' ORDER BY Sales_billion, Profits_billion;"
        ]
    },
    "1636": {
        "db_id": "wedding",
        "question": "How many female people are older than 30 in our record?",
        "ground_truth": "SELECT count(*) FROM people WHERE is_male  =  'F' AND age  >  30",
        "amends": [
            "Do use the column `is_male` instead of `gender` and test for value `'F'` instead of `'male'` in the WHERE filter, while keeping the `age > 30` condition unchanged. The amended query now correctly matches the intended logic by using the appropriate column name and value comparison for gender filtering."
        ],
        "rules": [
            "1) When the question mentions \"female\": use the exact literal value 'F' to represent female in the \"is_male\" column. 2) When filtering for age greater than 30: use the exact condition age > 30. 3) When counting people: use the \"is_male\" column with value 'F' and age > 30 condition to identify female people older than 30."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM people WHERE gender = 'male' AND age > 30;",
            "SELECT COUNT(*) FROM people WHERE Is_Male = 'F' AND Age > 30;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM people WHERE Is_Male = 'F' AND Age > 30"
        ]
    },
    "3250": {
        "db_id": "college_1",
        "question": "What is the total number of professors with a Ph.D. ?",
        "ground_truth": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.'",
        "amends": [
            "Do reference table `professor` instead of `professors` and use column `prof_high_degree` instead of `degree` for the filter condition. Do filter for value `'Ph.D.'` instead of `'PhD'` to match the correct degree format while maintaining the same aggregate `count(*)` function. The amended query now correctly counts professors with Ph.D. degrees from the appropriate table and column."
        ],
        "rules": [
            "1) When answering about \"total number of professors with a Ph.D.\": use table \"professor\" instead of \"professors\" and column \"prof_high_degree\" instead of \"degree\" for filtering. 2) When filtering for professors with Ph.D. degrees: use the exact literal value 'Ph.D.' instead of 'PhD' to match the correct degree format. 3) When counting professors: maintain the count(*) aggregate function to compute the total number of rows matching the condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM professors WHERE degree = 'PhD';",
            "SELECT COUNT(*) FROM PROFESSOR WHERE PROF_HIGH_DEGREE = 'Ph.D.'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM PROFESSOR WHERE PROF_HIGH_DEGREE = 'Ph.D.'"
        ]
    },
    "2155": {
        "db_id": "formula_1",
        "question": "What is the name and date of the most recent race?",
        "ground_truth": "SELECT name ,  date FROM races ORDER BY date DESC LIMIT 1",
        "amends": [
            "Do `ORDER BY date DESC` instead of `ORDER BY date ASC` to sort in descending order rather than ascending order, which changes the query to return the most recent race instead of the oldest race. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the \"most recent\" race: sort races by date in descending order to get the latest date first. 2) When ordering by date to find the most recent: use ORDER BY date DESC instead of ORDER BY date ASC. 3) When limiting to get only the most recent race: take only the first row after sorting by date in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, date FROM races ORDER BY date ASC LIMIT 1;",
            "SELECT name, date FROM races ORDER BY date DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT name, date FROM races ORDER BY date DESC LIMIT 1;"
        ]
    },
    "5378": {
        "db_id": "tracking_software_problems",
        "question": "For each product that has problems, find the number of problems reported after 1986-11-13 and the product id?",
        "ground_truth": "SELECT count(*) ,  T2.product_id FROM problems AS T1 JOIN product AS T2 ON T1.product_id = T2.product_id WHERE T1.date_problem_reported > \"1986-11-13\" GROUP BY T2.product_id",
        "amends": [
            "Do add `JOIN product AS T2` with `ON T1.product_id = T2.product_id` instead of querying only the problems table. Do change the date filter to use `T1.date_problem_reported` instead of `report_date`. Do select `T2.product_id` instead of `product_id` to ensure the join relationship is properly referenced. Do move the product_id column to the SELECT list after the aggregate function instead of placing it first. Do use the alias `T1` for the problems table instead of no alias. The amended query now correctly joins the product table to filter and count problems by product while using the proper date column and table references."
        ],
        "rules": [
            "1) When joining tables for product problems: combine rows from Problems as T1 and Product as T2 where T1.product_id = T2.product_id using an inner match. 2) When filtering by date after 1986-11-13: use T1.date_problem_reported > '1986-11-13' instead of report_date. 3) When selecting product identifier: use T2.product_id to reference the joined product table. 4) When counting problems per product: count using the canonical key T1.product_id and group by T2.product_id. 5) When ordering output columns: place the aggregate count before the product_id in the result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT product_id, COUNT(*) as problem_count \nFROM problems \nWHERE report_date > '1986-11-13' \nGROUP BY product_id",
            "SELECT COUNT(*) AS number_of_problems, T2.product_id\nFROM Problems AS T1\nJOIN Product AS T2 ON T1.product_id = T2.product_id\nWHERE T1.date_problem_reported > '1986-11-13'\nGROUP BY T2.product_id"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.product_id) AS problem_count, T2.product_id\nFROM Problems AS T1\nINNER JOIN Product AS T2 ON T1.product_id = T2.product_id\nWHERE T1.date_problem_reported > '1986-11-13'\nGROUP BY T2.product_id"
        ]
    },
    "3937": {
        "db_id": "hospital_1",
        "question": "Tell me the distinct block codes where some rooms are available.",
        "ground_truth": "SELECT DISTINCT blockcode FROM room WHERE unavailable  =  0",
        "amends": [
            "Do reference table `room` instead of `rooms` and column `blockcode` instead of `block_code`. Do filter on `unavailable = 0` instead of `available = 'some'` to correctly identify available rooms by checking for zero unavailability rather than an ambiguous string value. The amended query now matches RIGHT_SQL's behavior by properly identifying available rooms through appropriate column names and boolean logic."
        ],
        "rules": [
            "1) When the question mentions \"rooms\": use table \"room\" instead of \"rooms\". 2) When the question mentions \"block codes\": use column \"blockcode\" instead of \"block_code\". 3) When identifying available rooms: filter on \"unavailable = 0\" instead of using string value 'some' to correctly identify rooms with zero unavailability."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT block_code FROM rooms WHERE available = 'some'",
            "SELECT DISTINCT blockcode FROM room WHERE unavailable = 0;"
        ],
        "rule_sql": [
            "SELECT DISTINCT BlockCode FROM room WHERE unavailable = 0;"
        ]
    },
    "6208": {
        "db_id": "roller_coaster",
        "question": "What are the speeds of the longest roller coaster?",
        "ground_truth": "SELECT Speed FROM roller_coaster ORDER BY LENGTH DESC LIMIT 1",
        "amends": [
            "Do reference the table as `roller_coaster` instead of `roller_coasters` to match the correct table name. Do use column name `Speed` instead of `speed` to maintain proper column case sensitivity. The amended query now correctly references the intended table and column while preserving the same ORDER BY and LIMIT logic."
        ],
        "rules": [
            "1) When the question asks about roller coasters: use the exact table name \"roller_coaster\" instead of \"roller_coasters\". 2) When the question mentions \"speeds\": use the exact column name \"Speed\" with proper case sensitivity. 3) When finding the longest roller coaster: order by the \"length\" column in descending order and take the first result. 4) When outputting results: return the \"Speed\" value for the longest roller coaster."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT speed FROM roller_coasters ORDER BY length DESC LIMIT 1;",
            "SELECT Speed FROM roller_coaster ORDER BY Length DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Speed FROM roller_coaster ORDER BY Length DESC LIMIT 1;"
        ]
    },
    "5109": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "What are the distinct names of the products that cost more than the average?",
        "ground_truth": "SELECT DISTINCT Product_Name FROM PRODUCTS WHERE Product_Price  >  (SELECT avg(Product_Price) FROM PRODUCTS)",
        "amends": [
            "Do use `Product_Name` instead of `name` for the column selection. Do use `Product_Price` instead of `price` for both the WHERE filter and the subquery comparison. Do use `avg(Product_Price)` instead of `AVG(price)` in the subquery aggregate function. The amended query now correctly references the actual column names and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for distinct names of products: use the exact column token \"Product_Name\" from table Services. 2) When comparing product prices to the average: use the exact column token \"Product_Price\" for both the filter condition and the average calculation. 3) When calculating the average price: compute the average of \"Product_Price\" values from the Services table. 4) When filtering products that cost more than average: compare each product's \"Product_Price\" to the computed average of all \"Product_Price\" values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT name FROM products WHERE price > (SELECT AVG(price) FROM products);",
            "SELECT DISTINCT Product_Name FROM Products WHERE Product_Price > (SELECT AVG(Product_Price) FROM Products);"
        ],
        "rule_sql": [
            "SELECT DISTINCT Product_Name FROM Services WHERE Product_Price > (SELECT AVG(Product_Price) FROM Services);"
        ]
    },
    "1046": {
        "db_id": "phone_1",
        "question": "How many models do not have the wifi function?",
        "ground_truth": "SELECT count(*) FROM chip_model WHERE wifi  =  'No'",
        "amends": [
            "Do reference table `chip_model` instead of `models` in the FROM clause. Do filter on condition `wifi = 'No'` instead of `wifi = 'yes'` in the WHERE clause. The amended query now correctly counts records from the chip_model table where wifi is set to 'No' instead of counting from the wrong table with incorrect filter criteria."
        ],
        "rules": [
            "1) When answering about \"models without wifi function\": use table \"chip_model\" instead of \"models\" in the FROM clause. 2) When filtering for models that do not have wifi function: use condition wifi = 'No' instead of wifi = 'yes' in the WHERE clause. 3) When counting models: compute the count of records from the chip_model table where wifi is set to 'No'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM models WHERE wifi = 'yes';",
            "SELECT COUNT(*) FROM chip_model WHERE WiFi = 'No';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM chip_model WHERE wifi = 'No';"
        ]
    },
    "5399": {
        "db_id": "tracking_software_problems",
        "question": "Which products have problems reported by both the staff named Lacey Bosco and the staff named Kenton Champlin?",
        "ground_truth": "SELECT T2.product_name FROM problems AS T1 JOIN product AS T2 JOIN staff AS T3 ON T1.product_id = T2.product_id AND T1.reported_by_staff_id = T3.staff_id WHERE T3.staff_first_name = \"Lacey\" AND T3.staff_last_name = \"Bosco\" INTERSECT SELECT T2.product_name FROM problems AS T1 JOIN product AS T2 JOIN staff AS T3 ON T1.product_id = T2.product_id AND T1.reported_by_staff_id = T3.staff_id WHERE T3.staff_first_name = \"Kenton\" AND T3.staff_last_name = \"Champlin\"",
        "amends": [
            "Do use `INTERSECT` with two separate queries instead of multiple joins on the same tables. Do reference `product` table instead of `products` and use proper table aliases `T1`, `T2`, `T3` instead of `p`, `pr1`, `s1`. Do join on `T1.product_id = T2.product_id AND T1.reported_by_staff_id = T3.staff_id` instead of separate joins on `product_id` and `staff_id`. Do filter by both `staff_first_name` and `staff_last_name` columns with separate conditions for \"Lacey Bosco\" and \"Kenton Champlin\" instead of single `staff_name` column comparisons. Do remove the duplicate table joins and instead use two separate queries that find products reported by each staff member individually, then intersect the results. The amended query now correctly identifies products that have been reported by both specified staff members using their first and last names separately.",
            "Do select only `product_name` instead of both `product_id` and `product_name`. Do use table aliases `T1` for `problems`, `T2` for `product`, and `T3` for `staff` instead of `T1` for `Product`, `T2` for `Problems`, and `T3` for `Staff`. Do combine join conditions with `AND` in a single `ON` clause instead of separate `JOIN` statements. Do use double quotes for string literals instead of single quotes. The amended query now correctly finds products reported by both Lacey Bosco and Kenton Champlin."
        ],
        "rules": [
            "1) When the question asks for products reported by multiple specific staff members: use INTERSECT between separate queries for each staff member instead of multiple joins on the same tables. 2) When referencing the product table: use exact identifier \"product\" instead of \"products\" and assign alias T1. 3) When joining tables: use proper aliases T2 for problems table and T3 for staff table, and link with T1.product_id = T2.product_id AND T2.reported_by_staff_id = T3.staff_id. 4) When filtering by staff name \"Lacey Bosco\": use separate conditions T3.staff_first_name = 'Lacey' AND T3.staff_last_name = 'Bosco'. 5) When filtering by staff name \"Kenton Champlin\": use separate conditions T3.staff_first_name = 'Kenton' AND T3.staff_last_name = 'Champlin'. 6) When selecting output: return product_name from T1 as the final result.",
            "1) When selecting output columns for products with problems: include only \"product_name\" from table T2, not both \"product_id\" and \"product_name\". 2) When assigning table aliases: use T1 for \"problems\" table, T2 for \"product\" table, and T3 for \"staff\" table. 3) When joining multiple tables: combine all join conditions with AND in a single ON clause instead of separate JOIN statements. 4) When using string literals for staff names: use double quotes instead of single quotes, exactly as \"Lacey\" and \"Bosco\" for one staff member and \"Kenton\" and \"Champlin\" for the other. 5) When finding products reported by both specific staff members: use INTERSECT to find the common products between those reported by staff named \"Lacey Bosco\" and those reported by staff named \"Kenton Champlin\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.product_name\nFROM products p\nJOIN problems pr1 ON p.product_id = pr1.product_id\nJOIN staff s1 ON pr1.staff_id = s1.staff_id\nJOIN problems pr2 ON p.product_id = pr2.product_id\nJOIN staff s2 ON pr2.staff_id = s2.staff_id\nWHERE s1.staff_name = 'Lacey Bosco' AND s2.staff_name = 'Kenton Champlin';",
            "SELECT T1.product_id, T1.product_name\nFROM Product T1\nJOIN Problems T2 ON T1.product_id = T2.product_id\nJOIN Staff T3 ON T2.reported_by_staff_id = T3.staff_id\nWHERE T3.staff_first_name = 'Lacey' AND T3.staff_last_name = 'Bosco'\n\nINTERSECT\n\nSELECT T1.product_id, T1.product_name\nFROM Product T1\nJOIN Problems T2 ON T1.product_id = T2.product_id\nJOIN Staff T3 ON T2.reported_by_staff_id = T3.staff_id\nWHERE T3.staff_first_name = 'Kenton' AND T3.staff_last_name = 'Champlin'",
            "SELECT product_name\nFROM Product T2\nJOIN Problems T1 ON T1.product_id = T2.product_id\nJOIN Staff T3 ON T1.reported_by_staff_id = T3.staff_id\nWHERE T3.staff_first_name = \"Lacey\" AND T3.staff_last_name = \"Bosco\"\nINTERSECT\nSELECT product_name\nFROM Product T2\nJOIN Problems T1 ON T1.product_id = T2.product_id\nJOIN Staff T3 ON T1.reported_by_staff_id = T3.staff_id\nWHERE T3.staff_first_name = \"Kenton\" AND T3.staff_last_name = \"Champlin\""
        ],
        "rule_sql": [
            "SELECT T2.product_name\nFROM Problems T1\nJOIN Product T2 ON T1.product_id = T2.product_id\nJOIN Staff T3 ON T1.reported_by_staff_id = T3.staff_id\nWHERE T3.staff_first_name = \"Lacey\" AND T3.staff_last_name = \"Bosco\"\nINTERSECT\nSELECT T2.product_name\nFROM Problems T1\nJOIN Product T2 ON T1.product_id = T2.product_id\nJOIN Staff T3 ON T1.reported_by_staff_id = T3.staff_id\nWHERE T3.staff_first_name = \"Kenton\" AND T3.staff_last_name = \"Champlin\""
        ]
    },
    "2989": {
        "db_id": "sakila_1",
        "question": "What was the date of the earliest payment?",
        "ground_truth": "SELECT payment_date FROM payment ORDER BY payment_date ASC LIMIT 1",
        "amends": [
            "Do select the raw `payment_date` column instead of using `MAX(payment_date)` aggregation. Do add `ORDER BY payment_date ASC` to sort chronologically instead of omitting ordering. Do add `LIMIT 1` to return only the earliest record instead of returning a single aggregated maximum value. Do reference table `payment` instead of `payments` for correct table name. The amended query now correctly identifies the earliest payment date by sorting and limiting rather than finding the maximum value, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for the earliest date of an entity: select the raw date column instead of using MAX aggregation. 2) When identifying the earliest record: sort by the date column in ascending order and limit to 1 result. 3) When referencing table names: use the exact table name \"payment\" instead of variations like \"payments\". 4) When answering about payment dates: use the exact column name \"payment_date\" as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(payment_date) FROM payments;",
            "SELECT payment_date FROM payment ORDER BY payment_date ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT payment_date FROM payment ORDER BY payment_date ASC LIMIT 1;"
        ]
    },
    "1651": {
        "db_id": "theme_gallery",
        "question": "Show all artist name, age, and country ordered by the yeared they joined.",
        "ground_truth": "SELECT name ,  age ,  country FROM artist ORDER BY Year_Join",
        "amends": [
            "Do reference table `artist` instead of `artists` in the FROM clause. Do change the ORDER BY clause to use `Year_Join` instead of `name`."
        ],
        "rules": [
            "1) When the question asks about artist information: use table \"artist\" instead of \"artists\" as the data source. 2) When ordering results by the year they joined: use column \"Year_Join\" for ordering instead of \"name\". 3) When showing artist details: include columns \"name\", \"age\", and \"country\" in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, age, country FROM artists ORDER BY name;",
            "SELECT Name, Age, Country FROM artist ORDER BY Year_Join;"
        ],
        "rule_sql": [
            "SELECT name, age, country FROM artist ORDER BY Year_Join;"
        ]
    },
    "506": {
        "db_id": "allergy_1",
        "question": "What are the students ids of students who have more than one allergy?",
        "ground_truth": "SELECT StuID FROM Has_allergy GROUP BY StuID HAVING count(*)  >=  2",
        "amends": [
            "Do select `StuID` instead of `student_id` and use `GROUP BY` with `HAVING count(*) >= 2` instead of filtering `WHERE allergy_count > 1`. Do source from `Has_allergy` table instead of `students` table and aggregate with `GROUP BY StuID` instead of direct column filtering. Do use `HAVING` clause with count aggregation instead of simple WHERE condition on a count column. The amended query now correctly identifies students with multiple allergies by counting actual allergy records rather than relying on a potentially incorrect pre-counted column."
        ],
        "rules": [
            "1) When answering about \"students who have more than one allergy\": use the \"Has_allergy\" table instead of the \"students\" table. 2) When counting allergies per student: group by \"StuID\" and count the number of records for each student. 3) When filtering for students with multiple allergies: use a having condition that requires count(*) >= 2 instead of filtering on a pre-counted column. 4) When selecting student identifiers: use the exact column name \"StuID\" instead of \"student_id\". 5) When organizing results: output only the \"StuID\" column for students meeting the multiple allergy condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id FROM students WHERE allergy_count > 1;",
            "SELECT StuID FROM Has_Allergy GROUP BY StuID HAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT StuID FROM Has_Allergy GROUP BY StuID HAVING COUNT(*) >= 2"
        ]
    },
    "673": {
        "db_id": "customers_card_transactions",
        "question": "What is the first name, last name, and phone of the customer with account name 162?",
        "ground_truth": "SELECT T2.customer_first_name ,  T2.customer_last_name ,  T2.customer_phone FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  \"162\"",
        "amends": [
            "Do select `T2.customer_first_name`, `T2.customer_last_name`, and `T2.customer_phone` instead of `first_name`, `last_name`, and `phone`. Do join `Accounts AS T1` with `Customers AS T2` on `T1.customer_id = T2.customer_id` instead of querying only the `customers` table. Do filter on `T1.account_name = \"162\"` instead of `account_name = '162'` in the customers table. Do use double quotes around the string literal instead of single quotes. The amended query now correctly joins the Accounts and Customers tables to retrieve customer information based on account name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about customer information for a specific account name: make sure the output order: customer_first_name, customer_last_name, customer_phone. 2) When the question mentions \"first name\", \"last name\", and \"phone\": these actually mean \"customer_first_name\", \"customer_last_name\", and \"customer_phone\" in the Customers table. 3) When combining Accounts (T1) and Customers (T2) tables: link rows where T1.customer_id = T2.customer_id and keep only matching pairs (inner match). 4) When filtering for account name \"162\": use T1.account_name = \"162\" with double quotes around the literal value. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for the literal value \"162\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name, phone FROM customers WHERE account_name = '162';",
            "SELECT T2.customer_first_name, T2.customer_last_name, T2.customer_phone FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id = T2.customer_id WHERE T1.account_name = \"162\""
        ],
        "rule_sql": [
            "SELECT c.customer_first_name, c.customer_last_name, c.customer_phone FROM Customers c INNER JOIN Accounts a ON c.customer_id = a.customer_id WHERE a.account_name = \"162\""
        ]
    },
    "180": {
        "db_id": "bike_1",
        "question": "What are the ids and names of all start stations that were the beginning of at least 200 trips?",
        "ground_truth": "SELECT start_station_id ,  start_station_name FROM trip GROUP BY start_station_name HAVING COUNT(*)  >=  200",
        "amends": [
            "Do select `start_station_id` and `start_station_name` instead of `station_id` and `name`. Do use `FROM trip` instead of `FROM stations`. Do add `GROUP BY start_station_name` instead of omitting grouping. Do move the count filter to `HAVING COUNT(*) >= 200` instead of using `WHERE trip_count >= 200`. The amended query now correctly aggregates trip data by station and filters based on actual trip counts rather than relying on a pre-calculated trip_count column."
        ],
        "rules": [
            "1) When answering about \"start stations that were the beginning of at least 200 trips\": use \"start_station_id\" and \"start_station_name\" from the trip table instead of \"station_id\" and \"name\" from the stations table. 2) When counting trips per station: group by \"start_station_name\" and count all rows using COUNT(*) to determine the number of trips starting at each station. 3) When filtering for stations with at least 200 trips: apply the condition COUNT(*) >= 200 in a HAVING clause after grouping, not in a WHERE clause before grouping. 4) When selecting data about trip start stations: use FROM trip instead of FROM stations to access the actual trip data."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT station_id, name FROM stations WHERE trip_count >= 200;",
            "SELECT start_station_id, start_station_name FROM trip GROUP BY start_station_name HAVING COUNT(*) >= 200;"
        ],
        "rule_sql": [
            "SELECT start_station_id, start_station_name FROM trip GROUP BY start_station_name HAVING COUNT(*) >= 200;"
        ]
    },
    "3830": {
        "db_id": "e_learning",
        "question": "What are the completion dates of all the tests that have result \"Fail\"?",
        "ground_truth": "SELECT T1.date_of_completion FROM Student_Course_Enrolment AS T1 JOIN Student_Tests_Taken AS T2 ON T1.registration_id  =  T2.registration_id WHERE T2.test_result  =  \"Fail\"",
        "amends": [
            "Do select `T1.date_of_completion` instead of `completion_date`. Do use `FROM Student_Course_Enrolment AS T1 JOIN Student_Tests_Taken AS T2` instead of `FROM tests`. Do add join condition `ON T1.registration_id = T2.registration_id` instead of omitting it. Do filter with `T2.test_result = \"Fail\"` instead of `result = 'Pass'`. The amended query now correctly joins enrollment and test tables and filters for failed test results instead of passing ones."
        ],
        "rules": [
            "1) When the question asks for \"completion dates\": use the exact column token \"T1.date_of_completion\" instead of \"completion_date\". 2) When answering about tests with results: combine tables \"Student_Course_Enrolment AS T1\" and \"Student_Tests_Taken AS T2\" using inner match where \"T1.registration_id = T2.registration_id\". 3) When filtering for tests with result \"Fail\": use the exact condition \"T2.test_result = \\\"Fail\\\"\" with double quotes around the literal value. 4) When the question mentions \"tests that have result\": recognize that test information is stored in \"Student_Tests_Taken AS T2\" table with the result column \"test_result\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT completion_date FROM tests WHERE result = 'Pass';",
            "SELECT T1.date_of_completion \nFROM Student_Course_Enrolment AS T1 \nJOIN Student_Tests_Taken AS T2 ON T1.registration_id = T2.registration_id \nWHERE T2.test_result = \"Fail\""
        ],
        "rule_sql": [
            "SELECT T1.date_of_completion \nFROM Student_Course_Enrolment AS T1\nINNER JOIN Student_Tests_Taken AS T2 ON T1.registration_id = T2.registration_id\nWHERE T2.test_result = \"Fail\""
        ]
    },
    "6259": {
        "db_id": "ship_1",
        "question": "What are the names of ships that have more than one captain?",
        "ground_truth": "SELECT t1.name FROM ship AS t1 JOIN captain AS t2 ON t1.ship_id  =  t2.ship_id GROUP BY t2.ship_id HAVING count(*)  >  1",
        "amends": [
            "Do select `t1.name` with table alias instead of `name` without qualification. Do add `JOIN captain AS t2` instead of omitting the captain table entirely. Do use join condition `ON t1.ship_id = t2.ship_id` instead of filtering on `captain_id > 1`. Do add `GROUP BY t2.ship_id` and `HAVING count(*) > 1` instead of the simple WHERE filter, to count captains per ship rather than filtering by captain ID. The amended query now correctly identifies ships with multiple captains by joining the tables and using aggregation with a HAVING clause instead of the incorrect single-table filter."
        ],
        "rules": [
            "1) When answering about \"names of ships that have more than one captain\": make sure the output order: t1.name. 2) When the question mentions \"ships\": \"ships\" actually means \"t1.name in schema\". 3) When combining ships and captain tables for shared entities: link rows where t1.ship_id = t2.ship_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"more than one captain\" per ship: organize results by t2.ship_id and compute count(*) per group, then keep only groups where count(*) > 1."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM ships WHERE captain_id > 1;",
            "SELECT t1.Name FROM Ship AS t1 JOIN captain AS t2 ON t1.Ship_ID = t2.Ship_ID GROUP BY t2.Ship_ID HAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT t1.Name \nFROM Ship t1\nINNER JOIN captain t2 ON t1.Ship_ID = t2.Ship_ID\nGROUP BY t1.Ship_ID, t1.Name\nHAVING COUNT(*) > 1\nORDER BY t1.Name"
        ]
    },
    "1003": {
        "db_id": "university_basketball",
        "question": "How many schools do not participate in the basketball match?",
        "ground_truth": "SELECT count(*) FROM university WHERE school_id NOT IN (SELECT school_id FROM basketball_match)",
        "amends": [
            "Do query the `university` table instead of the `schools` table. Do use a subquery with `NOT IN` to filter by `school_id` values that exist in the `basketball_match` table instead of a direct inequality filter on a `sport` column. Do remove the direct column filter `sport != 'basketball'` instead of keeping it, as the logic now correctly identifies schools without basketball matches through the subquery correlation. The amended query now matches RIGHT_SQL's behavior by properly excluding schools that have basketball matches through a relational approach rather than a simple column value comparison."
        ],
        "rules": [
            "1) When answering about schools not participating in basketball matches: query the \"university\" table instead of the \"schools\" table. 2) When filtering for schools without basketball matches: use a subquery with NOT IN to filter by \"school_id\" values that exist in the \"basketball_match\" table instead of a direct inequality filter. 3) When identifying schools without basketball participation: remove direct column filters like sport != 'basketball' and instead use relational correlation through the subquery approach."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM schools WHERE sport != 'basketball';",
            "SELECT COUNT(*) \nFROM university \nWHERE School_ID NOT IN (SELECT DISTINCT School_ID FROM basketball_match)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM university WHERE School_ID NOT IN (SELECT School_ID FROM basketball_match)"
        ]
    },
    "6501": {
        "db_id": "scientist_1",
        "question": "Find the SSN and name of scientists who are assigned to the project with the longest hours.",
        "ground_truth": "SELECT T3.ssn ,  T3.name FROM assignedto AS T1 JOIN projects AS T2 ON T1.project  =  T2.code JOIN scientists AS T3 ON T1.scientist  =  T3.SSN WHERE T2.hours  =  (SELECT max(hours) FROM projects)",
        "amends": [
            "Do use explicit joins with `assignedto AS T1`, `projects AS T2`, and `scientists AS T3` instead of querying `Scientists` directly with a subquery. Do join `T1` to `T2` on `T1.project = T2.code` and to `T3` on `T1.scientist = T3.SSN` instead of using a correlated subquery for `ProjectID`. Do filter with `T2.hours = (SELECT max(hours) FROM projects)` instead of `ORDER BY Hours DESC LIMIT 1` to correctly find the maximum hours. Do select `T3.ssn` and `T3.name` instead of `SSN` and `Name` with proper table qualification. The amended query now correctly identifies scientists assigned to the project with maximum hours through proper join relationships."
        ],
        "rules": [
            "1) When answering about scientists assigned to projects: use explicit joins with assignedto AS T1, projects AS T2, and scientists AS T3 instead of direct table queries. 2) When combining assignedto and projects tables: link rows where T1.project = T2.code and keep only matching pairs (inner match). 3) When combining assignedto and scientists tables: link rows where T1.scientist = T3.SSN and keep only matching pairs (inner match). 4) When finding the project with maximum hours: filter with T2.hours = (SELECT max(hours) FROM projects) instead of ordering and limiting. 5) When selecting scientist information: use T3.ssn and T3.name with proper table qualification instead of unqualified SSN and Name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SSN, Name FROM Scientists WHERE ProjectID = (SELECT ProjectID FROM Projects ORDER BY Hours DESC LIMIT 1);",
            "SELECT T3.SSN, T3.Name\nFROM assignedto AS T1\nJOIN projects AS T2 ON T1.Project = T2.Code\nJOIN scientists AS T3 ON T1.Scientist = T3.SSN\nWHERE T2.Hours = (SELECT MAX(Hours) FROM projects)"
        ],
        "rule_sql": [
            "SELECT T3.SSN, T3.Name\nFROM AssignedTo AS T1\nINNER JOIN Projects AS T2 ON T1.Project = T2.Code\nINNER JOIN Scientists AS T3 ON T1.Scientist = T3.SSN\nWHERE T2.Hours = (SELECT MAX(Hours) FROM Projects)"
        ]
    },
    "4875": {
        "db_id": "school_player",
        "question": "Which team has the oldest player?",
        "ground_truth": "SELECT Team FROM player ORDER BY Age DESC LIMIT 1",
        "amends": [
            "Do select `Team` instead of `team_name` from the table. Do reference table `player` instead of `players`. Do order by `Age DESC` instead of `age ASC` while maintaining the limit of 1 row. The amended query now correctly retrieves the team from the player table ordered by age in descending order with a single row limit."
        ],
        "rules": [
            "1) When the question asks about \"team\" in the context of players: use the exact column token \"Team\" from table \"player\" instead of \"team_name\". 2) When ordering by player age to find the oldest: sort by column \"Age\" in descending order (DESC) instead of ascending order (ASC). 3) When limiting results to find a single extreme value: maintain a limit of 1 row to return only the top result. 4) When referencing the player table: use the exact table name \"player\" instead of \"players\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT team_name FROM players ORDER BY age ASC LIMIT 1;",
            "SELECT Team FROM player ORDER BY Age DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Team FROM player ORDER BY Age DESC LIMIT 1;"
        ]
    },
    "2609": {
        "db_id": "inn_1",
        "question": "How many rooms have a king bed?",
        "ground_truth": "SELECT count(*) FROM Rooms WHERE bedType  =  \"King\";",
        "amends": [
            "Do reference the table as `Rooms` instead of `rooms` to match the correct case sensitivity. Do filter for `bedType = \"King\"` instead of `bed_type = 'queen'` to use the correct column name and value. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency with the right query's formatting, though this is a cosmetic difference that doesn't affect functionality. The amended query now correctly counts rooms with king-sized beds instead of queen-sized beds."
        ],
        "rules": [
            "1) When referencing the table for rooms: use the exact identifier \"Rooms\" with capital R to match case sensitivity. 2) When filtering for bed type: use the exact column name \"bedType\" and the exact literal value \"King\" to find king-sized beds. 3) When counting rooms: use the canonical counting method with count(*) to get the total number of rooms matching the criteria."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM rooms WHERE bed_type = 'queen';",
            "SELECT count(*) FROM Rooms WHERE bedType = \"King\";"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Rooms WHERE bedType = 'King';"
        ]
    },
    "3454": {
        "db_id": "hr_1",
        "question": "What is the average salary of employees who have a commission percentage that is not null?",
        "ground_truth": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != \"null\" GROUP BY department_id",
        "amends": [
            "Do add `department_id` to the SELECT list instead of omitting it. Do change the WHERE filter to `commission_pct != \"null\"` instead of `commission_pct IS NULL` to properly exclude null commission values. Do add `GROUP BY department_id` instead of omitting it to aggregate salaries by department rather than calculating a single overall average. The amended query now correctly groups by department and excludes null commission values, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for average salary of employees with non-null commission percentage: compute the average of the \"salary\" column. 2) When filtering for employees with non-null commission percentage: use the condition \"commission_pct != \\\"null\\\"\" instead of checking for NULL values. 3) When the question implies grouping by department: include \"department_id\" in the output and group results by \"department_id\" to compute averages per department. 4) When producing output columns: maintain the order \"department_id\" followed by the average salary calculation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(salary) FROM employees WHERE commission_pct IS NULL;",
            "SELECT department_id, AVG(salary) AS average_salary FROM employees WHERE commission_pct IS NOT NULL GROUP BY department_id"
        ],
        "rule_sql": [
            "SELECT department_id, AVG(salary) AS average_salary FROM employees WHERE commission_pct != \"null\" GROUP BY department_id"
        ]
    },
    "4598": {
        "db_id": "entertainment_awards",
        "question": "How many artworks are there?",
        "ground_truth": "SELECT count(*) FROM artwork",
        "amends": [
            "Do query the `artwork` table instead of the `artists` table, changing the data source entirely while maintaining the same aggregate function structure with `COUNT(*)`."
        ],
        "rules": [
            "1) When answering about \"how many artworks\": query the \"artwork\" table instead of the \"artists\" table. 2) When counting artworks: use COUNT(*) to count all rows in the \"artwork\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM artists;",
            "SELECT COUNT(*) FROM artwork;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM artwork;"
        ]
    },
    "162": {
        "db_id": "bike_1",
        "question": "What is the installation date for each ending station on all the trips?",
        "ground_truth": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id",
        "amends": [
            "Do select `T1.id` and `T2.installation_date` instead of `ending_station` and `installation_date`. Do join `station AS T2` instead of omitting it. Do use `ON T1.end_station_id = T2.id` instead of grouping by `ending_station`. Do remove `GROUP BY` instead of keeping it. The amended query now correctly retrieves station installation dates by joining the trip and station tables on the proper foreign key relationship instead of attempting to group by a column that may not exist in the trips table."
        ],
        "rules": [
            "1) When answering about \"installation date for each ending station\": make sure the output order: T1.id, T2.installation_date. 2) When the question mentions \"ending station\": \"ending station\" actually means \"T1.id in schema\" from the trips table. 3) When combining trips table as T1 and station table as T2: link rows where T1.end_station_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for installation date: use T2.installation_date from the station table instead of any other column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT ending_station, installation_date FROM trips GROUP BY ending_station;",
            "SELECT T1.id, T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id = T2.id"
        ],
        "rule_sql": [
            "SELECT T1.id, T2.installation_date\nFROM trip T1\nINNER JOIN station T2 ON T1.end_station_id = T2.id\nORDER BY T1.id;"
        ]
    },
    "5160": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "What is the most frequent status of bookings?",
        "ground_truth": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `Status_Code` instead of `status` and remove the alias `count` instead of keeping it. Do group by `Status_Code` instead of `status`. Do order by `count(*) DESC` instead of `count ASC` to get the most frequent status rather than the least frequent. The amended query now correctly identifies the most common booking status code by counting occurrences in descending order.",
            "Do remove `COUNT(*) AS count` from the SELECT list instead of including it, and do move the aggregate function `count(*)` to the ORDER BY clause instead of referencing the alias `count`. Do maintain `GROUP BY Status_Code` and `LIMIT 1` as they correctly identify the most frequent status code by count while avoiding unnecessary column output."
        ],
        "rules": [
            "1) When the question asks for \"status of bookings\": use the exact column token \"Status_Code\" from the schema instead of \"status\". 2) When counting occurrences to find the most frequent status: count all rows using count(*) and do not assign an alias to the count. 3) When grouping by status: group by the exact column token \"Status_Code\". 4) When finding the most frequent status: order the results by the count in descending order to get the highest count first. 5) When the question asks for the single most frequent status: return only the top result (limit 1).",
            "1) When answering about \"most frequent status of bookings\": make sure the output order: Status_Code only. 2) When counting entities: use count(*) to compute the number of rows. 3) When the question asks for \"most frequent\": rank rows by count(*) in descending order and keep the first 1 row. 4) When grouping by status: organize results by Status_Code and compute count(*) per group. 5) When producing output: do not include the count column in the final results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT status, COUNT(*) as count FROM bookings GROUP BY status ORDER BY count ASC LIMIT 1;",
            "SELECT Status_Code, COUNT(*) AS count FROM Bookings GROUP BY Status_Code ORDER BY count DESC LIMIT 1;",
            "SELECT Status_Code FROM Bookings GROUP BY Status_Code ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Status_Code FROM Bookings GROUP BY Status_Code ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "3671": {
        "db_id": "baseball_1",
        "question": "What is the number of wins the team Boston Red Stockings got in the postseasons each year in history?",
        "ground_truth": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' GROUP BY T1.year",
        "amends": [
            "Do use `count(*)` without an alias instead of `COUNT(*) as wins`. Do join `postseason AS T1` with `team AS T2` on `T1.team_id_winner = T2.team_id_br` instead of querying `postseason_games` directly. Do filter on `T2.name = 'Boston Red Stockings'` instead of `team = 'Boston Red Stockings' AND result = 'win'`. Do group by `T1.year` instead of `year`. Do omit the `ORDER BY` clause instead of including `ORDER BY year`. The amended query now correctly counts postseason wins by joining the appropriate tables and filtering on team name rather than relying on deprecated column names and result values.",
            "Do place `count(*)` before `T1.year` in the SELECT list instead of having `T1.year` first. Do add a space after the comma in `count(*) , T1.year` instead of omitting it. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"number of wins the team Boston Red Stockings got in the postseasons each year\": make sure the output order: year, count(*) 2) When the question mentions \"Boston Red Stockings\": \"Boston Red Stockings\" actually means T2.name = 'Boston Red Stockings' in schema 3) When combining T1 and T2 for shared entities: link rows where T1.team_id_winner = T2.team_id_br exactly as shown in the amends; keep only matching pairs (inner match) 4) When the question asks for \"number of wins\": compute the count of rows using count(*) 5) When the question says \"each year\": organize results by T1.year and compute requested aggregates per group 6) When producing output: do not include an ORDER BY clause",
            "1) When answering about \"number of wins the team Boston Red Stockings got in the postseasons each year\": make sure the output order: count(*) first, then T1.year. 2) When the question mentions \"Boston Red Stockings\": \"Boston Red Stockings\" actually means T2.name = 'Boston Red Stockings' in schema. 3) When combining postseason table T1 and team table T2: link rows where T1.team_id_winner = T2.team_id_br and keep only matching pairs (inner match). 4) When the question asks for \"number of wins per year\": organize results by T1.year and compute count of wins per group using the canonical key."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, COUNT(*) as wins FROM postseason_games WHERE team = 'Boston Red Stockings' AND result = 'win' GROUP BY year ORDER BY year;",
            "SELECT T1.year, COUNT(*) \nFROM postseason AS T1 \nJOIN team AS T2 ON T1.team_id_winner = T2.team_id_br \nWHERE T2.name = 'Boston Red Stockings' \nGROUP BY T1.year",
            "SELECT count(*) , T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' GROUP BY T1.year"
        ],
        "rule_sql": [
            "SELECT T1.year, COUNT(*) \nFROM postseason T1\nINNER JOIN team T2 ON T1.team_id_winner = T2.team_id_br\nWHERE T2.name = 'Boston Red Stockings'\nGROUP BY T1.year"
        ]
    },
    "3681": {
        "db_id": "baseball_1",
        "question": "List the 3 highest salaries of the players in 2001?",
        "ground_truth": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;",
        "amends": [
            "Do query the `salary` table instead of the `players` table to access the correct data source containing salary information. Do use the `YEAR` column from the salary table instead of the non-existent `year` column in the players table. The amended query now correctly retrieves salaries from the appropriate salary table for the year 2001, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"highest salaries of the players in 2001\": make sure the output order: salary from highest to lowest and keep the first 3 rows. 2) When the question mentions \"salaries\": \"salaries\" actually means \"salary\" column from the \"salary\" table. 3) When the question mentions \"2001\": \"2001\" actually means \"YEAR\" column with value 2001 from the \"salary\" table. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table and column names."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT salary FROM players WHERE year = 2001 ORDER BY salary DESC LIMIT 3;",
            "SELECT salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3"
        ]
    },
    "1950": {
        "db_id": "cinema",
        "question": "What is total number of show times per dat for each cinema?",
        "ground_truth": "SELECT T2.name ,  sum(T1.show_times_per_day) FROM schedule AS T1 JOIN cinema AS T2 ON T1.cinema_id  =  T2.cinema_id GROUP BY T1.cinema_id",
        "amends": [
            "Do select `T2.name` and `sum(T1.show_times_per_day)` instead of `cinema_id`, `date`, and `COUNT(*) as total_shows`. Do join `cinema AS T2` on `T1.cinema_id = T2.cinema_id` instead of querying only the `showtimes` table. Do use `sum` aggregation on `show_times_per_day` instead of `COUNT(*)` on all rows. Do group by `T1.cinema_id` instead of grouping by both `cinema_id` and `date`. Do remove the `date` column from both selection and grouping instead of including it. The amended query now correctly aggregates show times by cinema with proper table joining and appropriate aggregation logic."
        ],
        "rules": [
            "1) When answering about \"total number of show times per day for each cinema\": make sure the output order: T2.name, sum(T1.show_times_per_day). 2) When the question mentions \"cinema\": \"cinema\" actually means \"T2.name in schema\". 3) When the question mentions \"show times per day\": \"show times per day\" actually means \"T1.show_times_per_day in schema\". 4) When combining T1 and T2 for shared entities: link rows where T1.cinema_id = T2.cinema_id; keep only matching pairs (inner match). 5) When the question says \"per cinema\"/\"for each cinema\": organize results by T1.cinema_id and compute sum(T1.show_times_per_day) per group. 6) When producing output: do not include date column in selection or grouping."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT cinema_id, date, COUNT(*) as total_shows FROM showtimes GROUP BY cinema_id",
            "SELECT T2.Name, SUM(T1.Show_times_per_day) AS total_show_times_per_day FROM schedule AS T1 JOIN cinema AS T2 ON T1.Cinema_ID = T2.Cinema_ID GROUP BY T1.Cinema_ID"
        ],
        "rule_sql": [
            "SELECT c.Name, SUM(s.Show_times_per_day) \nFROM schedule s \nJOIN cinema c ON s.Cinema_ID = c.Cinema_ID \nGROUP BY s.Cinema_ID \nORDER BY c.Name, SUM(s.Show_times_per_day)"
        ]
    },
    "91": {
        "db_id": "student_assessment",
        "question": "Find distinct cities of addresses of people?",
        "ground_truth": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id",
        "amends": [
            "Do add `DISTINCT` instead of omitting it, and do specify `T1.city` instead of just `city`. Do add `JOIN people_addresses AS T2` instead of omitting this table entirely, and do use `ON T1.address_id = T2.address_id` instead of grouping by `person_id`. Do remove `GROUP BY person_id` instead of keeping it. The amended query now correctly retrieves distinct cities by joining the addresses and people_addresses tables on their address_id relationship instead of incorrectly grouping by person_id without proper aggregation."
        ],
        "rules": [
            "1) When the question asks for \"distinct cities\": use DISTINCT on the exact column token \"T1.city\" to return unique city values. 2) When combining Addresses (T1) and People_Addresses (T2) tables: link rows where \"T1.address_id = T2.address_id\" and keep only matching pairs (inner match). 3) When the question asks about \"cities of addresses of people\": join Addresses and People_Addresses tables to connect people to their addresses before retrieving city information. 4) When grouping is incorrectly used for distinct values: remove GROUP BY clauses and use DISTINCT instead to get unique values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city FROM addresses GROUP BY person_id",
            "SELECT DISTINCT T1.city FROM Addresses AS T1 JOIN People_Addresses AS T2 ON T1.address_id = T2.address_id"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.city FROM Addresses T1 INNER JOIN People_Addresses T2 ON T1.address_id = T2.address_id"
        ]
    },
    "6880": {
        "db_id": "flight_4",
        "question": "What is the name of the airline with the most routes?",
        "ground_truth": "SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `routes` table with `JOIN` on `T1.alid = T2.alid` instead of querying only the `airlines` table. Do add `GROUP BY T1.name` and aggregate with `count(*)` instead of using a non-existent `route_count` column. Do change the ORDER BY to `count(*) DESC` instead of the invalid `route_count DESC`. Do include table alias `T1` in `SELECT T1.name` instead of just `name`. The amended query now correctly counts routes per airline and returns the airline with the most routes, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"the airline with the most routes\": make sure the output order: T1.name. 2) When the question mentions \"routes\": \"routes\" actually means \"count of routes in schema\" using the routes table. 3) When combining T1 (airlines) and T2 (routes) for shared entities: link rows where T1.alid = T2.alid exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"count of routes\": compute the number of rows using the canonical key token for routes (count(*)). 5) When the question asks for \"the most routes\": rank rows by count(*) in descending direction and keep the first 1 row. 6) When the question says \"per airline\"/\"by airline\": organize results by T1.name and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM airlines ORDER BY route_count DESC LIMIT 1;",
            "SELECT T1.name\nFROM airlines T1\nJOIN routes T2 ON T1.alid = T2.alid\nGROUP BY T1.name\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT a.name\nFROM airlines a\nJOIN routes r ON a.alid = r.alid\nGROUP BY a.name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "3724": {
        "db_id": "mountain_photos",
        "question": "List the brands of lenses that took both a picture of mountains with range 'Toubkal Atlas' and a picture of mountains with range 'Lasta Massif'",
        "ground_truth": "SELECT T3.brand FROM mountain AS T1 JOIN photos AS T2 ON T1.id  =  T2.mountain_id JOIN camera_lens AS T3 ON T2.camera_lens_id  =  T3.id WHERE T1.range  =  'Toubkal Atlas' INTERSECT SELECT T3.brand FROM mountain AS T1 JOIN photos AS T2 ON T1.id  =  T2.mountain_id JOIN camera_lens AS T3 ON T2.camera_lens_id  =  T3.id WHERE T1.range  =  'Lasta Massif'",
        "amends": [
            "Do use `INTERSECT` to find brands present in both mountain ranges instead of using `AND` with conflicting conditions. Do join `mountain` table as `T1` instead of `mountains` and use `id` instead of `mountain_id` for the join condition. Do join `photos` as `T2` with `T1.id = T2.mountain_id` instead of joining on `lens_id`. Do join `camera_lens` as `T3` with `T2.camera_lens_id = T3.id` instead of joining `lenses` directly. Do select `T3.brand` instead of `l.brand` and remove `DISTINCT` since `INTERSECT` inherently returns unique results. Do use separate queries for each mountain range condition instead of combining them with `AND` in a single `WHERE` clause. The amended query now correctly finds camera lens brands that have been used in both the Toubkal Atlas and Lasta Massif mountain ranges."
        ],
        "rules": [
            "1) When the question asks for brands that took pictures in both 'Toubkal Atlas' and 'Lasta Massif' ranges: use INTERSECT to combine results from separate queries for each range instead of AND conditions in a single WHERE clause. 2) When joining the mountain table: use table name \"mountain\" as T1 with column \"id\" as the join key instead of \"mountains\" with \"mountain_id\". 3) When joining photos table: use T2 with join condition T1.id = T2.mountain_id instead of joining on lens_id. 4) When joining camera_lens table: use T3 with join condition T2.camera_lens_id = T3.id instead of joining lenses directly. 5) When selecting the brand: use T3.brand instead of l.brand and remove DISTINCT since INTERSECT inherently returns unique results. 6) When handling mountain range conditions: use separate queries with m.range = 'Toubkal Atlas' and m.range = 'Lasta Massif' respectively."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT l.brand \nFROM lenses l \nJOIN photos p ON l.lens_id = p.lens_id \nJOIN mountains m ON p.mountain_id = m.mountain_id \nWHERE m.range = 'Toubkal Atlas' \nAND m.range = 'Lasta Massif'",
            "SELECT T3.brand\nFROM mountain T1\nJOIN photos T2 ON T1.id = T2.mountain_id\nJOIN camera_lens T3 ON T2.camera_lens_id = T3.id\nWHERE T1.Range = 'Toubkal Atlas'\nINTERSECT\nSELECT T3.brand\nFROM mountain T1\nJOIN photos T2 ON T1.id = T2.mountain_id\nJOIN camera_lens T3 ON T2.camera_lens_id = T3.id\nWHERE T1.Range = 'Lasta Massif'"
        ],
        "rule_sql": [
            "SELECT T3.brand\nFROM mountain T1\nJOIN photos T2 ON T1.id = T2.mountain_id\nJOIN camera_lens T3 ON T2.camera_lens_id = T3.id\nWHERE T1.Range = 'Toubkal Atlas'\nINTERSECT\nSELECT T3.brand\nFROM mountain T1\nJOIN photos T2 ON T1.id = T2.mountain_id\nJOIN camera_lens T3 ON T2.camera_lens_id = T3.id\nWHERE T1.Range = 'Lasta Massif'"
        ]
    },
    "5186": {
        "db_id": "music_2",
        "question": "Find all the songs produced by artists with first name \"Marianne\".",
        "ground_truth": "SELECT T3.Title FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId WHERE T2.firstname  =  \"Marianne\"",
        "amends": [
            "Do select only `T3.Title` instead of selecting all columns with `*`. Do join `Performance AS T1` instead of querying only the `songs` table. Do add `JOIN Band AS T2 ON T1.bandmate = T2.id` to connect band information instead of omitting this relationship. Do add `JOIN Songs AS T3 ON T3.SongId = T1.SongId` to properly link songs through performances instead of querying songs directly. Do filter on `T2.firstname = \"Marianne\"` instead of filtering on a non-existent `artist_first_name` column. The amended query now correctly retrieves song titles performed by band members named Marianne through proper table relationships, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"songs produced by artists with first name 'Marianne'\": make sure the output order: T3.Title 2) When the question mentions \"songs\": \"songs\" actually means \"Title in Songs table (T3)\" 3) When the question mentions \"artists with first name 'Marianne'\": \"artists\" actually means \"band members in Band table (T2) with firstname = 'Marianne'\" 4) When combining T1, T2, and T3 for shared entities: link rows where T1.bandmate = T2.id and T3.SongId = T1.SongId; keep only matching pairs (inner match) 5) When filtering for first name \"Marianne\": use exact literal 'Marianne' with T2.firstname column"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM songs WHERE artist_first_name = 'Marianne';",
            "SELECT T3.Title \nFROM Performance AS T1\nJOIN Band AS T2 ON T1.Bandmate = T2.Id\nJOIN Songs AS T3 ON T3.SongId = T1.SongId\nWHERE T2.Firstname = \"Marianne\""
        ],
        "rule_sql": [
            "SELECT T3.Title\nFROM Performance T1\nJOIN Band T2 ON T1.Bandmate = T2.Id\nJOIN Songs T3 ON T3.SongId = T1.SongId\nWHERE T2.Firstname = 'Marianne'\nORDER BY T3.Title"
        ]
    },
    "1429": {
        "db_id": "college_2",
        "question": "Give the title of the course offered in Chandler during the Fall of 2010.",
        "ground_truth": "SELECT T1.title FROM course AS T1 JOIN SECTION AS T2 ON T1.course_id  =  T2.course_id WHERE building  =  'Chandler' AND semester  =  'Fall' AND YEAR  =  2010",
        "amends": [
            "Do join `course AS T1` with `SECTION AS T2` on `T1.course_id = T2.course_id` instead of querying only the `courses` table. Do filter on `building = 'Chandler'` instead of `location = 'Chandler'` to reference the correct column name. Do qualify the title column as `T1.title` instead of just `title` for explicit table reference. The amended query now correctly joins the course and section tables and filters on the appropriate building column to match the intended behavior."
        ],
        "rules": [
            "1) When answering about courses offered in a specific location: join table \"course\" as T1 with table \"SECTION\" as T2 on T1.course_id = T2.course_id to access location information. 2) When the question mentions \"Chandler\" as a location: filter on T2.building = 'Chandler' instead of location column. 3) When selecting the course title: use T1.title as the output column with explicit table reference. 4) When combining course and section tables: perform an inner match where T1.course_id = T2.course_id to keep only courses that have sections."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM courses WHERE location = 'Chandler' AND semester = 'Fall' AND year = 2010;",
            "SELECT T1.title FROM course AS T1 JOIN section AS T2 ON T1.course_id = T2.course_id WHERE T2.building = 'Chandler' AND T2.semester = 'Fall' AND T2.year = 2010"
        ],
        "rule_sql": [
            "SELECT T1.title\nFROM course AS T1\nINNER JOIN section AS T2 ON T1.course_id = T2.course_id\nWHERE T2.building = 'Chandler'\nAND T2.semester = 'Fall'\nAND T2.year = 2010"
        ]
    },
    "1266": {
        "db_id": "apartment_rentals",
        "question": "Show each gender code and the corresponding count of guests sorted by the count in descending order.",
        "ground_truth": "SELECT gender_code ,  COUNT(*) FROM Guests GROUP BY gender_code ORDER BY COUNT(*) DESC",
        "amends": [
            "Do reference `gender_code` instead of `gender` in the SELECT list and GROUP BY clause. Do order by `COUNT(*) DESC` instead of `guest_count ASC`, removing the alias reference. Do remove the alias `guest_count` instead of keeping it in the SELECT clause. The amended query now correctly uses the actual column name for grouping and implements descending count ordering as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question mentions \"gender code\": use the exact column name \"gender_code\" from the Guests table for both selection and grouping. 2) When counting guests: count all rows using COUNT(*) without aliasing the result. 3) When ordering by count in descending order: sort the results by COUNT(*) in descending direction without referencing any alias. 4) When the question asks to show gender code and count: output only the gender_code column and the count result without additional columns or aliases."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT gender, COUNT(*) as guest_count FROM guests GROUP BY gender ORDER BY guest_count ASC;",
            "SELECT gender_code, COUNT(*) FROM Guests GROUP BY gender_code ORDER BY COUNT(*) DESC;"
        ],
        "rule_sql": [
            "SELECT gender_code, COUNT(*) FROM Guests GROUP BY gender_code ORDER BY COUNT(*) DESC;"
        ]
    },
    "364": {
        "db_id": "flight_1",
        "question": "What is the name and salary of all employees in order of salary?",
        "ground_truth": "SELECT name ,  salary FROM Employee ORDER BY salary",
        "amends": [
            "Do reference the `Employee` table instead of `employees` in the FROM clause. Do order by `salary` instead of `name` in the ORDER BY clause. The amended query now correctly references the intended table and sorts results by salary rather than name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"name and salary of all employees\": make sure the output order: \"name\", \"salary\". 2) When the question mentions \"employees\": \"employees\" actually means \"Employee\" in schema. 3) When the question asks for \"in order of salary\": rank rows by \"salary\" in ascending order (default)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, salary FROM employees ORDER BY name;",
            "SELECT name, salary FROM employee ORDER BY salary;"
        ],
        "rule_sql": [
            "SELECT name, salary FROM employee ORDER BY salary;"
        ]
    },
    "292": {
        "db_id": "twitter_1",
        "question": "List the name and number of followers for each user, and sort the results by the number of followers in descending order.",
        "ground_truth": "SELECT name ,  followers FROM user_profiles ORDER BY followers DESC",
        "amends": [
            "Do select `name, followers` instead of `name, COUNT(followers) AS follower_count` to return individual follower counts rather than an aggregate count. Do query from `user_profiles` instead of `users` to access the correct table containing the follower data. Do order by `followers DESC` instead of `follower_count ASC` to sort in descending order by the actual follower count column rather than the ascending aggregate alias. The amended query now correctly returns individual user profiles with their follower counts sorted from highest to lowest, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"number of followers\" for each user: use the exact column \"followers\" from the user_profiles table to return individual follower counts rather than counting followers. 2) When selecting data about users: query from the \"user_profiles\" table instead of \"users\" to access the correct table containing follower data. 3) When sorting by number of followers in descending order: order by the \"followers\" column in descending direction (DESC) rather than ascending order. 4) When answering about listing name and number of followers: make sure the output order is name followed by followers."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, COUNT(followers) AS follower_count FROM users ORDER BY follower_count ASC;",
            "SELECT name, followers FROM user_profiles ORDER BY followers DESC;"
        ],
        "rule_sql": [
            "SELECT name, followers FROM user_profiles ORDER BY followers DESC;"
        ]
    },
    "1133": {
        "db_id": "climbing",
        "question": "What is the height of the mountain climbined by the climbing who had the most points?",
        "ground_truth": "SELECT T2.Height FROM climber AS T1 JOIN mountain AS T2 ON T1.Mountain_ID  =  T2.Mountain_ID ORDER BY T1.Points DESC LIMIT 1",
        "amends": [
            "Do join `climber AS T1` with `mountain AS T2` on `T1.Mountain_ID = T2.Mountain_ID` instead of querying only `mountains` with a subquery. Do select `T2.Height` instead of just `height`. Do add `ORDER BY T1.Points DESC LIMIT 1` instead of using a subquery with ordering and limit. Do remove the `WHERE` filter and subquery entirely instead of filtering by `climber_id` from a subquery. The amended query now correctly retrieves the height from the mountain associated with the highest-scoring climber by joining the relevant tables and ordering by points."
        ],
        "rules": [
            "1) When answering about \"height of the mountain climbed by the climber with the most points\": make sure the output order: T2.Height. 2) When combining climber (T1) and mountain (T2) tables: link rows where T1.Mountain_ID = T2.Mountain_ID and keep only matching pairs (inner match). 3) When the question mentions \"most points\": rank rows by T1.Points in descending order and keep the first 1 row. 4) When selecting the height: use T2.Height instead of just height to specify the exact column from the mountain table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT height FROM mountains WHERE climber_id = (SELECT climber_id FROM climbers ORDER BY points DESC LIMIT 1);",
            "SELECT T2.Height \nFROM climber AS T1 \nJOIN mountain AS T2 ON T1.Mountain_ID = T2.Mountain_ID \nORDER BY T1.Points DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Height FROM climber T1 JOIN mountain T2 ON T1.Mountain_ID = T2.Mountain_ID ORDER BY T1.Points DESC LIMIT 1"
        ]
    },
    "4962": {
        "db_id": "soccer_2",
        "question": "How many students got accepted after the tryout?",
        "ground_truth": "SELECT count(*) FROM tryout WHERE decision  =  'yes'",
        "amends": [
            "Do reference the `tryout` table instead of the `students` table. Do filter on `decision = 'yes'` instead of `tryout_result = 'accepted'`. Do remove the `tryout_date > '2023-01-01'` filter instead of keeping it. The amended query now correctly counts accepted tryouts from the appropriate table using the correct decision criteria without unnecessary date filtering."
        ],
        "rules": [
            "1) When counting students who got accepted after tryout: use the \"tryout\" table instead of the \"students\" table. 2) When filtering for accepted students: use \"decision = 'yes'\" instead of \"tryout_result = 'accepted'\". 3) When the question does not specify a date range: do not include any date filtering like \"tryout_date > '2023-01-01'\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE tryout_result = 'accepted' AND tryout_date > '2023-01-01';",
            "SELECT COUNT(*) FROM Tryout WHERE decision = 'yes';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Tryout WHERE decision = 'yes'"
        ]
    },
    "3009": {
        "db_id": "loan_1",
        "question": "What is the total number of customers across banks?",
        "ground_truth": "SELECT sum(no_of_customers) FROM bank",
        "amends": [
            "Do use `sum(no_of_customers)` instead of `COUNT(*)` to aggregate the actual customer count values rather than counting rows. Do query from the `bank` table instead of the `customers` table to access the pre-aggregated customer data. Do remove the `WHERE bank_id IS NOT NULL` filter instead of keeping it since the bank table already contains aggregated counts. The amended query now correctly sums pre-calculated customer counts from the bank table rather than attempting to count individual customer records."
        ],
        "rules": [
            "1) When answering about \"total number of customers across banks\": use sum(\"no_of_customers\") instead of counting rows to aggregate the actual customer count values. 2) When the question asks for customer counts: query from the \"bank\" table instead of the \"customers\" table to access the pre-aggregated customer data. 3) When using aggregated data from the bank table: do not apply any WHERE filters on bank_id since the bank table already contains complete aggregated counts."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE bank_id IS NOT NULL;",
            "SELECT SUM(no_of_customers) AS total_customers FROM bank;"
        ],
        "rule_sql": [
            "SELECT SUM(no_of_customers) AS total_customers FROM bank;"
        ]
    },
    "3486": {
        "db_id": "hr_1",
        "question": "What are the employee ids for those who had two or more jobs.",
        "ground_truth": "SELECT employee_id FROM job_history GROUP BY employee_id HAVING COUNT(*)  >= 2",
        "amends": [
            "Do use `GROUP BY employee_id` with `HAVING COUNT(*) >= 2` instead of filtering `job_count >= 2` directly in the `WHERE` clause. Do reference the `job_history` table instead of the `employees` table to properly count job transitions. Do aggregate the count of job records per employee instead of relying on a potentially non-existent `job_count` column. The amended query now correctly identifies employees with multiple job entries by counting records in the job history table rather than filtering on an incorrect column assumption."
        ],
        "rules": [
            "1) When counting job records per employee: use the job_history table instead of employees table to properly track job transitions. 2) When identifying employees with multiple jobs: group by employee_id and count the number of job records, keeping only those groups where the count is 2 or more. 3) When the question asks for employee ids with two or more jobs: output only the employee_id values that satisfy the multiple job condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT employee_id FROM employees WHERE job_count >= 2",
            "SELECT EMPLOYEE_ID FROM job_history GROUP BY EMPLOYEE_ID HAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT employee_id FROM job_history GROUP BY employee_id HAVING COUNT(*) >= 2"
        ]
    },
    "5131": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "Find the description and code of the service type that is performed the most times.",
        "ground_truth": "SELECT T1.Service_Type_Description , T1.Service_Type_Code FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code GROUP BY T1.Service_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.Service_Type_Description` and `T1.Service_Type_Code` instead of `description` and `code`. Do add `FROM Ref_Service_Types AS T1 JOIN Services AS T2` instead of `FROM service_types`. Do add `ON T1.Service_Type_Code = T2.Service_Type_Code` join condition instead of omitting it. Do add `GROUP BY T1.Service_Type_Code` instead of omitting grouping. The amended query now correctly joins tables and groups by service type code to count services per type, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"description and code of the service type\": use the exact column tokens \"T1.Service_Type_Description\" and \"T1.Service_Type_Code\" from the Ref_Service_Types table. 2) When counting how many times a service type is performed: count the number of services in the Services table (T2) grouped by each service type code. 3) When combining service type information with service counts: link Ref_Service_Types (T1) and Services (T2) where T1.Service_Type_Code equals T2.Service_Type_Code using an inner join. 4) When finding the service type performed the most times: rank service types by their service count in descending order and keep only the top result. 5) When organizing results by service type: group by T1.Service_Type_Code to ensure each service type appears only once in the results with its aggregate count."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description, code FROM service_types ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T1.Service_Type_Description, T1.Service_Type_Code\nFROM Ref_Service_Types AS T1\nJOIN Services AS T2 ON T1.Service_Type_Code = T2.Service_Type_Code\nGROUP BY T1.Service_Type_Code\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Service_Type_Description, T1.Service_Type_Code\nFROM Ref_Service_Types T1\nINNER JOIN Services T2 ON T1.Service_Type_Code = T2.Service_Type_Code\nGROUP BY T1.Service_Type_Code\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "4347": {
        "db_id": "tracking_grants_for_research",
        "question": "What is the total amount of grant money given to each organization and what is its id?",
        "ground_truth": "SELECT sum(grant_amount) ,  organisation_id FROM Grants GROUP BY organisation_id",
        "amends": [
            "Do use `organisation_id` instead of `organization_id` for the grouping column and do use `sum(grant_amount)` instead of `SUM(amount) as total_grant_money` for the aggregate expression. Do group by `organisation_id` instead of `organization_name` to ensure the aggregation aligns with the correct grouping dimension. The amended query now correctly calculates the total grant amounts per organization using the proper column names and grouping logic.",
            "Do place `organisation_id` in the SELECT list after the aggregate function instead of before it, and do remove the alias `total_grant_money` instead of keeping it. The amended query now matches RIGHT_SQL's behavior by correctly grouping and summing grant amounts per organization without unnecessary aliasing.",
            "Do place `organisation_id` after the aggregate function in the SELECT list instead of before it, maintaining the same logical grouping by organisation_id. The amended query now correctly displays the sum of grant amounts alongside each organisation identifier, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"total amount of grant money\": use the exact column name \"grant_amount\" for the sum calculation. 2) When the question asks for \"each organization and what is its id\": use the exact column name \"organisation_id\" for both selection and grouping. 3) When grouping by organization: ensure the grouping column \"organisation_id\" matches the selection column \"organisation_id\" to maintain proper aggregation alignment.",
            "1) When answering about \"total amount of grant money given to each organization and its id\": make sure the output order: SUM(grant_amount) first, then organisation_id. 2) When the question asks for \"total amount of grant money\": compute the sum of grant_amount values. 3) When the question asks for \"each organization and its id\": group results by organisation_id. 4) When producing output columns: do not add aliases like total_grant_money unless explicitly required.",
            "1) When answering about \"total amount of grant money given to each organization and its id\": make sure the output order: organization identifier first, then the sum of grant amounts. 2) When the question asks for \"total amount of grant money given to each organization\": compute the sum of grant_amount values grouped by organisation_id. 3) When grouping by organisation_id: use the exact column token \"organisation_id\" from the Projects table for grouping. 4) When producing output columns: place organisation_id before the aggregate function SUM(grant_amount) in the result display."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT organization_id, SUM(amount) as total_grant_money FROM grants GROUP BY organization_name",
            "SELECT organisation_id, SUM(grant_amount) as total_grant_money FROM Grants GROUP BY organisation_id",
            "SELECT organisation_id, SUM(grant_amount) FROM Grants GROUP BY organisation_id",
            "SELECT SUM(grant_amount), organisation_id FROM Grants GROUP BY organisation_id"
        ],
        "rule_sql": [
            "SELECT organisation_id, SUM(grant_amount) FROM Grants GROUP BY organisation_id;"
        ]
    },
    "6533": {
        "db_id": "wine_1",
        "question": "List the names of all distinct wines that are made of red color grape.",
        "ground_truth": "SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  \"Red\"",
        "amends": [
            "Do join `GRAPES AS T1` and `WINE AS T2` instead of querying only `wines` table. Do use `T1.Grape = T2.Grape` join condition instead of no join. Do reference `T2.Name` instead of `name`. Do filter on `T1.Color = \"Red\"` instead of `grape_color = 'red'`. Do use double quotes around \"Red\" instead of single quotes. The amended query now correctly joins tables to filter wines by grape color rather than assuming color exists in the wines table."
        ],
        "rules": [
            "1) When answering about \"wines made of red color grape\": join table GRAPES as T1 and WINE as T2 using the condition T1.Grape = T2.Grape to link grape information to wines. 2) When filtering for red color grapes: use T1.Color = \"Red\" with exact double quotes around \"Red\". 3) When selecting wine names: reference T2.Name instead of name from the base table. 4) When listing distinct wines: ensure only unique wine names are returned from the joined result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT name FROM wines WHERE grape_color = 'red';",
            "SELECT DISTINCT T2.Name FROM grapes AS T1 JOIN wine AS T2 ON T1.Grape = T2.Grape WHERE T1.Color = \"Red\""
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.Name \nFROM grapes AS T1 \nJOIN wine AS T2 ON T1.Grape = T2.Grape \nWHERE T1.Color = \"Red\""
        ]
    },
    "4121": {
        "db_id": "film_rank",
        "question": "Return the types of film market estimations in 1995.",
        "ground_truth": "SELECT TYPE FROM film_market_estimation WHERE YEAR  =  1995",
        "amends": [
            "Do select `TYPE` instead of `market_estimation` and do query from `film_market_estimation` instead of `films`. Do remove `DISTINCT` instead of keeping it and do use consistent capitalization for `YEAR` instead of `year`. The amended query now correctly retrieves market estimation types from the appropriate table without unnecessary distinct filtering."
        ],
        "rules": [
            "1) When answering about \"types of film market estimations in 1995\": make sure the output order: TYPE. 2) When the question mentions \"film market estimations\": query from the \"film_market_estimation\" table instead of \"films\". 3) When filtering by year 1995: use the exact column \"YEAR\" with consistent capitalization and the literal value 1995. 4) When retrieving types: select the exact column \"TYPE\" instead of \"market_estimation\". 5) When the question asks for types: do not use DISTINCT filtering as it is unnecessary for this query."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT market_estimation FROM films WHERE year = 1995;",
            "SELECT Type FROM film_market_estimation WHERE Year = 1995"
        ],
        "rule_sql": [
            "SELECT Type FROM film_market_estimation WHERE Year = 1995"
        ]
    },
    "4085": {
        "db_id": "student_1",
        "question": "Find the classroom that the most students use.",
        "ground_truth": "SELECT classroom FROM list GROUP BY classroom ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `classroom` instead of including `COUNT(*) as student_count`. Do use table `list` instead of `students` as the FROM source. Do order by `count(*) DESC` instead of `student_count ASC` to find the classroom with the highest count. Do remove the explicit column alias `student_count` instead of keeping it since it's not needed in the ORDER BY clause. The amended query now correctly identifies the classroom with the most students by counting occurrences and ordering descending."
        ],
        "rules": [
            "1) When answering about \"classroom that the most students use\": make sure the output order: classroom only without count columns. 2) When counting students: use table \"list\" instead of \"students\" as the data source. 3) When finding the classroom with the most students: order by count(*) in descending direction and keep only the first row. 4) When ordering by count: do not use explicit column aliases like \"student_count\" in the ORDER BY clause."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT classroom, COUNT(*) as student_count FROM students GROUP BY classroom ORDER BY student_count ASC LIMIT 1;",
            "SELECT Classroom FROM list GROUP BY Classroom ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Classroom FROM list GROUP BY Classroom ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "337": {
        "db_id": "product_catalog",
        "question": "Find the dates on which more than one revisions were made.",
        "ground_truth": "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  1",
        "amends": [
            "Do select `date_of_latest_revision` instead of `date` and use `count(*) > 1` instead of `count(*) = 1` in the HAVING clause. Do query from `Catalogs` table instead of `revisions` table. The amended query now correctly identifies dates with multiple occurrences rather than single occurrences and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about dates with multiple revisions: use the exact column name \"date_of_latest_revision\" from the Catalogs table instead of \"date\". 2) When counting occurrences of revisions per date: use count(*) > 1 to find dates with more than one revision instead of count(*) = 1. 3) When querying for revision information: use the Catalogs table as the source instead of a revisions table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT date FROM revisions GROUP BY date HAVING COUNT(*) = 1;",
            "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING COUNT(*) > 1;"
        ]
    },
    "45": {
        "db_id": "farm",
        "question": "Return the different statuses of cities, ascending by frequency.",
        "ground_truth": "SELECT Status FROM city GROUP BY Status ORDER BY COUNT(*) ASC",
        "amends": [
            "Do use table name `city` instead of `cities` and column name `Status` instead of `status`. Do remove the explicit `COUNT(*) as frequency` column from the SELECT list instead of including it, keeping only the grouping column. Do change the ORDER BY to use `COUNT(*) ASC` for ascending order instead of `frequency DESC` for descending order. The amended query now correctly selects only the Status column from the city table, groups by Status, and orders by the count in ascending order as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question mentions \"cities\": use the exact table name \"city\" instead of \"cities\". 2) When the question mentions \"statuses\": use the exact column name \"Status\" instead of \"status\". 3) When the question asks for \"different statuses of cities\": select only the \"Status\" column and group by \"Status\". 4) When the question asks for \"ascending by frequency\": order by the count of rows in ascending order using COUNT(*) ASC. 5) When producing output for status counts: do not include the frequency count column in the final output, only show the distinct status values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT status, COUNT(*) as frequency FROM cities GROUP BY status ORDER BY frequency DESC;",
            "SELECT Status FROM city GROUP BY Status ORDER BY COUNT(*) ASC"
        ],
        "rule_sql": [
            "SELECT Status FROM city GROUP BY Status ORDER BY COUNT(*) ASC;"
        ]
    },
    "4991": {
        "db_id": "soccer_2",
        "question": "What are the names of the schools with the top 3 largest class sizes?",
        "ground_truth": "SELECT cName FROM college ORDER BY enr DESC LIMIT 3",
        "amends": [
            "Do select `cName` instead of `name` and use table `college` instead of `schools`. Do order by `enr DESC` instead of `class_size ASC` while maintaining the `LIMIT 3` clause. The amended query now correctly retrieves the top 3 colleges by enrollment in descending order from the college table."
        ],
        "rules": [
            "1) When answering about \"schools with the top 3 largest class sizes\": use table \"college\" instead of \"schools\". 2) When selecting school names: use column \"cName\" instead of \"name\". 3) When determining largest class sizes: order by column \"enr\" in descending order instead of \"class_size\" in ascending order. 4) When the question asks for \"top 3\": keep only the first 3 rows after ordering by \"enr\" in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM schools ORDER BY class_size ASC LIMIT 3;",
            "SELECT cName FROM College ORDER BY enr DESC LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT cName FROM College ORDER BY enr DESC LIMIT 3"
        ]
    },
    "3187": {
        "db_id": "college_1",
        "question": "what is the address of history department?",
        "ground_truth": "SELECT dept_address FROM department WHERE dept_name  =  'History'",
        "amends": [
            "Do select `dept_address` instead of `address` and use table name `department` instead of `departments`. Do filter on `dept_name = 'History'` instead of `name = 'Math Department'` to correctly reference the appropriate column and value for the intended query logic."
        ],
        "rules": [
            "1) When the question asks for \"address\" of a department: use the exact column token \"dept_address\" instead of \"address\". 2) When referencing the department table: use the exact table name \"department\" instead of \"departments\". 3) When filtering for the history department: use the exact column token \"dept_name\" and exact literal value 'History' instead of 'Math Department'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT address FROM departments WHERE name = 'Math Department';",
            "SELECT dept_address FROM department WHERE dept_name = 'History';"
        ],
        "rule_sql": [
            "SELECT dept_address FROM department WHERE dept_name = 'History';"
        ]
    },
    "6671": {
        "db_id": "driving_school",
        "question": "How many customers are there?",
        "ground_truth": "SELECT count(*) FROM Customers;",
        "amends": [
            "Do select from `Customers` instead of `orders` to count customer records rather than order records. The amended query now matches RIGHT_SQL's behavior by correctly targeting the customer table."
        ],
        "rules": [
            "1) When counting customers: count rows from the \"Customers\" table using the canonical key for customers. 2) When the question asks \"how many customers\": ensure the count is performed on the customer entity table rather than related tables like orders."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders;",
            "SELECT COUNT(*) FROM Customers;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Customers;"
        ]
    },
    "3844": {
        "db_id": "e_learning",
        "question": "How many students did not have any course enrollment?",
        "ground_truth": "SELECT count(*) FROM Students WHERE student_id NOT IN (SELECT student_id FROM Student_Course_Enrolment)",
        "amends": [
            "Do reference the `Student_Course_Enrolment` table instead of `enrollments` in the subquery. The amended query now correctly matches the intended behavior by querying the appropriate enrollment table."
        ],
        "rules": [
            "1) When the question asks about students without course enrollment: use the \"Student_Course_Enrolment\" table to identify enrolled students. 2) When counting students who did not enroll: count students where student_id is not found in the Student_Course_Enrolment table using student_id as the matching key. 3) When referencing table names: use exact table name \"Student_Course_Enrolment\" with proper case and spelling as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE student_id NOT IN (SELECT student_id FROM enrollments)",
            "SELECT COUNT(*) \nFROM Students s\nWHERE s.student_id NOT IN (\n    SELECT student_id \n    FROM Student_Course_Enrolment\n)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Students \nWHERE student_id NOT IN (SELECT student_id FROM Student_Course_Enrolment)"
        ]
    },
    "4613": {
        "db_id": "entertainment_awards",
        "question": "Please show different types of artworks with the corresponding number of artworks of each type.",
        "ground_truth": "SELECT TYPE ,  COUNT(*) FROM artwork GROUP BY TYPE",
        "amends": [
            "Do reference table `artwork` instead of `artworks` in the FROM clause, as the correct table name is singular rather than plural. The amended query now correctly counts records by type from the artwork table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for different types of artworks with counts: use the exact table name \"artwork\" (singular) instead of \"artworks\" (plural) 2) When counting artworks by type: count records using the canonical key from the artwork table and group by the \"type\" column"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type, COUNT(*) FROM artworks GROUP BY type;",
            "SELECT Type, COUNT(*) AS Number_of_Artworks FROM artwork GROUP BY Type;"
        ],
        "rule_sql": [
            "SELECT Type, COUNT(Artwork_ID) AS Number_of_Artworks FROM artwork GROUP BY Type;"
        ]
    },
    "4636": {
        "db_id": "college_3",
        "question": "Count the number of courses.",
        "ground_truth": "SELECT count(*) FROM COURSE",
        "amends": [
            "Do query the `COURSE` table instead of the `students` table, as the data source has been completely changed from one entity to another. The amended query now correctly counts records from the course catalog rather than student records, matching the intended behavior of counting course entries."
        ],
        "rules": [
            "1) When counting the number of courses: query the \"COURSE\" table instead of any other table. 2) When the question asks for \"count of courses\": compute the number of rows from the \"COURSE\" table using the canonical key for courses."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;",
            "SELECT COUNT(*) FROM Course;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Course;"
        ]
    },
    "4803": {
        "db_id": "aircraft",
        "question": "What are the number of international and domestic passengers of the airport named London \"Heathrow\"?",
        "ground_truth": "SELECT International_Passengers ,  Domestic_Passengers FROM airport WHERE Airport_Name  =  \"London Heathrow\"",
        "amends": [
            "Do reference columns `International_Passengers` and `Domestic_Passengers` with proper capitalization instead of lowercase `international_passengers` and `domestic_passengers`. Do query from table `airport` instead of incorrect table `airports`. Do filter on column `Airport_Name` instead of incorrect column `name`. Do use double quotes `\"London Heathrow\"` for string comparison instead of single quotes 'London Heathrow'. The amended query now correctly accesses the airport data with proper table and column references."
        ],
        "rules": [
            "1) When querying for airport data: use table \"airport\" instead of \"airports\". 2) When filtering by airport name: use column \"Airport_Name\" instead of \"name\". 3) When referencing international passengers: use column \"International_Passengers\" with exact capitalization. 4) When referencing domestic passengers: use column \"Domestic_Passengers\" with exact capitalization. 5) When filtering for London Heathrow airport: use the exact string literal \"London Heathrow\" with double quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT international_passengers, domestic_passengers FROM airports WHERE name = 'London Heathrow';",
            "SELECT International_Passengers, Domestic_Passengers FROM airport WHERE Airport_Name = \"London Heathrow\""
        ],
        "rule_sql": [
            "SELECT International_Passengers, Domestic_Passengers FROM airport WHERE Airport_Name = \"London Heathrow\";"
        ]
    },
    "2067": {
        "db_id": "party_people",
        "question": "Show member names that are not in the Progress Party.",
        "ground_truth": "SELECT T1.member_name FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id WHERE T2.Party_name != \"Progress Party\"",
        "amends": [
            "Do select `T1.member_name` instead of `name` and change the source to `Member AS T1` instead of `members`. Do add a `JOIN` with `party AS T2` instead of omitting it, using the join condition `T1.party_id = T2.party_id` instead of direct column filtering. Do change the filter to `T2.Party_name != \"Progress Party\"` instead of `party = 'Progress Party'`, effectively selecting members not from the Progress Party rather than those from it. The amended query now correctly joins tables and filters by party name rather than assuming a direct party column, matching the intended behavior."
        ],
        "rules": [
            "1) When selecting member names: use T1.member_name instead of name and source from Member AS T1 instead of members. 2) When filtering by party: join with party AS T2 using T1.party_id = T2.party_id instead of direct column filtering. 3) When excluding members from a specific party: use T2.Party_name != \"Progress Party\" instead of party = 'Progress Party' to select members not from the Progress Party."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM members WHERE party = 'Progress Party';",
            "SELECT T1.Member_Name \nFROM member AS T1 \nJOIN party AS T2 ON T1.Party_ID = T2.Party_ID \nWHERE T2.Party_name != 'Progress Party'"
        ],
        "rule_sql": [
            "SELECT T1.Member_Name FROM member AS T1 JOIN party AS T2 ON T1.Party_ID = T2.Party_ID WHERE T2.Party_name != \"Progress Party\""
        ]
    },
    "275": {
        "db_id": "twitter_1",
        "question": "What is the partition id of the user named \"Iron Man\".",
        "ground_truth": "SELECT partitionid FROM user_profiles WHERE name  =  'Iron Man'",
        "amends": [
            "Do reference table `user_profiles` instead of `users` and column `partitionid` instead of `partition_id` in the SELECT clause. Do filter on column `name` with value 'Iron Man' instead of `username` with the same value. The amended query now correctly retrieves the partition identifier from the user profiles table based on the name field, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"partition id of the user named 'Iron Man'\": make sure the output order: partitionid from table user_profiles. 2) When the question mentions \"user named 'Iron Man'\": filter rows where the column name equals exactly 'Iron Man' (case-sensitive). 3) When the question mentions \"partition id\": use the exact column name partitionid from table user_profiles, not partition_id. 4) When selecting data: use table user_profiles instead of users table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT partition_id FROM users WHERE username = 'Iron Man'",
            "SELECT partitionid FROM user_profiles WHERE name = 'Iron Man';"
        ],
        "rule_sql": [
            "SELECT partitionid FROM user_profiles WHERE name = 'Iron Man';"
        ]
    },
    "1992": {
        "db_id": "phone_market",
        "question": "List the names of phones that are not on any market.",
        "ground_truth": "SELECT Name FROM phone WHERE Phone_id NOT IN (SELECT Phone_ID FROM phone_market)",
        "amends": [
            "Do select `Name` instead of `name` and use table `phone` instead of `phones`. Do remove the `WHERE market_id IS NULL` filter instead of keeping it and instead add a `NOT IN` subquery condition checking `Phone_id NOT IN (SELECT Phone_ID FROM phone_market)` to properly identify phones not present in the market table. Do reference the correct primary key column `Phone_id` instead of the non-existent `market_id` column. The amended query now correctly identifies phones not associated with any market by checking against the phone_market junction table instead of relying on a missing foreign key column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting phone names: use the exact column token \"Name\" from table \"phone\" instead of \"name\". 2) When identifying phones not on any market: check that \"Phone_id\" is not present in the \"phone_market\" junction table using \"Phone_id NOT IN (SELECT Phone_ID FROM phone_market)\" instead of checking for NULL values. 3) When referring to the phone table: use the exact table name \"phone\" instead of \"phones\". 4) When checking for market association: use the primary key column \"Phone_id\" instead of the non-existent \"market_id\" column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM phones WHERE market_id IS NULL;",
            "SELECT Name FROM phone WHERE Phone_ID NOT IN (SELECT Phone_ID FROM phone_market)"
        ],
        "rule_sql": [
            "SELECT Name FROM phone WHERE Phone_ID NOT IN (SELECT Phone_ID FROM phone_market)"
        ]
    },
    "2580": {
        "db_id": "inn_1",
        "question": "How many times does ROY SWEAZY has reserved a room.",
        "ground_truth": "SELECT count(*) FROM Reservations WHERE FirstName = \"ROY\" AND LastName  =  \"SWEAZY\";",
        "amends": [
            "Do reference the `FirstName` and `LastName` columns instead of the non-existent `guest_name` column. Do add the `AND LastName = \"SWEAZY\"` condition instead of using a single combined name field. Do use proper table name capitalization `Reservations` instead of lowercase `reservations`. The amended query now correctly matches the RIGHT_SQL's behavior by properly querying separate first and last name fields."
        ],
        "rules": [
            "1) When the question mentions \"ROY SWEAZY\": \"ROY\" actually means \"FirstName = 'ROY'\" and \"SWEAZY\" actually means \"LastName = 'SWEAZY'\" in the Reservations table. 2) When counting reservations for a specific guest: count using the canonical key from the Reservations table where both FirstName = 'ROY' AND LastName = 'SWEAZY'. 3) When choosing identifier delimiters: use exact table name capitalization \"Reservations\" instead of lowercase \"reservations\". 4) When handling text literals: preserve exact case and spacing for 'ROY' and 'SWEAZY' as shown in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM reservations WHERE guest_name = 'ROY SWEAZY';",
            "SELECT COUNT(*) FROM Reservations WHERE FirstName = 'ROY' AND LastName = 'SWEAZY';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Reservations WHERE FirstName = 'ROY' AND LastName = 'SWEAZY'"
        ]
    },
    "5033": {
        "db_id": "soccer_2",
        "question": "What are the names of the schools with some players in the mid position but no goalies?",
        "ground_truth": "SELECT cName FROM  tryout WHERE pPos  =  'mid' EXCEPT SELECT cName FROM  tryout WHERE pPos  =  'goalie'",
        "amends": [
            "Do use table `tryout` instead of `schools` and `players` with joins. Do select column `cName` instead of `s.name`. Do filter with `pPos = 'mid'` instead of `p.position = 'mid'` and remove the join condition. Do use `EXCEPT` operator instead of a `NOT IN` subquery with duplicate joins. Do remove the `DISTINCT` keyword since `EXCEPT` inherently eliminates duplicates. Do remove the complex subquery structure and instead use a second `SELECT cName FROM tryout WHERE pPos = 'goalie'` in the `EXCEPT` clause. The amended query now correctly identifies mid-position players from schools that don't have goalies using the simpler and more efficient `EXCEPT` operation instead of the nested join approach."
        ],
        "rules": [
            "1) When answering about school names: use column \"cName\" from table \"tryout\" instead of \"s.name\" from \"schools\" table. 2) When filtering for mid position players: use condition \"pPos = 'mid'\" instead of \"p.position = 'mid'\". 3) When filtering for goalie position players: use condition \"pPos = 'goalie'\" instead of \"p.position = 'goalie'\". 4) When finding schools with mid players but no goalies: use EXCEPT operator between \"SELECT cName FROM tryout WHERE pPos = 'mid'\" and \"SELECT cName FROM tryout WHERE pPos = 'goalie'\" instead of NOT IN subquery with joins. 5) When eliminating duplicates: rely on EXCEPT operator's inherent duplicate elimination instead of using DISTINCT keyword. 6) When combining data from the same table: do not use join conditions since all data comes from \"tryout\" table with both player position information."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT s.name \nFROM schools s \nJOIN players p ON s.id = p.school_id \nWHERE p.position = 'mid' \nAND s.id NOT IN (\n    SELECT s2.id \n    FROM schools s2 \n    JOIN players p2 ON s2.id = p2.school_id \n    WHERE p2.position = 'goalie'\n)",
            "SELECT cName FROM Tryout WHERE pPos = 'mid' EXCEPT SELECT cName FROM Tryout WHERE pPos = 'goalie'"
        ],
        "rule_sql": [
            "SELECT cName FROM Tryout WHERE pPos = 'mid' EXCEPT SELECT cName FROM Tryout WHERE pPos = 'goalie'"
        ]
    },
    "1548": {
        "db_id": "customers_and_invoices",
        "question": "How many accounts are there?",
        "ground_truth": "SELECT count(*) FROM Accounts",
        "amends": [
            "Do reference the `Accounts` table instead of the `users` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)`. The amended query now correctly counts records from the Accounts table instead of the users table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"how many accounts\": make sure to count records from the \"Accounts\" table instead of the \"users\" table. 2) When counting entities: use lowercase \"count(*)\" to count all rows from the specified table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users;",
            "SELECT count(*) FROM Accounts;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM Accounts;"
        ]
    },
    "2352": {
        "db_id": "csu_1",
        "question": "Find the average fee on a CSU campus in 1996",
        "ground_truth": "SELECT avg(campusfee) FROM csu_fees WHERE YEAR  =  1996",
        "amends": [
            "Do use table `csu_fees` instead of `campuses` and column `campusfee` instead of `fee` for the aggregate calculation. Do filter on year `1996` instead of `1995` in the WHERE clause. The amended query now correctly calculates the average campus fee from the appropriate table for the specified year."
        ],
        "rules": [
            "1) When answering about \"average fee on a CSU campus in 1996\": use table \"csu_fees\" instead of \"campuses\" for the calculation. 2) When calculating the average fee: use column \"campusfee\" instead of \"fee\" for the aggregate calculation. 3) When filtering by year: use year value 1996 instead of 1995 in the filter condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(fee) FROM campuses WHERE year = 1995;",
            "SELECT AVG(CampusFee) AS AverageFee FROM csu_fees WHERE Year = 1996"
        ],
        "rule_sql": [
            "SELECT AVG(CampusFee) FROM csu_fees WHERE Year = 1996"
        ]
    },
    "438": {
        "db_id": "flight_1",
        "question": "What is the salaray and name of the employee with the most certificates to fly planes more than 5000?",
        "ground_truth": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `T1.name` instead of `name, salary` and change the source to `Employee AS T1` joined with `Certificate AS T2` on `T1.eid = T2.eid` instead of querying `employees` directly. Do add a second join with `Aircraft AS T3` on `T3.aid = T2.aid` instead of omitting these tables. Do change the WHERE filter to `T3.distance > 5000` instead of `certificates > 5000` and add `GROUP BY T1.eid` instead of omitting grouping. Do change the ORDER BY to `count(*) DESC` instead of `certificates DESC` while keeping `LIMIT 1`. The amended query now correctly finds the employee with the most certificates for aircraft flying over 5000 distance units.",
            "Do remove `T1.salary` from the SELECT list instead of including it. Do use `count(*)` instead of `COUNT(*)` for consistency. The amended query now correctly returns only employee names for those certified on aircraft with distance over 5000, grouped by employee ID and ordered by certificate count."
        ],
        "rules": [
            "1) When answering about \"employee with the most certificates to fly planes more than 5000\": make sure the output order: T1.name, salary. 2) When the question mentions \"certificates to fly planes more than 5000\": this actually means \"count of certificates where aircraft distance > 5000\" in schema. 3) When combining Employee (T1) and Certificate (T2) for shared entities: link rows where T1.eid = T2.eid exactly as shown; keep only matching pairs (inner match). 4) When combining Certificate (T2) and Aircraft (T3) for shared entities: link rows where T3.aid = T2.aid exactly as shown; keep only matching pairs (inner match). 5) When filtering for aircraft distance: use T3.distance > 5000 exactly as specified. 6) When the question asks for \"most certificates\": rank employees by count(*) in descending order and keep the first 1 row. 7) When counting certificates per employee: compute the number of rows using the grouping by T1.eid. 8) When producing output: select only T1.name and salary columns.",
            "1) When the question asks for \"salary and name\" but the amends specify removing salary: include only \"name\" in the output columns, not salary. 2) When counting certificates for employees: use count(*) to count the number of certificates per employee. 3) When the question asks for the employee with the most certificates: order the results by certificate count in descending order and take only the top result. 4) When filtering for planes that fly more than 5000: apply the condition distance > 5000 to the Aircraft table. 5) When combining Employee, Certificate, and Aircraft tables: link Employee to Certificate using T1.eid = T2.eid, and Certificate to Aircraft using T3.aid = T2.aid. 6) When grouping by employee: group by T1.eid to count certificates per employee."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, salary FROM employees WHERE certificates > 5000 ORDER BY certificates DESC LIMIT 1;",
            "SELECT T1.name, T1.salary\nFROM Employee AS T1\nJOIN Certificate AS T2 ON T1.eid = T2.eid\nJOIN Aircraft AS T3 ON T3.aid = T2.aid\nWHERE T3.distance > 5000\nGROUP BY T1.eid\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.name\nFROM Employee AS T1\nJOIN Certificate AS T2 ON T1.eid = T2.eid\nJOIN Aircraft AS T3 ON T3.aid = T2.aid\nWHERE T3.distance > 5000\nGROUP BY T1.eid\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.name\nFROM employee T1\nJOIN certificate T2 ON T1.eid = T2.eid\nJOIN aircraft T3 ON T3.aid = T2.aid\nWHERE T3.distance > 5000\nGROUP BY T1.eid\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "1208": {
        "db_id": "apartment_rentals",
        "question": "What is the average number of bedrooms of all apartments?",
        "ground_truth": "SELECT avg(bedroom_count) FROM Apartments",
        "amends": [
            "Do reference the `bedroom_count` column instead of `bedrooms` and use the `Apartments` table instead of `houses` table. The amended query now correctly calculates the average bedroom count from the Apartments table."
        ],
        "rules": [
            "1) When the question asks about \"apartments\": use the \"Apartments\" table instead of \"houses\" table. 2) When the question asks about \"bedrooms\": use the \"bedroom_count\" column instead of \"bedrooms\" column. 3) When calculating the average number of bedrooms: compute the average of the \"bedroom_count\" column from the \"Apartments\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(bedrooms) FROM houses;",
            "SELECT AVG(bedroom_count) AS average_bedrooms FROM Apartments;"
        ],
        "rule_sql": [
            "SELECT AVG(bedroom_count) AS average_bedrooms FROM Apartments;"
        ]
    },
    "5163": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "Which workshop groups have bookings with status code \"stop\"? Give me the names.",
        "ground_truth": "SELECT T2.Store_Name FROM Bookings AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T1.Status_Code  =  \"stop\"",
        "amends": [
            "Do select `T2.Store_Name` instead of `workshop_name`. Do join `Bookings AS T1` and `Drama_Workshop_Groups AS T2` instead of querying only `workshop_groups`. Do use `ON T1.Workshop_Group_ID = T2.Workshop_Group_ID` instead of no join condition. Do filter on `T1.Status_Code = \"stop\"` instead of `status_code = 'stop'`. The amended query now correctly joins the Bookings and Drama_Workshop_Groups tables to find stores associated with stopped workshop bookings, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about workshop groups with bookings having status code \"stop\": make sure the output order: T2.Store_Name. 2) When the question mentions \"workshop groups\": \"workshop groups\" actually means \"Drama_Workshop_Groups as T2\" in schema. 3) When the question mentions \"bookings with status code 'stop'\": this actually means \"Bookings as T1 with T1.Status_Code = 'stop'\" in schema. 4) When combining T1 and T2 for shared entities: link rows where T1.Workshop_Group_ID = T2.Workshop_Group_ID exactly as shown; keep only matching pairs (inner match). 5) When handling text literals: do not change case, spacing, or punctuation - use exact literal \"stop\" with single quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT workshop_name FROM workshop_groups WHERE status_code = 'stop';",
            "SELECT T2.Store_Name \nFROM Bookings AS T1 \nJOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID = T2.Workshop_Group_ID \nWHERE T1.Status_Code = 'stop'"
        ],
        "rule_sql": [
            "SELECT T2.Store_Name\nFROM Bookings AS T1\nINNER JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID = T2.Workshop_Group_ID\nWHERE T1.Status_Code = 'stop'\nORDER BY T2.Store_Name;"
        ]
    },
    "3364": {
        "db_id": "sports_competition",
        "question": "What are the positions of players whose average number of points scored by that position is larger than 20?",
        "ground_truth": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  20",
        "amends": [
            "Do select only `position` instead of selecting both `position` and `avg(points)` with an alias. Do group by `name` instead of grouping by `position`. Do use the aggregate function `avg(Points)` in the HAVING clause instead of the non-aggregated column `points`. Do use the comparison operator `>=` instead of `>` in the HAVING condition. Do reference the table `player` instead of `players`. The amended query now correctly filters groups based on the average points threshold rather than attempting to filter individual rows in the HAVING clause.",
            "Do group by `name` instead of `Position` in the GROUP BY clause, while keeping the SELECT clause as `Position` instead of changing it to match the grouping column. Do maintain the HAVING clause with `AVG(Points) >= 20` instead of altering the aggregate condition. The amended query now correctly groups by player name while selecting their position, matching the RIGHT_SQL's behavior of analyzing average points per player rather than per position."
        ],
        "rules": [
            "1) When answering about \"positions of players whose average number of points scored by that position is larger than 20\": make sure the output order: position only. 2) When the question asks for positions with average points greater than 20: group by the exact token \"name\" instead of \"position\". 3) When filtering groups based on average points: use the aggregate function avg(Points) in the HAVING condition instead of the non-aggregated column points. 4) When comparing average points against threshold 20: use the comparison operator >= instead of >. 5) When referencing the player table: use the exact table name \"player\" instead of \"players\".",
            "1) When the question asks for positions of players based on average points scored: group by the exact token \"name\" instead of \"Position\" to analyze per player rather than per position. 2) When computing average points per player: use AVG(Points) >= 20 as the condition to filter players whose average points exceed 20. 3) When selecting the position for qualified players: output the exact token \"Position\" from the player table while grouping by \"name\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT position, AVG(points) as avg_points FROM players GROUP BY position HAVING points > 20;",
            "SELECT Position FROM player GROUP BY Position HAVING AVG(Points) >= 20",
            "SELECT Position FROM player GROUP BY name HAVING AVG(Points) >= 20"
        ],
        "rule_sql": [
            "SELECT Position FROM player GROUP BY name HAVING AVG(Points) >= 20"
        ]
    },
    "119": {
        "db_id": "bike_1",
        "question": "What is the id of the trip that has the shortest duration?",
        "ground_truth": "SELECT id FROM trip ORDER BY duration LIMIT 1",
        "amends": [
            "Do reference table `trip` instead of `trips` in the FROM clause. Do remove the `ASC` keyword from the ORDER BY clause instead of including it, as ASC is the default sort order. The amended query now correctly selects from the proper table and uses the default ascending sort order without explicit specification."
        ],
        "rules": [
            "1) When answering about \"the id of the trip that has the shortest duration\": make sure the output order: id. 2) When the question mentions \"trip\": \"trip\" actually means table \"trip\" in schema. 3) When the question asks for \"shortest duration\": rank rows by duration in ascending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM trips ORDER BY duration ASC LIMIT 1;",
            "SELECT id FROM trip ORDER BY duration LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT id FROM trip ORDER BY duration ASC LIMIT 1;"
        ]
    },
    "2013": {
        "db_id": "gas_company",
        "question": "Show gas station id, location, and manager_name for all gas stations ordered by open year.",
        "ground_truth": "SELECT station_id ,  LOCATION ,  manager_name FROM gas_station ORDER BY open_year",
        "amends": [
            "Do reference `station_id` instead of `gas_station_id` and use table `gas_station` instead of `gas_stations` while maintaining the same column selection of `LOCATION` and `manager_name` with identical ordering by `open_year`. The amended query now correctly matches the intended table structure and column naming while preserving the same result ordering behavior."
        ],
        "rules": [
            "1) When the question mentions \"gas station id\": use the exact column token \"station_id\" instead of \"gas_station_id\". 2) When referencing the gas stations table: use the exact table name \"gas_station\" instead of \"gas_stations\". 3) When selecting output columns: maintain the exact column order \"station_id\", \"LOCATION\", \"manager_name\" as shown in the question. 4) When ordering results: sort by the exact column \"open_year\" in ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT gas_station_id, location, manager_name FROM gas_stations ORDER BY open_year;",
            "SELECT Station_ID, Location, Manager_Name FROM gas_station ORDER BY Open_Year;"
        ],
        "rule_sql": [
            "SELECT station_id, Location, Manager_Name FROM gas_station ORDER BY Open_Year;"
        ]
    },
    "730": {
        "db_id": "customers_card_transactions",
        "question": "What are the different card type codes?",
        "ground_truth": "SELECT DISTINCT card_type_code FROM Customers_Cards",
        "amends": [
            "Do reference `card_type_code` instead of `card_type` in the SELECT list. Do query from `Customers_Cards` table instead of `cards` table. The amended query now correctly retrieves distinct card type codes from the appropriate customer cards table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"card type codes\": use the exact column token \"card_type_code\" from the Customers_Cards table. 2) When retrieving distinct values from the Customers_Cards table: compute unique values of the \"card_type_code\" column. 3) When querying the Customers_Cards table: reference the table using its exact name \"Customers_Cards\" without any aliases."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT card_type FROM cards;",
            "SELECT DISTINCT card_type_code FROM Customers_Cards;"
        ],
        "rule_sql": [
            "SELECT DISTINCT card_type_code FROM Customers_Cards"
        ]
    },
    "3259": {
        "db_id": "college_1",
        "question": "List the first name of all employees with job code PROF ordered by their date of birth.",
        "ground_truth": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' ORDER BY emp_dob",
        "amends": [
            "Do reference column `emp_fname` instead of `first_name` in the SELECT list. Do reference table `employee` instead of `employees` in the FROM clause. Do use filter condition `emp_jobcode = 'PROF'` instead of `job_code = 'PROF'` in the WHERE clause. Do order by `emp_dob` instead of `hire_date` in the ORDER BY clause. The amended query now correctly references the appropriate schema elements and matches the intended behavior."
        ],
        "rules": [
            "1) When selecting employee first names: use the exact column token \"emp_fname\" from the employee table. 2) When referring to the employee table: use the exact table name \"employee\" (not \"employees\"). 3) When filtering by job code PROF: use the exact condition \"emp_jobcode = 'PROF'\" with the literal 'PROF' exactly as specified. 4) When ordering by date of birth: use the exact column token \"emp_dob\" for ordering instead of hire date."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM employees WHERE job_code = 'PROF' ORDER BY hire_date;",
            "SELECT emp_fname FROM employee WHERE emp_jobcode = 'PROF' ORDER BY emp_dob;"
        ],
        "rule_sql": [
            "SELECT emp_fname FROM employee WHERE emp_jobcode = 'PROF' ORDER BY emp_dob"
        ]
    },
    "6311": {
        "db_id": "e_government",
        "question": "What are the different types of forms?",
        "ground_truth": "SELECT DISTINCT form_type_code FROM forms",
        "amends": [
            "Do select only `form_type_code` instead of all columns with `*`. Do add `DISTINCT` instead of omitting it to return unique values. Do remove the `WHERE type = 'all'` filter instead of keeping it, as the right query returns all distinct form types without filtering. The amended query now correctly returns unique form type codes from the forms table without unnecessary filtering, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"different types of forms\": make sure the output order: form_type_code. 2) When the question asks for \"different types\": return only distinct values of form_type_code instead of all values. 3) When the question does not specify any filtering condition: do not apply any WHERE clause filters like type = 'all'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM forms WHERE type = 'all';",
            "SELECT DISTINCT form_type_code FROM Forms;"
        ],
        "rule_sql": [
            "SELECT DISTINCT form_type_code FROM Forms ORDER BY form_type_code;"
        ]
    },
    "4802": {
        "db_id": "aircraft",
        "question": "What is the average number of international passengers for an airport?",
        "ground_truth": "SELECT avg(International_Passengers) FROM airport",
        "amends": [
            "Do use `avg(International_Passengers)` instead of `AVG(domestic_passengers)` to calculate the average of international passengers rather than domestic passengers. Do reference the `airport` table instead of `airports` to use the correct table name. The amended query now correctly calculates the average international passengers from the airport table."
        ],
        "rules": [
            "1) When the question asks for average number of international passengers: use avg(International_Passengers) to calculate the average. 2) When referencing the airport data: use the table named \"airport\" instead of \"airports\". 3) When computing averages: ensure the calculation is performed on the exact column token International_Passengers as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(domestic_passengers) FROM airports;",
            "SELECT AVG(International_Passengers) FROM airport"
        ],
        "rule_sql": [
            "SELECT AVG(International_Passengers) AS average_international_passengers FROM airport;"
        ]
    },
    "5214": {
        "db_id": "music_2",
        "question": "How many instrument does the musician with last name \"Heilo\" use?",
        "ground_truth": "SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN Band AS T2 ON T1.bandmateid  =  T2.id WHERE T2.lastname  =  \"Heilo\"",
        "amends": [
            "Do select `count(DISTINCT instrument)` instead of `COUNT(*)`. Do change the FROM clause to join `instruments AS T1` with `Band AS T2` on `T1.bandmateid = T2.id` instead of querying only the `musicians` table. Do filter on `T2.lastname = \"Heilo\"` instead of `last_name = 'Heilo'`. The amended query now correctly counts distinct instruments played by band members with the last name Heilo instead of counting all musicians with that last name."
        ],
        "rules": [
            "1) When the question asks about \"instrument\" count for a musician: use the \"instrument\" column from the \"instruments\" table (aliased as T1) instead of counting all rows. 2) When joining tables for musician information: combine \"instruments AS T1\" with \"Band AS T2\" using the exact key equality \"T1.bandmateid = T2.id\" and keep only matching pairs (inner match). 3) When filtering for last name \"Heilo\": use the exact literal \"Heilo\" with the exact column token \"T2.lastname\" (not 'last_name'). 4) When counting distinct instruments: compute the number of unique values in \"T1.instrument\" column rather than counting all rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM musicians WHERE last_name = 'Heilo';",
            "SELECT COUNT(DISTINCT T1.Instrument) \nFROM Instruments AS T1 \nJOIN Band AS T2 ON T1.BandmateId = T2.Id \nWHERE T2.Lastname = 'Heilo'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.instrument) \nFROM Instruments AS T1 \nINNER JOIN Band AS T2 ON T1.BandmateId = T2.Id \nWHERE T2.Lastname = 'Heilo';"
        ]
    },
    "923": {
        "db_id": "insurance_fnol",
        "question": "Find the names of customers who have used both the service \"Close a policy\" and the service \"New policy application\".",
        "ground_truth": "SELECT t1.customer_name FROM customers AS t1 JOIN first_notification_of_loss AS t2 ON t1.customer_id  =  t2.customer_id JOIN services AS t3 ON t2.service_id  =  t3.service_id WHERE t3.service_name  =  \"Close a policy\" INTERSECT SELECT t1.customer_name FROM customers AS t1 JOIN first_notification_of_loss AS t2 ON t1.customer_id  =  t2.customer_id JOIN services AS t3 ON t2.service_id  =  t3.service_id WHERE t3.service_name  =  \"New policy application\"",
        "amends": [
            "Do select `customer_name` instead of `name` and remove `DISTINCT` instead of keeping it. Do join `first_notification_of_loss` as `t2` on `t1.customer_id=t2.customer_id` instead of directly joining `services` twice, and then join `services` as `t3` on `t2.service_id=t3.service_id` instead of joining `services` directly to customers. Do use `INTERSECT` to find customers with both services instead of self-joining the same table with different conditions. Do filter for `service_name` values separately in each branch of the `INTERSECT` instead of using multiple `WHERE` conditions on the same result set. The amended query now correctly identifies customers who have both services through the proper relationship tables and uses set intersection logic instead of potentially incorrect self-join semantics."
        ],
        "rules": [
            "1) When the question asks for customer names: use the exact column token \"customer_name\" instead of \"name\". 2) When finding customers who used both \"Close a policy\" and \"New policy application\" services: use INTERSECT logic instead of self-joining the same table. 3) When joining tables to access service information: join first_notification_of_loss as T2 on T1.customer_id = T2.customer_id, then join services as T3 on T2.service_id = T3.service_id. 4) When filtering for specific service names: apply each service name filter ('Close a policy' and 'New policy application') in separate branches of the INTERSECT operation. 5) When selecting customer names: do not use DISTINCT since INTERSECT inherently returns unique results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT c.name \nFROM customers c\nJOIN services s1 ON c.customer_id = s1.customer_id\nJOIN services s2 ON c.customer_id = s2.customer_id\nWHERE s1.service_name = 'Close a policy' \nAND s2.service_name = 'New policy application';",
            "SELECT Customer_name\nFROM Customers\nWHERE Customer_ID IN (\n    SELECT t1.Customer_ID\n    FROM First_Notification_of_Loss t1\n    JOIN Services t2 ON t1.Service_ID = t2.Service_ID\n    WHERE t2.Service_name = 'Close a policy'\n    INTERSECT\n    SELECT t1.Customer_ID\n    FROM First_Notification_of_Loss t1\n    JOIN Services t2 ON t1.Service_ID = t2.Service_ID\n    WHERE t2.Service_name = 'New policy application'\n)"
        ],
        "rule_sql": [
            "SELECT customer_name\nFROM Customers\nWHERE Customer_ID IN (\n    SELECT T1.Customer_ID\n    FROM Customers_Policies T1\n    JOIN First_Notification_of_Loss T2 ON T1.Customer_ID = T2.Customer_ID\n    JOIN Services T3 ON T2.Service_ID = T3.Service_ID\n    WHERE T3.Service_name = 'Close a policy'\n    INTERSECT\n    SELECT T1.Customer_ID\n    FROM Customers_Policies T1\n    JOIN First_Notification_of_Loss T2 ON T1.Customer_ID = T2.Customer_ID\n    JOIN Services T3 ON T2.Service_ID = T3.Service_ID\n    WHERE T3.Service_name = 'New policy application'\n)"
        ]
    },
    "4712": {
        "db_id": "department_store",
        "question": "Give the id and product type of the product with the lowest price.",
        "ground_truth": "SELECT product_id ,  product_type_code FROM products ORDER BY product_price LIMIT 1",
        "amends": [
            "Do use `product_id` and `product_type_code` in the SELECT list instead of `id` and `product_type`. Do order by `product_price` instead of `price`. The amended query now correctly references the appropriate column names and matches the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"id\" of a product: use \"product_id\" from the Products table instead of \"id\". 2) When the question asks for \"product type\" of a product: use \"product_type_code\" from the Products table instead of \"product_type\". 3) When ordering products by price to find the lowest price: use \"product_price\" from the Products table instead of \"price\" and sort in ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, product_type FROM products ORDER BY price ASC LIMIT 1;",
            "SELECT product_id, product_type_code FROM Products ORDER BY product_price ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT product_id, product_type_code FROM Products ORDER BY product_price ASC LIMIT 1;"
        ]
    },
    "4197": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "Find the number of employees we have.",
        "ground_truth": "SELECT count(*) FROM Employees",
        "amends": [
            "Do select from `Employees` table instead of `customers` table. The amended query now correctly counts records from the Employees table as specified in the target query."
        ],
        "rules": [
            "1) When answering about \"number of employees\": make sure to count from the \"Employees\" table instead of the \"customers\" table. 2) When counting entities: use the canonical counting method that counts all records from the specified table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers;",
            "SELECT COUNT(*) FROM Employees;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS number_of_employees FROM Employees;"
        ]
    },
    "2922": {
        "db_id": "icfp_1",
        "question": "Retrieve all the first and last names of authors in the alphabetical order of last names.",
        "ground_truth": "SELECT fname ,  lname FROM authors ORDER BY lname",
        "amends": [
            "Do select `fname` and `lname` instead of `first_name` and `last_name` in the SELECT list. Do order by `lname` instead of `first_name ASC` in the ORDER BY clause. The amended query now correctly retrieves and sorts by the appropriate column names to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"first and last names\": select \"fname\" and \"lname\" columns from the Authors table. 2) When the question specifies \"alphabetical order of last names\": order the results by the \"lname\" column in ascending order. 3) When choosing identifier names: use the exact column names \"fname\" and \"lname\" as shown in the schema, not alternative names like \"first_name\" or \"last_name\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM authors ORDER BY first_name ASC;",
            "SELECT fname, lname FROM Authors ORDER BY lname;"
        ],
        "rule_sql": [
            "SELECT fname, lname FROM Authors ORDER BY lname ASC;"
        ]
    },
    "4081": {
        "db_id": "student_1",
        "question": "For each grade, return the grade number, the number of classrooms used for the grade, and the total number of students enrolled in the grade.",
        "ground_truth": "SELECT grade ,  count(DISTINCT classroom) ,  count(*) FROM list GROUP BY grade",
        "amends": [
            "Do `count(DISTINCT classroom)` instead of `COUNT(classroom)` to count unique classrooms rather than all classroom occurrences. Do `count(*)` instead of `SUM(students)` to count the total number of records rather than summing student counts. Do reference table `list` instead of `grades` to query from the correct data source. The amended query now correctly counts distinct classrooms and total records per grade group."
        ],
        "rules": [
            "1) When answering about \"number of classrooms used for the grade\": count distinct values of the \"classroom\" column using count(DISTINCT classroom). 2) When answering about \"total number of students enrolled in the grade\": count all records using count(*) instead of summing student counts. 3) When querying data about grades and classrooms: use the \"list\" table instead of the \"grades\" table as the data source. 4) When grouping results by grade: organize the output by the \"grade\" column and compute aggregates per grade group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT grade, COUNT(classroom), SUM(students) \nFROM grades \nGROUP BY grade;",
            "SELECT Grade, COUNT(DISTINCT Classroom) AS NumberOfClassrooms, COUNT(*) AS TotalStudents FROM list GROUP BY Grade;"
        ],
        "rule_sql": [
            "SELECT Grade, COUNT(DISTINCT Classroom) AS NumberOfClassrooms, COUNT(*) AS TotalStudents FROM list GROUP BY Grade ORDER BY Grade;"
        ]
    },
    "978": {
        "db_id": "university_basketball",
        "question": "What are the different schools and their nicknames, ordered by their founding years?",
        "ground_truth": "SELECT school ,  nickname FROM university ORDER BY founded",
        "amends": [
            "Do select `school` instead of `school_name` and change the source table to `university` instead of `schools`. Do order by `founded` instead of `nickname`. The amended query now correctly retrieves data from the university table and sorts by the founded date rather than nickname."
        ],
        "rules": [
            "1) When the question asks for schools and their nicknames: select \"school\" and \"nickname\" columns from the \"university\" table. 2) When ordering results by founding years: order by the \"founded\" column instead of nickname. 3) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for column names like \"school\" and \"nickname\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT school_name, nickname FROM schools ORDER BY nickname;",
            "SELECT School, Nickname FROM university ORDER BY Founded;"
        ],
        "rule_sql": [
            "SELECT \"School\", \"Nickname\" FROM \"university\" ORDER BY \"Founded\";"
        ]
    },
    "4105": {
        "db_id": "company_employee",
        "question": "Show the headquarters that have both companies in banking industry and companies in oil and gas industry.",
        "ground_truth": "SELECT Headquarters FROM company WHERE Industry  =  \"Banking\" INTERSECT SELECT Headquarters FROM company WHERE Industry  =  \"Oil and gas\"",
        "amends": [
            "Do use `INTERSECT` to find common headquarters instead of a self-join with duplicate filtering. Do query the `company` table directly instead of using aliased `companies` table joins. Do filter for `\"Banking\"` industry in the first branch instead of `'banking'` with incorrect case handling. Do filter for `\"Oil and gas\"` industry in the second branch instead of `'oil and gas'` with inconsistent quoting. Do remove the `DISTINCT` keyword since `INTERSECT` inherently returns unique values instead of keeping redundant distinct filtering. Do use proper double quotes for string literals instead of single quotes for consistency. The amended query now correctly identifies headquarters shared between banking and oil/gas companies using set intersection semantics."
        ],
        "rules": [
            "1) When the question asks for headquarters that have both companies in banking industry and companies in oil and gas industry: use INTERSECT to find common headquarters instead of self-join with duplicate filtering. 2) When filtering for banking industry: use the exact literal \"Banking\" with double quotes and proper case instead of 'banking'. 3) When filtering for oil and gas industry: use the exact literal \"Oil and gas\" with double quotes and proper case instead of 'oil and gas'. 4) When using INTERSECT operations: remove DISTINCT keyword since INTERSECT inherently returns unique values. 5) When handling string literals: always use double quotes for consistency instead of single quotes. 6) When querying the company table: use the exact table name \"company\" directly instead of aliased \"companies\" table joins."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT hq.headquarters\nFROM companies c1\nJOIN companies c2 ON c1.headquarters = c2.headquarters\nWHERE c1.industry = 'banking' AND c2.industry = 'oil and gas';",
            "SELECT Headquarters FROM company WHERE Industry = \"Banking\" INTERSECT SELECT Headquarters FROM company WHERE Industry = \"Oil and gas\""
        ],
        "rule_sql": [
            "SELECT Headquarters FROM company WHERE Industry = \"Banking\" INTERSECT SELECT Headquarters FROM company WHERE Industry = \"Oil and gas\""
        ]
    },
    "3819": {
        "db_id": "e_learning",
        "question": "Find the the date of enrollment of the \"Spanish\" course.",
        "ground_truth": "SELECT T2.date_of_enrolment FROM Courses AS T1 JOIN Student_Course_Enrolment AS T2 ON T1.course_id  =  T2.course_id WHERE T1.course_name  =  \"Spanish\"",
        "amends": [
            "Do select `T2.date_of_enrolment` from the Student_Course_Enrolment table instead of `enrollment_date` from the Courses table. Do add a `JOIN` between `Courses AS T1` and `Student_Course_Enrolment AS T2` with the predicate `T1.course_id = T2.course_id` instead of querying only the Courses table. Do use double quotes around `\"Spanish\"` instead of single quotes for the string literal. The amended query now correctly retrieves enrollment dates from the join table rather than assuming the enrollment date exists directly in the Courses table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"date of enrollment of the Spanish course\": make sure the output order: T2.date_of_enrolment. 2) When the question mentions \"Spanish\": \"Spanish\" actually means \"Spanish\" in schema and must be enclosed in double quotes exactly as \"Spanish\". 3) When combining Courses as T1 and Student_Course_Enrolment as T2: link rows where T1.course_id = T2.course_id and keep only matching pairs (inner match). 4) When selecting enrollment date: use T2.date_of_enrolment from Student_Course_Enrolment table instead of enrollment_date from Courses table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT enrollment_date FROM courses WHERE course_name = 'Spanish';",
            "SELECT T2.date_of_enrolment \nFROM Courses AS T1 \nJOIN Student_Course_Enrolment AS T2 ON T1.course_id = T2.course_id \nWHERE T1.course_name = \"Spanish\""
        ],
        "rule_sql": [
            "SELECT T2.date_of_enrolment\nFROM Courses AS T1\nINNER JOIN Student_Course_Enrolment AS T2 ON T1.course_id = T2.course_id\nWHERE T1.course_name = \"Spanish\""
        ]
    },
    "3854": {
        "db_id": "insurance_policies",
        "question": "List the method, date and amount of all the payments, in ascending order of date.",
        "ground_truth": "SELECT Payment_Method_Code ,  Date_Payment_Made ,  Amount_Payment FROM Payments ORDER BY Date_Payment_Made ASC",
        "amends": [
            "Do use exact column names `Payment_Method_Code`, `Date_Payment_Made`, and `Amount_Payment` instead of generic names `method`, `date`, and `amount`. Do sort by `Date_Payment_Made` in ascending order instead of descending order. The amended query now correctly references the actual column names from the Payments table and sorts the results in chronological order rather than reverse chronological order, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"method\": use the exact column name \"Payment_Method_Code\" from the Payments table. 2) When the question asks for \"date\": use the exact column name \"Date_Payment_Made\" from the Payments table. 3) When the question asks for \"amount\": use the exact column name \"Amount_Payment\" from the Payments table. 4) When the question specifies \"ascending order of date\": sort the results by \"Date_Payment_Made\" in ascending (chronological) order rather than descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT method, date, amount FROM payments ORDER BY date DESC;",
            "SELECT Payment_Method_Code, Date_Payment_Made, Amount_Payment FROM Payments ORDER BY Date_Payment_Made ASC;"
        ],
        "rule_sql": [
            "SELECT Payment_Method_Code, Date_Payment_Made, Amount_Payment FROM Payments ORDER BY Date_Payment_Made ASC;"
        ]
    },
    "3166": {
        "db_id": "station_weather",
        "question": "Give me the maximum low temperature and average precipitation at the Amersham station.",
        "ground_truth": "SELECT max(t1.low_temperature) ,  avg(t1.precipitation) FROM weekly_weather AS t1 JOIN station AS t2 ON t1.station_id  =  t2.id WHERE t2.network_name  =  \"Amersham\"",
        "amends": [
            "Do select `max(t1.low_temperature)` and `avg(t1.precipitation)` instead of `MAX(high_temperature)` and `AVG(precipitation)`. Do use `FROM weekly_weather AS t1 JOIN station AS t2` instead of `FROM weather_data`. Do add `ON t1.station_id = t2.id` join condition instead of omitting it. Do change filter to `WHERE t2.network_name = \"Amersham\"` instead of `WHERE station = 'Amersham'`. The amended query now correctly joins tables and filters by network name rather than a potentially ambiguous station field."
        ],
        "rules": [
            "1) When answering about maximum low temperature and average precipitation: make sure the output order: max(low_temperature) then avg(precipitation). 2) When the question mentions \"Amersham station\": \"Amersham\" actually means \"network_name = 'Amersham'\" in schema. 3) When combining weekly_weather and station tables: link rows where t1.station_id = t2.id exactly as shown; keep only matching pairs (inner match). 4) When computing maximum low temperature: compute max(t1.low_temperature) using the exact column token. 5) When computing average precipitation: compute avg(t1.precipitation) using the exact column token."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(high_temperature), AVG(precipitation) FROM weather_data WHERE station = 'Amersham';",
            "SELECT MAX(t1.low_temperature), AVG(t1.precipitation) FROM weekly_weather AS t1 JOIN station AS t2 ON t1.station_id = t2.id WHERE t2.network_name = 'Amersham'"
        ],
        "rule_sql": [
            "SELECT MAX(ww.low_temperature) AS max_low_temperature, AVG(ww.precipitation) AS avg_precipitation\nFROM weekly_weather ww\nJOIN station s ON ww.station_id = s.id\nWHERE s.network_name = 'Amersham';"
        ]
    },
    "5255": {
        "db_id": "music_2",
        "question": "What are the types of vocals that the band member with the first name \"Solveig\" played the most?",
        "ground_truth": "SELECT TYPE FROM vocals AS T1 JOIN band AS T2 ON T1.bandmate  =  T2.id WHERE firstname  =  \"Solveig\" GROUP BY TYPE ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `TYPE` instead of `v.type, COUNT(*) as count`. Do join `band` table instead of `band_members` table. Do use join condition `T1.bandmate = T2.id` instead of `bm.member_id = v.member_id`. Do filter on `firstname = \"Solveig\"` instead of `bm.first_name = 'Solveig'`. Do group by `TYPE` instead of `v.type`. Do order by `count(*) DESC` instead of `count DESC`. The amended query now correctly retrieves the vocal type for Solveig by joining vocals with band table using the proper relationship between bandmate and id fields."
        ],
        "rules": [
            "1) When answering about \"types of vocals that the band member with the first name Solveig played the most\": make sure the output order: TYPE. 2) When the question mentions \"band member\": use the \"band\" table (T1) instead of \"band_members\" table. 3) When combining T1 and T2 for shared entities: link rows where T1.bandmate = T2.id exactly as shown; keep only matching pairs (inner match). 4) When filtering for first name \"Solveig\": use exact literal \"Solveig\" with column firstname from T1. 5) When the question asks for \"most played\" vocal types: rank rows by count(*) in descending order and keep the first 1 row. 6) When grouping by vocal type: organize results by TYPE from T2 and compute count per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT v.type, COUNT(*) as count\nFROM band_members bm\nJOIN vocals v ON bm.member_id = v.member_id\nWHERE bm.first_name = 'Solveig'\nGROUP BY v.type\nORDER BY count DESC\nLIMIT 1;",
            "SELECT v.Type, COUNT(*) as count\nFROM Vocals v\nJOIN Band b ON v.Bandmate = b.Id\nWHERE b.Firstname = 'Solveig'\nGROUP BY v.Type\nORDER BY COUNT(*) DESC;"
        ],
        "rule_sql": [
            "SELECT v.Type\nFROM Vocals v\nJOIN Band b ON v.Bandmate = b.Id\nWHERE b.Firstname = 'Solveig'\nGROUP BY v.Type\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "5937": {
        "db_id": "cre_Theme_park",
        "question": "Show the average price of hotels for different pet policy.",
        "ground_truth": "SELECT pets_allowed_yn ,  avg(price_range) FROM HOTELS GROUP BY pets_allowed_yn",
        "amends": [
            "Do use column name `pets_allowed_yn` instead of `pet_policy` in both the SELECT list and GROUP BY clause. Do use column name `price_range` instead of `price` in the AVG aggregate function. Do reference table name `HOTELS` instead of `hotels` to match the correct schema. The amended query now correctly calculates average price ranges grouped by pet allowance status using the appropriate column names and table reference."
        ],
        "rules": [
            "1) When the question mentions \"pet policy\": \"pet policy\" actually means \"pets_allowed_yn\" in the schema. 2) When the question mentions \"price\": \"price\" actually means \"price_range\" in the schema. 3) When the question asks for \"average price of hotels for different pet policy\": compute the average of \"price_range\" grouped by \"pets_allowed_yn\". 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table name \"HOTELS\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pet_policy, AVG(price) FROM hotels GROUP BY pet_policy;",
            "SELECT pets_allowed_yn, AVG(price_range) AS average_price FROM Hotels GROUP BY pets_allowed_yn;"
        ],
        "rule_sql": [
            "SELECT pets_allowed_yn, AVG(price_range) AS average_price FROM Hotels GROUP BY pets_allowed_yn"
        ]
    },
    "3930": {
        "db_id": "hospital_1",
        "question": "Find the name of physicians who are in charge of more than one patient.",
        "ground_truth": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1",
        "amends": [
            "Do select `T1.name` with table alias qualification instead of just `name`. Do use `FROM physician AS T1 JOIN patient AS T2` with explicit table aliases and a JOIN instead of `FROM physicians` alone. Do specify the join condition `ON T1.employeeid = T2.PCP` instead of no join condition. Do add `GROUP BY T1.employeeid` to group by physician instead of no grouping. Do move the count filter to `HAVING count(*) > 1` instead of `WHERE patient_count > 1` since the count is an aggregate that must be evaluated after grouping. The amended query now correctly counts patients per physician and filters for those with more than one patient, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about physicians in charge of patients: combine physician table as T1 and patient table as T2 using an inner match where T1.employeeid equals T2.PCP. 2) When grouping by physician: use T1.employeeid as the grouping key to organize results per physician. 3) When counting patients per physician: compute the count of rows in each group using count(*). 4) When filtering for physicians with more than one patient: apply the condition count(*) > 1 after grouping. 5) When selecting physician names: output T1.name from the physician table with table alias qualification."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM physicians WHERE patient_count > 1",
            "SELECT T1.Name FROM Physician AS T1 JOIN Patient AS T2 ON T1.EmployeeID = T2.PCP GROUP BY T1.EmployeeID HAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T1.Name \nFROM Physician AS T1 \nINNER JOIN Patient AS T2 ON T1.EmployeeID = T2.PCP \nGROUP BY T1.EmployeeID \nHAVING COUNT(*) > 1"
        ]
    },
    "2061": {
        "db_id": "party_people",
        "question": "Show all party names and their region names.",
        "ground_truth": "SELECT T1.party_name ,  T2.region_name FROM party AS T1 JOIN region AS T2 ON T1.region_id  =  T2.region_id",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference `T1.party_name` and `T2.region_name` with explicit aliases instead of unqualified column names. Do join `party AS T1` and `region AS T2` with explicit table aliases instead of `parties` and `regions` without aliases. Do use the join condition `T1.region_id = T2.region_id` instead of `parties.region_id = regions.id`. The amended query now correctly matches the intended behavior with proper table aliasing and join conditions."
        ],
        "rules": [
            "1) When answering about \"party names and their region names\": make sure the output order: T1.party_name, T2.region_name. 2) When combining T1 and T2 for shared entities: link rows where T1.region_id = T2.region_id exactly as shown in the amends; keep only matching pairs (inner match). 3) When the question mentions \"party names\": \"party names\" actually means \"T1.party_name in schema\". 4) When the question mentions \"region names\": \"region names\" actually means \"T2.region_name in schema\". 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT party_name, region_name FROM parties JOIN regions ON parties.region_id = regions.id;",
            "SELECT T1.Party_name, T2.Region_name FROM party AS T1 JOIN region AS T2 ON T1.Region_ID = T2.Region_ID"
        ],
        "rule_sql": [
            "SELECT p.\"Party_name\", r.\"Region_name\" FROM \"party\" p INNER JOIN \"region\" r ON p.\"Region_ID\" = r.\"Region_ID\""
        ]
    },
    "289": {
        "db_id": "twitter_1",
        "question": "Find the id of users who are followed by Mary or Susan.",
        "ground_truth": "SELECT T2.f1 FROM user_profiles AS T1 JOIN follows AS T2 ON T1.uid  =  T2.f2 WHERE T1.name  =  \"Mary\" OR T1.name  =  \"Susan\"",
        "amends": [
            "Do use explicit `JOIN` syntax with `user_profiles AS T1` and `follows AS T2` instead of a subquery with `users` table. Do reference `T2.f1` instead of `follower_id` in the SELECT list. Do join on `T1.uid = T2.f2` instead of using `IN` with `followed_id` and subquery. Do filter directly on `T1.name` with `= \"Mary\" OR T1.name = \"Susan\"` instead of the subquery condition. Do remove the subquery structure entirely instead of keeping it. The amended query now correctly joins user profiles to follows and returns follower IDs for specified users, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"users who are followed by Mary or Susan\": use explicit JOIN syntax with user_profiles as T1 and follows as T2 instead of subqueries. 2) When selecting follower IDs: reference T2.f1 instead of follower_id in the output. 3) When joining user_profiles and follows tables: link rows where T1.uid = T2.f2 exactly. 4) When filtering for specific users: apply the condition T1.name = \"Mary\" OR T1.name = \"Susan\" directly on the joined table. 5) When the question mentions \"Mary\" or \"Susan\": use the exact string literals \"Mary\" and \"Susan\" with double quotes as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT follower_id FROM follows WHERE followed_id IN (SELECT id FROM users WHERE name = 'Mary' OR name = 'Susan')",
            "SELECT T2.f1\nFROM user_profiles AS T1\nJOIN follows AS T2 ON T1.uid = T2.f2\nWHERE T1.name = 'Mary' OR T1.name = 'Susan'"
        ],
        "rule_sql": [
            "SELECT T2.f1 FROM user_profiles AS T1 JOIN follows AS T2 ON T1.uid = T2.f2 WHERE T1.name = \"Mary\" OR T1.name = \"Susan\""
        ]
    },
    "5120": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "Which city is the address of the store named \"FJA Filming\" located in?",
        "ground_truth": "SELECT T1.City_Town FROM Addresses AS T1 JOIN Stores AS T2 ON T1.Address_ID  =  T2.Address_ID WHERE T2.Store_Name  =  \"FJA Filming\"",
        "amends": [
            "Do join `Addresses AS T1` and `Stores AS T2` on `T1.Address_ID = T2.Address_ID` instead of querying only the `stores` table. Do select `T1.City_Town` instead of `city` to get the city from the correct table. Do use the table alias `T2` in the `WHERE` clause with `T2.Store_Name = \"FJA Filming\"` instead of directly filtering on `store_name` without table qualification. The amended query now correctly joins the address and store tables to retrieve the city information associated with the specified store name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about a store's address location: join Addresses as T1 and Stores as T2 on T1.Address_ID = T2.Address_ID to link address information with store records. 2) When retrieving city information for a store: select T1.City_Town instead of city to get the correct column from the Addresses table. 3) When filtering by store name: use T2.Store_Name = \"FJA Filming\" with exact table qualification and preserve the exact literal \"FJA Filming\" with double quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city FROM stores WHERE store_name = 'FJA Filming';",
            "SELECT T1.City_Town \nFROM Addresses AS T1 \nJOIN Stores AS T2 ON T1.Address_ID = T2.Address_ID \nWHERE T2.Store_Name = 'FJA Filming'"
        ],
        "rule_sql": [
            "SELECT T1.City_Town FROM Addresses AS T1 JOIN Stores AS T2 ON T1.Address_ID = T2.Address_ID WHERE T2.Store_Name = \"FJA Filming\";"
        ]
    },
    "2089": {
        "db_id": "pilot_record",
        "question": "What are the different nationalities of pilots? Show each nationality and the number of pilots of each nationality.",
        "ground_truth": "SELECT Nationality ,  COUNT(*) FROM pilot GROUP BY Nationality",
        "amends": [
            "Do use table name `pilot` instead of `pilots` and column name `Nationality` instead of `nationality` to match the correct schema. The amended query now correctly references the intended table and column names while preserving the same aggregation logic."
        ],
        "rules": [
            "1) When the question asks about \"nationalities of pilots\": use the exact table name \"pilot\" instead of \"pilots\" as shown in the schema. 2) When referring to nationality information: use the exact column name \"Nationality\" with proper capitalization as shown in the schema. 3) When counting pilots per nationality: count using the canonical key for pilots (implied by the table structure) and group by the exact \"Nationality\" column. 4) When producing output: show each nationality value followed by the count of pilots for that nationality."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT nationality, COUNT(*) FROM pilots GROUP BY nationality;",
            "SELECT Nationality, COUNT(*) AS Number_of_Pilots FROM pilot GROUP BY Nationality;"
        ],
        "rule_sql": [
            "SELECT Nationality, COUNT(Pilot_ID) AS Number_of_Pilots FROM pilot GROUP BY Nationality;"
        ]
    },
    "51": {
        "db_id": "farm",
        "question": "Which statuses correspond to both cities that have a population over 1500 and cities that have a population lower than 500?",
        "ground_truth": "SELECT Status FROM city WHERE Population  >  1500 INTERSECT SELECT Status FROM city WHERE Population  <  500",
        "amends": [
            "Do use `INTERSECT` to find common status values instead of a single range filter with `AND`. Do reference the table as `city` instead of `cities`. Do capitalize column names as `Status` and `Population` instead of lowercase `status` and `population`. Do split into two separate queries with `Population > 1500` and `Population < 500` instead of combining them with `AND`. Do remove the contradictory range condition that would return no results (since population cannot be both greater than 1500 and less than 500) instead of keeping the logically impossible filter. The amended query now correctly finds status values that appear in both the high population (>1500) and low population (<500) groups, matching RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about statuses that correspond to both high population (>1500) and low population (<500) cities: use INTERSECT to find common status values instead of combining conditions with AND. 2) When referencing the table in the schema: use the exact table name \"city\" instead of \"cities\". 3) When selecting columns: use the exact column names \"Status\" and \"Population\" with proper capitalization instead of lowercase versions. 4) When filtering for high population cities: use the condition \"Population > 1500\" as a separate query. 5) When filtering for low population cities: use the condition \"Population < 500\" as a separate query. 6) When combining results from both population groups: avoid contradictory range conditions that would return no results (since population cannot be both >1500 and <500 simultaneously)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT status FROM cities WHERE population > 1500 AND population < 500;",
            "SELECT Status FROM city WHERE Population > 1500\nINTERSECT\nSELECT Status FROM city WHERE Population < 500"
        ],
        "rule_sql": [
            "SELECT Status FROM city WHERE Population > 1500\nINTERSECT\nSELECT Status FROM city WHERE Population < 500"
        ]
    },
    "2607": {
        "db_id": "inn_1",
        "question": "What is the total number of rooms available in this inn?",
        "ground_truth": "SELECT count(*) FROM Rooms;",
        "amends": [
            "Do remove the `WHERE status = 'occupied'` filter instead of keeping it, which changes the query from counting only occupied rooms to counting all rooms in the table. Do use the correct table name `Rooms` instead of `rooms` to match the actual schema. The amended query now correctly counts all records in the Rooms table instead of filtering for occupied status only, matching the intended behavior of the right SQL."
        ],
        "rules": [
            "1) When the question asks for \"total number of rooms available\": count all records in the \"Rooms\" table without any status filters. 2) When choosing table names: use the exact table name \"Rooms\" (with capital R) instead of \"rooms\". 3) When counting entities: do not apply any WHERE conditions unless explicitly specified in the question - the question asks for total rooms, not occupied rooms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM rooms WHERE status = 'occupied';",
            "SELECT COUNT(*) FROM Rooms;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Rooms;"
        ]
    },
    "2892": {
        "db_id": "icfp_1",
        "question": "Which papers have \"Stephanie Weirich\" as an author?",
        "ground_truth": "SELECT t3.title FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid WHERE t1.fname  =  \"Stephanie\" AND t1.lname  =  \"Weirich\"",
        "amends": [
            "Do join `authors AS t1` and `authorship AS t2` on `t1.authid = t2.authid` instead of querying `papers` directly without joins. Do join `papers AS t3` on `t2.paperid = t3.paperid` instead of omitting the authorship relationship. Do filter on `t1.fname = \"Stephanie\"` and `t1.lname = \"Weirich\"` instead of using `author = 'Stephanie Weirich'` which assumes a combined name column. Do select only `t3.title` instead of `*` to return only paper titles. The amended query now correctly joins through the authorship table to find papers by the specified author and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about papers by an author: join authors as T1 and authorship as T2 on T1.authid = T2.authid, then join papers as T3 on T2.paperid = T3.paperid. 2) When the question mentions \"Stephanie Weirich\" as an author: filter on T1.fname = \"Stephanie\" and T1.lname = \"Weirich\" instead of using a combined name column. 3) When selecting output for papers by an author: return only T3.title instead of all columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM papers WHERE author = 'Stephanie Weirich';",
            "SELECT t3.title \nFROM Authors AS t1 \nJOIN Authorship AS t2 ON t1.authID = t2.authID \nJOIN Papers AS t3 ON t2.paperID = t3.paperID \nWHERE t1.fname = 'Stephanie' AND t1.lname = 'Weirich'"
        ],
        "rule_sql": [
            "SELECT T3.title FROM Authors AS T1 JOIN Authorship AS T2 ON T1.authID = T2.authID JOIN Papers AS T3 ON T2.paperID = T3.paperID WHERE T1.fname = 'Stephanie' AND T1.lname = 'Weirich'"
        ]
    },
    "664": {
        "db_id": "journal_committee",
        "question": "List the names of editors that are not on any journal committee.",
        "ground_truth": "SELECT Name FROM editor WHERE editor_id NOT IN (SELECT editor_id FROM journal_committee)",
        "amends": [
            "Do select `Name` from table `editor` instead of `name` from `editors`. Do use a `NOT IN` subquery filtering on `editor_id` from `journal_committee` instead of checking `journal_committee IS NULL`. Do remove the direct NULL check condition instead of including it. The amended query now correctly identifies editors not associated with any journal committee by checking membership through a subquery rather than relying on a potentially incorrect NULL assumption."
        ],
        "rules": [
            "1) When selecting editor names: use the exact column token \"Name\" from table \"editor\" instead of \"name\" from \"editors\". 2) When identifying editors not on any journal committee: use a NOT IN subquery filtering on \"editor_id\" from \"journal_committee\" table instead of checking for NULL values. 3) When checking for non-membership: remove any direct NULL check conditions and instead verify absence from the journal committee membership list."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM editors WHERE journal_committee IS NULL;",
            "SELECT Name FROM editor WHERE Editor_ID NOT IN (SELECT Editor_ID FROM journal_committee)"
        ],
        "rule_sql": [
            "SELECT Name FROM editor WHERE Editor_ID NOT IN (SELECT Editor_ID FROM journal_committee)"
        ]
    },
    "29": {
        "db_id": "farm",
        "question": "Count the number of different statuses.",
        "ground_truth": "SELECT count(DISTINCT Status) FROM city",
        "amends": [
            "Do `count(DISTINCT Status)` instead of `COUNT(*)` to count distinct status values rather than all rows. Do specify `FROM city` instead of `FROM table_name` to query from the correct table. The amended query now correctly counts distinct status values from the city table instead of counting all rows from an incorrect table."
        ],
        "rules": [
            "1) When counting the number of different statuses: count distinct values of the exact column \"Status\" from the \"city\" table. 2) When the question asks for \"different statuses\": this means distinct values of the \"Status\" column. 3) When querying from the database: use the exact table name \"city\" as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM table_name",
            "SELECT COUNT(DISTINCT Status) FROM city;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Status) FROM city;"
        ]
    },
    "6278": {
        "db_id": "city_record",
        "question": "Give me the temperature of Shanghai in January.",
        "ground_truth": "SELECT T2.Jan FROM city AS T1 JOIN temperature AS T2 ON T1.city_id = T2.city_id WHERE T1.city = \"Shanghai\"",
        "amends": [
            "Do select `T2.Jan` instead of `temperature` and do join `city AS T1` and `temperature AS T2` with `ON T1.city_id = T2.city_id` instead of querying a single `weather_data` table. Do filter on `T1.city = \"Shanghai\"` instead of `city = 'Shanghai' AND month = 'January'` and remove the month condition entirely. The amended query now correctly retrieves January temperatures from a normalized schema using proper table joins."
        ],
        "rules": [
            "1) When answering about \"temperature of Shanghai in January\": make sure the output order: T2.Jan\n2) When the question mentions \"Shanghai\": \"Shanghai\" actually means T1.city = \"Shanghai\" in schema\n3) When combining T1 and T2 for shared entities: link rows where T1.city_id = T2.city_id exactly as shown in the amends; keep only matching pairs (inner match)\n4) When the question mentions \"January\": \"January\" actually means T2.Jan column in schema, not a month filter condition"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT temperature FROM weather_data WHERE city = 'Shanghai' AND month = 'January';",
            "SELECT T2.Jan \nFROM city AS T1 \nJOIN temperature AS T2 ON T1.City_ID = T2.City_ID \nWHERE T1.City = 'Shanghai'"
        ],
        "rule_sql": [
            "SELECT T2.Jan FROM city T1 JOIN temperature T2 ON T1.City_ID = T2.City_ID WHERE T1.City = 'Shanghai'"
        ]
    },
    "6200": {
        "db_id": "music_4",
        "question": "How many music festivals have had each kind of result, ordered descending by count?",
        "ground_truth": "SELECT RESULT ,  COUNT(*) FROM music_festival GROUP BY RESULT ORDER BY COUNT(*) DESC",
        "amends": [
            "Do reference table `music_festival` instead of `music_festivals`. Do order by `COUNT(*) DESC` instead of `count ASC`. Do remove the alias `as count` from the aggregate function instead of keeping it. Do use uppercase `RESULT` in both SELECT and GROUP BY clauses instead of lowercase `result`. The amended query now correctly counts results from the music_festival table and orders them in descending frequency."
        ],
        "rules": [
            "1) When answering about \"how many music festivals have had each kind of result\": organize results by the exact token \"RESULT\" and compute the count of festivals per group. 2) When counting music festivals: compute the number of rows using all matching rows from the music_festival table. 3) When the question asks for ordering descending by count: rank rows by the count value in descending order (highest count first). 4) When choosing table identifiers: use the exact table name \"music_festival\" instead of \"music_festivals\". 5) When referring to column identifiers: use the exact uppercase token \"RESULT\" in both selection and grouping operations. 6) When computing aggregates: do not assign aliases to aggregate functions like COUNT(*)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT result, COUNT(*) as count FROM music_festivals GROUP BY result ORDER BY count ASC;",
            "SELECT RESULT, COUNT(*) FROM music_festival GROUP BY RESULT ORDER BY COUNT(*) DESC;"
        ],
        "rule_sql": [
            "SELECT RESULT, COUNT(*) FROM music_festival GROUP BY RESULT ORDER BY COUNT(*) DESC"
        ]
    },
    "1297": {
        "db_id": "soccer_1",
        "question": "List all player names who have an overall rating higher than the average.",
        "ground_truth": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.overall_rating  >  ( SELECT avg(overall_rating) FROM Player_Attributes )",
        "amends": [
            "Do select `T1.player_name` with `DISTINCT` instead of `name` without distinct. Do join `Player AS T1` with `Player_Attributes AS T2` on `T1.player_api_id = T2.player_api_id` instead of querying only the `players` table. Do filter on `T2.overall_rating` instead of `overall_rating` from the base table. Do use the subquery against `Player_Attributes` for the average calculation instead of against the base `players` table. The amended query now correctly joins the player and attributes tables, uses distinct player names, and compares against the proper average rating from the attributes table."
        ],
        "rules": [
            "1) When answering about \"player names\": make sure the output order: T1.player_name with DISTINCT to avoid duplicates. 2) When the question mentions \"overall rating\": \"overall rating\" actually means \"T2.overall_rating\" from the Player_Attributes table. 3) When combining Player AS T1 and Player_Attributes AS T2: link rows where T1.player_api_id = T2.player_api_id and keep only matching pairs (inner match). 4) When calculating average overall rating: compute the average of T2.overall_rating from the Player_Attributes table instead of the base players table. 5) When filtering for ratings higher than average: compare T2.overall_rating against the computed average from Player_Attributes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM players WHERE overall_rating > (SELECT AVG(overall_rating) FROM players);",
            "SELECT DISTINCT T1.player_name\nFROM Player AS T1\nJOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id\nWHERE T2.overall_rating > (\n    SELECT AVG(overall_rating)\n    FROM Player_Attributes\n)"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.player_name\nFROM Player AS T1\nINNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id\nWHERE T2.overall_rating > (SELECT AVG(overall_rating) FROM Player_Attributes)\nORDER BY T1.player_name;"
        ]
    },
    "339": {
        "db_id": "product_catalog",
        "question": "How many products are there in the records?",
        "ground_truth": "SELECT count(*) FROM catalog_contents",
        "amends": [
            "Do query the `catalog_contents` table instead of the `products` table. Do remove the `WHERE id = 1` filter instead of keeping it. The amended query now correctly counts all records in the catalog_contents table without any filtering condition."
        ],
        "rules": [
            "1) When answering about \"how many products are there in the records\": query the \"catalog_contents\" table instead of the \"products\" table. 2) When counting all records without filtering conditions: remove any WHERE clause filters such as \"WHERE id = 1\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM products WHERE id = 1;",
            "SELECT COUNT(*) FROM Catalog_Contents;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Catalog_Contents;"
        ]
    },
    "3665": {
        "db_id": "baseball_1",
        "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?",
        "ground_truth": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';",
        "amends": [
            "Do select `max(T1.wins)` from the `postseason` table instead of `MAX(score)` from the `games` table. Do join `team AS T2` on `T1.team_id_winner = T2.team_id_br` instead of querying a single table. Do filter on `T2.name = 'Boston Red Stockings'` instead of `team = 'Boston Red Stockings' AND postseason = 'won'`. Do remove the `WHERE postseason = 'won'` condition entirely since the join on `team_id_winner` implicitly handles this logic. The amended query now correctly retrieves maximum wins from postseason results for the specified team instead of attempting to find maximum scores from a games table with incorrect filtering logic."
        ],
        "rules": [
            "1) When answering about \"maximum scores of the team Boston Red Stockings when the team won in postseason\": use max(T1.wins) from the postseason table instead of MAX(score) from the games table. 2) When joining tables for this question: link postseason as T1 and team as T2 where T1.team_id_winner = T2.team_id_br. 3) When filtering for the team Boston Red Stockings: use T2.name = 'Boston Red Stockings' instead of team = 'Boston Red Stockings' AND postseason = 'won'. 4) When handling postseason win logic: do not include WHERE postseason = 'won' condition since the join on team_id_winner implicitly handles this logic."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(score) FROM games WHERE team = 'Boston Red Stockings' AND postseason = 'won'",
            "SELECT MAX(T1.wins) \nFROM postseason AS T1\nJOIN team AS T2 ON T1.team_id_winner = T2.team_id_br\nWHERE T2.name = 'Boston Red Stockings'"
        ],
        "rule_sql": [
            "SELECT MAX(T1.wins) AS max_score\nFROM postseason T1\nJOIN team T2 ON T1.team_id_winner = T2.team_id_br\nWHERE T2.name = 'Boston Red Stockings';"
        ]
    },
    "4787": {
        "db_id": "department_store",
        "question": "Find the names of customers who have bought by at least three distinct products.",
        "ground_truth": "SELECT DISTINCT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id JOIN order_items AS T3 ON T2.order_id  =  T3.order_id GROUP BY T1.customer_id HAVING COUNT (DISTINCT T3.product_id)  >=  3",
        "amends": [
            "Do select `DISTINCT T1.customer_name` instead of `c.name` without distinct. Do join `customer_orders AS T2` on `T1.customer_id = T2.customer_id` instead of directly joining orders, and add `order_items AS T3` on `T2.order_id = T3.order_id` instead of omitting it. Do group by `T1.customer_id` instead of `c.id` and use `COUNT(DISTINCT T3.product_id)` instead of `COUNT(o.product_id)` to count unique products instead of all order items. The amended query now correctly identifies customers with at least 3 distinct products ordered by joining through the proper relationship tables and using distinct counting."
        ],
        "rules": [
            "1) When answering about \"customers who have bought at least three distinct products\": make sure the output order: T1.customer_name. 2) When the question mentions \"customers\": \"customers\" actually means \"T1.customer_name in schema\". 3) When combining T1 and T2 for shared entities: link rows where T1.customer_id = T2.customer_id; keep only matching pairs (inner match). 4) When combining T2 and T3 for shared entities: link rows where T2.order_id = T3.order_id; keep only matching pairs (inner match). 5) When the question asks for \"distinct products\": compute the number of unique values of T3.product_id. 6) When the question asks for \"count of distinct products\": compute COUNT(DISTINCT T3.product_id) using the canonical key T3.product_id. 7) When the question says \"at least three distinct products\": filter groups where COUNT(DISTINCT T3.product_id) >= 3. 8) When the question asks for \"customers who have bought\": organize results by T1.customer_id and compute requested aggregates per customer."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name \nFROM customers c\nJOIN orders o ON c.id = o.customer_id\nGROUP BY c.id\nHAVING COUNT(o.product_id) >= 3;",
            "SELECT DISTINCT T1.customer_name\nFROM Customers AS T1\nJOIN Customer_Orders AS T2 ON T1.customer_id = T2.customer_id\nJOIN Order_Items AS T3 ON T2.order_id = T3.order_id\nGROUP BY T1.customer_id\nHAVING COUNT(DISTINCT T3.product_id) >= 3"
        ],
        "rule_sql": [
            "SELECT T1.customer_name\nFROM Customers T1\nJOIN Customer_Orders T2 ON T1.customer_id = T2.customer_id\nJOIN Order_Items T3 ON T2.order_id = T3.order_id\nGROUP BY T1.customer_id, T1.customer_name\nHAVING COUNT(DISTINCT T3.product_id) >= 3\nORDER BY T1.customer_name;"
        ]
    },
    "4879": {
        "db_id": "school_player",
        "question": "What are the team and the location of school each player belongs to?",
        "ground_truth": "SELECT T1.Team ,  T2.Location FROM player AS T1 JOIN school AS T2 ON T1.School_ID  =  T2.School_ID",
        "amends": [
            "Do select `T1.Team` and `T2.Location` instead of `player_name` and `team_name`. Do use table aliases `T1` and `T2` instead of no aliases. Do reference `player` as `T1` and `school` as `T2` instead of `players` and `teams`. Do join on `T1.School_ID = T2.School_ID` instead of `players.team_id = teams.team_id`. The amended query now correctly selects team and location information from the player and school tables with proper join conditions."
        ],
        "rules": [
            "1) When answering about \"team and location of school each player belongs to\": make sure the output order: T1.Team, T2.Location 2) When the question mentions \"team\": \"team\" actually means \"T1.Team in schema\" 3) When the question mentions \"location of school\": \"location of school\" actually means \"T2.Location in schema\" 4) When combining T1 and T2 for shared entities: link rows where T1.School_ID = T2.School_ID exactly as shown; keep only matching pairs (inner match) 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms 6) When referring to table roles: do not rename or swap the aliases T1 for player and T2 for school once set for this schema"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_name, team_name FROM players JOIN teams ON players.team_id = teams.team_id;",
            "SELECT T1.Team, T2.Location FROM player T1 JOIN school T2 ON T1.School_ID = T2.School_ID"
        ],
        "rule_sql": [
            "SELECT T1.Team, T2.Location FROM player T1 INNER JOIN school T2 ON T1.School_ID = T2.School_ID ORDER BY T1.Team, T2.Location"
        ]
    },
    "218": {
        "db_id": "book_2",
        "question": "What are the dates of publications in descending order of price?",
        "ground_truth": "SELECT Publication_Date FROM publication ORDER BY Price DESC",
        "amends": [
            "Do reference the table as `publication` instead of `publications` and use the correct column name `Publication_Date` instead of `publication_date`. Do change the sort order to `DESC` instead of `ASC` and use the correct column name `Price` instead of `price` for ordering. The amended query now correctly retrieves publication dates from the publication table ordered by price in descending order."
        ],
        "rules": [
            "1) When the question asks for dates of publications: use the exact column name \"Publication_Date\" from table \"publication\" instead of \"publication_date\" or \"publications\". 2) When ordering by price in descending order: use the exact column name \"Price\" from table \"publication\" and sort in descending order instead of ascending. 3) When answering about dates of publications in descending order of price: make sure the output order is \"Publication_Date\" sorted by \"Price\" descending."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT publication_date FROM publications ORDER BY price ASC;",
            "SELECT Publication_Date FROM publication ORDER BY Price DESC;"
        ],
        "rule_sql": [
            "SELECT Publication_Date FROM publication ORDER BY Price DESC;"
        ]
    },
    "5124": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "What is the name of the marketing region that the store Rob Dinning belongs to?",
        "ground_truth": "SELECT T1.Marketing_Region_Name FROM Marketing_Regions AS T1 JOIN Stores AS T2 ON T1.Marketing_Region_Code  =  T2.Marketing_Region_Code WHERE T2.Store_Name  =  \"Rob Dinning\"",
        "amends": [
            "Do select `T1.Marketing_Region_Name` instead of `region_name`. Do add `JOIN` between `Marketing_Regions AS T1` and `Stores AS T2` instead of querying only `stores`. Do use `ON T1.Marketing_Region_Code = T2.Marketing_Region_Code` instead of no join condition. Do keep the `WHERE T2.Store_Name = \"Rob Dinning\"` filter but reference the joined table instead of the original table. The amended query now correctly joins the tables to retrieve the marketing region name associated with the specified store."
        ],
        "rules": [
            "1) When the question asks for the marketing region name of a specific store: select T1.Marketing_Region_Name as the output column. 2) When combining Marketing_Regions and Stores tables: link rows where T1.Marketing_Region_Code = T2.Marketing_Region_Code and keep only matching pairs (inner match). 3) When filtering for a specific store name: apply the condition T2.Store_Name = \"Rob Dinning\" exactly as specified, including the exact case and spacing of the literal value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT region_name FROM stores WHERE store_name = 'Rob Dinning';",
            "SELECT T1.Marketing_Region_Name \nFROM Marketing_Regions AS T1\nJOIN Stores AS T2 ON T1.Marketing_Region_Code = T2.Marketing_Region_Code\nWHERE T2.Store_Name = 'Rob Dinning'"
        ],
        "rule_sql": [
            "SELECT T1.Marketing_Region_Name \nFROM Marketing_Regions T1 \nINNER JOIN Stores T2 ON T1.Marketing_Region_Code = T2.Marketing_Region_Code \nWHERE T2.Store_Name = 'Rob Dinning'"
        ]
    },
    "24": {
        "db_id": "farm",
        "question": "What is the average number of working horses of farms with more than 5000 total number of horses?",
        "ground_truth": "SELECT avg(Working_Horses) FROM farm WHERE Total_Horses  >  5000",
        "amends": [
            "Do reference table `farm` instead of `farms` in the FROM clause. Do use column name `Working_Horses` instead of `working_horses` in the aggregate function. Do use column name `Total_Horses` instead of `total_horses` in the WHERE filter. Do use lowercase `avg` function instead of uppercase `AVG` while maintaining the same aggregation logic. The amended query now correctly references the intended table and column names while preserving the same filtering and aggregation behavior."
        ],
        "rules": [
            "1) When answering about \"average number of working horses of farms with more than 5000 total number of horses\": make sure the output order: avg(Working_Horses). 2) When the question mentions \"farms\": \"farms\" actually means \"farm\" in schema. 3) When the question mentions \"working horses\": \"working horses\" actually means \"Working_Horses\" in schema. 4) When the question mentions \"total number of horses\": \"total number of horses\" actually means \"Total_Horses\" in schema. 5) When filtering for farms with more than 5000 total horses: include only rows where Total_Horses > 5000. 6) When computing the average: use the avg function on Working_Horses column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(working_horses) FROM farms WHERE total_horses > 5000;",
            "SELECT avg(Working_Horses) FROM farm WHERE Total_Horses > 5000"
        ],
        "rule_sql": [
            "SELECT AVG(Working_Horses) FROM farm WHERE Total_Horses > 5000"
        ]
    },
    "2162": {
        "db_id": "formula_1",
        "question": "What are the forenames and surnames of all unique drivers who had a lap time of less than 93000 milliseconds?",
        "ground_truth": "SELECT DISTINCT T1.forename ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid WHERE T2.milliseconds < 93000",
        "amends": [
            "Do add table `laptimes AS T2` with a `JOIN` on `T1.driverid = T2.driverid` instead of querying only the `drivers` table. Do change the filter to use `T2.milliseconds < 93000` instead of `lap_time < 93000` since the lap time data resides in the joined table. Do qualify all columns with table aliases `T1.forename` and `T1.surname` instead of unqualified `forename` and `surname` for clarity. The amended query now correctly joins the necessary tables and filters on the appropriate column to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"forenames and surnames of all unique drivers who had a lap time of less than 93000 milliseconds\": make sure the output order: T1.forename, T1.surname\n2) When the question mentions \"lap time\": \"lap time\" actually means \"T2.milliseconds in schema\"\n3) When combining T1 (drivers) and T2 (laptimes) for shared entities: link rows where T1.driverid = T2.driverid; keep only matching pairs (inner match)\n4) When filtering for lap times less than 93000 milliseconds: use T2.milliseconds < 93000\n5) When selecting driver names: qualify columns with table aliases as T1.forename and T1.surname\n6) When the question asks for \"unique drivers\": use DISTINCT on the combination of T1.forename and T1.surname"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT forename, surname FROM drivers WHERE lap_time < 93000;",
            "SELECT DISTINCT T1.forename, T1.surname\nFROM drivers AS T1\nJOIN lapTimes AS T2 ON T1.driverId = T2.driverId\nWHERE T2.milliseconds < 93000"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.forename, T1.surname\nFROM drivers T1\nINNER JOIN lapTimes T2 ON T1.driverId = T2.driverId\nWHERE T2.milliseconds < 93000\nORDER BY T1.forename, T1.surname"
        ]
    },
    "3383": {
        "db_id": "sports_competition",
        "question": "which country did participated in the most number of Tournament competitions?",
        "ground_truth": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do query the `competition` table instead of the `Tournament` table. Do add the filter `competition_type = 'Tournament'` in the WHERE clause instead of omitting it. Do remove the explicit column `tournament_count` from the SELECT list instead of including it. Do use `count(*)` directly in the ORDER BY clause instead of referencing an alias. Do maintain the GROUP BY on `country` and the DESC ordering with LIMIT 1 as in the original query. The amended query now correctly filters for tournament-type competitions from the appropriate table while maintaining the same result behavior of finding the country with the most tournaments."
        ],
        "rules": [
            "1) When answering about \"which country participated in the most number of Tournament competitions\": query the \"competition\" table instead of the \"Tournament\" table. 2) When filtering for tournament-type competitions: add the condition \"competition_type = 'Tournament'\" in the WHERE clause. 3) When counting competitions: use count(*) directly in the ORDER BY clause instead of referencing an alias. 4) When grouping results by country: maintain GROUP BY on \"country\" column. 5) When finding the country with the most tournaments: order by count(*) in descending direction and keep only the first row (LIMIT 1). 6) When producing output: remove any explicit column aliases like \"tournament_count\" from the SELECT list."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country, COUNT(*) as tournament_count FROM Tournament GROUP BY country ORDER BY tournament_count DESC LIMIT 1;",
            "SELECT country FROM competition WHERE Competition_type = 'Tournament' GROUP BY country ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT country FROM competition WHERE competition_type = 'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1;"
        ]
    },
    "3753": {
        "db_id": "program_share",
        "question": "Which programs are never broadcasted in the morning? Give me the names of the programs.",
        "ground_truth": "SELECT name FROM program EXCEPT SELECT t1.name FROM program AS t1 JOIN broadcast AS t2 ON t1.program_id  =  t2.program_id WHERE t2.Time_of_day  =  \"Morning\"",
        "amends": [
            "Do select `name` from `program` instead of `program_name` from `programs`. Do use `EXCEPT` to filter out morning programs instead of using `NOT LIKE '%AM%'` on `broadcast_time`. Do join `program` with `broadcast` on `program_id` instead of querying a single table. Do filter on `Time_of_day = \"Morning\"` instead of string pattern matching on time values. Do reference the correct table aliases `t1` and `t2` instead of direct table access. The amended query now correctly identifies programs that are not broadcast in the morning by using proper relational operations instead of string manipulation on time data."
        ],
        "rules": [
            "1) When answering about \"programs never broadcasted in the morning\": make sure the output order: name from program table. 2) When the question mentions \"program names\": \"program names\" actually means \"name in program table\". 3) When filtering for programs not broadcast in the morning: use EXCEPT operation to exclude programs that have Time_of_day = \"Morning\" in broadcast table. 4) When combining program and broadcast tables: link rows where t1.program_id = t2.program_id; keep only matching pairs (inner match). 5) When handling text literals: do not change case, spacing, or punctuation - use exact value \"Morning\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT program_name FROM programs WHERE broadcast_time NOT LIKE '%AM%'",
            "SELECT Name FROM program WHERE Program_ID NOT IN (SELECT Program_ID FROM broadcast WHERE Time_of_day = 'Morning')"
        ],
        "rule_sql": [
            "SELECT p.Name\nFROM program p\nEXCEPT\nSELECT p.Name\nFROM program p\nJOIN broadcast b ON p.Program_ID = b.Program_ID\nWHERE b.Time_of_day = 'Morning'"
        ]
    },
    "607": {
        "db_id": "store_1",
        "question": "How many orders does Lucas Mancini has?",
        "ground_truth": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = \"Lucas\" AND T1.last_name = \"Mancini\";",
        "amends": [
            "Do join `customers AS T1` with `invoices AS T2` on `T1.id = T2.customer_id` instead of querying only the `orders` table. Do filter on `T1.first_name = \"Lucas\"` and `T1.last_name = \"Mancini\"` instead of using `customer_name = 'Lucas Mancini'`. Do use the correct table structure with separate first and last name fields instead of a combined customer_name field. The amended query now correctly counts invoices for the specific customer instead of potentially miscounting orders with a similar name."
        ],
        "rules": [
            "1) When answering about \"How many orders does Lucas Mancini has?\": make sure the output order: COUNT(*) 2) When the question mentions \"Lucas Mancini\": \"Lucas Mancini\" actually means \"T1.first_name = 'Lucas' and T1.last_name = 'Mancini'\" in schema 3) When combining T1 and T2 for shared entities: link rows where T1.id = T2.customer_id exactly as shown in the amends; keep only matching pairs (inner match) 4) When the question asks for \"count of orders\": compute the number of rows using the canonical key token for invoices (T2) 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for T1.first_name and T1.last_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE customer_name = 'Lucas Mancini';",
            "SELECT COUNT(*) AS order_count\nFROM customers AS T1\nJOIN invoices AS T2 ON T1.id = T2.customer_id\nWHERE T1.first_name = 'Lucas' AND T1.last_name = 'Mancini'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM customers T1\nINNER JOIN invoices T2 ON T1.id = T2.customer_id\nWHERE T1.first_name = 'Lucas' AND T1.last_name = 'Mancini'"
        ]
    },
    "3195": {
        "db_id": "college_1",
        "question": "Find the number of departments in each school.",
        "ground_truth": "SELECT count(DISTINCT dept_name) ,  school_code FROM department GROUP BY school_code",
        "amends": [
            "Do `count(DISTINCT dept_name)` instead of `COUNT(*)` to count unique department names rather than all rows. Do `school_code` instead of `school` to reference the correct column name. Do change the table reference to `department` instead of `departments` to use the correct table name. Do `GROUP BY school_code` instead of `GROUP BY school` to group by the proper column identifier. The amended query now correctly counts distinct department names per school code from the department table.",
            "Do place `school_code` in the SELECT list instead of omitting it from the output columns. Do move `school_code` to the second position in the SELECT list instead of having it as the first column. Do use lowercase `school_code` and `dept_name` instead of uppercase `SCHOOL_CODE` and `DEPT_NAME` for column references. Do remove the alias `department_count` instead of keeping it for the count expression. The amended query now correctly returns both the count of distinct departments and the school code grouped by school code, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"number of departments\": count distinct values of \"DEPT_NAME\" from table \"DEPARTMENT\". 2) When the question mentions \"each school\": group results by \"SCHOOL_CODE\" column from table \"DEPARTMENT\". 3) When referencing the table containing department information: use table name \"DEPARTMENT\" (not \"departments\"). 4) When counting departments per school: use \"SCHOOL_CODE\" as the grouping column (not \"school\"). 5) When producing output columns: include both the school code and the count of distinct department names.",
            "1) When answering about \"number of departments in each school\": make sure the output order: count of distinct departments, then school_code. 2) When the question mentions \"school\": \"school\" actually means \"school_code in schema\". 3) When the question asks for \"number of departments\": compute the number of distinct values of dept_name. 4) When the question says \"per school\"/\"each school\": organize results by school_code and compute the count of distinct departments per group. 5) When choosing identifier delimiters: do not use uppercase letters for column references; use lowercase school_code and dept_name exactly as shown in the schema. 6) When producing output: do not add aliases to aggregate expressions like count(distinct dept_name)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT school, COUNT(*) FROM departments GROUP BY school;",
            "SELECT SCHOOL_CODE, COUNT(DISTINCT DEPT_NAME) AS department_count FROM DEPARTMENT GROUP BY SCHOOL_CODE;",
            "SELECT COUNT(DISTINCT dept_name), school_code FROM department GROUP BY school_code"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT dept_name) AS department_count, school_code FROM DEPARTMENT GROUP BY school_code ORDER BY department_count, school_code;"
        ]
    },
    "3169": {
        "db_id": "station_weather",
        "question": "Find the id and local authority of the station with has the highest average high temperature.",
        "ground_truth": "SELECT t2.id ,  t2.local_authority FROM weekly_weather AS t1 JOIN station AS t2 ON t1.station_id  =  t2.id GROUP BY t1.station_id ORDER BY avg(high_temperature) DESC LIMIT 1",
        "amends": [
            "Do select `t2.id` and `t2.local_authority` instead of `id`, `local_authority`, and `MAX(avg_high_temperature)`. Do use `FROM weekly_weather AS t1 JOIN station AS t2 ON t1.station_id = t2.id` instead of `FROM weather_stations` without any join. Do add `GROUP BY t1.station_id` instead of omitting grouping. Do add `ORDER BY avg(high_temperature) DESC` instead of omitting ordering. Do add `LIMIT 1` instead of omitting the limit. The amended query now correctly joins the weather and station tables, groups by station to find maximum average temperatures, and returns the top station with proper column selection."
        ],
        "rules": [
            "1) When answering about \"station with highest average high temperature\": make sure the output order: t2.id, t2.local_authority. 2) When combining weekly_weather and station tables: link rows where t1.station_id = t2.id and keep only matching pairs (inner match). 3) When the question asks for \"highest average high temperature\": group by t1.station_id, compute average of high_temperature per group, rank groups by average high_temperature in descending order, and keep only the top 1 row. 4) When selecting station information: use t2.id and t2.local_authority from the station table rather than direct columns from weather_stations."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, local_authority, MAX(avg_high_temperature) FROM weather_stations;",
            "SELECT t2.id, t2.local_authority\nFROM weekly_weather AS t1\nJOIN station AS t2 ON t1.station_id = t2.id\nGROUP BY t1.station_id\nORDER BY AVG(high_temperature) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT t2.id, t2.local_authority\nFROM weekly_weather t1\nINNER JOIN station t2 ON t1.station_id = t2.id\nGROUP BY t1.station_id\nORDER BY AVG(t1.high_temperature) DESC\nLIMIT 1"
        ]
    },
    "6649": {
        "db_id": "driving_school",
        "question": "What is the zip code of the hosue of the employee named Janessa Sawayn?",
        "ground_truth": "SELECT T1.zip_postcode FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id WHERE T2.first_name = \"Janessa\" AND T2.last_name = \"Sawayn\";",
        "amends": [
            "Do select `T1.zip_postcode` from the `Addresses` table instead of `zip_code` from the `employees` table. Do join `Staff AS T2` on `T1.address_id = T2.staff_address_id` instead of querying the `employees` table directly. Do use table aliases `T1` and `T2` instead of no aliases. Do filter on `T2.first_name` and `T2.last_name` instead of directly on the base table columns. The amended query now correctly retrieves zip code information from the Addresses table by joining with Staff data instead of incorrectly assuming zip codes are stored in an employees table."
        ],
        "rules": [
            "1) When answering about \"zip code of the house of an employee\": select T1.zip_postcode from the Addresses table instead of zip_code from employees. 2) When joining Addresses and Staff tables: link rows where T1.address_id = T2.staff_address_id and keep only matching pairs (inner match). 3) When filtering for employee named Janessa Sawayn: filter on T2.first_name = 'Janessa' AND T2.last_name = 'Sawayn' using exact name literals. 4) When using table aliases: use T1 for Addresses table and T2 for Staff table as specified in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT zip_code FROM employees WHERE first_name = 'Janessa' AND last_name = 'Sawayn';",
            "SELECT T1.zip_postcode \nFROM Addresses AS T1\nJOIN Staff AS T2 ON T1.address_id = T2.staff_address_id\nWHERE T2.first_name = 'Janessa' AND T2.last_name = 'Sawayn'"
        ],
        "rule_sql": [
            "SELECT T1.zip_postcode \nFROM Addresses T1\nINNER JOIN Staff T2 ON T1.address_id = T2.staff_address_id\nWHERE T2.first_name = 'Janessa' AND T2.last_name = 'Sawayn'"
        ]
    },
    "4697": {
        "db_id": "college_3",
        "question": "Find the last names of faculties who are members of computer science department.",
        "ground_truth": "SELECT T2.Lname FROM DEPARTMENT AS T1 JOIN FACULTY AS T2 ON T1.DNO  =  T3.DNO JOIN MEMBER_OF AS T3 ON T2.FacID  =  T3.FacID WHERE T1.DName  =  \"Computer Science\"",
        "amends": [
            "Do select `T2.Lname` instead of `first_name` and use proper table aliases. Do join `DEPARTMENT AS T1` and `FACULTY AS T2` instead of querying only `faculties` table. Do add `JOIN MEMBER_OF AS T3` with join condition `T2.FacID = T3.FacID` instead of omitting this table. Do use join condition `T1.DNO = T3.DNO` instead of missing the relationship between DEPARTMENT and MEMBER_OF tables. Do filter on `T1.DName = \"Computer Science\"` instead of `department = 'computer science'` to properly reference the department name column. The amended query now correctly retrieves faculty last names from the Computer Science department through proper table relationships and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about faculty last names in computer science department: select T2.Lname instead of first_name. 2) When combining DEPARTMENT and FACULTY tables: use DEPARTMENT AS T1 and FACULTY AS T2 with proper table aliases. 3) When including membership information: join MEMBER_OF AS T3 with join condition T2.FacID = T3.FacID. 4) When linking DEPARTMENT and MEMBER_OF tables: use join condition T1.DNO = T3.DNO. 5) When filtering for computer science department: use T1.DName = \"Computer Science\" with exact case and double quotes instead of department = 'computer science'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM faculties WHERE department = 'computer science';",
            "SELECT T2.Lname \nFROM Department AS T1\nJOIN Member_of AS T3 ON T1.DNO = T3.DNO\nJOIN Faculty AS T2 ON T3.FacID = T2.FacID\nWHERE T1.DName = 'Computer Science'"
        ],
        "rule_sql": [
            "SELECT T2.Lname \nFROM Department AS T1\nJOIN Member_of AS T3 ON T1.DNO = T3.DNO\nJOIN Faculty AS T2 ON T2.FacID = T3.FacID\nWHERE T1.DName = \"Computer Science\""
        ]
    },
    "2750": {
        "db_id": "election",
        "question": "How many distinct governors are there?",
        "ground_truth": "SELECT count(DISTINCT Governor) FROM party",
        "amends": [
            "Do select `count(DISTINCT Governor)` instead of `COUNT(*)`. Do query from `party` table instead of `governors` table. The amended query now correctly counts distinct governors from the party table rather than counting all rows from the governors table."
        ],
        "rules": [
            "1) When counting distinct governors: count the number of unique values in the \"Governor\" column. 2) When answering about governors: use the \"party\" table instead of the \"governors\" table. 3) When performing distinct counting: use the exact column name \"Governor\" with double quotes as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM governors;",
            "SELECT COUNT(DISTINCT Governor) FROM party;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT \"Governor\") FROM party"
        ]
    },
    "6539": {
        "db_id": "wine_1",
        "question": "How many appelations are in Napa Country?",
        "ground_truth": "SELECT count(*) FROM APPELLATIONS WHERE County  =  \"Napa\"",
        "amends": [
            "Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency with the right SQL. Do reference the table as `APPELLATIONS` instead of `appelations` to match the correct table name. Do filter on `County = \"Napa\"` instead of `Country = 'Napa'` to use the correct column name (County instead of Country) and double quotes instead of single quotes around the value. The amended query now correctly counts records from the APPELLATIONS table where the County column equals Napa, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question mentions \"appelations\": use the exact table name \"APPELLATIONS\" with uppercase letters. 2) When filtering by county name: use the exact column name \"County\" (not \"Country\") and the exact literal value \"Napa\" with double quotes. 3) When counting records: use lowercase \"count(*)\" for consistency with the correct SQL format."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM appelations WHERE Country = 'Napa';",
            "SELECT count(*) FROM APPELLATIONS WHERE County = \"Napa\""
        ],
        "rule_sql": [
            "SELECT count(*) FROM APPELLATIONS WHERE County = \"Napa\""
        ]
    },
    "3223": {
        "db_id": "college_1",
        "question": "What is the name and the average gpa of department whose students have the highest average gpa?",
        "ground_truth": "SELECT T2.dept_name ,  avg(T1.stu_gpa) FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.dept_code ORDER BY avg(T1.stu_gpa) DESC LIMIT 1",
        "amends": [
            "Do join `department` table as `T2` instead of querying only the `students` table. Do use `T1.dept_code = T2.dept_code` as the join condition instead of missing the table relationship entirely. Do select `T2.dept_name` instead of `department_name` to get the proper department name from the joined table. Do reference `T1.stu_gpa` for averaging instead of `gpa` to use the correct column name. Do group by `T1.dept_code` instead of `department_name` to ensure proper aggregation by the joining key. Do order by `avg(T1.stu_gpa)` instead of the alias `average_gpa` to reference the actual aggregate expression. The amended query now correctly joins student and department tables to calculate average GPA by department name."
        ],
        "rules": [
            "1) When answering about department names and average GPA: make sure the output order: T2.dept_name, AVG(T1.stu_gpa) 2) When combining students and department tables: link rows where T1.dept_code = T2.dept_code and keep only matching pairs (inner match) 3) When grouping by department: organize results by T1.dept_code and compute average GPA per group 4) When the question mentions \"highest average gpa\": rank rows by AVG(T1.stu_gpa) in descending order and keep the first 1 row 5) When selecting department name: use T2.dept_name instead of department_name to get the proper name from the department table 6) When referencing student GPA for averaging: use T1.stu_gpa instead of gpa to use the correct column name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department_name, AVG(gpa) as average_gpa \nFROM students \nGROUP BY department_name \nORDER BY average_gpa DESC \nLIMIT 1;",
            "SELECT T2.DEPT_NAME, AVG(T1.STU_GPA) AS average_gpa\nFROM STUDENT T1\nJOIN DEPARTMENT T2 ON T1.DEPT_CODE = T2.DEPT_CODE\nGROUP BY T1.DEPT_CODE\nORDER BY AVG(T1.STU_GPA) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.dept_name, AVG(T1.stu_gpa) \nFROM STUDENT T1\nINNER JOIN DEPARTMENT T2 ON T1.dept_code = T2.dept_code\nGROUP BY T1.dept_code\nORDER BY AVG(T1.stu_gpa) DESC\nLIMIT 1"
        ]
    },
    "611": {
        "db_id": "store_1",
        "question": "List all media types.",
        "ground_truth": "SELECT name FROM media_types;",
        "amends": [
            "Do select only the `name` column instead of selecting all columns with `*`. Do change the table source to `media_types` instead of `tracks`. Do remove the entire query structure and replace it with a completely different table and column selection, as the original query was on the wrong table entirely. The amended query now correctly retrieves only the name column from the media_types table instead of all columns from the tracks table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"media types\": make sure the output order: name. 2) When the question mentions \"media types\": \"media types\" actually means \"name in media_types table\". 3) When selecting from the media_types table: only retrieve the name column, not all columns with *."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM tracks;",
            "SELECT name FROM media_types;"
        ],
        "rule_sql": [
            "SELECT name FROM media_types ORDER BY name;"
        ]
    },
    "2554": {
        "db_id": "county_public_safety",
        "question": "Show the name of cities in the county that has the largest number of police officers.",
        "ground_truth": "SELECT name FROM city WHERE county_ID  =  (SELECT county_ID FROM county_public_safety ORDER BY Police_officers DESC LIMIT 1)",
        "amends": [
            "Do select `name` from `city` instead of `city_name` from `cities`. Do reference `county_ID` instead of `county_id` in the main query filter. Do use a subquery that selects `county_ID` from `county_public_safety` instead of aggregating `police_officers` by `county_id`. Do order by `Police_officers DESC` instead of `COUNT(*) DESC` in the subquery. The amended query now correctly identifies the county with the most police officers by directly using the pre-aggregated count column rather than performing a separate aggregation, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for city names: select \"name\" from \"city\" table instead of \"city_name\" from \"cities\". 2) When filtering cities by county: use \"county_ID\" as the exact column name instead of \"county_id\". 3) When finding the county with the largest number of police officers: select \"county_ID\" from \"county_public_safety\" table instead of aggregating \"police_officers\". 4) When ordering to find the county with most police officers: order by \"Police_officers DESC\" instead of counting and ordering by count. 5) When combining city and county data: use the pre-aggregated police officer count from \"county_public_safety\" rather than performing separate aggregation on \"police_officers\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city_name FROM cities WHERE county_id = (SELECT county_id FROM police_officers GROUP BY county_id ORDER BY COUNT(*) DESC LIMIT 1);",
            "SELECT Name FROM city WHERE County_ID = (SELECT County_ID FROM county_public_safety ORDER BY Police_officers DESC LIMIT 1)"
        ],
        "rule_sql": [
            "SELECT c.Name \nFROM city c\nWHERE c.County_ID = (\n    SELECT County_ID \n    FROM county_public_safety \n    ORDER BY Police_officers DESC \n    LIMIT 1\n)"
        ]
    },
    "5478": {
        "db_id": "voter_2",
        "question": "Find the distinct Advisor of students who have treasurer votes in the spring election cycle.",
        "ground_truth": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  \"Spring\"",
        "amends": [
            "Do add table `STUDENT AS T1` and `VOTING_RECORD AS T2` with a `JOIN` on `T1.StuID = T2.Treasurer_Vote` instead of querying only the `students` table. Do change the filter to `T2.Election_Cycle = \"Spring\"` instead of `election_cycle = 'spring'` and remove the `vote_type = 'treasurer'` condition. Do reference `T1.Advisor` instead of just `Advisor` and maintain `DISTINCT` selection. The amended query now correctly identifies advisors through the voting relationship rather than direct student attributes, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"distinct Advisor of students who have treasurer votes in the spring election cycle\": make sure the output order: T1.Advisor. 2) When combining T1 and T2 for shared entities: link rows where T1.StuID = T2.Treasurer_Vote exactly as shown in the amends; keep only matching pairs (inner match). 3) When the question mentions \"spring election cycle\": \"spring\" actually means \"Spring\" in schema with exact case and double quotes as T2.Election_Cycle = \"Spring\". 4) When the question asks for \"distinct Advisor\": compute the number of unique values of the exact token T1.Advisor. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for identifiers like \"Spring\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT Advisor FROM students WHERE election_cycle = 'spring' AND vote_type = 'treasurer';",
            "SELECT DISTINCT T1.Advisor FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.Treasurer_Vote WHERE T2.Election_Cycle = \"Spring\""
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Advisor\nFROM Student T1\nINNER JOIN Voting_record T2 ON T1.StuID = T2.Treasurer_Vote\nWHERE T2.Election_Cycle = \"Spring\""
        ]
    },
    "5914": {
        "db_id": "cre_Theme_park",
        "question": "Give me the star rating descriptions of the hotels that cost more than 10000.",
        "ground_truth": "SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  10000",
        "amends": [
            "Do select `T2.star_rating_description` instead of `star_rating` from the wrong table. Do add `JOIN Ref_Hotel_Star_Ratings AS T2` with the correct join condition `ON T1.star_rating_code = T2.star_rating_code` instead of missing this table entirely. Do change the filter to `T1.price_range > 10000` instead of `price < 10000` with the wrong comparison operator and column reference. The amended query now correctly joins the reference table to get the star rating description and uses the proper price range filter with greater than comparison."
        ],
        "rules": [
            "1) When answering about \"star rating descriptions of hotels\": make sure the output order: T2.star_rating_description. 2) When the question mentions \"hotels that cost more than 10000\": use T1.price_range > 10000 as the filter condition. 3) When combining hotels and star rating reference data: link rows where T1.star_rating_code = T2.star_rating_code and keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT star_rating FROM hotels WHERE price < 10000",
            "SELECT T2.star_rating_description \nFROM Hotels AS T1 \nJOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code = T2.star_rating_code \nWHERE T1.price_range > 10000"
        ],
        "rule_sql": [
            "SELECT T2.star_rating_description\nFROM Hotels T1\nINNER JOIN Ref_Hotel_Star_Ratings T2 ON T1.star_rating_code = T2.star_rating_code\nWHERE T1.price_range > 10000\nORDER BY T2.star_rating_description"
        ]
    },
    "4208": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "Show all role codes with at least 3 employees.",
        "ground_truth": "SELECT role_code FROM Employees GROUP BY role_code HAVING count(*)  >=  3",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT role_code FROM employees GROUP BY role_code HAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT Role_Code, COUNT(Employee_ID) as Employee_Count\nFROM Employees\nGROUP BY Role_Code\nHAVING COUNT(Employee_ID) >= 3;",
            "SELECT Role_Code, COUNT(Employee_ID) as Employee_Count\nFROM Employees\nGROUP BY Role_Code\nHAVING COUNT(Employee_ID) >= 3;"
        ]
    },
    "2783": {
        "db_id": "election",
        "question": "Which county has the largest population? Give me the name of the county.",
        "ground_truth": "SELECT County_name FROM county ORDER BY Population DESC LIMIT 1",
        "amends": [
            "Do reference table `county` instead of `counties` and use column `County_name` instead of `county_name`. Do order by `Population DESC` instead of `population ASC` to get the highest population county instead of the lowest. The amended query now correctly retrieves the county with the largest population from the county table."
        ],
        "rules": [
            "1) When the question asks about \"county\": use the exact table name \"county\" and column name \"County_name\" as shown in the schema. 2) When the question asks for the \"largest population\": order by \"Population DESC\" to get the highest value first. 3) When retrieving the top result: use LIMIT 1 to get only the first row after ordering."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT county_name FROM counties ORDER BY population ASC LIMIT 1;",
            "SELECT County_name FROM county ORDER BY Population DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT County_name FROM county ORDER BY Population DESC LIMIT 1;"
        ]
    },
    "1549": {
        "db_id": "customers_and_invoices",
        "question": "How many customers have opened an account?",
        "ground_truth": "SELECT count(DISTINCT customer_id) FROM Accounts",
        "amends": [
            "Do count `DISTINCT customer_id` instead of counting all rows with `COUNT(*)`. Do reference the `Accounts` table instead of the `customers` table. Do remove the `WHERE account_status = 'closed'` filter instead of keeping it. The amended query now correctly counts unique customers from the Accounts table without unnecessary filtering."
        ],
        "rules": [
            "1) When counting customers who have opened an account: count distinct \"customer_id\" values from the \"Accounts\" table instead of counting all rows. 2) When the question asks about customers with opened accounts: use the \"Accounts\" table instead of the \"customers\" table. 3) When counting customers: do not apply any account_status filter, especially not 'closed' status."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE account_status = 'closed';",
            "SELECT COUNT(DISTINCT customer_id) FROM Accounts;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT customer_id) FROM Accounts;"
        ]
    },
    "1807": {
        "db_id": "small_bank_1",
        "question": "What are the names of customers with accounts, and what are the total savings balances for each?",
        "ground_truth": "SELECT sum(T2.balance) ,  T1.name FROM accounts AS T1 JOIN savings AS T2 ON T1.custid  =  T2.custid GROUP BY T1.name",
        "amends": [
            "Do reference `accounts` as `T1` and `savings` as `T2` instead of `customers` and `accounts` with different table aliases. Do join on `T1.custid = T2.custid` instead of `c.customer_id = a.customer_id` with different column names. Do select `sum(T2.balance)` without an alias instead of `SUM(a.balance) as total_savings_balance` with an alias. Do include only `T1.name` in the SELECT list instead of both `c.name` and the aggregate. Do remove the `WHERE a.account_type = 'savings'` filter instead of keeping it, as the join to the `savings` table inherently filters for savings accounts. Do group by `T1.name` instead of `c.name` with different table reference. The amended query now correctly calculates total savings balances by joining the accounts table with the savings table using the appropriate customer identifier.",
            "Do place the aggregate function `sum(T2.balance)` first in the SELECT list instead of second, and do use lowercase `sum` instead of uppercase `SUM`. Do maintain the explicit `AS` keyword for table aliases `accounts AS T1` and `savings AS T2` instead of omitting them. Do preserve the identical join condition `ON T1.custid = T2.custid` and GROUP BY clause `GROUP BY T1.name` without changes. The amended query now correctly matches the RIGHT_SQL's behavior while maintaining the same logical result."
        ],
        "rules": [
            "1) When joining tables for customer account information: link rows where T1.custid = T2.custid to combine customer and account data, keeping only matching pairs (inner match). 2) When calculating total savings balances: compute the sum of T2.balance for each customer without applying an alias to the result. 3) When organizing results by customer: group the output by T1.name to show totals for each individual customer. 4) When answering about customer names and savings balances: make sure the output order shows T1.name first followed by the sum of T2.balance. 5) When filtering for savings accounts: do not apply a WHERE filter on account_type since joining with the savings table inherently provides only savings account data.",
            "1) When answering about \"names of customers with accounts and total savings balances for each\": make sure the output order: sum(T2.balance) first, then T1.name. 2) When using aggregate functions: use lowercase \"sum\" instead of uppercase \"SUM\". 3) When defining table aliases: use explicit \"AS\" keyword for \"accounts AS T1\" and \"savings AS T2\". 4) When combining accounts and savings tables: link rows where T1.custid = T2.custid and keep only matching pairs (inner match). 5) When grouping results by customer names: organize results by T1.name and compute sum(T2.balance) per group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.name, SUM(a.balance) as total_savings_balance \nFROM customers c \nJOIN accounts a ON c.customer_id = a.customer_id \nWHERE a.account_type = 'savings' \nGROUP BY c.name",
            "SELECT T1.name, SUM(T2.balance) FROM ACCOUNTS T1 JOIN SAVINGS T2 ON T1.custid = T2.custid GROUP BY T1.name",
            "SELECT sum(T2.balance), T1.name\nFROM accounts AS T1\nJOIN savings AS T2 ON T1.custid = T2.custid\nGROUP BY T1.name"
        ],
        "rule_sql": [
            "SELECT T1.name, sum(T2.balance) FROM accounts AS T1 JOIN savings AS T2 ON T1.custid = T2.custid GROUP BY T1.name"
        ]
    },
    "6300": {
        "db_id": "city_record",
        "question": "Find the number of matches in different competitions.",
        "ground_truth": "SELECT count(*) ,  Competition FROM MATCH GROUP BY Competition",
        "amends": [
            "Do use `count(*)` without an alias instead of `COUNT(*)` with the same function but different formatting. Do reference the column as `Competition` instead of `competition` to match the correct case. Do use the table name `MATCH` instead of `matches` to reference the correct source table. Do maintain the same `GROUP BY Competition` logic but with proper case matching instead of the lowercase `competition`. The amended query now correctly counts records grouped by competition from the MATCH table, matching the RIGHT_SQL's behavior.",
            "Do place the `Competition` column after the aggregate function instead of before it in the SELECT list. Do maintain the same `COUNT(*)` aggregate function and `GROUP BY Competition` clause without changes. The amended query now correctly positions the non-aggregated column after the aggregate function in the SELECT list while preserving the same logical behavior and output as the RIGHT_SQL."
        ],
        "rules": [
            "1) When counting records from the match table: use the exact table name \"MATCH\" instead of \"matches\". 2) When grouping by competition: use the exact column name \"Competition\" with proper case instead of lowercase \"competition\". 3) When counting records: use count(*) without an alias to match the correct formatting. 4) When answering about number of matches in different competitions: make sure the output order includes Competition first followed by the count.",
            "1) When answering about \"number of matches in different competitions\": make sure the output order: count first, then Competition column. 2) When the question asks for \"number of matches\": compute the count of all rows in the match table. 3) When the question mentions \"different competitions\": group the results by the exact \"Competition\" column from the match table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT competition, COUNT(*) FROM matches GROUP BY competition;",
            "SELECT Competition, COUNT(*) FROM match GROUP BY Competition",
            "SELECT COUNT(*), Competition FROM MATCH GROUP BY Competition"
        ],
        "rule_sql": [
            "SELECT COUNT(*), Competition FROM MATCH GROUP BY Competition;"
        ]
    },
    "4083": {
        "db_id": "student_1",
        "question": "For each classroom, show the classroom number and count the number of distinct grades that use the room.",
        "ground_truth": "SELECT classroom ,  count(DISTINCT grade) FROM list GROUP BY classroom",
        "amends": [
            "Do select `classroom` instead of `classroom_number` and `count(DISTINCT grade)` instead of `COUNT(*)`. Do use table `list` instead of `classrooms` and remove the GROUP BY clause entirely instead of grouping by `classroom_number`. Do add the DISTINCT keyword within the count function to count unique grades instead of counting all rows, and change the aggregation to count distinct grades per classroom rather than total records per classroom number. The amended query now correctly counts distinct grades per classroom from the list table instead of counting all records from classrooms grouped by classroom number."
        ],
        "rules": [
            "1) When answering about \"classroom number and count of distinct grades\": make sure the output order: classroom, count of distinct grades. 2) When the question mentions \"classroom\": \"classroom\" actually means \"classroom\" in schema. 3) When the question asks for \"count of distinct grades\": compute the number of unique values of the exact token \"grade\". 4) When using the table \"list\": do not use the table \"classrooms\" as specified in the wrong query. 5) When counting distinct grades per classroom: do not use GROUP BY classroom_number, instead count distinct grades directly without grouping."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT classroom_number, COUNT(*) FROM classrooms GROUP BY classroom_number;",
            "SELECT Classroom, COUNT(DISTINCT Grade) FROM list GROUP BY Classroom;"
        ],
        "rule_sql": [
            "SELECT Classroom, COUNT(DISTINCT Grade) FROM list GROUP BY Classroom;"
        ]
    },
    "3177": {
        "db_id": "college_1",
        "question": "What is the first and last name of the professor in biology department?",
        "ground_truth": "SELECT T3.EMP_FNAME ,  T3.EMP_LNAME FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code JOIN employee AS T3 ON T1.EMP_NUM  =  T3.EMP_NUM WHERE DEPT_NAME  =  \"Biology\"",
        "amends": [
            "Do select `T3.EMP_FNAME` and `T3.EMP_LNAME` from the `employee` table instead of `first_name` and `last_name` from `professors`. Do join three tables (`professor AS T1`, `department AS T2`, and `employee AS T3`) with `INNER JOIN` conditions instead of querying only the `professors` table. Do use the join predicate `T1.dept_code = T2.dept_code` to connect professor and department tables, and `T1.EMP_NUM = T3.EMP_NUM` to connect professor and employee tables instead of no joins. Do filter on `DEPT_NAME = \"Biology\"` instead of `department = 'biology'` to match the correct department name column and value. Do remove the `ORDER BY professor_id LIMIT 1` clause instead of keeping it since the correct query returns all matching records without ordering or limiting. The amended query now correctly retrieves employee names by joining through proper table relationships and filtering on the actual department name column."
        ],
        "rules": [
            "1) When the question asks for first and last name of professors: select T3.EMP_FNAME and T3.EMP_LNAME from the employee table instead of first_name and last_name from professors table. 2) When combining professor, department, and employee tables: link professor and department tables using T1.dept_code = T2.dept_code, and link professor and employee tables using T1.EMP_NUM = T3.EMP_NUM, keeping only matching pairs (inner match). 3) When filtering for biology department: use DEPT_NAME = \"Biology\" instead of department = 'biology' to match the correct department name column and value. 4) When the question does not specify ordering or limiting: remove ORDER BY professor_id LIMIT 1 clause and return all matching records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM professors WHERE department = 'biology' ORDER BY professor_id LIMIT 1;",
            "SELECT T3.EMP_FNAME, T3.EMP_LNAME\nFROM professor AS T1\nINNER JOIN department AS T2 ON T1.dept_code = T2.dept_code\nINNER JOIN employee AS T3 ON T1.EMP_NUM = T3.EMP_NUM\nWHERE T2.DEPT_NAME = 'Biology';"
        ],
        "rule_sql": [
            "SELECT T3.EMP_FNAME, T3.EMP_LNAME\nFROM PROFESSOR T1\nINNER JOIN DEPARTMENT T2 ON T1.DEPT_CODE = T2.DEPT_CODE\nINNER JOIN EMPLOYEE T3 ON T1.EMP_NUM = T3.EMP_NUM\nWHERE T2.DEPT_NAME = 'Biology';"
        ]
    },
    "494": {
        "db_id": "allergy_1",
        "question": "How old is each student and how many students are each age?",
        "ground_truth": "SELECT age ,  count(*) FROM Student GROUP BY age",
        "amends": [
            "Do reference the table as `Student` instead of `students` to match the correct schema. Do maintain the same `SELECT` list with `age` and `count(*)` without changes. Do preserve the `GROUP BY age` clause without modification. Do remove the `ORDER BY age` clause instead of keeping it, as the right query does not include ordering. The amended query now correctly references the proper table name and removes the unnecessary ordering to match the right SQL's behavior."
        ],
        "rules": [
            "1) When referencing the student table: use the exact table name \"Student\" instead of \"students\" to match the schema. 2) When counting students by age: maintain the output columns as age followed by count of students. 3) When grouping students by age: use the age column for grouping without any ordering clause. 4) When the question asks for student ages and counts: do not include any sorting in the final output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT age, COUNT(*) FROM students GROUP BY age ORDER BY age;",
            "SELECT age, COUNT(*) FROM Student GROUP BY age"
        ],
        "rule_sql": [
            "SELECT Age, COUNT(*) FROM Student GROUP BY Age;"
        ]
    },
    "1020": {
        "db_id": "university_basketball",
        "question": "What is all the information about the basketball match?",
        "ground_truth": "SELECT * FROM basketball_match",
        "amends": [
            "Do query from `basketball_match` table instead of `football_matches` table. Do filter for basketball matches by table selection instead of using a `WHERE sport = 'basketball'` condition. The amended query now correctly retrieves basketball match data from the appropriate table."
        ],
        "rules": [
            "1) When answering about basketball matches: use the \"basketball_match\" table instead of the \"football_matches\" table. 2) When the question asks for all information about basketball matches: retrieve all columns from the \"basketball_match\" table without any filtering conditions. 3) When selecting data from the \"basketball_match\" table: do not apply a WHERE sport = 'basketball' filter since the table name already specifies the sport."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM football_matches WHERE sport = 'basketball';",
            "SELECT * FROM basketball_match;"
        ],
        "rule_sql": [
            "SELECT * FROM basketball_match;"
        ]
    },
    "2591": {
        "db_id": "inn_1",
        "question": "What are the names and decor of rooms with a king bed? Sort them by their price",
        "ground_truth": "SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  'King' ORDER BY basePrice;",
        "amends": [
            "Do select `roomName` instead of `name` and maintain `decor` in the SELECT list. Do reference table `Rooms` instead of `rooms` in the FROM clause. Do filter on `bedtype = 'King'` instead of `bed_type = 'king'` to correct both column name and case sensitivity. Do order by `basePrice` instead of `name` to change the sorting criterion. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for room names: select \"roomName\" instead of \"name\" from table \"Rooms\". 2) When filtering for king beds: use condition \"bedtype = 'King'\" with exact case and column name. 3) When sorting by price: order by \"basePrice\" instead of name. 4) When selecting room attributes: include both \"roomName\" and \"decor\" in the output columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, decor FROM rooms WHERE bed_type = 'king' ORDER BY name;",
            "SELECT roomName, decor FROM Rooms WHERE bedType = 'King' ORDER BY basePrice;"
        ],
        "rule_sql": [
            "SELECT roomName, decor FROM Rooms WHERE bedType = 'King' ORDER BY basePrice;"
        ]
    },
    "857": {
        "db_id": "chinook_1",
        "question": "Find all the customer last names that do not have invoice totals larger than 20.",
        "ground_truth": "SELECT LastName FROM CUSTOMER EXCEPT SELECT T1.LastName FROM CUSTOMER AS T1 JOIN Invoice AS T2 ON T1.CustomerId  =  T2.CustomerId WHERE T2.total  >  20",
        "amends": [
            "Do use `EXCEPT` to filter out customers with invoices over 20 instead of directly filtering by `InvoiceTotal <= 20`. Do add a join between `CUSTOMER` and `Invoice` tables on `CustomerId` instead of omitting the invoice table relationship. Do reference the joined table with alias `T2` instead of directly accessing `InvoiceTotal` from the wrong table context. Do filter with `T2.total > 20` in the EXCEPT subquery instead of `InvoiceTotal <= 20` in the main query. Do use table aliases `T1` and `T2` for clarity instead of no aliases. The amended query now correctly identifies customers who have never had an invoice exceeding 20, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"customer last names that do not have invoice totals larger than 20\": make sure the output order: LastName. 2) When the question mentions \"invoice totals larger than 20\": \"invoice totals larger than 20\" actually means \"T2.total > 20\" in schema. 3) When combining T1 and T2 for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (T1.CustomerId = T2.CustomerId); keep only matching pairs (inner match). 4) When filtering customers without invoices over 20: use EXCEPT to remove customers who have any T2.total > 20 instead of directly filtering by T2.total <= 20. 5) When referring to table roles: use T1 for the Customer table and T2 for the Invoice table as established in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT LastName FROM Customers WHERE InvoiceTotal <= 20;",
            "SELECT T1.LastName\nFROM Customer T1\nEXCEPT\nSELECT T1.LastName\nFROM Customer T1\nJOIN Invoice T2 ON T1.CustomerId = T2.CustomerId\nWHERE T2.Total > 20"
        ],
        "rule_sql": [
            "SELECT LastName FROM Customer WHERE CustomerId IN (SELECT CustomerId FROM Customer EXCEPT SELECT CustomerId FROM Invoice WHERE Total > 20) ORDER BY LastName;"
        ]
    },
    "768": {
        "db_id": "race_track",
        "question": "What are the different classes of races, and how many races correspond to each?",
        "ground_truth": "SELECT CLASS ,  count(*) FROM race GROUP BY CLASS",
        "amends": [
            "Do reference the `race` table instead of the `races` table. Do group by `CLASS` instead of `race_id` to correctly aggregate counts by class rather than by race identifier. Do use consistent case for `CLASS` instead of mixing `class` and `CLASS` in the SELECT clause. The amended query now correctly counts records grouped by class values rather than by race identifiers, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"different classes of races and how many races correspond to each\": make sure the output order: CLASS, COUNT(*) 2) When the question mentions \"classes of races\": \"classes\" actually means \"CLASS in schema\" 3) When the question asks for \"how many races correspond to each class\": compute the number of rows using the canonical key token for races (e.g., race_id) grouped by CLASS 4) When the question says \"per class\"/\"by class\": organize results by CLASS and compute count of races per group 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms 6) When handling text literals: do not change case, spacing, or punctuation"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT class, COUNT(*) FROM races GROUP BY race_id;",
            "SELECT Class, COUNT(Race_ID) AS Number_of_Races FROM race GROUP BY Class;"
        ],
        "rule_sql": [
            "SELECT \"Class\", COUNT(\"Race_ID\") FROM \"race\" GROUP BY \"Class\""
        ]
    },
    "1865": {
        "db_id": "wrestler",
        "question": "How many eliminations did each team have?",
        "ground_truth": "SELECT Team ,  COUNT(*) FROM elimination GROUP BY Team",
        "amends": [
            "Do select `COUNT(*)` instead of `SUM(kills)` as the aggregate function. Do use table `elimination` instead of `matches` as the data source. Do group by `Team` instead of `team` to match the selected column case. The amended query now correctly counts records per team from the elimination table rather than summing kills from matches."
        ],
        "rules": [
            "1) When answering about \"how many eliminations each team had\": make sure the output order: Team, COUNT(*) 2) When the question mentions \"eliminations\": \"eliminations\" actually means \"records in the elimination table\" in schema 3) When the question asks for \"count of eliminations per team\": compute the number of rows using the canonical key for elimination records and organize results by the exact token \"Team\" 4) When choosing identifier delimiters: do not change the case of \"Team\" as it appears in the schema"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT team, SUM(kills) FROM matches GROUP BY team",
            "SELECT Team, COUNT(*) AS Eliminations FROM Elimination GROUP BY Team;"
        ],
        "rule_sql": [
            "SELECT Team, COUNT(*) FROM Elimination GROUP BY Team;"
        ]
    },
    "1360": {
        "db_id": "college_2",
        "question": "what is the name of the instructor who is in Statistics department and earns the lowest salary?",
        "ground_truth": "SELECT name FROM instructor WHERE dept_name  =  'Statistics' ORDER BY salary LIMIT 1",
        "amends": [
            "Do reference table `instructor` instead of `instructors` and use column `dept_name` instead of `department` for the filter condition. Do order by `salary` in ascending order instead of descending order. The amended query now correctly selects from the instructor table, filters by the Statistics department using the proper column name, and orders results by salary in the specified direction to match the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"instructors\": use the exact table name \"instructor\" instead of \"instructors\". 2) When filtering by department: use column \"dept_name\" instead of \"department\" for the condition. 3) When the question asks for \"lowest salary\": order by \"salary\" in ascending order instead of descending order. 4) When filtering for Statistics department: use the exact literal value 'Statistics' with proper case and spelling."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM instructors WHERE department = 'Statistics' ORDER BY salary DESC LIMIT 1;",
            "SELECT name FROM instructor WHERE dept_name = 'Statistics' ORDER BY salary ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT name FROM instructor WHERE dept_name = 'Statistics' ORDER BY salary ASC LIMIT 1;"
        ]
    },
    "3645": {
        "db_id": "baseball_1",
        "question": "How many parks are there in the state of NY?",
        "ground_truth": "SELECT count(*) FROM park WHERE state  =  'NY';",
        "amends": [
            "Do reference table `park` instead of `parks` to correctly align with the actual table name in the schema. The amended query now matches RIGHT_SQL's behavior by using the proper table name while maintaining the same counting logic for New York state parks."
        ],
        "rules": [
            "1) When the question asks about \"parks\": use the exact table name \"park\" from the schema instead of \"parks\". 2) When counting entities from table \"park\": count all rows where the condition is satisfied, using COUNT(*). 3) When filtering for parks in the state of NY: use the exact literal value 'NY' with the correct case and no additional punctuation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM parks WHERE state = 'NY';",
            "SELECT COUNT(*) FROM park WHERE state = 'NY';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM park WHERE state = 'NY';"
        ]
    },
    "3784": {
        "db_id": "e_learning",
        "question": "Find the dates of the tests taken with result \"Pass\".",
        "ground_truth": "SELECT date_test_taken FROM Student_Tests_Taken WHERE test_result  =  \"Pass\"",
        "amends": [
            "Do reference the column as `date_test_taken` instead of `test_date` and use the table name `Student_Tests_Taken` instead of `tests`. Do use the column name `test_result` instead of `result` and maintain the filter condition for 'Pass' values. The amended query now correctly references the actual schema elements and matches the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"dates of the tests taken\": use the exact column name \"date_test_taken\" from table \"Student_Tests_Taken\". 2) When the question mentions \"result 'Pass'\": use the exact column name \"test_result\" from table \"Student_Tests_Taken\" and filter for the exact literal value 'Pass'. 3) When answering about \"dates of the tests taken with result 'Pass'\": make sure the output order: \"date_test_taken\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT test_date FROM tests WHERE result = 'Pass';",
            "SELECT date_test_taken FROM Student_Tests_Taken WHERE test_result = 'Pass';"
        ],
        "rule_sql": [
            "SELECT date_test_taken FROM Student_Tests_Taken WHERE test_result = 'Pass' ORDER BY date_test_taken;"
        ]
    },
    "6147": {
        "db_id": "music_4",
        "question": "What is the average age of all artists?",
        "ground_truth": "SELECT avg(Age) FROM artist",
        "amends": [
            "Do use `avg(Age)` in the SELECT list instead of `AVG(name)` to calculate the average age rather than attempting to average string names. Do reference the `artist` table instead of `artists` to match the correct table name. The amended query now correctly calculates the average age from the appropriate table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"average age of all artists\": use the exact column token \"Age\" from the artist table to calculate the average. 2) When referencing the table containing artist information: use the exact table name \"artist\" (not \"artists\") as specified in the schema. 3) When calculating averages: ensure the aggregation is performed on numerical columns like \"Age\" rather than string columns like \"name\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(name) FROM artists;",
            "SELECT AVG(Age) FROM artist;"
        ],
        "rule_sql": [
            "SELECT AVG(Age) FROM artist;"
        ]
    },
    "3057": {
        "db_id": "loan_1",
        "question": "What is the average account balance of customers with credit score below 50 for the different account types?",
        "ground_truth": "SELECT avg(acc_bal) ,  acc_type FROM customer WHERE credit_score  <  50 GROUP BY acc_type",
        "amends": [
            "Do use `avg(acc_bal)` and `acc_type` instead of `AVG(balance)` and `account_type` for column names. Do reference table `customer` instead of `customers` as the source. Do change the filter to `credit_score < 50` instead of `credit_score > 50` for the correct threshold comparison. Do maintain `GROUP BY acc_type` instead of `GROUP BY account_type` to match the selected column. The amended query now correctly calculates average account balances by account type for customers with credit scores below 50, matching the intended behavior.",
            "Do place `acc_type` after the aggregate function instead of listing it first in the SELECT clause. Do use lowercase `avg(acc_bal)` instead of `AVG(acc_bal) as average_account_balance` to remove the unnecessary alias. Do maintain the same `WHERE credit_score < 50` filter and `GROUP BY acc_type` grouping without changes. The amended query now correctly calculates the average account balance grouped by account type for customers with low credit scores, matching the right SQL's behavior.",
            "Do place `acc_type` after `avg(acc_bal)` in the SELECT list instead of before it, maintaining the same column order as in the GROUP BY clause for consistency. The amended query now matches RIGHT_SQL's behavior.",
            "Do place `acc_type` after `avg(acc_bal)` in the SELECT list instead of before it, maintaining the same aggregation logic and filtering condition with `credit_score < 50` and grouping by `acc_type`. The amended query now matches RIGHT_SQL's behavior with identical column ordering while preserving the same analytical results."
        ],
        "rules": [
            "1) When the question asks for average account balance: use avg(acc_bal) instead of AVG(balance) as the aggregation function. 2) When the question mentions account types: use acc_type instead of account_type as the column name. 3) When the question refers to customers: use table customer instead of customers as the data source. 4) When the question specifies credit score below 50: use credit_score < 50 instead of credit_score > 50 for the filter condition. 5) When grouping by account type: use GROUP BY acc_type to match the selected column name.",
            "1) When answering about average account balance of customers with credit score below 50 for different account types: make sure the output order is avg(acc_bal) first, then acc_type. 2) When computing the average account balance: use lowercase avg(acc_bal) without an alias instead of AVG(acc_bal) as average_account_balance. 3) When filtering for customers with credit score below 50: maintain the exact condition credit_score < 50. 4) When grouping by account types: use GROUP BY acc_type to organize results by account type.",
            "1) When answering about \"average account balance of customers with credit score below 50 for different account types\": make sure the output order: avg(acc_bal) then acc_type\n2) When the question mentions \"account types\": \"account types\" actually means \"acc_type in schema\"\n3) When the question asks for \"average account balance\": compute the average of acc_bal values\n4) When the question specifies \"credit score below 50\": include only rows where credit_score < 50\n5) When the question asks for results \"for the different account types\": organize results by acc_type and compute requested aggregates per group",
            "1) When the question asks for average account balance by account type: place \"acc_type\" after \"avg(acc_bal)\" in the output order. 2) When filtering customers by credit score below 50: use the condition credit_score < 50. 3) When grouping results by account types: group by the exact token \"acc_type\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT account_type, AVG(balance) \nFROM customers \nWHERE credit_score > 50 \nGROUP BY account_type;",
            "SELECT acc_type, AVG(acc_bal) as average_account_balance FROM customer WHERE credit_score < 50 GROUP BY acc_type;",
            "SELECT acc_type, avg(acc_bal) FROM customer WHERE credit_score < 50 GROUP BY acc_type",
            "SELECT acc_type, avg(acc_bal) FROM customer WHERE credit_score < 50 GROUP BY acc_type",
            "SELECT avg(acc_bal), acc_type FROM customer WHERE credit_score < 50 GROUP BY acc_type"
        ],
        "rule_sql": [
            "SELECT avg(acc_bal), acc_type FROM customer WHERE credit_score < 50 GROUP BY acc_type"
        ]
    },
    "2662": {
        "db_id": "party_host",
        "question": "List the themes of parties in ascending order of number of hosts.",
        "ground_truth": "SELECT Party_Theme FROM party ORDER BY Number_of_hosts ASC",
        "amends": [
            "Do select `Party_Theme` instead of `theme` and remove the `COUNT(host_id) as num_hosts` aggregation instead of including it. Do reference the `party` table instead of `parties` and remove the FROM clause entirely instead of keeping it. Do order by `Number_of_hosts` instead of `num_hosts` and maintain the ASC direction. The amended query now correctly selects a single column from the party table without aggregation and orders by the pre-existing Number_of_hosts column, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"themes of parties\": select \"Party_Theme\" from the \"party\" table. 2) When the question asks for \"ascending order of number of hosts\": order the results by \"Number_of_hosts\" in ascending direction. 3) When the schema shows column names with exact case and underscores: use \"Party_Theme\" and \"Number_of_hosts\" exactly as shown in the schema. 4) When the question does not require aggregation: do not perform any counting or aggregation operations."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT theme, COUNT(host_id) as num_hosts FROM parties ORDER BY num_hosts ASC;",
            "SELECT Party_Theme FROM party ORDER BY Number_of_hosts ASC"
        ],
        "rule_sql": [
            "SELECT Party_Theme FROM party ORDER BY Number_of_hosts ASC;"
        ]
    },
    "3049": {
        "db_id": "loan_1",
        "question": "What is the name of the customer with the worst credit score?",
        "ground_truth": "SELECT cust_name FROM customer ORDER BY credit_score LIMIT 1",
        "amends": [
            "Do reference `cust_name` instead of `name` and use table `customer` instead of `customers`. Do remove the explicit `ASC` direction from `ORDER BY credit_score` instead of keeping it, as ascending order is the default. The amended query now correctly selects from the intended table with the proper column name and maintains the same sorting behavior with implicit ascending order."
        ],
        "rules": [
            "1) When the question asks for customer names: use the exact column token \"cust_name\" from the customer table instead of \"name\". 2) When referring to the customer table: use the exact table name \"customer\" instead of \"customers\". 3) When ordering by credit score to find the worst score: use implicit ascending order (default) instead of explicit ASC direction."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM customers ORDER BY credit_score ASC LIMIT 1;",
            "SELECT cust_name FROM customer ORDER BY credit_score LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT cust_name FROM customer ORDER BY credit_score LIMIT 1;"
        ]
    },
    "6176": {
        "db_id": "music_4",
        "question": "Return the famous titles for artists that have volumes that lasted more than 2 weeks on top.",
        "ground_truth": "SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  >  2",
        "amends": [
            "Do add `JOIN volume AS T2 ON T1.Artist_ID = T2.Artist_ID` instead of querying only the `artists` table. Do change the source table to `artist AS T1` instead of `artists`. Do use the column `T2.Weeks_on_Top > 2` instead of `volume_duration > 2` for the WHERE filter. Do reference `T1.Famous_Title` instead of just `famous_title`. The amended query now correctly joins the artist and volume tables to filter based on weeks on top rather than volume duration, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"famous titles for artists that have volumes that lasted more than 2 weeks on top\": make sure the output order: T1.Famous_Title. 2) When combining artist and volume tables: link rows where T1.Artist_ID = T2.Artist_ID and keep only matching pairs (inner match). 3) When filtering for volumes that lasted more than 2 weeks on top: use the condition T2.Weeks_on_Top > 2. 4) When referring to the artist table: use the exact identifier \"artist AS T1\" instead of \"artists\". 5) When selecting the famous title: reference T1.Famous_Title instead of just famous_title."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT famous_title FROM artists WHERE volume_duration > 2",
            "SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID = T2.Artist_ID WHERE T2.Weeks_on_Top > 2"
        ],
        "rule_sql": [
            "SELECT T1.Famous_Title FROM artist AS T1 INNER JOIN volume AS T2 ON T1.Artist_ID = T2.Artist_ID WHERE T2.Weeks_on_Top > 2"
        ]
    },
    "3373": {
        "db_id": "sports_competition",
        "question": "What are the positions with both players having more than 20 points and less than 10 points.",
        "ground_truth": "SELECT POSITION FROM player WHERE Points  >  20 INTERSECT SELECT POSITION FROM player WHERE Points  <  10",
        "amends": [
            "Do use `INTERSECT` to find common positions instead of the contradictory `WHERE points > 20 AND points < 10` that would return no results. Do query from table `player` instead of `players` and use column name `Points` instead of `points`. Do split the query into two separate SELECT statements with `SELECT POSITION FROM player WHERE Points > 20` and `SELECT POSITION FROM player WHERE Points < 10` instead of trying to combine both conditions in a single WHERE clause. The amended query now correctly finds positions where players have both scored more than 20 points and less than 10 points in different games, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for positions with both players having more than 20 points and less than 10 points: use INTERSECT to find common positions between two separate queries instead of combining contradictory conditions in a single WHERE clause. 2) When querying from the player table: use the exact table name \"player\" instead of \"players\" and the exact column name \"Points\" instead of \"points\". 3) When finding positions with players scoring more than 20 points: use SELECT POSITION FROM player WHERE Points > 20. 4) When finding positions with players scoring less than 10 points: use SELECT POSITION FROM player WHERE Points < 10. 5) When combining the results: use INTERSECT between the two separate queries to find positions that appear in both result sets."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT position FROM players WHERE points > 20 AND points < 10",
            "SELECT Position FROM player WHERE Points > 20\nINTERSECT\nSELECT Position FROM player WHERE Points < 10"
        ],
        "rule_sql": [
            "SELECT Position FROM player WHERE Points > 20\nINTERSECT\nSELECT Position FROM player WHERE Points < 10"
        ]
    },
    "758": {
        "db_id": "race_track",
        "question": "What are the names, locations, and years of opening for tracks with seating higher than average?",
        "ground_truth": "SELECT name ,  LOCATION ,  year_opened FROM track WHERE seating  >  (SELECT avg(seating) FROM track)",
        "amends": [
            "Do reference table `track` instead of `tracks` in both the main query and subquery. Do use lowercase `avg` function instead of uppercase `AVG` in the subquery. The amended query now correctly references the actual table name and uses the standard lowercase aggregate function, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"tracks\": the actual table name is \"track\" (not \"tracks\"). 2) When computing the average seating capacity: use the lowercase function \"avg\" (not uppercase \"AVG\"). 3) When filtering for seating higher than average: compare the seating column against the average seating value computed from the same track table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, location, year_opened FROM tracks WHERE seating > (SELECT AVG(seating) FROM tracks);",
            "SELECT Name, Location, Year_Opened FROM track WHERE Seating > (SELECT avg(Seating) FROM track)"
        ],
        "rule_sql": [
            "SELECT Name, Location, Year_Opened FROM track WHERE Seating > (SELECT avg(Seating) FROM track);"
        ]
    },
    "6090": {
        "db_id": "customers_and_addresses",
        "question": "Which city is post code 255 located in?",
        "ground_truth": "SELECT city FROM addresses WHERE zip_postcode  =  255",
        "amends": [
            "Do use column name `zip_postcode` instead of `post_code` in the WHERE filter. Do remove single quotes around the value `255` instead of treating it as a string literal, allowing proper numeric comparison. The amended query now correctly filters by the numeric zip_postcode column value 255 instead of incorrectly searching for a string '255' in a potentially non-existent post_code column, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"post code\": use the exact column name \"zip_postcode\" from the Addresses table instead. 2) When filtering by numeric values like 255: treat the value as a numeric literal without quotes, not as a string literal '255'. 3) When answering about city location by post code: make sure the output order includes only the city column from the Addresses table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city FROM addresses WHERE post_code = '255';",
            "SELECT city FROM Addresses WHERE zip_postcode = 255"
        ],
        "rule_sql": [
            "SELECT city FROM Addresses WHERE zip_postcode = 255"
        ]
    },
    "4918": {
        "db_id": "store_product",
        "question": "Find all the stores in the district with the most population.",
        "ground_truth": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id WHERE district_id  =  (SELECT district_id FROM district ORDER BY city_population DESC LIMIT 1)",
        "amends": [
            "Do specify `t1.store_name` in the SELECT list instead of using `*` to select all columns. Do join `store AS t1` with `store_district AS t2` on `t1.store_id = t2.store_id` instead of querying only the `stores` table. Do reference `district_id` from the joined `store_district` table instead of assuming it exists in the `stores` table. Do use `city_population` in the subquery's ORDER BY instead of `population` to correctly identify the target district. Do reference the `district` table in the subquery instead of `districts` to match the correct table name. The amended query now correctly identifies stores in the district with the highest city population by properly joining the store and store_district tables."
        ],
        "rules": [
            "1) When answering about \"stores in the district with the most population\": make sure the output order includes only t1.store_name. 2) When combining store and store_district tables: link rows where t1.store_id = t2.store_id exactly and keep only matching pairs (inner match). 3) When the question mentions \"district with the most population\": use city_population from the district table to identify the highest population district. 4) When referencing district identifiers: use district_id from the store_district table instead of assuming it exists in the stores table. 5) When identifying the target district: use the district table (not districts) to match the correct table name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM stores WHERE district_id = (SELECT district_id FROM districts ORDER BY population DESC LIMIT 1);",
            "SELECT t1.Store_Name\nFROM store AS t1\nJOIN store_district AS t2 ON t1.Store_ID = t2.Store_ID\nWHERE t2.District_ID = (\n    SELECT District_ID \n    FROM district \n    ORDER BY City_Population DESC \n    LIMIT 1\n)"
        ],
        "rule_sql": [
            "SELECT s.Store_Name\nFROM store s\nJOIN store_district sd ON s.Store_ID = sd.Store_ID\nJOIN district d ON sd.District_ID = d.District_ID\nWHERE d.City_Population = (SELECT MAX(City_Population) FROM district)\nORDER BY s.Store_Name;"
        ]
    },
    "2917": {
        "db_id": "icfp_1",
        "question": "Which authors have first name \"Amal\"? List their last names.",
        "ground_truth": "SELECT lname FROM authors WHERE fname  =  \"Amal\"",
        "amends": [
            "Do select `lname` instead of `first_name` in the SELECT list. Do filter on `fname = \"Amal\"` instead of `last_name = 'Amal'` in the WHERE clause. The amended query now correctly retrieves last names for authors with the first name Amal instead of first names for authors with the last name Amal, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for authors with first name \"Amal\": filter rows where \"fname\" equals exactly \"Amal\". 2) When the question asks to list last names: select the \"lname\" column in the output. 3) When handling text literals: preserve the exact case and spelling of \"Amal\" as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM authors WHERE last_name = 'Amal';",
            "SELECT lname FROM Authors WHERE fname = 'Amal';"
        ],
        "rule_sql": [
            "SELECT lname FROM Authors WHERE fname = 'Amal';"
        ]
    },
    "6965": {
        "db_id": "culture_company",
        "question": "What are the titles and authors or editors that correspond to books made after 1989?",
        "ground_truth": "SELECT book_title ,  author_or_editor FROM book_club WHERE YEAR  >  1989",
        "amends": [
            "Do select `book_title` and `author_or_editor` instead of `title` and `author`. Do query from `book_club` table instead of `books` table. Do keep the filter `YEAR > 1989` unchanged. The amended query now correctly retrieves data from the book_club table with the appropriate column names while maintaining the same year-based filtering logic."
        ],
        "rules": [
            "1) When the question asks for \"titles and authors or editors\": select \"book_title\" and \"author_or_editor\" columns instead of \"title\" and \"author\". 2) When querying about books: use the \"book_club\" table instead of the \"books\" table. 3) When filtering for books made after 1989: keep the condition YEAR > 1989 unchanged."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title, author FROM books WHERE year > 1989",
            "SELECT book_title, author_or_editor FROM book_club WHERE Year > 1989"
        ],
        "rule_sql": [
            "SELECT book_title, author_or_editor FROM book_club WHERE Year > 1989;"
        ]
    },
    "2304": {
        "db_id": "perpetrator",
        "question": "List the date of perpetrators in descending order of the number of people killed.",
        "ground_truth": "SELECT Date FROM perpetrator ORDER BY Killed DESC",
        "amends": [
            "Do reference the `Date` column instead of `date` and use the `perpetrator` table instead of `perpetrators`. Do order by `Killed DESC` instead of `number_of_people_killed ASC`, changing both the column reference and sort direction. The amended query now correctly references the intended table and column names with the proper sort order to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about \"date of perpetrators\": use the exact column name \"Date\" from the \"perpetrator\" table. 2) When ordering by number of people killed: use the exact column name \"Killed\" and sort in descending order (DESC). 3) When the question mentions \"perpetrators\": this refers to the exact table name \"perpetrator\" (singular form)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT date FROM perpetrators ORDER BY number_of_people_killed ASC;",
            "SELECT Date FROM perpetrator ORDER BY Killed DESC;"
        ],
        "rule_sql": [
            "SELECT Date FROM perpetrator ORDER BY Killed DESC;"
        ]
    },
    "6448": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "Give the ids of documents with expenses that have the budget code 'SF'.",
        "ground_truth": "SELECT document_id FROM Documents_with_expenses WHERE budget_type_code  =  'SF'",
        "amends": [
            "Do query the `Documents_with_expenses` table instead of the `expenses` table. Do filter on `budget_type_code` instead of `budget_code`. The amended query now correctly retrieves document IDs from the appropriate table using the correct budget type filter."
        ],
        "rules": [
            "1) When answering about \"documents with expenses\": query the \"Documents_with_expenses\" table instead of the \"expenses\" table. 2) When filtering by budget code: use \"budget_type_code\" column instead of \"budget_code\" column. 3) When filtering for budget code 'SF': use the exact literal value 'SF' with the correct case and no additional spacing."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id FROM expenses WHERE budget_code = 'SF'",
            "SELECT Document_ID FROM Documents_with_Expenses WHERE Budget_Type_Code = 'SF'"
        ],
        "rule_sql": [
            "SELECT Document_ID FROM Documents_with_Expenses WHERE Budget_Type_Code = 'SF';"
        ]
    },
    "4666": {
        "db_id": "college_3",
        "question": "What are the last names of female students, ordered by age descending?",
        "ground_truth": "SELECT LName FROM STUDENT WHERE Sex  =  \"F\" ORDER BY Age DESC",
        "amends": [
            "Do select `LName` instead of `last_name` and use table `STUDENT` instead of `students`. Do filter on `Sex = \"F\"` instead of `gender = 'male'` and order by `Age DESC` instead of `age ASC`."
        ],
        "rules": [
            "1) When the question asks for \"last names\": use the exact column token \"LName\" from table \"STUDENT\" (not \"last_name\"). 2) When the question specifies \"female students\": filter rows where column \"Sex\" equals the exact literal \"F\" (not 'male'). 3) When the question asks for ordering \"by age descending\": sort results by column \"Age\" in descending order (not ascending)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM students WHERE gender = 'male' ORDER BY age ASC;",
            "SELECT LName FROM Student WHERE Sex = 'F' ORDER BY Age DESC;"
        ],
        "rule_sql": [
            "SELECT LName FROM Student WHERE Sex = 'F' ORDER BY Age DESC;"
        ]
    },
    "6088": {
        "db_id": "customers_and_addresses",
        "question": "List all the distinct cities",
        "ground_truth": "SELECT DISTINCT city FROM addresses",
        "amends": [
            "Do query the `addresses` table instead of the `customers` table to retrieve city information. Do keep the `DISTINCT` clause and `city IS NOT NULL` filter as they correctly handle uniqueness and null values respectively. The amended query now correctly sources city data from the appropriate addresses table while maintaining the same filtering and deduplication logic."
        ],
        "rules": [
            "1) When answering about \"distinct cities\": make sure to query the \"addresses\" table instead of the \"customers\" table to retrieve city information. 2) When handling uniqueness requirements: keep the DISTINCT clause to return only unique city values. 3) When filtering for valid data: apply the condition \"city IS NOT NULL\" to exclude null values from the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT city FROM customers WHERE city IS NOT NULL",
            "SELECT DISTINCT city FROM Addresses WHERE city IS NOT NULL;"
        ],
        "rule_sql": [
            "SELECT DISTINCT city FROM Addresses WHERE city IS NOT NULL;"
        ]
    },
    "4737": {
        "db_id": "department_store",
        "question": "Return ids of all the products that are supplied by supplier id 2 and are more expensive than the average price of all products.",
        "ground_truth": "SELECT T1.product_id FROM product_suppliers AS T1 JOIN products AS T2 ON T1.product_id  =  T2.product_id WHERE T1.supplier_id  =  2 AND T2.product_price  >  (SELECT avg(product_price) FROM products)",
        "amends": [
            "Do join `product_suppliers AS T1` with `products AS T2` on `T1.product_id = T2.product_id` instead of querying only the `products` table. Do filter on `T1.supplier_id = 2` instead of `supplier_id = 2` in the main WHERE clause. Do use `T2.product_price` instead of `price` in the price comparison. Do reference the subquery column as `product_price` instead of `price` and remove the supplier filter from the subquery instead of including it. The amended query now correctly joins supplier and product data and calculates the average price across all products rather than just those from supplier 2, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about products supplied by a specific supplier: join \"product_suppliers\" as T1 with \"products\" as T2 where T1.product_id = T2.product_id to combine supplier and product data. 2) When filtering for supplier id 2: use T1.supplier_id = 2 instead of filtering on the products table. 3) When comparing product prices: use T2.product_price instead of price for price comparisons. 4) When calculating average price across all products: compute the average of T2.product_price without supplier filters in the subquery. 5) When selecting product identifiers: return T2.product_id from the joined result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT product_id FROM products WHERE supplier_id = 2 AND price > (SELECT AVG(price) FROM products WHERE supplier_id = 2)",
            "SELECT T1.product_id\nFROM product_suppliers AS T1\nJOIN products AS T2 ON T1.product_id = T2.product_id\nWHERE T1.supplier_id = 2\nAND T2.product_price > (SELECT AVG(product_price) FROM products)"
        ],
        "rule_sql": [
            "SELECT T2.product_id\nFROM Product_Suppliers AS T1\nJOIN Products AS T2 ON T1.product_id = T2.product_id\nWHERE T1.supplier_id = 2\nAND T2.product_price > (SELECT AVG(product_price) FROM Products)"
        ]
    },
    "5610": {
        "db_id": "swimming",
        "question": "Which country has both stadiums with capacity greater than 60000 and stadiums with capacity less than 50000?",
        "ground_truth": "SELECT country FROM stadium WHERE capacity  >  60000 INTERSECT SELECT country FROM stadium WHERE capacity  <  50000",
        "amends": [
            "Do use `INTERSECT` with two separate queries instead of a single `WHERE` clause with contradictory conditions. Do query from table `stadium` instead of `stadiums`. Do add a second `SELECT country FROM stadium WHERE capacity < 50000` instead of trying to combine both conditions in one filter. Do remove the contradictory `capacity > 60000 AND capacity < 50000` condition instead of keeping it, as no value can satisfy both constraints simultaneously. The amended query now correctly finds countries that have both stadiums with capacity over 60,000 and stadiums with capacity under 50,000, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about countries with stadiums meeting two different capacity conditions: use INTERSECT to combine results from two separate queries instead of using contradictory conditions in a single WHERE clause. 2) When referring to the stadium table: use the exact table name \"stadium\" instead of \"stadiums\". 3) When finding countries with stadiums having capacity greater than 60000: use SELECT country FROM stadium WHERE capacity > 60000. 4) When finding countries with stadiums having capacity less than 50000: use SELECT country FROM stadium WHERE capacity < 50000. 5) When combining the two sets of countries: use INTERSECT to find countries that appear in both result sets, ensuring the country has both types of stadiums."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM stadiums WHERE capacity > 60000 AND capacity < 50000;",
            "SELECT Country FROM stadium WHERE Capacity > 60000\nINTERSECT\nSELECT Country FROM stadium WHERE Capacity < 50000"
        ],
        "rule_sql": [
            "SELECT Country FROM stadium WHERE Capacity > 60000\nINTERSECT\nSELECT Country FROM stadium WHERE Capacity < 50000"
        ]
    },
    "1159": {
        "db_id": "body_builder",
        "question": "What are the birth date and birth place of the body builder with the highest total points?",
        "ground_truth": "SELECT T2.Birth_Date ,  T2.Birth_Place FROM body_builder AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T1.Total DESC LIMIT 1",
        "amends": [
            "Do add table `people` with alias `T2` and join it to `body_builder` as `T1` using `ON T1.People_ID = T2.People_ID` instead of querying only `body_builders`. Do select columns `T2.Birth_Date` and `T2.Birth_Place` from the joined table instead of `birth_date` and `birth_place` from a single table. Do order by `T1.Total DESC` instead of `total_points ASC` to sort by descending total points rather than ascending. The amended query now correctly retrieves birth information from the people table while ordering by the body builder's total points in descending order to find the top performer."
        ],
        "rules": [
            "1) When answering about birth date and birth place of body builders: select T2.Birth_Date and T2.Birth_Place as output columns. 2) When combining body_builder and people tables: link rows where T1.People_ID = T2.People_ID and keep only matching pairs (inner match). 3) When the question mentions \"highest total points\": rank rows by T1.Total in descending order and keep the first 1 row. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT birth_date, birth_place FROM body_builders ORDER BY total_points ASC LIMIT 1;",
            "SELECT T2.Birth_Date, T2.Birth_Place FROM body_builder T1 JOIN people T2 ON T1.People_ID = T2.People_ID ORDER BY T1.Total DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Birth_Date, T2.Birth_Place FROM body_builder T1 INNER JOIN people T2 ON T1.People_ID = T2.People_ID ORDER BY T1.Total DESC LIMIT 1"
        ]
    },
    "4033": {
        "db_id": "student_1",
        "question": "What are the first names of students in room 108?",
        "ground_truth": "SELECT firstname FROM list WHERE classroom  =  108",
        "amends": [
            "Do select `firstname` from the `list` table instead of `last_name` from `students`. Do filter on `classroom = 108` instead of `room_number = 108`. Do use table `list` instead of `students`."
        ],
        "rules": [
            "1) When the question asks for \"first names of students\": select \"firstname\" from the \"list\" table. 2) When filtering by room number: use the condition \"classroom = 108\" with the exact literal value 108. 3) When choosing the source table: use the \"list\" table instead of any other table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM students WHERE room_number = 108;",
            "SELECT FirstName FROM list WHERE Classroom = 108"
        ],
        "rule_sql": [
            "SELECT FirstName FROM list WHERE Classroom = 108"
        ]
    },
    "6210": {
        "db_id": "roller_coaster",
        "question": "Show the different statuses and the numbers of roller coasters for each status.",
        "ground_truth": "SELECT Status ,  COUNT(*) FROM roller_coaster GROUP BY Status",
        "amends": [
            "Do reference table `roller_coaster` instead of `roller_coasters` and use column name `Status` instead of `status` while maintaining the same COUNT(*) aggregation and GROUP BY logic, with the amended query now matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"different statuses and numbers of roller coasters for each status\": make sure the output order: Status, count of roller coasters. 2) When the question mentions \"statuses\": \"statuses\" actually means \"Status in schema\". 3) When the question asks for \"numbers of roller coasters for each status\": compute the count of roller coasters per Status group using the canonical counting method. 4) When grouping by Status: organize results by the exact column token \"Status\" and compute the count per group. 5) When choosing identifier delimiters: use the exact column name \"Status\" as shown in the schema without changing case or adding quotes unless specified."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT status, COUNT(*) FROM roller_coasters GROUP BY status;",
            "SELECT Status, COUNT(*) FROM roller_coaster GROUP BY Status;"
        ],
        "rule_sql": [
            "SELECT Status, COUNT(*) AS \"count of roller coasters\" FROM roller_coaster GROUP BY Status ORDER BY Status;"
        ]
    },
    "12": {
        "db_id": "department_management",
        "question": "What are the distinct ages of the heads who are acting?",
        "ground_truth": "SELECT DISTINCT T1.age FROM management AS T2 JOIN head AS T1 ON T1.head_id  =  T2.head_id WHERE T2.temporary_acting  =  'Yes'",
        "amends": [
            "Do use `management AS T2` and `head AS T1` as FROM sources instead of just `heads` table. Do add `JOIN` with `ON T1.head_id = T2.head_id` instead of having no join condition. Do select `T1.age` with table alias qualification instead of just `age`. Do change the WHERE filter to `T2.temporary_acting = 'Yes'` instead of `status = 'acting'`. The amended query now correctly joins the management and head tables to identify temporary acting heads and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about distinct ages of heads who are acting: use tables \"management\" as T2 and \"head\" as T1 instead of just \"heads\" table. 2) When combining T1 and T2 for shared entities: link rows where T1.head_id = T2.head_id and keep only matching pairs (inner match). 3) When selecting age information: use T1.age with table alias qualification instead of just age. 4) When filtering for acting heads: use T2.temporary_acting = 'Yes' instead of status = 'acting' to identify temporary acting heads."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT age FROM heads WHERE status = 'acting'",
            "SELECT DISTINCT T1.age FROM head AS T1 JOIN management AS T2 ON T1.head_ID = T2.head_ID WHERE T2.temporary_acting = 'Yes'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.age FROM head AS T1 INNER JOIN management AS T2 ON T1.head_ID = T2.head_ID WHERE T2.temporary_acting = 'Yes'"
        ]
    },
    "2864": {
        "db_id": "icfp_1",
        "question": "What are the titles of papers published by \"Jeremy Gibbons\"?",
        "ground_truth": "SELECT t3.title FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid WHERE  t1.fname  =  \"Jeremy\" AND t1.lname  =  \"Gibbons\"",
        "amends": [
            "Do join `authors AS t1` and `authorship AS t2` on `t1.authid = t2.authid` instead of omitting these tables entirely. Do join `papers AS t3` on `t2.paperid = t3.paperid` instead of querying `papers` directly without proper relationships. Do filter on `t1.fname = \"Jeremy\"` and `t1.lname = \"Gibbons\"` instead of incorrectly filtering `author = 'Jeremy Gibbons'` which doesn't match the schema structure. Do select `t3.title` with proper table qualification instead of just `title` which could be ambiguous. The amended query now correctly retrieves paper titles by joining through the authorship relationship table instead of making incorrect assumptions about the schema structure."
        ],
        "rules": [
            "1) When answering about \"titles of papers published by Jeremy Gibbons\": make sure the output order: t3.title\n2) When the question mentions \"Jeremy Gibbons\": \"Jeremy Gibbons\" actually means \"t1.fname = 'Jeremy' and t1.lname = 'Gibbons'\" in schema\n3) When combining authors as T1 and authorship as T2 for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (t1.authid = t2.authid); keep only matching pairs (inner match)\n4) When combining authorship as T2 and papers as T3 for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (t2.paperid = t3.paperid); keep only matching pairs (inner match)\n5) When selecting paper titles: use t3.title with proper table qualification instead of just title to avoid ambiguity"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM papers WHERE author = 'Jeremy Gibbons';",
            "SELECT t3.title \nFROM Authors AS t1 \nJOIN Authorship AS t2 ON t1.authID = t2.authID \nJOIN Papers AS t3 ON t2.paperID = t3.paperID \nWHERE t1.fname = 'Jeremy' AND t1.lname = 'Gibbons'"
        ],
        "rule_sql": [
            "SELECT t3.title\nFROM Authors t1\nINNER JOIN Authorship t2 ON t1.authID = t2.authID\nINNER JOIN Papers t3 ON t2.paperID = t3.paperID\nWHERE t1.fname = 'Jeremy' AND t1.lname = 'Gibbons'\nORDER BY t3.title"
        ]
    },
    "3327": {
        "db_id": "college_1",
        "question": "Find the first name and office of history professor who did not get a Ph.D. degree.",
        "ground_truth": "SELECT T2.emp_fname ,  T1.prof_office FROM professor AS T1 JOIN employee AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T1.dept_code  =  T3.dept_code WHERE T3.dept_name  =  'History' AND T1.prof_high_degree != 'Ph.D.'",
        "amends": [
            "Do join `professor AS T1` with `employee AS T2` on `T1.emp_num = T2.emp_num` and `department AS T3` on `T1.dept_code = T3.dept_code` instead of querying a single `professors` table. Do select `T2.emp_fname` and `T1.prof_office` instead of `first_name` and `office`. Do filter on `T3.dept_name = 'History'` instead of `department = 'History'` and `T1.prof_high_degree != 'Ph.D.'` instead of `degree != 'Ph.D.'`. The amended query now correctly joins related tables and uses the proper column names to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"history professor who did not get a Ph.D. degree\": make sure the output order: T2.emp_fname, T1.prof_office\n2) When the question mentions \"history professor\": join professor AS T1 with department AS T3 on T1.dept_code = T3.dept_code where T3.dept_name = 'History'\n3) When the question mentions \"first name\": \"first name\" actually means \"T2.emp_fname in schema\"\n4) When the question mentions \"office\": \"office\" actually means \"T1.prof_office in schema\"\n5) When the question mentions \"did not get a Ph.D. degree\": filter where T1.prof_high_degree != 'Ph.D.'\n6) When combining professor AS T1 and employee AS T2: link rows where T1.emp_num = T2.emp_num and keep only matching pairs (inner match)\n7) When combining professor AS T1 and department AS T3: link rows where T1.dept_code = T3.dept_code and keep only matching pairs (inner match)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, office FROM professors WHERE department = 'History' AND degree != 'Ph.D.'",
            "SELECT T2.emp_fname, T1.prof_office \nFROM professor AS T1 \nJOIN employee AS T2 ON T1.emp_num = T2.emp_num \nJOIN department AS T3 ON T1.dept_code = T3.dept_code \nWHERE T3.dept_name = 'History' AND T1.prof_high_degree != 'Ph.D.'"
        ],
        "rule_sql": [
            "SELECT T2.emp_fname, T1.prof_office\nFROM professor AS T1\nINNER JOIN employee AS T2 ON T1.emp_num = T2.emp_num\nINNER JOIN department AS T3 ON T1.dept_code = T3.dept_code\nWHERE T3.dept_name = 'History'\nAND T1.prof_high_degree != 'Ph.D.'"
        ]
    },
    "4345": {
        "db_id": "tracking_grants_for_research",
        "question": "How many different roles are there on the project staff?",
        "ground_truth": "SELECT count(DISTINCT role_code) FROM Project_Staff",
        "amends": [
            "Do count `DISTINCT role_code` instead of `COUNT(*)` to count unique roles rather than all staff members. Do query from `Project_Staff` table instead of `staff` table to access the correct data source. Do remove the `WHERE project_id = 1` filter instead of keeping it to count roles across all projects rather than filtering to a specific project. The amended query now correctly counts distinct role codes from the Project_Staff table without unnecessary filtering."
        ],
        "rules": [
            "1) When counting different roles on project staff: count distinct values of \"role_code\" instead of counting all rows. 2) When accessing project staff data: use the \"Project_Staff\" table instead of any other table. 3) When counting roles across all projects: do not filter by any specific project_id value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM staff WHERE project_id = 1;",
            "SELECT COUNT(DISTINCT role_code) FROM Project_Staff;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT role_code) FROM Project_Staff;"
        ]
    },
    "6472": {
        "db_id": "scientist_1",
        "question": "What is the total number of hours for all projects?",
        "ground_truth": "SELECT sum(hours) FROM projects",
        "amends": [
            "Do select from `projects` table instead of `employees` table. Do use lowercase `sum(hours)` instead of uppercase `SUM(hours)` to match the right SQL's formatting. The amended query now correctly aggregates hours from the projects table instead of employees, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"total number of hours for all projects\": select from the \"projects\" table instead of the \"employees\" table. 2) When computing the sum of hours: use lowercase \"sum(hours)\" instead of uppercase \"SUM(hours)\" to match the correct SQL formatting. 3) When aggregating hours from projects: ensure the sum operation is performed on the \"hours\" column from the \"projects\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(hours) FROM employees;",
            "SELECT sum(hours) FROM Projects;"
        ],
        "rule_sql": [
            "SELECT sum(hours) FROM Projects;"
        ]
    },
    "6930": {
        "db_id": "tracking_orders",
        "question": "Which order deals with the most items? Return the order id.",
        "ground_truth": "SELECT T1.order_id FROM orders AS T1 JOIN order_items AS T2 ON T1.order_id = T2.order_id GROUP BY T1.order_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT order_id FROM orders ORDER BY order_id DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT o.order_id\nFROM Orders o\nJOIN Order_Items oi ON o.order_id = oi.order_id\nGROUP BY o.order_id\nORDER BY COUNT(oi.order_item_id) DESC\nLIMIT 1;"
        ]
    },
    "2876": {
        "db_id": "icfp_1",
        "question": "Which authors belong to the institution \"Google\"? Show the first names and last names.",
        "ground_truth": "SELECT DISTINCT t1.fname ,  t1.lname FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN inst AS t3 ON t2.instid  =  t3.instid WHERE t3.name  =  \"Google\"",
        "amends": [
            "Do select `t1.fname` and `t1.lname` with `DISTINCT` instead of `first_name` and `last_name` without distinct. Do add joins to `authorship AS t2` on `t1.authid = t2.authid` and `inst AS t3` on `t2.instid = t3.instid` instead of querying only the `authors` table. Do filter on `t3.name = \"Google\"` instead of `institution = 'Google'` to properly reference the institution name from the joined table. The amended query now correctly identifies authors from Google by joining through the authorship relationship and institution table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about authors from institution \"Google\": make sure the output order: t1.fname, t1.lname. 2) When the question mentions \"first names and last names\": \"first_name\" actually means \"t1.fname\" in schema and \"last_name\" actually means \"t1.lname\" in schema. 3) When the question asks for authors from a specific institution: combine tables authors AS t1, authorship AS t2, and inst AS t3 by linking rows where t1.authid = t2.authid and t2.instid = t3.instid, keeping only matching pairs (inner match). 4) When filtering for institution \"Google\": use exact literal \"Google\" with t3.name = \"Google\" to properly reference the institution name. 5) When selecting author names: use DISTINCT to ensure each author appears only once in the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM authors WHERE institution = 'Google';",
            "SELECT DISTINCT t1.fname, t1.lname\nFROM Authors AS t1\nJOIN Authorship AS t2 ON t1.authID = t2.authID\nJOIN Inst AS t3 ON t2.instID = t3.instID\nWHERE t3.name = 'Google'"
        ],
        "rule_sql": [
            "SELECT DISTINCT t1.fname, t1.lname\nFROM Authors AS t1\nINNER JOIN Authorship AS t2 ON t1.authID = t2.authID\nINNER JOIN Inst AS t3 ON t2.instID = t3.instID\nWHERE t3.name = 'Google'\nORDER BY t1.fname, t1.lname"
        ]
    },
    "5002": {
        "db_id": "soccer_2",
        "question": "Find the name and hours of the students whose tryout decision is yes.",
        "ground_truth": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'",
        "amends": [
            "Do select `T1.pName` and `T1.HS` instead of `name` and `hours`. Do use `FROM player AS T1 JOIN tryout AS T2` instead of `FROM students` alone. Do add `ON T1.pID = T2.pID` join condition instead of omitting it. Do filter on `T2.decision = 'yes'` instead of `tryout_decision = 'no'`. The amended query now correctly joins player and tryout tables and filters for accepted decisions, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"name and hours of students whose tryout decision is yes\": make sure the output order: T1.pName, T1.HS 2) When combining player and tryout tables: link rows where T1.pID = T2.pID and keep only matching pairs (inner match) 3) When filtering for tryout decision: use T2.decision = 'yes' exactly as specified 4) When the question mentions \"name\": \"name\" actually means \"T1.pName in schema\" 5) When the question mentions \"hours\": \"hours\" actually means \"T1.HS in schema\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, hours FROM students WHERE tryout_decision = 'no';",
            "SELECT T1.pName, T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID = T2.pID WHERE T2.decision = 'yes'"
        ],
        "rule_sql": [
            "SELECT T1.pName, T1.HS FROM Player T1 INNER JOIN Tryout T2 ON T1.pID = T2.pID WHERE T2.decision = 'yes'"
        ]
    },
    "2145": {
        "db_id": "local_govt_in_alabama",
        "question": "How many events had participants whose details had the substring 'Dr.'",
        "ground_truth": "SELECT count(*) FROM participants AS T1 JOIN Participants_in_Events AS T2 ON T1.Participant_ID  =  T2.Participant_ID WHERE T1.participant_details LIKE '%Dr.%'",
        "amends": [
            "Do join `participants` and `Participants_in_Events` tables on `Participant_ID` instead of querying only the `events` table. Do filter on `participant_details` column containing '%Dr.%' instead of filtering the `participants` column in the `events` table. Do use a proper join relationship to count participants with 'Dr.' in their details instead of attempting to search for this pattern in what appears to be a misused column. The amended query now correctly identifies participants with 'Dr.' in their details through the appropriate table relationships and filtering logic."
        ],
        "rules": [
            "1) When the question asks about events with participants containing 'Dr.' in details: join the participants and Participants_in_Events tables using the exact key relationship Participant_ID = Participant_ID. 2) When filtering for participants with 'Dr.' in their details: apply the filter condition participant_details LIKE '%Dr.%' exactly as specified. 3) When counting events with such participants: count the distinct events using the appropriate event identifier after establishing the correct table relationships through the join."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM events WHERE participants LIKE '%Dr.%';",
            "SELECT COUNT(DISTINCT e.Event_ID) \nFROM Events e\nJOIN Participants_in_Events pie ON e.Event_ID = pie.Event_ID\nJOIN Participants p ON pie.Participant_ID = p.Participant_ID\nWHERE p.Participant_Details LIKE '%Dr.%'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT e.Event_ID) \nFROM Events e\nJOIN Participants_in_Events pie ON e.Event_ID = pie.Event_ID\nJOIN Participants p ON pie.Participant_ID = p.Participant_ID\nWHERE p.Participant_Details LIKE '%Dr.%'"
        ]
    },
    "2452": {
        "db_id": "movie_1",
        "question": "Find all years that have a movie that received a rating of 4 or 5, and sort them in increasing order of year.",
        "ground_truth": "SELECT DISTINCT YEAR FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID WHERE T2.stars  >=  4 ORDER BY T1.year",
        "amends": [
            "Do reference the `year` column from the `Movie` table as `T1.year` instead of just `year` without table qualification. Do join the `Rating` table as `T2` with `T1.mID = T2.mID` instead of querying only the `movies` table. Do filter on `T2.stars >= 4` instead of `rating >= 4` to correctly reference the rating column from the joined table. Do remove the `DESC` ordering modifier instead of keeping it to match the ascending order behavior. The amended query now correctly joins the Movie and Rating tables to filter movies by their star ratings and returns distinct years in ascending order."
        ],
        "rules": [
            "1) When answering about \"years that have a movie that received a rating of 4 or 5\": make sure the output order: T1.year in increasing order. 2) When the question mentions \"rating of 4 or 5\": \"rating\" actually means \"T2.stars >= 4\" in schema. 3) When combining T1 (Movie) and T2 (Rating) for shared entities: link rows where T1.mID = T2.mID exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"distinct years\": compute the number of unique values of the exact token T1.year. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT year FROM movies WHERE rating >= 4 ORDER BY year DESC;",
            "SELECT DISTINCT T1.year FROM Movie T1 JOIN Rating T2 ON T1.mID = T2.mID WHERE T2.stars >= 4 ORDER BY T1.year ASC;"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.year\nFROM Movie T1\nINNER JOIN Rating T2 ON T1.mID = T2.mID\nWHERE T2.stars >= 4\nORDER BY T1.year ASC;"
        ]
    },
    "1846": {
        "db_id": "wrestler",
        "question": "List the names of wrestlers in descending order of days held.",
        "ground_truth": "SELECT Name FROM wrestler ORDER BY Days_held DESC",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the `wrestler` table instead of `wrestlers`. Do order by `Days_held DESC` instead of `days_held ASC` to sort in descending order rather than ascending. The amended query now correctly references the proper table and column names with the intended descending sort order."
        ],
        "rules": [
            "1) When answering about \"names of wrestlers\": use the exact column token \"Name\" from the wrestler table. 2) When the question mentions \"wrestlers\": the correct table name is \"wrestler\" not \"wrestlers\". 3) When ordering by \"days held\": use the exact column token \"Days_held\" and sort in descending order (DESC) rather than ascending (ASC)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM wrestlers ORDER BY days_held ASC;",
            "SELECT Name FROM wrestler ORDER BY Days_held DESC;"
        ],
        "rule_sql": [
            "SELECT Name FROM wrestler ORDER BY Days_held DESC;"
        ]
    },
    "6098": {
        "db_id": "customers_and_addresses",
        "question": "Find the contact channel code that was used by the customer named \"Tillman Ernser\".",
        "ground_truth": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  \"Tillman Ernser\"",
        "amends": [
            "Do select `channel_code` instead of `contact_channel`. Do add table `customer_contact_channels` with alias `t2` instead of omitting it. Do use `JOIN` with `ON t1.customer_id = t2.customer_id` instead of querying only the `customers` table. Do add table alias `t1` for `customers` instead of omitting aliases. Do add `DISTINCT` modifier instead of omitting it. Do use double quotes around string literal instead of single quotes. The amended query now correctly retrieves distinct channel codes from the joined customer contact channels table instead of attempting to select from a non-existent column in the base table."
        ],
        "rules": [
            "1) When the question asks for \"contact channel code\": use the exact column token \"channel_code\" from the Customer_Contact_Channels table instead of \"contact_channel\". 2) When joining tables for customer contact information: link rows where t1.customer_id = t2.customer_id using an inner match between customers table (t1) and customer_contact_channels table (t2). 3) When filtering by customer name \"Tillman Ernser\": use double quotes around the literal exactly as \"Tillman Ernser\" instead of single quotes. 4) When retrieving channel codes for a customer: use DISTINCT modifier to return only unique channel_code values. 5) When selecting from multiple tables: use table aliases t1 for customers and t2 for customer_contact_channels as specified in the join condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT contact_channel FROM customers WHERE customer_name = 'Tillman Ernser';",
            "SELECT DISTINCT t2.channel_code\nFROM customers t1\nJOIN customer_contact_channels t2 ON t1.customer_id = t2.customer_id\nWHERE t1.customer_name = \"Tillman Ernser\""
        ],
        "rule_sql": [
            "SELECT DISTINCT t2.channel_code\nFROM Customers t1\nINNER JOIN Customer_Contact_Channels t2 ON t1.customer_id = t2.customer_id\nWHERE t1.customer_name = \"Tillman Ernser\""
        ]
    },
    "1922": {
        "db_id": "protein_institute",
        "question": "For each building, show the name of the building and the number of institutions in it.",
        "ground_truth": "SELECT T1.name ,  count(*) FROM building AS T1 JOIN institution AS T2 ON T1.building_id  =  T2.building_id GROUP BY T1.building_id",
        "amends": [
            "Do use `T1.name` instead of `building_name` in the SELECT list. Do join `building AS T1` and `institution AS T2` instead of querying only `institutions`. Do use the join condition `T1.building_id = T2.building_id` instead of no join condition. Do group by `T1.building_id` instead of `building_name`. The amended query now correctly counts institutions per building by joining the building and institution tables and grouping on the building identifier.",
            "Do use `JOIN` instead of `LEFT JOIN` to exclude buildings without institutions. Do reference `T1.name` instead of `T1.Name` for case sensitivity. Do use `count(*)` instead of `COUNT(T2.Institution_id)` to count all institution records rather than non-null institution IDs. Do remove the alias `number_of_institutions` instead of keeping it. The amended query now correctly counts all institutions per building while excluding buildings without any associated institutions."
        ],
        "rules": [
            "1) When answering about \"number of institutions in each building\": make sure the output order: T1.name, COUNT(T2.institution_id) 2) When the question mentions \"building\": \"building\" actually means \"T1.name in schema\" 3) When the question mentions \"institutions\": \"institutions\" actually means \"T2.institution_id in schema\" 4) When combining T1 and T2 for shared entities: link rows where T1.building_id = T2.building_id exactly as shown in the amends; keep only matching pairs (inner match) 5) When the question asks for \"count of institutions\": compute the number of rows using the canonical key token T2.institution_id 6) When the question says \"per building\"/\"by building\": organize results by T1.building_id and compute requested aggregates per group",
            "1) When combining building and Institution tables: link rows where T1.building_id = T2.building_id and keep only matching pairs (inner match) to exclude buildings without institutions. 2) When referencing the building name column: use exact token \"T1.name\" instead of \"T1.Name\" for case sensitivity. 3) When counting institutions per building: count all institution records using count(*) rather than counting non-null institution IDs. 4) When producing output columns: show T1.name first followed by the count of institutions, without using any alias for the count column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT building_name, COUNT(*) FROM institutions GROUP BY building_name;",
            "SELECT T1.Name, COUNT(T2.Institution_id) AS number_of_institutions\nFROM building AS T1\nLEFT JOIN Institution AS T2 ON T1.building_id = T2.building_id\nGROUP BY T1.building_id;",
            "SELECT T1.name, COUNT(*) FROM building AS T1 JOIN Institution AS T2 ON T1.building_id = T2.building_id GROUP BY T1.building_id"
        ],
        "rule_sql": [
            "SELECT T1.Name, COUNT(*) FROM building T1 JOIN Institution T2 ON T1.building_id = T2.building_id GROUP BY T1.building_id"
        ]
    },
    "900": {
        "db_id": "insurance_fnol",
        "question": "Find the policy types more than 4 customers use. Show their type code.",
        "ground_truth": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*)  >  4",
        "amends": [
            "Do reference `policy_type_code` from the `available_policies` table instead of `type_code` from the `policies` table. Do use `count(*)` to count all rows in each group instead of `COUNT(customer_id)` which only counts non-null customer_id values. The amended query now correctly identifies policy types with more than 4 available policies by counting all records in each group rather than just those with customer associations."
        ],
        "rules": [
            "1) When the question asks for \"policy types\": use \"policy_type_code\" from the \"available_policies\" table. 2) When counting policy types: count all rows in each group using count(*) instead of counting specific columns. 3) When filtering for policy types used by more than 4 customers: apply the condition > 4 to the count result."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT type_code FROM policies GROUP BY type_code HAVING COUNT(customer_id) > 4;",
            "SELECT policy_type_code \nFROM Available_Policies \nGROUP BY policy_type_code \nHAVING COUNT(*) > 4"
        ],
        "rule_sql": [
            "SELECT ap.policy_type_code\nFROM Available_Policies ap\nJOIN Customers_Policies cp ON ap.Policy_ID = cp.Policy_ID\nGROUP BY ap.policy_type_code\nHAVING COUNT(*) > 4"
        ]
    },
    "279": {
        "db_id": "twitter_1",
        "question": "Find the number of tweets in record.",
        "ground_truth": "SELECT count(*) FROM tweets",
        "amends": [
            "Do select from `tweets` table instead of `users` table. The amended query now matches RIGHT_SQL's behavior by counting records from the correct table."
        ],
        "rules": [
            "1) When answering about \"number of tweets in record\": make sure to count from the \"tweets\" table instead of the \"users\" table. 2) When counting tweets: use the canonical counting method for records in the \"tweets\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users;",
            "SELECT COUNT(*) FROM tweets;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM tweets;"
        ]
    },
    "6947": {
        "db_id": "architecture",
        "question": "What is the maximum length in meters for the bridges and what are the architects' names?",
        "ground_truth": "SELECT max(T1.length_meters) ,  T2.name FROM bridge AS T1 JOIN architect AS T2 ON T1.architect_id  =  T2.id",
        "amends": [
            "Do reference the `bridge` table as `T1` and `architect` table as `T2` instead of using a single table. Do join `T1.architect_id = T2.id` instead of grouping by a non-existent column. Do select `max(T1.length_meters)` instead of `MAX(length)` to use the correct column name and table alias. Do select `T2.name` instead of `architect_name` to reference the actual column from the joined table. Do remove the `GROUP BY` clause instead of keeping it since the join provides the correct architect association without aggregation. The amended query now correctly retrieves maximum bridge lengths with architect names through proper table joining instead of incorrect grouping."
        ],
        "rules": [
            "1) When answering about maximum bridge length and architect names: make sure to reference the bridge table as T1 and architect table as T2. 2) When combining T1 and T2 for shared entities: link rows where T1.architect_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match). 3) When the question asks for maximum length in meters: compute max(T1.length_meters) instead of MAX(length) to use the correct column name and table alias. 4) When the question asks for architects' names: select T2.name instead of architect_name to reference the actual column from the joined table. 5) When the question does not require grouping by architect: remove the GROUP BY clause since the join provides the correct architect association without aggregation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(length), architect_name FROM bridges GROUP BY architect_name;",
            "SELECT MAX(T1.length_meters), T2.name FROM bridge T1 JOIN architect T2 ON T1.architect_id = T2.id"
        ],
        "rule_sql": [
            "SELECT MAX(T1.length_meters) AS max_length_meters, T2.name AS architect_name FROM bridge T1 INNER JOIN architect T2 ON T1.architect_id = T2.id"
        ]
    },
    "1187": {
        "db_id": "election_representative",
        "question": "What are the different parties of representative? Show the party name and the number of representatives in each party.",
        "ground_truth": "SELECT Party ,  COUNT(*) FROM representative GROUP BY Party",
        "amends": [
            "Do reference the table as `representative` instead of `representatives` and use consistent capitalization `Party` instead of `party` in both the SELECT list and GROUP BY clause, while maintaining the same COUNT(*) aggregation logic. The amended query now correctly references the intended table and uses consistent column naming to match RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"different parties of representative\": reference the table as \"representative\" instead of \"representatives\". 2) When selecting and grouping by party information: use the exact column name \"Party\" with consistent capitalization in both SELECT list and GROUP BY clause. 3) When counting representatives per party: use COUNT(*) aggregation to count all rows in each party group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT party, COUNT(*) FROM representatives GROUP BY party;",
            "SELECT Party, COUNT(*) AS Number_of_Representatives FROM representative GROUP BY Party;"
        ],
        "rule_sql": [
            "SELECT Party, COUNT(*) AS NumberOfRepresentatives FROM representative GROUP BY Party;"
        ]
    },
    "3865": {
        "db_id": "insurance_policies",
        "question": "Find the number of settlements each claim corresponds to. Show the number together with the claim id.",
        "ground_truth": "SELECT T1.Claim_id ,  count(*) FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT claim_id, COUNT(*) FROM settlements GROUP BY claim_id;"
        ],
        "rule_sql": [
            "SELECT c.Claim_ID, COUNT(s.Settlement_ID) AS Number_of_Settlements\nFROM Claims c\nLEFT JOIN Settlements s ON c.Claim_ID = s.Claim_ID\nGROUP BY c.Claim_ID\nORDER BY c.Claim_ID;",
            "SELECT c.Claim_ID, COUNT(s.Settlement_ID) AS Number_of_Settlements\nFROM Claims c\nLEFT JOIN Settlements s ON c.Claim_ID = s.Claim_ID\nGROUP BY c.Claim_ID\nORDER BY c.Claim_ID;"
        ]
    },
    "3497": {
        "db_id": "hr_1",
        "question": "Find the ids of the employees who does not work in those departments where some employees works whose manager id within the range 100 and 200.",
        "ground_truth": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)",
        "amends": [
            "Do select all columns with `*` instead of only `employee_id` in the SELECT list. Do reference the `departments` table instead of `employees` in the subquery's FROM clause. Do filter by `manager_id BETWEEN 100 AND 200` on the `departments` table instead of the `employees` table in the subquery. The amended query now correctly identifies employees whose department is not managed by managers with IDs between 100-200, matching the RIGHT_SQL's behavior.",
            "Do select all columns with `*` instead of only `employee_id` in the SELECT list, while keeping the same FROM source of `employees`, the same WHERE filter using `department_id NOT IN` with the same correlated subquery that selects `department_id` from `departments` with the same `manager_id BETWEEN 100 AND 200` predicate. The amended query now correctly returns all employee columns instead of just the ID, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting all columns from the employees table: use * instead of specifying individual column names like employee_id. 2) When filtering departments based on manager_id range: reference the departments table instead of the employees table in subqueries. 3) When checking for manager_id values between 100 and 200: apply the filter manager_id BETWEEN 100 AND 200 directly on the departments table rather than the employees table. 4) When identifying employees not in certain departments: use a NOT IN subquery that selects department_id from departments where the manager_id condition is met.",
            "1) When the question asks for \"ids of the employees\": select all columns using * instead of just employee_id to match the complete employee records. 2) When filtering departments by manager_id range: use manager_id BETWEEN 100 AND 200 to include managers with IDs from 100 to 200 inclusive. 3) When finding employees not in certain departments: use department_id NOT IN with a subquery that selects department_id from departments where the manager_id condition is satisfied. 4) When combining employee and department data: use the department_id as the linking key between employees and departments tables."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT employee_id FROM employees WHERE department_id NOT IN (SELECT department_id FROM employees WHERE manager_id BETWEEN 100 AND 200)",
            "SELECT employee_id FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)",
            "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)"
        ],
        "rule_sql": [
            "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)"
        ]
    },
    "3483": {
        "db_id": "hr_1",
        "question": "display all the information about the department Marketing.",
        "ground_truth": "SELECT * FROM  departments WHERE department_name  =  'Marketing'",
        "amends": [
            "Do query the `departments` table instead of the `employees` table. Do filter on `department_name = 'Marketing'` instead of `department = 'Marketing'` to correctly reference the department name column. The amended query now matches the intended behavior of selecting from the departments table with the appropriate filter condition."
        ],
        "rules": [
            "1) When answering about \"department Marketing\": query the \"departments\" table instead of the \"employees\" table. 2) When filtering for the Marketing department: use the exact condition \"department_name = 'Marketing'\" with the exact literal 'Marketing' (case-sensitive). 3) When displaying all information about a department: select all columns from the \"departments\" table where the department name matches exactly 'Marketing'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM employees WHERE department = 'Marketing';",
            "SELECT * FROM departments WHERE department_name = 'Marketing';"
        ],
        "rule_sql": [
            "SELECT * FROM departments WHERE department_name = 'Marketing';"
        ]
    },
    "3245": {
        "db_id": "college_1",
        "question": "What is the first name of students enrolled in class ACCT-211 and got grade C?",
        "ground_truth": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211' AND T2.enroll_grade  =  'C'",
        "amends": [
            "Do select `T3.stu_fname` instead of `first_name` and remove the `ORDER BY student_id LIMIT 1` clause instead of keeping it. Do join three tables using `CLASS AS T1 JOIN enroll AS T2 ON T1.class_code = T2.class_code JOIN student AS T3 ON T2.stu_num = T3.stu_num` instead of querying a single `students` table. Do filter on `T1.crs_code = 'ACCT-211'` instead of `class = 'ACCT-211'` and `T2.enroll_grade = 'C'` instead of `grade = 'C'`. The amended query now correctly joins the appropriate tables and matches the intended behavior by retrieving student first names from the proper relationship structure."
        ],
        "rules": [
            "1) When answering about student first names for specific class and grade: use T3.stu_fname as the output column instead of first_name. 2) When the question mentions class ACCT-211: filter using T1.crs_code = 'ACCT-211' instead of class = 'ACCT-211'. 3) When the question mentions grade C: filter using T2.enroll_grade = 'C' instead of grade = 'C'. 4) When combining CLASS, enroll, and student tables: link CLASS as T1 with enroll as T2 using T1.class_code = T2.class_code, then link enroll as T2 with student as T3 using T2.stu_num = T3.stu_num, keeping only matching pairs (inner joins). 5) When the question asks for first names without ranking: remove any ORDER BY and LIMIT clauses that were incorrectly added for ranking purposes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE class = 'ACCT-211' AND grade = 'C' ORDER BY student_id LIMIT 1;",
            "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code = T2.class_code JOIN student AS T3 ON T2.stu_num = T3.stu_num WHERE T1.crs_code = 'ACCT-211' AND T2.enroll_grade = 'C'"
        ],
        "rule_sql": [
            "SELECT T3.stu_fname FROM CLASS AS T1 INNER JOIN ENROLL AS T2 ON T1.class_code = T2.class_code INNER JOIN STUDENT AS T3 ON T2.stu_num = T3.stu_num WHERE T1.crs_code = 'ACCT-211' AND T2.enroll_grade = 'C'"
        ]
    },
    "1536": {
        "db_id": "insurance_and_eClaims",
        "question": "What are the names of the customers and staff members?",
        "ground_truth": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff",
        "amends": [
            "Do select `customer_details` and `staff_details` in separate UNION branches instead of selecting `customer_name` and `staff_name` from a cross join. Do use `UNION` to combine results from separate tables instead of attempting to join `customers` and `staff` tables with an incorrect join condition `customers.id = staff.id`. Do remove the incorrect WHERE clause join predicate entirely instead of keeping the flawed cross join logic. The amended query now correctly retrieves customer and staff details as separate result sets combined through UNION, matching the RIGHT_SQL's intended behavior."
        ],
        "rules": [
            "1) When answering about \"names of customers and staff members\": make sure the output order: customer_details, staff_details in separate UNION branches 2) When combining results from multiple tables for separate entities: use UNION to combine results from separate tables instead of joining them with incorrect join conditions 3) When the question asks for both customer and staff information: retrieve customer details from the customers table and staff details from the staff table as separate result sets 4) When dealing with unrelated entities like customers and staff: do not attempt to join them with conditions like customers.id = staff.id as they represent different entity types"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT customer_name, staff_name FROM customers, staff WHERE customers.id = staff.id;",
            "SELECT Customer_Details AS Name FROM Customers\nUNION\nSELECT Staff_Details AS Name FROM Staff;"
        ],
        "rule_sql": [
            "SELECT Customer_Details AS Details FROM Customers\nUNION ALL\nSELECT Staff_Details AS Details FROM Staff;"
        ]
    },
    "724": {
        "db_id": "customers_card_transactions",
        "question": "What are the codes of card types that have 5 or more cards?",
        "ground_truth": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code HAVING count(*)  >=  5",
        "amends": [
            "Do reference the `Customers_cards` table instead of the `cards` table in the FROM clause. The amended query now correctly identifies card types from the appropriate customer cards table while maintaining the same grouping and filtering logic to find card types with at least 5 occurrences."
        ],
        "rules": [
            "1) When answering about \"codes of card types that have 5 or more cards\": make sure the output order: card_type_code\n2) When counting cards per card type: compute the number of rows using the canonical key from the Customers_cards table\n3) When filtering for card types with 5 or more cards: keep only groups where the count is greater than or equal to 5\n4) When grouping by card type: organize results by card_type_code from the Customers_cards table\n5) When choosing the source table: use the Customers_cards table instead of the cards table as specified in the amends"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT card_type_code FROM cards GROUP BY card_type_code HAVING COUNT(*) >= 5;",
            "SELECT card_type_code FROM Customers_Cards GROUP BY card_type_code HAVING COUNT(card_id) >= 5"
        ],
        "rule_sql": [
            "SELECT card_type_code\nFROM Customers_Cards\nGROUP BY card_type_code\nHAVING COUNT(card_id) >= 5\nORDER BY card_type_code;"
        ]
    },
    "2226": {
        "db_id": "formula_1",
        "question": "What is the average fastest lap speed for races held after 2004, for each race, ordered by year?",
        "ground_truth": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year",
        "amends": [
            "Do join `results AS T2` on `T1.raceid = T2.raceid` instead of querying only the `races` table. Do reference `T2.fastestlapspeed` instead of `fastest_lap_speed` from the wrong table. Do use table aliases `T1` and `T2` instead of unaliased table references. Do filter on `T1.year > 2014` instead of `year > 2004` with the wrong threshold. Do group by `T1.name` instead of `race_name` using the correct column reference. Do order by `T1.year` instead of just `year` with proper table qualification. Do calculate the average on the joined table's column instead of the base table's column. The amended query now correctly joins the necessary tables and uses proper table qualifications to match the intended behavior.",
            "Do include `T1.year` in the GROUP BY clause instead of omitting it, as it appears in the SELECT list without aggregation. Do reorder the SELECT list to place the aggregate function `avg(T2.fastestlapspeed)` first instead of having `T1.year` first. Do use lowercase column names `fastestlapspeed` and `raceid` instead of mixed case `fastestLapSpeed` and `raceId` to match the database's case sensitivity. The amended query now correctly handles the non-aggregated column in GROUP BY and matches the RIGHT_SQL's behavior.",
            "Do place the aggregate function `avg(T2.fastestlapspeed)` first in the SELECT list instead of third position. Do remove the alias `average_fastest_lap_speed` instead of keeping it. Do change the GROUP BY clause to include only `T1.name` instead of both `T1.year` and `T1.name`. Do maintain the same FROM clause with `JOIN results AS T2 ON T1.raceid = T2.raceid` instead of the original join condition. Do preserve the WHERE filter `T1.year > 2014` and ORDER BY `T1.year` unchanged. The amended query now correctly groups by name only while calculating average fastest lap speed per race name across years, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about races held after 2014: filter using T1.year > 2014 instead of 2004. 2) When calculating average fastest lap speed: use T2.fastestlapspeed from the results table instead of fastest_lap_speed from races table. 3) When combining race and result data: join races AS T1 and results AS T2 on T1.raceid = T2.raceid to link race information with lap speed data. 4) When grouping by race name: use T1.name instead of race_name as the grouping column. 5) When ordering results by year: use T1.year with proper table qualification instead of unqualified year. 6) When using table references: always use table aliases T1 for races and T2 for results instead of unaliased table names.",
            "1) When the question asks for average fastest lap speed for races held after 2004: use the exact literal value 2004 as the cutoff year, not 2014. 2) When including non-aggregated columns in SELECT: include all non-aggregated columns like T1.year and T1.name in the GROUP BY clause. 3) When ordering output by year: place T1.year in the ORDER BY clause to sort results chronologically. 4) When using column names from the database schema: use lowercase identifiers fastestlapspeed and raceid instead of mixed case fastestLapSpeed and raceId to match the database's case sensitivity. 5) When computing average fastest lap speed: use the aggregate function AVG on T2.fastestlapspeed to calculate the average value per race group.",
            "1) When answering about \"average fastest lap speed for races held after 2004, for each race, ordered by year\": make sure the output order: avg(T2.fastestlapspeed), T1.year, T1.name\n2) When the question asks for average fastest lap speed per race: group by T1.name only instead of both T1.year and T1.name\n3) When the question mentions \"races held after 2004\": filter using T1.year > 2014\n4) When the question asks for ordering by year: order the results by T1.year\n5) When combining races and results tables: link rows where T1.raceid = T2.raceid and keep only matching pairs (inner match)"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT race_name, year, AVG(fastest_lap_speed) as avg_speed \nFROM races \nWHERE year > 2004 \nGROUP BY race_name \nORDER BY year;",
            "SELECT T1.year, T1.name, AVG(T2.fastestLapSpeed) as avg_fastest_lap_speed\nFROM races AS T1\nJOIN results AS T2 ON T1.raceId = T2.raceId\nWHERE T1.year > 2014\nGROUP BY T1.name\nORDER BY T1.year;",
            "SELECT T1.year, T1.name, AVG(T2.fastestlapspeed) AS average_fastest_lap_speed\nFROM races AS T1\nJOIN results AS T2 ON T1.raceId = T2.raceId\nWHERE T1.year > 2014\nGROUP BY T1.year, T1.name\nORDER BY T1.year",
            "SELECT avg(T2.fastestlapspeed), T1.name, T1.year\nFROM races AS T1\nJOIN results AS T2 ON T1.raceid = T2.raceid\nWHERE T1.year > 2014\nGROUP BY T1.name\nORDER BY T1.year"
        ],
        "rule_sql": [
            "SELECT T1.year, T1.name, AVG(T2.fastestlapspeed) AS average_fastest_lap_speed\nFROM races AS T1\nJOIN results AS T2 ON T1.raceid = T2.raceid\nWHERE T1.year > 2014\nGROUP BY T1.name\nORDER BY T1.year"
        ]
    },
    "3633": {
        "db_id": "baseball_1",
        "question": "What are first and last names of players participating in all star game in 1998?",
        "ground_truth": "SELECT name_first ,  name_last FROM player AS T1 JOIN all_star AS T2 ON T1.player_id  =  T2.player_id WHERE YEAR  =  1998",
        "amends": [
            "Do select `name_first` and `name_last` instead of `first_name` and `last_name`. Do join `all_star` table on `player_id` instead of filtering with `all_star = 'yes'` in WHERE clause. Do reference table `player` with alias `T1` instead of `players`. Do use proper column names `name_first` and `name_last` from the joined tables instead of the original column names. The amended query now correctly retrieves all-star players from 1998 by properly joining the relevant tables."
        ],
        "rules": [
            "1) When answering about \"first and last names of players participating in all star game in 1998\": make sure the output order: name_first, name_last. 2) When the question mentions \"first and last names\": \"first name\" actually means \"name_first in schema\" and \"last name\" actually means \"name_last in schema\". 3) When the question asks about \"players participating in all star game\": join table \"all_star\" with table \"player\" (as T1) using the key player_id to find matching players. 4) When filtering for year 1998: apply the condition year = 1998 to the all_star table. 5) When combining T1 (player) and all_star table: link rows where T1.player_id = all_star.player_id and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM players WHERE year = 1998 AND all_star = 'yes';",
            "SELECT p.name_first, p.name_last\nFROM all_star a\nJOIN player p ON a.player_id = p.player_id\nWHERE a.year = 1998;"
        ],
        "rule_sql": [
            "SELECT p.name_first, p.name_last\nFROM player p\nINNER JOIN all_star a ON p.player_id = a.player_id\nWHERE a.year = 1998\nORDER BY p.name_first, p.name_last;"
        ]
    },
    "5022": {
        "db_id": "soccer_2",
        "question": "What is the state and enrollment of the colleges where have any students who got accepted in the tryout decision.",
        "ground_truth": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do select `state` and `enr` columns instead of `state` and `enrollment`. Do reference table `college` as `T1` instead of `colleges`. Do use `JOIN` with `tryout` as `T2` instead of a subquery with `students` table. Do join on `T1.cName = T2.cName` instead of filtering by `college_id` in a subquery. Do filter with `T2.decision = 'yes'` instead of `decision = 'tryout'` in the WHERE clause. Do remove the subquery entirely instead of using an IN clause. The amended query now correctly returns distinct states and enrollment values from colleges that have tryouts with 'yes' decisions."
        ],
        "rules": [
            "1) When answering about colleges with students accepted in tryout decisions: select distinct \"state\" and \"enr\" columns from table \"College\" as T1. 2) When combining College and tryout tables: link rows where T1.\"cName\" = T2.\"cName\" using an inner join. 3) When filtering for accepted tryout decisions: use T2.\"decision\" = 'yes' instead of 'tryout'. 4) When producing output: eliminate duplicate rows using DISTINCT on the selected columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT state, enrollment FROM colleges WHERE college_id IN (SELECT college_id FROM students WHERE decision = 'tryout');",
            "SELECT DISTINCT T1.state, T1.enr FROM College T1 JOIN Tryout T2 ON T1.cName = T2.cName WHERE T2.decision = 'yes';"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.state, T1.enr FROM College AS T1 INNER JOIN Tryout AS T2 ON T1.cName = T2.cName WHERE T2.decision = 'yes';"
        ]
    },
    "3036": {
        "db_id": "loan_1",
        "question": "Find the name of customers who have both saving and checking account types.",
        "ground_truth": "SELECT cust_name FROM customer WHERE acc_type  =  'saving' INTERSECT SELECT cust_name FROM customer WHERE acc_type  =  'checking'",
        "amends": [
            "Do select `cust_name` instead of `c.name` and use a single table `customer` instead of joining `customers` and `accounts`. Do filter with `acc_type = 'saving'` and `acc_type = 'checking'` in separate queries instead of using `OR` in a `WHERE` clause. Do use `INTERSECT` to find customers with both account types instead of grouping and counting distinct account types with `HAVING COUNT(DISTINCT a.account_type) >= 1`. Do remove the `GROUP BY` clause and `JOIN` operation entirely instead of keeping them. The amended query now correctly identifies customers who have both saving and checking accounts by using set intersection instead of the flawed counting approach."
        ],
        "rules": [
            "1) When the question asks for customer names: use the exact column token \"cust_name\" from the customer table instead of c.name. 2) When finding customers with both saving and checking account types: use separate queries with exact literal filters \"acc_type = 'saving'\" and \"acc_type = 'checking'\" instead of OR conditions. 3) When combining results from multiple account type conditions: use INTERSECT operation to find customers who appear in both result sets instead of grouping and counting distinct account types. 4) When working with this schema: use only the single customer table instead of joining with accounts table, as the account information is contained within the customer table structure."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name \nFROM customers c\nJOIN accounts a ON c.customer_id = a.customer_id\nWHERE a.account_type = 'saving' OR a.account_type = 'checking'\nGROUP BY c.customer_id, c.name\nHAVING COUNT(DISTINCT a.account_type) >= 1",
            "SELECT cust_name FROM customer WHERE acc_type = 'saving'\nINTERSECT\nSELECT cust_name FROM customer WHERE acc_type = 'checking'"
        ],
        "rule_sql": [
            "SELECT cust_name FROM customer WHERE acc_type = 'saving' INTERSECT SELECT cust_name FROM customer WHERE acc_type = 'checking'"
        ]
    },
    "3644": {
        "db_id": "baseball_1",
        "question": "Which manager won the most manager award? Give me the manager's first name, last name and id.",
        "ground_truth": "SELECT T1.name_first ,  T1.name_last ,  T2.player_id FROM player AS T1 JOIN manager_award AS T2 ON T1.player_id  =  T2.player_id GROUP BY T2.player_id ORDER BY count(*) DESC LIMIT 1;",
        "amends": [
            "Do select `name_first`, `name_last`, and `player_id` instead of `first_name`, `last_name`, and `manager_id`. Do join `player` table as `T1` with `manager_award` table as `T2` on `T1.player_id = T2.player_id` instead of querying only the `managers` table. Do remove the `WHERE award_type = 'Manager of the Year'` filter instead of keeping it. Do group by `T2.player_id` instead of `manager_id`. Do order by `count(*)` instead of `award_count` while maintaining the descending order and single result limit. The amended query now correctly retrieves player information from the appropriate tables with proper joins and grouping."
        ],
        "rules": [
            "1) When answering about manager awards: use the exact column names \"name_first\", \"name_last\", and \"player_id\" instead of \"first_name\", \"last_name\", and \"manager_id\". 2) When combining player and manager award information: link rows where T1.player_id = T2.player_id and keep only matching pairs (inner match). 3) When counting manager awards: count all rows per player without filtering by award type. 4) When grouping manager award counts: group by T2.player_id to count awards per manager. 5) When finding the manager with the most awards: rank rows by award count in descending order and keep only the top result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name, manager_id, COUNT(*) as award_count \nFROM managers \nWHERE award_type = 'Manager of the Year' \nGROUP BY manager_id \nORDER BY award_count DESC \nLIMIT 1;",
            "SELECT p.name_first, p.name_last, p.player_id\nFROM player p\nJOIN manager_award ma ON p.player_id = ma.player_id\nGROUP BY p.player_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT p.name_first, p.name_last, p.player_id\nFROM player p\nJOIN manager_award ma ON p.player_id = ma.player_id\nGROUP BY p.player_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "4053": {
        "db_id": "student_1",
        "question": "Which teachers teach in classroom 109? Give me their last names.",
        "ground_truth": "SELECT lastname FROM teachers WHERE classroom  =  109",
        "amends": [
            "Do select `lastname` instead of `first_name` in the SELECT list. Do use consistent column naming by selecting `lastname` instead of the incorrect `first_name` column. The amended query now correctly retrieves the last names of teachers from classroom 109, matching the intended behavior of the right SQL."
        ],
        "rules": [
            "1) When the question asks for \"last names\" of teachers: select the exact column \"lastname\" instead of \"first_name\". 2) When filtering for teachers in classroom 109: use the exact literal value 109 without quotes for numeric comparison with the \"classroom\" column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM teachers WHERE classroom = 109;",
            "SELECT LastName FROM teachers WHERE Classroom = 109"
        ],
        "rule_sql": [
            "SELECT LastName FROM teachers WHERE Classroom = 109"
        ]
    },
    "6286": {
        "db_id": "city_record",
        "question": "Which city has the highest temperature in February?",
        "ground_truth": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1",
        "amends": [
            "Do join `city AS T1` with `temperature AS T2` on `T1.city_id = T2.city_id` instead of querying a single `temperatures` table. Do select `T1.city` instead of just `city`. Do order by `T2.Feb DESC` instead of `temperature ASC`. Do remove the `WHERE month = 'February'` filter instead of keeping it, as the February data is now directly accessed through the `T2.Feb` column. The amended query now correctly joins the city and temperature tables and retrieves the city with the highest February temperature instead of the lowest."
        ],
        "rules": [
            "1) When answering about \"highest temperature in February\": make sure the output order: T2.Feb DESC. 2) When combining T1 and T2 for shared entities: link rows where T1.city_id = T2.city_id; keep only matching pairs (inner match). 3) When the question asks for \"city\": select T1.city instead of just city. 4) When the question mentions \"February\": February data is accessed through T2.Feb column instead of filtering by month = 'February'. 5) When the question asks for \"highest\": rank rows by T2.Feb in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city FROM temperatures WHERE month = 'February' ORDER BY temperature ASC LIMIT 1;",
            "SELECT T1.City FROM city AS T1 JOIN temperature AS T2 ON T1.City_ID = T2.City_ID ORDER BY T2.Feb DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.City FROM city T1 INNER JOIN temperature T2 ON T1.City_ID = T2.City_ID ORDER BY T2.Feb DESC LIMIT 1"
        ]
    },
    "3585": {
        "db_id": "music_1",
        "question": "What is the language used most often in the songs?",
        "ground_truth": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use column name `languages` instead of `language` in the SELECT list and GROUP BY clause. Do reference table `song` instead of `songs` in the FROM clause. Do order by the aggregate expression `count(*)` directly instead of using the alias `count` in the ORDER BY clause. The amended query now correctly references the appropriate table and column names while maintaining the same logical behavior of finding the most frequent language.",
            "Do select only `languages` instead of including `COUNT(*)` in the SELECT list. Do keep the `GROUP BY languages` clause instead of changing it. Do maintain the `ORDER BY count(*) DESC` instead of altering it. Do preserve the `LIMIT 1` instead of modifying it. The amended query now correctly returns only the language with the highest count instead of returning both the language and its count."
        ],
        "rules": [
            "1) When the question asks about \"language used most often in the songs\": use the exact column name \"languages\" from table \"song\" instead of \"language\". 2) When counting occurrences of languages: count all rows using count(*) and group by the exact column \"languages\". 3) When finding the most frequent language: order the results by the count(*) expression in descending order and take only the top result.",
            "1) When answering about \"language used most often in the songs\": make sure the output order: only the \"languages\" column. 2) When the question asks for \"most often\": rank rows by count of songs in descending order and keep the first 1 row. 3) When grouping by language: organize results by the \"languages\" column and compute the count of songs per language. 4) When counting songs: compute the number of rows using the canonical key for songs (though not explicitly shown, the count is implied by the grouping)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT language, COUNT(*) as count FROM songs GROUP BY language ORDER BY count DESC LIMIT 1;",
            "SELECT languages, COUNT(*) FROM song GROUP BY languages ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT languages FROM song GROUP BY languages ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT languages FROM song GROUP BY languages ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "5319": {
        "db_id": "manufactory_1",
        "question": "What are the names of companies that do not make DVD drives?",
        "ground_truth": "SELECT name FROM manufacturers EXCEPT SELECT T2.name FROM products AS T1 JOIN manufacturers AS T2 ON T1.Manufacturer  =  T2.code WHERE T1.name  =  'DVD drive'",
        "amends": [
            "Do select `name` from the `manufacturers` table instead of `company_name` from `companies`. Do use an `EXCEPT` set operation instead of a simple `WHERE` filter. Do add a subquery that joins `products` with `manufacturers` on `Manufacturer = code` instead of omitting this relationship. Do filter for products with `name = 'DVD drive'` in the joined subquery instead of filtering for `product_type = 'DVD drive'` directly. Do remove the incorrect table reference `companies` and replace it with the correct `manufacturers` table structure. The amended query now correctly identifies manufacturers who do not produce DVD drives by using set difference logic instead of the original incorrect filtering approach."
        ],
        "rules": [
            "1) When selecting company names: use \"name\" from the \"manufacturers\" table instead of \"company_name\" from \"companies\". 2) When finding companies that do not make a specific product: use a set difference operation (EXCEPT) instead of a simple WHERE filter. 3) When relating products to manufacturers: join the \"products\" table with \"manufacturers\" on \"Manufacturer = code\" to establish the correct relationship. 4) When filtering for DVD drives: use the exact literal 'DVD drive' with the \"name\" column in the products table. 5) When referencing tables: use the correct \"manufacturers\" table structure instead of the incorrect \"companies\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT company_name FROM companies WHERE product_type = 'DVD drive';",
            "SELECT Name FROM Manufacturers\nEXCEPT\nSELECT m.Name \nFROM Manufacturers m\nJOIN Products p ON m.Code = p.Manufacturer\nWHERE p.Name = 'DVD drive'"
        ],
        "rule_sql": [
            "SELECT name FROM Manufacturers\nEXCEPT\nSELECT m.name FROM Manufacturers m\nJOIN Products p ON m.Code = p.Manufacturer\nWHERE p.name = 'DVD drive'"
        ]
    },
    "1071": {
        "db_id": "match_season",
        "question": "What are the names of all teams?",
        "ground_truth": "SELECT Name FROM Team",
        "amends": [
            "Do select `Name` instead of `team_id` and do reference table `Team` instead of `teams` to match the correct schema and column naming conventions."
        ],
        "rules": [
            "1) When the question asks for team names: select \"Name\" from the \"team\" table instead of team_id from teams. 2) When referencing the team table: use the exact table name \"team\" as shown in the schema, not \"teams\". 3) When selecting team names: output the \"Name\" column which contains text values like 'Columbus Crew' and 'Miami Fusion'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT team_id FROM teams;",
            "SELECT Name FROM team;"
        ],
        "rule_sql": [
            "SELECT Name FROM team;"
        ]
    },
    "6091": {
        "db_id": "customers_and_addresses",
        "question": "Find the state and country of all cities with post code starting with 4.",
        "ground_truth": "SELECT state_province_county ,  country FROM addresses WHERE zip_postcode LIKE \"4%\"",
        "amends": [
            "Do select `state_province_county` instead of `state` and use table `addresses` instead of `cities`. Do filter on `zip_postcode` with pattern matching instead of `post_code`. The amended query now correctly retrieves address data with the appropriate column names and table source."
        ],
        "rules": [
            "1) When the question asks for \"state and country\": use the exact column name \"state_province_county\" from the Addresses table instead of \"state\". 2) When filtering by post code starting with 4: use the exact column name \"zip_postcode\" from the Addresses table instead of \"post_code\" and filter using pattern matching for values starting with '4'. 3) When retrieving address data: use the Addresses table as the source instead of a cities table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT state, country FROM cities WHERE post_code LIKE '4%';",
            "SELECT state_province_county, country FROM Addresses WHERE zip_postcode LIKE '4%';"
        ],
        "rule_sql": [
            "SELECT state_province_county, country FROM Addresses WHERE zip_postcode LIKE '4%';"
        ]
    },
    "1971": {
        "db_id": "products_for_hire",
        "question": "What are the maximum, minimum, and average booked count for the products booked?",
        "ground_truth": "SELECT max(booked_count) ,  min(booked_count) ,  avg(booked_count) FROM products_booked",
        "amends": [
            "Do reference the `products_booked` table instead of the `products` table. Do remove the `WHERE booked_count IS NOT NULL` filter instead of keeping it, as aggregate functions inherently ignore NULL values. Do remove the column aliases `max_booked`, `min_booked`, and `avg_booked` instead of including them. The amended query now correctly calculates aggregates from the appropriate table without unnecessary filtering and aliasing, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about maximum, minimum, and average booked count for products: use the \"products_booked\" table instead of the \"products\" table. 2) When calculating aggregate functions like MAX, MIN, and AVG: do not include WHERE filters for NULL values as aggregate functions inherently ignore NULL values. 3) When producing output columns for aggregate calculations: do not include column aliases like \"max_booked\", \"min_booked\", and \"avg_booked\" in the final output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(booked_count) as max_booked, MIN(booked_count) as min_booked, AVG(booked_count) as avg_booked FROM products WHERE booked_count IS NOT NULL",
            "SELECT MAX(booked_count), MIN(booked_count), AVG(booked_count) FROM Products_Booked;"
        ],
        "rule_sql": [
            "SELECT MAX(booked_count), MIN(booked_count), AVG(booked_count) FROM Products_Booked;"
        ]
    },
    "5469": {
        "db_id": "voter_2",
        "question": "What are the distinct registration dates and the election cycles?",
        "ground_truth": "SELECT DISTINCT Registration_Date ,  Election_Cycle FROM VOTING_RECORD",
        "amends": [
            "Do reference the `VOTING_RECORD` table instead of the `voters` table. Do use proper column case `Registration_Date` and `Election_Cycle` instead of lowercase `registration_date` and `election_cycle`. The amended query now correctly selects distinct registration dates and election cycles from the VOTING_RECORD table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about distinct registration dates and election cycles: use the exact table name \"VOTING_RECORD\" instead of \"voters\". 2) When selecting registration date: use the exact column name \"Registration_Date\" with proper case instead of lowercase \"registration_date\". 3) When selecting election cycle: use the exact column name \"Election_Cycle\" with proper case instead of lowercase \"election_cycle\". 4) When retrieving distinct combinations: ensure both \"Registration_Date\" and \"Election_Cycle\" are selected together to get unique date-cycle pairs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT registration_date, election_cycle FROM voters ORDER BY registration_date;",
            "SELECT DISTINCT Registration_Date, Election_Cycle FROM Voting_record;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Registration_Date, Election_Cycle FROM VOTING_RECORD;"
        ]
    },
    "363": {
        "db_id": "flight_1",
        "question": "Show name and salary for all employees sorted by salary.",
        "ground_truth": "SELECT name ,  salary FROM Employee ORDER BY salary",
        "amends": [
            "Do reference the table as `Employee` instead of `employees` in the FROM clause. Do order by `salary` instead of `name` in the ORDER BY clause. The amended query now correctly references the intended table and sorts results by salary instead of name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for employee information: use the exact table name \"Employee\" instead of \"employees\". 2) When the question specifies sorting by salary: order results by the \"salary\" column instead of \"name\". 3) When selecting output columns: include both \"name\" and \"salary\" columns from the Employee table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, salary FROM employees ORDER BY name;",
            "SELECT name, salary FROM Employee ORDER BY salary;"
        ],
        "rule_sql": [
            "SELECT name, salary FROM Employee ORDER BY salary;"
        ]
    },
    "3425": {
        "db_id": "hr_1",
        "question": "What are the full name (first and last name) and salary for all employees who does not have any value for commission?",
        "ground_truth": "SELECT first_name ,  last_name ,  salary FROM  employees WHERE commission_pct  =  \"null\"",
        "amends": [
            "Do use `commission_pct = \"null\"` instead of `commission IS NULL` in the WHERE filter, changing from checking for NULL values to checking for the string literal \"null\". Do maintain the same SELECT list with `first_name`, `last_name`, and `salary` columns from the `employees` table. The amended query now correctly matches the RIGHT_SQL's behavior by filtering for string equality rather than NULL checking."
        ],
        "rules": [
            "1) When filtering for employees who do not have any value for commission: use commission_pct = \"null\" instead of checking for NULL values. 2) When selecting employee information: include first_name, last_name, and salary columns from the employees table. 3) When handling text literals: use the exact string literal \"null\" with double quotes and lowercase spelling as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name, salary FROM employees WHERE commission IS NULL;",
            "SELECT first_name, last_name, salary FROM employees WHERE commission_pct = \"null\""
        ],
        "rule_sql": [
            "SELECT first_name, last_name, salary FROM employees WHERE commission_pct = \"null\""
        ]
    },
    "5835": {
        "db_id": "workshop_paper",
        "question": "Which submission received the highest score in acceptance result. Show me the result.",
        "ground_truth": "SELECT T1.Result FROM acceptance AS T1 JOIN submission AS T2 ON T1.Submission_ID  =  T2.Submission_ID ORDER BY T2.Scores DESC LIMIT 1",
        "amends": [
            "Do select `T1.Result` instead of `*` to retrieve only the acceptance result instead of all columns. Do join `acceptance AS T1` with `submission AS T2` on `T1.Submission_ID = T2.Submission_ID` instead of querying only the `submissions` table to properly relate acceptance records with their corresponding submissions. Do order by `T2.Scores DESC` instead of `score DESC` to sort by the submission scores from the joined table rather than a potentially incorrect column name. The amended query now correctly retrieves the acceptance result for the highest-scoring submission by properly joining the acceptance and submission tables."
        ],
        "rules": [
            "1) When answering about \"which submission received the highest score in acceptance result\": make sure the output order: T1.Result. 2) When combining acceptance table as T1 and submission table as T2: link rows where T1.Submission_ID = T2.Submission_ID and keep only matching pairs (inner match). 3) When the question mentions \"highest score\": rank rows by T2.Scores in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM submissions ORDER BY score DESC LIMIT 1;",
            "SELECT T1.Result \nFROM acceptance AS T1 \nJOIN submission AS T2 ON T1.Submission_ID = T2.Submission_ID \nORDER BY T2.Scores DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Result\nFROM Acceptance AS T1\nINNER JOIN submission AS T2 ON T1.Submission_ID = T2.Submission_ID\nORDER BY T2.Scores DESC\nLIMIT 1"
        ]
    },
    "5767": {
        "db_id": "dorm_1",
        "question": "What are the amenities in the dorm that a student who has the last name of Smith lives in?",
        "ground_truth": "SELECT T3.amenity_name FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid JOIN dorm_amenity AS T3 ON T2.amenid  =  T3.amenid JOIN lives_in AS T4 ON T4.dormid  =  T1.dormid JOIN student AS T5 ON T5.stuid  =  T4.stuid WHERE T5.lname  =  'Smith'",
        "amends": [
            "Do select `T3.amenity_name` from the `dorm_amenity` table instead of `amenities` from the `dorms` table. Do join five tables (`dorm`, `has_amenity`, `dorm_amenity`, `lives_in`, and `student`) with proper foreign key relationships instead of querying only the `dorms` table. Do use `T5.lname = 'Smith'` as the filter condition instead of `student_last_name = 'Smith'`, properly referencing the student table's last name column. The amended query now correctly retrieves amenity names by establishing the proper relationships between dorms, their amenities, and the students living in them, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for amenities in a dorm: select \"T3.amenity_name\" from the \"dorm_amenity\" table instead of \"amenities\" from the \"dorms\" table. 2) When finding amenities for a student with last name Smith: use \"T5.lname = 'Smith'\" as the filter condition, properly referencing the student table's last name column. 3) When connecting dorm amenities to students: join five tables (\"dorm\", \"has_amenity\", \"dorm_amenity\", \"lives_in\", and \"student\") with proper foreign key relationships instead of querying only the \"dorms\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT amenities FROM dorms WHERE student_last_name = 'Smith';",
            "SELECT T3.amenity_name\nFROM Dorm T1\nJOIN Has_amenity T2 ON T1.dormid = T2.dormid\nJOIN Dorm_amenity T3 ON T2.amenid = T3.amenid\nJOIN Lives_in T4 ON T1.dormid = T4.dormid\nJOIN Student T5 ON T4.stuid = T5.StuID\nWHERE T5.LName = 'Smith';"
        ],
        "rule_sql": [
            "SELECT T3.amenity_name\nFROM Student T5\nJOIN Lives_in T4 ON T5.StuID = T4.stuid\nJOIN Dorm T1 ON T4.dormid = T1.dormid\nJOIN Has_amenity T2 ON T1.dormid = T2.dormid\nJOIN Dorm_amenity T3 ON T2.amenid = T3.amenid\nWHERE T5.LName = 'Smith';"
        ]
    },
    "740": {
        "db_id": "customers_card_transactions",
        "question": "What are the different card types, and how many transactions have been made with each?",
        "ground_truth": "SELECT T2.card_type_code ,  count(*) FROM Financial_transactions AS T1 JOIN Customers_cards AS T2 ON T1.card_id  =  T2.card_id GROUP BY T2.card_type_code",
        "amends": [
            "Do select `T2.card_type_code` instead of `card_type` and add the `Customers_cards` table alias. Do join `Financial_transactions AS T1` with `Customers_cards AS T2` on `T1.card_id = T2.card_id` instead of querying only the `transactions` table. Do group by `T2.card_type_code` instead of `transaction_id` to correctly count transactions by card type rather than by individual transaction identifiers. The amended query now properly correlates transaction data with customer card information to produce accurate card type counts."
        ],
        "rules": [
            "1) When answering about \"different card types and transaction counts per card type\": make sure the output order: T2.card_type_code first, then the count of transactions. 2) When the question mentions \"card types\": \"card types\" actually means \"T2.card_type_code in schema\". 3) When combining Financial_transactions AS T1 and Customers_cards AS T2: link rows where T1.card_id = T2.card_id exactly as shown; keep only matching pairs (inner match). 4) When the question asks for \"how many transactions have been made with each\": compute the number of rows using the canonical key T1.transaction_id for counting transactions. 5) When the question says \"per card type\": organize results by T2.card_type_code and compute transaction counts per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT card_type, COUNT(*) FROM transactions GROUP BY transaction_id;",
            "SELECT T2.card_type_code, COUNT(*) AS transaction_count\nFROM Financial_Transactions AS T1\nJOIN Customers_Cards AS T2 ON T1.card_id = T2.card_id\nGROUP BY T2.card_type_code"
        ],
        "rule_sql": [
            "SELECT T2.card_type_code, COUNT(T1.transaction_id) AS transaction_count\nFROM Financial_Transactions AS T1\nINNER JOIN Customers_Cards AS T2 ON T1.card_id = T2.card_id\nGROUP BY T2.card_type_code\nORDER BY T2.card_type_code, transaction_count;"
        ]
    },
    "4647": {
        "db_id": "college_3",
        "question": "Find the number of students that have at least one grade \"B\".",
        "ground_truth": "SELECT COUNT(DISTINCT StuID) FROM ENROLLED_IN WHERE Grade  =  \"B\"",
        "amends": [
            "Do select `COUNT(DISTINCT StuID)` instead of `COUNT(*)` to count unique student IDs rather than all rows. Do query from table `ENROLLED_IN` instead of `students` to access enrollment records. Do filter on column `Grade` with value `\"B\"` instead of `grade = 'B'` to use the correct table's grading system. Do remove the single quotes around the grade value and use double quotes instead to match the column's data format."
        ],
        "rules": [
            "1) When counting students: count distinct \"StuID\" values instead of all rows to get unique student counts. 2) When accessing enrollment data: use table \"ENROLLED_IN\" instead of \"students\" to get enrollment records. 3) When filtering by grade: use column \"Grade\" with value \"B\" (with double quotes) instead of 'B' (with single quotes) to match the column's data format. 4) When the question asks for students with at least one grade \"B\": count distinct students who have a \"Grade\" value of \"B\" in the \"ENROLLED_IN\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE grade = 'B';",
            "SELECT COUNT(DISTINCT StuID) FROM Enrolled_in WHERE Grade = \"B\""
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT StuID) FROM Enrolled_in WHERE Grade = \"B\";"
        ]
    },
    "5348": {
        "db_id": "manufactory_1",
        "question": "Select the name of each manufacturer along with the name and price of its most expensive product.",
        "ground_truth": "SELECT T1.Name ,  max(T1.Price) ,  T2.name FROM products AS T1 JOIN Manufacturers AS T2 ON T1.manufacturer  =  T2.code GROUP BY T2.name",
        "amends": [
            "Do select `max(T1.Price)` and `T2.name` instead of `m.name`, `p.name`, and `p.price`. Do join `products AS T1` with `Manufacturers AS T2` on `T1.manufacturer = T2.code` instead of joining `manufacturers m` with `products p` on `m.id = p.manufacturer_id`. Do remove the subquery filter for minimum price instead of keeping it. Do add `GROUP BY T2.name` instead of omitting grouping. The amended query now correctly groups by manufacturer name and finds maximum prices rather than attempting to find minimum prices per manufacturer through a correlated subquery.",
            "Do include `T1.Name` in the SELECT list instead of omitting it, and do place `T2.name` at the end of the SELECT list instead of at the beginning. Do use lowercase `name` for the manufacturer column instead of uppercase `Name`, and do use lowercase `manufacturer` in the join condition instead of uppercase `Manufacturer`. The amended query now correctly includes all necessary columns in the SELECT list while maintaining proper grouping logic and matches the RIGHT_SQL's behavior.",
            "Do include `T1.Name` in the SELECT list instead of omitting it, and do not alias `max(T1.Price)` as `max_price` instead of keeping it unaliased. Do remove the alias `product_name` from `T1.Name` instead of keeping it, and do remove the alias `manufacturer_name` from `T2.name` instead of keeping it. The amended query now correctly returns the product names along with maximum prices grouped by manufacturer without unnecessary aliases, matching the RIGHT_SQL's behavior.",
            "Do list columns as `T1.Name`, `max(T1.Price)`, and `T2.name` instead of `T2.name`, `T1.Name`, and `max(T1.Price)` to maintain proper column order. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"most expensive product per manufacturer\": make sure the output order: manufacturer name, product name, and product price. 2) When combining products AS T1 and Manufacturers AS T2: link rows where T1.manufacturer = T2.code and keep only matching pairs (inner match). 3) When the question asks for \"most expensive product\": for each manufacturer, find the maximum value of T1.Price. 4) When grouping by manufacturer: organize results by T2.name and compute the maximum T1.Price per group. 5) When selecting output columns: include T2.name, T1.name, and max(T1.Price) to show manufacturer name, product name, and its highest price.",
            "1) When answering about \"manufacturer name along with product name and price\": make sure the output order: T1.Name, T1.Price, T2.name 2) When the question mentions \"manufacturer\": \"manufacturer\" actually means \"manufacturer in schema\" and should be referenced in lowercase 3) When the question asks for \"most expensive product per manufacturer\": rank products by T1.Price in descending order and keep the first row per manufacturer group 4) When combining Products as T1 and Manufacturers as T2: link rows where T1.manufacturer = T2.Code and keep only matching pairs (inner match) 5) When choosing identifier delimiters: do not replace lowercase identifiers with uppercase forms",
            "1) When answering about \"most expensive product per manufacturer\": make sure the output order: manufacturer name, product name, and maximum price. 2) When the question asks for \"name of each manufacturer along with the name and price of its most expensive product\": include T2.name, T1.Name, and MAX(T1.Price) in the SELECT list. 3) When grouping by manufacturer: organize results by T2.name and compute MAX(T1.Price) per group. 4) When selecting columns: do not apply aliases to T2.name, T1.Name, or MAX(T1.Price) as the question does not specify aliases. 5) When combining Products (T1) and Manufacturers (T2): link rows where T1.manufacturer = T2.code and keep only matching pairs (inner match).",
            "1) When answering about \"the name of each manufacturer along with the name and price of its most expensive product\": make sure the output order: T1.Name, max(T1.Price), T2.name\n2) When the question asks for \"most expensive product\": compute the maximum value of T1.Price for each manufacturer group\n3) When organizing results by manufacturer: group by T2.name to compute aggregates per manufacturer\n4) When combining Products (T1) and Manufacturers (T2) for shared entities: link rows where T1.manufacturer = T2.code and keep only matching pairs (inner match)"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT m.name, p.name, p.price\nFROM manufacturers m\nJOIN products p ON m.id = p.manufacturer_id\nWHERE p.price = (SELECT MIN(price) FROM products WHERE manufacturer_id = m.id)",
            "SELECT T2.Name, T1.Name, MAX(T1.Price) \nFROM Products AS T1 \nJOIN Manufacturers AS T2 ON T1.Manufacturer = T2.Code \nGROUP BY T2.Name",
            "SELECT MAX(T1.Price) AS max_price, T1.Name AS product_name, T2.name AS manufacturer_name\nFROM Products AS T1\nJOIN Manufacturers AS T2 ON T1.manufacturer = T2.code\nGROUP BY T2.name",
            "SELECT T2.name, T1.Name, max(T1.Price) FROM Products AS T1 JOIN Manufacturers AS T2 ON T1.manufacturer = T2.code GROUP BY T2.name",
            "SELECT T1.Name, max(T1.Price), T2.name FROM Products AS T1 JOIN Manufacturers AS T2 ON T1.manufacturer = T2.code GROUP BY T2.name"
        ],
        "rule_sql": [
            "SELECT T2.name, T1.Name, MAX(T1.Price) \nFROM Products AS T1 \nINNER JOIN Manufacturers AS T2 ON T1.manufacturer = T2.Code \nGROUP BY T2.name"
        ]
    },
    "456": {
        "db_id": "allergy_1",
        "question": "Which allergy type is most common?",
        "ground_truth": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference the table as `Allergy_type` instead of `allergies` and the column as `allergytype` instead of `allergy_type`. Do remove the explicit `COUNT(*) as count` column from the SELECT list instead of including it, and do order by `count(*) DESC` instead of `count ASC` to get the highest count rather than the lowest. The amended query now correctly returns the most common allergy type by counting occurrences in descending order."
        ],
        "rules": [
            "1) When the question asks about \"allergy type\": use the exact column token \"allergytype\" from table \"Allergy_type\". 2) When counting occurrences of allergy types: count using the canonical key \"allergytype\" and order by the count in descending order to find the most common. 3) When the question asks for the most common allergy type: return only the allergy type value without including the count column in the output. 4) When ordering results to find the most common: use descending order on the count and limit to the first result to get the highest count."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT allergy_type, COUNT(*) as count FROM allergies GROUP BY allergy_type ORDER BY count ASC LIMIT 1;",
            "SELECT AllergyType FROM Allergy_Type JOIN Has_Allergy ON Allergy_Type.Allergy = Has_Allergy.Allergy GROUP BY AllergyType ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT AllergyType FROM Allergy_Type \nJOIN Has_Allergy ON Allergy_Type.Allergy = Has_Allergy.Allergy \nGROUP BY AllergyType \nORDER BY COUNT(AllergyType) DESC \nLIMIT 1"
        ]
    },
    "1019": {
        "db_id": "university_basketball",
        "question": "List all information regarding the basketball match.",
        "ground_truth": "SELECT * FROM basketball_match",
        "amends": [
            "Do query from `basketball_match` table instead of `football_matches` table. Do filter for basketball matches by table selection instead of using a `WHERE sport = 'basketball'` condition. The amended query now correctly retrieves basketball match data from the appropriate table structure."
        ],
        "rules": [
            "1) When answering about basketball matches: use the \"basketball_match\" table instead of the \"football_matches\" table. 2) When filtering for basketball matches: select from the basketball-specific table directly rather than using a WHERE condition on a sport column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM football_matches WHERE sport = 'basketball';",
            "SELECT * FROM basketball_match;"
        ],
        "rule_sql": [
            "SELECT * FROM basketball_match;"
        ]
    },
    "3689": {
        "db_id": "baseball_1",
        "question": "How many games were played in park \"Columbia Park\" in 1907?",
        "ground_truth": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';",
        "amends": [
            "Do join `home_game` and `park` tables with `INNER JOIN` on `park_id` instead of querying only the `games` table. Do filter on `T1.year = 1907` and `T2.park_name = 'Columbia Park'` instead of filtering directly on `park_name` and `year` in a single table. Do reference the correct table aliases `T1` and `T2` for column qualifications instead of accessing columns without proper table context. The amended query now correctly joins the necessary tables and matches the RIGHT_SQL's behavior by properly relating games to their corresponding park information through the appropriate foreign key relationship.",
            "Do use `count(*)` instead of selecting `T1.games` to return the count of matching records rather than individual game values. Do add the `AS` keyword for table aliases instead of omitting it for explicit alias declaration. Do use simple `JOIN` instead of `INNER JOIN` as they are functionally equivalent. Do maintain the same join condition `T1.park_id = T2.park_id` with consistent spacing. Do preserve the `WHERE` filters `T1.year = 1907` and `T2.park_name = 'Columbia Park'` unchanged as they correctly filter for the specific year and park. The amended query now correctly counts home games from 1907 at Columbia Park instead of returning individual game records, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about games played in a specific park: combine the home_game table (T1) and park table (T2) using an inner match where T1.park_id equals T2.park_id. 2) When the question mentions \"Columbia Park\": filter for rows where T2.park_name exactly equals 'Columbia Park' (case-sensitive). 3) When the question mentions year 1907: filter for rows where T1.year equals 1907. 4) When counting games: count the number of rows from the combined result after applying all filters.",
            "1) When counting games played: use count(*) instead of selecting individual game values to get the count of matching records. 2) When joining tables home_game and park: link rows where T1.park_id = T2.park_id to find games played at specific parks. 3) When filtering for year 1907: use T1.year = 1907 to select games from that specific year. 4) When filtering for park \"Columbia Park\": use T2.park_name = 'Columbia Park' exactly as written to match the specific park name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE park_name = 'Columbia Park' AND year = 1907;",
            "SELECT T1.games\nFROM home_game T1\nINNER JOIN park T2 ON T1.park_id = T2.park_id\nWHERE T1.year = 1907 AND T2.park_name = 'Columbia Park'",
            "SELECT COUNT(*) \nFROM home_game AS T1 \nJOIN park AS T2 ON T1.park_id = T2.park_id \nWHERE T1.year = 1907 AND T2.park_name = 'Columbia Park'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM home_game hg\nINNER JOIN park p ON hg.park_id = p.park_id\nWHERE p.park_name = 'Columbia Park' \nAND hg.year = 1907;"
        ]
    },
    "1050": {
        "db_id": "phone_1",
        "question": "Find the names of the chip models that are not used by any phone with full accreditation type.",
        "ground_truth": "SELECT model_name FROM chip_model EXCEPT SELECT chip_model FROM phone WHERE Accreditation_type  =  'Full'",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do select from `chip_model` table instead of `chips` table. Do reference `chip_model` column instead of `model_name` in the second part. Do query from `phone` table instead of `phones` table. Do use proper case `Accreditation_type = 'Full'` instead of `accreditation_type = 'full'`. The amended query now correctly uses set operations to find chip models not associated with phones having full accreditation."
        ],
        "rules": [
            "1) When selecting from the chip model table: use the exact table name \"chip_model\" instead of \"chips\". 2) When referencing the model name column: use the exact column name \"Model_name\" instead of \"model_name\". 3) When querying the phone table: use the exact table name \"phone\" instead of \"phones\". 4) When filtering for full accreditation type: use the exact literal value 'Full' with proper case instead of 'full'. 5) When finding chip models not used by phones with full accreditation: use the EXCEPT set operation instead of NOT IN with a subquery. 6) When combining chip_model and phone tables: use the foreign key relationship where phone.chip_model references chip_model.Model_name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT model_name FROM chips WHERE chip_id NOT IN (SELECT chip_id FROM phones WHERE accreditation_type = 'full');",
            "SELECT Model_name FROM chip_model\nEXCEPT\nSELECT chip_model FROM phone WHERE Accreditation_type = 'Full';"
        ],
        "rule_sql": [
            "SELECT Model_name FROM chip_model\nEXCEPT\nSELECT chip_model FROM phone WHERE Accreditation_type = 'Full';"
        ]
    },
    "4841": {
        "db_id": "aircraft",
        "question": "find the name of pilots who did not win the matches held in the country of Australia.",
        "ground_truth": "SELECT name FROM pilot WHERE pilot_id NOT IN (SELECT Winning_Pilot  FROM MATCH WHERE country  =  'Australia')",
        "amends": [
            "Do reference table `pilot` instead of `pilots` in the FROM clause. Do use a subquery with `pilot_id NOT IN` instead of direct `WHERE` filters with `country != 'Australia'` and `match_result = 'win'`. Do remove the `match_result = 'win'` condition from the WHERE clause and instead filter through the subquery that selects `Winning_Pilot` from the `MATCH` table where `country = 'Australia'`. Do change the logic to exclude pilots who have won matches in Australia rather than excluding non-Australian pilots with wins. The amended query now correctly identifies pilots who have not won matches in Australia, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about pilots who did not win matches in Australia: use table \"pilot\" as the main table T1, not \"pilots\". 2) When excluding pilots who won matches in Australia: use a subquery that selects \"Winning_Pilot\" from the \"MATCH\" table where \"country\" = 'Australia'. 3) When filtering pilots: use \"pilot_id NOT IN\" the subquery results instead of direct WHERE conditions with country and match_result filters. 4) When combining pilot and match data: the foreign key relationship is \"Winning_Pilot\" in match table references \"Pilot_Id\" in pilot table. 5) When outputting results: return only the \"name\" column from the pilot table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM pilots WHERE country != 'Australia' AND match_result = 'win';",
            "SELECT Name FROM pilot WHERE Pilot_Id NOT IN (SELECT Winning_Pilot FROM match WHERE Country = 'Australia')"
        ],
        "rule_sql": [
            "SELECT Name FROM pilot WHERE Pilot_Id NOT IN (SELECT Winning_Pilot FROM match WHERE Country = 'Australia')"
        ]
    },
    "4368": {
        "db_id": "tracking_grants_for_research",
        "question": "How many documents can one grant have at most? List the grant id and number.",
        "ground_truth": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT grant_id, COUNT(*) as document_count FROM documents GROUP BY grant_id HAVING COUNT(*) = (SELECT MAX(document_count) FROM (SELECT grant_id, COUNT(*) as document_count FROM documents GROUP BY grant_id))"
        ],
        "rule_sql": [
            "SELECT grant_id, COUNT(document_id) AS document_count\nFROM Documents\nGROUP BY grant_id\nORDER BY document_count DESC\nLIMIT 1;"
        ]
    },
    "3110": {
        "db_id": "behavior_monitoring",
        "question": "What are the code and description of the most frequent behavior incident type?",
        "ground_truth": "SELECT T1.incident_type_code ,  T2.incident_type_description FROM Behavior_Incident AS T1 JOIN Ref_Incident_Type AS T2 ON T1.incident_type_code  =  T2.incident_type_code GROUP BY T1.incident_type_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.incident_type_code` and `T2.incident_type_description` instead of `code` and `description`. Do join `Ref_Incident_Type AS T2` on `T1.incident_type_code = T2.incident_type_code` instead of querying only `behavior_incidents`. Do add `GROUP BY T1.incident_type_code` instead of omitting it, as the aggregate `count(*)` requires grouping. The amended query now correctly joins reference data and groups by incident type before ordering by count."
        ],
        "rules": [
            "1) When the question asks for \"code and description\" of behavior incident types: select \"T1.incident_type_code\" and \"T2.incident_type_description\" as the output columns. 2) When combining behavior incidents with reference data: join \"Ref_Incident_Type AS T2\" to the main table using \"T1.incident_type_code = T2.incident_type_code\" with inner matching. 3) When counting the frequency of behavior incident types: group the results by \"T1.incident_type_code\" to count occurrences per type. 4) When finding the most frequent type: order the grouped results by count in descending order and take the first row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT code, description FROM behavior_incidents ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T1.incident_type_code, T2.incident_type_description\nFROM Behavior_Incident AS T1\nJOIN Ref_Incident_Type AS T2 ON T1.incident_type_code = T2.incident_type_code\nGROUP BY T1.incident_type_code\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.incident_type_code, T2.incident_type_description\nFROM Behavior_Incident AS T1\nINNER JOIN Ref_Incident_Type AS T2 ON T1.incident_type_code = T2.incident_type_code\nGROUP BY T1.incident_type_code\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "1982": {
        "db_id": "phone_market",
        "question": "Show the names of phones with carrier either \"Sprint\" or \"TMobile\".",
        "ground_truth": "SELECT Name FROM phone WHERE Carrier  =  \"Sprint\" OR Carrier  =  \"TMobile\"",
        "amends": [
            "Do use `OR` operator between carrier conditions instead of `AND` to find records matching either carrier. Do reference table `phone` instead of `phones` for correct table name. Do use column name `Carrier` instead of `carrier` and `Name` instead of `name` for proper case sensitivity. Do use double quotes around string literals instead of single quotes for consistent string formatting. The amended query now correctly retrieves records where the carrier is either Sprint or TMobile instead of incorrectly requiring both conditions to be true simultaneously."
        ],
        "rules": [
            "1) When the question asks for phones with carrier either \"Sprint\" or \"TMobile\": use the OR operator between conditions instead of AND to find records matching either carrier. 2) When referencing the phone table: use the exact table name \"phone\" instead of \"phones\". 3) When selecting phone names: use the exact column name \"Name\" with proper case sensitivity. 4) When filtering by carrier: use the exact column name \"Carrier\" with proper case sensitivity. 5) When using string literals for carrier values: use double quotes around \"Sprint\" and \"TMobile\" for consistent string formatting."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM phones WHERE carrier = 'Sprint' AND carrier = 'TMobile';",
            "SELECT \"Name\" FROM \"phone\" WHERE \"Carrier\" = \"Sprint\" OR \"Carrier\" = \"TMobile\""
        ],
        "rule_sql": [
            "SELECT Name FROM phone WHERE Carrier = \"Sprint\" OR Carrier = \"TMobile\";"
        ]
    },
    "1279": {
        "db_id": "game_injury",
        "question": "What are the player name, number of matches, and information source for players who do not suffer from injury of 'Knee problem'?",
        "ground_truth": "SELECT player ,  number_of_matches ,  SOURCE FROM injury_accident WHERE injury != 'Knee problem'",
        "amends": [
            "Do use table `injury_accident` instead of joining `players` with `injuries`. Do select columns `player`, `number_of_matches`, and `SOURCE` instead of `player_name`, `COUNT(match_id) AS number_of_matches`, and `info_source`. Do filter with `injury != 'Knee problem'` instead of `injury_type = 'Knee problem'`. Do remove the `GROUP BY` clause and aggregate function instead of grouping by `players.player_id`, `player_name`, and `info_source`. The amended query now correctly excludes knee problems and uses the appropriate table structure without unnecessary joins and aggregation."
        ],
        "rules": [
            "1) When answering about players who do not suffer from 'Knee problem' injury: use table \"injury_accident\" instead of joining \"players\" with \"injuries\". 2) When selecting output columns: use exact tokens \"player\", \"number_of_matches\", and \"SOURCE\" instead of \"player_name\", aggregated count, and \"info_source\". 3) When filtering for players without 'Knee problem': use condition \"injury != 'Knee problem'\" exactly as specified. 4) When the question does not require aggregation: do not use GROUP BY clause or aggregate functions like COUNT()."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_name, COUNT(match_id) AS number_of_matches, info_source \nFROM players \nJOIN injuries ON players.player_id = injuries.player_id \nWHERE injury_type = 'Knee problem' \nGROUP BY players.player_id, player_name, info_source;",
            "SELECT Player, Number_of_matches, Source FROM injury_accident WHERE Injury != 'Knee problem';"
        ],
        "rule_sql": [
            "SELECT Player, Number_of_matches, Source FROM injury_accident WHERE Injury != 'Knee problem';"
        ]
    },
    "317": {
        "db_id": "product_catalog",
        "question": "What is the entry name of the most expensive catalog (in USD)?",
        "ground_truth": "SELECT catalog_entry_name FROM catalog_contents ORDER BY price_in_dollars DESC LIMIT 1",
        "amends": [
            "Do reference column `catalog_entry_name` instead of `entry_name` in the SELECT list. Do reference table `catalog_contents` instead of `catalog` in the FROM clause. Do reference column `price_in_dollars` instead of `price` in the ORDER BY clause. The amended query now correctly references the appropriate table and column names to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"entry name\": use the exact column \"catalog_entry_name\" from table \"Catalog_Contents\". 2) When the question asks about \"most expensive catalog (in USD)\": use the exact column \"price_in_dollars\" for ordering in descending direction to find the highest value. 3) When selecting from the catalog table: use the exact table name \"Catalog_Contents\" instead of \"catalog\". 4) When answering about the most expensive item: return only the top 1 result after ordering by price in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT entry_name FROM catalog ORDER BY price DESC LIMIT 1;",
            "SELECT catalog_entry_name FROM Catalog_Contents ORDER BY price_in_dollars DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT catalog_entry_name FROM Catalog_Contents ORDER BY price_in_dollars DESC LIMIT 1;"
        ]
    },
    "3488": {
        "db_id": "hr_1",
        "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?",
        "ground_truth": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT department_id FROM employees WHERE manager_id IS NOT NULL GROUP BY department_id HAVING COUNT(*) >= 4;"
        ],
        "rule_sql": [
            "SELECT DISTINCT DEPARTMENT_ID \nFROM employees \nWHERE MANAGER_ID IS NOT NULL \nGROUP BY DEPARTMENT_ID, MANAGER_ID \nHAVING COUNT(EMPLOYEE_ID) >= 4"
        ]
    },
    "6460": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "What are the ids of documents with the type code CV that do not have expenses.",
        "ground_truth": "SELECT document_id FROM Documents WHERE document_type_code  =  \"CV\" EXCEPT SELECT document_id FROM Documents_with_expenses",
        "amends": [
            "Do select `document_id` instead of `d.id` from the main table. Do use a single table `Documents` instead of joining `documents` with `expenses`. Do filter with `document_type_code = \"CV\"` instead of `d.type_code = 'CV'`. Do remove the `LEFT JOIN` and `e.id IS NOT NULL` condition entirely, replacing it with an `EXCEPT` operation against `Documents_with_expenses` to exclude documents with expenses. Do use double quotes around \"CV\" instead of single quotes. The amended query now correctly identifies CV documents without expenses by using set exclusion instead of a join with null checking."
        ],
        "rules": [
            "1) When answering about \"ids of documents with type code CV that do not have expenses\": make sure the output order: document_id. 2) When the question mentions \"type code CV\": \"type code CV\" actually means \"document_type_code = \\\"CV\\\"\" in schema. 3) When the question mentions \"do not have expenses\": exclude documents that appear in the Documents_with_expenses table. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms, use \\\"CV\\\" exactly as shown. 5) When handling text literals: do not change case, spacing, or punctuation, use \\\"CV\\\" exactly as specified."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.id FROM documents d LEFT JOIN expenses e ON d.id = e.document_id WHERE d.type_code = 'CV' AND e.id IS NOT NULL",
            "SELECT document_id FROM Documents WHERE document_type_code = \"CV\" EXCEPT SELECT document_id FROM Documents_with_Expenses"
        ],
        "rule_sql": [
            "SELECT d.Document_ID\nFROM Documents d\nWHERE d.Document_Type_Code = \"CV\"\nAND d.Document_ID NOT IN (\n    SELECT Document_ID \n    FROM Documents_with_Expenses\n)\nORDER BY d.Document_ID;"
        ]
    },
    "4503": {
        "db_id": "document_management",
        "question": "Find the types of documents with more than 4 documents.",
        "ground_truth": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4",
        "amends": [
            "Do use `document_type_code` instead of `type` in both the SELECT list and GROUP BY clause. Do maintain the aggregate function `COUNT(*)` and HAVING condition `> 4` without changes. The amended query now correctly references the actual column name and matches the RIGHT_SQL's behavior.",
            "Do remove the `COUNT(*) AS document_count` column from the SELECT list instead of including it, as the RIGHT_SQL only needs to return the grouping column. Do keep the `GROUP BY document_type_code` clause unchanged. Do maintain the `HAVING count(*) > 4` filter without modification. The amended query now correctly returns only document_type_code values that appear more than 4 times, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question mentions \"types of documents\": use the exact column token \"document_type_code\" instead of \"type\" in both the output and grouping. 2) When counting documents: use COUNT(*) to count all rows in each group. 3) When filtering for groups with more than 4 documents: apply the condition > 4 to the count result.",
            "1) When answering about \"types of documents with more than 4 documents\": make sure the output order: document_type_code. 2) When the question asks for \"types of documents with more than 4 documents\": group by document_type_code and keep only groups having count(*) > 4. 3) When producing output: do not include aggregate columns like document_count in the result, only return the grouping column document_type_code."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type, COUNT(*) FROM documents GROUP BY type HAVING COUNT(*) > 4",
            "SELECT document_type_code, COUNT(*) AS document_count\nFROM Documents\nGROUP BY document_type_code\nHAVING COUNT(*) > 4",
            "SELECT document_type_code FROM Documents GROUP BY document_type_code HAVING COUNT(*) > 4"
        ],
        "rule_sql": [
            "SELECT document_type_code FROM Documents GROUP BY document_type_code HAVING COUNT(*) > 4 ORDER BY document_type_code;"
        ]
    },
    "5397": {
        "db_id": "tracking_software_problems",
        "question": "Which staff members who reported problems from the product \"rem\" but not \"aut\"? Give me their first and last names.",
        "ground_truth": "SELECT T3.staff_first_name ,  T3.staff_last_name FROM problems AS T1 JOIN product AS T2 JOIN staff AS T3 ON T1.product_id = T2.product_id AND T1.reported_by_staff_id = T3.staff_id WHERE T2.product_name = \"rem\" EXCEPT SELECT T3.staff_first_name ,  T3.staff_last_name FROM problems AS T1 JOIN product AS T2 JOIN staff AS T3 ON T1.product_id = T2.product_id AND T1.reported_by_staff_id = T3.staff_id WHERE T2.product_name = \"aut\"",
        "amends": [
            "Do join `problems AS T1`, `product AS T2`, and `staff AS T3` with explicit join conditions `T1.product_id = T2.product_id AND T1.reported_by_staff_id = T3.staff_id` instead of querying `staff` table directly without proper joins. Do filter for `T2.product_name = \"rem\"` instead of filtering on a non-existent `product` column in the staff table. Do use `EXCEPT` to exclude staff who reported problems with `T2.product_name = \"aut\"` instead of using `AND product != 'aut'` which incorrectly attempts to filter the same column. Do select `T3.staff_first_name` and `T3.staff_last_name` with proper table aliasing instead of `first_name` and `last_name` without table qualification. The amended query now correctly identifies staff who reported 'rem' products but not 'aut' products by properly joining through the problems table and using set operations instead of incorrect column references."
        ],
        "rules": [
            "1) When answering about staff members who reported problems from specific products: join problems AS T1, product AS T2, and staff AS T3 using the exact join conditions T1.product_id = T2.product_id AND T1.reported_by_staff_id = T3.staff_id. 2) When filtering for product \"rem\": use T2.product_name = \"rem\" exactly as specified. 3) When excluding staff who reported product \"aut\": use EXCEPT operation with T2.product_name = \"aut\" instead of AND conditions on the same column. 4) When selecting staff names: output T3.staff_first_name and T3.staff_last_name with proper table qualification. 5) When combining tables for this question: perform inner matches only using the specified join conditions to ensure proper relationships between problems, products, and staff."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM staff WHERE product = 'rem' AND product != 'aut';",
            "SELECT T3.staff_first_name, T3.staff_last_name\nFROM Problems AS T1\nJOIN Product AS T2 ON T1.product_id = T2.product_id\nJOIN Staff AS T3 ON T1.reported_by_staff_id = T3.staff_id\nWHERE T2.product_name = 'rem'\nEXCEPT\nSELECT T3.staff_first_name, T3.staff_last_name\nFROM Problems AS T1\nJOIN Product AS T2 ON T1.product_id = T2.product_id\nJOIN Staff AS T3 ON T1.reported_by_staff_id = T3.staff_id\nWHERE T2.product_name = 'aut'"
        ],
        "rule_sql": [
            "SELECT T3.staff_first_name, T3.staff_last_name\nFROM Problems AS T1\nJOIN Product AS T2 ON T1.product_id = T2.product_id\nJOIN Staff AS T3 ON T1.reported_by_staff_id = T3.staff_id\nWHERE T2.product_name = 'rem'\nEXCEPT\nSELECT T3.staff_first_name, T3.staff_last_name\nFROM Problems AS T1\nJOIN Product AS T2 ON T1.product_id = T2.product_id\nJOIN Staff AS T3 ON T1.reported_by_staff_id = T3.staff_id\nWHERE T2.product_name = 'aut'"
        ]
    },
    "3622": {
        "db_id": "music_1",
        "question": "What is the id, genre, and name of the artist for every English song ordered by ascending rating?",
        "ground_truth": "SELECT f_id ,  genre_is ,  artist_name FROM song WHERE languages  =   \"english\" ORDER BY rating",
        "amends": [
            "Do select `f_id`, `genre_is`, and `artist_name` instead of `artist.id`, `artist.genre`, and `artist.name`. Do query only from `song` table instead of joining `artist` and `song` tables. Do filter on `languages = \"english\"` instead of `song.language = 'English'`. Do order by `rating` instead of `song.rating ASC`. The amended query now correctly retrieves data directly from the song table with the appropriate column names and filtering conditions."
        ],
        "rules": [
            "1) When answering about \"id, genre, and name of the artist for every English song\": make sure the output order: f_id, genre_is, artist_name. 2) When the question mentions \"English song\": \"English\" actually means \"english\" in schema, so filter on languages = \"english\". 3) When the question asks for ordering by \"ascending rating\": order by rating in ascending direction. 4) When retrieving data about songs: query only from the song table instead of joining with other tables."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT artist.id, artist.genre, artist.name FROM artist JOIN song ON artist.id = song.artist_id WHERE song.language = 'English' ORDER BY song.rating ASC;",
            "SELECT f_id, genre_is, artist_name FROM song WHERE languages = 'english' ORDER BY rating;"
        ],
        "rule_sql": [
            "SELECT f_id, genre_is, artist_name FROM song WHERE languages = 'english' ORDER BY rating ASC"
        ]
    },
    "3374": {
        "db_id": "sports_competition",
        "question": "What are the positions of both players that have more than 20 20 points and less than 10 points?",
        "ground_truth": "SELECT POSITION FROM player WHERE Points  >  20 INTERSECT SELECT POSITION FROM player WHERE Points  <  10",
        "amends": [
            "Do use `INTERSECT` to find common positions instead of the contradictory `WHERE points > 20 AND points < 10` condition. Do reference the table as `player` instead of `players` and use consistent case `POSITION` instead of `position`. Do split into two separate queries with `SELECT POSITION FROM player WHERE Points > 20` and `SELECT POSITION FROM player WHERE Points < 10` instead of trying to combine incompatible conditions in a single WHERE clause. The amended query now correctly finds positions where players have both scored more than 20 points and less than 10 points in different games, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for positions of players with both more than 20 points and less than 10 points: use INTERSECT to find common positions from separate queries instead of combining contradictory conditions in a single WHERE clause. 2) When referencing the player table: use the exact table name \"player\" instead of \"players\". 3) When selecting the position column: use the exact column name \"POSITION\" with consistent case. 4) When finding players with more than 20 points: use the condition \"Points > 20\" with exact column name \"Points\". 5) When finding players with less than 10 points: use the condition \"Points < 10\" with exact column name \"Points\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT position FROM players WHERE points > 20 AND points < 10;",
            "SELECT POSITION FROM player WHERE Points > 20\nINTERSECT\nSELECT POSITION FROM player WHERE Points < 10"
        ],
        "rule_sql": [
            "SELECT POSITION FROM player WHERE Points > 20\nINTERSECT\nSELECT POSITION FROM player WHERE Points < 10;"
        ]
    },
    "5006": {
        "db_id": "soccer_2",
        "question": "Find the names of the students who are in the position of striker and got a yes tryout decision.",
        "ground_truth": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'",
        "amends": [
            "Do select `T1.pName` instead of `name` and use table alias `T1` instead of direct table reference. Do join `player AS T1` with `tryout AS T2` on `T1.pID = T2.pID` instead of querying only the `students` table. Do filter on `T2.decision = 'yes'` instead of `tryout_decision = 'no'` and maintain the position filter as `T2.pPos = 'striker'` instead of `position = 'striker'`. The amended query now correctly joins player and tryout tables to find strikers with positive tryout decisions instead of negative ones, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about student names: use T1.pName instead of name as the output column. 2) When combining player and tryout information: link rows where T1.pID = T2.pID and keep only matching pairs (inner match). 3) When filtering for striker position: use T2.pPos = 'striker' with exact literal 'striker'. 4) When filtering for positive tryout decisions: use T2.decision = 'yes' with exact literal 'yes' instead of 'no'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM students WHERE position = 'striker' AND tryout_decision = 'no';",
            "SELECT T1.pName FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T2.pPos = 'striker' AND T2.decision = 'yes'"
        ],
        "rule_sql": [
            "SELECT T1.pName FROM Player T1 INNER JOIN Tryout T2 ON T1.pID = T2.pID WHERE T2.pPos = 'striker' AND T2.decision = 'yes'"
        ]
    },
    "3443": {
        "db_id": "hr_1",
        "question": "display job Title, the difference between minimum and maximum salaries for those jobs which max salary within the range 12000 to 18000.",
        "ground_truth": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT job_title, max_salary - min_salary AS salary_difference \nFROM jobs \nWHERE max_salary BETWEEN 12000 AND 18000;"
        ],
        "rule_sql": [
            "SELECT JOB_TITLE, (MAX_SALARY - MIN_SALARY) AS SALARY_DIFFERENCE FROM jobs WHERE MAX_SALARY BETWEEN 12000 AND 18000;"
        ]
    },
    "953": {
        "db_id": "medicine_enzyme_interaction",
        "question": "What is the id and name of the enzyme with most number of medicines that can interact as 'activator'?",
        "ground_truth": "SELECT T1.id ,  T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id WHERE T2.interaction_type  =  'activitor' GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference table `medicine_enzyme_interaction` as `T2` instead of `medicine_enzyme` and use alias `T1` for `enzyme` instead of `e`. Do join on `T1.id = T2.enzyme_id` instead of `e.id = me.enzyme_id`. Do filter on `T2.interaction_type = 'activitor'` instead of `me.interaction_type = 'activator'` with corrected spelling. Do group by only `T1.id` instead of both `e.id` and `e.name`. Do order by `count(*)` instead of `COUNT(me.medicine_id)` for the aggregate count. The amended query now correctly identifies the enzyme with the most activator interactions using the proper table relationships and grouping logic."
        ],
        "rules": [
            "1) When joining enzyme and medicine_enzyme_interaction tables: use T1 as alias for enzyme and T2 as alias for medicine_enzyme_interaction, and link rows where T1.id = T2.enzyme_id. 2) When filtering for activator interactions: use T2.interaction_type = 'activitor' with exact spelling 'activitor'. 3) When grouping enzyme results: group by only T1.id instead of both id and name. 4) When counting interactions: use count(*) to count all rows in each group rather than counting a specific column. 5) When ordering results by interaction count: order by count(*) in descending order to find the enzyme with most interactions. 6) When selecting output columns: include both T1.id and T1.name for the enzyme with most activator interactions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.id, e.name \nFROM enzyme e \nJOIN medicine_enzyme me ON e.id = me.enzyme_id \nWHERE me.interaction_type = 'activator' \nGROUP BY e.id, e.name \nORDER BY COUNT(me.medicine_id) DESC \nLIMIT 1;",
            "SELECT T1.id, T1.name\nFROM enzyme AS T1\nJOIN medicine_enzyme_interaction AS T2 ON T1.id = T2.enzyme_id\nWHERE T2.interaction_type = 'activitor'\nGROUP BY T1.id\nORDER BY count(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.id, T1.name\nFROM enzyme T1\nJOIN medicine_enzyme_interaction T2 ON T1.id = T2.enzyme_id\nWHERE T2.interaction_type = 'activitor'\nGROUP BY T1.id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "6113": {
        "db_id": "customers_and_addresses",
        "question": "How many types of products have Rodrick Heaney bought in total?",
        "ground_truth": "SELECT count(DISTINCT t3.product_id) FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t1.customer_name  =  \"Rodrick Heaney\"",
        "amends": [
            "Do count `DISTINCT t3.product_id` instead of `COUNT(*)` to count unique products rather than all rows. Do join `customers AS t1` instead of querying only the `products` table to properly access customer data. Do add `JOIN customer_orders AS t2 ON t1.customer_id = t2.customer_id` instead of omitting this relationship to connect customers to their orders. Do add `JOIN order_items AS t3 ON t2.order_id = t3.order_id` instead of omitting this relationship to access the products in orders. Do filter on `t1.customer_name = \"Rodrick Heaney\"` instead of `customer_name = 'Rodrick Heaney'` to reference the joined table and use proper string quoting. The amended query now correctly counts distinct products for the specified customer by properly joining through the customer-order relationship chain."
        ],
        "rules": [
            "1) When answering about \"types of products bought by a customer\": make sure the output order: count of distinct products. 2) When the question mentions \"Rodrick Heaney\": \"Rodrick Heaney\" actually means \"t1.customer_name = 'Rodrick Heaney'\" in schema. 3) When combining t1 and t2 for shared entities: link rows where t1.customer_id = t2.customer_id; keep only matching pairs (inner match). 4) When combining t2 and t3 for shared entities: link rows where t2.order_id = t3.order_id; keep only matching pairs (inner match). 5) When the question asks for \"count of distinct products\": compute the number of unique values of the exact token t3.product_id."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM products WHERE customer_name = 'Rodrick Heaney';",
            "SELECT COUNT(DISTINCT t3.product_id) \nFROM customers AS t1\nJOIN customer_orders AS t2 ON t1.customer_id = t2.customer_id\nJOIN order_items AS t3 ON t2.order_id = t3.order_id\nWHERE t1.customer_name = \"Rodrick Heaney\""
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT oi.product_id) \nFROM Customers c\nINNER JOIN Customer_Orders co ON c.customer_id = co.customer_id\nINNER JOIN Order_Items oi ON co.order_id = oi.order_id\nWHERE c.customer_name = 'Rodrick Heaney'"
        ]
    },
    "237": {
        "db_id": "musical",
        "question": "What are the names of actors, ordered alphabetically?",
        "ground_truth": "SELECT Name FROM actor ORDER BY Name ASC",
        "amends": [
            "Do use column name `Name` instead of `name` to match the correct case sensitivity. Do use table name `actor` instead of `actors` to reference the correct table. Do use `ASC` ordering instead of `DESC` to sort in ascending order rather than descending. The amended query now correctly selects from the proper table with appropriate column casing and sorting direction."
        ],
        "rules": [
            "1) When the question asks for actor names: use the exact column token \"Name\" from table \"actor\" to match case sensitivity. 2) When ordering alphabetically: sort the results in ascending order (A-Z) using the \"Name\" column. 3) When referencing the actors table: use the exact table name \"actor\" instead of any variations like \"actors\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM actors ORDER BY name DESC;",
            "SELECT Name FROM actor ORDER BY Name ASC;"
        ],
        "rule_sql": [
            "SELECT Name FROM actor ORDER BY Name ASC;"
        ]
    },
    "2096": {
        "db_id": "pilot_record",
        "question": "Show names of pilots that have more than one record.",
        "ground_truth": "SELECT T2.Pilot_name ,  COUNT(*) FROM pilot_record AS T1 JOIN pilot AS T2 ON T1.pilot_ID  =  T2.pilot_ID GROUP BY T2.Pilot_name HAVING COUNT(*)  >  1",
        "amends": [
            "Do select `T2.Pilot_name` and `COUNT(*)` instead of just `name`. Do use `FROM pilot_record AS T1 JOIN pilot AS T2` instead of `FROM pilots` alone. Do add join condition `ON T1.pilot_ID = T2.pilot_ID` instead of missing the table relationship. Do add `GROUP BY T2.Pilot_name` instead of omitting grouping. Do move the count filter to `HAVING COUNT(*) > 1` instead of incorrectly placing it in `WHERE`. The amended query now correctly counts pilot records per pilot name and filters for duplicates, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"names of pilots that have more than one record\": make sure the output order: T2.Pilot_name, COUNT(*). 2) When the question mentions \"pilots\": \"pilots\" actually means \"pilot AS T2\" in schema. 3) When the question mentions \"record\": \"record\" actually means \"pilot_record AS T1\" in schema. 4) When combining T1 and T2 for shared entities: link rows where T1.pilot_ID = T2.pilot_ID exactly as shown; keep only matching pairs (inner match). 5) When the question asks for \"count of records per pilot\": compute the number of rows using T1.pilot_ID as the counting key and organize results by T2.Pilot_name. 6) When filtering for \"more than one record\": apply the condition COUNT(*) > 1 after grouping (HAVING clause equivalent)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM pilots WHERE COUNT(*) > 1",
            "SELECT T2.Pilot_name, COUNT(*) \nFROM pilot_record AS T1 \nJOIN pilot AS T2 ON T1.Pilot_ID = T2.Pilot_ID \nGROUP BY T2.Pilot_name \nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T2.Pilot_name, COUNT(*)\nFROM pilot_record AS T1\nINNER JOIN pilot AS T2 ON T1.Pilot_ID = T2.Pilot_ID\nGROUP BY T2.Pilot_name\nHAVING COUNT(*) > 1\nORDER BY T2.Pilot_name, COUNT(*)"
        ]
    },
    "6768": {
        "db_id": "activity_1",
        "question": "Find the number of activities available.",
        "ground_truth": "SELECT count(*) FROM Activity",
        "amends": [
            "Do query the `Activity` table instead of the `users` table. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"number of activities available\": query the \"Activity\" table instead of the \"users\" table. 2) When counting activities: count all rows from the \"Activity\" table to get the total number of activities available."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users;",
            "SELECT COUNT(*) FROM Activity;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Activity;"
        ]
    },
    "26": {
        "db_id": "farm",
        "question": "What are the maximum and minimum number of cows across all farms.",
        "ground_truth": "SELECT max(Cows) ,  min(Cows) FROM farm",
        "amends": [
            "Do use lowercase `cows` in the column references instead of uppercase `Cows` to match the actual column name. Do include the `AS` keyword for column aliases `max_cows` and `min_cows` instead of omitting them for better readability. Do specify the table name as `farms` (plural) instead of `farm` (singular) to reference the correct table. Do keep the `WHERE cows IS NOT NULL` filter to exclude null values instead of removing it, ensuring accurate aggregation. The amended query now correctly calculates maximum and minimum cow counts from the farms table while handling null values appropriately.",
            "Do use lowercase `max` and `min` functions instead of uppercase `MAX` and `MIN`. Do reference table `farm` instead of `farms`. Do remove the `WHERE cows IS NOT NULL` filter instead of keeping it, as aggregate functions automatically handle NULL values. Do remove the column aliases `max_cows` and `min_cows` instead of including them. The amended query now correctly calculates the maximum and minimum cow values from the farm table without unnecessary filtering or aliasing."
        ],
        "rules": [
            "1) When the question asks for maximum and minimum values of \"cows\": use the exact column name \"cows\" (lowercase) from the \"farms\" table. 2) When calculating aggregates on \"cows\": exclude null values by filtering where \"cows IS NOT NULL\" to ensure accurate results. 3) When presenting aggregated results: use column aliases \"max_cows\" and \"min_cows\" with the AS keyword for better readability. 4) When referencing the table containing cow data: use the exact table name \"farms\" (plural) instead of singular forms.",
            "1) When answering about maximum and minimum number of cows across all farms: use lowercase functions max and min instead of uppercase MAX and MIN. 2) When referencing the table containing farm data: use the exact table name farm instead of farms. 3) When calculating aggregate functions on cow values: do not filter out NULL values as aggregate functions automatically handle NULL values. 4) When producing output columns: do not include column aliases like max_cows and min_cows."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(cows) AS max_cows, MIN(cows) AS min_cows FROM farms WHERE cows IS NOT NULL;",
            "SELECT MAX(cows) AS max_cows, MIN(cows) AS min_cows FROM farms WHERE cows IS NOT NULL",
            "SELECT MAX(cows) AS max_cows, MIN(cows) AS min_cows FROM farm"
        ],
        "rule_sql": [
            "SELECT min(cows) AS min_cows, max(cows) AS max_cows FROM farm WHERE cows IS NOT NULL"
        ]
    },
    "3885": {
        "db_id": "insurance_policies",
        "question": "Return the distinct customer details.",
        "ground_truth": "SELECT DISTINCT customer_details FROM Customers",
        "amends": [
            "Do select `customer_details` instead of `*` for all columns. Do use `DISTINCT` instead of omitting it to remove duplicate rows. Do reference table `Customers` instead of `customers` with proper case sensitivity. Do remove the `WHERE customer_id = 1` filter instead of keeping it to return all customer details rather than just one specific customer. The amended query now matches RIGHT_SQL's behavior by selecting distinct customer details from the entire Customers table."
        ],
        "rules": [
            "1) When selecting customer details: use the exact column name \"customer_details\" instead of selecting all columns with *. 2) When returning distinct customer details: apply DISTINCT to remove duplicate rows. 3) When referencing the customers table: use the exact table name \"Customers\" with proper case sensitivity. 4) When the question asks for all customer details: do not apply any WHERE filter that would restrict results to specific customers."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM customers WHERE customer_id = 1;",
            "SELECT DISTINCT Customer_Details FROM Customers"
        ],
        "rule_sql": [
            "SELECT DISTINCT Customer_Details FROM Customers;"
        ]
    },
    "426": {
        "db_id": "flight_1",
        "question": "What are the names of all employees who have a certificate to fly Boeing 737-800?",
        "ground_truth": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  \"Boeing 737-800\"",
        "amends": [
            "Do specify `T1.name` with table alias instead of just `name` without qualification. Do add joins to `Certificate AS T2` and `Aircraft AS T3` instead of querying only the `employees` table. Do use `JOIN` with proper join conditions `ON T1.eid = T2.eid` and `ON T3.aid = T2.aid` instead of no joins. Do filter on `T3.name = \"Boeing 737-800\"` instead of filtering directly on a `certificate` column that doesn't exist in the employees table. The amended query now correctly joins through the certificate and aircraft tables to find employees certified for the specific aircraft type, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about employee names with specific aircraft certification: make sure the output order: T1.name 2) When the question mentions \"Boeing 737-800\": \"Boeing 737-800\" actually means T3.name = \"Boeing 737-800\" in schema 3) When combining T1 (employee) and T2 (Certificate) for shared entities: link rows where T1.eid = T2.eid and keep only matching pairs (inner match) 4) When combining T2 (Certificate) and T3 (Aircraft) for shared entities: link rows where T3.aid = T2.aid and keep only matching pairs (inner match) 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for literal \"Boeing 737-800\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM employees WHERE certificate = 'Boeing 737-800';",
            "SELECT T1.name \nFROM employee AS T1\nJOIN certificate AS T2 ON T1.eid = T2.eid\nJOIN aircraft AS T3 ON T3.aid = T2.aid\nWHERE T3.name = 'Boeing 737-800'"
        ],
        "rule_sql": [
            "SELECT T1.name FROM employee T1 INNER JOIN certificate T2 ON T1.eid = T2.eid INNER JOIN aircraft T3 ON T3.aid = T2.aid WHERE T3.name = \"Boeing 737-800\""
        ]
    },
    "1205": {
        "db_id": "apartment_rentals",
        "question": "Find all the building full names containing the word \"court\".",
        "ground_truth": "SELECT building_full_name FROM Apartment_Buildings WHERE building_full_name LIKE \"%court%\"",
        "amends": [
            "Do select `building_full_name` instead of `*` to return only the specific column needed. Do reference table `Apartment_Buildings` instead of `buildings` to query the correct data source. Do use double quotes for the string pattern `\"%court%\"` instead of single quotes to maintain consistency with the surrounding query syntax, though this may be database-specific. The amended query now correctly retrieves building full names containing \"court\" from the appropriate table."
        ],
        "rules": [
            "1) When answering about \"building full names containing the word 'court'\": make sure the output order: building_full_name. 2) When the question mentions \"building full names\": \"building_full_name\" actually means \"building_full_name in Apartment_Buildings\". 3) When the question mentions \"containing the word 'court'\": use the exact string pattern \"%court%\" to match building_full_name values. 4) When selecting from the database: reference table \"Apartment_Buildings\" instead of generic \"buildings\" to query the correct data source."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM buildings WHERE building_name LIKE '%court%';",
            "SELECT building_full_name FROM Apartment_Buildings WHERE building_full_name LIKE \"%court%\""
        ],
        "rule_sql": [
            "SELECT building_full_name FROM Apartment_Buildings WHERE building_full_name LIKE '%court%' ORDER BY building_full_name;"
        ]
    },
    "6419": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "What is the document type code with most number of documents?",
        "ground_truth": "SELECT document_type_code FROM Documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do order by `count(*) DESC` instead of `count ASC` to get the document type with the highest count rather than the lowest count. Do remove the explicit `COUNT(*) as count` column from the SELECT list instead of including it since only the document_type_code is needed in the final result. The amended query now correctly identifies the most frequent document type by counting occurrences in descending order and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"document type code with most number of documents\": make sure the output order: document_type_code only. 2) When counting documents: compute the number of rows using the canonical key for documents. 3) When the question mentions \"most number\": rank document types by count in descending order and keep the first 1 row. 4) When producing output: do not include the count column in the final result, only show document_type_code."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_type_code, COUNT(*) as count FROM documents GROUP BY document_type_code ORDER BY count ASC LIMIT 1;",
            "SELECT Document_Type_Code FROM Documents GROUP BY Document_Type_Code ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Document_Type_Code\nFROM Documents\nGROUP BY Document_Type_Code\nORDER BY COUNT(Document_ID) DESC\nLIMIT 1;"
        ]
    },
    "6360": {
        "db_id": "school_bus",
        "question": "What is the maximum, minimum and average years spent working on a school bus?",
        "ground_truth": "SELECT max(years_working) ,  min(years_working) ,  avg(years_working) FROM school_bus",
        "amends": [
            "Do reference table `school_bus` instead of `employees` in the FROM clause. Do use column `years_working` instead of `years_worked` in all aggregate functions. Do remove the WHERE filter condition `job_title = 'teacher'` instead of keeping it. Do omit column aliases `max_years`, `min_years`, and `avg_years` instead of including them. The amended query now correctly calculates aggregate statistics on the years_working column from the school_bus table without unnecessary filtering or aliasing."
        ],
        "rules": [
            "1) When answering about \"years spent working on a school bus\": use the table \"school_bus\" instead of \"employees\". 2) When calculating aggregate statistics on years worked: use the column \"years_working\" instead of \"years_worked\" for MAX, MIN, and AVG functions. 3) When the question does not specify any job title filtering: remove any WHERE clause conditions like \"job_title = 'teacher'\". 4) When the question asks for maximum, minimum and average values: omit column aliases like \"max_years\", \"min_years\", and \"avg_years\" from the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(years_worked) AS max_years, MIN(years_worked) AS min_years, AVG(years_worked) AS avg_years FROM employees WHERE job_title = 'teacher';",
            "SELECT MAX(Years_Working), MIN(Years_Working), AVG(Years_Working) FROM school_bus;"
        ],
        "rule_sql": [
            "SELECT MAX(Years_Working), MIN(Years_Working), AVG(Years_Working) FROM school_bus;"
        ]
    },
    "5030": {
        "db_id": "soccer_2",
        "question": "How many schools have some students playing in goalie and mid positions.",
        "ground_truth": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid')",
        "amends": [
            "Do use a subquery with `INTERSECT` to find schools with both positions instead of a single `WHERE` clause with conflicting conditions. Do query the `tryout` table instead of the `schools` table to access position data. Do filter for `pPos = 'goalie'` in one branch and `pPos = 'mid'` in another instead of using `AND` between mutually exclusive conditions. Do select `cName` for intersection instead of counting directly from the wrong table. Do count the intersecting school names instead of attempting to count rows with impossible dual positions. The amended query now correctly identifies schools that have both goalie and mid positions through set intersection."
        ],
        "rules": [
            "1) When the question asks about schools with students in specific positions: use the \"tryout\" table instead of the \"schools\" table to access position data. 2) When finding schools with both \"goalie\" and \"mid\" positions: use set intersection on \"cName\" values rather than using AND conditions on the same row. 3) When filtering for position \"goalie\": use the exact literal 'goalie' with the column \"pPos\". 4) When filtering for position \"mid\": use the exact literal 'mid' with the column \"pPos\". 5) When counting schools with both positions: count the intersecting \"cName\" values from the set intersection result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM schools WHERE position = 'goalie' AND position = 'mid'",
            "SELECT COUNT(*) \nFROM (\n    SELECT cName FROM Tryout WHERE pPos = 'goalie'\n    INTERSECT\n    SELECT cName FROM Tryout WHERE pPos = 'mid'\n)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM (\n    SELECT cName \n    FROM Tryout \n    WHERE pPos = 'goalie' \n    INTERSECT\n    SELECT cName \n    FROM Tryout \n    WHERE pPos = 'mid'\n)"
        ]
    },
    "4657": {
        "db_id": "college_3",
        "question": "Find the department name that is in Building \"Mergenthaler\".",
        "ground_truth": "SELECT DName FROM DEPARTMENT WHERE Building  =  \"Mergenthaler\"",
        "amends": [
            "Do reference the `DName` column instead of `department_name` and use the `DEPARTMENT` table instead of `departments`. Do use double quotes around the string literal \"Mergenthaler\" instead of single quotes. The amended query now correctly references the table and column names to match the intended schema."
        ],
        "rules": [
            "1) When answering about \"department name in Building Mergenthaler\": make sure the output order: \"DName\" 2) When the question mentions \"department name\": \"department name\" actually means \"DName in schema\" 3) When the question mentions \"Building Mergenthaler\": use the exact literal \"Mergenthaler\" with double quotes 4) When querying department information: use the table \"DEPARTMENT\" instead of \"departments\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department_name FROM departments WHERE building = 'Mergenthaler';",
            "SELECT DName FROM Department WHERE Building = \"Mergenthaler\""
        ],
        "rule_sql": [
            "SELECT DName FROM Department WHERE Building = \"Mergenthaler\";"
        ]
    },
    "502": {
        "db_id": "allergy_1",
        "question": "Give the advisor with the most students.",
        "ground_truth": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use table name `Student` instead of `students` and column name `advisor` instead of `advisor_id`. Do use `count(*)` instead of `COUNT(student_id)` to count all rows including those with null student_id values. Do order by `count(*) DESC` instead of `student_count ASC` to find the advisor with the most students rather than the fewest. Do remove the alias `student_count` instead of keeping it since the ORDER BY clause now directly references the aggregate function. The amended query now correctly identifies the advisor with the highest student count by counting all students per advisor and sorting in descending order.",
            "Do select only `advisor` instead of including both `advisor` and `COUNT(*)` in the SELECT list. Do maintain the `GROUP BY advisor` clause instead of altering it. Do preserve the `ORDER BY count(*) DESC` and `LIMIT 1` clauses instead of changing them. The amended query now correctly returns only the advisor with the highest student count instead of returning both the advisor and the count value."
        ],
        "rules": [
            "1) When the question asks about \"advisor with the most students\": use table name \"Student\" instead of \"students\" and column name \"advisor\" instead of \"advisor_id\". 2) When counting students per advisor: use count(*) instead of counting a specific column to include all rows including those with null values. 3) When finding the advisor with the most students: order by the count in descending order instead of ascending order to get the highest count. 4) When ordering by an aggregate function: reference the function directly instead of using an alias for the count. 5) When the question asks for \"the advisor with the most students\": return only the top result by using a limit of 1 after descending ordering.",
            "1) When answering about \"the advisor with the most students\": make sure the output order: advisor only without the count value. 2) When the question asks for \"most students\" per advisor: organize results by advisor and count the number of students per group. 3) When the question asks for \"the most\" (highest count): rank rows by student count in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT advisor_id, COUNT(student_id) as student_count FROM students GROUP BY advisor_id ORDER BY student_count ASC LIMIT 1;",
            "SELECT advisor, COUNT(*) FROM Student GROUP BY advisor ORDER BY COUNT(*) DESC LIMIT 1",
            "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT advisor FROM Student GROUP BY advisor ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "6623": {
        "db_id": "driving_school",
        "question": "What are the ids of all vehicles?",
        "ground_truth": "SELECT vehicle_id FROM Vehicles;",
        "amends": [
            "Do select `vehicle_id` instead of `vehicle_name` and reference the table as `Vehicles` instead of `vehicles` to match the correct schema and column naming conventions."
        ],
        "rules": [
            "1) When answering about \"ids of all vehicles\": make sure the output column is \"vehicle_id\" instead of \"vehicle_name\". 2) When referencing the vehicles table: use the exact table name \"Vehicles\" with capital V instead of \"vehicles\" with lowercase v. 3) When selecting from the Vehicles table: output the vehicle_id column to get the vehicle identifiers."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT vehicle_name FROM vehicles;",
            "SELECT vehicle_id FROM Vehicles;"
        ],
        "rule_sql": [
            "SELECT vehicle_id FROM Vehicles;"
        ]
    },
    "1452": {
        "db_id": "college_2",
        "question": "Find the name of students who didn't take any course from Biology department.",
        "ground_truth": "SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  'Biology')",
        "amends": [
            "Do select `name` directly from `student` instead of joining multiple tables and selecting `s.name`. Do use a `NOT IN` subquery instead of a multi-table join approach. Do filter with `WHERE id NOT IN` instead of using positive matching with `WHERE c.department = 'Biology'`. Do reference `takes` and `course` tables in the subquery instead of `enrollments` and `courses`. Do use `dept_name` column instead of `department` for the department filter. Do join on `course_id` instead of `id` for the course table relationship. The amended query now correctly finds students who have not taken Biology courses instead of those who have taken them."
        ],
        "rules": [
            "1) When answering about students who didn't take Biology courses: select \"name\" directly from \"student\" table instead of joining multiple tables. 2) When filtering for students who didn't take courses from Biology department: use a NOT IN subquery with \"id NOT IN\" instead of positive matching. 3) When referencing department information: use \"dept_name\" column instead of \"department\" for the department filter. 4) When joining tables in subqueries: use \"takes\" and \"course\" tables instead of \"enrollments\" and \"courses\". 5) When establishing course relationships: join on \"course_id\" instead of \"id\" for the course table relationship. 6) When filtering for Biology department: use exact literal 'Biology' with correct case and spelling."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.name FROM students s JOIN enrollments e ON s.id = e.student_id JOIN courses c ON e.course_id = c.id WHERE c.department = 'Biology';",
            "SELECT name FROM student WHERE id NOT IN (SELECT t.id FROM takes t JOIN course c ON t.course_id = c.course_id WHERE c.dept_name = 'Biology')"
        ],
        "rule_sql": [
            "SELECT name FROM student WHERE ID NOT IN (SELECT t.ID FROM takes t JOIN course c ON t.course_id = c.course_id WHERE c.dept_name = 'Biology')"
        ]
    },
    "1686": {
        "db_id": "theme_gallery",
        "question": "Count the number of exhibitions that have had an attendnance of over 100 or a ticket prices under 10.",
        "ground_truth": "SELECT count(*) FROM exhibition_record AS T1 JOIN exhibition AS T2 ON T1.exhibition_id  =  T2.exhibition_id WHERE T1.attendance  >  100 OR T2.ticket_price  <  10",
        "amends": [
            "Do join `exhibition_record AS T1` and `exhibition AS T2` on `T1.exhibition_id = T2.exhibition_id` instead of querying only the `exhibitions` table. Do use `OR` between conditions `T1.attendance > 100` and `T2.ticket_price < 10` instead of `AND`. Do reference `attendance` from `T1` and `ticket_price` from `T2` instead of assuming both columns exist in a single table. The amended query now correctly joins related tables and uses the appropriate logical operator to match the intended behavior.",
            "Do use `count(*)` instead of `COUNT(DISTINCT T1.Exhibition_ID)` to count all matching rows rather than distinct exhibition IDs. Do reference lowercase column names `exhibition_id`, `attendance`, and `ticket_price` instead of mixed-case versions to ensure proper column matching. The amended query now correctly counts all exhibition records where attendance exceeds 100 or ticket price is below 10, matching the intended behavior."
        ],
        "rules": [
            "1) When counting exhibitions with attendance over 100 or ticket prices under 10: join exhibition_record AS T1 and exhibition AS T2 on T1.exhibition_id = T2.exhibition_id using an inner match. 2) When combining conditions for attendance and ticket price: use OR between T1.attendance > 100 and T2.ticket_price < 10 instead of AND. 3) When referencing attendance and ticket_price columns: use T1.attendance from exhibition_record table and T2.ticket_price from exhibition table. 4) When counting exhibitions: count using the exhibition entity (likely T2.exhibition_id) rather than counting all rows.",
            "1) When counting exhibitions that meet certain conditions: use count(*) to count all matching rows rather than counting distinct exhibition IDs. 2) When referencing column names: use lowercase column names exhibition_id, attendance, and ticket_price instead of mixed-case versions to ensure proper column matching. 3) When filtering exhibition records: include rows where attendance exceeds 100 or ticket price is below 10 to match the intended behavior."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM exhibitions WHERE attendance > 100 AND ticket_price < 10;",
            "SELECT COUNT(DISTINCT T1.Exhibition_ID) \nFROM exhibition_record AS T1 \nJOIN exhibition AS T2 ON T1.Exhibition_ID = T2.Exhibition_ID \nWHERE T1.Attendance > 100 OR T2.Ticket_Price < 10",
            "SELECT COUNT(*) \nFROM exhibition_record AS T1 \nJOIN exhibition AS T2 ON T1.exhibition_id = T2.exhibition_id \nWHERE T1.attendance > 100 OR T2.ticket_price < 10"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM exhibition_record AS T1 \nINNER JOIN exhibition AS T2 ON T1.exhibition_id = T2.exhibition_id \nWHERE T1.attendance > 100 OR T2.ticket_price < 10"
        ]
    },
    "5805": {
        "db_id": "customer_complaints",
        "question": "Count the number of different complaint type codes.",
        "ground_truth": "SELECT count(DISTINCT complaint_type_code) FROM complaints",
        "amends": [
            "Do use `count(DISTINCT complaint_type_code)` instead of `COUNT(complaint_type)` to count distinct complaint type codes rather than all occurrences of complaint types, and do reference the correct column `complaint_type_code` instead of `complaint_type` to ensure accurate distinct counting of complaint type identifiers. The amended query now correctly counts unique complaint type codes as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When counting the number of different complaint type codes: use count(DISTINCT complaint_type_code) instead of COUNT(complaint_type) to count distinct values. 2) When the question asks for \"different complaint type codes\": reference the exact column complaint_type_code rather than complaint_type to ensure accurate counting of complaint type identifiers."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(complaint_type) FROM complaints;",
            "SELECT COUNT(DISTINCT complaint_type_code) FROM Complaints;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT complaint_type_code) FROM Complaints;"
        ]
    },
    "2860": {
        "db_id": "icfp_1",
        "question": "How many institutions are there?",
        "ground_truth": "SELECT count(*) FROM inst",
        "amends": [
            "Do reference the `inst` table instead of the `students` table in the FROM clause. The amended query now correctly counts records from the intended table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting institutions: use the \"inst\" table to count records instead of the \"students\" table. 2) When answering about \"how many institutions\": count all records from the \"inst\" table to get the total number of institutions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;",
            "SELECT COUNT(*) FROM Inst;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Inst;"
        ]
    },
    "6313": {
        "db_id": "e_government",
        "question": "What is the name of the party form that is most common?",
        "ground_truth": "SELECT t1.form_name FROM forms AS t1 JOIN party_forms AS t2 ON t1.form_id  =  t2.form_id GROUP BY t2.form_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `form_name` from the `forms` table instead of `party_form` from the `parties` table. Do join `forms` with `party_forms` on `form_id` instead of querying only the `parties` table. Do group by `form_id` instead of `party_form`. Do order by `count(*)` descending instead of the alias `count`. The amended query now correctly identifies the most common party form by joining the forms reference table with party associations and counting occurrences per form_id.",
            "Do group by `t2.form_id` instead of `f.form_id, f.form_name` to ensure correct aggregation behavior. Do reference `forms AS t1` and `party_forms AS t2` instead of `Forms f` and `Party_Forms pf` for consistent table aliasing. Do use `t1.form_id = t2.form_id` instead of `f.form_id = pf.form_id` for the join condition to maintain proper table reference alignment. The amended query now correctly groups by the joined table's form_id and matches the intended behavior of the right SQL."
        ],
        "rules": [
            "1) When answering about \"most common party form\": select \"form_name\" from the \"forms\" table instead of \"party_form\" from the \"parties\" table. 2) When combining tables for party form analysis: join \"forms\" with \"party_forms\" on \"form_id\" to link form definitions with party associations. 3) When counting occurrences of party forms: group by \"form_id\" instead of \"party_form\" to count distinct form instances. 4) When ordering by frequency: order by the count of rows in descending order to find the most common form. 5) When identifying the most common item: limit to the top 1 result after ordering by count descending.",
            "1) When combining tables \"forms\" as T1 and \"party_forms\" as T2: link rows where T1.form_id = T2.form_id exactly and keep only matching pairs (inner match). 2) When counting party forms per form type: group by T2.form_id to ensure correct aggregation behavior. 3) When answering about \"most common party form\": rank forms by count of party forms in descending order and keep only the top 1 row. 4) When producing output: return only the form_name column from T1."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT party_form, COUNT(*) as count FROM parties GROUP BY party_form ORDER BY count DESC LIMIT 1;",
            "SELECT f.form_name\nFROM Forms f\nJOIN Party_Forms pf ON f.form_id = pf.form_id\nGROUP BY f.form_id, f.form_name\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT t1.form_name\nFROM Forms AS t1\nJOIN Party_Forms AS t2 ON t1.form_id = t2.form_id\nGROUP BY t2.form_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT f.form_name\nFROM Forms f\nJOIN Party_Forms pf ON f.form_id = pf.form_id\nGROUP BY f.form_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "1784": {
        "db_id": "small_bank_1",
        "question": "How many accounts have a savings balance above the average savings balance?",
        "ground_truth": "SELECT count(*) FROM savings WHERE balance  >  (SELECT avg(balance) FROM savings)",
        "amends": [
            "Do reference the `savings` table instead of `accounts` in both the main query and subquery. Do use the `balance` column instead of `savings_balance` for the comparison. Do remove the `WHERE savings_balance > 0` filter from the subquery instead of keeping it, as the right SQL calculates the average of all balances without filtering out zero values. The amended query now correctly counts records in the savings table where the balance exceeds the overall average balance from the same table."
        ],
        "rules": [
            "1) When answering about \"accounts with savings balance above average\": use the \"savings\" table instead of \"accounts\" table. 2) When comparing balance values: use the \"balance\" column instead of \"savings_balance\" column. 3) When calculating the average savings balance: compute the average of all balance values without filtering out zero values (remove any WHERE balance > 0 condition). 4) When counting accounts above average: count records from the savings table where balance exceeds the overall average balance from the same table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM accounts WHERE savings_balance > (SELECT AVG(savings_balance) FROM accounts WHERE savings_balance > 0);",
            "SELECT COUNT(*) FROM SAVINGS WHERE balance > (SELECT AVG(balance) FROM SAVINGS)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM SAVINGS \nWHERE balance > (SELECT AVG(balance) FROM SAVINGS)"
        ]
    },
    "2553": {
        "db_id": "county_public_safety",
        "question": "What are the white percentages of cities, and the corresponding crime rates of the counties they correspond to?",
        "ground_truth": "SELECT T1.White ,  T2.Crime_rate FROM city AS T1 JOIN county_public_safety AS T2 ON T1.County_ID  =  T2.County_ID",
        "amends": [
            "Do use column names `White` and `Crime_rate` instead of `white_percentage` and `crime_rate`. Do reference table `county_public_safety` instead of `counties`. Do use join condition `T1.County_ID = T2.County_ID` instead of `city.county_id = county.id`. Do remove the `WHERE city.white_percentage > 50` filter instead of keeping it. Do remove the `ORDER BY county.crime_rate DESC` clause instead of including it. The amended query now correctly joins city data with county public safety information using the appropriate County_ID relationship without unnecessary filtering or sorting."
        ],
        "rules": [
            "1) When the question asks for white percentages of cities: use column \"White\" from table \"city\" (T1) instead of \"white_percentage\". 2) When the question asks for crime rates of counties: use column \"Crime_rate\" from table \"county_public_safety\" (T2) instead of \"crime_rate\". 3) When combining city and county public safety data: link rows where T1.County_ID = T2.County_ID instead of city.county_id = county.id. 4) When the question does not specify filtering by white percentage: do not include any WHERE clause filtering on \"White\" values. 5) When the question does not specify ordering by crime rate: do not include any ORDER BY clause for \"Crime_rate\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city.white_percentage, county.crime_rate FROM cities city JOIN counties county ON city.county_id = county.id WHERE city.white_percentage > 50 ORDER BY county.crime_rate DESC;",
            "SELECT city.White, county_public_safety.Crime_rate \nFROM city \nJOIN county_public_safety ON city.County_ID = county_public_safety.County_ID"
        ],
        "rule_sql": [
            "SELECT c.White, cps.Crime_rate FROM city c JOIN county_public_safety cps ON c.County_ID = cps.County_ID"
        ]
    },
    "6704": {
        "db_id": "driving_school",
        "question": "How long is the total lesson time taught by staff with first name as Janessa and last name as Sawayn?",
        "ground_truth": "SELECT sum(lesson_time) FROM Lessons AS T1 JOIN Staff AS T2 ON T1.staff_id = T2.staff_id WHERE T2.first_name = \"Janessa\" AND T2.last_name = \"Sawayn\";",
        "amends": [
            "Do use `sum(lesson_time)` instead of `SUM(lesson_duration)` for the aggregate expression. Do reference `T2.first_name` and `T2.last_name` with table aliases instead of unqualified column names. Do use double quotes around string literals instead of single quotes. Do specify table aliases `AS T1` and `AS T2` instead of omitting them. The amended query now correctly calculates the total lesson time for the specified staff member using the appropriate column name and proper table qualification."
        ],
        "rules": [
            "1) When calculating total lesson time: use sum(lesson_time) instead of sum(lesson_duration) for the aggregate expression. 2) When referencing staff name columns: use T2.first_name and T2.last_name with table aliases instead of unqualified column names. 3) When using string literals for names: use double quotes around \"Janessa\" and \"Sawayn\" instead of single quotes. 4) When specifying table aliases: use AS T1 for lessons table and AS T2 for staff table instead of omitting them."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(lesson_duration) FROM staff JOIN lessons ON staff.staff_id = lessons.staff_id WHERE first_name = 'Janessa' AND last_name = 'Sawayn';",
            "SELECT SUM(lesson_time) AS total_lesson_time\nFROM Lessons AS T1\nJOIN Staff AS T2 ON T1.staff_id = T2.staff_id\nWHERE T2.first_name = \"Janessa\" AND T2.last_name = \"Sawayn\";"
        ],
        "rule_sql": [
            "SELECT SUM(T1.lesson_time) AS total_lesson_time\nFROM Lessons AS T1\nJOIN Staff AS T2 ON T1.staff_id = T2.staff_id\nWHERE T2.first_name = \"Janessa\" AND T2.last_name = \"Sawayn\";"
        ]
    },
    "5549": {
        "db_id": "products_gen_characteristics",
        "question": "What are the product ids and color descriptions for products with two or more characteristics?",
        "ground_truth": "SELECT t1.product_id ,  t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code JOIN product_characteristics AS t3 ON t1.product_id  =  t3.product_id GROUP BY t1.product_id HAVING count(*)  >=  2",
        "amends": [
            "Do add `t2.color_description` from `ref_colors` table instead of selecting `color_description` directly from `products`. Do add `JOIN ref_colors AS t2 ON t1.color_code = t2.color_code` to properly reference color descriptions instead of assuming they exist in the products table. Do add `JOIN product_characteristics AS t3 ON t1.product_id = t3.product_id` to access the characteristics data instead of using a non-existent `characteristics` column. Do change the filter to `GROUP BY t1.product_id HAVING count(*) >= 2` instead of `WHERE characteristics >= 2` to count actual characteristic records rather than comparing a non-existent column. Do add proper table aliasing with `products AS t1` instead of directly referencing columns without source specification. The amended query now correctly joins multiple tables and uses aggregate counting to identify products with at least two characteristics, matching the intended behavior."
        ],
        "rules": [
            "1) When selecting color descriptions for products: use \"t2.color_description\" from the \"ref_colors\" table instead of selecting directly from \"products\". 2) When combining products and color information: link rows where \"t1.color_code = t2.color_code\" to properly reference color descriptions. 3) When accessing product characteristics data: join with \"product_characteristics AS t3 ON t1.product_id = t3.product_id\" instead of using a non-existent \"characteristics\" column. 4) When identifying products with two or more characteristics: group by \"t1.product_id\" and filter with \"count(*) >= 2\" to count actual characteristic records. 5) When referencing table columns: always use proper table aliasing with \"products AS t1\" instead of direct column references without source specification."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT product_id, color_description FROM products WHERE characteristics >= 2;",
            "SELECT t1.product_id, t2.color_description\nFROM products AS t1\nJOIN ref_colors AS t2 ON t1.color_code = t2.color_code\nJOIN product_characteristics AS t3 ON t1.product_id = t3.product_id\nGROUP BY t1.product_id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT t1.product_id, t2.color_description\nFROM Products AS t1\nJOIN Ref_Colors AS t2 ON t1.color_code = t2.color_code\nJOIN Product_Characteristics AS t3 ON t1.product_id = t3.product_id\nGROUP BY t1.product_id, t2.color_description\nHAVING COUNT(*) >= 2"
        ]
    },
    "2207": {
        "db_id": "formula_1",
        "question": "What are the drivers' first, last names and id who had more than 8 pit stops or participated in more than 5 race results?",
        "ground_truth": "SELECT T1.forename ,  T1.surname ,  T1.driverid FROM drivers AS T1 JOIN pitstops AS T2 ON T1.driverid  =  T2.driverid GROUP BY T1.driverid HAVING count(*)  >  8 UNION SELECT T1.forename ,  T1.surname ,  T1.driverid FROM drivers AS T1 JOIN results AS T2 ON T1.driverid  =  T2.driverid GROUP BY T1.driverid HAVING count(*)  >  5",
        "amends": [
            "Do use `JOIN` with `GROUP BY` and `HAVING` instead of `WHERE IN` subqueries. Do change column names from `first_name` to `forename` and `last_name` to `surname` instead of the original names. Do use `UNION` to combine results instead of `OR` conditions. Do reference table `pitstops` instead of `pit_stops` and `results` instead of `race_results`. Do remove the redundant `d.id` selection since it's already included in the grouping. The amended query now correctly uses joins with aggregation and union to find drivers meeting either condition, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about drivers with more than 8 pit stops or more than 5 race results: use UNION to combine results from both conditions instead of OR conditions. 2) When selecting driver names: use \"forename\" instead of \"first_name\" and \"surname\" instead of \"last_name\" from table \"drivers\". 3) When counting pit stops: reference table \"pitstops\" instead of \"pit_stops\" and count using the driver_id grouping. 4) When counting race results: reference table \"results\" instead of \"race_results\" and count using the driver_id grouping. 5) When grouping and aggregating: use JOIN with GROUP BY and HAVING instead of WHERE IN subqueries. 6) When selecting output columns: include driver id only once since it's already included in the grouping structure."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT d.first_name, d.last_name, d.id \nFROM drivers d\nWHERE d.id IN (\n    SELECT ps.driver_id \n    FROM pit_stops ps \n    GROUP BY ps.driver_id \n    HAVING COUNT(*) > 8\n) \nOR d.id IN (\n    SELECT rr.driver_id \n    FROM race_results rr \n    GROUP BY rr.driver_id \n    HAVING COUNT(*) > 5\n)",
            "SELECT d.forename, d.surname, d.driverId\nFROM drivers d\nJOIN (\n    SELECT driverId\n    FROM pitStops\n    GROUP BY driverId\n    HAVING COUNT(*) > 8\n    \n    UNION\n    \n    SELECT driverId\n    FROM results\n    GROUP BY driverId\n    HAVING COUNT(*) > 5\n) sub ON d.driverId = sub.driverId\nGROUP BY d.driverId, d.forename, d.surname"
        ],
        "rule_sql": [
            "SELECT d.driverId, d.forename, d.surname\nFROM drivers d\nJOIN (\n    SELECT driverId\n    FROM pitStops\n    GROUP BY driverId\n    HAVING COUNT(*) > 8\n    \n    UNION\n    \n    SELECT driverId\n    FROM results\n    GROUP BY driverId\n    HAVING COUNT(*) > 5\n) combined ON d.driverId = combined.driverId\nORDER BY d.driverId;"
        ]
    },
    "2942": {
        "db_id": "sakila_1",
        "question": "Which countries have at least 3 cities?",
        "ground_truth": "SELECT T2.country FROM city AS T1 JOIN country AS T2 ON T1.country_id  =  T2.country_id GROUP BY T2.country_id HAVING count(*)  >=  3",
        "amends": [
            "Do join `country AS T2` instead of querying `cities` alone, and do reference `T2.country` instead of just `country`. Do add the join condition `ON T1.country_id = T2.country_id` instead of missing the table relationship. Do group by `T2.country_id` instead of `country` to ensure proper aggregation. The amended query now correctly retrieves countries from the country table while counting cities through the proper join relationship, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"countries with at least 3 cities\": make sure to join table \"country\" as T2 instead of querying \"cities\" alone. 2) When combining tables for shared entities: link rows where T1.country_id = T2.country_id and keep only matching pairs (inner match). 3) When the question asks for \"countries\": use T2.country instead of just country. 4) When grouping by country: group by T2.country_id instead of country to ensure proper aggregation. 5) When counting cities per country: count using the canonical key relationship T1.country_id = T2.country_id and require at least 3 cities."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM cities GROUP BY country HAVING COUNT(*) >= 3;",
            "SELECT T2.country\nFROM city AS T1\nJOIN country AS T2 ON T1.country_id = T2.country_id\nGROUP BY T2.country_id\nHAVING COUNT(*) >= 3"
        ],
        "rule_sql": [
            "SELECT T2.country\nFROM city AS T1\nINNER JOIN country AS T2 ON T1.country_id = T2.country_id\nGROUP BY T2.country_id\nHAVING COUNT(*) >= 3"
        ]
    },
    "6841": {
        "db_id": "flight_4",
        "question": "Which countries has the most number of airlines?",
        "ground_truth": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do remove `COUNT(*)` from the SELECT list instead of including it, as the query only needs to return the country with the highest count rather than both the country and its count value. The amended query now correctly returns just the country field while maintaining the same grouping, ordering, and limiting logic to identify the country with the most airlines."
        ],
        "rules": [
            "1) When answering about \"which countries has the most number of airlines\": make sure the output order: country only without the count value. 2) When the question asks for \"most number of airlines\": rank countries by count of airlines in descending order and keep the first 1 row. 3) When the question asks for \"count of airlines\": compute the number of rows using the canonical key for airlines entities. 4) When producing output for this question: do not include the count value in the final result columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country, COUNT(*) FROM airlines GROUP BY country ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT country FROM airlines GROUP BY country ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT country FROM airlines GROUP BY country ORDER BY COUNT(alid) DESC LIMIT 1;"
        ]
    },
    "4849": {
        "db_id": "local_govt_and_lot",
        "question": "What is each customer's move in date, and the corresponding customer id and details?",
        "ground_truth": "SELECT T2.date_moved_in ,  T1.customer_id ,  T1.customer_details FROM Customers AS T1 JOIN Customer_Events AS T2 ON T1.customer_id  =  T2.customer_id",
        "amends": [
            "Do select `T2.date_moved_in`, `T1.customer_id`, and `T1.customer_details` instead of `customer_id`, `move_in_date`, and `details`. Do use `FROM Customers AS T1 JOIN Customer_Events AS T2` instead of `FROM customers`. Do add `ON T1.customer_id = T2.customer_id` join condition instead of omitting it. Do remove `ORDER BY customer_id` instead of keeping it. The amended query now correctly joins the Customers and Customer_Events tables to retrieve the appropriate customer movement data."
        ],
        "rules": [
            "1) When answering about \"each customer's move in date, and the corresponding customer id and details\": make sure the output order: T2.date_moved_in, T1.customer_id, T1.customer_details. 2) When the question mentions \"move in date\": \"move in date\" actually means \"date_moved_in in Customer_Events table\". 3) When the question mentions \"details\": \"details\" actually means \"customer_details in Customers table\". 4) When combining Customers and Customer_Events tables: link rows where T1.customer_id = T2.customer_id exactly as shown; keep only matching pairs (inner match). 5) When the question asks for \"each customer's\" information: do not apply ordering unless explicitly requested."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT customer_id, move_in_date, details FROM customers ORDER BY customer_id;",
            "SELECT T2.date_moved_in, T1.customer_id, T1.customer_details FROM Customers AS T1 JOIN Customer_Events AS T2 ON T1.customer_id = T2.customer_id"
        ],
        "rule_sql": [
            "SELECT T2.date_moved_in, T1.customer_id, T1.customer_details\nFROM Customers T1\nINNER JOIN Customer_Events T2 ON T1.customer_id = T2.customer_id"
        ]
    },
    "745": {
        "db_id": "customers_card_transactions",
        "question": "Show the account id and the number of transactions for each account",
        "ground_truth": "SELECT account_id ,  count(*) FROM Financial_transactions GROUP BY account_id",
        "amends": [
            "Do reference the `Financial_transactions` table instead of the generic `transactions` table. Do maintain the same `SELECT account_id, COUNT(*)` structure and `GROUP BY account_id` clause without changes. The amended query now correctly references the specific financial transactions table while preserving the same aggregation logic to count transactions per account."
        ],
        "rules": [
            "1) When answering about \"account id and number of transactions for each account\": make sure the output order: account_id, then count of transactions. 2) When the question mentions \"transactions\": \"transactions\" actually means \"Financial_transactions\" in schema. 3) When the question asks for \"number of transactions per account\": organize results by account_id and compute the count of transactions using the canonical key for transactions. 4) When counting transactions: count all rows in the Financial_transactions table for each account_id group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT account_id, COUNT(*) FROM transactions GROUP BY account_id;",
            "SELECT account_id, COUNT(*) FROM Financial_Transactions GROUP BY account_id"
        ],
        "rule_sql": [
            "SELECT account_id, COUNT(*) AS transaction_count FROM Financial_Transactions GROUP BY account_id ORDER BY account_id, transaction_count;"
        ]
    },
    "4935": {
        "db_id": "store_product",
        "question": "What are all of the products whose name includes the substring \"Scanner\"?",
        "ground_truth": "SELECT product FROM product WHERE product LIKE \"%Scanner%\"",
        "amends": [
            "Do reference the `product` column instead of `*` in the SELECT list. Do use the correct table name `product` instead of `products` in the FROM clause. Do use double quotes for the string pattern instead of single quotes in the WHERE filter. The amended query now correctly selects only the product column from the product table with the appropriate pattern matching."
        ],
        "rules": [
            "1) When selecting from the product table: use the exact table name \"product\" not \"products\". 2) When the question asks for products whose name includes \"Scanner\": use the pattern \"%Scanner%\" with double quotes for the string literal. 3) When outputting results: select only the \"product\" column instead of all columns (*)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM products WHERE name LIKE '%Scanner%';",
            "SELECT \"product\" FROM \"product\" WHERE \"product\" LIKE \"%Scanner%\""
        ],
        "rule_sql": [
            "SELECT product FROM product WHERE product LIKE \"%Scanner%\";"
        ]
    },
    "108": {
        "db_id": "student_assessment",
        "question": "What are the ids of the students who attended courses in the statistics department in order of attendance date.",
        "ground_truth": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = \"statistics\" ORDER BY T2.date_of_attendance",
        "amends": [
            "Do use table alias `T2` for `student_id` instead of no alias. Do change FROM source to `courses AS T1 JOIN student_course_attendance AS T2` instead of `attendance JOIN courses`. Do use join condition `T1.course_id = T2.course_id` instead of `attendance.course_id = courses.course_id`. Do change WHERE filter to `T1.course_name = \"statistics\"` instead of `department = 'statistics'`. Do change ORDER BY to `T2.date_of_attendance` instead of `attendance_date`. The amended query now correctly joins the appropriate tables and filters by course name rather than department."
        ],
        "rules": [
            "1) When answering about \"students who attended courses in the statistics department\": use table alias T2 for student_id from student_course_attendance table. 2) When combining courses and student_course_attendance tables: link rows where T1.course_id = T2.course_id and keep only matching pairs (inner match). 3) When filtering for statistics department courses: use T1.course_name = \"statistics\" instead of department column. 4) When ordering by attendance date: use T2.date_of_attendance instead of attendance_date column. 5) When selecting student identifiers: output student_id from T2 table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id FROM attendance JOIN courses ON attendance.course_id = courses.course_id WHERE department = 'statistics' ORDER BY attendance_date",
            "SELECT T2.student_id\nFROM courses AS T1\nJOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id\nWHERE T1.course_name = 'statistics'\nORDER BY T2.date_of_attendance"
        ],
        "rule_sql": [
            "SELECT T2.student_id\nFROM Courses T1\nINNER JOIN Student_Course_Attendance T2 ON T1.course_id = T2.course_id\nWHERE T1.course_name = 'statistics'\nORDER BY T2.date_of_attendance"
        ]
    },
    "6000": {
        "db_id": "game_1",
        "question": "How many different types of sports do we offer?",
        "ground_truth": "SELECT count(DISTINCT sportname) FROM Sportsinfo",
        "amends": [
            "Do select `count(DISTINCT sportname)` instead of `COUNT(*)` to count distinct sport names rather than all rows. Do query from `Sportsinfo` table instead of `sports` table to access the correct data source. The amended query now correctly counts distinct sport names from the appropriate table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"different types of sports\": make sure the output order: count of distinct sport names. 2) When the question mentions \"different types of sports\": \"different types\" actually means \"distinct sportname in schema\". 3) When counting distinct sport names: compute the number of unique values of the exact token \"sportname\". 4) When accessing sports data: use the \"Sportsinfo\" table instead of any other table to access the correct data source."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM sports;",
            "SELECT COUNT(DISTINCT SportName) FROM SportsInfo"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT SportName) FROM SportsInfo;"
        ]
    },
    "3586": {
        "db_id": "music_1",
        "question": "What are the languages that are used most often in songs?",
        "ground_truth": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use `languages` as the column name instead of `language` and change the table name to `song` instead of `songs`. Do remove the alias `song_count` and instead use the aggregate function `count(*)` directly in the ORDER BY clause instead of referencing an alias. Do change the LIMIT to `1` instead of `10` to return only the top result instead of the top 10. The amended query now correctly identifies the most frequent language from the song table by counting occurrences and returning the single highest count.",
            "Do select only `languages` instead of including `COUNT(*)` in the SELECT list. Do keep the `GROUP BY languages` clause instead of changing it. Do maintain the `ORDER BY count(*) DESC` instead of altering the ordering. Do preserve the `LIMIT 1` instead of modifying the limit clause. The amended query now correctly returns only the language with the highest count instead of returning both the language and its count value."
        ],
        "rules": [
            "1) When answering about \"languages used most often in songs\": use the exact column name \"languages\" from table \"song\" instead of \"language\". 2) When counting occurrences of languages: count all rows using count(*) and group by the \"languages\" column. 3) When ranking languages by frequency: order the results by count(*) in descending order to find the most frequent. 4) When the question asks for the \"most often\" used language: return only the top 1 result using LIMIT 1 instead of LIMIT 10. 5) When ordering by aggregate results: use count(*) directly in the ORDER BY clause instead of referencing an alias.",
            "1) When answering about \"languages used most often in songs\": make sure the output order: only include the \"languages\" column without any count values. 2) When the question asks for \"most often\": rank rows by count of songs per language in descending order and keep only the first 1 row. 3) When grouping by languages: organize results by the exact token \"languages\" and compute the count of songs per group using the canonical grouping key. 4) When handling text literals: do not change case, spacing, or punctuation of language values like 'bangla' and 'english'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT language, COUNT(*) as song_count FROM songs GROUP BY language ORDER BY song_count DESC LIMIT 10;",
            "SELECT languages, COUNT(*) FROM song GROUP BY languages ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT languages FROM song GROUP BY languages ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT languages FROM song GROUP BY languages ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "1660": {
        "db_id": "theme_gallery",
        "question": "Return the average and minimum ages across artists from the United States.",
        "ground_truth": "SELECT avg(age) ,  min(age) FROM artist WHERE country  =  'United States'",
        "amends": [
            "Do use `avg(age)` and `min(age)` without aliases instead of `AVG(age) as average_age` and incorrectly using `MAX(age) as minimum_age`. Do reference table `artist` instead of `artists`. Do maintain the same `WHERE country = 'United States'` filter without changes. The amended query now correctly calculates the minimum age instead of incorrectly labeling a maximum calculation as minimum, and matches the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"average and minimum ages across artists from the United States\": make sure the output order: avg(age), min(age). 2) When the question mentions \"artists\": \"artists\" actually means \"artist\" in schema. 3) When the question mentions \"United States\": use the exact literal 'United States' with the exact case and spacing. 4) When calculating minimum age: use min(age) function, not max(age) incorrectly labeled as minimum_age."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age) as average_age, MAX(age) as minimum_age FROM artists WHERE country = 'United States';",
            "SELECT avg(Age), min(Age) FROM artist WHERE Country = 'United States'"
        ],
        "rule_sql": [
            "SELECT AVG(Age) AS \"avg(age)\", MIN(Age) AS \"min(age)\" FROM artist WHERE Country = 'United States';"
        ]
    },
    "213": {
        "db_id": "book_2",
        "question": "How many books are there?",
        "ground_truth": "SELECT count(*) FROM book",
        "amends": [
            "Do query the `book` table instead of the `authors` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the book table rather than the authors table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"how many books\": make sure to query the \"book\" table instead of the \"authors\" table. 2) When counting entities: use lowercase \"count(*)\" for consistency with the schema requirements."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM authors;",
            "SELECT count(*) FROM book;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM book;"
        ]
    },
    "5635": {
        "db_id": "railway",
        "question": "What is the maximum level of managers in countries that are not \"Australia\"?",
        "ground_truth": "SELECT max(LEVEL) FROM manager WHERE Country != \"Australia\t\"",
        "amends": [
            "Do reference table `manager` instead of `managers`. Do use inequality filter `Country != \"Australia\"` instead of equality filter `country = 'Australia'`. Do use consistent case for `max(LEVEL)` instead of `MAX(level)`. The amended query now correctly filters for non-Australian records from the appropriate table with proper case handling.",
            "Do use lowercase `max` function instead of uppercase `MAX` to maintain consistent function naming. Do include the tab character in the string literal `\"Australia\\t\"` instead of `\"Australia\"` to properly match the exact country value with trailing whitespace. The amended query now correctly handles the case sensitivity of the aggregate function and matches the exact string comparison including whitespace characters."
        ],
        "rules": [
            "1) When referencing the table for managers: use the exact table name \"manager\" instead of \"managers\". 2) When filtering for countries that are not Australia: use the exact condition Country != \"Australia\" with double quotes around the literal value. 3) When computing the maximum level: use the exact column name \"LEVEL\" with proper case handling instead of \"level\". 4) When the question asks for maximum level in countries excluding Australia: apply the inequality filter to exclude records where Country equals \"Australia\" exactly.",
            "1) When using aggregate functions: use lowercase function names like \"max\" instead of uppercase \"MAX\" to maintain consistent function naming. 2) When comparing string literals with \"Australia\": use the exact literal \"Australia\\t\" including the tab character instead of just \"Australia\" to properly match the exact country value with trailing whitespace."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(level) FROM managers WHERE country = 'Australia';",
            "SELECT MAX(Level) FROM manager WHERE Country != \"Australia\";",
            "SELECT max(Level) FROM manager WHERE Country != \"Australia\\t\""
        ],
        "rule_sql": [
            "SELECT max(LEVEL) FROM manager WHERE Country != \"Australia\\t\""
        ]
    },
    "3448": {
        "db_id": "hr_1",
        "question": "What are the employee ids for each employee and final dates of employment at their last job?",
        "ground_truth": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id",
        "amends": [
            "Do reference the `job_history` table instead of the `employees` table in the FROM clause, as the end_date column appears to belong to job history records rather than employee master data. The amended query now correctly aggregates maximum end dates from job history records grouped by employee_id, matching the intended behavior of the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for employee ids and final dates of employment at their last job: use the \"job_history\" table instead of the \"employees\" table because end_date belongs to job history records. 2) When computing the last employment date for each employee: find the maximum end_date from job history records grouped by employee_id. 3) When organizing results by employee: group by employee_id to get one result row per employee with their maximum end_date."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT employee_id, MAX(end_date) FROM employees GROUP BY employee_id;",
            "SELECT EMPLOYEE_ID, MAX(END_DATE) AS FINAL_END_DATE FROM job_history GROUP BY EMPLOYEE_ID"
        ],
        "rule_sql": [
            "SELECT EMPLOYEE_ID, MAX(END_DATE) AS FINAL_EMPLOYMENT_DATE FROM job_history GROUP BY EMPLOYEE_ID"
        ]
    },
    "3301": {
        "db_id": "college_1",
        "question": "Find the first name and gpa of the students whose gpa is lower than the average gpa of all students.",
        "ground_truth": "SELECT stu_fname ,  stu_gpa FROM student WHERE stu_gpa  <  (SELECT avg(stu_gpa) FROM student)",
        "amends": [
            "Do use column names `stu_fname` and `stu_gpa` instead of `first_name` and `gpa`. Do reference table `student` instead of `students`. Do use comparison operator `<` instead of `>` in the WHERE filter. Do use aggregate function `avg(stu_gpa)` instead of `AVG(gpa)` in the subquery. The amended query now correctly selects students with below-average GPAs instead of above-average ones, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"first name\": use the exact column name \"stu_fname\" from the student table. 2) When the question asks for \"gpa\": use the exact column name \"stu_gpa\" from the student table. 3) When the question refers to the table containing student information: use the exact table name \"student\" instead of \"students\". 4) When filtering for students with GPA lower than average: use the comparison operator \"<\" (less than) instead of \">\" (greater than). 5) When calculating the average GPA: use the aggregate function \"avg(stu_gpa)\" on the exact column name \"stu_gpa\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, gpa FROM students WHERE gpa > (SELECT AVG(gpa) FROM students);",
            "SELECT stu_fname, stu_gpa FROM student WHERE stu_gpa < (SELECT AVG(stu_gpa) FROM student)"
        ],
        "rule_sql": [
            "SELECT stu_fname, stu_gpa FROM student WHERE stu_gpa < (SELECT AVG(stu_gpa) FROM student)"
        ]
    },
    "1608": {
        "db_id": "customers_and_invoices",
        "question": "How many invoices correspond to each order id?",
        "ground_truth": "SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id",
        "amends": [
            "Do group by `order_id` instead of `invoice_id` to correctly aggregate counts by order rather than by invoice. Do reference the table as `Invoices` instead of `invoices` to match the correct case sensitivity. The amended query now matches RIGHT_SQL's behavior by properly counting records per order_id."
        ],
        "rules": [
            "1) When the question asks for counts per order_id: group the results by the exact column token \"order_id\" from the Invoices table. 2) When counting invoices per order: use the canonical counting key \"order_id\" to count the number of invoices for each order. 3) When referencing the Invoices table: use the exact table name \"Invoices\" with proper case sensitivity as shown in the schema. 4) When the question asks \"how many invoices correspond to each order id\": make sure the output order shows order_id first followed by the count of invoices."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT order_id, COUNT(*) FROM invoices GROUP BY invoice_id;",
            "SELECT order_id, COUNT(*) AS invoice_count FROM Invoices GROUP BY order_id;"
        ],
        "rule_sql": [
            "SELECT order_id, COUNT(*) AS invoice_count FROM Invoices GROUP BY order_id ORDER BY order_id;"
        ]
    },
    "3403": {
        "db_id": "manufacturer",
        "question": "Find the market shares and names of furnitures which no any company is producing in our records.",
        "ground_truth": "SELECT Market_Rate ,  name FROM furniture WHERE Furniture_ID NOT IN (SELECT Furniture_ID FROM furniture_manufacte)",
        "amends": [
            "Do select `Market_Rate` and `name` instead of `name` and `market_share`. Do change the WHERE clause to use `Furniture_ID NOT IN` with a subquery selecting `Furniture_ID` from `furniture_manufacte` instead of filtering on `company_id IS NULL`. Do add a correlated subquery to check for non-existent furniture IDs in the manufacturing table instead of checking for null company IDs. The amended query now correctly identifies furniture items that haven't been manufactured rather than those missing company IDs, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"market shares and names\": select \"Market_Rate\" and \"name\" columns from the furniture table. 2) When identifying furniture not produced by any company: use \"Furniture_ID NOT IN\" with a subquery selecting \"Furniture_ID\" from the \"furniture_manufacte\" table instead of checking for null company IDs. 3) When combining furniture and manufacturing data: use the foreign key relationship where \"furniture_manufacte\".\"Furniture_ID\" references \"furniture\".\"Furniture_ID\" to identify unmatched furniture items."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, market_share FROM furniture WHERE company_id IS NULL;",
            "SELECT Market_Rate, Name FROM furniture WHERE Furniture_ID NOT IN (SELECT Furniture_ID FROM furniture_manufacte)"
        ],
        "rule_sql": [
            "SELECT \"Market_Rate\", \"Name\" FROM furniture WHERE \"Furniture_ID\" NOT IN (SELECT \"Furniture_ID\" FROM furniture_manufacte)"
        ]
    },
    "4046": {
        "db_id": "student_1",
        "question": "Find the last names of the teachers that teach fifth grade.",
        "ground_truth": "SELECT DISTINCT T2.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE grade  =  5",
        "amends": [
            "Do use `DISTINCT T2.lastname` instead of `last_name` to select unique teacher last names. Do join `list AS T1` with `teachers AS T2` on `T1.classroom = T2.classroom` instead of querying only the teachers table. Do filter on `grade = 5` using numeric comparison instead of string comparison with `'fifth'`. The amended query now correctly identifies teachers who teach fifth grade classes by joining with class lists and using proper numeric grade filtering, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"teachers that teach fifth grade\": join list AS T1 with teachers AS T2 on T1.classroom = T2.classroom to identify which teachers teach which classes. 2) When filtering for fifth grade: use numeric comparison grade = 5 instead of string comparison with 'fifth'. 3) When selecting teacher last names: use DISTINCT T2.lastname to get unique teacher last names instead of last_name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM teachers WHERE grade = 'fifth'",
            "SELECT DISTINCT T2.LastName FROM list AS T1 JOIN teachers AS T2 ON T1.Classroom = T2.Classroom WHERE T1.Grade = 5"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.LastName FROM list AS T1 JOIN teachers AS T2 ON T1.Classroom = T2.Classroom WHERE T1.Grade = 5"
        ]
    },
    "1101": {
        "db_id": "match_season",
        "question": "What are the names of all colleges that have two or more players?",
        "ground_truth": "SELECT College FROM match_season GROUP BY College HAVING count(*)  >=  2",
        "amends": [
            "Do select `College` instead of `name` and use `GROUP BY College` with `HAVING count(*) >= 2` instead of filtering `player_count >= 2` in the `WHERE` clause. Do source from `match_season` table instead of `colleges` table. The amended query now correctly groups by college and counts occurrences per group rather than relying on a pre-aggregated player_count column, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"colleges that have two or more players\": select \"College\" from the \"match_season\" table. 2) When counting players per college: group by \"College\" and count occurrences using count(*). 3) When filtering for colleges with two or more players: use HAVING count(*) >= 2 instead of WHERE clause filtering. 4) When the question asks for \"names of colleges\": the output column should be exactly \"College\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM colleges WHERE player_count >= 2;",
            "SELECT College FROM match_season GROUP BY College HAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT College FROM match_season GROUP BY College HAVING COUNT(*) >= 2"
        ]
    },
    "5624": {
        "db_id": "swimming",
        "question": "Find the name of the swimmer who has at least 2 records.",
        "ground_truth": "SELECT t1.name FROM swimmer AS t1 JOIN record AS t2 ON t1.id  =  t2.swimmer_id GROUP BY t2.swimmer_id HAVING count(*)  >=  2",
        "amends": [
            "Do specify the table alias `t1.name` instead of just `name`. Do join the `record` table as `t2` with `ON t1.id = t2.swimmer_id` instead of omitting the join entirely. Do use `GROUP BY t2.swimmer_id` instead of grouping by nothing. Do move the count condition to `HAVING count(*) >= 2` instead of placing it in the `WHERE` clause where aggregate functions cannot be used. The amended query now correctly counts records per swimmer and filters those with at least two records, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"swimmer who has at least 2 records\": make sure the output order: t1.name 2) When the question mentions \"swimmer\": \"swimmer\" actually means \"t1.id in schema\" 3) When the question mentions \"records\": \"records\" actually means \"t2.swimmer_id in schema\" 4) When combining swimmers table as T1 and record table as T2 for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (t1.id = t2.swimmer_id); keep only matching pairs (inner match). 5) When the question asks for \"count of records\": compute the number of rows using the canonical key token for records (t2.swimmer_id). 6) When the question asks for \"at least 2 records\": filter groups where count of records is >= 2 using HAVING clause instead of WHERE clause. 7) When grouping by swimmer: organize results by t2.swimmer_id and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM swimmers WHERE COUNT(records) >= 2",
            "SELECT t1.name FROM swimmer t1 JOIN record t2 ON t1.ID = t2.Swimmer_ID GROUP BY t2.Swimmer_ID HAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT t1.name FROM swimmer t1 INNER JOIN record t2 ON t1.ID = t2.Swimmer_ID GROUP BY t2.Swimmer_ID HAVING COUNT(t2.Swimmer_ID) >= 2 ORDER BY t1.name"
        ]
    },
    "1937": {
        "db_id": "cinema",
        "question": "Find the distinct locations that has a cinema.",
        "ground_truth": "SELECT DISTINCT LOCATION FROM cinema",
        "amends": [
            "Do select `DISTINCT LOCATION` instead of `*` to return only unique location values rather than all columns. Do reference table `cinema` instead of `cinemas` to use the correct table name. Do remove the `WHERE location IS NOT NULL` filter instead of keeping it since the DISTINCT operation inherently excludes NULL values when selecting the specific column. The amended query now correctly returns distinct location values from the cinema table."
        ],
        "rules": [
            "1) When the question asks for \"distinct locations\": select only unique values of the exact column \"location\" from the table. 2) When referencing the table containing cinema information: use the exact table name \"cinema\" (not \"cinemas\"). 3) When selecting distinct values of a specific column: do not include a separate filter for NULL values since the distinct operation inherently excludes NULL values for that column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM cinemas WHERE location IS NOT NULL;",
            "SELECT DISTINCT Location FROM cinema;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Location FROM cinema;"
        ]
    },
    "5067": {
        "db_id": "device",
        "question": "What is the shop name corresponding to the shop that opened in the most recent year?",
        "ground_truth": "SELECT Shop_Name FROM shop ORDER BY Open_Year DESC LIMIT 1",
        "amends": [
            "Do reference table `shop` instead of `shops` and use column `Shop_Name` instead of `shop_name` in the SELECT list. Do use column `Open_Year` instead of `opening_year` in the ORDER BY clause instead of the previous column reference. The amended query now correctly references the actual table and column names to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for shop name: use the exact column token \"Shop_Name\" from table \"shop\". 2) When the question asks about the most recent opening year: use the exact column token \"Open_Year\" for ordering in descending direction. 3) When the question asks for the shop with the most recent opening year: take only the first row after ordering by \"Open_Year\" in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT shop_name FROM shops ORDER BY opening_year DESC LIMIT 1;",
            "SELECT Shop_Name FROM shop ORDER BY Open_Year DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Shop_Name FROM shop ORDER BY Open_Year DESC LIMIT 1;"
        ]
    },
    "2102": {
        "db_id": "cre_Doc_Control_Systems",
        "question": "What are the shipping agent names?",
        "ground_truth": "SELECT shipping_agent_name FROM Ref_Shipping_Agents;",
        "amends": [
            "Do select `shipping_agent_name` instead of `agent_name` and do source from `Ref_Shipping_Agents` instead of `shipping_agents`. Do remove the `WHERE agent_id IS NOT NULL` filter instead of keeping it, as the right query retrieves all records without filtering. The amended query now correctly selects the appropriate column from the proper table reference without unnecessary filtering, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"shipping agent names\": make sure the output order: shipping_agent_name. 2) When the question mentions \"shipping agent names\": \"shipping agent names\" actually means \"shipping_agent_name in table Ref_Shipping_Agents\". 3) When selecting from the shipping agents table: use table name Ref_Shipping_Agents instead of shipping_agents. 4) When retrieving all shipping agent records: do not apply any WHERE filter conditions as all records should be included."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT agent_name FROM shipping_agents WHERE agent_id IS NOT NULL",
            "SELECT shipping_agent_name FROM Ref_Shipping_Agents"
        ],
        "rule_sql": [
            "SELECT shipping_agent_name FROM Ref_Shipping_Agents ORDER BY shipping_agent_name;"
        ]
    },
    "6057": {
        "db_id": "customers_and_addresses",
        "question": "How many customers are there?",
        "ground_truth": "SELECT count(*) FROM customers",
        "amends": [
            "Do query the `customers` table instead of the `orders` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the customers table instead of the orders table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"how many customers\": query the \"customers\" table instead of the \"orders\" table. 2) When counting entities: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" for consistency."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders;",
            "SELECT count(*) FROM Customers;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM Customers;"
        ]
    },
    "1779": {
        "db_id": "small_bank_1",
        "question": "Count the number of accounts.",
        "ground_truth": "SELECT count(*) FROM accounts",
        "amends": [
            "Do reference the `accounts` table instead of the `customers` table in the FROM clause. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for the aggregate function. The amended query now correctly counts records from the accounts table using consistent lowercase syntax."
        ],
        "rules": [
            "1) When counting the number of accounts: use the \"accounts\" table instead of the \"customers\" table. 2) When performing aggregate counting: use lowercase \"count(*)\" syntax for consistency."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers;",
            "select count(*) from accounts"
        ],
        "rule_sql": [
            "SELECT count(*) FROM ACCOUNTS"
        ]
    },
    "2898": {
        "db_id": "icfp_1",
        "question": "What is the last name of the author that has published the most papers?",
        "ground_truth": "SELECT t1.lname FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid GROUP BY t1.fname ,  t1.lname ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `authorship` and `papers` tables with proper joins instead of querying only the `authors` table. Do use `JOIN authorship AS t2 ON t1.authid = t2.authid` and `JOIN papers AS t3 ON t2.paperid = t3.paperid` instead of missing these necessary table connections. Do add `GROUP BY t1.fname, t1.lname` instead of omitting the grouping clause required for the aggregate function. Do use `count(*)` instead of `COUNT(papers.id)` to count all papers rather than just non-null paper IDs. Do change the SELECT clause to `t1.lname` instead of `last_name` to match the table alias and column naming. The amended query now correctly joins the necessary tables to count papers per author and returns the author with the most publications, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"the author that has published the most papers\": make sure to join the authors table (T1) with authorship table (T2) using T1.authid = T2.authid, and then join with papers table (T3) using T2.paperid = T3.paperid. 2) When counting papers per author: use count(*) to count all papers rather than counting specific columns. 3) When grouping for aggregate counting: group by T1.fname and T1.lname to get counts per author. 4) When selecting the author's last name: use T1.lname instead of last_name to match the table alias and column naming. 5) When finding the author with the most papers: order by the paper count in descending order and take the first result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM authors ORDER BY COUNT(papers.id) DESC LIMIT 1;",
            "SELECT t1.lname\nFROM Authors AS t1\nJOIN Authorship AS t2 ON t1.authID = t2.authID\nJOIN Papers AS t3 ON t2.paperID = t3.paperID\nGROUP BY t1.authID, t1.lname\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT a.lname \nFROM Authors a\nJOIN Authorship au ON a.authID = au.authID\nJOIN Papers p ON au.paperID = p.paperID\nGROUP BY a.fname, a.lname\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "1915": {
        "db_id": "protein_institute",
        "question": "List the names of buildings with at least 200 feet of height and with at least 20 floors.",
        "ground_truth": "SELECT name FROM building WHERE height_feet  >=  200 AND floors  >=  20",
        "amends": [
            "Do reference table `building` instead of `buildings` in the FROM clause. Do use column `height_feet` instead of `height` in the WHERE condition. Do apply `AND` logical operator instead of `OR` between the height and floors conditions. The amended query now correctly filters for buildings that meet both height and floor requirements simultaneously, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"buildings\": use the exact table name \"building\" instead of \"buildings\". 2) When the question mentions \"height\": use the exact column name \"height_feet\" instead of \"height\". 3) When the question asks for buildings with \"at least 200 feet of height and with at least 20 floors\": use the AND logical operator to require both conditions (height_feet >= 200 AND floors >= 20) instead of OR."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM buildings WHERE height >= 200 OR floors >= 20;",
            "SELECT Name FROM building WHERE height_feet >= 200 AND Floors >= 20"
        ],
        "rule_sql": [
            "SELECT Name FROM building WHERE height_feet >= 200 AND Floors >= 20;"
        ]
    },
    "4415": {
        "db_id": "network_2",
        "question": "What is the age of the doctor named Zach?",
        "ground_truth": "SELECT age FROM Person WHERE job  =  'doctor' AND name  =  'Zach'",
        "amends": [
            "Do reference table `Person` instead of `doctors` in the FROM clause. Do add filter condition `job = 'doctor'` instead of omitting it, while keeping the existing `name = 'Zach'` filter in the WHERE clause. The amended query now correctly filters for doctors by their job attribute rather than relying on a separate doctors table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about doctors: use table \"Person\" instead of a separate doctors table. 2) When filtering for doctors: add condition \"job = 'doctor'\" to identify medical professionals. 3) When searching for a person by name: use condition \"name = 'Zach'\" with exact case and spelling. 4) When retrieving age information: select the \"age\" column from the \"Person\" table. 5) When combining filters: apply both \"job = 'doctor'\" and \"name = 'Zach'\" conditions together in the WHERE clause."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT age FROM doctors WHERE name = 'Zach';",
            "SELECT age FROM Person WHERE name = 'Zach' AND job = 'doctor';"
        ],
        "rule_sql": [
            "SELECT age FROM Person WHERE job = 'doctor' AND name = 'Zach';"
        ]
    },
    "3616": {
        "db_id": "music_1",
        "question": "What is the id of every song that has a resolution higher than that of a song with a rating below 8?",
        "ground_truth": "SELECT f_id FROM song WHERE resolution  >  (SELECT max(resolution) FROM song WHERE rating  <  8)",
        "amends": [
            "Do reference table `song` instead of `songs` in both main and subquery. Do select column `f_id` instead of `id` in the main query. Do use aggregate function `max(resolution)` in the subquery instead of plain `resolution` to ensure the comparison operates against the maximum value rather than potentially multiple values. Do remove the unnecessary parentheses around the subquery comparison. The amended query now correctly identifies songs with resolution greater than the maximum resolution of songs rated below 8, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about songs: use table \"song\" instead of \"songs\" as the correct table name. 2) When selecting song identifiers: use column \"f_id\" instead of \"id\" as the correct identifier column. 3) When comparing against multiple values from a subquery: use aggregate function max(resolution) to ensure comparison operates against the maximum value rather than potentially multiple values. 4) When the question asks for songs with resolution higher than songs with rating below 8: compare resolution > (SELECT max(resolution) FROM song WHERE rating < 8) to correctly identify songs with resolution greater than the maximum resolution of songs rated below 8."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM songs WHERE resolution > (SELECT resolution FROM songs WHERE rating < 8);",
            "SELECT f_id FROM song WHERE resolution > (SELECT MAX(resolution) FROM song WHERE rating < 8)"
        ],
        "rule_sql": [
            "SELECT f_id FROM song WHERE resolution > (SELECT MAX(resolution) FROM song WHERE rating < 8)"
        ]
    },
    "3517": {
        "db_id": "hr_1",
        "question": "display the first and last name, department, city, and state province for each employee.",
        "ground_truth": "SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id",
        "amends": [
            "Do specify table aliases `T1.first_name`, `T1.last_name` instead of unqualified `first_name`, `last_name`. Do join `departments AS T2` with predicate `T1.department_id = T2.department_id` instead of omitting the table and join. Do join `locations AS T3` with predicate `T2.location_id = T3.location_id` instead of omitting the table and join. Do select `T2.department_name` instead of `department` which doesn't exist. The amended query now correctly joins three tables to retrieve employee details with proper department and location information."
        ],
        "rules": [
            "1) When selecting employee attributes: use table aliases with exact column names as T1.first_name and T1.last_name instead of unqualified column names. 2) When the question mentions \"department\": \"department\" actually means T2.department_name in the schema, not a column called department. 3) When combining employees (T1) and departments (T2): link rows where T1.department_id = T2.department_id and keep only matching pairs (inner match). 4) When combining departments (T2) and locations (T3): link rows where T2.location_id = T3.location_id and keep only matching pairs (inner match). 5) When answering about employee details with department and location information: make sure the output order: T1.first_name, T1.last_name, T2.department_name, T3.city, T3.state_province."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name, department, city, state_province FROM employees",
            "SELECT T1.first_name, T1.last_name, T2.department_name, T3.city, T3.state_province\nFROM employees AS T1\nJOIN departments AS T2 ON T1.department_id = T2.department_id\nJOIN locations AS T3 ON T2.location_id = T3.location_id"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.last_name, T2.department_name, T3.city, T3.state_province\nFROM employees T1\nINNER JOIN departments T2 ON T1.department_id = T2.department_id\nINNER JOIN locations T3 ON T2.location_id = T3.location_id"
        ]
    },
    "4163": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "What are all the calendar dates and day Numbers?",
        "ground_truth": "SELECT calendar_date ,  day_Number FROM Ref_calendar",
        "amends": [
            "Do reference the `Ref_calendar` table instead of the `calendar` table. Do use the correct column name `day_Number` instead of `day_number`. The amended query now correctly selects from the appropriate calendar reference table with the proper column casing."
        ],
        "rules": [
            "1) When answering about calendar dates and day numbers: use the table \"Ref_calendar\" instead of \"calendar\" 2) When referring to the day number column: use the exact column name \"day_Number\" with proper casing instead of \"day_number\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT calendar_date, day_number FROM calendar ORDER BY calendar_date DESC;",
            "SELECT Calendar_Date, Day_Number FROM Ref_Calendar;"
        ],
        "rule_sql": [
            "SELECT Calendar_Date, Day_Number FROM Ref_Calendar;"
        ]
    },
    "6296": {
        "db_id": "city_record",
        "question": "Please give me a list of cities whose regional population is over 10000000.",
        "ground_truth": "SELECT city FROM city WHERE regional_population  >  10000000",
        "amends": [
            "Do reference the `city` column instead of `city_name` and use the `city` table instead of `cities`. Do filter on `regional_population > 10000000` instead of `population > 10000000` to correctly apply the regional population criteria. The amended query now matches the intended behavior of selecting cities based on regional population thresholds."
        ],
        "rules": [
            "1) When the question mentions \"cities\": use the table \"city\" instead of \"cities\". 2) When the question asks for city names: use the column \"city\" instead of \"city_name\". 3) When the question specifies \"regional population is over 10000000\": filter using \"regional_population > 10000000\" instead of \"population > 10000000\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city_name FROM cities WHERE population > 10000000;",
            "SELECT City FROM city WHERE Regional_Population > 10000000"
        ],
        "rule_sql": [
            "SELECT City FROM city WHERE Regional_Population > 10000000;"
        ]
    },
    "6939": {
        "db_id": "tracking_orders",
        "question": "Find the name of the customers who have at most two orders.",
        "ground_truth": "SELECT T2.customer_name FROM orders AS T1 JOIN customers AS T2 ON T1.customer_id = T2.customer_id GROUP BY T2.customer_id HAVING count(*)  <=  2",
        "amends": [
            "Do use `JOIN` between `orders` and `customers` tables with `ON T1.customer_id = T2.customer_id` instead of querying only the `customers` table. Do select `T2.customer_name` instead of `name` from the customers table. Do use `HAVING count(*) <= 2` instead of `WHERE COUNT(order_id) <= 2` to properly filter aggregated results. Do include proper table aliases `T1` and `T2` instead of omitting them. Do group by `T2.customer_id` instead of `customer_id` to ensure proper grouping with the joined tables. The amended query now correctly counts orders per customer and filters based on the aggregate count, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"customers who have at most two orders\": make sure to combine the orders and customers tables using an inner match where T1.customer_id = T2.customer_id. 2) When counting orders per customer: use count(*) to count all order rows for each customer group. 3) When filtering based on the count of orders: use HAVING count(*) <= 2 instead of WHERE to filter aggregated results. 4) When selecting customer names: use T2.customer_name instead of just name. 5) When grouping results: group by T2.customer_id to ensure proper grouping with joined tables."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM customers WHERE COUNT(order_id) <= 2 GROUP BY customer_id",
            "SELECT T2.customer_name\nFROM Orders T1\nJOIN Customers T2 ON T1.customer_id = T2.customer_id\nGROUP BY T2.customer_id\nHAVING COUNT(*) <= 2"
        ],
        "rule_sql": [
            "SELECT T2.customer_name\nFROM Orders T1\nINNER JOIN Customers T2 ON T1.customer_id = T2.customer_id\nGROUP BY T2.customer_id\nHAVING COUNT(*) <= 2"
        ]
    },
    "2688": {
        "db_id": "party_host",
        "question": "List the names of hosts who did not serve as a host of any party in our record.",
        "ground_truth": "SELECT Name FROM HOST WHERE Host_ID NOT IN (SELECT Host_ID FROM party_host)",
        "amends": [
            "Do reference table `HOST` instead of `hosts` and use column `Name` instead of `name`. Do use `Host_ID` instead of `host_id` in the main query's WHERE clause. Do reference subquery table `party_host` instead of `parties` and use column `Host_ID` instead of `host_id` in the subquery. The amended query now correctly matches the intended logic by using the proper table and column names from the schema."
        ],
        "rules": [
            "1) When answering about \"hosts who did not serve as a host of any party\": use table \"host\" as T1 and column \"Name\" for the output. 2) When checking which hosts did not host any party: use column \"Host_ID\" from T1 in the WHERE clause. 3) When identifying parties hosted: use table \"party_host\" as T2 and column \"Host_ID\" for the subquery. 4) When combining host and party information: check for non-matching Host_ID values between T1 and T2 using the exact equality condition T1.Host_ID NOT IN (SELECT Host_ID FROM party_host). 5) When producing output: return only the \"Name\" column from T1 in the order specified by the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM hosts WHERE host_id NOT IN (SELECT host_id FROM parties)",
            "SELECT Name FROM host WHERE Host_ID NOT IN (SELECT Host_ID FROM party_host)"
        ],
        "rule_sql": [
            "SELECT Name FROM host AS T1 WHERE T1.Host_ID NOT IN (SELECT Host_ID FROM party_host AS T2)"
        ]
    },
    "6405": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "Find names and ids of all documents with document type code BK.",
        "ground_truth": "SELECT document_name ,  document_id FROM Documents WHERE document_type_code  =  \"BK\"",
        "amends": [
            "Do use `document_name` and `document_id` instead of `name` and `id` for column selection. Do reference the `Documents` table instead of `documents` for the FROM source. Do filter on `document_type_code = \"BK\"` instead of `document_type = 'BK'` for the WHERE condition, changing both the column name and quote style. The amended query now correctly matches the RIGHT_SQL's behavior with proper column and table references.",
            "Do reverse the column order in the SELECT list to `document_name, document_id` instead of `document_id, document_name`. Do use double quotes `\"BK\"` for the string literal instead of single quotes `'BK'` in the WHERE clause filter on `document_type_code`. The amended query now matches RIGHT_SQL's behavior with identical column selection and filtering logic."
        ],
        "rules": [
            "1) When selecting document names and IDs: use \"document_name\" and \"document_id\" columns instead of \"name\" and \"id\". 2) When referencing the documents table: use \"Documents\" (with capital D) instead of \"documents\". 3) When filtering by document type code BK: use \"document_type_code = \\\"BK\\\"\" with double quotes around BK instead of single quotes, and use the exact column name \"document_type_code\" instead of \"document_type\".",
            "1) When the question asks for \"names and ids\" of documents: make sure the output order is document_name, document_id instead of document_id, document_name. 2) When filtering on document_type_code with value BK: use the exact literal \"BK\" with double quotes instead of single quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, id FROM documents WHERE document_type = 'BK'",
            "SELECT document_id, document_name FROM Documents WHERE document_type_code = 'BK';",
            "SELECT document_name, document_id FROM Documents WHERE document_type_code = \"BK\""
        ],
        "rule_sql": [
            "SELECT document_name, document_id FROM Documents WHERE document_type_code = \"BK\""
        ]
    },
    "5564": {
        "db_id": "products_gen_characteristics",
        "question": "How many characteristics does the product named \"laurel\" have?",
        "ground_truth": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  \"laurel\"",
        "amends": [
            "Do add `JOIN product_characteristics AS t2 ON t1.product_id = t2.product_id` and `JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id = t3.characteristic_id` instead of querying only the `products` table. Do reference `t1.product_name` instead of `name` in the WHERE clause. Do use double quotes around `\"laurel\"` instead of single quotes. The amended query now correctly joins related tables to count products with the specified name across the complete product-characteristics relationship, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about characteristics of a product: join the products table (T1) with product_characteristics table (T2) using T1.product_id = T2.product_id, and join with characteristics table (T3) using T2.characteristic_id = T3.characteristic_id. 2) When filtering by product name: use T1.product_name instead of name and match the exact literal \"laurel\" with double quotes. 3) When counting characteristics for a product: count the rows from the joined tables after filtering for the specific product name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM products WHERE name = 'laurel';",
            "SELECT COUNT(*) \nFROM Products AS t1\nJOIN Product_Characteristics AS t2 ON t1.product_id = t2.product_id\nJOIN Characteristics AS t3 ON t2.characteristic_id = t3.characteristic_id\nWHERE t1.product_name = \"laurel\""
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Products T1\nJOIN Product_Characteristics T2 ON T1.product_id = T2.product_id\nJOIN Characteristics T3 ON T2.characteristic_id = T3.characteristic_id\nWHERE T1.product_name = \"laurel\""
        ]
    },
    "1801": {
        "db_id": "small_bank_1",
        "question": "What are the names and sum of checking and savings balances for accounts with savings balances higher than the average savings balance?",
        "ground_truth": "SELECT T1.name ,  T2.balance + T3.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid WHERE T3.balance  >  (SELECT avg(balance) FROM savings)",
        "amends": [
            "Do reference `T1.name` instead of `name` and use explicit column addition `T2.balance + T3.balance` instead of the aliased expression `(checking_balance + savings_balance) as total_balance`. Do join `checking AS T2` on `T1.custid = T2.custid` and `savings AS T3` on `T1.custid = T3.custid` instead of querying only the `accounts` table. Do filter on `T3.balance > (SELECT avg(balance) FROM savings)` instead of `savings_balance > (SELECT AVG(savings_balance) FROM accounts)` to compare against the correct table average. The amended query now properly joins related tables and calculates balances from the appropriate sources, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about account names and sum of checking and savings balances: make sure the output order: T1.name, T2.balance + T3.balance\n2) When combining ACCOUNTS as T1 with checking as T2: link rows where T1.custid = T2.custid and keep only matching pairs (inner match)\n3) When combining ACCOUNTS as T1 with savings as T3: link rows where T1.custid = T3.custid and keep only matching pairs (inner match)\n4) When filtering accounts with savings balances higher than average: filter on T3.balance > (SELECT avg(balance) FROM savings) to compare against the correct table average\n5) When calculating total balance: compute T2.balance + T3.balance instead of using aliased expressions from a single table"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, (checking_balance + savings_balance) as total_balance \nFROM accounts \nWHERE savings_balance > (SELECT AVG(savings_balance) FROM accounts);",
            "SELECT T1.name, (T2.balance + T3.balance) as total_balance\nFROM ACCOUNTS AS T1\nJOIN CHECKING AS T2 ON T1.custid = T2.custid\nJOIN SAVINGS AS T3 ON T1.custid = T3.custid\nWHERE T3.balance > (SELECT AVG(balance) FROM SAVINGS)"
        ],
        "rule_sql": [
            "SELECT T1.name, T2.balance + T3.balance \nFROM ACCOUNTS AS T1\nINNER JOIN CHECKING AS T2 ON T1.custid = T2.custid\nINNER JOIN SAVINGS AS T3 ON T1.custid = T3.custid\nWHERE T3.balance > (SELECT AVG(balance) FROM SAVINGS)"
        ]
    },
    "858": {
        "db_id": "chinook_1",
        "question": "What are the last names of customers without invoice totals exceeding 20?",
        "ground_truth": "SELECT LastName FROM CUSTOMER EXCEPT SELECT T1.LastName FROM CUSTOMER AS T1 JOIN Invoice AS T2 ON T1.CustomerId  =  T2.CustomerId WHERE T2.total  >  20",
        "amends": [
            "Do use `EXCEPT` to exclude customers with invoices over 20 instead of directly filtering by `InvoiceTotal`. Do add a join between `CUSTOMER` and `Invoice` tables on `CustomerId` instead of missing this relationship entirely. Do reference the correct table alias `T1.LastName` instead of omitting the alias specification. Do filter on `T2.total > 20` in the excluded subquery instead of using `InvoiceTotal <= 20` in the main query. Do include proper table aliasing with `AS T1` and `AS T2` instead of omitting explicit aliases. The amended query now correctly identifies customers without any invoices exceeding 20, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about customers without invoice totals exceeding 20: use EXCEPT to exclude customers with invoices over 20 instead of direct filtering. 2) When combining Customer and Invoice tables: link rows where T1.CustomerId = T2.CustomerId and keep only matching pairs (inner match). 3) When referencing customer last names: use the exact token T1.LastName with proper table alias. 4) When filtering for invoices exceeding 20: use the exact condition T2.total > 20 in the excluded subquery. 5) When using table aliases: always specify AS T1 for Customer table and AS T2 for Invoice table instead of omitting explicit aliases."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT LastName FROM Customers WHERE InvoiceTotal <= 20;",
            "SELECT T1.LastName\nFROM Customer AS T1\nEXCEPT\nSELECT T1.LastName\nFROM Customer AS T1\nJOIN Invoice AS T2 ON T1.CustomerId = T2.CustomerId\nWHERE T2.Total > 20"
        ],
        "rule_sql": [
            "SELECT T1.LastName\nFROM Customer AS T1\nINNER JOIN Invoice AS T2 ON T1.CustomerId = T2.CustomerId\nEXCEPT\nSELECT T1.LastName\nFROM Customer AS T1\nINNER JOIN Invoice AS T2 ON T1.CustomerId = T2.CustomerId\nWHERE T2.Total > 20"
        ]
    },
    "4276": {
        "db_id": "club_1",
        "question": "Which club has the most members majoring in \"600\"?",
        "ground_truth": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  \"600\" GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use table aliases `t1`, `t2`, and `t3` instead of direct table names. Do reference `t1.clubname` in SELECT instead of `club_name`. Do join three tables with `JOIN member_of_club AS t2` and `JOIN student AS t3` instead of just two tables. Do use join conditions `t1.clubid = t2.clubid` and `t2.stuid = t3.stuid` instead of `clubs.club_id = members.club_id`. Do filter on `t3.major = \"600\"` instead of `major = '600'`. Do group by `t1.clubname` instead of `club_name`. Do order by `count(*) DESC` instead of `member_count DESC` while keeping the same aggregate logic. The amended query now correctly joins through the member_of_club bridge table to access student major information and matches the RIGHT_SQL's behavior.",
            "Do select only `t1.clubname` instead of including `COUNT(*) AS member_count` in the SELECT list. Do use lowercase `clubname` instead of `ClubName` and maintain the same FROM sources with `JOIN` on `t1.clubid = t2.clubid` and `t2.stuid = t3.stuid`. Do keep the WHERE filter on `t3.major = \"600\"` unchanged. Do maintain GROUP BY on `t1.clubname` and ORDER BY on `count(*) DESC` with LIMIT 1. The amended query now correctly returns only the club name with the most members majoring in \"600\" instead of including the count value in the output."
        ],
        "rules": [
            "1) When answering about \"which club has the most members majoring in '600'\": make sure the output order: t1.clubname, count(*) 2) When the question mentions \"club\": \"club\" actually means \"t1.clubname in schema\" 3) When the question mentions \"most members\": rank rows by count(*) in descending direction and keep the first 1 row 4) When the question asks for \"count of members majoring in '600'\": compute the number of rows using the canonical key token for members (t3.stuid) 5) When combining tables for shared entities: link rows where t1.clubid = t2.clubid and t2.stuid = t3.stuid exactly as shown in the amends; keep only matching pairs (inner match) 6) When filtering on major: use exact literal \"600\" with double quotes as shown in the amends (t3.major = \"600\") 7) When grouping by club: organize results by t1.clubname and compute requested aggregates per group",
            "1) When the question asks for \"which club has the most members\": select only the club name (t1.clubname) without including the count value in the output. 2) When the question specifies members majoring in \"600\": filter rows where t3.major equals exactly \"600\" (case-sensitive). 3) When counting members per club: group by t1.clubname and count using the canonical key (implied by the join structure). 4) When finding the club with the most members: order by the count in descending order and take only the first result (limit 1). 5) When combining Club, Member_of_club, and Student tables: link rows where t1.clubid = t2.clubid and t2.stuid = t3.stuid using inner matches only."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT club_name, COUNT(*) as member_count FROM clubs JOIN members ON clubs.club_id = members.club_id WHERE major = '600' GROUP BY club_name ORDER BY member_count DESC LIMIT 1;",
            "SELECT t1.ClubName, COUNT(*) AS member_count\nFROM Club AS t1\nJOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID\nJOIN Student AS t3 ON t2.StuID = t3.StuID\nWHERE t3.Major = \"600\"\nGROUP BY t1.ClubName\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT t1.clubname\nFROM Club AS t1\nJOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID\nJOIN Student AS t3 ON t2.StuID = t3.StuID\nWHERE t3.Major = \"600\"\nGROUP BY t1.clubname\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t1.ClubName\nFROM Club t1\nJOIN Member_of_club t2 ON t1.ClubID = t2.ClubID\nJOIN Student t3 ON t2.StuID = t3.StuID\nWHERE t3.Major = \"600\"\nGROUP BY t1.ClubName\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "5232": {
        "db_id": "music_2",
        "question": "Find all the songs that do not have a lead vocal.",
        "ground_truth": "SELECT DISTINCT title FROM vocals AS t1 JOIN songs AS t2 ON t1.songid  =  t2.songid EXCEPT SELECT t2.title FROM vocals AS t1 JOIN songs AS t2 ON t1.songid  =  t2.songid WHERE TYPE  =  \"lead\"",
        "amends": [
            "Do select only `title` instead of all columns with `*`. Do add `DISTINCT` instead of omitting it. Do change from a single table `songs` to joining `vocals` and `songs` on `songid` instead of querying only `songs`. Do add an `EXCEPT` operation to exclude results instead of using a simple `WHERE` filter. Do include a subquery that filters for `TYPE = \"lead\"` instead of checking `lead_vocal IS NULL`. The amended query now correctly identifies songs without lead vocals by using set operations instead of relying on a potentially incorrect null check."
        ],
        "rules": [
            "1) When answering about \"songs that do not have a lead vocal\": make sure the output order: title. 2) When the question asks for songs without lead vocals: use an EXCEPT operation to exclude songs that have lead vocals instead of checking for NULL values. 3) When combining vocals and songs tables: link rows where vocals.songid = songs.songid to identify vocal assignments. 4) When identifying lead vocals: filter for TYPE = \"lead\" exactly as specified in the vocals table. 5) When selecting output: use DISTINCT title to ensure each song appears only once in the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM songs WHERE lead_vocal IS NULL;",
            "SELECT DISTINCT s.Title\nFROM Songs s\nEXCEPT\nSELECT DISTINCT s.Title\nFROM Songs s\nJOIN Vocals v ON s.SongId = v.SongId\nWHERE v.Type = 'lead'"
        ],
        "rule_sql": [
            "SELECT DISTINCT Title FROM Songs\nEXCEPT\nSELECT DISTINCT s.Title\nFROM Songs s\nJOIN Vocals v ON s.SongId = v.SongId\nWHERE v.Type = 'lead'\nORDER BY Title;"
        ]
    },
    "6606": {
        "db_id": "train_station",
        "question": "Show all locations that have train stations with at least 15 platforms and train stations with more than 25 total passengers.",
        "ground_truth": "SELECT DISTINCT LOCATION FROM station WHERE number_of_platforms  >=  15 AND total_passengers  >  25",
        "amends": [
            "Do reference table `station` instead of `train_stations` and use column `number_of_platforms` instead of `platforms`. Do apply `AND` logic instead of `OR` between the filter conditions. Do add `DISTINCT` instead of omitting it to eliminate duplicate location values. The amended query now correctly filters for stations that have both at least 15 platforms AND more than 25 passengers, ensuring distinct location results match the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"train stations\": use table \"station\" instead of \"train_stations\". 2) When filtering for \"at least 15 platforms\": use column \"number_of_platforms\" >= 15 instead of \"platforms\". 3) When filtering for \"more than 25 total passengers\": use column \"total_passengers\" > 25. 4) When combining multiple filter conditions for the same station: use AND logic instead of OR to require both conditions simultaneously. 5) When showing \"all locations\": use DISTINCT to eliminate duplicate location values and return each unique location only once."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location FROM train_stations WHERE platforms >= 15 OR total_passengers > 25;",
            "SELECT DISTINCT Location FROM station WHERE Number_of_Platforms >= 15 AND Total_Passengers > 25;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Location FROM station WHERE Number_of_Platforms >= 15 AND Total_Passengers > 25;"
        ]
    },
    "5116": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "Show all payment method codes and the number of orders for each code.",
        "ground_truth": "SELECT payment_method_code ,  count(*) FROM INVOICES GROUP BY payment_method_code",
        "amends": [
            "Do reference table `INVOICES` instead of `orders` in the FROM clause. Do use column `payment_method_code` instead of `payment_method` in both the SELECT list and GROUP BY clause. Do group by `payment_method_code` instead of `order_id` to correctly aggregate counts by payment method type rather than by individual orders. The amended query now correctly counts invoices grouped by payment method code as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When answering about \"payment method codes and number of orders\": make sure the output order: payment_method_code first, then count of invoices. 2) When the question mentions \"payment method codes\": \"payment method codes\" actually means \"payment_method_code in table INVOICES\". 3) When the question asks for \"number of orders\": \"orders\" actually means \"invoices in table INVOICES\". 4) When the question says \"for each code\": organize results by payment_method_code and compute count of invoices per group. 5) When the question asks for \"count of invoices\": compute the number of rows using the canonical key for invoices (e.g., invoice identifier from INVOICES table). 6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table names like \"INVOICES\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT payment_method, COUNT(*) FROM orders GROUP BY order_id;",
            "SELECT payment_method_code, COUNT(*) AS number_of_orders\nFROM Invoices\nGROUP BY payment_method_code;"
        ],
        "rule_sql": [
            "SELECT payment_method_code, COUNT(Invoice_ID) AS number_of_orders\nFROM Invoices\nGROUP BY payment_method_code\nORDER BY payment_method_code;"
        ]
    },
    "5576": {
        "db_id": "products_gen_characteristics",
        "question": "Count the products that have the color description \"white\" or have the characteristic name \"hot\".",
        "ground_truth": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  \"white\" OR t3.characteristic_name  =  \"hot\"",
        "amends": [
            "Do add joins to `product_characteristics`, `CHARACTERISTICS`, and `ref_colors` tables instead of querying only the `products` table. Do use `JOIN` with `ON t1.product_id = t2.product_id` and `ON t2.characteristic_id = t3.characteristic_id` and `ON t1.color_code = t4.color_code` instead of missing these table relationships. Do change the WHERE condition to use `OR` logic with `t4.color_description = \"white\" OR t3.characteristic_name = \"hot\"` instead of `AND` logic with `color_description = 'white' AND characteristic_name = 'hot'`. Do reference columns through proper table aliases `t1`, `t2`, `t3`, `t4` instead of accessing them directly without table context. The amended query now correctly joins the necessary tables and uses OR logic to find products that are either white or hot, matching the intended behavior."
        ],
        "rules": [
            "1) When counting products that have color description \"white\" or characteristic name \"hot\": join products table (T1) with product_characteristics table (T2) using T1.product_id = T2.product_id. 2) When joining product_characteristics table (T2): also join with CHARACTERISTICS table (T3) using T2.characteristic_id = T3.characteristic_id. 3) When joining products table (T1): also join with ref_colors table (T4) using T1.color_code = T4.color_code. 4) When filtering for products that are white or hot: use OR condition with T4.color_description = \"white\" OR T3.characteristic_name = \"hot\" instead of AND logic. 5) When counting products: use proper table aliases T1, T2, T3, T4 for column references instead of accessing columns without table context."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM products WHERE color_description = 'white' AND characteristic_name = 'hot';",
            "SELECT COUNT(DISTINCT t1.product_id)\nFROM Products t1\nJOIN Product_Characteristics t2 ON t1.product_id = t2.product_id\nJOIN Characteristics t3 ON t2.characteristic_id = t3.characteristic_id\nJOIN Ref_Colors t4 ON t1.color_code = t4.color_code\nWHERE t4.color_description = 'white' OR t3.characteristic_name = 'hot'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.product_id) \nFROM Products T1\nLEFT JOIN Product_Characteristics T2 ON T1.product_id = T2.product_id\nLEFT JOIN Characteristics T3 ON T2.characteristic_id = T3.characteristic_id\nJOIN Ref_Colors T4 ON T1.color_code = T4.color_code\nWHERE T4.color_description = 'white' OR T3.characteristic_name = 'hot'"
        ]
    },
    "1180": {
        "db_id": "election_representative",
        "question": "What are the life spans of representatives from New York state or Indiana state?",
        "ground_truth": "SELECT Lifespan FROM representative WHERE State  =  \"New York\" OR State  =  \"Indiana\"",
        "amends": [
            "Do reference the `Lifespan` column instead of `lifespan` and remove the `name` column instead of including it. Do reference the `representative` table instead of `representatives` and use double quotes around string literals instead of single quotes. Do maintain the same WHERE filter logic with `State = \"New York\" OR State = \"Indiana\"` instead of `state = 'New York' OR state = 'Indiana'`. The amended query now correctly selects only the lifespan data from the representative table for the specified states, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"life spans\": select only the \"Lifespan\" column from the \"representative\" table. 2) When the question mentions \"representatives\": use the exact table name \"representative\" instead of \"representatives\". 3) When filtering for states \"New York\" or \"Indiana\": use the exact string literals \"New York\" and \"Indiana\" with double quotes. 4) When constructing the state filter: use the condition State = \"New York\" OR State = \"Indiana\" to include representatives from either state."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, lifespan FROM representatives WHERE state = 'New York' OR state = 'Indiana';",
            "SELECT Lifespan FROM representative WHERE State = \"New York\" OR State = \"Indiana\""
        ],
        "rule_sql": [
            "SELECT Lifespan FROM representative WHERE State = \"New York\" OR State = \"Indiana\""
        ]
    },
    "2595": {
        "db_id": "inn_1",
        "question": "Return the decor of the room named \"Recluse and defiance\".",
        "ground_truth": "SELECT decor FROM Rooms WHERE roomName  =  \"Recluse and defiance\";",
        "amends": [
            "Do reference the table as `Rooms` instead of `rooms` to match the correct schema. Do use the column name `roomName` instead of `name` for the filter condition. Do use double quotes `\"Recluse and defiance\"` instead of single quotes for the string literal. The amended query now correctly selects decor from the Rooms table filtered by the roomName column with proper identifier casing and string quoting."
        ],
        "rules": [
            "1) When referencing the table containing room information: use the exact table name \"Rooms\" with proper casing. 2) When filtering by room name: use the exact column name \"roomName\" from the Rooms table. 3) When matching the literal room name \"Recluse and defiance\": use double quotes exactly as \"Recluse and defiance\" for the string literal. 4) When selecting room decor information: retrieve the \"decor\" column from the Rooms table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT decor FROM rooms WHERE name = 'Recluse and defiance'",
            "SELECT decor FROM Rooms WHERE roomName = \"Recluse and defiance\";"
        ],
        "rule_sql": [
            "SELECT decor FROM Rooms WHERE roomName = \"Recluse and defiance\";"
        ]
    },
    "6369": {
        "db_id": "flight_company",
        "question": "What is maximum group equity shareholding of the companies?",
        "ground_truth": "SELECT max(group_equity_shareholding) FROM operate_company",
        "amends": [
            "Do reference the `max(group_equity_shareholding)` column instead of `MAX(shareholding)`. Do query from the `operate_company` table instead of the `companies` table. Do remove the `WHERE group_equity = 'yes'` filter instead of keeping it, as the maximum value calculation should apply to all records without restriction. The amended query now correctly calculates the maximum group equity shareholding from the appropriate table without unnecessary filtering."
        ],
        "rules": [
            "1) When answering about \"maximum group equity shareholding\": use the exact column \"max(group_equity_shareholding)\" instead of \"MAX(shareholding)\". 2) When querying company data: use the \"operate_company\" table instead of the \"companies\" table. 3) When calculating maximum values: do not apply filters like \"WHERE group_equity = 'yes'\" as maximum calculations should consider all records without restriction."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(shareholding) FROM companies WHERE group_equity = 'yes';",
            "SELECT MAX(Group_Equity_Shareholding) FROM operate_company;"
        ],
        "rule_sql": [
            "SELECT max(Group_Equity_Shareholding) FROM operate_company"
        ]
    },
    "4776": {
        "db_id": "department_store",
        "question": "Return the maximum and minimum customer codes.",
        "ground_truth": "SELECT max(customer_code) ,  min(customer_code) FROM Customers",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(customer_code), MIN(customer_code) FROM customers;"
        ],
        "rule_sql": [
            "SELECT MAX(customer_code) AS max_customer_code, MIN(customer_code) AS min_customer_code FROM Customers;"
        ]
    },
    "4652": {
        "db_id": "college_3",
        "question": "What are the first names for students who have an \"a\" in their first name?",
        "ground_truth": "SELECT DISTINCT Fname FROM STUDENT WHERE Fname LIKE '%a%'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate first names. Do reference column `Fname` instead of `first_name` to match the correct schema. Do reference table `STUDENT` instead of `students` to use the proper table name. The amended query now correctly returns unique first names containing 'a' from the STUDENT table."
        ],
        "rules": [
            "1) When the question asks for first names of students: use column \"Fname\" from table \"STUDENT\" instead of \"first_name\" from \"students\". 2) When eliminating duplicate values in the result: use DISTINCT to return only unique first names. 3) When filtering for names containing the letter \"a\": use the pattern '%a%' to match first names with \"a\" anywhere in the string. 4) When producing output: return only the \"Fname\" column in the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE first_name LIKE '%a%';",
            "SELECT DISTINCT Fname FROM Student WHERE Fname LIKE '%a%';"
        ],
        "rule_sql": [
            "SELECT DISTINCT Fname FROM Student WHERE Fname LIKE '%a%';"
        ]
    },
    "4303": {
        "db_id": "club_1",
        "question": "Count the number of members in club \"Bootup Baltimore\" whose age is below 18.",
        "ground_truth": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.age  <  18",
        "amends": [
            "Do add joins to `club`, `member_of_club`, and `student` tables instead of querying only the `members` table. Do use `JOIN` with `t1.clubid = t2.clubid` and `t2.stuid = t3.stuid` instead of no joins. Do filter on `t1.clubname = \"Bootup Baltimore\"` instead of `club_name = 'Bootup Baltimore'`. Do change the age condition to `t3.age < 18` instead of `age > 18`. Do remove the incorrect `WHERE` clause structure and implement proper table relationships through joins. The amended query now correctly counts students under 18 who are members of the specified club."
        ],
        "rules": [
            "1) When answering about counting members in a specific club: use joins between club, member_of_club, and student tables instead of querying only the members table. 2) When combining club and member_of_club tables: link rows where t1.clubid = t2.clubid exactly as shown. 3) When combining member_of_club and student tables: link rows where t2.stuid = t3.stuid exactly as shown. 4) When filtering for club \"Bootup Baltimore\": use t1.clubname = \"Bootup Baltimore\" with exact case and quotes. 5) When filtering for age below 18: use t3.age < 18 instead of age > 18. 6) When counting members: count using the canonical student key (t3.stuid) from the student table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM members WHERE club_name = 'Bootup Baltimore' AND age > 18;",
            "SELECT COUNT(*) \nFROM Club t1\nJOIN Member_of_club t2 ON t1.ClubID = t2.ClubID\nJOIN Student t3 ON t2.StuID = t3.StuID\nWHERE t1.ClubName = 'Bootup Baltimore' AND t3.Age < 18"
        ],
        "rule_sql": [
            "SELECT COUNT(t3.StuID) \nFROM Club t1\nJOIN Member_of_club t2 ON t1.ClubID = t2.ClubID\nJOIN Student t3 ON t2.StuID = t3.StuID\nWHERE t1.ClubName = \"Bootup Baltimore\" AND t3.Age < 18"
        ]
    },
    "6280": {
        "db_id": "city_record",
        "question": "What is the host year of city \"Taizhou ( Zhejiang )\"?",
        "ground_truth": "SELECT T2.year FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city WHERE T1.city  =  \"Taizhou ( Zhejiang )\"",
        "amends": [
            "Do select `T2.year` from the `hosting_city` table instead of `host_year` from the `cities` table. Do use a `JOIN` between `city` and `hosting_city` tables on `T1.city_id = T2.host_city` instead of querying only the `cities` table. Do filter on `T1.city = \"Taizhou ( Zhejiang )\"` instead of `city_name = 'Taizhou (Zhejiang)'` to match the correct table structure and column naming. The amended query now correctly retrieves the hosting year by joining the appropriate tables and using the correct column references."
        ],
        "rules": [
            "1) When the question asks for \"host year\" of a city: use \"T2.year\" from the \"hosting_city\" table instead of \"host_year\" from \"cities\" table. 2) When combining city and hosting_city tables: link rows where \"T1.city_id = T2.host_city\" and keep only matching pairs (inner match). 3) When filtering for city \"Taizhou ( Zhejiang )\": use exact literal \"Taizhou ( Zhejiang )\" with double quotes and proper spacing in \"T1.city\" column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT host_year FROM cities WHERE city_name = 'Taizhou (Zhejiang)';",
            "SELECT T2.Year \nFROM city T1 \nJOIN hosting_city T2 ON T1.City_ID = T2.Host_City \nWHERE T1.City = 'Taizhou ( Zhejiang )'"
        ],
        "rule_sql": [
            "SELECT T2.Year FROM city T1 JOIN hosting_city T2 ON T1.City_ID = T2.Host_City WHERE T1.City = \"Taizhou ( Zhejiang )\""
        ]
    },
    "3567": {
        "db_id": "music_1",
        "question": "For each file format, return the number of artists who released songs in that format.",
        "ground_truth": "SELECT count(*) ,  formats FROM files GROUP BY formats",
        "amends": [
            "Do use `count(*)` without column alias instead of `COUNT(*)` with the same function but different formatting. Do reference `formats` column instead of `format` column in both SELECT list and GROUP BY clause. Do query from `files` table instead of `artists` table. Do place the aggregate function `count(*)` first in the SELECT list instead of second position. The amended query now correctly counts records grouped by format types from the files table rather than artists table."
        ],
        "rules": [
            "1) When answering about \"number of artists per file format\": make sure the output order: count(*) first, then formats. 2) When the question mentions \"file format\": \"file format\" actually means \"formats in schema\". 3) When the question asks for \"number of artists\": compute the number of rows using count(*) from the files table. 4) When the question says \"per file format\"/\"by file format\": organize results by the token for formats and compute count(*) per group. 5) When choosing identifier delimiters: do not replace the unquoted column name formats with quoted forms or backticks."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT format, COUNT(*) FROM artists GROUP BY format;",
            "SELECT count(*), formats FROM files GROUP BY formats"
        ],
        "rule_sql": [
            "SELECT COUNT(*), formats FROM files GROUP BY formats"
        ]
    },
    "3547": {
        "db_id": "music_1",
        "question": "How many artists are from Bangladesh?",
        "ground_truth": "SELECT count(*) FROM artist WHERE country  =  \"Bangladesh\"",
        "amends": [
            "Do reference table `artist` instead of `artists` in the FROM clause. Do use double quotes `\"Bangladesh\"` instead of single quotes `'Bangladesh'` for the string literal in the WHERE filter. The amended query now correctly references the intended table and uses consistent string quoting to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"artists from Bangladesh\": reference the table \"artist\" instead of \"artists\". 2) When filtering for country values: use double quotes \"Bangladesh\" instead of single quotes 'Bangladesh' for string literals."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM artists WHERE country = 'Bangladesh';",
            "SELECT COUNT(*) FROM artist WHERE country = \"Bangladesh\""
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM artist WHERE country = \"Bangladesh\""
        ]
    },
    "5771": {
        "db_id": "customer_complaints",
        "question": "What are the emails and phone numbers of all customers, sorted by email address and phone number?",
        "ground_truth": "SELECT email_address ,  phone_number FROM customers ORDER BY email_address ,  phone_number",
        "amends": [
            "Do select `email_address` instead of `email` in the SELECT list. Do order by `email_address` first instead of `phone_number` first in the ORDER BY clause. The amended query now correctly references the email_address column and prioritizes email sorting over phone number sorting, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for emails: use the exact column token \"email_address\" from the Customers table instead of \"email\". 2) When sorting results by email address and phone number: order by \"email_address\" first, then by \"phone_number\" second. 3) When selecting customer contact information: include both \"email_address\" and \"phone_number\" columns in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT email, phone_number FROM customers ORDER BY phone_number, email;",
            "SELECT email_address, phone_number FROM Customers ORDER BY email_address, phone_number;"
        ],
        "rule_sql": [
            "SELECT email_address, phone_number FROM Customers ORDER BY email_address, phone_number;"
        ]
    },
    "6825": {
        "db_id": "flight_4",
        "question": "Find the number of routes operated by American Airlines.",
        "ground_truth": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'",
        "amends": [
            "Do join `airlines AS T1` with `routes AS T2` on `T1.alid = T2.alid` instead of querying only the `routes` table. Do filter on `T1.name = 'American Airlines'` instead of filtering directly on `routes.airline`. Do use the correct join condition `T1.alid = T2.alid` to properly relate airlines to their routes instead of relying on a potentially incorrect or non-existent `airline` column in the routes table. The amended query now correctly counts routes by joining through the proper airline identifier relationship rather than using a direct text match that may not exist or be reliable."
        ],
        "rules": [
            "1) When answering about \"routes operated by American Airlines\": join table \"airlines\" as T1 with table \"routes\" as T2 using the condition T1.alid = T2.alid to properly relate airlines to their routes. 2) When filtering for \"American Airlines\": use T1.name = 'American Airlines' instead of relying on the routes.airline column. 3) When counting routes: count the number of rows in T2 that match the join condition and filter criteria."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM routes WHERE airline = 'American Airlines';",
            "SELECT COUNT(*) AS number_of_routes\nFROM routes AS T2\nJOIN airlines AS T1 ON T1.alid = T2.alid\nWHERE T1.name = 'American Airlines'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM routes T2\nJOIN airlines T1 ON T1.alid = T2.alid\nWHERE T1.name = 'American Airlines'"
        ]
    },
    "5492": {
        "db_id": "voter_2",
        "question": "Find the average age of female (sex is F) students who have secretary votes in the spring election cycle.",
        "ground_truth": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  \"F\" AND T2.Election_Cycle  =  \"Spring\"",
        "amends": [
            "Do use `avg(T1.Age)` with table alias instead of `AVG(age)` without qualification. Do join `STUDENT AS T1` with `VOTING_RECORD AS T2` instead of querying only `students` table. Do use join condition `T1.StuID = SECRETARY_Vote` instead of filtering `secretary_votes > 0`. Do filter `T1.Sex = \"F\"` instead of `sex = 'M'`. Do filter `T2.Election_Cycle = \"Spring\"` instead of `election_cycle = 'spring'`. The amended query now correctly joins tables and applies proper filters to match the intended behavior."
        ],
        "rules": [
            "1) When answering about average age of female students with secretary votes in spring election: make sure the output order: average age of T1.Age. 2) When the question mentions \"female students\": \"female\" actually means \"T1.Sex = 'F'\" in schema. 3) When the question mentions \"secretary votes\": \"secretary votes\" actually means joining T1 with T2 where T1.StuID = SECRETARY_Vote. 4) When the question mentions \"spring election cycle\": \"spring\" actually means \"T2.Election_Cycle = 'Spring'\" in schema. 5) When combining T1 and T2 for shared entities: link rows where T1.StuID = SECRETARY_Vote exactly as shown in the amends; keep only matching pairs (inner match). 6) When computing average age: use avg(T1.Age) with table alias qualification instead of unqualified AVG(age)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age) FROM students WHERE sex = 'M' AND election_cycle = 'spring' AND secretary_votes > 0",
            "SELECT AVG(T1.Age) \nFROM Student AS T1\nJOIN Voting_record AS T2 ON T1.StuID = T2.Secretary_Vote\nWHERE T1.Sex = 'F' AND T2.Election_Cycle = 'Spring'"
        ],
        "rule_sql": [
            "SELECT AVG(T1.Age) \nFROM Student T1\nJOIN Voting_record T2 ON T1.StuID = T2.Secretary_Vote\nWHERE T1.Sex = 'F' AND T2.Election_Cycle = 'Spring'"
        ]
    },
    "1788": {
        "db_id": "small_bank_1",
        "question": "What is the checking balance of the account whose owner\u2019s name contains the substring \u2018ee\u2019?",
        "ground_truth": "SELECT T2.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid WHERE T1.name LIKE '%ee%'",
        "amends": [
            "Do select `T2.balance` from the `checking` table instead of `balance` from the `accounts` table. Do join `checking AS T2` on `T1.custid = T2.custid` instead of querying only the `accounts` table. Do filter on `T1.name LIKE '%ee%'` instead of `owner_name LIKE '%ee%'` to use the correct column name from the joined table. Do add table aliasing with `AS T1` and `AS T2` instead of omitting aliases for clarity. The amended query now correctly retrieves balance information from the checking table based on customer name patterns, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about checking balance: select T2.balance from the checking table instead of balance from the accounts table. 2) When the question mentions account owner's name: \"owner's name\" actually means T1.name in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.custid = T2.custid and keep only matching pairs (inner match). 4) When filtering for names containing 'ee': use T1.name LIKE '%ee%' with exact literal 'ee' and wildcards."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT balance FROM accounts WHERE owner_name LIKE '%ee%';",
            "SELECT T2.balance FROM ACCOUNTS AS T1 JOIN CHECKING AS T2 ON T1.custid = T2.custid WHERE T1.name LIKE '%ee%'"
        ],
        "rule_sql": [
            "SELECT T2.balance \nFROM ACCOUNTS T1 \nINNER JOIN CHECKING T2 ON T1.custid = T2.custid \nWHERE T1.name LIKE '%ee%'"
        ]
    },
    "942": {
        "db_id": "medicine_enzyme_interaction",
        "question": "What is the product, chromosome, and porphyria of the enzymes located at 'Cytosol'?",
        "ground_truth": "SELECT product ,  chromosome ,  porphyria FROM enzyme WHERE LOCATION  =  'Cytosol'",
        "amends": [
            "Do reference table `enzyme` instead of `enzymes` in the FROM clause. Do use column name `LOCATION` instead of `location` in the WHERE filter condition. The amended query now correctly references the proper table name and column name to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks about enzymes: use table \"enzyme\" instead of \"enzymes\" as the data source. 2) When filtering by location 'Cytosol': use column \"LOCATION\" (in uppercase) instead of \"location\" for the comparison. 3) When the question specifies output columns: maintain the exact order of product, chromosome, and porphyria in the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT product, chromosome, porphyria FROM enzymes WHERE location = 'Cytosol';",
            "SELECT Product, Chromosome, Porphyria FROM enzyme WHERE Location = 'Cytosol';"
        ],
        "rule_sql": [
            "SELECT Product, Chromosome, Porphyria FROM enzyme WHERE LOCATION = 'Cytosol';"
        ]
    },
    "4984": {
        "db_id": "soccer_2",
        "question": "Which position is most popular among players in the tryout?",
        "ground_truth": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference table `tryout` instead of `players` and use column `pPos` instead of `position` in both SELECT and GROUP BY clauses. Do remove the explicit `COUNT(*) as count` column alias and WHERE filter `tryout_status = 'yes'` instead of including them, as the aggregation handles the counting without filtering. Do use the aggregate function directly in ORDER BY as `count(*)` instead of referencing the alias `count`. Do maintain the `DESC` ordering and `LIMIT 1` unchanged. The amended query now correctly aggregates positions from the tryout table without unnecessary filtering and matches the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"most popular position among players in the tryout\": use table \"tryout\" instead of \"players\" and column \"pPos\" instead of \"position\". 2) When counting entities in the tryout: count all rows using count(*) without filtering by tryout_status. 3) When grouping by position: group by the exact column \"pPos\" from table \"tryout\". 4) When finding the most popular position: order the results by count(*) in descending order and keep only the top 1 result."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT position, COUNT(*) as count FROM players WHERE tryout_status = 'yes' GROUP BY position ORDER BY count DESC LIMIT 1;",
            "SELECT pPos FROM Tryout GROUP BY pPos ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT pPos, COUNT(*) as count FROM Tryout GROUP BY pPos ORDER BY count DESC LIMIT 1;"
        ]
    },
    "2497": {
        "db_id": "movie_1",
        "question": "What are the movie titles with the highest average rating and what are those ratings?",
        "ground_truth": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT 1",
        "amends": [
            "Do reference the `Rating` table as `T1` and `Movie` table as `T2` instead of only using a single `movies` table. Do join `T1` and `T2` on `T1.mID = T2.mID` instead of querying a single table without joins. Do aggregate by `T1.mID` instead of grouping by `title` to ensure proper grouping by movie identifier. Do calculate the average of `T1.stars` instead of `rating` to use the correct column name. Do order by `avg(T1.stars)` instead of the alias `average_rating` to reference the actual aggregate expression. Do limit to `1` result instead of `5` to return only the top-rated movie. The amended query now correctly joins rating data with movie information and returns the single highest-rated movie."
        ],
        "rules": [
            "1) When answering about \"movie titles with the highest average rating\": make sure the output order: T2.title, avg(T1.stars). 2) When the question mentions \"highest average rating\": rank rows by avg(T1.stars) in descending direction and keep the first 1 row. 3) When combining Rating table as T1 and Movie table as T2: link rows where T1.mID = T2.mID exactly; keep only matching pairs (inner match). 4) When calculating average rating: compute the average of T1.stars instead of rating to use the correct column name. 5) When grouping movies: organize results by T1.mID instead of title to ensure proper grouping by movie identifier. 6) When ordering results: order by avg(T1.stars) instead of the alias average_rating to reference the actual aggregate expression."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title, AVG(rating) as average_rating FROM movies GROUP BY title ORDER BY average_rating DESC LIMIT 5;",
            "SELECT T2.title, AVG(T1.stars) as average_rating\nFROM Rating T1\nJOIN Movie T2 ON T1.mID = T2.mID\nGROUP BY T1.mID\nORDER BY AVG(T1.stars) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.title, avg(T1.stars) \nFROM Rating AS T1 \nINNER JOIN Movie AS T2 ON T1.mID = T2.mID \nGROUP BY T1.mID \nORDER BY avg(T1.stars) DESC \nLIMIT 1"
        ]
    },
    "5940": {
        "db_id": "cre_Theme_park",
        "question": "Find the id and star rating of each hotel and sort them in increasing order of price.",
        "ground_truth": "SELECT hotel_id ,  star_rating_code FROM HOTELS ORDER BY price_range ASC",
        "amends": [
            "Do select `hotel_id` and `star_rating_code` instead of `id` and `star_rating`. Do order by `price_range` instead of `star_rating`. The amended query now correctly references the appropriate column names and ordering criteria to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"id\" of hotels: use the exact column token \"hotel_id\" from the Hotels table instead of \"id\". 2) When the question asks for \"star rating\" of hotels: use the exact column token \"star_rating_code\" from the Hotels table instead of \"star_rating\". 3) When the question requires sorting in increasing order of price: order by the exact column token \"price_range\" in ascending direction instead of \"star_rating\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, star_rating FROM hotels ORDER BY star_rating ASC;",
            "SELECT hotel_id, star_rating_code FROM Hotels ORDER BY price_range ASC;"
        ],
        "rule_sql": [
            "SELECT hotel_id, star_rating_code FROM Hotels ORDER BY price_range ASC;"
        ]
    },
    "4836": {
        "db_id": "aircraft",
        "question": "What is all the information on the airport with the largest number of international passengers?",
        "ground_truth": "SELECT * FROM airport ORDER BY International_Passengers DESC LIMIT 1",
        "amends": [
            "Do reference the `airport` table instead of `airports` in the FROM clause. Do order by `International_Passengers` instead of `domestic_passengers` in the ORDER BY clause. The amended query now correctly identifies the airport with the highest international passenger count rather than domestic passengers."
        ],
        "rules": [
            "1) When answering about \"airport with the largest number of international passengers\": use the table \"airport\" not \"airports\" in the FROM clause. 2) When ordering to find the airport with the highest international passenger count: order by \"International_Passengers\" in descending direction instead of \"domestic_passengers\". 3) When retrieving all information about the top-ranked airport: use LIMIT 1 to get only the single row with the maximum value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM airports ORDER BY domestic_passengers DESC LIMIT 1;",
            "SELECT * FROM airport ORDER BY International_Passengers DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT * FROM airport ORDER BY International_Passengers DESC LIMIT 1;"
        ]
    },
    "2094": {
        "db_id": "pilot_record",
        "question": "Show the fleet series of the aircrafts flied by pilots younger than 34",
        "ground_truth": "SELECT T2.Fleet_Series FROM pilot_record AS T1 JOIN aircraft AS T2 ON T1.Aircraft_ID  =  T2.Aircraft_ID JOIN pilot AS T3 ON T1.Pilot_ID  =  T3.Pilot_ID WHERE T3.Age  <  34",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of full table names. Do reference `T2.Fleet_Series` instead of `fleet_series`. Do join through an intermediate `pilot_record` table `T1` instead of directly joining `aircrafts` to `pilots`. Do use `JOIN aircraft AS T2 ON T1.Aircraft_ID = T2.Aircraft_ID` instead of `JOIN pilots ON aircrafts.pilot_id = pilots.id`. Do add an additional `JOIN pilot AS T3 ON T1.Pilot_ID = T3.Pilot_ID` instead of omitting this relationship. Do change the filter to `T3.Age < 34` instead of `pilots.age > 34`, reversing both the column reference and the inequality operator. The amended query now correctly follows the three-table relationship through the pilot_record junction table and applies the proper age filter."
        ],
        "rules": [
            "1) When answering about \"fleet series of aircrafts flied by pilots younger than 34\": make sure the output order: T2.Fleet_Series\n2) When combining tables for pilot records: use T1 as the pilot_record junction table to link aircrafts (T2) and pilots (T3) through T1.Aircraft_ID = T2.Aircraft_ID and T1.Pilot_ID = T3.Pilot_ID\n3) When filtering for pilots younger than 34: use T3.Age < 34 instead of age > 34, reversing both the column reference and inequality operator\n4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for T2.Fleet_Series\n5) When handling text literals: do not change case, spacing, or punctuation for any values in the query"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT fleet_series FROM aircrafts JOIN pilots ON aircrafts.pilot_id = pilots.id WHERE pilots.age > 34;",
            "SELECT T2.Fleet_Series \nFROM pilot_record AS T1\nJOIN aircraft AS T2 ON T1.Aircraft_ID = T2.Aircraft_ID\nJOIN pilot AS T3 ON T1.Pilot_ID = T3.Pilot_ID\nWHERE T3.Age < 34"
        ],
        "rule_sql": [
            "SELECT T2.Fleet_Series \nFROM pilot_record T1\nJOIN aircraft T2 ON T1.Aircraft_ID = T2.Aircraft_ID\nJOIN pilot T3 ON T1.Pilot_ID = T3.Pilot_ID\nWHERE T3.Age < 34\nORDER BY T2.Fleet_Series"
        ]
    },
    "1006": {
        "db_id": "university_basketball",
        "question": "What are the schools that were either founded before 1850 or are public?",
        "ground_truth": "SELECT school FROM university WHERE founded  >  1850 OR affiliation  =  'Public'",
        "amends": [
            "Do select `school` instead of `name` and use table `university` instead of `schools`. Do filter on `founded > 1850` instead of `founded_year > 1850` and use condition `affiliation = 'Public'` instead of `type = 'private'`. The amended query now correctly retrieves public universities founded after 1850 from the university table.",
            "Do use lowercase column names `founded` and `affiliation` instead of capitalized `Founded` and `Affiliation`. Do change the comparison operator to `>` instead of `<` for the `founded` column, filtering for universities founded after 1850 rather than before 1850. The amended query now correctly matches the intended logic of selecting schools from universities founded after 1850 or with public affiliation."
        ],
        "rules": [
            "1) When the question asks about schools: use the table \"university\" instead of \"schools\" and select the column \"school\" instead of \"name\". 2) When filtering by founding year: use the column \"Founded\" instead of \"founded_year\" and apply the condition \"Founded > 1850\" for schools founded after 1850. 3) When filtering by school type: use the column \"Affiliation\" instead of \"type\" and apply the condition \"Affiliation = 'Public'\" for public schools. 4) When combining conditions for schools that were either founded before 1850 or are public: use OR logic between \"Founded < 1850\" and \"Affiliation = 'Public'\" conditions.",
            "1) When the question mentions \"founded before 1850\": use the exact column name \"founded\" (lowercase) and comparison operator \">\" to filter for universities founded after 1850. 2) When the question mentions \"public\" schools: use the exact column name \"affiliation\" (lowercase) and literal value 'Public' (with capital P) to filter for public affiliation. 3) When combining multiple conditions with \"or\": include rows that satisfy either the founded condition (founded > 1850) or the affiliation condition (affiliation = 'Public')."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM schools WHERE founded_year > 1850 OR type = 'private';",
            "SELECT school FROM university WHERE Founded < 1850 OR Affiliation = 'Public';",
            "SELECT school FROM university WHERE founded > 1850 OR affiliation = 'Public';"
        ],
        "rule_sql": [
            "SELECT School FROM university WHERE Founded < 1850 OR Affiliation = 'Public'"
        ]
    },
    "256": {
        "db_id": "musical",
        "question": "Show names of musicals and the number of actors who have appeared in the musicals.",
        "ground_truth": "SELECT T2.Name ,  COUNT(*) FROM actor AS T1 JOIN musical AS T2 ON T1.Musical_ID  =  T2.Musical_ID GROUP BY T1.Musical_ID",
        "amends": [
            "Do join `musical AS T2` on `T1.Musical_ID = T2.Musical_ID` instead of querying only the `actors` table. Do select `T2.Name` instead of `musical_name` from the original table. Do use `COUNT(*)` instead of `COUNT(actor_id)` to count all rows in the group. Do group by `T1.Musical_ID` instead of `musical_name` to ensure proper aggregation with the joined table structure. The amended query now correctly retrieves musical names from the musical table while counting actors per musical through the proper join relationship."
        ],
        "rules": [
            "1) When answering about \"names of musicals and the number of actors who have appeared in the musicals\": make sure the output order: T2.Name, COUNT(*). 2) When combining actors table as T1 and musical table as T2: link rows where T1.Musical_ID = T2.Musical_ID and keep only matching pairs (inner match). 3) When counting actors per musical: compute the number of rows using COUNT(*) for each musical group. 4) When grouping results by musical: organize results by T1.Musical_ID to ensure proper aggregation with the joined table structure. 5) When selecting musical names: select T2.Name from the musical table instead of musical_name from the actors table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT musical_name, COUNT(actor_id) FROM actors GROUP BY musical_name;",
            "SELECT T2.Name, COUNT(*) AS actor_count FROM actor AS T1 JOIN musical AS T2 ON T1.Musical_ID = T2.Musical_ID GROUP BY T1.Musical_ID"
        ],
        "rule_sql": [
            "SELECT T2.Name, COUNT(*) \nFROM actor AS T1 \nINNER JOIN musical AS T2 ON T1.Musical_ID = T2.Musical_ID \nGROUP BY T1.Musical_ID \nORDER BY T2.Name, COUNT(*)"
        ]
    },
    "1740": {
        "db_id": "gymnast",
        "question": "List the total points of gymnasts in descending order of floor exercise points.",
        "ground_truth": "SELECT Total_Points FROM gymnast ORDER BY Floor_Exercise_Points DESC",
        "amends": [
            "Do select `Total_Points` instead of `name, floor_exercise_points`. Do order by `Floor_Exercise_Points DESC` instead of `total_points DESC`. Do query from table `gymnast` instead of `gymnasts`. The amended query now correctly selects the total points column and orders by floor exercise points as specified in the target query."
        ],
        "rules": [
            "1) When answering about \"total points of gymnasts\": select \"Total_Points\" from table \"gymnast\". 2) When ordering results in descending order of floor exercise points: order by \"Floor_Exercise_Points DESC\". 3) When the question mentions \"gymnasts\": the correct table name is \"gymnast\" (not \"gymnasts\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, floor_exercise_points FROM gymnasts ORDER BY total_points DESC;",
            "SELECT Total_Points FROM gymnast ORDER BY Floor_Exercise_Points DESC;"
        ],
        "rule_sql": [
            "SELECT Total_Points FROM gymnast ORDER BY Floor_Exercise_Points DESC;"
        ]
    },
    "5554": {
        "db_id": "products_gen_characteristics",
        "question": "How many characteristics does the product named \"sesame\" have?",
        "ground_truth": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id WHERE t1.product_name  =  \"sesame\"",
        "amends": [
            "Do add `JOIN product_characteristics AS t2 ON t1.product_id = t2.product_id` instead of querying only the `products` table. Do use `product_name` instead of `name` in the WHERE filter. Do add table alias `t1` for the products table instead of omitting it. Do use double quotes around 'sesame' instead of single quotes. The amended query now correctly joins the product characteristics table and uses the proper column name for filtering, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"how many characteristics does the product named 'sesame' have\": make sure to join the product_characteristics table as t2 with the products table as t1 using t1.product_id = t2.product_id. 2) When the question mentions \"product named 'sesame'\": use \"product_name\" instead of \"name\" in the WHERE filter with exact literal \"sesame\". 3) When counting characteristics for a product: count the number of rows from the product_characteristics table (t2) that match the product_id of the specified product."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM products WHERE name = 'sesame';",
            "SELECT COUNT(*) \nFROM Products AS t1\nJOIN Product_Characteristics AS t2 ON t1.product_id = t2.product_id\nWHERE t1.product_name = \"sesame\""
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Products t1\nJOIN Product_Characteristics t2 ON t1.product_id = t2.product_id\nWHERE t1.product_name = 'sesame';"
        ]
    },
    "5879": {
        "db_id": "tracking_share_transactions",
        "question": "Show the id and details for the investors who have the top 3 number of transactions.",
        "ground_truth": "SELECT T2.investor_id ,  T1.Investor_details FROM INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id GROUP BY T2.investor_id ORDER BY COUNT(*) DESC LIMIT 3",
        "amends": [
            "Do specify `T2.investor_id` and `T1.Investor_details` in the SELECT list instead of `id` and `details`. Do add `FROM INVESTORS AS T1 JOIN TRANSACTIONS AS T2` instead of omitting the JOIN. Do use `ON T1.investor_id = T2.investor_id` for the join condition instead of missing the join entirely. Do add `GROUP BY T2.investor_id` instead of omitting grouping. Do use `COUNT(*)` in ORDER BY instead of `COUNT(transactions)`. The amended query now correctly joins the tables, groups by investor, and counts transactions to identify the top investors."
        ],
        "rules": [
            "1) When answering about \"top 3 number of transactions\": make sure the output order: T2.investor_id, T1.Investor_details 2) When combining INVESTORS and TRANSACTIONS tables: link rows where T1.investor_id = T2.investor_id and keep only matching pairs (inner match) 3) When counting transactions per investor: compute the number of rows using COUNT(*) and group by T2.investor_id 4) When the question mentions \"top 3\": rank rows by transaction count in descending order and keep the first 3 rows"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, details FROM investors ORDER BY COUNT(transactions) DESC LIMIT 3;",
            "SELECT T2.investor_id, T1.Investor_details\nFROM Investors AS T1\nJOIN Transactions AS T2 ON T1.investor_id = T2.investor_id\nGROUP BY T2.investor_id\nORDER BY COUNT(*) DESC\nLIMIT 3;"
        ],
        "rule_sql": [
            "SELECT T2.investor_id, T1.Investor_details\nFROM Investors T1\nINNER JOIN Transactions T2 ON T1.investor_id = T2.investor_id\nGROUP BY T2.investor_id, T1.Investor_details\nORDER BY COUNT(*) DESC\nLIMIT 3"
        ]
    },
    "4540": {
        "db_id": "document_management",
        "question": "What are the different role codes for users, and how many users have each?",
        "ground_truth": "SELECT count(*) ,  role_code FROM users GROUP BY role_code",
        "amends": [
            "Do select `count(*)` and `role_code` instead of `role_code` and `COUNT(*)`. Do group by `role_code` instead of `user_id` to correctly count users by role rather than counting each user individually. The amended query now matches the intended behavior of counting users grouped by their role codes.",
            "Do place `role_code` after the aggregate function instead of before it in the SELECT list. Do use lowercase `users` instead of uppercase `Users` as the table name. The amended query now correctly groups by role_code while counting all records, matching the intended behavior.",
            "Do place `role_code` after `count(*)` in the SELECT list instead of before it, maintaining the same aggregation logic and GROUP BY clause. The amended query now matches RIGHT_SQL's behavior.",
            "Do place `role_code` after the aggregate function in the SELECT list instead of before it, maintaining the same logical grouping by `role_code` but with proper column ordering that follows standard SQL conventions where aggregates typically precede grouping columns. The amended query now matches RIGHT_SQL's behavior with identical results.",
            "Do place `role_code` after `count(*)` in the SELECT list instead of before it, maintaining the same aggregation logic but altering the column order. Do keep the `COUNT(*)` aggregate function and `GROUP BY role_code` clause unchanged as they correctly calculate counts per role category. The amended query now matches RIGHT_SQL's behavior with identical results but different column ordering."
        ],
        "rules": [
            "1) When the question asks for \"different role codes for users\" and \"how many users have each\": select the exact column \"role_code\" and count the number of users per role code. 2) When counting users by role code: group the results by the exact column \"role_code\" instead of \"user_id\" to correctly count users grouped by their role codes. 3) When producing output columns: order them as count first followed by role_code to match the intended behavior.",
            "1) When the question asks for different role codes and their user counts: use the exact table name \"users\" (lowercase) instead of \"Users\" (uppercase). 2) When grouping by role_code and counting users: place the role_code column before the aggregate count function in the output order. 3) When counting users per role code: count all records using the canonical grouping by role_code to get the number of users for each role code type.",
            "1) When answering about \"different role codes for users and how many users have each\": make sure the output order: count of users first, then role_code. 2) When the question asks for \"how many users have each\" role code: compute the number of rows using the canonical key for users (role_code) and group by role_code. 3) When producing output columns: place the count result before the role_code value in the output.",
            "1) When answering about \"different role codes for users and how many users have each\": make sure the output order: count of users first, then role_code. 2) When the question asks for \"how many users have each\" role code: compute the number of rows using the canonical key for users (role_code) and group by role_code. 3) When producing output columns: place the aggregate count column before the grouping column role_code in the result set.",
            "1) When answering about \"different role codes for users and how many users have each\": make sure the output order: count of users first, then role_code. 2) When the question asks for \"count of users\": compute the number of rows using the canonical key for users from the schema. 3) When the question says \"per role_code\"/\"by role_code\": organize results by the exact token \"role_code\" and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT role_code, COUNT(*) FROM users GROUP BY user_id;",
            "SELECT role_code, COUNT(*) FROM Users GROUP BY role_code;",
            "SELECT role_code, COUNT(*) FROM users GROUP BY role_code;",
            "SELECT role_code, COUNT(*) FROM users GROUP BY role_code;",
            "SELECT role_code, COUNT(*) FROM users GROUP BY role_code;",
            "SELECT count(*), role_code FROM users GROUP BY role_code"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS user_count, role_code FROM users GROUP BY role_code ORDER BY user_count DESC, role_code;"
        ]
    },
    "2509": {
        "db_id": "movie_1",
        "question": "What is the name of the movie that has been reviewed the most?",
        "ground_truth": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `T2.title` and `T1.mID` to the SELECT list instead of only `title`. Do change the FROM clause to use `Rating AS T1 JOIN Movie AS T2 ON T1.mID = T2.mID` instead of a single table. Do add `GROUP BY T1.mID` to aggregate by movie ID instead of no grouping. Do change the ORDER BY to `count(*) DESC` instead of `movie_id DESC` to order by rating count rather than movie ID. Do keep `LIMIT 1` to return only the top result. The amended query now correctly identifies the movie with the most ratings by joining the Rating and Movie tables, grouping by movie ID, counting the ratings, and ordering by the count in descending order.",
            "Do include `T2.title` in the SELECT list instead of omitting it, and do remove `COUNT(*) as rating_count` from the SELECT list instead of keeping it. Do maintain the same FROM clause with `JOIN Movie AS T2 ON T1.mID = T2.mID` without changes. Do preserve the GROUP BY on `T1.mID` without modification. Do keep the ORDER BY `count(*) DESC` and LIMIT 1 clauses unchanged. The amended query now correctly selects only the movie title and ID while counting ratings for ordering purposes, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"movie that has been reviewed the most\": make sure the output order: T2.title, T1.mID 2) When combining Rating and Movie tables: link rows where T1.mID = T2.mID and keep only matching pairs (inner match) 3) When counting reviews per movie: group by T1.mID and compute the number of rows using T1.mID as the counting key 4) When ordering by review count: rank rows by count(*) in descending direction and keep the first 1 row 5) When the question asks for \"the most reviewed\": use count(*) to determine the movie with the highest number of reviews",
            "1) When answering about \"the movie that has been reviewed the most\": make sure the output order: T2.title, T1.mID\n2) When counting reviews: count using the canonical key T1.mID for grouping and ordering purposes\n3) When combining Rating (T1) and Movie (T2) tables: link rows where T1.mID = T2.mID and keep only matching pairs (inner match)\n4) When finding the most reviewed movie: rank rows by count of reviews in descending order and keep only the first 1 row\n5) When the question asks for the movie name: include T2.title in the output instead of omitting it\n6) When producing final output: remove aggregate count columns like rating_count from the SELECT list"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM movies ORDER BY movie_id DESC LIMIT 1;",
            "SELECT T2.title, T1.mID, COUNT(*) as rating_count\nFROM Rating AS T1 \nJOIN Movie AS T2 ON T1.mID = T2.mID\nGROUP BY T1.mID\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T2.title, T1.mID\nFROM Rating AS T1\nJOIN Movie AS T2 ON T1.mID = T2.mID\nGROUP BY T1.mID\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.title, T1.mID\nFROM Rating T1\nINNER JOIN Movie T2 ON T1.mID = T2.mID\nGROUP BY T1.mID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "6902": {
        "db_id": "tracking_orders",
        "question": "Which orders are made by the customer named \"Jeramie\"? Give me the order ids and status.",
        "ground_truth": "SELECT T2.order_id ,  T2.order_status FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T1.customer_name = \"Jeramie\"",
        "amends": [
            "Do use explicit table aliases `T2.order_id` and `T2.order_status` instead of bare column references `order_id` and `status`. Do add a `JOIN` between `customers AS T1` and `orders AS T2` on `T1.customer_id = T2.customer_id` instead of querying only the `orders` table. Do reference the customer name filter through the joined table as `T1.customer_name = \"Jeramie\"` instead of filtering directly on the orders table. Do use double quotes around the string literal instead of single quotes. The amended query now correctly joins customer and order data to match the intended logic."
        ],
        "rules": [
            "1) When answering about orders made by a specific customer: join customers table as T1 and orders table as T2 using T1.customer_id = T2.customer_id to link customer and order data. 2) When filtering by customer name \"Jeramie\": use T1.customer_name = \"Jeramie\" with double quotes around the literal. 3) When selecting order information: use explicit table aliases T2.order_id and T2.order_status instead of bare column references. 4) When combining customer and order tables: perform an inner join to keep only matching pairs where customer IDs are equal."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT order_id, status FROM orders WHERE customer_name = 'Jeramie';",
            "SELECT T2.order_id, T2.order_status FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id = T2.customer_id WHERE T1.customer_name = \"Jeramie\""
        ],
        "rule_sql": [
            "SELECT T2.order_id, T2.order_status\nFROM Customers AS T1\nINNER JOIN Orders AS T2 ON T1.customer_id = T2.customer_id\nWHERE T1.customer_name = \"Jeramie\""
        ]
    },
    "3593": {
        "db_id": "music_1",
        "question": "Return the names of songs for which format is mp3 and resolution is below 1000.",
        "ground_truth": "SELECT T2.song_name FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.formats  =  \"mp3\" INTERSECT SELECT song_name FROM song WHERE resolution  <  1000",
        "amends": [
            "Do select `T2.song_name` from the `song` table instead of `name` from the `songs` table. Do use a `JOIN` between `files AS T1` and `song AS T2` on `T1.f_id = T2.f_id` instead of querying only the `songs` table. Do filter with `T1.formats = \"mp3\"` instead of `format = 'mp3'` and use `INTERSECT` to combine with another query instead of a single WHERE clause. Do add a second query `SELECT song_name FROM song WHERE resolution < 1000` instead of using `resolution > 1000` and intersect the results rather than using AND logic. The amended query now correctly uses table relationships and set operations to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"names of songs\": make sure the output order: T2.song_name. 2) When the question mentions \"format is mp3\": \"format\" actually means \"T1.formats\" in schema and the literal must be exactly \"mp3\". 3) When the question mentions \"resolution is below 1000\": use the condition T2.resolution < 1000. 4) When combining files and song tables: link rows where T1.f_id = T2.f_id and keep only matching pairs (inner match). 5) When filtering for both conditions: use INTERSECT to combine results from the query for T1.formats = \"mp3\" and the query for T2.resolution < 1000."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM songs WHERE format = 'mp3' AND resolution > 1000;",
            "SELECT T2.song_name FROM files AS T1 JOIN song AS T2 ON T1.f_id = T2.f_id WHERE T1.formats = 'mp3' INTERSECT SELECT song_name FROM song WHERE resolution < 1000"
        ],
        "rule_sql": [
            "SELECT T2.song_name\nFROM files T1\nJOIN song T2 ON T1.f_id = T2.f_id\nWHERE T1.formats = 'mp3'\nINTERSECT\nSELECT T2.song_name\nFROM files T1\nJOIN song T2 ON T1.f_id = T2.f_id\nWHERE T2.resolution < 1000\nORDER BY T2.song_name;"
        ]
    },
    "6409": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "Show the document name and the document date for all documents on project with details 'Graph Database project'.",
        "ground_truth": "SELECT document_name ,  document_date FROM Documents AS T1 JOIN projects AS T2 ON T1.project_id  =  T2.project_id WHERE T2.project_details  =  'Graph Database project'",
        "amends": [
            "Do add a `JOIN` with `projects AS T2` on `T1.project_id = T2.project_id` instead of querying only the `documents` table. Do change the table reference to `Documents AS T1` instead of just `documents`. Do move the filter condition to reference `T2.project_details = 'Graph Database project'` instead of filtering directly on `document_details`. The amended query now correctly joins the documents and projects tables to filter based on project details rather than incorrectly assuming project details exist in the documents table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about documents and projects: combine tables Documents AS T1 and projects AS T2 using the exact join condition T1.project_id = T2.project_id, keeping only matching pairs (inner match). 2) When the question mentions filtering by project details 'Graph Database project': apply the filter condition T2.project_details = 'Graph Database project' exactly as specified. 3) When showing document information: output the columns document_name and document_date from table T1 in that order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_name, document_date FROM documents WHERE project_details = 'Graph Database project'",
            "SELECT T1.Document_Name, T1.Document_Date \nFROM Documents AS T1 \nJOIN Projects AS T2 ON T1.Project_ID = T2.Project_ID \nWHERE T2.Project_Details = 'Graph Database project'"
        ],
        "rule_sql": [
            "SELECT T1.document_name, T1.document_date \nFROM Documents AS T1 \nINNER JOIN Projects AS T2 ON T1.project_id = T2.project_id \nWHERE T2.project_details = 'Graph Database project'"
        ]
    },
    "2907": {
        "db_id": "icfp_1",
        "question": "Which papers have the substring \"Database\" in their titles? Show the titles of the papers.",
        "ground_truth": "SELECT title FROM papers WHERE title LIKE \"%Database%\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM papers WHERE title LIKE '%Database%';"
        ],
        "rule_sql": [
            "SELECT title FROM Papers WHERE title LIKE '%Database%';"
        ]
    },
    "6199": {
        "db_id": "music_4",
        "question": "Please show the results of music festivals and the number of music festivals that have had each, ordered by this count.",
        "ground_truth": "SELECT RESULT ,  COUNT(*) FROM music_festival GROUP BY RESULT ORDER BY COUNT(*) DESC",
        "amends": [
            "Do select `RESULT` instead of `festival_name` and remove the alias `festival_count` instead of keeping it. Do reference table `music_festival` instead of `music_festivals`. Do order by `COUNT(*)` directly instead of using the alias `festival_count`. The amended query now correctly counts results grouped by the RESULT column from the music_festival table."
        ],
        "rules": [
            "1) When answering about \"music festivals and the number of music festivals that have had each\": make sure the output order: RESULT, COUNT(*) 2) When the question asks for \"results of music festivals\": \"results\" actually means \"RESULT in schema\" 3) When the question asks for \"count of music festivals\": compute the number of rows using the canonical key from the music_festival table 4) When the question says \"ordered by this count\": order the results by COUNT(*) in descending direction 5) When the question says \"per RESULT\"/\"by RESULT\": organize results by the token for RESULT and compute COUNT(*) per group 6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms 7) When handling text literals: do not change case, spacing, or punctuation"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT festival_name, COUNT(*) as festival_count FROM music_festivals GROUP BY festival_name ORDER BY festival_count DESC;",
            "SELECT RESULT, COUNT(*) FROM music_festival GROUP BY RESULT ORDER BY COUNT(*);"
        ],
        "rule_sql": [
            "SELECT \"Result\", COUNT(*) \nFROM \"music_festival\" \nGROUP BY \"Result\" \nORDER BY COUNT(*) DESC"
        ]
    },
    "1134": {
        "db_id": "climbing",
        "question": "Show the distinct names of mountains climbed by climbers from country \"West Germany\".",
        "ground_truth": "SELECT DISTINCT T2.Name FROM climber AS T1 JOIN mountain AS T2 ON T1.Mountain_ID  =  T2.Mountain_ID WHERE T1.Country  =  \"West Germany\"",
        "amends": [
            "Do reference the `mountain` table via `T2.Name` instead of directly querying `mountain_name` from an unspecified source. Do join `climber` table as `T1` with `mountain` table as `T2` on `T1.Mountain_ID = T2.Mountain_ID` instead of querying a single table without proper relationships. Do filter on `T1.Country = \"West Germany\"` instead of filtering on `country` from an undefined context. The amended query now correctly retrieves mountain names by establishing the proper relationship between climbers and mountains through the join condition."
        ],
        "rules": [
            "1) When answering about \"distinct names of mountains climbed by climbers from country 'West Germany'\": make sure the output order: T2.Name. 2) When the question mentions \"climbers from country 'West Germany'\": \"country\" actually means \"T1.Country in schema\" and use exact literal \"West Germany\". 3) When combining T1 (climber) and T2 (mountain) for shared entities: link rows where T1.Mountain_ID = T2.Mountain_ID; keep only matching pairs (inner match). 4) When the question asks for \"distinct names\": compute the number of unique values of the exact token T2.Name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT mountain_name FROM climbers WHERE country = 'West Germany';",
            "SELECT DISTINCT T2.Name \nFROM climber T1 \nJOIN mountain T2 ON T1.Mountain_ID = T2.Mountain_ID \nWHERE T1.Country = 'West Germany'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.Name FROM climber T1 JOIN mountain T2 ON T1.Mountain_ID = T2.Mountain_ID WHERE T1.Country = 'West Germany' ORDER BY T2.Name;"
        ]
    },
    "3843": {
        "db_id": "e_learning",
        "question": "Which students not enrolled in any course? Find their personal names.",
        "ground_truth": "SELECT personal_name FROM Students EXCEPT SELECT T1.personal_name FROM Students AS T1 JOIN Student_Course_Enrolment AS T2 ON T1.student_id  =  T2.student_id",
        "amends": [
            "Do use `EXCEPT` with a subquery to exclude enrolled students instead of filtering for `course_id IS NULL`. Do add a `JOIN` between `Students AS T1` and `Student_Course_Enrolment AS T2` on `T1.student_id = T2.student_id` instead of omitting the enrollment table entirely. Do reference `T1.personal_name` in the subquery instead of directly selecting from the base table. The amended query now correctly identifies students not enrolled in any courses by excluding those with enrollment records, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When identifying students not enrolled in any course: use an EXCEPT operation to exclude students who have enrollment records from the complete set of students. 2) When combining Students (T1) and Student_Course_Enrolment (T2) tables: link rows where T1.student_id = T2.student_id to identify enrolled students. 3) When selecting personal names of non-enrolled students: reference T1.personal_name from the Students table after excluding enrolled students. 4) When checking for enrollment status: do not filter for course_id IS NULL directly, instead exclude students who appear in the enrollment table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT personal_name FROM students WHERE course_id IS NULL;",
            "SELECT personal_name FROM Students\nEXCEPT\nSELECT T1.personal_name \nFROM Students AS T1\nJOIN Student_Course_Enrolment AS T2 ON T1.student_id = T2.student_id"
        ],
        "rule_sql": [
            "SELECT personal_name FROM Students\nEXCEPT\nSELECT s.personal_name \nFROM Students s\nJOIN Student_Course_Enrolment sce ON s.student_id = sce.student_id;"
        ]
    },
    "6351": {
        "db_id": "school_bus",
        "question": "Show the name of drivers in descending order of age.",
        "ground_truth": "SELECT name FROM driver ORDER BY age DESC",
        "amends": [
            "Do reference table `driver` instead of `drivers` to use the correct table name. Do use `DESC` ordering instead of `ASC` to sort by age in descending order instead of ascending. The amended query now correctly selects from the proper table and applies the intended descending sort order."
        ],
        "rules": [
            "1) When the question asks about drivers: use the exact table name \"driver\" instead of \"drivers\". 2) When the question specifies \"descending order of age\": sort by the age column in descending order (DESC) instead of ascending order (ASC)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM drivers ORDER BY age ASC;",
            "SELECT Name FROM driver ORDER BY Age DESC;"
        ],
        "rule_sql": [
            "SELECT Name FROM driver ORDER BY Age DESC;"
        ]
    },
    "6969": {
        "db_id": "culture_company",
        "question": "What are the years, titles, and publishers for all books, ordered by year descending?",
        "ground_truth": "SELECT YEAR ,  book_title ,  publisher FROM book_club ORDER BY YEAR DESC",
        "amends": [
            "Do reference table `book_club` instead of `books`. Do select column `book_title` instead of `title`. Do use descending order with `DESC` instead of ascending order with `ASC`. Do capitalize `YEAR` consistently throughout the query instead of using lowercase `year`. The amended query now correctly retrieves data from the book_club table with the appropriate column names and sorting order."
        ],
        "rules": [
            "1) When answering about books: use table \"book_club\" instead of \"books\". 2) When selecting book title information: use column \"book_title\" instead of \"title\". 3) When ordering by year: use descending order with \"DESC\" instead of ascending order. 4) When referring to the year column: use \"YEAR\" (uppercase) consistently throughout instead of lowercase \"year\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, title, publisher FROM books ORDER BY year ASC;",
            "SELECT Year, Book_Title, Publisher FROM book_club ORDER BY Year DESC;"
        ],
        "rule_sql": [
            "SELECT Year, Book_Title, Publisher FROM book_club ORDER BY Year DESC;"
        ]
    },
    "6764": {
        "db_id": "activity_1",
        "question": "What are the ids of the faculty members who do not advise any student.",
        "ground_truth": "SELECT FacID FROM Faculty EXCEPT SELECT advisor FROM Student",
        "amends": [
            "Do use `EXCEPT` set operation instead of a `LEFT JOIN` with `WHERE` filter. Do select `FacID` from `Faculty` instead of `f.id` from `faculty f`. Do select `advisor` from `Student` instead of joining on `students s` with `ON f.id = s.advisor_id`. Do remove the `WHERE s.advisor_id IS NOT NULL` condition instead of keeping it, as the `EXCEPT` operation inherently excludes matching rows. Do change the table aliasing approach, removing the `f` alias from `faculty` and using the proper table name `Faculty` instead of `faculty`. The amended query now correctly identifies faculty members who are not assigned as advisors to any students, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting faculty identifiers: use \"FacID\" from \"Faculty\" table instead of f.id from faculty f. 2) When finding faculty who do not advise any students: use EXCEPT set operation instead of LEFT JOIN with WHERE filter. 3) When referencing student advisor relationships: use \"advisor\" column from \"Student\" table instead of s.advisor_id from students s. 4) When using EXCEPT operation: do not include WHERE conditions as EXCEPT inherently excludes matching rows. 5) When handling table names: use exact case-sensitive identifiers \"Faculty\" and \"Student\" as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT f.id FROM faculty f LEFT JOIN students s ON f.id = s.advisor_id WHERE s.advisor_id IS NOT NULL",
            "SELECT FacID FROM Faculty\nEXCEPT\nSELECT Advisor FROM Student WHERE Advisor IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT FacID FROM Faculty\nEXCEPT\nSELECT Advisor FROM Student WHERE Advisor IS NOT NULL"
        ]
    },
    "3846": {
        "db_id": "e_learning",
        "question": "Find the common login name of course authors and students.",
        "ground_truth": "SELECT login_name FROM Course_Authors_and_Tutors INTERSECT SELECT login_name FROM Students",
        "amends": [
            "Do remove `DISTINCT` from both sides of the `INTERSECT` instead of keeping it, as `INTERSECT` inherently returns distinct values. Do use table name `Course_Authors_and_Tutors` instead of `course_authors` to reference the correct source table. The amended query now matches RIGHT_SQL's behavior by correctly finding the intersection of login names between the two tables without redundant DISTINCT operations."
        ],
        "rules": [
            "1) When the question asks for common login names between course authors and students: use the exact table name \"Course_Authors_and_Tutors\" instead of \"course_authors\" to reference the correct source table. 2) When using INTERSECT to find common values between two tables: do not use DISTINCT on either side of the INTERSECT operation, as INTERSECT inherently returns distinct values without redundant DISTINCT operations."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT login_name FROM course_authors INTERSECT SELECT DISTINCT login_name FROM students;",
            "SELECT login_name FROM Course_Authors_and_Tutors INTERSECT SELECT login_name FROM Students"
        ],
        "rule_sql": [
            "SELECT login_name FROM Course_Authors_and_Tutors INTERSECT SELECT login_name FROM Students;"
        ]
    },
    "4895": {
        "db_id": "school_player",
        "question": "What are the denominations used by both schools founded before 1890 and schools founded  after 1900?",
        "ground_truth": "SELECT Denomination FROM school WHERE Founded  <  1890 INTERSECT SELECT Denomination FROM school WHERE Founded  >  1900",
        "amends": [
            "Do use `INTERSECT` between two separate queries instead of a single `WHERE` clause with conflicting conditions. Do reference the table as `school` instead of `schools` and use proper column casing with `Denomination` and `Founded` instead of lowercase `denomination` and `founded`. Do remove the logically impossible condition `founded < 1890 AND founded > 1900` and instead use separate queries for values less than 1890 and greater than 1900 combined with set intersection. The amended query now correctly finds denominations that exist in both pre-1890 and post-1900 schools, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for denominations used by both schools founded before 1890 and schools founded after 1900: use set intersection between two separate queries instead of a single WHERE clause with conflicting conditions. 2) When referencing the school table: use the exact table name \"school\" instead of \"schools\". 3) When selecting denomination values: use the exact column name \"Denomination\" with proper casing. 4) When filtering by founding year: use the exact column name \"Founded\" with proper casing. 5) When finding schools founded before 1890: select denominations where \"Founded\" < 1890. 6) When finding schools founded after 1900: select denominations where \"Founded\" > 1900. 7) When combining results from both time periods: use set intersection to find denominations that exist in both the pre-1890 and post-1900 result sets."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT denomination FROM schools WHERE founded < 1890 AND founded > 1900;",
            "SELECT Denomination FROM school WHERE Founded < 1890\nINTERSECT\nSELECT Denomination FROM school WHERE Founded > 1900"
        ],
        "rule_sql": [
            "SELECT Denomination FROM school WHERE Founded < 1890\nINTERSECT\nSELECT Denomination FROM school WHERE Founded > 1900;"
        ]
    },
    "2149": {
        "db_id": "local_govt_in_alabama",
        "question": "Which events id does not have any participant with detail 'Kenyatta Kuhn'?",
        "ground_truth": "SELECT event_id FROM EVENTS EXCEPT SELECT T1.event_id FROM Participants_in_Events AS T1 JOIN Participants AS T2 ON T1.Participant_ID  =  T2.Participant_ID WHERE Participant_Details  =  'Kenyatta Kuhn'",
        "amends": [
            "Do select from `EVENTS` instead of `participants` and use `EXCEPT` instead of a simple filter. Do add a join between `Participants_in_Events` and `Participants` on `Participant_ID` instead of querying participants directly. Do filter on `Participant_Details = 'Kenyatta Kuhn'` instead of `detail != 'Kenyatta Kuhn'` to exclude events containing this participant rather than including non-matching details. Do structure the query to find all events except those with the specified participant instead of attempting to filter participants directly. The amended query now correctly identifies events that do not contain the specified participant by using set exclusion logic."
        ],
        "rules": [
            "1) When answering about events without a specific participant: select from the \"EVENTS\" table instead of the \"Participants\" table. 2) When excluding events that contain a participant with specific details: use set exclusion logic (EXCEPT) instead of simple filtering. 3) When combining event and participant information: join \"Participants_in_Events\" and \"Participants\" tables on \"Participant_ID\" = \"Participant_ID\". 4) When filtering for participant details: use exact literal matching with \"Participant_Details = 'Kenyatta Kuhn'\" (case-sensitive). 5) When identifying events without a specific participant: find all events except those that have any participant matching the specified detail condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT event_id FROM participants WHERE detail != 'Kenyatta Kuhn'",
            "SELECT Event_ID FROM Events\nEXCEPT\nSELECT pie.Event_ID\nFROM Participants_in_Events pie\nJOIN Participants p ON pie.Participant_ID = p.Participant_ID\nWHERE p.Participant_Details = 'Kenyatta Kuhn'"
        ],
        "rule_sql": [
            "SELECT Event_ID FROM Events\nEXCEPT\nSELECT pie.Event_ID\nFROM Participants_in_Events pie\nJOIN Participants p ON pie.Participant_ID = p.Participant_ID\nWHERE p.Participant_Details = 'Kenyatta Kuhn'"
        ]
    },
    "3921": {
        "db_id": "hospital_1",
        "question": "Find the number of patients' prescriptions physician John Dorian made.",
        "ground_truth": "SELECT count(T1.SSN) FROM patient AS T1 JOIN prescribes AS T2 ON T1.SSN  =  T2.patient JOIN physician AS T3 ON T2.physician  =  T3.employeeid WHERE T3.name = \"John Dorian\"",
        "amends": [
            "Do select `count(T1.SSN)` instead of `COUNT(*)` to count specific patient identifiers rather than all rows. Do join `patient AS T1` and `physician AS T3` through `prescribes AS T2` instead of querying only the `prescriptions` table to properly relate patients to physicians. Do use the join condition `T1.SSN = T2.patient` and `T2.physician = T3.employeeid` instead of the incorrect physician name filter to establish correct table relationships. Do filter on `T3.name = \"John Dorian\"` in the WHERE clause instead of directly filtering on a physician_name column that doesn't exist in the prescriptions table. The amended query now correctly counts patients treated by physician John Dorian by properly joining the patient, prescribes, and physician tables with appropriate relationship conditions."
        ],
        "rules": [
            "1) When counting patients' prescriptions: count using the exact token T1.SSN instead of counting all rows. 2) When relating patients to physicians through prescriptions: join patient AS T1, prescribes AS T2, and physician AS T3 using the exact join conditions T1.SSN = T2.patient and T2.physician = T3.employeeid. 3) When filtering for physician John Dorian: use the exact filter T3.name = \"John Dorian\" instead of filtering on a non-existent physician_name column. 4) When combining tables for shared entities: perform inner matches using the exact key equalities shown in the join conditions to keep only matching pairs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM prescriptions WHERE physician_name = 'John Dorian';",
            "SELECT COUNT(T1.SSN) \nFROM patient AS T1\nJOIN prescribes AS T2 ON T1.SSN = T2.patient\nJOIN physician AS T3 ON T2.physician = T3.EmployeeID\nWHERE T3.Name = 'John Dorian'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.SSN) \nFROM patient AS T1\nINNER JOIN prescribes AS T2 ON T1.SSN = T2.patient\nINNER JOIN physician AS T3 ON T2.physician = T3.employeeid\nWHERE T3.name = \"John Dorian\""
        ]
    },
    "6857": {
        "db_id": "flight_4",
        "question": "List the cities which have more than 2 airports sorted by the number of airports.",
        "ground_truth": "SELECT city FROM airports GROUP BY city HAVING count(*)  >  2 ORDER BY count(*)",
        "amends": [
            "Do remove the `COUNT(*) as airport_count` column from the SELECT list instead of including it, and do reference `count(*)` directly in both the HAVING clause and ORDER BY clause instead of using the alias `airport_count`. The amended query now matches RIGHT_SQL's behavior by eliminating the unnecessary column output while maintaining the same filtering and sorting logic based on the count of airports per city."
        ],
        "rules": [
            "1) When answering about \"cities with more than 2 airports\": make sure the output order: city\n2) When the question asks for \"count of airports per city\": compute the number of rows using count(*) and group by city\n3) When the question mentions \"more than 2 airports\": apply the condition count(*) > 2\n4) When the question says \"sorted by the number of airports\": order the results by count(*) in descending order\n5) When producing output: do not include the count(*) column in the final results, only show the city column"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, COUNT(*) as airport_count FROM airports GROUP BY city HAVING airport_count > 2 ORDER BY airport_count DESC;",
            "SELECT city FROM airports GROUP BY city HAVING COUNT(*) > 2 ORDER BY COUNT(*) DESC"
        ],
        "rule_sql": [
            "SELECT city FROM airports GROUP BY city HAVING COUNT(*) > 2 ORDER BY COUNT(*) DESC;"
        ]
    },
    "5808": {
        "db_id": "customer_complaints",
        "question": "Find the number of complaints with Product Failure type for each complaint status.",
        "ground_truth": "SELECT complaint_status_code ,  count(*) FROM complaints WHERE complaint_type_code  =  \"Product Failure\" GROUP BY complaint_status_code",
        "amends": [
            "Do select `complaint_status_code` instead of `status` in the SELECT list. Do use `complaint_status_code` instead of `complaint_type` in the GROUP BY clause. Do filter on `complaint_type_code = \"Product Failure\"` instead of `complaint_type = 'Product Failure'` in the WHERE clause. The amended query now correctly groups by complaint status codes while filtering for product failure complaints, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for complaint status: use the exact column token \"complaint_status_code\" instead of \"status\" in both SELECT and GROUP BY clauses. 2) When filtering for Product Failure type complaints: use the exact condition \"complaint_type_code = \\\"Product Failure\\\"\" with double quotes around the literal value. 3) When counting complaints per status: count all rows that match the Product Failure filter condition, grouped by complaint_status_code."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT status, COUNT(*) FROM complaints WHERE complaint_type = 'Product Failure' GROUP BY complaint_type;",
            "SELECT complaint_status_code, COUNT(*) AS number_of_complaints\nFROM Complaints\nWHERE complaint_type_code = 'Product Failure'\nGROUP BY complaint_status_code;"
        ],
        "rule_sql": [
            "SELECT complaint_status_code, COUNT(*) AS number_of_complaints\nFROM Complaints\nWHERE complaint_type_code = \"Product Failure\"\nGROUP BY complaint_status_code;"
        ]
    },
    "73": {
        "db_id": "student_assessment",
        "question": "Find id of the candidate whose email is stanley.monahan@example.org?",
        "ground_truth": "SELECT T2.candidate_id FROM people AS T1 JOIN candidates AS T2 ON T1.person_id = T2.candidate_id WHERE T1.email_address = \"stanley.monahan@example.org\"",
        "amends": [
            "Do select `T2.candidate_id` instead of `id` from the candidate table. Do use `people AS T1 JOIN candidates AS T2` instead of querying only the `candidate` table. Do join on `T1.person_id = T2.candidate_id` instead of no join condition. Do filter on `T1.email_address = \"stanley.monahan@example.org\"` instead of `email = 'stanley.monahan@example.com'` with different column name and email domain. The amended query now correctly joins people and candidates tables to find the candidate ID associated with the given email address."
        ],
        "rules": [
            "1) When the question asks for \"id of the candidate\": select \"T2.candidate_id\" instead of \"id\" from the candidate table. 2) When combining people and candidates tables: use \"people AS T1 JOIN candidates AS T2\" with join condition \"T1.person_id = T2.candidate_id\" to link matching rows. 3) When filtering by email address \"stanley.monahan@example.org\": use exact literal \"stanley.monahan@example.org\" and filter on \"T1.email_address\" column instead of \"email\" column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM candidate WHERE email = 'stanley.monahan@example.com';",
            "SELECT T2.candidate_id \nFROM people AS T1 \nJOIN candidates AS T2 ON T1.person_id = T2.candidate_id \nWHERE T1.email_address = 'stanley.monahan@example.org'"
        ],
        "rule_sql": [
            "SELECT T2.candidate_id \nFROM People AS T1 \nJOIN Candidates AS T2 ON T1.person_id = T2.candidate_id \nWHERE T1.email_address = 'stanley.monahan@example.org'"
        ]
    },
    "975": {
        "db_id": "medicine_enzyme_interaction",
        "question": "find the number of medicines offered by each trade.",
        "ground_truth": "SELECT trade_name ,  count(*) FROM medicine GROUP BY trade_name",
        "amends": [
            "Do reference `trade_name` instead of `trade` in the SELECT list. Do use `medicine` as the table name instead of `medicines` in the FROM clause. Do group by `trade_name` instead of `medicine_name` to match the selected column. The amended query now correctly counts records grouped by trade names from the medicine table."
        ],
        "rules": [
            "1) When the question asks for \"number of medicines offered by each trade\": count the number of rows using the canonical key for medicines and group by the exact token \"trade_name\". 2) When selecting the trade column: use the exact identifier \"trade_name\" in the SELECT list. 3) When referencing the medicines table: use the exact table name \"medicine\" instead of \"medicines\" in the FROM clause. 4) When grouping results: group by the exact identifier \"trade_name\" to match the selected column and ensure proper aggregation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT trade, COUNT(*) FROM medicines GROUP BY medicine_name;",
            "SELECT Trade_Name, COUNT(*) AS number_of_medicines FROM medicine GROUP BY Trade_Name"
        ],
        "rule_sql": [
            "SELECT trade_name, COUNT(id) AS number_of_medicines FROM medicine GROUP BY trade_name;"
        ]
    },
    "5877": {
        "db_id": "tracking_share_transactions",
        "question": "Show the description of the transaction type that occurs most frequently.",
        "ground_truth": "SELECT T1.transaction_type_description FROM Ref_Transaction_Types AS T1 JOIN TRANSACTIONS AS T2 ON T1.transaction_type_code  =  T2.transaction_type_code GROUP BY T1.transaction_type_code ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.transaction_type_description` instead of `description` and add `FROM Ref_Transaction_Types AS T1 JOIN TRANSACTIONS AS T2 ON T1.transaction_type_code = T2.transaction_type_code` instead of just `FROM transaction_types`. Do add `GROUP BY T1.transaction_type_code` instead of omitting it to properly aggregate the count. The amended query now correctly joins the reference table with transactions and groups by transaction type code to find the most frequent transaction type description."
        ],
        "rules": [
            "1) When answering about \"the transaction type that occurs most frequently\": make sure the output order: T1.transaction_type_description. 2) When combining T1 and T2 for shared entities: link rows where T1.transaction_type_code = T2.transaction_type_code; keep only matching pairs (inner match). 3) When the question asks for \"count of transactions\": compute the number of rows using the canonical key token T2.transaction_type_code. 4) When the question mentions \"most frequently\": rank rows by count of transactions in descending order and keep the first 1 row. 5) When the question says \"per transaction type\": organize results by T1.transaction_type_code and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description FROM transaction_types ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T1.transaction_type_description\nFROM Ref_Transaction_Types AS T1\nJOIN Transactions AS T2 ON T1.transaction_type_code = T2.transaction_type_code\nGROUP BY T1.transaction_type_code\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.transaction_type_description\nFROM Ref_Transaction_Types T1\nINNER JOIN Transactions T2 ON T1.transaction_type_code = T2.transaction_type_code\nGROUP BY T1.transaction_type_code, T1.transaction_type_description\nORDER BY COUNT(T2.transaction_type_code) DESC\nLIMIT 1;"
        ]
    },
    "6340": {
        "db_id": "e_government",
        "question": "Which is the email of the party that has used the services the most number of times?",
        "ground_truth": "SELECT t1.party_email FROM parties AS t1 JOIN party_services AS t2 ON t1.party_id  =  t2.customer_id GROUP BY t1.party_email ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `t1.party_email` instead of `email` and add an explicit table alias. Do add `FROM parties AS t1 JOIN party_services AS t2 ON t1.party_id = t2.customer_id` instead of just `FROM parties`, introducing a join with the party_services table on the correct relationship `t1.party_id = t2.customer_id`. Do add `GROUP BY t1.party_email` instead of omitting it, which is necessary for the aggregate function to work properly. Do keep `ORDER BY count(*) DESC LIMIT 1` as it correctly orders by the count of records per group. The amended query now correctly counts party service records per email address and returns the most frequently occurring one, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"the party that has used the services the most number of times\": make sure the output order: t1.party_email. 2) When the question mentions \"email\": \"email\" actually means \"t1.party_email in schema\". 3) When combining T1 and T2 for shared entities: link rows where t1.party_id = t2.customer_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"count of services used\": compute the number of rows using the canonical key from the relationship (count of party_services records per party). 5) When the question asks for \"the most number of times\": rank rows by count(*) in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT email FROM parties ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT t1.party_email \nFROM parties AS t1 \nJOIN party_services AS t2 ON t1.party_id = t2.customer_id \nGROUP BY t1.party_email \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT t1.party_email\nFROM Parties t1\nINNER JOIN Party_Services t2 ON t1.party_id = t2.customer_id\nGROUP BY t1.party_id, t1.party_email\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "1991": {
        "db_id": "phone_market",
        "question": "Show the names of phones that have total number of stocks bigger than 2000, in descending order of the total number of stocks.",
        "ground_truth": "SELECT T2.Name FROM phone_market AS T1 JOIN phone AS T2 ON T1.Phone_ID  =  T2.Phone_ID GROUP BY T2.Name HAVING sum(T1.Num_of_stock)  >=  2000 ORDER BY sum(T1.Num_of_stock) DESC",
        "amends": [
            "Do select `T2.Name` from joined tables instead of `name` from a single table. Do use `FROM phone_market AS T1 JOIN phone AS T2` with an explicit join instead of `FROM phones` alone. Do add the join condition `ON T1.Phone_ID = T2.Phone_ID` instead of omitting any table relationship. Do add `GROUP BY T2.Name` for aggregation instead of no grouping. Do move the stock filter to `HAVING sum(T1.Num_of_stock) >= 2000` instead of `WHERE stock > 2000` to properly aggregate before filtering. Do order by `sum(T1.Num_of_stock) DESC` instead of `stock ASC` to sort by the aggregated total in descending order. The amended query now correctly aggregates stock across multiple market entries and filters based on the sum rather than individual values, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"phones that have total number of stocks bigger than 2000\": make sure the output order: T2.Name, sum(T1.Num_of_stock) DESC\n2) When the question mentions \"names of phones\": \"names\" actually means \"T2.Name in schema\"\n3) When the question mentions \"total number of stocks\": \"total number of stocks\" actually means \"sum(T1.Num_of_stock) in schema\"\n4) When combining T1 and T2 for shared entities: link rows where T1.Phone_ID = T2.Phone_ID; keep only matching pairs (inner match)\n5) When the question asks for \"phones that have total number of stocks bigger than 2000\": compute sum(T1.Num_of_stock) per T2.Name and filter to keep only groups where sum(T1.Num_of_stock) >= 2000\n6) When the question says \"in descending order of the total number of stocks\": rank rows by sum(T1.Num_of_stock) in descending direction"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM phones WHERE stock > 2000 ORDER BY stock ASC;",
            "SELECT T2.Name\nFROM phone_market AS T1\nJOIN phone AS T2 ON T1.Phone_ID = T2.Phone_ID\nGROUP BY T2.Name\nHAVING SUM(T1.Num_of_stock) > 2000\nORDER BY SUM(T1.Num_of_stock) DESC;"
        ],
        "rule_sql": [
            "SELECT T2.Name, SUM(T1.Num_of_stock) AS total_stocks\nFROM phone_market T1\nINNER JOIN phone T2 ON T1.Phone_ID = T2.Phone_ID\nGROUP BY T2.Name\nHAVING SUM(T1.Num_of_stock) > 2000\nORDER BY SUM(T1.Num_of_stock) DESC;"
        ]
    },
    "6829": {
        "db_id": "flight_4",
        "question": "Find the name, city, and country of the airport that has the lowest altitude.",
        "ground_truth": "SELECT name ,  city ,  country FROM airports ORDER BY elevation LIMIT 1",
        "amends": [
            "Do order by `elevation` instead of `altitude DESC` to use the correct column name and ascending order instead of descending order. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the airport with the \"lowest altitude\": use the column \"elevation\" from table airports instead of \"altitude\" as it represents the correct schema term for altitude measurement. 2) When ordering to find the lowest value: sort by \"elevation\" in ascending order (lowest to highest) rather than descending order. 3) When selecting airport details: include the columns \"name\", \"city\", and \"country\" from the airports table to match the requested information."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, city, country FROM airports ORDER BY altitude DESC LIMIT 1;",
            "SELECT name, city, country FROM airports ORDER BY elevation ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT name, city, country FROM airports ORDER BY elevation ASC LIMIT 1;"
        ]
    },
    "1172": {
        "db_id": "body_builder",
        "question": "What are the total scores of the body builders whose birthday contains the string \"January\" ?",
        "ground_truth": "SELECT T1.total FROM body_builder AS T1 JOIN people AS T2 ON T1.people_id  =  T2.people_id WHERE T2.Birth_Date LIKE \"%January%\";",
        "amends": [
            "Do use `T1.total` instead of `SUM(score)` for the SELECT expression. Do join `body_builder AS T1` with `people AS T2` instead of querying only `body_builders`. Do apply the join condition `T1.people_id = T2.people_id` instead of having no join. Do filter on `T2.Birth_Date LIKE \"%January%\"` instead of `birthday LIKE '%January%'` to reference the correct table and column. Do remove the aggregate function since `T1.total` already contains the pre-calculated value instead of summing individual scores. The amended query now correctly retrieves total scores from body_builder while filtering by birth month from the related people table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"total scores of body builders\": use T1.total instead of summing individual scores. 2) When the question mentions \"body builders\": query the body_builder table as T1. 3) When combining body_builder and people tables: link rows where T1.people_id = T2.people_id and keep only matching pairs (inner match). 4) When filtering by birthday containing \"January\": apply the condition T2.Birth_Date LIKE \"%January%\" to reference the correct table and column. 5) When handling text literals: preserve the exact string \"January\" with proper case and spacing in the LIKE pattern."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(score) FROM body_builders WHERE birthday LIKE '%January%';",
            "SELECT T1.Total \nFROM body_builder AS T1 \nJOIN people AS T2 ON T1.People_ID = T2.People_ID \nWHERE T2.Birth_Date LIKE '%January%'"
        ],
        "rule_sql": [
            "SELECT T1.Total\nFROM body_builder AS T1\nINNER JOIN people AS T2 ON T1.People_ID = T2.People_ID\nWHERE T2.Birth_Date LIKE '%January%'"
        ]
    },
    "6616": {
        "db_id": "train_station",
        "question": "Show the station name with at least two trains.",
        "ground_truth": "SELECT T2.name FROM train_station AS T1 JOIN station AS T2 ON T1.station_id  =  T2.station_id GROUP BY T1.station_id HAVING count(*)  >=  2",
        "amends": [
            "Do select `T2.name` from the `station` table instead of `station_name` from the `trains` table. Do join `train_station AS T1` with `station AS T2` on `T1.station_id = T2.station_id` instead of querying only the `trains` table. Do group by `T1.station_id` instead of `station_name`. Do use `count(*) >= 2` instead of `COUNT(*) > 1` to include stations with exactly 2 trains. The amended query now correctly identifies station names with multiple trains by joining the appropriate tables and using the proper threshold."
        ],
        "rules": [
            "1) When answering about \"station name with at least two trains\": make sure the output order: T2.name 2) When the question mentions \"station name\": \"station name\" actually means \"T2.name in schema\" 3) When combining T1 (train_station) and T2 (station) for shared entities: link rows where T1.station_id = T2.station_id exactly as shown; keep only matching pairs (inner match) 4) When the question asks for \"at least two trains\": use count(*) >= 2 to include stations with exactly 2 trains 5) When grouping by station: organize results by T1.station_id instead of station_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT station_name FROM trains GROUP BY station_name HAVING COUNT(*) > 1;",
            "SELECT T2.Name \nFROM train_station AS T1 \nJOIN station AS T2 ON T1.Station_ID = T2.Station_ID \nGROUP BY T1.Station_ID \nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T2.Name FROM train_station T1 JOIN station T2 ON T1.Station_ID = T2.Station_ID GROUP BY T1.Station_ID HAVING COUNT(*) >= 2 ORDER BY T2.Name;"
        ]
    },
    "5132": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "What are the phones and emails of workshop groups in which services are performed?",
        "ground_truth": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID",
        "amends": [
            "Do use `T1.Store_Phone` and `T1.Store_Email_Address` instead of `wg.phone` and `wg.email` for column selection. Do reference `Drama_Workshop_Groups AS T1` instead of `workshop_groups wg` as the source table with correct table name and alias. Do use `Services AS T2` instead of `services s` for the joined table with proper table name and alias. Do join on `T1.Workshop_Group_ID = T2.Workshop_Group_ID` instead of `wg.group_id = s.group_id` with correct join column names. Do remove the `WHERE s.service_performed = 1` filter instead of keeping it, as the right query omits this condition entirely. The amended query now correctly retrieves store contact information without the service performance filter, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When selecting phone and email information from workshop groups: use T1.Store_Phone and T1.Store_Email_Address as the exact output columns. 2) When referencing the workshop groups table: use Drama_Workshop_Groups AS T1 as the exact table name and alias. 3) When joining with services information: use Services AS T2 as the exact table name and alias. 4) When combining workshop groups and services tables: link rows where T1.Workshop_Group_ID = T2.Workshop_Group_ID using an inner match. 5) When the question asks about workshop groups where services are performed: do not apply any service performance filter condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT wg.phone, wg.email \nFROM workshop_groups wg\nJOIN services s ON wg.group_id = s.group_id\nWHERE s.service_performed = 1;",
            "SELECT T1.Store_Phone, T1.Store_Email_Address \nFROM Drama_Workshop_Groups AS T1\nJOIN Services AS T2 ON T1.Workshop_Group_ID = T2.Workshop_Group_ID"
        ],
        "rule_sql": [
            "SELECT T1.Store_Phone, T1.Store_Email_Address\nFROM Drama_Workshop_Groups AS T1\nINNER JOIN Services AS T2 ON T1.Workshop_Group_ID = T2.Workshop_Group_ID"
        ]
    },
    "2433": {
        "db_id": "candidate_poll",
        "question": "What is all the information about all people?",
        "ground_truth": "SELECT * FROM people",
        "amends": [
            "Do query the `people` table instead of the `employees` table, as the data source has been changed to reflect the correct underlying dataset. The amended query now matches RIGHT_SQL's behavior by selecting all columns from the appropriate table."
        ],
        "rules": [
            "1) When the question asks for information about people: use the \"people\" table instead of the \"employees\" table as the data source. 2) When selecting all information about entities: retrieve all columns from the appropriate table using the exact table name specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM employees;",
            "SELECT * FROM people;"
        ],
        "rule_sql": [
            "SELECT * FROM people;"
        ]
    },
    "1676": {
        "db_id": "theme_gallery",
        "question": "What are the average, minimum, and maximum ticket prices for exhibitions that happened prior to 2009?",
        "ground_truth": "SELECT avg(ticket_price) ,  min(ticket_price) ,  max(ticket_price) FROM exhibition WHERE YEAR  <  2009",
        "amends": [
            "Do use lowercase `avg`, `min`, and `max` function names instead of uppercase `AVG`, `MIN`, and `MAX`. Do reference table `exhibition` instead of `exhibitions`. Do change the WHERE filter to `YEAR < 2009` instead of `year > 2009`, which reverses the date comparison logic to include earlier years rather than later years. The amended query now correctly calculates statistics for exhibitions before 2009 rather than after 2009, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for average, minimum, and maximum ticket prices: use lowercase function names avg, min, and max. 2) When referencing the exhibitions table: use the exact table name \"exhibition\" instead of \"exhibitions\". 3) When filtering for exhibitions prior to 2009: use the condition YEAR < 2009 to include years before 2009 rather than after 2009."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(ticket_price), MIN(ticket_price), MAX(ticket_price) \nFROM exhibitions \nWHERE year > 2009;",
            "SELECT avg(Ticket_Price) as average_ticket_price, min(Ticket_Price) as minimum_ticket_price, max(Ticket_Price) as maximum_ticket_price FROM exhibition WHERE Year < 2009"
        ],
        "rule_sql": [
            "SELECT avg(Ticket_Price), min(Ticket_Price), max(Ticket_Price) FROM exhibition WHERE Year < 2009"
        ]
    },
    "966": {
        "db_id": "medicine_enzyme_interaction",
        "question": "What are the different names, locations, and products of the enzymes that are capable inhibitor interactions?",
        "ground_truth": "SELECT DISTINCT T1.name ,  T1.location ,  T1.product FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.enzyme_id  =  T1.id WHERE T2.interaction_type  =  'inhibitor'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate results. Do select from `enzyme AS T1` instead of `enzymes` with proper table aliasing. Do add `JOIN medicine_enzyme_interaction AS T2` instead of querying a single table. Do use join condition `T2.enzyme_id = T1.id` instead of no join predicate. Do move filter to `WHERE T2.interaction_type = 'inhibitor'` instead of `WHERE inhibitor_interactions = 'capable'` to correctly reference the interaction type column in the joined table. The amended query now correctly identifies enzymes with inhibitor interactions through proper table joining and filtering."
        ],
        "rules": [
            "1) When answering about enzymes with inhibitor interactions: make sure the output order: name, location, product. 2) When the question mentions \"capable inhibitor interactions\": \"capable inhibitor interactions\" actually means \"interaction_type = 'inhibitor' in T2.medicine_enzyme_interaction\". 3) When selecting from multiple tables: use enzyme AS T1 and JOIN medicine_enzyme_interaction AS T2 with join condition T2.enzyme_id = T1.id, keeping only matching pairs (inner match). 4) When eliminating duplicate results: use DISTINCT on the selected columns. 5) When handling text literals: use exact literal 'inhibitor' with proper case and no quotes modification."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, location, product FROM enzymes WHERE inhibitor_interactions = 'capable';",
            "SELECT DISTINCT T1.name, T1.Location, T1.Product FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.enzyme_id = T1.id WHERE T2.interaction_type = 'inhibitor'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.name, T1.Location, T1.Product\nFROM enzyme AS T1\nJOIN medicine_enzyme_interaction AS T2 ON T2.enzyme_id = T1.id\nWHERE T2.interaction_type = 'inhibitor'"
        ]
    },
    "5550": {
        "db_id": "products_gen_characteristics",
        "question": "List all the product names with the color description \"white\".",
        "ground_truth": "SELECT t1.product_name FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code WHERE t2.color_description  =  \"white\"",
        "amends": [
            "Do reference `t1.product_name` with table alias instead of `product_name` without qualification. Do add `JOIN ref_colors AS t2` instead of querying only the products table. Do use join condition `t1.color_code = t2.color_code` instead of direct color comparison. Do filter on `t2.color_description = \"white\"` instead of `color = 'white'` to properly use the reference table for color lookup. The amended query now correctly joins to the color reference table to match products by color code rather than relying on potentially inconsistent color values in the products table."
        ],
        "rules": [
            "1) When answering about \"product names with color description 'white'\": make sure the output order: t1.product_name 2) When the question mentions \"color description 'white'\": \"color description 'white'\" actually means \"t2.color_description = 'white'\" in schema 3) When combining Products as T1 and ref_colors as T2 for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (t1.color_code = t2.color_code); keep only matching pairs (inner match) 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms 5) When handling text literals: do not change case, spacing, or punctuation - keep 'white' exactly as specified"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT product_name FROM products WHERE color = 'white';",
            "SELECT t1.product_name \nFROM Products AS t1\nJOIN Ref_Colors AS t2 ON t1.color_code = t2.color_code\nWHERE t2.color_description = 'white'"
        ],
        "rule_sql": [
            "SELECT t1.product_name\nFROM Products AS t1\nINNER JOIN Ref_Colors AS t2 ON t1.color_code = t2.color_code\nWHERE t2.color_description = 'white'\nORDER BY t1.product_name"
        ]
    },
    "4231": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "What are the codes of the locations with at least three documents?",
        "ground_truth": "SELECT location_code FROM Document_locations GROUP BY location_code HAVING count(*)  >=  3",
        "amends": [
            "Do query the `Document_locations` table instead of the `documents` table. Do use the comparison `>= 3` instead of `> 2` in the HAVING clause while keeping the same aggregate function `COUNT(*)`. The amended query now correctly filters for location codes that appear three or more times in the Document_locations table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"codes of locations with at least three documents\": query the \"Document_locations\" table instead of the \"documents\" table. 2) When counting occurrences of location codes: use COUNT(*) to count all rows per location code group. 3) When filtering for at least three documents: use the comparison >= 3 instead of > 2 in the HAVING clause to include locations with exactly three documents."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location_code FROM documents GROUP BY location_code HAVING COUNT(*) > 2",
            "SELECT Location_Code FROM Document_Locations GROUP BY Location_Code HAVING COUNT(*) >= 3"
        ],
        "rule_sql": [
            "SELECT Location_Code FROM Document_Locations GROUP BY Location_Code HAVING COUNT(*) >= 3"
        ]
    },
    "3120": {
        "db_id": "behavior_monitoring",
        "question": "What are the line 1 and average monthly rentals of all student addresses?",
        "ground_truth": "SELECT T1.line_1 ,  avg(T2.monthly_rental) FROM Addresses AS T1 JOIN Student_Addresses AS T2 ON T1.address_id  =  T2.address_id GROUP BY T2.address_id",
        "amends": [
            "Do specify `T1.line_1` with table alias instead of `line1` without qualification. Do use `avg(T2.monthly_rental)` with table alias instead of `AVG(monthly_rental)` without qualification. Do join `Addresses AS T1` and `Student_Addresses AS T2` instead of querying only `student_addresses`. Do add `ON T1.address_id = T2.address_id` join condition instead of omitting it. Do group by `T2.address_id` instead of `line1` to correctly aggregate by address identifier rather than address line text. The amended query now correctly calculates average monthly rental per address by properly joining the address and student address tables and grouping by the address identifier."
        ],
        "rules": [
            "1) When joining Addresses and Student_Addresses tables: use T1 for Addresses and T2 for Student_Addresses, and link rows where T1.address_id = T2.address_id exactly, keeping only matching pairs (inner match). 2) When selecting address line information: use T1.line_1 (with exact underscore) instead of line1. 3) When calculating average monthly rental: use avg(T2.monthly_rental) with table alias qualification. 4) When grouping by address identifier: group by T2.address_id instead of line text to correctly aggregate per address entity. 5) When answering about student addresses' line 1 and average monthly rentals: make sure the output order includes T1.line_1 first, then the average monthly rental calculation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT line1, AVG(monthly_rental) FROM student_addresses GROUP BY line1;",
            "SELECT T1.line_1, AVG(T2.monthly_rental) AS average_monthly_rental\nFROM Addresses AS T1\nJOIN Student_Addresses AS T2 ON T1.address_id = T2.address_id\nGROUP BY T2.address_id"
        ],
        "rule_sql": [
            "SELECT T1.line_1, AVG(T2.monthly_rental) AS average_monthly_rental\nFROM Addresses T1\nINNER JOIN Student_Addresses T2 ON T1.address_id = T2.address_id\nGROUP BY T2.address_id\nORDER BY T1.line_1, average_monthly_rental;"
        ]
    },
    "3957": {
        "db_id": "hospital_1",
        "question": "What is the alphabetically ordered list of all distinct medications?",
        "ground_truth": "SELECT DISTINCT name FROM medication ORDER BY name",
        "amends": [
            "Do select `name` instead of `medication` and use `DISTINCT` instead of omitting it. Do order by `name` instead of `medication ASC` and remove the explicit `ASC` specification since it's the default. Do query from `medication` table instead of `medications` table. The amended query now correctly returns distinct medication names from the medication table in alphabetical order."
        ],
        "rules": [
            "1) When the question asks for \"medications\": use the exact column token \"name\" from the medication table. 2) When selecting distinct values: use DISTINCT to return only unique values. 3) When ordering alphabetically: sort by the \"name\" column in ascending order (default). 4) When querying the medication data: use the exact table name \"medication\" (not \"medications\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT medication FROM medications ORDER BY medication ASC",
            "SELECT DISTINCT Name FROM Medication ORDER BY Name;"
        ],
        "rule_sql": [
            "SELECT DISTINCT name FROM medication ORDER BY name;"
        ]
    },
    "5603": {
        "db_id": "swimming",
        "question": "List all the event names by year from the most recent to the oldest.",
        "ground_truth": "SELECT name FROM event ORDER BY YEAR DESC",
        "amends": [
            "Do select `name` instead of `event_name` and `year`. Do reference table `event` instead of `events`. Do order by `YEAR DESC` instead of `year ASC`. Do remove the `year` column from the SELECT list instead of including it. The amended query now correctly selects only event names from the event table in descending year order."
        ],
        "rules": [
            "1) When the question asks for \"event names\": use the exact column token \"name\" from the event table. 2) When the question asks to list from \"most recent to the oldest\" by year: order the results by \"YEAR\" in descending order (DESC). 3) When the question asks for \"event names by year\" but only wants names in output: exclude the \"year\" column from the final output selection. 4) When referencing the events table: use the exact table name \"event\" (not \"events\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT event_name, year FROM events ORDER BY year ASC;",
            "SELECT name FROM event ORDER BY year DESC;"
        ],
        "rule_sql": [
            "SELECT name FROM event ORDER BY Year DESC;"
        ]
    },
    "4528": {
        "db_id": "document_management",
        "question": "Return the name of the document that has the most sections.",
        "ground_truth": "SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code GROUP BY t1.document_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `t1.document_name` instead of `name`. Do add `FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code = t2.document_code` instead of just `FROM documents`. Do add `GROUP BY t1.document_code` instead of omitting grouping. Do order by `count(*) DESC` instead of `section_count DESC`. The amended query now correctly joins with document_sections to count actual sections and returns the document with the highest section count."
        ],
        "rules": [
            "1) When answering about \"document with the most sections\": make sure the output order: t1.document_name. 2) When the question mentions \"name\": \"name\" actually means \"t1.document_name\" in schema. 3) When combining T1 (documents) and T2 (document_sections) for shared entities: link rows where t1.document_code = t2.document_code; keep only matching pairs (inner match). 4) When the question asks for \"count of sections\": compute the number of rows using the grouping by t1.document_code. 5) When the question asks for \"most sections\": rank rows by count(*) in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM documents ORDER BY section_count DESC LIMIT 1;",
            "SELECT t1.document_name\nFROM documents AS t1\nJOIN document_sections AS t2 ON t1.document_code = t2.document_code\nGROUP BY t1.document_code\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT t1.document_name\nFROM Documents t1\nINNER JOIN Document_Sections t2 ON t1.document_code = t2.document_code\nGROUP BY t1.document_code\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "2479": {
        "db_id": "movie_1",
        "question": "What are the names of all directors whose movies have been reviewed by Sarah Martinez?",
        "ground_truth": "SELECT DISTINCT T2.director FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T3.name  =  'Sarah Martinez'",
        "amends": [
            "Do use table aliases `T2` and `T3` instead of `d` and `r` for consistency with the schema. Do reference `T2.director` instead of `d.name` as the column to select. Do join `Rating AS T1` instead of `reviews r` as the rating table. Do join `Movie AS T2` instead of `movies m` with the condition `T1.mID = T2.mID` instead of `m.id = r.movie_id`. Do join `Reviewer AS T3` instead of filtering directly on reviewer name with the condition `T1.rID = T3.rID` instead of no reviewer table join. Do filter on `T3.name = 'Sarah Martinez'` instead of `r.reviewer_name = 'Sarah Martinez'` to use the proper reviewer table. The amended query now correctly identifies directors of movies reviewed by Sarah Martinez using the proper schema relationships."
        ],
        "rules": [
            "1) When answering about \"names of all directors whose movies have been reviewed by Sarah Martinez\": make sure the output order: T2.director\n2) When the question mentions \"directors\": \"directors\" actually means \"T2.director in schema\"\n3) When the question mentions \"Sarah Martinez\": use the exact literal 'Sarah Martinez' with proper case and spacing\n4) When combining T1 (Rating), T2 (Movie), and T3 (Reviewer) for shared entities: link rows where T1.mID = T2.mID and T1.rID = T3.rID; keep only matching pairs (inner match)\n5) When filtering for reviewer name: use T3.name = 'Sarah Martinez' instead of direct column filtering on rating table"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT d.name \nFROM directors d \nJOIN movies m ON d.id = m.director_id \nJOIN reviews r ON m.id = r.movie_id \nWHERE r.reviewer_name = 'Sarah Martinez';",
            "SELECT DISTINCT T2.director\nFROM Rating AS T1\nJOIN Movie AS T2 ON T1.mID = T2.mID\nJOIN Reviewer AS T3 ON T1.rID = T3.rID\nWHERE T3.name = 'Sarah Martinez'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.director\nFROM Rating T1\nJOIN Movie T2 ON T1.mID = T2.mID\nJOIN Reviewer T3 ON T1.rID = T3.rID\nWHERE T3.name = 'Sarah Martinez'\nORDER BY T2.director"
        ]
    },
    "4441": {
        "db_id": "network_2",
        "question": "What are the names and ages of every person who is a friend of both Dan and Alice?",
        "ground_truth": "SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Dan' INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Alice'",
        "amends": [
            "Do use `INTERSECT` to find mutual friends instead of multiple joins with subqueries. Do reference `Person` and `PersonFriend` tables instead of `persons` and `friends`. Do join on `T1.name = T2.name` instead of `p.id = f1.person_id`. Do filter directly with `T2.friend = 'Dan'` and `T2.friend = 'Alice'` instead of subqueries for friend IDs. Do structure as two separate SELECT statements combined with INTERSECT instead of a single query with multiple joins. The amended query now correctly identifies people who are friends with both Dan and Alice by intersecting the two friend sets."
        ],
        "rules": [
            "1) When the question asks for mutual friends of multiple people: use INTERSECT to combine results from separate queries for each person instead of multiple joins. 2) When referencing tables in this schema: use exact table names \"Person\" and \"PersonFriend\" instead of \"persons\" and \"friends\". 3) When joining tables: use the exact join condition T1.name = T2.name instead of ID-based joins. 4) When filtering for specific friends: use direct literal comparisons T2.friend = 'Dan' and T2.friend = 'Alice' instead of subqueries to find friend IDs. 5) When structuring queries for mutual relationships: create separate SELECT statements for each condition and combine them with INTERSECT operation."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.name, p.age FROM persons p JOIN friends f1 ON p.id = f1.person_id JOIN friends f2 ON p.id = f2.person_id WHERE f1.friend_id = (SELECT id FROM persons WHERE name = 'Dan') AND f2.friend_id = (SELECT id FROM persons WHERE name = 'Alice');",
            "SELECT p.name, p.age\nFROM Person p\nWHERE p.name IN (\n    SELECT pf1.name\n    FROM PersonFriend pf1\n    WHERE pf1.friend = 'Dan'\n    INTERSECT\n    SELECT pf2.name\n    FROM PersonFriend pf2\n    WHERE pf2.friend = 'Alice'\n)"
        ],
        "rule_sql": [
            "SELECT p.name, p.age\nFROM Person p\nWHERE p.name IN (\n    SELECT pf1.friend\n    FROM PersonFriend pf1\n    WHERE pf1.name = 'Dan'\n    INTERSECT\n    SELECT pf2.friend\n    FROM PersonFriend pf2\n    WHERE pf2.name = 'Alice'\n)"
        ]
    },
    "2547": {
        "db_id": "county_public_safety",
        "question": "What is the name of the county with the greatest population?",
        "ground_truth": "SELECT Name FROM county_public_safety ORDER BY Population DESC LIMIT 1",
        "amends": [
            "Do select `Name` from the `county_public_safety` table instead of `county_name` from the `counties` table. Do order by `Population` instead of `population` to match the correct column name. The amended query now correctly retrieves the county with the highest population from the appropriate table structure."
        ],
        "rules": [
            "1) When answering about \"county with the greatest population\": select \"Name\" from the county_public_safety table. 2) When ordering by population to find the greatest value: order by \"Population\" in descending direction. 3) When retrieving the top result: keep only the first row after ordering."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT county_name FROM counties ORDER BY population DESC LIMIT 1;",
            "SELECT Name FROM county_public_safety ORDER BY Population DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT \"Name\" FROM county_public_safety ORDER BY \"Population\" DESC LIMIT 1;"
        ]
    },
    "649": {
        "db_id": "journal_committee",
        "question": "How many editors are there?",
        "ground_truth": "SELECT count(*) FROM editor",
        "amends": [
            "Do query the `editor` table instead of the `users` table. Do filter for `role = 'admin'` instead of omitting any filter condition. The amended query now correctly counts admin users from the appropriate editor table.",
            "Do remove the `WHERE role = 'admin'` filter instead of keeping it, as the correct query should count all editors regardless of their role rather than only counting those with admin privileges. The amended query now matches RIGHT_SQL's behavior by returning the total count of all records in the editor table."
        ],
        "rules": [
            "1) When answering about \"how many editors\": query the \"editor\" table instead of the \"users\" table. 2) When filtering for admin users: apply the condition role = 'admin' to count only admin users. 3) When counting entities: count all rows from the \"editor\" table that satisfy the admin role condition.",
            "1) When counting all editors regardless of role: remove any filtering conditions based on role values like 'admin' and count all records in the editor table. 2) When the question asks for \"how many editors\": compute the total count of all rows in the editor table without any role-based restrictions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE role = 'admin';",
            "SELECT COUNT(*) FROM editor WHERE role = 'admin'",
            "SELECT COUNT(*) FROM editor;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM editor;"
        ]
    },
    "3810": {
        "db_id": "e_learning",
        "question": "Find the names of courses taught by the tutor who has personal name \"Julio\".",
        "ground_truth": "SELECT T2.course_name FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id WHERE T1.personal_name  =  \"Julio\"",
        "amends": [
            "Do use explicit `JOIN` syntax with `Course_Authors_and_Tutors AS T1 JOIN Courses AS T2` instead of a subquery with `WHERE tutor_id IN`. Do reference `T2.course_name` instead of just `course_name`. Do join on `T1.author_id = T2.author_id` instead of filtering by `tutor_id`. Do filter with `T1.personal_name = \"Julio\"` instead of using a subquery with `personal_name = 'Julio'`. The amended query now correctly retrieves course names by joining the author/tutor table directly with courses using the author relationship instead of relying on a potentially incorrect tutor_id subquery approach."
        ],
        "rules": [
            "1) When combining Course_Authors_and_Tutors and Courses tables: link rows where T1.author_id = T2.author_id and keep only matching pairs (inner match). 2) When filtering for personal name \"Julio\": use T1.personal_name = \"Julio\" exactly as specified. 3) When selecting course names: reference T2.course_name instead of just course_name. 4) When answering about courses taught by a tutor: use explicit JOIN syntax between Course_Authors_and_Tutors AS T1 and Courses AS T2 instead of subqueries with WHERE tutor_id IN."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_name FROM courses WHERE tutor_id IN (SELECT tutor_id FROM tutors WHERE personal_name = 'Julio')",
            "SELECT T2.course_name\nFROM Course_Authors_and_Tutors AS T1\nJOIN Courses AS T2 ON T1.author_id = T2.author_id\nWHERE T1.personal_name = 'Julio'"
        ],
        "rule_sql": [
            "SELECT T2.course_name\nFROM Course_Authors_and_Tutors AS T1\nINNER JOIN Courses AS T2 ON T1.author_id = T2.author_id\nWHERE T1.personal_name = 'Julio'"
        ]
    },
    "214": {
        "db_id": "book_2",
        "question": "List the writers of the books in ascending alphabetical order.",
        "ground_truth": "SELECT Writer FROM book ORDER BY Writer ASC",
        "amends": [
            "Do select only `Writer` instead of all columns with `*`. Do reference table `book` instead of `books`. Do order by `Writer ASC` instead of `writer DESC`, correcting both the column case and sort direction. The amended query now correctly retrieves only the writer column from the book table in ascending order."
        ],
        "rules": [
            "1) When selecting columns for output: use only the exact column \"Writer\" instead of all columns with *. 2) When referencing the table containing book data: use the exact table name \"book\" instead of \"books\". 3) When ordering by writer names alphabetically: use exact column \"Writer\" with ascending order (ASC) instead of descending order (DESC). 4) When answering about listing writers in alphabetical order: make sure the output order is \"Writer\" in ascending alphabetical sequence."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM books ORDER BY writer DESC;",
            "SELECT Writer FROM book ORDER BY Writer ASC;"
        ],
        "rule_sql": [
            "SELECT Writer FROM book ORDER BY Writer ASC;"
        ]
    },
    "990": {
        "db_id": "university_basketball",
        "question": "Return the primary conference of the school with the lowest acc percentage score.",
        "ground_truth": "SELECT t1.Primary_conference FROM university AS t1 JOIN basketball_match AS t2 ON t1.school_id  =  t2.school_id ORDER BY t2.acc_percent LIMIT 1",
        "amends": [
            "Do select `t1.Primary_conference` instead of `conference`. Do add `FROM university AS t1 JOIN basketball_match AS t2` instead of `FROM schools`. Do add join condition `ON t1.school_id = t2.school_id` instead of omitting it. Do order by `t2.acc_percent` instead of `acc_percentage`. The amended query now correctly joins the university and basketball_match tables to retrieve the primary conference based on accuracy percentage from basketball matches."
        ],
        "rules": [
            "1) When answering about \"primary conference of the school with the lowest acc percentage score\": make sure the output order: t1.Primary_conference. 2) When combining university and basketball_match tables: link rows where t1.school_id = t2.school_id and keep only matching pairs (inner match). 3) When ordering by accuracy percentage: order by t2.acc_percent in ascending direction to find the lowest value. 4) When selecting the school with the lowest value: take only the first row after ordering by t2.acc_percent in ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT conference FROM schools ORDER BY acc_percentage ASC LIMIT 1;",
            "SELECT t1.Primary_conference FROM university AS t1 JOIN basketball_match AS t2 ON t1.School_ID = t2.School_ID ORDER BY t2.ACC_Percent LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t1.Primary_conference FROM university t1 INNER JOIN basketball_match t2 ON t1.School_ID = t2.School_ID ORDER BY t2.ACC_Percent ASC LIMIT 1"
        ]
    },
    "4498": {
        "db_id": "decoration_competition",
        "question": "List the names of members who did not participate in any round.",
        "ground_truth": "SELECT Name FROM member WHERE Member_ID NOT IN (SELECT Member_ID FROM round)",
        "amends": [
            "Do reference `Name` instead of `name` to match the correct column casing. Do reference `member` instead of `members` as the correct table name. Do reference `Member_ID` instead of `member_id` to match the correct column casing. Do reference `round` instead of `rounds` as the correct table name. The amended query now correctly identifies members who have not participated in any rounds using the proper table and column names."
        ],
        "rules": [
            "1) When the question asks for member names: use the exact column token \"Name\" from table \"member\" with proper casing. 2) When referencing the members table: use the exact table name \"member\" (singular) instead of \"members\". 3) When referencing the rounds table: use the exact table name \"round\" (singular) instead of \"rounds\". 4) When referencing member ID columns: use the exact column token \"Member_ID\" with proper casing. 5) When finding members who did not participate in any round: identify members whose \"Member_ID\" does not appear in the \"Member_ID\" column of the \"round\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM members WHERE member_id NOT IN (SELECT member_id FROM rounds);",
            "SELECT Name FROM member WHERE Member_ID NOT IN (SELECT Member_ID FROM round)"
        ],
        "rule_sql": [
            "SELECT Name FROM member WHERE Member_ID NOT IN (SELECT Member_ID FROM round)"
        ]
    },
    "5858": {
        "db_id": "tracking_share_transactions",
        "question": "Show details of all investors if they make any transaction with share count greater than 100.",
        "ground_truth": "SELECT T1.Investor_details FROM  INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id WHERE T2.share_count  >  100",
        "amends": [
            "Do select `T1.Investor_details` instead of `*` to return specific columns rather than all columns. Do add `JOIN TRANSACTIONS AS T2` instead of querying only the `investors` table to incorporate transaction data. Do use join condition `T1.investor_id = T2.investor_id` instead of no join condition to properly relate investors to their transactions. Do move the filter to `T2.share_count > 100` instead of `share_count > 100` to apply the condition on transaction data rather than investor table data. The amended query now correctly filters investors based on their transaction share counts rather than attempting to filter on a non-existent column in the investors table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"details of all investors\": make sure the output order: T1.Investor_details. 2) When the question mentions \"investors\" and \"transactions\": combine tables T1 (investors) and T2 (TRANSACTIONS) using the exact join condition T1.investor_id = T2.investor_id to link investors to their transactions. 3) When the question specifies \"share count greater than 100\": apply the filter T2.share_count > 100 to the transaction data rather than the investor table. 4) When combining tables for shared entities: keep only matching pairs where T1.investor_id = T2.investor_id (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM investors WHERE share_count > 100;",
            "SELECT T1.Investor_details FROM Investors AS T1 JOIN Transactions AS T2 ON T1.investor_id = T2.investor_id WHERE T2.share_count > 100"
        ],
        "rule_sql": [
            "SELECT T1.Investor_details\nFROM Investors T1\nINNER JOIN Transactions T2 ON T1.investor_id = T2.investor_id\nWHERE CAST(T2.share_count AS INTEGER) > 100\nGROUP BY T1.Investor_details\nORDER BY T1.Investor_details;"
        ]
    },
    "6011": {
        "db_id": "game_1",
        "question": "Show all sport name and the number of students.",
        "ground_truth": "SELECT sportname ,  count(*) FROM Sportsinfo GROUP BY sportname",
        "amends": [
            "Do reference the `Sportsinfo` table instead of the `students` table. Do use the column name `sportname` instead of `sport_name` in both the SELECT list and GROUP BY clause. The amended query now correctly aggregates sports data from the appropriate table with the proper column naming convention."
        ],
        "rules": [
            "1) When answering about \"sport name and number of students\": make sure the output order: sportname first, then count of students. 2) When the question mentions \"sport name\": \"sport name\" actually means \"sportname in Sportsinfo table\". 3) When the question asks for \"number of students\": compute the count of rows using the canonical key from Sportsinfo table. 4) When the question says \"by sport name\": organize results by sportname and compute the count per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT sport_name, COUNT(*) FROM students GROUP BY sport_name;",
            "SELECT SportName, COUNT(StuID) AS NumberOfStudents FROM SportsInfo GROUP BY SportName;"
        ],
        "rule_sql": [
            "SELECT SportName, COUNT(StuID) AS NumberOfStudents FROM SportsInfo GROUP BY SportName ORDER BY SportName;"
        ]
    },
    "6523": {
        "db_id": "wine_1",
        "question": "List the grapes and appelations of all wines.",
        "ground_truth": "SELECT Grape ,  Appelation FROM WINE",
        "amends": [
            "Do capitalize table and column names as `Grape` and `Appelation` instead of lowercase `grape` and `appelation`. Do use the correct table name `WINE` instead of the pluralized `wines`. The amended query now matches RIGHT_SQL's behavior with proper case sensitivity and table reference."
        ],
        "rules": [
            "1) When referring to table names: use exact case-sensitive table name \"WINE\" instead of pluralized forms like \"wines\". 2) When referring to column names: use exact case-sensitive column names \"Grape\" and \"Appelation\" instead of lowercase versions. 3) When answering about listing grapes and appellations of all wines: make sure the output order: \"Grape\" then \"Appelation\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT grape, appelation FROM wines;",
            "SELECT Grape, Appelation FROM wine;"
        ],
        "rule_sql": [
            "SELECT \"Grape\", \"Appelation\" FROM \"WINE\" ORDER BY \"Grape\", \"Appelation\";"
        ]
    },
    "2256": {
        "db_id": "machine_repair",
        "question": "What are the names of the technicians that are assigned to repair machines with more point values than 70?",
        "ground_truth": "SELECT T3.Name FROM repair_assignment AS T1 JOIN machine AS T2 ON T1.machine_id  =  T2.machine_id JOIN technician AS T3 ON T1.technician_ID  =  T3.technician_ID WHERE T2.value_points  >  70",
        "amends": [
            "Do use explicit joins with `repair_assignment`, `machine`, and `technician` tables instead of a subquery approach. Do reference `T3.Name` instead of just `name` from the technicians table. Do join `repair_assignment AS T1` to `machine AS T2` on `T1.machine_id = T2.machine_id` instead of the implicit subquery correlation. Do join to `technician AS T3` on `T1.technician_ID = T3.technician_ID` instead of directly querying the technicians table. Do filter on `T2.value_points > 70` instead of `point_value > 70` in the subquery. Do use proper table aliases `T1`, `T2`, and `T3` throughout the query instead of no aliases. The amended query now correctly retrieves technician names through the repair assignment relationship rather than assuming direct machine-technician relationships."
        ],
        "rules": [
            "1) When answering about technician names assigned to repair machines with high point values: use explicit joins with repair_assignment (T1), machine (T2), and technician (T3) tables instead of subqueries. 2) When retrieving technician names: reference T3.Name instead of just name from the technicians table. 3) When combining repair_assignment and machine tables: link rows where T1.machine_id = T2.machine_id. 4) When combining repair_assignment and technician tables: link rows where T1.technician_ID = T3.technician_ID. 5) When filtering for machines with high point values: use T2.value_points > 70 instead of point_value > 70. 6) When using table aliases: consistently use T1 for repair_assignment, T2 for machine, and T3 for technician throughout the query."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM technicians WHERE machine_id IN (SELECT machine_id FROM machines WHERE point_value > 70)",
            "SELECT T3.Name \nFROM repair_assignment AS T1\nJOIN machine AS T2 ON T1.Machine_ID = T2.Machine_ID\nJOIN technician AS T3 ON T1.technician_id = T3.technician_id\nWHERE T2.value_points > 70"
        ],
        "rule_sql": [
            "SELECT T3.Name \nFROM repair_assignment T1\nJOIN machine T2 ON T1.Machine_ID = T2.Machine_ID\nJOIN technician T3 ON T1.technician_id = T3.technician_id\nWHERE T2.value_points > 70"
        ]
    },
    "4339": {
        "db_id": "tracking_grants_for_research",
        "question": "What are the details for all projects that did not hire any staff in a research role?",
        "ground_truth": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )",
        "amends": [
            "Do select `project_details` instead of `*` and reference table `Projects` instead of `projects`. Do use subquery source `Project_Staff` instead of `staff_assignments` with filter on `role_code = 'researcher'` instead of `role = 'research'`. The amended query now correctly filters for researcher role codes and returns only project details from the proper Projects table."
        ],
        "rules": [
            "1) When selecting project details: use \"project_details\" from table \"Projects\" instead of using * to select all columns. 2) When filtering for projects that did not hire research staff: use table \"Project_Staff\" instead of \"staff_assignments\" and filter on \"role_code = 'researcher'\" instead of \"role = 'research'\". 3) When checking for projects without research staff: use the NOT IN condition with a subquery that selects \"project_id\" from \"Project_Staff\" where \"role_code = 'researcher'\". 4) When referencing the main projects table: use \"Projects\" (with capital P) instead of \"projects\" (lowercase)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM projects WHERE project_id NOT IN (SELECT project_id FROM staff_assignments WHERE role = 'research');",
            "SELECT project_details FROM Projects WHERE project_id NOT IN (SELECT DISTINCT project_id FROM Project_Staff WHERE role_code = 'researcher')"
        ],
        "rule_sql": [
            "SELECT project_details FROM Projects WHERE project_id NOT IN (SELECT project_id FROM Project_Staff WHERE role_code = 'researcher')"
        ]
    },
    "6387": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "Show all account ids and account details.",
        "ground_truth": "SELECT account_id ,  account_details FROM Accounts",
        "amends": [
            "Do specify explicit columns `account_id, account_details` instead of using `SELECT *`. Do reference the correct table name `Accounts` instead of `accounts`. Do remove the `WHERE account_id IS NULL` filter instead of keeping it, as the right query returns all records without filtering. The amended query now correctly selects specific columns from the proper table name without unnecessary filtering, matching the intended behavior of retrieving all account records with their identifiers and details."
        ],
        "rules": [
            "1) When selecting all account records: use the exact table name \"Accounts\" with double quotes as shown in the schema. 2) When showing account ids and account details: explicitly specify the columns \"account_id\" and \"account_details\" instead of using SELECT *. 3) When retrieving all records without filtering: do not apply any WHERE conditions that would filter out records, such as WHERE account_id IS NULL."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM accounts WHERE account_id IS NULL;",
            "SELECT account_id, account_details FROM Accounts"
        ],
        "rule_sql": [
            "SELECT account_id, account_details FROM \"Accounts\""
        ]
    },
    "4735": {
        "db_id": "department_store",
        "question": "Find the name and address of the customers who have both New and Pending orders.",
        "ground_truth": "SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  \"New\" INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  \"Pending\"",
        "amends": [
            "Do use `customer_name` and `customer_address` instead of `name` and `address` for column selection. Do join with `customer_orders` table instead of `orders` table. Do use `order_status_code` instead of `status` for the filter condition. Do remove the impossible `AND` condition that required both 'New' and 'Pending' status simultaneously and instead implement an `INTERSECT` operation between two separate queries filtering for each status individually. Do use double quotes around string literals instead of single quotes. The amended query now correctly finds customers who have both New AND Pending orders using set intersection logic instead of the impossible single-row condition, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting customer information: use \"customer_name\" and \"customer_address\" columns from the Customers table. 2) When finding customers with both New and Pending orders: use the Customer_Orders table instead of the Orders table. 3) When filtering by order status: use the \"order_status_code\" column instead of \"status\". 4) When checking for customers with both statuses: use set intersection logic instead of AND conditions on the same row. 5) When specifying string literals: use double quotes around \"New\" and \"Pending\" values. 6) When combining status conditions: create separate queries for \"order_status_code\" = \"New\" and \"order_status_code\" = \"Pending\" then intersect the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name, c.address FROM customers c JOIN orders o ON c.customer_id = o.customer_id WHERE o.status = 'New' AND o.status = 'Pending'",
            "SELECT customer_name, customer_address\nFROM Customers\nWHERE customer_id IN (\n    SELECT customer_id\n    FROM Customer_Orders\n    WHERE order_status_code = \"New\"\n    INTERSECT\n    SELECT customer_id\n    FROM Customer_Orders\n    WHERE order_status_code = \"Pending\"\n)"
        ],
        "rule_sql": [
            "SELECT c.customer_name, c.customer_address\nFROM Customers c\nWHERE c.customer_id IN (\n    SELECT co1.customer_id\n    FROM Customer_Orders co1\n    WHERE co1.order_status_code = \"New\"\n)\nAND c.customer_id IN (\n    SELECT co2.customer_id\n    FROM Customer_Orders co2\n    WHERE co2.order_status_code = \"Pending\"\n);"
        ]
    },
    "1899": {
        "db_id": "school_finance",
        "question": "List the amount and donor name for the largest amount of donation.",
        "ground_truth": "SELECT amount ,  donator_name FROM endowment ORDER BY amount DESC LIMIT 1",
        "amends": [
            "Do reference column `donator_name` instead of `donor_name` and table `endowment` instead of `donations` to match the correct schema while preserving the same `ORDER BY amount DESC LIMIT 1` structure for retrieving the highest amount record."
        ],
        "rules": [
            "1) When the question mentions \"donor name\": \"donor name\" actually means \"donator_name\" in the endowment table. 2) When the question asks about \"donations\": use the \"endowment\" table instead of \"donations\" to match the correct schema. 3) When the question asks for the \"largest amount\": rank rows by amount in descending order and keep the first 1 row. 4) When producing output: make sure the output order is amount followed by donator_name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT amount, donor_name FROM donations ORDER BY amount DESC LIMIT 1;",
            "SELECT amount, donator_name FROM endowment ORDER BY amount DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT amount, donator_name FROM endowment ORDER BY amount DESC LIMIT 1;"
        ]
    },
    "4655": {
        "db_id": "college_3",
        "question": "Find the rooms of faculties with rank professor who live in building NEB.",
        "ground_truth": "SELECT Room FROM FACULTY WHERE Rank  =  \"Professor\" AND Building  =  \"NEB\"",
        "amends": [
            "Do use table name `FACULTY` instead of `faculties` and column name `Room` instead of `room_number`. Do use column name `Rank` instead of `rank` and `Building` instead of `building`. Do use double quotes around string literals \"Professor\" and \"NEB\" instead of single quotes 'professor' and 'NEB'. The amended query now correctly references the proper table and column names with appropriate string formatting to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about \"faculties\": use the exact table name \"FACULTY\" instead of \"faculties\". 2) When the question mentions \"rooms\": use the exact column name \"Room\" instead of \"room_number\". 3) When the question mentions \"rank\": use the exact column name \"Rank\" instead of \"rank\". 4) When the question mentions \"building\": use the exact column name \"Building\" instead of \"building\". 5) When filtering for professors: use the exact string literal \"Professor\" with double quotes instead of 'professor'. 6) When filtering for building NEB: use the exact string literal \"NEB\" with double quotes instead of 'NEB'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT room_number FROM faculties WHERE rank = 'professor' AND building = 'NEB';",
            "SELECT Room FROM Faculty WHERE Rank = \"Professor\" AND Building = \"NEB\";"
        ],
        "rule_sql": [
            "SELECT Room FROM Faculty WHERE Rank = \"Professor\" AND Building = \"NEB\";"
        ]
    },
    "5994": {
        "db_id": "game_1",
        "question": "What are the first names for all students who are from the major numbered 600?",
        "ground_truth": "SELECT Fname FROM Student WHERE Major  =  600",
        "amends": [
            "Do reference column `Fname` instead of `first_name` and table `Student` instead of `students`. Do use numeric comparison `Major = 600` instead of string comparison `major = '600'` by removing the single quotes around the value. The amended query now correctly matches the RIGHT_SQL's behavior with proper column and table references and appropriate numeric comparison semantics."
        ],
        "rules": [
            "1) When the question asks for \"first names\": use the exact column token \"Fname\" from the Student table. 2) When the question refers to \"students\": use the exact table token \"Student\" instead of \"students\". 3) When the question mentions major numbered \"600\": use numeric comparison Major = 600 without quotes around the value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE major = '600';",
            "SELECT Fname FROM Student WHERE Major = 600"
        ],
        "rule_sql": [
            "SELECT Fname FROM Student WHERE Major = 600"
        ]
    },
    "6942": {
        "db_id": "tracking_orders",
        "question": "What are the names of the customers who bought product \"food\" at least once?",
        "ground_truth": "SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 JOIN order_items AS T3 JOIN products AS T4 ON T1.customer_id = T2.customer_id AND T2.order_id = T3.order_id AND T3.product_id = T4.product_id WHERE T4.product_name = \"food\" GROUP BY T1.customer_id HAVING count(*)  >=  1",
        "amends": [
            "Do add `T1.customer_name` instead of `name` in the SELECT list. Do add multiple table joins with `customers AS T1 JOIN orders AS T2 JOIN order_items AS T3 JOIN products AS T4` instead of querying only the `customers` table. Do add join conditions `T1.customer_id = T2.customer_id AND T2.order_id = T3.order_id AND T3.product_id = T4.product_id` instead of having no joins. Do change the filter to `T4.product_name = \"food\"` instead of `product = 'food'`. Do add `GROUP BY T1.customer_id` and `HAVING count(*) >= 1` instead of omitting grouping and aggregation. The amended query now correctly joins multiple tables to find customers who ordered food products and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about customer names who bought product \"food\": make sure the output order: T1.customer_name. 2) When the question mentions \"customers\": use table \"customers AS T1\" with column \"customer_name\" for customer names. 3) When the question mentions \"product 'food'\": \"food\" actually means \"T4.product_name = 'food'\" in schema. 4) When combining multiple tables for customer orders: link rows where T1.customer_id = T2.customer_id AND T2.order_id = T3.order_id AND T3.product_id = T4.product_id; keep only matching pairs (inner match). 5) When the question asks for customers who bought at least once: organize results by T1.customer_id and compute count(*) per group, keeping only groups with count(*) >= 1."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM customers WHERE product = 'food';",
            "SELECT T1.customer_name\nFROM Customers AS T1\nJOIN Orders AS T2 ON T1.customer_id = T2.customer_id\nJOIN Order_Items AS T3 ON T2.order_id = T3.order_id\nJOIN Products AS T4 ON T3.product_id = T4.product_id\nWHERE T4.product_name = 'food'\nGROUP BY T1.customer_id\nHAVING COUNT(*) >= 1"
        ],
        "rule_sql": [
            "SELECT T1.customer_name\nFROM Customers AS T1\nINNER JOIN Orders AS T2 ON T1.customer_id = T2.customer_id\nINNER JOIN Order_Items AS T3 ON T2.order_id = T3.order_id\nINNER JOIN Products AS T4 ON T3.product_id = T4.product_id\nWHERE T4.product_name = 'food'\nGROUP BY T1.customer_id\nHAVING COUNT(*) >= 1\nORDER BY T1.customer_name"
        ]
    },
    "4808": {
        "db_id": "aircraft",
        "question": "What is the maximum and mininum number of transit passengers for all airports?",
        "ground_truth": "SELECT max(Transit_Passengers) ,  min(Transit_Passengers) FROM airport",
        "amends": [
            "Do reference the table as `airport` instead of `airports` to match the correct schema. Do maintain the aggregate functions `max(Transit_Passengers)` and `min(Transit_Passengers)` instead of changing their case or structure. Do remove the `WHERE transit_passengers IS NOT NULL` filter instead of keeping it, as the aggregate functions naturally handle NULL values by excluding them from calculations. The amended query now correctly calculates the maximum and minimum Transit_Passengers values from the airport table without unnecessary filtering."
        ],
        "rules": [
            "1) When answering about \"maximum and minimum number of transit passengers for all airports\": make sure the output order: max(Transit_Passengers), min(Transit_Passengers). 2) When the question mentions \"airports\": \"airports\" actually means \"airport\" in schema. 3) When computing aggregates on Transit_Passengers: do not filter out NULL values as aggregate functions naturally exclude them from calculations."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(transit_passengers), MIN(transit_passengers) FROM airports WHERE transit_passengers IS NOT NULL;",
            "SELECT MAX(Transit_Passengers) AS Max_Transit_Passengers, MIN(Transit_Passengers) AS Min_Transit_Passengers FROM airport"
        ],
        "rule_sql": [
            "SELECT MAX(Transit_Passengers) AS max_transit_passengers, MIN(Transit_Passengers) AS min_transit_passengers FROM airport;"
        ]
    },
    "6871": {
        "db_id": "flight_4",
        "question": "Return the number of routes with destination airport in Italy operated by the airline with name 'American Airlines'.",
        "ground_truth": "SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  'Italy' AND T3.name  =  'American Airlines'",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `r`, `ap`, and `a`. Do join `airports` on `T1.dst_apid = T2.apid` instead of `r.destination_airport_id = ap.airport_id`. Do join `airlines` on `T1.alid = T3.alid` instead of `r.airline_id = a.airline_id`. Do use column names `dst_apid` and `alid` instead of `destination_airport_id` and `airline_id`. Do use column names `apid` and `alid` instead of `airport_id` and `airline_id`. The amended query now correctly matches the intended logic using the proper table aliases and column references."
        ],
        "rules": [
            "1) When answering about routes with destination airport in Italy operated by American Airlines: use table aliases T1 for routes, T2 for airports, and T3 for airlines. 2) When combining routes and airports: link rows where T1.dst_apid = T2.apid and keep only matching pairs (inner match). 3) When combining routes and airlines: link rows where T1.alid = T3.alid and keep only matching pairs (inner match). 4) When filtering for airline name: use exact literal 'American Airlines' for T3.name. 5) When filtering for destination country: use exact literal 'Italy' for T2.country. 6) When counting routes: compute the number of rows using the canonical key for routes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM routes r\nJOIN airlines a ON r.airline_id = a.airline_id\nJOIN airports ap ON r.destination_airport_id = ap.airport_id\nWHERE a.name = 'American Airlines' AND ap.country = 'Italy';",
            "SELECT COUNT(*) \nFROM routes T1\nJOIN airports T2 ON T1.dst_apid = T2.apid\nJOIN airlines T3 ON T1.alid = T3.alid\nWHERE T2.country = 'Italy' AND T3.name = 'American Airlines'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.rid) \nFROM routes T1\nINNER JOIN airports T2 ON T1.dst_apid = T2.apid\nINNER JOIN airlines T3 ON T1.alid = T3.alid\nWHERE T3.name = 'American Airlines' AND T2.country = 'Italy'"
        ]
    },
    "2857": {
        "db_id": "customer_deliveries",
        "question": "List the state names and the number of customers living in each state.",
        "ground_truth": "SELECT t2.state_province_county ,  count(*) FROM customer_addresses AS t1 JOIN addresses AS t2 ON t1.address_id  =  t2.address_id GROUP BY t2.state_province_county",
        "amends": [
            "Do join `addresses AS t2` instead of querying `customers` table alone. Do use `t2.state_province_county` instead of `state` for both selection and grouping. Do add `JOIN addresses AS t2 ON t1.address_id = t2.address_id` instead of missing the address relationship. Do reference `customer_addresses AS t1` instead of directly accessing customer data. The amended query now correctly counts customers by their address state/province/county rather than assuming state exists directly in customers."
        ],
        "rules": [
            "1) When answering about \"customers living in each state\": make sure the output order: state names first, then count of customers. 2) When the question mentions \"state names\": \"state names\" actually means \"t2.state_province_county\" in schema. 3) When the question asks for \"number of customers living in each state\": compute the count using the canonical key token for customers (t1.address_id). 4) When combining customer_addresses AS t1 and addresses AS t2 for shared entities: link rows where t1.address_id = t2.address_id exactly as shown in the amends; keep only matching pairs (inner match). 5) When the question says \"per state\"/\"by state\": organize results by t2.state_province_county and compute customer count per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT state, COUNT(*) FROM customers GROUP BY state;",
            "SELECT t2.state_province_county, COUNT(DISTINCT t1.customer_id) AS customer_count\nFROM Customer_Addresses AS t1\nJOIN Addresses AS t2 ON t1.address_id = t2.address_id\nGROUP BY t2.state_province_county"
        ],
        "rule_sql": [
            "SELECT t2.state_province_county AS state_names, COUNT(t1.address_id) AS number_of_customers\nFROM Customer_Addresses AS t1\nINNER JOIN Addresses AS t2 ON t1.address_id = t2.address_id\nGROUP BY t2.state_province_county\nORDER BY t2.state_province_county, COUNT(t1.address_id);"
        ]
    },
    "635": {
        "db_id": "store_1",
        "question": "List the name of all tracks in the playlists of Movies.",
        "ground_truth": "SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id = T2.track_id JOIN playlists AS T3 ON T3.id = T2.playlist_id WHERE T3.name = \"Movies\";",
        "amends": [
            "Do join `playlist_tracks` as an intermediate table instead of directly joining `tracks` to `playlists`. Do use `tracks.id = playlist_tracks.track_id` instead of `tracks.PlaylistId = playlists.PlaylistId` for the first join condition. Do join `playlists` on `playlists.id = playlist_tracks.playlist_id` instead of the direct join approach. Do reference `tracks.name` instead of `tracks.Name` for the column selection. Do use table aliases `T1`, `T2`, and `T3` instead of single-letter aliases. Do use double quotes around the string literal \"Movies\" instead of single quotes. The amended query now correctly handles the many-to-many relationship between tracks and playlists through the junction table."
        ],
        "rules": [
            "1) When answering about \"tracks in playlists of Movies\": make sure the output order: T1.name\n2) When the question mentions \"tracks\": \"tracks\" actually means \"T1\" in schema\n3) When the question mentions \"playlists\": \"playlists\" actually means \"T3\" in schema\n4) When combining T1, T2, and T3 for shared entities: link rows where T1.id = T2.track_id and T3.id = T2.playlist_id; keep only matching pairs (inner match)\n5) When filtering for the playlist named \"Movies\": use the exact string literal \"Movies\" with double quotes for T3.name = \"Movies\"\n6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms\n7) When handling text literals: do not change case, spacing, or punctuation of \"Movies\"\n8) When referring to table roles: do not rename or swap the aliases T1 (tracks), T2 (playlist_tracks), T3 (playlists) once set for this schema"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.Name FROM tracks t JOIN playlists p ON t.PlaylistId = p.PlaylistId WHERE p.Name = 'Movies'",
            "SELECT T1.name \nFROM tracks T1\nJOIN playlist_tracks T2 ON T1.id = T2.track_id\nJOIN playlists T3 ON T3.id = T2.playlist_id\nWHERE T3.name = \"Movies\""
        ],
        "rule_sql": [
            "SELECT T1.name\nFROM tracks T1\nINNER JOIN playlist_tracks T2 ON T1.id = T2.track_id\nINNER JOIN playlists T3 ON T3.id = T2.playlist_id\nWHERE T3.name = \"Movies\"\nORDER BY T1.name"
        ]
    },
    "3612": {
        "db_id": "music_1",
        "question": "What country is the artist who made the fewest songs from?",
        "ground_truth": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name GROUP BY T2.artist_name ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do join `artist AS T1` with `song AS T2` on `T1.artist_name = T2.artist_name` instead of querying only `artists` without any join. Do group by `T2.artist_name` instead of ordering by a count without grouping. Do order by `count(*)` instead of ordering by `COUNT(songs.id)` without proper table qualification. Do select `T1.country` instead of selecting just `country` without table specification. The amended query now correctly aggregates song counts per artist and returns the country with the artist having the fewest songs, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"country of artist with fewest songs\": make sure the output order: T1.country. 2) When combining T1 (artist) and T2 (song) for shared entities: link rows where T1.artist_name = T2.artist_name exactly as shown; keep only matching pairs (inner match). 3) When the question asks for \"fewest songs per artist\": organize results by T2.artist_name and compute count(*) per group. 4) When the question asks for \"artist with fewest songs\": rank rows by count(*) in ascending direction and keep the first 1 row. 5) When selecting country information: select T1.country instead of just country without table specification."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM artists ORDER BY COUNT(songs.id) ASC LIMIT 1;",
            "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name = T2.artist_name GROUP BY T2.artist_name ORDER BY COUNT(*) LIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.country\nFROM artist T1\nINNER JOIN song T2 ON T1.artist_name = T2.artist_name\nGROUP BY T2.artist_name\nORDER BY COUNT(*) ASC\nLIMIT 1"
        ]
    },
    "5129": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "List the description, code and the number of services for each service type.",
        "ground_truth": "SELECT T1.Service_Type_Description ,  T2.Service_Type_Code ,  COUNT(*) FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code GROUP BY T2.Service_Type_Code",
        "amends": [
            "Do select `T1.Service_Type_Description` and `T2.Service_Type_Code` instead of `description` and `code`. Do join `Ref_Service_Types AS T1` with `Services AS T2` on `T1.Service_Type_Code = T2.Service_Type_Code` instead of querying only the `services` table. Do group by `T2.Service_Type_Code` instead of `service_type`. The amended query now correctly joins the reference table to access the service type description while maintaining the count aggregation on services data."
        ],
        "rules": [
            "1) When the question asks for \"description\" and \"code\" of service types: use \"T1.Service_Type_Description\" for description and \"T2.Service_Type_Code\" for code. 2) When combining service type reference data with services data: join \"Ref_Service_Types AS T1\" with \"Services AS T2\" where \"T1.Service_Type_Code = T2.Service_Type_Code\" and keep only matching pairs. 3) When counting services per service type: count the number of services using the services table data grouped by \"T2.Service_Type_Code\". 4) When organizing results by service type: group the output by \"T2.Service_Type_Code\" to show one row per service type with its description, code, and service count."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description, code, COUNT(*) as service_count FROM services GROUP BY service_type",
            "SELECT \n    T1.Service_Type_Description,\n    T2.Service_Type_Code,\n    COUNT(*) AS number_of_services\nFROM \n    Ref_Service_Types AS T1\nJOIN \n    Services AS T2 ON T1.Service_Type_Code = T2.Service_Type_Code\nGROUP BY \n    T2.Service_Type_Code"
        ],
        "rule_sql": [
            "SELECT \n    T1.Service_Type_Description AS description,\n    T2.Service_Type_Code AS code,\n    COUNT(T2.Service_ID) AS number_of_services\nFROM \n    Ref_Service_Types AS T1\nJOIN \n    Services AS T2 ON T1.Service_Type_Code = T2.Service_Type_Code\nGROUP BY \n    T2.Service_Type_Code\nORDER BY \n    T2.Service_Type_Code;"
        ]
    },
    "4168": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "What is the name and description for document type code RV?",
        "ground_truth": "SELECT document_type_name ,  document_type_description FROM Ref_document_types WHERE document_type_code  =  \"RV\"",
        "amends": [
            "Do select `document_type_name` and `document_type_description` instead of `name` and `description`. Do reference table `Ref_document_types` instead of `document_types`. Do filter on `document_type_code = \"RV\"` instead of `code = 'RV'` with proper double quotes instead of single quotes. The amended query now correctly retrieves the specified document type information from the appropriate reference table."
        ],
        "rules": [
            "1) When the question asks for \"name and description\" for document types: use columns \"document_type_name\" and \"document_type_description\" from table \"Ref_document_types\". 2) When filtering for document type code \"RV\": use condition \"document_type_code = \\\"RV\\\"\" with exact double quotes around the literal value. 3) When referencing the document types table: use table name \"Ref_document_types\" instead of \"document_types\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, description FROM document_types WHERE code = 'RV';",
            "SELECT document_type_name, document_type_description FROM Ref_Document_Types WHERE document_type_code = \"RV\";"
        ],
        "rule_sql": [
            "SELECT document_type_name, document_type_description FROM Ref_document_types WHERE document_type_code = \"RV\""
        ]
    },
    "228": {
        "db_id": "book_2",
        "question": "List the writers who have written more than one book.",
        "ground_truth": "SELECT Writer FROM book GROUP BY Writer HAVING COUNT(*)  >  1",
        "amends": [
            "Do reference the `Writer` column instead of `writer_name` and use the `book` table instead of `books` while maintaining the same GROUP BY and HAVING logic with `COUNT(*) > 1` to find duplicate writers. The amended query now correctly identifies duplicate writers from the book table."
        ],
        "rules": [
            "1) When the question asks about writers who have written more than one book: use the exact column name \"Writer\" from the book table. 2) When counting books per writer: group by the \"Writer\" column and count all rows in each group. 3) When filtering for writers with multiple books: only keep groups where the count of books is greater than 1. 4) When producing output: return only the \"Writer\" column values for the matching writers."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT writer_name FROM books GROUP BY writer_name HAVING COUNT(*) > 1",
            "SELECT Writer FROM book GROUP BY Writer HAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT Writer FROM book GROUP BY Writer HAVING COUNT(*) > 1"
        ]
    },
    "5324": {
        "db_id": "manufactory_1",
        "question": "Select the names and the prices of all the products in the store.",
        "ground_truth": "SELECT name ,  price FROM products",
        "amends": [
            "Do add `price` to the SELECT list instead of omitting it, ensuring both product name and price are retrieved from the products table. The amended query now matches RIGHT_SQL's behavior by including all required columns."
        ],
        "rules": [
            "1) When selecting product information from the products table: include both \"name\" and \"price\" columns in the output. 2) When the question asks for \"names and prices of all products\": retrieve all rows from the products table without filtering. 3) When producing output columns: maintain the order of columns as specified in the question - first \"name\" then \"price\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM products;",
            "SELECT Name, Price FROM Products;"
        ],
        "rule_sql": [
            "SELECT Name, Price FROM Products;"
        ]
    },
    "446": {
        "db_id": "allergy_1",
        "question": "What are the allergies and their types?",
        "ground_truth": "SELECT allergy ,  allergytype FROM Allergy_type",
        "amends": [
            "Do reference the correct table name `Allergy_type` instead of `allergies`. Do select the correct column `allergytype` instead of `type`. Do maintain the column `allergy` without changes. The amended query now correctly retrieves allergy information from the appropriate table structure."
        ],
        "rules": [
            "1) When referencing the table containing allergy information: use the exact table name \"Allergy_type\" instead of \"allergies\". 2) When selecting the column for allergy type: use the exact column name \"allergytype\" instead of \"type\". 3) When selecting the allergy column: maintain the exact column name \"allergy\" without changes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT allergy, type FROM allergies WHERE type = 'food';",
            "SELECT Allergy, AllergyType FROM Allergy_Type;"
        ],
        "rule_sql": [
            "SELECT allergy, allergytype FROM Allergy_Type;"
        ]
    },
    "1193": {
        "db_id": "election_representative",
        "question": "How many distinct parties are there for representatives?",
        "ground_truth": "SELECT count(DISTINCT Party) FROM representative",
        "amends": [
            "Do `count(DISTINCT Party)` instead of `COUNT(*)` to count distinct party values rather than all rows. Do reference table `representative` instead of `representatives` to use the correct table name. The amended query now correctly counts distinct political parties from the representative table."
        ],
        "rules": [
            "1) When counting distinct parties: use COUNT(DISTINCT Party) instead of COUNT(*) to count unique party values. 2) When referencing the representatives table: use the exact table name \"representative\" instead of \"representatives\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM representatives;",
            "SELECT COUNT(DISTINCT Party) FROM representative;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Party) FROM representative;"
        ]
    },
    "5648": {
        "db_id": "railway",
        "question": "List the object number of railways that do not have any trains.",
        "ground_truth": "SELECT ObjectNumber FROM railway WHERE Railway_ID NOT IN (SELECT Railway_ID FROM train)",
        "amends": [
            "Do select `ObjectNumber` instead of `object_number` and use `Railway_ID NOT IN` subquery instead of `train_id IS NULL`. Do reference table `railway` instead of `railways` and remove the incorrect `train_id` column reference. Do add a correlated subquery `(SELECT Railway_ID FROM train)` to properly check for railways without associated trains instead of checking for NULL values in a non-existent column. The amended query now correctly identifies railways that have no corresponding train records by using proper table relationships instead of relying on incorrect column semantics."
        ],
        "rules": [
            "1) When the question asks for \"object number\": use the exact column token \"ObjectNumber\" from the railway table. 2) When checking for railways without trains: use a subquery that selects \"Railway_ID\" from the train table and check where railway's \"Railway_ID\" is not in that subquery, instead of checking for NULL values. 3) When referring to the main table: use the exact table name \"railway\" instead of \"railways\". 4) When the question mentions \"railways that do not have any trains\": this means railways where there are no corresponding records in the train table for their Railway_ID."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT object_number FROM railways WHERE train_id IS NULL;",
            "SELECT ObjectNumber FROM railway WHERE Railway_ID NOT IN (SELECT Railway_ID FROM train)"
        ],
        "rule_sql": [
            "SELECT ObjectNumber FROM railway WHERE Railway_ID NOT IN (SELECT Railway_ID FROM train)"
        ]
    },
    "3336": {
        "db_id": "college_1",
        "question": "What is the first name of the student whose last name starts with the letter S and is taking ACCT-211?",
        "ground_truth": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code WHERE T3.crs_code  =  'ACCT-211' AND T1.stu_lname LIKE 'S%'",
        "amends": [
            "Do select `T1.stu_fname` instead of `first_name` and use proper table aliasing. Do join `student AS T1` with `enroll AS T2` on `T1.stu_num = T2.stu_num` instead of querying only the students table. Do add a second join to `CLASS AS T3` on `T2.class_code = T3.class_code` instead of omitting the class relationship. Do filter on `T3.crs_code = 'ACCT-211'` instead of `course = 'ACCT-211'` to properly reference the course code through the class table. Do filter on `T1.stu_lname LIKE 'S%'` instead of `last_name LIKE 'S%'` to use the correct column name. Do remove the `LIMIT 1` clause instead of keeping it since the business logic requires all matching records. The amended query now correctly joins through the enrollment and class tables to find students enrolled in the specific course with matching last names, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"first name\": use the exact column token \"T1.stu_fname\" instead of \"first_name\". 2) When the question mentions \"last name starts with the letter S\": use the exact column token \"T1.stu_lname LIKE 'S%'\" instead of \"last_name LIKE 'S%'\". 3) When the question mentions \"taking ACCT-211\": join \"student AS T1\" with \"enroll AS T2\" on \"T1.stu_num = T2.stu_num\" and then join with \"CLASS AS T3\" on \"T2.class_code = T3.class_code\", filtering on \"T3.crs_code = 'ACCT-211'\" instead of using \"course = 'ACCT-211'\". 4) When combining tables for student enrollment information: perform inner matches using the exact key equalities \"T1.stu_num = T2.stu_num\" and \"T2.class_code = T3.class_code\". 5) When the business logic requires all matching records: do not apply any row limiting clauses like \"LIMIT 1\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE last_name LIKE 'S%' AND course = 'ACCT-211' LIMIT 1;",
            "SELECT T1.stu_fname \nFROM student AS T1\nJOIN enroll AS T2 ON T1.stu_num = T2.stu_num\nJOIN CLASS AS T3 ON T2.class_code = T3.class_code\nWHERE T1.stu_lname LIKE 'S%' \nAND T3.crs_code = 'ACCT-211'"
        ],
        "rule_sql": [
            "SELECT T1.stu_fname FROM student AS T1\nINNER JOIN enroll AS T2 ON T1.stu_num = T2.stu_num\nINNER JOIN CLASS AS T3 ON T2.class_code = T3.class_code\nWHERE T1.stu_lname LIKE 'S%' AND T3.crs_code = 'ACCT-211'"
        ]
    },
    "2298": {
        "db_id": "entrepreneur",
        "question": "What are the investors who have invested in both entrepreneurs who requested more than 140000 and entrepreneurs who requested less than 120000?",
        "ground_truth": "SELECT Investor FROM entrepreneur WHERE Money_Requested  >  140000 INTERSECT SELECT Investor FROM entrepreneur WHERE Money_Requested  <  120000",
        "amends": [
            "Do use `INTERSECT` to find common investors instead of multiple `JOIN` operations with different conditions. Do query from a single `entrepreneur` table instead of joining through `investments` and `investors` tables. Do filter with `Money_Requested > 140000` in the first branch instead of `e1.requested_amount > 140000`. Do filter with `Money_Requested < 120000` in the second branch instead of `e2.requested_amount < 120000`. Do select `Investor` column directly instead of `i.name` through complex joins. Do remove the `DISTINCT` modifier since `INTERSECT` inherently returns unique results instead of keeping it. The amended query now correctly identifies investors who have funded both high-request and low-request entrepreneurs using set intersection logic."
        ],
        "rules": [
            "1) When answering about investors who invested in both types of entrepreneurs: use INTERSECT to find common investors instead of multiple JOIN operations. 2) When filtering entrepreneurs who requested more than 140000: use Money_Requested > 140000 as the exact condition. 3) When filtering entrepreneurs who requested less than 120000: use Money_Requested < 120000 as the exact condition. 4) When selecting investor names: select the \"Investor\" column directly from the entrepreneur table instead of joining through other tables. 5) When using set operations like INTERSECT: do not use DISTINCT modifier as INTERSECT inherently returns unique results. 6) When combining results from different conditions: use the exact column name \"Investor\" from the entrepreneur table for both branches of the INTERSECT operation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT i.name \nFROM investors i\nJOIN investments inv1 ON i.id = inv1.investor_id\nJOIN entrepreneurs e1 ON inv1.entrepreneur_id = e1.id AND e1.requested_amount > 140000\nJOIN investments inv2 ON i.id = inv2.investor_id\nJOIN entrepreneurs e2 ON inv2.entrepreneur_id = e2.id AND e2.requested_amount < 120000",
            "SELECT Investor FROM entrepreneur WHERE Money_Requested > 140000\nINTERSECT\nSELECT Investor FROM entrepreneur WHERE Money_Requested < 120000"
        ],
        "rule_sql": [
            "SELECT Investor FROM entrepreneur WHERE Money_Requested > 140000\nINTERSECT\nSELECT Investor FROM entrepreneur WHERE Money_Requested < 120000"
        ]
    },
    "4402": {
        "db_id": "network_2",
        "question": "What is the average age for all person?",
        "ground_truth": "SELECT avg(age) FROM Person",
        "amends": [
            "Do use `avg(age)` instead of `AVG(name)` to calculate the average of numeric age values rather than attempting to average a string name column. Do reference the table as `Person` instead of `person` to maintain consistent case sensitivity. The amended query now correctly calculates the average age from the Person table instead of the erroneous attempt to average non-numeric name values."
        ],
        "rules": [
            "1) When calculating an average for all persons: use avg(age) instead of AVG(name) to compute the average of numeric age values rather than attempting to average a string name column. 2) When referencing the person table: use Person instead of person to maintain consistent case sensitivity."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(name) FROM person;",
            "SELECT AVG(age) FROM Person;"
        ],
        "rule_sql": [
            "SELECT avg(age) FROM Person;"
        ]
    },
    "3264": {
        "db_id": "college_1",
        "question": "What are the first and last names of the employee with the earliest date of birth?",
        "ground_truth": "SELECT emp_fname ,  emp_lname FROM employee ORDER BY emp_dob LIMIT 1",
        "amends": [
            "Do use column names `emp_fname` and `emp_lname` instead of `first_name` and `last_name`. Do reference table `employee` instead of `employees`. Do use column `emp_dob` for ordering instead of `date_of_birth`. Do remove the explicit `ASC` direction since it is the default ordering. The amended query now correctly selects employee first and last names from the employee table ordered by date of birth with a limit of one result."
        ],
        "rules": [
            "1) When the question asks for first and last names: use the exact column names \"emp_fname\" and \"emp_lname\" from the employee table. 2) When the question refers to employees: use the table name \"employee\" (not \"employees\"). 3) When ordering by date of birth: use the column \"emp_dob\" for sorting. 4) When finding the earliest date of birth: sort in ascending order (default direction) and take only the first result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM employees ORDER BY date_of_birth ASC LIMIT 1;",
            "SELECT emp_fname, emp_lname FROM employee ORDER BY emp_dob LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT emp_fname, emp_lname FROM employee ORDER BY emp_dob ASC LIMIT 1;"
        ]
    },
    "4716": {
        "db_id": "department_store",
        "question": "What is the address for the customer with id 10?",
        "ground_truth": "SELECT T1.address_details FROM addresses AS T1 JOIN customer_addresses AS T2 ON T1.address_id  =  T2.address_id WHERE T2.customer_id  =  10",
        "amends": [
            "Do select only `T1.address_details` instead of all columns with `*`. Do add `addresses AS T1` and `customer_addresses AS T2` as joined tables instead of querying only `customers`. Do use `JOIN` with `T1.address_id = T2.address_id` instead of no join condition. Do filter on `T2.customer_id = 10` instead of `customer_id = 10` to reference the correct table. The amended query now correctly retrieves address details for the specified customer by properly joining the address and customer_address tables."
        ],
        "rules": [
            "1) When answering about \"address for customer with id 10\": make sure the output order: T1.address_details. 2) When the question mentions \"customer with id 10\": use T2.customer_id = 10 to filter for the correct customer. 3) When combining T1 and T2 for shared entities: link rows where T1.address_id = T2.address_id exactly as shown; keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM customers WHERE customer_id = 10;",
            "SELECT T1.address_details FROM addresses AS T1 JOIN customer_addresses AS T2 ON T1.address_id = T2.address_id WHERE T2.customer_id = 10"
        ],
        "rule_sql": [
            "SELECT T1.address_details\nFROM Addresses T1\nINNER JOIN Customer_Addresses T2 ON T1.address_id = T2.address_id\nWHERE T2.customer_id = 10"
        ]
    },
    "6951": {
        "db_id": "architecture",
        "question": "What are the names of the mills which are not located in 'Donceel'?",
        "ground_truth": "SELECT name FROM mill WHERE LOCATION != 'Donceel'",
        "amends": [
            "Do reference table `mill` instead of `mills` in the FROM clause. Do use inequality filter `LOCATION != 'Donceel'` instead of equality filter `location = 'Donceel'` in the WHERE clause. The amended query now correctly filters for mills not located in Donceel instead of those located in Donceel."
        ],
        "rules": [
            "1) When the question asks about mills: use the exact table name \"mill\" instead of \"mills\". 2) When filtering for mills not located in 'Donceel': use the inequality condition LOCATION != 'Donceel' instead of equality. 3) When handling the literal 'Donceel': preserve the exact case and spelling as 'Donceel'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM mills WHERE location = 'Donceel';",
            "SELECT name FROM mill WHERE location != 'Donceel';"
        ],
        "rule_sql": [
            "SELECT name FROM mill WHERE location != 'Donceel';"
        ]
    },
    "1646": {
        "db_id": "wedding",
        "question": "Show the church names for the weddings of all people older than 30.",
        "ground_truth": "SELECT T4.name FROM wedding AS T1 JOIN people AS T2 ON T1.male_id  =  T2.people_id JOIN people AS T3 ON T1.female_id  =  T3.people_id JOIN church AS T4 ON T4.church_id  =  T1.church_id WHERE T2.age  >  30 OR T3.age  >  30",
        "amends": [
            "Do select `T4.name` instead of `church_name` and add joins to `people` tables `T2` and `T3` instead of querying only the `weddings` table. Do use `JOIN` operations with `ON T1.male_id = T2.people_id` and `ON T1.female_id = T3.people_id` instead of no joins, and add a `JOIN` to `church AS T4` with `ON T4.church_id = T1.church_id` instead of omitting the church table. Do change the WHERE filter to `T2.age > 30 OR T3.age > 30` instead of `age > 30` to properly check both male and female ages, and remove the incorrect direct reference to `age` from the weddings table. The amended query now correctly retrieves church names where either wedding participant is over 30, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"church names for weddings\": make sure the output order: T4.name\n2) When combining tables for wedding information: link weddings table T1 with people table T2 using T1.male_id = T2.people_id and with people table T3 using T1.female_id = T3.people_id, and with church table T4 using T4.church_id = T1.church_id, keeping only matching pairs (inner match)\n3) When checking for people older than 30: filter where T2.age > 30 OR T3.age > 30 to include weddings where either the male or female participant is over 30\n4) When selecting church names: use T4.name instead of church_name from the weddings table"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT church_name FROM weddings WHERE age > 30;",
            "SELECT T4.Name \nFROM wedding AS T1\nJOIN people AS T2 ON T1.Male_ID = T2.People_ID\nJOIN people AS T3 ON T1.Female_ID = T3.People_ID\nJOIN church AS T4 ON T4.Church_ID = T1.Church_ID\nWHERE T2.Age > 30 OR T3.Age > 30"
        ],
        "rule_sql": [
            "SELECT T4.name \nFROM wedding T1\nINNER JOIN people T2 ON T1.Male_ID = T2.People_ID\nINNER JOIN people T3 ON T1.Female_ID = T3.People_ID\nINNER JOIN church T4 ON T4.Church_ID = T1.Church_ID\nWHERE T2.Age > 30 OR T3.Age > 30\nORDER BY T4.name"
        ]
    },
    "1530": {
        "db_id": "insurance_and_eClaims",
        "question": "Which customers have the substring \"Diana\" in their names? Return the customer details.",
        "ground_truth": "SELECT customer_details FROM customers WHERE customer_details LIKE \"%Diana%\"",
        "amends": [
            "Do select `customer_details` instead of `*` to return only the specific column instead of all columns. Do use double quotes around the pattern `\"%Diana%\"` instead of single quotes for string literal consistency. The amended query now correctly returns only the customer_details column containing 'Diana' instead of all customer columns, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"customer details\": return only the \"customer_details\" column instead of all columns. 2) When searching for the substring \"Diana\" in customer names: use the pattern \"%Diana%\" with double quotes for string literals."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM customers WHERE name LIKE '%Diana%';",
            "SELECT Customer_Details FROM Customers WHERE Customer_Details LIKE \"%Diana%\""
        ],
        "rule_sql": [
            "SELECT Customer_Details FROM Customers WHERE Customer_Details LIKE \"%Diana%\";"
        ]
    },
    "961": {
        "db_id": "medicine_enzyme_interaction",
        "question": "How many enzymes do not have any interactions?",
        "ground_truth": "SELECT count(*) FROM enzyme WHERE id NOT IN ( SELECT enzyme_id FROM medicine_enzyme_interaction );",
        "amends": [
            "Do select from `enzyme` table instead of `enzymes` table. Do use `count(*)` with a subquery condition instead of checking for `NULL` values. Do filter with `id NOT IN (SELECT enzyme_id FROM medicine_enzyme_interaction)` instead of `interaction_id IS NULL`. Do remove the incorrect column reference `interaction_id` and instead use a proper subquery to identify enzymes without interactions through the join table `medicine_enzyme_interaction`. The amended query now correctly counts enzymes that have no associated interactions in the medicine-enzyme relationship table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"enzymes\": use the exact table name \"enzyme\" instead of \"enzymes\". 2) When counting enzymes without interactions: use a subquery condition with \"id NOT IN (SELECT enzyme_id FROM medicine_enzyme_interaction)\" instead of checking for NULL values. 3) When the question mentions \"interactions\": this refers to entries in the \"medicine_enzyme_interaction\" table through the \"enzyme_id\" column. 4) When producing the count: use \"count(*)\" to count all enzymes that satisfy the no-interaction condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM enzymes WHERE interaction_id IS NULL;",
            "SELECT COUNT(*) FROM enzyme WHERE id NOT IN (SELECT enzyme_id FROM medicine_enzyme_interaction)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM enzyme WHERE id NOT IN (SELECT enzyme_id FROM medicine_enzyme_interaction)"
        ]
    },
    "5162": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "What are the names of the workshop groups that have bookings with status code \"stop\"?",
        "ground_truth": "SELECT T2.Store_Name FROM Bookings AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T1.Status_Code  =  \"stop\"",
        "amends": [
            "Do select `T2.Store_Name` instead of `name` and change the source to `Bookings AS T1 JOIN Drama_Workshop_Groups AS T2` instead of `workshop_groups`. Do use `ON T1.Workshop_Group_ID = T2.Workshop_Group_ID` instead of no join condition. Do filter on `T1.Status_Code = \"stop\"` instead of `status = 'stop'` and use double quotes instead of single quotes. The amended query now correctly joins the Bookings and Drama_Workshop_Groups tables to retrieve store names for stopped workshop groups."
        ],
        "rules": [
            "1) When answering about workshop group names with bookings having status code \"stop\": make sure the output order: T2.Store_Name\n2) When the question mentions \"workshop groups\": \"workshop groups\" actually means \"Drama_Workshop_Groups as T2\" in schema\n3) When the question mentions \"bookings with status code\": \"bookings\" actually means \"Bookings as T1\" and \"status code\" actually means \"T1.Status_Code\" in schema\n4) When combining T1 and T2 for shared entities: link rows where T1.Workshop_Group_ID = T2.Workshop_Group_ID; keep only matching pairs (inner match)\n5) When filtering for status code \"stop\": use exact literal \"stop\" with double quotes as T1.Status_Code = \"stop\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM workshop_groups WHERE status = 'stop';",
            "SELECT T2.Store_Name \nFROM Bookings AS T1 \nJOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID = T2.Workshop_Group_ID \nWHERE T1.Status_Code = \"stop\""
        ],
        "rule_sql": [
            "SELECT T2.Store_Name\nFROM Bookings AS T1\nINNER JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID = T2.Workshop_Group_ID\nWHERE T1.Status_Code = \"stop\""
        ]
    },
    "5094": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "Show all the planned delivery dates and actual delivery dates of bookings.",
        "ground_truth": "SELECT Planned_Delivery_Date ,  Actual_Delivery_Date FROM BOOKINGS",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT planned_delivery_date, actual_delivery_date FROM bookings WHERE planned_delivery_date IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT Planned_Delivery_Date, Actual_Delivery_Date FROM Bookings;"
        ]
    },
    "1097": {
        "db_id": "match_season",
        "question": "What is the position that is most common among players in match seasons?",
        "ground_truth": "SELECT POSITION FROM match_season GROUP BY POSITION ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `POSITION` instead of `position, COUNT(*) as count` and do group by `POSITION` instead of `position`. Do order by `count(*) DESC` instead of `count DESC` and do use table `match_season` instead of `players`. The amended query now correctly returns the position with the highest count from the match_season table.",
            "Do select only `POSITION` instead of selecting both `Position` and `COUNT(*) as count`. Do remove the alias `count` from the aggregate function instead of keeping it. Do maintain the same `GROUP BY POSITION` clause but use uppercase column name instead of mixed case. Do keep the `ORDER BY count(*) DESC` and `LIMIT 1` unchanged as they correctly identify the position with the highest count. The amended query now matches RIGHT_SQL's behavior by returning only the position value with the maximum occurrence count rather than returning both the position and the count value."
        ],
        "rules": [
            "1) When answering about \"most common position among players in match seasons\": make sure the output order: POSITION, count(*) 2) When the question mentions \"position\": \"position\" actually means \"POSITION in schema\" 3) When the question mentions \"most common\": rank rows by count(*) in descending order and keep the first 1 row. 4) When the question asks for \"count of players per position\": compute the number of rows using the column POSITION for grouping. 5) When using the match_season table: use the exact table name \"match_season\" with the column \"POSITION\" exactly as shown in the schema.",
            "1) When answering about \"most common position among players\": make sure the output order: only the Position column value. 2) When counting occurrences of positions: count all rows using the canonical key (each row represents a player position). 3) When the question mentions \"most common\": rank positions by count in descending order and keep only the first position (highest count). 4) When grouping by position: organize results by the exact column token \"POSITION\" (uppercase as shown in amends). 5) When handling column identifiers: use exact uppercase form \"POSITION\" instead of mixed case \"Position\"."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT position, COUNT(*) as count FROM players GROUP BY position ORDER BY count DESC LIMIT 1;",
            "SELECT Position, COUNT(*) as count FROM match_season GROUP BY Position ORDER BY COUNT(*) DESC LIMIT 1",
            "SELECT POSITION FROM match_season GROUP BY POSITION ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT POSITION, COUNT(*) AS count\nFROM match_season\nGROUP BY POSITION\nORDER BY count DESC\nLIMIT 1"
        ]
    },
    "332": {
        "db_id": "product_catalog",
        "question": "Which catalog contents have length below 3 or above 5? Find the catalog entry names.",
        "ground_truth": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5",
        "amends": [
            "Do select `catalog_entry_name` instead of `name` and use table `catalog_contents` instead of `catalog`. Do change the condition to `LENGTH < 3 OR width > 5` instead of `length < 3 AND length > 5`, replacing the impossible AND condition with a logical OR that includes the new `width` column instead of the redundant second `length` check. The amended query now correctly retrieves records where either the length is less than 3 or the width is greater than 5, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about catalog contents: use table \"Catalog_Contents\" instead of \"catalog\". 2) When selecting catalog entry names: use column \"catalog_entry_name\" instead of \"name\". 3) When filtering for length below 3 or width above 5: use condition \"length\" < 3 OR \"width\" > 5 instead of \"length\" < 3 AND \"length\" > 5."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM catalog WHERE length < 3 AND length > 5;",
            "SELECT catalog_entry_name FROM Catalog_Contents WHERE length < 3 OR width > 5;"
        ],
        "rule_sql": [
            "SELECT catalog_entry_name FROM Catalog_Contents WHERE length < 3 OR width > 5;"
        ]
    },
    "1307": {
        "db_id": "performance_attendance",
        "question": "How many performances are there?",
        "ground_truth": "SELECT count(*) FROM performance",
        "amends": [
            "Do query the `performance` table instead of the `artists` table. Do count records from the performance data source instead of the artists data source. The amended query now correctly counts performance records as specified in the target output."
        ],
        "rules": [
            "1) When answering about \"how many performances\": make sure to count records from the \"performance\" table instead of the \"artists\" table. 2) When counting performances: compute the number of rows using the canonical key from the performance table as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM artists;",
            "SELECT COUNT(*) FROM performance;"
        ],
        "rule_sql": [
            "SELECT COUNT(Performance_ID) FROM performance;"
        ]
    },
    "4451": {
        "db_id": "network_2",
        "question": "What are the names of everybody who has exactly one friend?",
        "ground_truth": "SELECT name FROM PersonFriend GROUP BY name HAVING count(*)  =  1",
        "amends": [
            "Do use `GROUP BY name` and `HAVING count(*) = 1` instead of `WHERE COUNT(friends) = 1` to properly aggregate and filter grouped results. Do reference table `PersonFriend` instead of `people` as the correct data source. Do remove the incorrect column reference `friends` in the aggregate function and use `count(*)` instead to count the number of friend records per person. Do add the necessary grouping clause instead of attempting to use an aggregate function directly in the WHERE clause, which is syntactically invalid. The amended query now correctly identifies persons with exactly one friend by grouping and counting records in the PersonFriend table."
        ],
        "rules": [
            "1) When answering about \"names of everybody who has exactly one friend\": use table \"PersonFriend\" as the data source instead of \"people\". 2) When counting the number of friends per person: use count(*) to count the number of friend records per person instead of referencing a \"friends\" column. 3) When filtering for persons with exactly one friend: use GROUP BY name and HAVING count(*) = 1 instead of WHERE COUNT(friends) = 1 to properly aggregate and filter grouped results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM people WHERE COUNT(friends) = 1;",
            "SELECT name FROM PersonFriend GROUP BY name HAVING COUNT(*) = 1"
        ],
        "rule_sql": [
            "SELECT name FROM PersonFriend GROUP BY name HAVING COUNT(*) = 1"
        ]
    },
    "6660": {
        "db_id": "driving_school",
        "question": "List email address and birthday of customer whose first name as Carole.",
        "ground_truth": "SELECT email_address ,  date_of_birth FROM Customers WHERE first_name = \"Carole\"",
        "amends": [
            "Do select `email_address` and `date_of_birth` instead of `email` and `birthday` to use the correct column names from the schema. Do reference the table as `Customers` instead of `customers` to match the proper table name casing. Do use double quotes `\"Carole\"` instead of single quotes `'Carole'` for the string literal in the WHERE clause, though this is a cosmetic formatting difference that doesn't affect functionality. The amended query now correctly retrieves the email address and date of birth columns from the Customers table for records where first_name equals Carole, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting email information from the Customers table: use the exact column name \"email_address\" instead of \"email\". 2) When selecting birthday information from the Customers table: use the exact column name \"date_of_birth\" instead of \"birthday\". 3) When referencing the customer table: use the exact table name \"Customers\" with proper casing. 4) When filtering by first name with value Carole: use the exact string literal \"Carole\" with double quotes as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT email, birthday FROM customers WHERE first_name = 'Carole'",
            "SELECT email_address, date_of_birth FROM Customers WHERE first_name = \"Carole\";"
        ],
        "rule_sql": [
            "SELECT email_address, date_of_birth FROM Customers WHERE first_name = \"Carole\";"
        ]
    },
    "2874": {
        "db_id": "icfp_1",
        "question": "Who belong to the institution \"University of Oxford\"? Show the first names and last names.",
        "ground_truth": "SELECT DISTINCT t1.fname ,  t1.lname FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN inst AS t3 ON t2.instid  =  t3.instid WHERE t3.name  =  \"University of Oxford\"",
        "amends": [
            "Do select `t1.fname` and `t1.lname` with `DISTINCT` instead of `first_name` and `last_name` without distinct. Do use `authors AS t1` joined with `authorship AS t2` on `t1.authid = t2.authid` instead of a single `people` table. Do add a second join to `inst AS t3` on `t2.instid = t3.instid` instead of omitting this table. Do filter on `t3.name = \"University of Oxford\"` instead of `institution = 'University of Oxford'`. The amended query now correctly identifies unique authors from the specified institution through proper table relationships."
        ],
        "rules": [
            "1) When answering about \"Who belong to the institution 'University of Oxford'\": make sure the output order: t1.fname, t1.lname 2) When the question mentions \"first names and last names\": \"first names\" actually means \"t1.fname in schema\" and \"last names\" actually means \"t1.lname in schema\" 3) When combining tables for authors and their institutional affiliations: link t1 (authors) and t2 (authorship) where t1.authid = t2.authid, then link t2 and t3 (inst) where t2.instid = t3.instid; keep only matching pairs (inner match) 4) When filtering for institution \"University of Oxford\": use exact literal \"University of Oxford\" with t3.name = \"University of Oxford\" 5) When selecting author names: use DISTINCT to show unique combinations of t1.fname and t1.lname"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM people WHERE institution = 'University of Oxford'",
            "SELECT DISTINCT t1.fname, t1.lname FROM Authors AS t1 JOIN Authorship AS t2 ON t1.authID = t2.authID JOIN Inst AS t3 ON t2.instID = t3.instID WHERE t3.name = 'University of Oxford'"
        ],
        "rule_sql": [
            "SELECT DISTINCT t1.fname, t1.lname\nFROM Authors t1\nINNER JOIN Authorship t2 ON t1.authID = t2.authID\nINNER JOIN Inst t3 ON t2.instID = t3.instID\nWHERE t3.name = \"University of Oxford\"\nORDER BY t1.fname, t1.lname"
        ]
    },
    "6195": {
        "db_id": "music_4",
        "question": "What is the issue date of the volume with the minimum weeks on top?",
        "ground_truth": "SELECT Issue_Date FROM volume ORDER BY Weeks_on_Top ASC LIMIT 1",
        "amends": [
            "Do select `Issue_Date` instead of `issue_date` and use `ORDER BY Weeks_on_Top ASC LIMIT 1` instead of a subquery with `MAX(weeks_on_top)`. Do reference table `volume` instead of `volumes` and remove the WHERE clause entirely instead of filtering by maximum weeks. The amended query now correctly retrieves the earliest issue date by ordering ascending and limiting to one result, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"issue date\": use the exact column token \"Issue_Date\" from the volume table. 2) When the question asks for the volume with minimum weeks on top: order rows by \"Weeks_on_Top\" in ascending order and keep only the first row. 3) When referencing the table containing volume data: use the exact table name \"volume\" instead of any pluralized form."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT issue_date FROM volumes WHERE weeks_on_top = (SELECT MAX(weeks_on_top) FROM volumes);",
            "SELECT Issue_Date FROM volume ORDER BY Weeks_on_Top ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Issue_Date FROM volume ORDER BY Weeks_on_Top ASC LIMIT 1;"
        ]
    },
    "2893": {
        "db_id": "icfp_1",
        "question": "Find the titles of the papers the author \"Stephanie Weirich\" wrote.",
        "ground_truth": "SELECT t3.title FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid WHERE t1.fname  =  \"Stephanie\" AND t1.lname  =  \"Weirich\"",
        "amends": [
            "Do join `authors AS t1` and `authorship AS t2` on `t1.authid = t2.authid` instead of querying `papers` directly without proper joins. Do join `papers AS t3` on `t2.paperid = t3.paperid` instead of missing the authorship relationship. Do filter on `t1.fname = \"Stephanie\" AND t1.lname = \"Weirich\"` instead of incorrectly filtering `author = 'Stephanie Weirich'` which doesn't match the schema structure. Do select `t3.title` with proper table qualification instead of just `title` without source specification. The amended query now correctly retrieves papers by joining through the authorship relationship and properly filtering on first and last name fields."
        ],
        "rules": [
            "1) When the question asks for papers by an author: join authors table as T1 with authorship table as T2 using T1.authid = T2.authid to establish the author-authorship relationship. 2) When joining authorship with papers: join authorship table as T2 with papers table as T3 using T2.paperid = T3.paperid to connect authorship records to paper details. 3) When filtering for author \"Stephanie Weirich\": use T1.fname = \"Stephanie\" AND T1.lname = \"Weirich\" instead of a single author field, as the schema stores first and last names separately. 4) When selecting paper titles: use T3.title with proper table qualification instead of just title to specify the source table. 5) When combining tables for author-paper relationships: perform inner joins on the exact key equalities T1.authid = T2.authid and T2.paperid = T3.paperid to ensure only matching author-paper pairs are included."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM papers WHERE author = 'Stephanie Weirich';",
            "SELECT t3.title \nFROM Authors AS t1 \nJOIN Authorship AS t2 ON t1.authID = t2.authID \nJOIN Papers AS t3 ON t2.paperID = t3.paperID \nWHERE t1.fname = 'Stephanie' AND t1.lname = 'Weirich'"
        ],
        "rule_sql": [
            "SELECT T3.title \nFROM Authors AS T1\nINNER JOIN Authorship AS T2 ON T1.authID = T2.authID\nINNER JOIN Papers AS T3 ON T2.paperID = T3.paperID\nWHERE T1.fname = 'Stephanie' AND T1.lname = 'Weirich'"
        ]
    },
    "1243": {
        "db_id": "apartment_rentals",
        "question": "How many rooms in total are there in the apartments in the building with short name \"Columbus Square\"?",
        "ground_truth": "SELECT sum(T2.room_count) FROM Apartment_Buildings AS T1 JOIN Apartments AS T2 ON T1.building_id  =  T2.building_id WHERE T1.building_short_name  =  \"Columbus Square\"",
        "amends": [
            "Do use `sum(T2.room_count)` instead of `COUNT(*)` to sum actual room counts rather than counting rows. Do join `Apartment_Buildings AS T1` and `Apartments AS T2` on `T1.building_id = T2.building_id` instead of querying only the `rooms` table. Do filter on `T1.building_short_name = \"Columbus Square\"` instead of `building_short_name = 'Columbus Square'` to reference the correct table and use double quotes. The amended query now correctly calculates the total room count for the specified building by joining the building and apartment tables and summing room counts."
        ],
        "rules": [
            "1) When answering about \"total rooms in apartments in a building\": use sum(T2.room_count) instead of counting rows to sum actual room counts. 2) When combining Apartment_Buildings and Apartments tables: link rows where T1.building_id = T2.building_id and keep only matching pairs (inner match). 3) When filtering by building short name: use T1.building_short_name = \"Columbus Square\" with double quotes around the literal value. 4) When the question mentions \"building with short name\": \"building_short_name\" in Apartment_Buildings table (T1) contains the exact value to match."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM rooms WHERE building_short_name = 'Columbus Square';",
            "SELECT SUM(CAST(T2.room_count AS INTEGER)) AS total_rooms\nFROM Apartment_Buildings AS T1\nJOIN Apartments AS T2 ON T1.building_id = T2.building_id\nWHERE T1.building_short_name = \"Columbus Square\""
        ],
        "rule_sql": [
            "SELECT SUM(CAST(T2.room_count AS INTEGER)) AS total_rooms\nFROM Apartment_Buildings T1\nINNER JOIN Apartments T2 ON T1.building_id = T2.building_id\nWHERE T1.building_short_name = \"Columbus Square\""
        ]
    },
    "1385": {
        "db_id": "college_2",
        "question": "What are the names of students and their respective departments, ordered by number of credits from least to greatest?",
        "ground_truth": "SELECT name ,  dept_name FROM student ORDER BY tot_cred",
        "amends": [
            "Do select `dept_name` instead of `department` and order by `tot_cred` instead of `credits DESC`. Do use table `student` instead of `students`. The amended query now correctly references the appropriate column names and table while maintaining the intended sorting behavior."
        ],
        "rules": [
            "1) When the question asks for student names and departments: use table \"student\" (not \"students\") and select columns \"name\" and \"dept_name\" (not \"department\"). 2) When ordering by number of credits: use column \"tot_cred\" (not \"credits\") and order from least to greatest (ascending order, not descending)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, department FROM students ORDER BY credits DESC;",
            "SELECT name, dept_name FROM student ORDER BY tot_cred ASC;"
        ],
        "rule_sql": [
            "SELECT name, dept_name FROM student ORDER BY tot_cred ASC;"
        ]
    },
    "1511": {
        "db_id": "insurance_and_eClaims",
        "question": "Which type of policy is most frequently used? Give me the policy type code.",
        "ground_truth": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `policy_type_code` instead of including `COUNT(*) as frequency` in the SELECT list. Do order by `count(*) DESC` instead of `frequency ASC` to find the most frequent policy type rather than the least frequent. Do remove the explicit column alias `frequency` since it's no longer needed in the ORDER BY clause. The amended query now correctly identifies the policy type with the highest frequency count by ordering in descending order rather than ascending order."
        ],
        "rules": [
            "1) When answering about \"most frequently used policy type\": make sure the output order includes only policy_type_code. 2) When counting frequency of policy types: count all rows using the canonical counting method. 3) When the question asks for \"most frequently used\": rank policy types by count in descending order and keep the first row. 4) When ordering by frequency count: use descending order to find the highest frequency rather than ascending order. 5) When producing final output: do not include the frequency count column in the results, only show the policy_type_code."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT policy_type_code, COUNT(*) as frequency FROM policies GROUP BY policy_type_code ORDER BY frequency ASC LIMIT 1;",
            "SELECT Policy_Type_Code FROM Policies GROUP BY Policy_Type_Code ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Policy_Type_Code \nFROM Policies \nGROUP BY Policy_Type_Code \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ]
    },
    "1145": {
        "db_id": "climbing",
        "question": "What are the countries that have both mountains that are higher than 5600 and lower than 5200?",
        "ground_truth": "SELECT Country FROM mountain WHERE Height  >  5600 INTERSECT SELECT Country FROM mountain WHERE Height  <  5200",
        "amends": [
            "Do use `INTERSECT` to find countries with both high and low mountains instead of using `AND` with contradictory height conditions. Do reference table `mountain` instead of `mountains` and column `Country` instead of `country`. Do use separate queries for each height condition instead of combining them in a single `WHERE` clause. Do remove the `DISTINCT` keyword since `INTERSECT` inherently returns unique results instead of keeping it. Do use proper column name `Height` instead of `height` and maintain the correct height thresholds of greater than 5600 and less than 5200. The amended query now correctly identifies countries that contain both very tall mountains (over 5600) and very short mountains (under 5200) by using set intersection logic instead of the impossible condition of a mountain being simultaneously above 5600 and below 5200."
        ],
        "rules": [
            "1) When the question asks for countries with both mountains higher than 5600 and lower than 5200: use INTERSECT to combine results from two separate queries instead of using AND with contradictory height conditions. 2) When referencing the mountain table: use exact table name \"mountain\" instead of \"mountains\". 3) When referencing the country column: use exact column name \"Country\" instead of \"country\". 4) When filtering for mountains higher than 5600: use condition Height > 5600. 5) When filtering for mountains lower than 5200: use condition Height < 5200. 6) When using INTERSECT: do not include DISTINCT keyword as INTERSECT inherently returns unique results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT country \nFROM mountains \nWHERE height > 5600 AND height < 5200;",
            "SELECT Country FROM mountain WHERE Height > 5600\nINTERSECT\nSELECT Country FROM mountain WHERE Height < 5200"
        ],
        "rule_sql": [
            "SELECT Country FROM mountain WHERE Height > 5600\nINTERSECT\nSELECT Country FROM mountain WHERE Height < 5200"
        ]
    },
    "3926": {
        "db_id": "hospital_1",
        "question": "What is the name of the nurse has the most appointments?",
        "ground_truth": "SELECT T1.name FROM nurse AS T1 JOIN appointment AS T2 ON T1.employeeid  =  T2.prepnurse GROUP BY T1.employeeid ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.name` with explicit table alias instead of just `name`. Do join `nurse AS T1` with `appointment AS T2` on `T1.employeeid = T2.prepnurse` instead of querying only the `nurses` table. Do add `GROUP BY T1.employeeid` to aggregate appointments per nurse instead of relying on a non-existent `appointment_count` column. Do order by `count(*) DESC` to sort by actual appointment count instead of the missing `appointment_count` column. The amended query now correctly counts appointments per nurse and returns the nurse with the highest appointment count, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"the nurse has the most appointments\": make sure the output order: T1.name. 2) When the question asks for \"count of appointments per nurse\": compute the number of rows using the canonical key T1.employeeid and group by T1.employeeid. 3) When combining nurse AS T1 and appointment AS T2: link rows where T1.employeeid = T2.prepnurse and keep only matching pairs (inner match). 4) When the question mentions \"most appointments\": rank rows by count(*) in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM nurses ORDER BY appointment_count DESC LIMIT 1;",
            "SELECT T1.Name\nFROM Nurse AS T1\nJOIN Appointment AS T2 ON T1.EmployeeID = T2.PrepNurse\nGROUP BY T1.EmployeeID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Name\nFROM Nurse AS T1\nINNER JOIN Appointment AS T2 ON T1.EmployeeID = T2.PrepNurse\nGROUP BY T1.EmployeeID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "3995": {
        "db_id": "hospital_1",
        "question": "Count how many appointments have been made in total.",
        "ground_truth": "SELECT count(*) FROM appointment",
        "amends": [
            "Do reference the `appointment` table instead of the `appointments` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. Do remove the `WHERE appointment_id IS NULL` filter instead of keeping it, as the right query counts all records without filtering for null values. The amended query now correctly counts all records in the appointment table without unnecessary filtering."
        ],
        "rules": [
            "1) When counting all appointments: count all records in the \"appointment\" table without any filtering conditions. 2) When referring to the appointment entity: use the exact table name \"appointment\" (not \"appointments\"). 3) When performing counting operations: use lowercase \"count(*)\" for consistency with the schema requirements."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM appointments WHERE appointment_id IS NULL;",
            "SELECT count(*) FROM appointment;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM appointment;"
        ]
    },
    "5866": {
        "db_id": "tracking_share_transactions",
        "question": "Show the average transaction amount for different transaction types.",
        "ground_truth": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code",
        "amends": [
            "Do select `transaction_type_code` instead of `transaction_type` and `avg(amount_of_transaction)` instead of `AVG(transaction_amount)`. Do group by `transaction_type_code` instead of `transaction_id` to correctly calculate average transaction amounts by transaction type rather than per individual transaction. The amended query now matches RIGHT_SQL's behavior by properly aggregating transactions by their type codes."
        ],
        "rules": [
            "1) When the question asks for \"transaction types\": use the exact column \"transaction_type_code\" from the Transactions table. 2) When calculating average transaction amount: use the exact column \"amount_of_transaction\" with the avg function. 3) When grouping by transaction type: group by \"transaction_type_code\" instead of transaction_id to aggregate by type rather than individual transactions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT transaction_type, AVG(transaction_amount) FROM transactions GROUP BY transaction_id;",
            "SELECT transaction_type_code, AVG(amount_of_transaction) AS average_transaction_amount FROM Transactions GROUP BY transaction_type_code"
        ],
        "rule_sql": [
            "SELECT transaction_type_code, AVG(amount_of_transaction) AS average_transaction_amount FROM Transactions GROUP BY transaction_type_code;"
        ]
    },
    "2651": {
        "db_id": "local_govt_mdm",
        "question": "What are the renting arrears tax ids related to the customer master index whose detail is not 'Schmidt, Kertzmann and Lubowitz'?",
        "ground_truth": "SELECT T1.council_tax_id FROM Rent_Arrears AS T1 JOIN CMI_Cross_References AS T2 ON T1.cmi_cross_ref_id  =  T2.cmi_cross_ref_id JOIN Customer_Master_Index AS T3 ON T3.master_customer_id  =  T2.master_customer_id WHERE T3.cmi_details != 'Schmidt ,  Kertzmann and Lubowitz'",
        "amends": [
            "Do use `SELECT T1.council_tax_id` instead of `SELECT tax_id`. Do add `JOIN CMI_Cross_References AS T2 ON T1.cmi_cross_ref_id = T2.cmi_cross_ref_id` and `JOIN Customer_Master_Index AS T3 ON T3.master_customer_id = T2.master_customer_id` instead of querying `renting_arrears` directly with a subquery. Do change the filter to `T3.cmi_details != 'Schmidt ,  Kertzmann and Lubowitz'` instead of `customer_master_index NOT IN (SELECT id FROM customer_master WHERE detail = 'Schmidt, Kertzmann and Lubowitz')`. Do remove the subquery entirely instead of using it for filtering. The amended query now correctly joins through the cross-reference table to access customer details and matches the RIGHT_SQL's behavior.",
            "Do use `T3.cmi_details != 'Schmidt ,  Kertzmann and Lubowitz'` instead of `T3.cmi_details != 'Schmidt, Kertzmann and Lubowitz'` to properly handle the comma spacing in the string comparison. The amended query now matches RIGHT_SQL's behavior with the corrected string literal format."
        ],
        "rules": [
            "1) When selecting tax identifiers from renting arrears: use \"T1.council_tax_id\" as the output column instead of \"tax_id\". 2) When relating renting arrears to customer master index: join through \"CMI_Cross_References\" as T2 using \"T1.cmi_cross_ref_id = T2.cmi_cross_ref_id\" and then join to \"Customer_Master_Index\" as T3 using \"T3.master_customer_id = T2.master_customer_id\" instead of direct subquery filtering. 3) When filtering for customer details not equal to a specific value: use \"T3.cmi_details != 'Schmidt ,  Kertzmann and Lubowitz'\" with exact spacing and punctuation as shown. 4) When the question asks about renting arrears tax ids related to customer master index: ensure the query structure uses explicit joins through cross-reference tables rather than subqueries.",
            "1) When the question asks for renting arrears tax ids related to customer master index: select T1.council_tax_id from Rent_Arrears as T1 joined with CMI_Cross_References as T2 on T1.cmi_cross_ref_id = T2.cmi_cross_ref_id, then joined with Customer_Master_Index as T3 on T3.master_customer_id = T2.master_customer_id. 2) When filtering for customer details not equal to 'Schmidt ,  Kertzmann and Lubowitz': use T3.cmi_details != 'Schmidt ,  Kertzmann and Lubowitz' with exact spacing around the comma. 3) When handling string literals: preserve the exact spacing and punctuation as shown in 'Schmidt ,  Kertzmann and Lubowitz' with two spaces after the comma."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT tax_id FROM renting_arrears WHERE customer_master_index NOT IN (SELECT id FROM customer_master WHERE detail = 'Schmidt, Kertzmann and Lubowitz')",
            "SELECT T1.council_tax_id \nFROM Rent_Arrears AS T1\nJOIN CMI_Cross_References AS T2 ON T1.cmi_cross_ref_id = T2.cmi_cross_ref_id\nJOIN Customer_Master_Index AS T3 ON T3.master_customer_id = T2.master_customer_id\nWHERE T3.cmi_details != 'Schmidt, Kertzmann and Lubowitz'",
            "SELECT T1.council_tax_id \nFROM Rent_Arrears AS T1\nJOIN CMI_Cross_References AS T2 ON T1.cmi_cross_ref_id = T2.cmi_cross_ref_id\nJOIN Customer_Master_Index AS T3 ON T3.master_customer_id = T2.master_customer_id\nWHERE T3.cmi_details != 'Schmidt ,  Kertzmann and Lubowitz'"
        ],
        "rule_sql": [
            "SELECT T1.council_tax_id \nFROM Rent_Arrears AS T1\nJOIN CMI_Cross_References AS T2 ON T1.cmi_cross_ref_id = T2.cmi_cross_ref_id\nJOIN Customer_Master_Index AS T3 ON T3.master_customer_id = T2.master_customer_id\nWHERE T3.cmi_details != 'Schmidt ,  Kertzmann and Lubowitz'"
        ]
    },
    "3542": {
        "db_id": "music_1",
        "question": "What are the names of the artists who sang the shortest song?",
        "ground_truth": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1",
        "amends": [
            "Do select `T1.artist_name` from the `song` table instead of `artist_name` from the `artists` table. Do join `files AS T2` on `T1.f_id = T2.f_id` instead of querying a single table without any joins. Do order by `T2.duration` instead of `song_duration` to reference the correct column from the joined files table. The amended query now correctly retrieves the artist with the shortest song duration by joining the song and files tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"artists who sang the shortest song\": make sure the output order: T1.artist_name. 2) When the question mentions \"shortest song\": use T2.duration for ordering in ascending direction to find the minimum duration. 3) When combining T1 (song table) and T2 (files table) for shared entities: link rows where T1.f_id = T2.f_id exactly as shown; keep only matching pairs (inner match). 4) When the question asks for \"names of the artists\": select T1.artist_name from the song table, not from an artists table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT artist_name FROM artists ORDER BY song_duration ASC LIMIT 1;",
            "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id = T2.f_id ORDER BY T2.duration LIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.artist_name FROM song T1 JOIN files T2 ON T1.f_id = T2.f_id ORDER BY T2.duration ASC LIMIT 1"
        ]
    },
    "4761": {
        "db_id": "department_store",
        "question": "List the name of staff who has been assigned multiple jobs.",
        "ground_truth": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  1",
        "amends": [
            "Do select `T1.staff_name` instead of `name` and use table aliases. Do add `staff_department_assignments AS T2` as a joined table instead of querying only the `staff` table. Do use `JOIN` with `ON T1.staff_id = T2.staff_id` instead of no join condition. Do group by `T2.staff_id` instead of `name` to properly count department assignments per staff member. Do use `COUNT(*)` instead of `COUNT(job_id)` to count all department assignments rather than non-null job IDs only. The amended query now correctly identifies staff with multiple department assignments by joining the assignment table and grouping by staff ID."
        ],
        "rules": [
            "1) When answering about \"staff who has been assigned multiple jobs\": use table aliases with T1 for staff table and T2 for staff_department_assignments table. 2) When combining staff and staff_department_assignments tables: link rows where T1.staff_id = T2.staff_id and keep only matching pairs (inner match). 3) When grouping to count department assignments per staff member: group by T2.staff_id instead of name. 4) When counting department assignments: use COUNT(*) to count all department assignments rather than non-null job IDs only. 5) When selecting output: use T1.staff_name instead of name to get the staff name. 6) When filtering for multiple assignments: keep only groups where the count of department assignments is greater than 1."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM staff GROUP BY name HAVING COUNT(job_id) > 1;",
            "SELECT T1.staff_name\nFROM Staff AS T1\nJOIN Staff_Department_Assignments AS T2 ON T1.staff_id = T2.staff_id\nGROUP BY T2.staff_id\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T1.staff_name \nFROM Staff T1\nINNER JOIN Staff_Department_Assignments T2 ON T1.staff_id = T2.staff_id\nGROUP BY T2.staff_id\nHAVING COUNT(*) > 1"
        ]
    },
    "883": {
        "db_id": "chinook_1",
        "question": "What are the birth dates of employees living in Edmonton?",
        "ground_truth": "SELECT BirthDate FROM EMPLOYEE WHERE City  =  \"Edmonton\"",
        "amends": [
            "Do reference `BirthDate` instead of `birth_date` and use `EMPLOYEE` instead of `employees` as the table name. Do filter on `City = \"Edmonton\"` instead of `city = 'Calgary'` to query the correct city location. The amended query now correctly retrieves birth dates from employees located in Edmonton rather than Calgary."
        ],
        "rules": [
            "1) When the question asks about \"birth dates\": use the exact column name \"BirthDate\" from the Employee table. 2) When the question mentions \"employees\": use the exact table name \"EMPLOYEE\" (case-sensitive). 3) When the question specifies employees living in \"Edmonton\": filter using the exact literal \"Edmonton\" for the City column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT birth_date FROM employees WHERE city = 'Calgary';",
            "SELECT BirthDate FROM Employee WHERE City = 'Edmonton';"
        ],
        "rule_sql": [
            "SELECT BirthDate FROM Employee WHERE City = 'Edmonton';"
        ]
    },
    "3672": {
        "db_id": "baseball_1",
        "question": "For each year, return the year and the number of times the team Boston Red Stockings won in the postseasons.",
        "ground_truth": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' GROUP BY T1.year",
        "amends": [
            "Do use `count(*)` without an alias instead of `COUNT(*) as wins`. Do join `postseason AS T1` with `team AS T2` instead of querying `postseason_results` alone. Do specify `ON T1.team_id_winner = T2.team_id_br` instead of filtering by team name directly. Do filter with `T2.name = 'Boston Red Stockings'` in the WHERE clause instead of using `team = 'Boston Red Stockings'`. Do group by `T1.year` instead of `year`. The amended query now correctly joins tables to filter by team name through the team_id relationship and matches the RIGHT_SQL's behavior.",
            "Do place `count(*)` before `T1.year` in the SELECT list instead of having `T1.year` first. Do add a space after the comma in `count(*) , T1.year` instead of omitting it. The amended query now correctly matches the RIGHT_SQL's behavior with identical logic and output structure."
        ],
        "rules": [
            "1) When answering about \"number of times the team Boston Red Stockings won in the postseasons per year\": make sure the output order: year, count(*) 2) When the question mentions \"Boston Red Stockings\": \"Boston Red Stockings\" actually means \"T2.name = 'Boston Red Stockings'\" in schema 3) When combining T1 and T2 for shared entities: link rows where T1.team_id_winner = T2.team_id_br exactly as shown in the amends; keep only matching pairs (inner match) 4) When the question asks for \"count of wins\": compute the number of rows using count(*) without an alias 5) When the question says \"per year\"/\"for each year\": organize results by T1.year and compute requested aggregates per group",
            "1) When answering about \"number of times the team Boston Red Stockings won in the postseasons per year\": make sure the output order: count(*) first, then T1.year 2) When the question mentions \"Boston Red Stockings\": \"Boston Red Stockings\" actually means T2.name = 'Boston Red Stockings' in schema 3) When the question asks for \"count of wins\": compute the number of rows using the canonical key token for wins (T1.team_id_winner) 4) When combining postseason AS T1 and team AS T2 for shared entities: link rows where T1.team_id_winner = T2.team_id_br exactly as shown; keep only matching pairs (inner match) 5) When the question says \"per year\"/\"for each year\": organize results by T1.year and compute requested aggregates per group"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, COUNT(*) as wins\nFROM postseason_results\nWHERE team = 'Boston Red Stockings'\nGROUP BY year;",
            "SELECT T1.year, COUNT(*) \nFROM postseason AS T1 \nJOIN team AS T2 ON T1.team_id_winner = T2.team_id_br \nWHERE T2.name = 'Boston Red Stockings' \nGROUP BY T1.year",
            "SELECT count(*) , T1.year\nFROM postseason AS T1\nJOIN team AS T2 ON T1.team_id_winner = T2.team_id_br\nWHERE T2.name = 'Boston Red Stockings'\nGROUP BY T1.year"
        ],
        "rule_sql": [
            "SELECT T1.year, COUNT(*) \nFROM postseason AS T1 \nINNER JOIN team AS T2 ON T1.team_id_winner = T2.team_id_br \nWHERE T2.name = 'Boston Red Stockings' \nGROUP BY T1.year \nORDER BY T1.year"
        ]
    },
    "2351": {
        "db_id": "csu_1",
        "question": "What campus has the most faculties in 2003?",
        "ground_truth": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1",
        "amends": [
            "Do select `T1.campus` instead of `campus` and remove the `COUNT(*) as faculty_count` aggregation. Do join `campuses AS T1` with `faculty AS T2` instead of querying only the `faculties` table. Do use `ON T1.id = T2.campus` as the join condition instead of no join. Do filter with `T2.year = 2003` instead of `year = 2003`. Do remove the `GROUP BY campus` clause instead of keeping it. Do order by `T2.faculty DESC` instead of `faculty_count DESC`. The amended query now correctly retrieves the campus with the highest faculty count for 2003 by joining the campuses and faculty tables directly."
        ],
        "rules": [
            "1) When answering about \"campus with the most faculties in 2003\": make sure the output order: T1.campus\n2) When combining campuses (T1) and faculty (T2) tables: link rows where T1.id = T2.campus and keep only matching pairs (inner match)\n3) When filtering for year 2003: use T2.year = 2003 exactly\n4) When the question mentions \"most faculties\" or \"highest faculty count\": rank rows by T2.faculty in descending order and keep the first 1 row\n5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT campus, COUNT(*) as faculty_count FROM faculties WHERE year = 2003 GROUP BY campus ORDER BY faculty_count DESC LIMIT 1;",
            "SELECT T1.Campus FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus WHERE T2.Year = 2003 ORDER BY T2.Faculty DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Campus FROM Campuses T1 INNER JOIN faculty T2 ON T1.Id = T2.Campus WHERE T2.Year = 2003 ORDER BY T2.Faculty DESC LIMIT 1"
        ]
    },
    "2725": {
        "db_id": "storm_record",
        "question": "Return the names of the regions affected by storms that had a death count of at least 10.",
        "ground_truth": "SELECT T2.region_name FROM affected_region AS T1 JOIN region AS T2 ON T1.region_id  =  T2.region_id JOIN storm AS T3 ON T1.storm_id  =  T3.storm_id WHERE T3.number_deaths  >=  10",
        "amends": [
            "Do select `T2.region_name` from the `region` table instead of `region_name` from `storms`. Do join `affected_region AS T1` and `region AS T2` on `T1.region_id = T2.region_id` instead of querying `storms` directly. Do add a second join to `storm AS T3` on `T1.storm_id = T3.storm_id` instead of missing this relationship. Do filter with `T3.number_deaths >= 10` in the WHERE clause instead of `death_count > 10` against the wrong table. The amended query now correctly retrieves region names through proper table relationships and filtering logic."
        ],
        "rules": [
            "1) When answering about \"regions affected by storms\": make sure the output order: T2.region_name. 2) When the question mentions \"regions affected by storms\": combine tables affected_region AS T1 and region AS T2 where T1.region_id = T2.region_id and storm AS T3 where T1.storm_id = T3.storm_id, keeping only matching pairs. 3) When the question mentions \"death count of at least 10\": filter using T3.number_deaths >= 10 instead of death_count > 10. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT region_name FROM storms WHERE death_count > 10",
            "SELECT T2.Region_name \nFROM affected_region AS T1\nJOIN region AS T2 ON T1.Region_id = T2.Region_id\nJOIN storm AS T3 ON T1.Storm_ID = T3.Storm_ID\nWHERE T3.Number_Deaths >= 10"
        ],
        "rule_sql": [
            "SELECT T2.region_name \nFROM affected_region AS T1 \nJOIN region AS T2 ON T1.region_id = T2.region_id \nJOIN storm AS T3 ON T1.storm_id = T3.storm_id \nWHERE T3.Number_Deaths >= 10 \nORDER BY T2.region_name"
        ]
    },
    "3687": {
        "db_id": "baseball_1",
        "question": "How many parks are there in Atlanta city?",
        "ground_truth": "SELECT count(*) FROM park WHERE city = 'Atlanta';",
        "amends": [
            "Do reference the `park` table instead of the `parks` table to correctly match the database schema. The amended query now uses the proper table name `park` instead of the incorrect `parks`, ensuring accurate counting of records for Atlanta in the correct database table."
        ],
        "rules": [
            "1) When the question asks about \"parks\": use the exact table name \"park\" from the schema instead of \"parks\". 2) When counting entities in the park table: count all rows where the city column equals 'Atlanta' exactly as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM parks WHERE city = 'Atlanta';",
            "SELECT COUNT(*) FROM park WHERE city = 'Atlanta';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM park WHERE city = 'Atlanta';"
        ]
    },
    "1610": {
        "db_id": "customers_and_invoices",
        "question": "Return the order ids and details for orderes with two or more invoices.",
        "ground_truth": "SELECT T2.order_id ,  T2.order_details FROM Invoices AS T1 JOIN Orders AS T2 ON T1.order_id  =  T2.order_id GROUP BY T2.order_id HAVING count(*)  >  2",
        "amends": [
            "Do select `T2.order_id` and `T2.order_details` instead of `order_id` and `details`. Do add `Invoices AS T1` and `Orders AS T2` with a `JOIN` on `T1.order_id = T2.order_id` instead of querying only the `orders` table. Do remove the `WHERE invoice_count >= 2` filter instead of keeping it. Do add `GROUP BY T2.order_id` instead of omitting grouping. Do add `HAVING count(*) > 2` instead of the removed WHERE clause to filter groups by invoice count. The amended query now correctly identifies orders with more than two invoices by joining the Invoices table and counting occurrences per order, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"order ids and details for orders with two or more invoices\": make sure the output order: T2.order_id, T2.order_details. 2) When the question mentions \"orders with two or more invoices\": join Invoices AS T1 and Orders AS T2 where T1.order_id = T2.order_id to link invoices to their orders. 3) When counting invoices per order: group by T2.order_id and count the number of invoice rows per group. 4) When filtering for orders with two or more invoices: use having count(*) >= 2 to keep only groups with at least two invoices. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT order_id, details FROM orders WHERE invoice_count >= 2",
            "SELECT T2.order_id, T2.order_details\nFROM Invoices AS T1\nJOIN Orders AS T2 ON T1.order_id = T2.order_id\nGROUP BY T2.order_id\nHAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT T2.order_id, T2.order_details\nFROM Invoices AS T1\nJOIN Orders AS T2 ON T1.order_id = T2.order_id\nGROUP BY T2.order_id\nHAVING COUNT(*) >= 2"
        ]
    },
    "5322": {
        "db_id": "manufactory_1",
        "question": "Select the names of all the products in the store.",
        "ground_truth": "SELECT Name FROM Products",
        "amends": [
            "Do specify individual columns by adding `Name` instead of using `*` to select all columns. Do reference the table as `Products` instead of `products` to match the correct case sensitivity. The amended query now matches RIGHT_SQL's behavior by selecting only the Name column from the Products table."
        ],
        "rules": [
            "1) When selecting from the Products table: specify individual columns instead of using * to select all columns. 2) When referencing the Products table: use exact case sensitivity as \"Products\" instead of \"products\". 3) When answering about product names: select only the \"Name\" column from the \"Products\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM products;",
            "SELECT Name FROM Products;"
        ],
        "rule_sql": [
            "SELECT Name FROM Products;"
        ]
    },
    "2843": {
        "db_id": "customer_deliveries",
        "question": "Find the name and price of the product that has been ordered the greatest number of times.",
        "ground_truth": "SELECT t1.product_name ,   t1.product_price FROM products AS t1 JOIN regular_order_products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t2.product_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `product_name` and `product_price` instead of `name` and `price`. Do add `JOIN` with `regular_order_products` on `product_id = product_id` instead of querying only the `products` table. Do add `GROUP BY product_id` and order by `count(*) DESC` instead of ordering by `price DESC` to find the most frequently ordered product rather than the most expensive one. Do keep `LIMIT 1` to return only the top result. The amended query now correctly identifies the most ordered product by counting order occurrences instead of simply selecting the highest-priced item."
        ],
        "rules": [
            "1) When the question asks for \"name and price\" of a product: use \"product_name\" and \"product_price\" columns from the Products table. 2) When finding the product ordered the greatest number of times: join Products table (T1) with regular_order_products table (T2) where T1.product_id = T2.product_id to count order occurrences. 3) When counting order occurrences: group by product_id and count the number of rows to determine frequency. 4) When ranking products by order frequency: order by the count in descending direction to find the most frequently ordered product. 5) When only the top result is needed: keep only the first row after ordering to return the single most ordered product."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, price FROM products ORDER BY price DESC LIMIT 1;",
            "SELECT p.product_name, p.product_price\nFROM Products p\nJOIN Regular_Order_Products rop ON p.product_id = rop.product_id\nGROUP BY p.product_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT p.product_name, p.product_price\nFROM Products p\nJOIN Regular_Order_Products rop ON p.product_id = rop.product_id\nGROUP BY p.product_id, p.product_name, p.product_price\nORDER BY COUNT(rop.regular_order_id) DESC\nLIMIT 1;"
        ]
    },
    "614": {
        "db_id": "store_1",
        "question": "What are the different names of the genres?",
        "ground_truth": "SELECT DISTINCT name FROM genres;",
        "amends": [
            "Do add `DISTINCT` instead of omitting it, and do remove the `WHERE id = 1` filter instead of keeping it. The amended query now matches RIGHT_SQL's behavior by returning all distinct genre names rather than filtering to a specific ID."
        ],
        "rules": [
            "1) When answering about \"different names of the genres\": make sure to return only distinct values of the \"name\" column. 2) When the question asks for \"different names\" without any specific filtering condition: do not apply any WHERE clause filters like \"id = 1\" that would restrict the results to a single genre."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM genres WHERE id = 1;",
            "SELECT DISTINCT name FROM genres;"
        ],
        "rule_sql": [
            "SELECT DISTINCT name FROM genres;"
        ]
    },
    "1721": {
        "db_id": "riding_club",
        "question": "What are the gender and occupation of players?",
        "ground_truth": "SELECT Gender ,  Occupation FROM player",
        "amends": [
            "Do reference the table as `player` instead of `players` to match the correct schema. Do use column names `Gender` and `Occupation` with proper capitalization instead of lowercase `gender` and `occupation` to align with the actual column definitions. The amended query now correctly selects from the appropriate table with the proper column names, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"gender and occupation of players\": make sure the output order: Gender, Occupation. 2) When the question mentions \"players\": \"players\" actually means \"player\" in schema. 3) When the question mentions \"gender\" and \"occupation\": \"gender\" actually means \"Gender\" in schema and \"occupation\" actually means \"Occupation\" in schema. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 5) When handling text literals: do not change case, spacing, or punctuation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT gender, occupation FROM players WHERE gender = 'male';",
            "SELECT Gender, Occupation FROM player;"
        ],
        "rule_sql": [
            "SELECT \"Gender\", \"Occupation\" FROM \"player\";"
        ]
    },
    "6696": {
        "db_id": "driving_school",
        "question": "List all payment methods and number of payments using each payment methods.",
        "ground_truth": "SELECT payment_method_code ,  count(*) FROM Customer_Payments GROUP BY payment_method_code;",
        "amends": [
            "Do reference `payment_method_code` instead of `payment_method` in both the SELECT list and GROUP BY clause. Do use table `Customer_Payments` instead of `payments` as the data source. The amended query now correctly references the appropriate column and table names to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for payment methods: use the exact column \"payment_method_code\" from table \"Customer_Payments\" instead of \"payment_method\". 2) When counting payments per payment method: count using the canonical key from \"Customer_Payments\" table and group by \"payment_method_code\". 3) When the question mentions \"number of payments\": compute the count of rows from \"Customer_Payments\" table for each payment method group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT payment_method, COUNT(*) FROM payments GROUP BY payment_method;",
            "SELECT payment_method_code, COUNT(*) AS number_of_payments FROM Customer_Payments GROUP BY payment_method_code;"
        ],
        "rule_sql": [
            "SELECT payment_method_code, COUNT(*) AS number_of_payments FROM Customer_Payments GROUP BY payment_method_code;"
        ]
    },
    "3353": {
        "db_id": "sports_competition",
        "question": "List all club names in descending alphabetical order.",
        "ground_truth": "SELECT name FROM club ORDER BY name DESC",
        "amends": [
            "Do select `name` from the `club` table instead of `club_name` from the `clubs` table. Do order by `name` in descending order instead of ascending order. The amended query now correctly retrieves and sorts the club names from the appropriate table structure."
        ],
        "rules": [
            "1) When the question asks for \"club names\": use the column \"name\" from table \"club\" instead of \"club_name\" from table \"clubs\". 2) When the question specifies \"descending alphabetical order\": order by \"name\" in descending order instead of ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT club_name FROM clubs ORDER BY club_name ASC;",
            "SELECT name FROM club ORDER BY name DESC;"
        ],
        "rule_sql": [
            "SELECT name FROM club ORDER BY name DESC;"
        ]
    },
    "3304": {
        "db_id": "college_1",
        "question": "What is the name and address of the department with the most students?",
        "ground_truth": "SELECT T2.dept_name ,  T2.dept_address FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.dept_name` and `T2.dept_address` instead of `name` and `address`. Do join `student AS T1` with `department AS T2` on `T1.dept_code = T2.dept_code` instead of querying only `departments`. Do add `GROUP BY T1.dept_code` and aggregate with `count(*)` instead of ordering by `student_count`. Do order by `count(*) DESC` instead of `student_count DESC`. The amended query now correctly identifies the department with the most students by joining student and department tables and counting enrollments per department."
        ],
        "rules": [
            "1) When the question asks for \"name and address of the department\": select \"T2\".\"dept_name\" and \"T2\".\"dept_address\" as the output columns. 2) When combining student and department tables: join \"student\" AS \"T1\" with \"department\" AS \"T2\" where \"T1\".\"dept_code\" = \"T2\".\"dept_code\" and keep only matching pairs (inner match). 3) When counting students per department: group by \"T1\".\"dept_code\" and compute count(*) to get the number of students. 4) When finding the department with the most students: order the results by count(*) in descending order and keep only the top result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, address FROM departments ORDER BY student_count DESC LIMIT 1;",
            "SELECT T2.dept_name, T2.dept_address\nFROM student AS T1\nJOIN department AS T2 ON T1.dept_code = T2.dept_code\nGROUP BY T1.dept_code\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.DEPT_NAME, T2.DEPT_ADDRESS\nFROM STUDENT AS T1\nINNER JOIN DEPARTMENT AS T2 ON T1.DEPT_CODE = T2.DEPT_CODE\nGROUP BY T1.DEPT_CODE\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "5321": {
        "db_id": "manufactory_1",
        "question": "How many products are there for each manufacturer?",
        "ground_truth": "SELECT count(*) ,  T2.name FROM products AS T1 JOIN manufacturers AS T2 ON T1.Manufacturer  =  T2.code GROUP BY T2.name",
        "amends": [
            "Do add `T2.name` in the SELECT list and remove `manufacturer` instead of keeping it. Do change the FROM clause to join `products AS T1` with `manufacturers AS T2` on `T1.Manufacturer = T2.code` instead of using a single table without joins. Do change the GROUP BY clause to use `T2.name` instead of `product_id`. Do remove the incorrect column reference `manufacturer` from the SELECT list and replace it with the proper aggregated count and manufacturer name. The amended query now correctly counts products grouped by manufacturer name rather than incorrectly grouping by product_id.",
            "Do use `count(*)` without an alias instead of `COUNT(*) AS ProductCount`. Do place the aggregate function first in the SELECT list instead of starting with `T2.Name`. Do remove the column alias `ProductCount` instead of keeping it. Do use lowercase `name` instead of `Name` for the grouping column. The amended query now correctly counts products per manufacturer without unnecessary aliasing and follows the proper column ordering."
        ],
        "rules": [
            "1) When answering about \"products per manufacturer\": make sure the output order: manufacturer name, then count. 2) When the question mentions \"manufacturer\": \"manufacturer\" actually means \"T2.name in schema\" from the manufacturers table. 3) When combining T1 (products) and T2 (manufacturers) for shared entities: link rows where T1.Manufacturer = T2.code exactly as shown; keep only matching pairs (inner match). 4) When the question asks for \"count of products\": compute the number of rows using the canonical key for products. 5) When the question says \"per manufacturer\"/\"by manufacturer\": organize results by T2.name and compute requested aggregates per group.",
            "1) When answering about \"How many products are there for each manufacturer\": make sure the output order: count(*) first, then T2.name. 2) When counting products per manufacturer: use count(*) without any column alias. 3) When grouping by manufacturer name: use lowercase \"name\" instead of \"Name\" for the grouping column. 4) When combining Products as T1 and Manufacturers as T2: link rows where T1.Manufacturer = T2.Code and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT manufacturer, COUNT(*) FROM products GROUP BY product_id;",
            "SELECT T2.Name, COUNT(*) AS ProductCount FROM Products AS T1 JOIN Manufacturers AS T2 ON T1.Manufacturer = T2.Code GROUP BY T2.Name",
            "SELECT COUNT(*), T2.name FROM products AS T1 JOIN manufacturers AS T2 ON T1.Manufacturer = T2.code GROUP BY T2.name"
        ],
        "rule_sql": [
            "SELECT COUNT(*), T2.name FROM Products AS T1 INNER JOIN Manufacturers AS T2 ON T1.Manufacturer = T2.Code GROUP BY T2.name ORDER BY COUNT(*), T2.name"
        ]
    },
    "88": {
        "db_id": "student_assessment",
        "question": "What are the ids of the students who registered for course 301?",
        "ground_truth": "SELECT student_id FROM student_course_attendance WHERE course_id  =  301",
        "amends": [
            "Do query the `student_course_attendance` table instead of the `registrations` table. Do keep the `student_id` column and `course_id = 301` filter unchanged. The amended query now correctly retrieves student attendance data from the appropriate table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"students who registered for course 301\": query the \"student_course_attendance\" table instead of the \"registrations\" table. 2) When the question asks for \"ids of the students\": select the \"student_id\" column from the \"student_course_attendance\" table. 3) When filtering for course 301: apply the condition \"course_id = 301\" to the \"student_course_attendance\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id FROM registrations WHERE course_id = 301",
            "SELECT student_id FROM Student_Course_Attendance WHERE course_id = 301;"
        ],
        "rule_sql": [
            "SELECT student_id FROM Student_Course_Attendance WHERE course_id = 301;"
        ]
    },
    "3132": {
        "db_id": "assets_maintenance",
        "question": "Which parts have more than 2 faults? Show the part name and id.",
        "ground_truth": "SELECT T1.part_name ,  T1.part_id FROM Parts AS T1 JOIN Part_Faults AS T2 ON T1.part_id  =  T2.part_id GROUP BY T1.part_id HAVING count(*)  >  2",
        "amends": [
            "Do add table `Parts AS T1` and `Part_Faults AS T2` with a `JOIN` on `T1.part_id = T2.part_id` instead of querying only the `parts` table. Do change the SELECT list to use qualified column names `T1.part_name` and `T1.part_id` instead of unqualified `part_name` and `part_id`. Do remove the WHERE clause filter `faults > 2` instead of keeping it. Do add GROUP BY `T1.part_id` instead of omitting aggregation. Do move the count condition to HAVING `count(*) > 2` instead of using WHERE with a direct column filter. The amended query now correctly counts fault occurrences per part through the join and grouping, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"parts with more than 2 faults\": combine tables Parts AS T1 and Part_Faults AS T2 by linking rows where T1.part_id = T2.part_id and keep only matching pairs (inner match). 2) When counting faults per part: group results by T1.part_id and compute the count of fault occurrences. 3) When filtering for parts with more than 2 faults: apply the condition count(*) > 2 after grouping. 4) When showing part information: output T1.part_name and T1.part_id as the result columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT part_name, part_id FROM parts WHERE faults > 2",
            "SELECT T1.part_name, T1.part_id\nFROM Parts AS T1\nJOIN Part_Faults AS T2 ON T1.part_id = T2.part_id\nGROUP BY T1.part_id\nHAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT T1.part_name, T1.part_id\nFROM Parts AS T1\nINNER JOIN Part_Faults AS T2 ON T1.part_id = T2.part_id\nGROUP BY T1.part_id\nHAVING COUNT(*) > 2"
        ]
    },
    "3308": {
        "db_id": "college_1",
        "question": "What are the first names and office of the professors who are in the history department and have a Ph.D?",
        "ground_truth": "SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  'History' AND T2.prof_high_degree  =  'Ph.D.'",
        "amends": [
            "Do select `emp_fname` and `prof_office` instead of `first_name` and `office`. Do join `employee` as `T1` with `professor` as `T2` on `emp_num` instead of querying only `professors`. Do add join with `department` as `T3` on `dept_code` instead of omitting it. Do filter on `dept_name = 'History'` instead of `department = 'history'`. Do filter on `prof_high_degree = 'Ph.D.'` instead of `degree = 'PhD'`. The amended query now correctly joins related tables and uses proper column references to match the intended behavior."
        ],
        "rules": [
            "1) When selecting professor information: use \"emp_fname\" for first name and \"prof_office\" for office instead of \"first_name\" and \"office\". 2) When querying about professors: join \"employee\" as T1 with \"professor\" as T2 on \"emp_num\" instead of using only a professors table. 3) When filtering by department: join with \"department\" as T3 on \"dept_code\" and use \"dept_name = 'History'\" instead of \"department = 'history'\". 4) When filtering by degree qualification: use \"prof_high_degree = 'Ph.D.'\" instead of \"degree = 'PhD'\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, office FROM professors WHERE department = 'history' AND degree = 'PhD';",
            "SELECT T1.EMP_FNAME, T2.PROF_OFFICE\nFROM EMPLOYEE T1\nJOIN PROFESSOR T2 ON T1.EMP_NUM = T2.EMP_NUM\nJOIN DEPARTMENT T3 ON T2.DEPT_CODE = T3.DEPT_CODE\nWHERE T3.DEPT_NAME = 'History' AND T2.PROF_HIGH_DEGREE = 'Ph.D.'"
        ],
        "rule_sql": [
            "SELECT T1.emp_fname, T2.prof_office\nFROM EMPLOYEE AS T1\nJOIN PROFESSOR AS T2 ON T1.EMP_NUM = T2.EMP_NUM\nJOIN DEPARTMENT AS T3 ON T2.DEPT_CODE = T3.DEPT_CODE\nWHERE T3.DEPT_NAME = 'History' AND T2.PROF_HIGH_DEGREE = 'Ph.D.'"
        ]
    },
    "1533": {
        "db_id": "insurance_and_eClaims",
        "question": "Find the names of customers who either have an deputy policy or uniformed policy.",
        "ground_truth": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  \"Deputy\" OR t1.policy_type_code  =  \"Uniform\"",
        "amends": [
            "Do select `DISTINCT t2.customer_details` instead of `name` from a single table. Do join `policies AS t1` with `customers AS t2` on `t1.customer_id = t2.customer_id` instead of querying only the `customers` table. Do filter with `t1.policy_type_code = \"Deputy\" OR t1.policy_type_code = \"Uniform\"` instead of the impossible `policy_type = 'deputy' AND policy_type = 'uniformed'` condition that could never return results. Do reference the policy type from the `policies` table instead of incorrectly assuming it exists in the `customers` table. The amended query now correctly retrieves distinct customer details for those with either Deputy or Uniform policy types by properly joining the relevant tables and using OR logic instead of contradictory AND conditions."
        ],
        "rules": [
            "1) When answering about customer names with specific policy types: make sure the output order: DISTINCT t2.customer_details. 2) When the question mentions \"customers who either have an deputy policy or uniformed policy\": join policies AS t1 with customers AS t2 on t1.customer_id = t2.customer_id to link customer policies. 3) When filtering for policy types: use t1.policy_type_code = \"Deputy\" OR t1.policy_type_code = \"Uniform\" instead of impossible AND conditions. 4) When referencing policy information: always use the policy_type_code from the policies table (t1) rather than assuming it exists in the customers table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM customers WHERE policy_type = 'deputy' AND policy_type = 'uniformed';",
            "SELECT DISTINCT t2.Customer_Details\nFROM Policies AS t1\nJOIN Customers AS t2 ON t1.Customer_ID = t2.Customer_ID\nWHERE t1.Policy_Type_Code = 'Deputy' OR t1.Policy_Type_Code = 'Uniform'"
        ],
        "rule_sql": [
            "SELECT DISTINCT t2.Customer_Details \nFROM Policies AS t1 \nJOIN Customers AS t2 ON t1.Customer_ID = t2.Customer_ID \nWHERE t1.Policy_Type_Code = 'Deputy' OR t1.Policy_Type_Code = 'Uniform'"
        ]
    },
    "4810": {
        "db_id": "aircraft",
        "question": "what is the name of every pilot who is at least 25 years old?",
        "ground_truth": "SELECT Name FROM pilot WHERE Age  >=  25",
        "amends": [
            "Do reference the table as `pilot` instead of `pilots` and use column names `Name` and `Age` instead of `name` and `age`. Do use the inclusive comparison `>= 25` instead of the exclusive `> 25` to include pilots who are exactly 25 years old. The amended query now correctly selects from the intended table structure and includes the appropriate age threshold."
        ],
        "rules": [
            "1) When referencing the table containing pilot information: use the exact table name \"pilot\" instead of \"pilots\". 2) When selecting the pilot's name: use the exact column name \"Name\" instead of \"name\". 3) When filtering by age to include pilots who are at least 25 years old: use the inclusive comparison \"Age >= 25\" instead of the exclusive \"Age > 25\" to include pilots who are exactly 25 years old."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM pilots WHERE age > 25;",
            "SELECT Name FROM pilot WHERE Age >= 25"
        ],
        "rule_sql": [
            "SELECT Name FROM pilot WHERE Age >= 25"
        ]
    },
    "5029": {
        "db_id": "soccer_2",
        "question": "What are the names of the states that have some college students playing in the positions of goalie and mid-field?",
        "ground_truth": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'",
        "amends": [
            "Do use `INTERSECT` to find states with both positions instead of `AND` conditions that cannot both be true. Do change the table structure to use `college` and `tryout` tables instead of `states` and `players`. Do join on `cName` instead of `state_id`. Do reference `pPos` for position instead of `position`. Do remove the `college IS NOT NULL` filter instead of keeping it. Do select `state` instead of `name`. Do use separate queries for each position condition with `INTERSECT` instead of contradictory `WHERE` clauses. The amended query now correctly finds states that have both goalie and mid-field players by intersecting results from two separate queries.",
            "Do use explicit `JOIN` syntax with table aliases `T1` and `T2` instead of subqueries with `IN` clauses. Do specify `T1.state` instead of just `state` to avoid ambiguity. Do use proper join condition `ON T1.cName = T2.cName` instead of implicit correlation through `IN` subqueries. Do move the position filter to the `WHERE` clause with `T2.pPos = 'goalie'` and `T2.pPos = 'mid'` instead of embedding it in subqueries. Do maintain the `INTERSECT` operation between the two queries to find states that have both goalie and mid-field positions. The amended query now correctly uses explicit joins for better performance and clarity while maintaining the same intersection logic to find colleges that offer both specified positions."
        ],
        "rules": [
            "1) When the question asks for states with both goalie and mid-field college players: use INTERSECT to combine results from separate queries for each position instead of AND conditions that cannot both be true. 2) When working with college player positions: reference the exact column token \"pPos\" for position instead of \"position\". 3) When selecting state information: use the exact column token \"state\" instead of \"name\". 4) When joining tables for college player data: use \"cName\" as the join key instead of \"state_id\". 5) When filtering for college players: do not include a college IS NOT NULL filter as it is unnecessary for this schema. 6) When the question mentions \"college students playing\": this refers to data in the college and tryout tables rather than states and players tables.",
            "1) When answering about states with colleges having both goalie and mid-field positions: use explicit JOIN syntax with table aliases T1 for College and T2 for Tryout instead of subqueries with IN clauses. 2) When selecting the state column: specify T1.state instead of just state to avoid ambiguity. 3) When combining College and Tryout tables: link rows where T1.cName = T2.cName exactly as shown in the amends. 4) When filtering for position 'goalie': use T2.pPos = 'goalie' in the WHERE clause. 5) When filtering for position 'mid': use T2.pPos = 'mid' in the WHERE clause (note exact literal 'mid' instead of 'mid-field'). 6) When finding states with both positions: maintain the INTERSECT operation between the two queries to find states that have both goalie and mid positions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT s.name \nFROM states s \nJOIN players p ON s.state_id = p.state_id \nWHERE p.position = 'goalie' \nAND p.position = 'mid-field' \nAND p.college IS NOT NULL",
            "SELECT state FROM College WHERE cName IN (SELECT cName FROM Tryout WHERE pPos = 'goalie') INTERSECT SELECT state FROM College WHERE cName IN (SELECT cName FROM Tryout WHERE pPos = 'mid-field')",
            "SELECT DISTINCT T1.state\nFROM College T1\nJOIN Tryout T2 ON T1.cName = T2.cName\nWHERE T2.pPos = 'goalie'\nINTERSECT\nSELECT DISTINCT T1.state\nFROM College T1\nJOIN Tryout T2 ON T1.cName = T2.cName\nWHERE T2.pPos = 'mid'"
        ],
        "rule_sql": [
            "SELECT T1.state\nFROM College T1\nJOIN Tryout T2 ON T1.cName = T2.cName\nWHERE T2.pPos = 'goalie'\nINTERSECT\nSELECT T1.state\nFROM College T1\nJOIN Tryout T2 ON T1.cName = T2.cName\nWHERE T2.pPos = 'mid'"
        ]
    },
    "5818": {
        "db_id": "workshop_paper",
        "question": "What are the authors of submissions and their colleges?",
        "ground_truth": "SELECT Author ,  College FROM submission",
        "amends": [
            "Do use table name `submission` instead of `submissions` and capitalize column names `Author` and `College` instead of lowercase `author` and `college`. Do remove the `WHERE` clause filtering for non-null values instead of keeping it, and remove the `ORDER BY` clause instead of sorting by author. The amended query now correctly selects from the proper table with appropriate column casing and without unnecessary filtering or sorting."
        ],
        "rules": [
            "1) When the question asks for authors and colleges from submissions: use table name \"submission\" instead of \"submissions\". 2) When selecting author information: use column name \"Author\" with exact capitalization instead of lowercase \"author\". 3) When selecting college information: use column name \"College\" with exact capitalization instead of lowercase \"college\". 4) When the schema shows no null values in Author and College columns: do not add WHERE clause filtering for non-null values. 5) When the question does not specify any ordering requirement: do not include ORDER BY clause."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT author, college FROM submissions WHERE author IS NOT NULL AND college IS NOT NULL ORDER BY author;",
            "SELECT Author, College FROM submission"
        ],
        "rule_sql": [
            "SELECT Author, College FROM submission;"
        ]
    },
    "6949": {
        "db_id": "architecture",
        "question": "What are the names and year of construction for the mills of 'Grondzeiler' type?",
        "ground_truth": "SELECT name ,  built_year FROM mill WHERE TYPE  =  'Grondzeiler'",
        "amends": [
            "Do reference column `built_year` instead of `year_built` and use table `mill` instead of `mills` while maintaining the filter `TYPE = 'Grondzeiler'` with consistent case handling, resulting in the amended query now matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"year of construction\": use the exact column token \"built_year\" from table \"mill\" instead of \"year_built\". 2) When referring to mills in the database: use the exact table name \"mill\" instead of \"mills\". 3) When filtering for mills of 'Grondzeiler' type: apply the exact filter condition TYPE = 'Grondzeiler' with consistent case handling."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, year_built FROM mills WHERE type = 'Grondzeiler';",
            "SELECT name, built_year FROM mill WHERE type = 'Grondzeiler'"
        ],
        "rule_sql": [
            "SELECT name, built_year FROM mill WHERE type = 'Grondzeiler'"
        ]
    },
    "3607": {
        "db_id": "music_1",
        "question": "Find the name and country of origin for all artists who have release at least one song of resolution above 900.",
        "ground_truth": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.resolution  >  900 GROUP BY T2.artist_name HAVING count(*)  >=  1",
        "amends": [
            "Do select `T1.artist_name` and `T1.country` instead of `name` and `country`. Do join `artist AS T1` with `song AS T2` on `T1.artist_name = T2.artist_name` instead of querying only the `artists` table. Do filter on `T2.resolution > 900` instead of `resolution > 900` and move the condition to the WHERE clause instead of applying it directly to the artists table. Do add `GROUP BY T2.artist_name` and `HAVING count(*) >= 1` instead of omitting grouping and aggregation. The amended query now correctly filters artists based on song resolution and ensures only artists with matching songs are returned, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting artist information: use T1.artist_name and T1.country instead of generic name and country columns. 2) When combining artist and song data: join artist AS T1 with song AS T2 on T1.artist_name = T2.artist_name using inner match. 3) When filtering by song resolution: apply the condition T2.resolution > 900 in the WHERE clause instead of filtering directly on the artists table. 4) When ensuring artists have at least one qualifying song: group by T2.artist_name and require count(*) >= 1 using HAVING clause."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, country FROM artists WHERE resolution > 900;",
            "SELECT T1.artist_name, T1.country\nFROM artist AS T1\nJOIN song AS T2 ON T1.artist_name = T2.artist_name\nWHERE T2.resolution > 900\nGROUP BY T2.artist_name\nHAVING COUNT(*) >= 1"
        ],
        "rule_sql": [
            "SELECT T1.artist_name, T1.country FROM artist AS T1 INNER JOIN song AS T2 ON T1.artist_name = T2.artist_name WHERE T2.resolution > 900 GROUP BY T2.artist_name HAVING COUNT(*) >= 1"
        ]
    },
    "2590": {
        "db_id": "inn_1",
        "question": "List the names and decor of rooms that have a king bed. Sort the list by their price.",
        "ground_truth": "SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  'King' ORDER BY basePrice;",
        "amends": [
            "Do select `roomName` instead of `name` and maintain `decor` in the SELECT list. Do reference table `Rooms` instead of `rooms` in the FROM clause. Do filter on `bedtype = 'King'` instead of `bed_type = 'king'` in the WHERE clause. Do order by `basePrice` instead of `name` in the ORDER BY clause. The amended query now correctly matches the intended behavior with proper column names, table reference, case-sensitive value comparison, and appropriate sorting criteria."
        ],
        "rules": [
            "1) When selecting room names: use \"roomName\" instead of \"name\" from table \"Rooms\". 2) When filtering for king beds: use condition \"bedtype = 'King'\" with exact case and spelling. 3) When sorting by price: order results by \"basePrice\" column instead of room name. 4) When referencing the rooms table: use exact table name \"Rooms\" with proper capitalization."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, decor FROM rooms WHERE bed_type = 'king' ORDER BY name;",
            "SELECT roomName, decor FROM Rooms WHERE bedType = 'King' ORDER BY basePrice;"
        ],
        "rule_sql": [
            "SELECT roomName, decor FROM Rooms WHERE bedType = 'King' ORDER BY basePrice;"
        ]
    },
    "1475": {
        "db_id": "college_2",
        "question": "List the distinct names of the instructors, ordered by name.",
        "ground_truth": "SELECT DISTINCT name FROM  instructor ORDER BY name",
        "amends": [
            "Do add `DISTINCT` instead of omitting it to eliminate duplicate name values. Do change `ORDER BY name DESC` to `ORDER BY name` instead to sort in ascending order rather than descending. The amended query now returns unique instructor names sorted alphabetically in ascending order, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"distinct names\": eliminate duplicate values from the \"name\" column. 2) When ordering results by name: sort the \"name\" column in ascending order (alphabetical A-Z) rather than descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM instructors ORDER BY name DESC",
            "SELECT DISTINCT name FROM instructor ORDER BY name;"
        ],
        "rule_sql": [
            "SELECT DISTINCT name FROM instructor ORDER BY name ASC;"
        ]
    },
    "3892": {
        "db_id": "insurance_policies",
        "question": "List the details of the customers who do not have any policies.",
        "ground_truth": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id",
        "amends": [
            "Do select only `customer_details` instead of all columns with `*`. Do use `EXCEPT` set operation instead of a simple `WHERE` filter. Do add a join between `Customers` and `Customer_Policies` on `customer_id` instead of checking for `policy_id` directly. Do reference the main table as `T1` and join table as `T2` with explicit aliases instead of a single table reference. Do remove the `IS NOT NULL` condition entirely instead of keeping it, as the EXCEPT operation inherently excludes customers with policies. The amended query now correctly identifies customers without any policies by excluding those found in the joined Customer_Policies table."
        ],
        "rules": [
            "1) When answering about \"customers who do not have any policies\": make sure the output order: customer_details. 2) When the question asks for customer details: use the exact column token \"customer_details\" instead of selecting all columns. 3) When identifying customers without policies: use an EXCEPT set operation between Customers table (T1) and Customer_Policies table (T2) instead of a WHERE filter. 4) When combining T1 (Customers) and T2 (Customer_Policies): link rows where T1.customer_id = T2.customer_id and keep only customers present in T1 but not in T2. 5) When handling the condition for policies: do not use IS NOT NULL or any direct policy_id check, as the EXCEPT operation inherently excludes customers with policies."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM customers WHERE policy_id IS NOT NULL;",
            "SELECT Customer_Details FROM Customers T1 EXCEPT SELECT Customer_Details FROM Customers T1 JOIN Customer_Policies T2 ON T1.Customer_ID = T2.Customer_ID"
        ],
        "rule_sql": [
            "SELECT customer_details FROM Customers\nEXCEPT\nSELECT customer_details FROM Customers\nJOIN Customer_Policies ON Customers.Customer_ID = Customer_Policies.Customer_ID"
        ]
    },
    "6952": {
        "db_id": "architecture",
        "question": "What are the distinct types of mills that are built by American or Canadian architects?",
        "ground_truth": "SELECT DISTINCT T1.type FROM mill AS T1 JOIN architect AS t2 ON T1.architect_id  =  T2.id WHERE T2.nationality  =  'American' OR T2.nationality  =  'Canadian'",
        "amends": [
            "Do reference `type` from the `mill` table instead of `mill_type` from the `mills` table. Do join `architect` table on `mill.architect_id = architect.id` instead of querying from a single table. Do filter on `architect.nationality` instead of `architect_nationality`. Do use table aliases `T1` and `t2` instead of no aliases. The amended query now correctly joins related tables and filters based on architect nationality rather than relying on a denormalized column structure."
        ],
        "rules": [
            "1) When answering about distinct types of mills: make sure the output order: T1.type 2) When the question mentions \"types of mills\": \"types\" actually means \"type in mill table\" 3) When the question mentions \"American or Canadian architects\": filter where T2.nationality = 'American' OR T2.nationality = 'Canadian' 4) When combining mill and architect tables: link rows where T1.architect_id = T2.id and keep only matching pairs (inner match) 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms 6) When handling text literals: do not change case, spacing, or punctuation for 'American' and 'Canadian'"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT mill_type FROM mills WHERE architect_nationality = 'American' OR architect_nationality = 'Canadian';",
            "SELECT DISTINCT T1.type FROM mill T1 JOIN architect t2 ON T1.architect_id = t2.id WHERE t2.nationality IN ('American', 'Canadian')"
        ],
        "rule_sql": [
            "SELECT DISTINCT mill.type FROM mill JOIN architect ON mill.architect_id = architect.id WHERE architect.nationality = 'American' OR architect.nationality = 'Canadian' ORDER BY mill.type"
        ]
    },
    "368": {
        "db_id": "flight_1",
        "question": "What is the number of employees that have a salary between 100000 and 200000?",
        "ground_truth": "SELECT count(*) FROM Employee WHERE salary BETWEEN 100000 AND 200000",
        "amends": [
            "Do use `BETWEEN 100000 AND 200000` instead of `salary > 200000 OR salary < 100000` to correctly count employees within the salary range rather than outside it. Do reference table `Employee` instead of `employees` to match the correct schema. The amended query now correctly counts employees with salaries between 100,000 and 200,000 instead of those outside this range, matching the RIGHT_SQL's intended behavior."
        ],
        "rules": [
            "1) When the question asks for employees with salary between 100000 and 200000: use the condition \"salary BETWEEN 100000 AND 200000\" to include salaries within this range inclusively. 2) When referencing the employee table: use the exact table name \"Employee\" instead of \"employees\" to match the schema. 3) When counting employees: use COUNT(*) to count all rows that satisfy the salary range condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE salary > 200000 OR salary < 100000;",
            "SELECT COUNT(*) FROM employee WHERE salary BETWEEN 100000 AND 200000"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM employee WHERE salary BETWEEN 100000 AND 200000"
        ]
    },
    "495": {
        "db_id": "allergy_1",
        "question": "Show the average age for male and female students.",
        "ground_truth": "SELECT avg(age) ,  sex FROM Student GROUP BY sex",
        "amends": [
            "Do use `sex` instead of `gender` as the column name and grouping field. Do remove the `WHERE` clause filter instead of keeping it since the grouping inherently handles distinct values. Do use `avg(age)` without an alias instead of `AVG(age) as average_age`. Do reference table `Student` instead of `students`. The amended query now correctly calculates average age grouped by sex without unnecessary filtering.",
            "Do place the `avg(age)` aggregate function first in the SELECT list instead of placing `sex` first, while maintaining the same GROUP BY `sex` clause and preserving the identical logical behavior of calculating average age grouped by gender. The amended query now matches RIGHT_SQL's behavior with identical output results."
        ],
        "rules": [
            "1) When the question mentions \"gender\": use the exact column token \"sex\" from the Student table instead. 2) When grouping by sex: organize results by the \"sex\" column and compute the average of \"age\" per group. 3) When calculating average age: use avg(age) without an alias instead of AVG(age) as average_age. 4) When referencing the student table: use the exact table name \"Student\" instead of \"students\". 5) When grouping by categorical values: do not add a WHERE clause filter since the grouping inherently handles distinct values.",
            "1) When answering about \"average age for male and female students\": make sure the output order: average age first, then sex. 2) When the question asks for \"average age\": compute the average of the exact token \"age\". 3) When the question says \"for male and female students\" and \"by sex\": organize results by the exact token \"sex\" and compute average age per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT gender, AVG(age) as average_age FROM students GROUP BY gender WHERE gender IN ('male', 'female')",
            "SELECT sex, avg(age) FROM Student GROUP BY sex;",
            "SELECT avg(age), sex FROM Student GROUP BY sex"
        ],
        "rule_sql": [
            "SELECT avg(age), sex FROM Student GROUP BY sex"
        ]
    },
    "6741": {
        "db_id": "activity_1",
        "question": "For each faculty rank, show the number of faculty members who have it.",
        "ground_truth": "SELECT rank ,  count(*) FROM Faculty GROUP BY rank",
        "amends": [
            "Do use column name `rank` instead of `faculty_rank` in the SELECT list. Do group by `rank` instead of `faculty_id` to correctly count faculty members by their rank rather than by individual faculty IDs. Do use table name `Faculty` instead of `faculty` to match the correct schema. The amended query now correctly counts faculty members grouped by their rank categories rather than producing one count per individual faculty member."
        ],
        "rules": [
            "1) When the question asks about faculty rank: use the exact column name \"rank\" from the Faculty table. 2) When counting faculty members per rank: group by the \"rank\" column instead of individual faculty IDs. 3) When referring to the faculty table: use the exact table name \"Faculty\" with proper capitalization. 4) When answering about number of faculty members per rank: count using the canonical key (faculty members) grouped by their rank categories rather than producing counts per individual faculty member."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT faculty_rank, COUNT(*) FROM faculty GROUP BY faculty_id;",
            "SELECT rank, COUNT(*) AS number_of_faculty FROM Faculty GROUP BY rank;"
        ],
        "rule_sql": [
            "SELECT rank, COUNT(FacID) AS number_of_faculty_members FROM Faculty GROUP BY rank;"
        ]
    },
    "3680": {
        "db_id": "baseball_1",
        "question": "How many players did Boston Red Stockings have in 2000?",
        "ground_truth": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2000",
        "amends": [
            "Do join `salary AS T1` with `team AS T2` on `T1.team_id = T2.team_id_br` instead of querying `players` table directly. Do filter on `T2.name = 'Boston Red Stockings'` instead of `team = 'Boston Red Stockings'` to reference the correct table and column. Do filter on `T1.year = 2000` instead of `year = 2000` to specify the table alias. The amended query now correctly joins salary and team tables to count players from the specified team in the given year, matching the intended behavior.",
            "Do use `count(*)` instead of `COUNT(DISTINCT T1.player_id)` to count all rows rather than distinct player IDs. Do maintain the same `JOIN` on `T1.team_id = T2.team_id_br` without changes. Do keep the `WHERE` filters `T2.name = 'Boston Red Stockings'` and `T1.year = 2000` unchanged. The amended query now correctly counts all salary records for the specified team and year instead of counting distinct players, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"How many players did Boston Red Stockings have in 2000\": make sure the output order: COUNT of players\n2) When the question mentions \"Boston Red Stockings\": \"Boston Red Stockings\" actually means \"T2.name = 'Boston Red Stockings'\" in schema\n3) When the question mentions \"2000\": \"2000\" actually means \"T1.year = 2000\" in schema\n4) When combining T1 (salary) and T2 (team) for shared entities: link rows where T1.team_id = T2.team_id_br exactly as shown in the amends; keep only matching pairs (inner match)\n5) When the question asks for \"count of players\": compute the number of rows using the canonical key token for players from the salary table\n6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table and column names",
            "1) When counting players for a specific team and year: use count(*) to count all rows rather than distinct player IDs. 2) When joining salary and team tables: link rows where T1.team_id = T2.team_id_br exactly as shown. 3) When filtering for team name: use T2.name = 'Boston Red Stockings' with exact case and spacing. 4) When filtering for year: use T1.year = 2000 with the exact numeric value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE team = 'Boston Red Stockings' AND year = 2000;",
            "SELECT COUNT(DISTINCT T1.player_id) \nFROM salary AS T1 \nJOIN team AS T2 ON T1.team_id = T2.team_id_br \nWHERE T2.name = 'Boston Red Stockings' AND T1.year = 2000",
            "SELECT COUNT(*) \nFROM salary AS T1 \nJOIN team AS T2 ON T1.team_id = T2.team_id_br \nWHERE T2.name = 'Boston Red Stockings' \nAND T1.year = 2000"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM salary T1\nINNER JOIN team T2 ON T1.team_id = T2.team_id_br\nWHERE T2.name = 'Boston Red Stockings' AND T1.year = 2000"
        ]
    },
    "2239": {
        "db_id": "machine_repair",
        "question": "List the name of technicians whose team is not \"NYY\".",
        "ground_truth": "SELECT Name FROM technician WHERE Team != \"NYY\"",
        "amends": [
            "Do use `Name` instead of `name` for the column selection to match the correct case. Do reference table `technician` instead of `technicians` to use the correct table name. Do use inequality filter `Team != \"NYY\"` instead of equality filter `team = 'NYY'` to select the opposite set of records. The amended query now correctly selects names from the technician table where the team is not NYY."
        ],
        "rules": [
            "1) When selecting from the technician table: use the exact table name \"technician\" not \"technicians\". 2) When selecting the name column from technician: use the exact column name \"Name\" with proper case, not \"name\". 3) When filtering for technicians whose team is not \"NYY\": use the inequality condition Team != \"NYY\" with exact literal value and proper column case."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM technicians WHERE team = 'NYY';",
            "SELECT Name FROM technician WHERE Team != 'NYY';"
        ],
        "rule_sql": [
            "SELECT Name FROM technician WHERE Team != \"NYY\";"
        ]
    },
    "1813": {
        "db_id": "small_bank_1",
        "question": "What is the sum of checking and savings balances for all customers, ordered by the total balance?",
        "ground_truth": "SELECT T1.balance + T2.balance FROM checking AS T1 JOIN savings AS T2 ON T1.custid  =  T2.custid ORDER BY T1.balance + T2.balance",
        "amends": [
            "Do select the sum of `T1.balance + T2.balance` instead of selecting `customer_id` and aliased `total_balance`. Do use `FROM checking AS T1 JOIN savings AS T2` instead of `FROM accounts`. Do join on `T1.custid = T2.custid` instead of not specifying any join condition. Do order by `T1.balance + T2.balance` instead of ordering by `checking_balance` alone. The amended query now correctly joins checking and savings accounts by customer ID and calculates the total balance across both account types, matching the intended behavior."
        ],
        "rules": [
            "1) When calculating total balance across account types: compute the sum of T1.balance + T2.balance instead of selecting individual customer IDs and aliased totals. 2) When combining checking and savings account data: use FROM checking AS T1 JOIN savings AS T2 instead of a single accounts table. 3) When linking customer accounts across tables: join on T1.custid = T2.custid to match customer records between checking and savings accounts. 4) When ordering by total balance: order by T1.balance + T2.balance instead of ordering by checking_balance alone."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_id, checking_balance + savings_balance AS total_balance FROM accounts ORDER BY checking_balance;",
            "SELECT T1.balance + T2.balance AS total_balance\nFROM CHECKING AS T1\nJOIN SAVINGS AS T2 ON T1.custid = T2.custid\nORDER BY T1.balance + T2.balance"
        ],
        "rule_sql": [
            "SELECT SUM(T1.balance + T2.balance) AS total_balance\nFROM checking AS T1\nJOIN savings AS T2 ON T1.custid = T2.custid\nORDER BY T1.balance + T2.balance;"
        ]
    },
    "5191": {
        "db_id": "music_2",
        "question": "What are the first and last names of the performer who was in the back stage position for the song \"Badlands\"?",
        "ground_truth": "SELECT T2.firstname ,  T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId WHERE T3.Title  =  \"Badlands\" AND T1.StagePosition  =  \"back\"",
        "amends": [
            "Do select `T2.firstname` and `T2.lastname` from the `Band` table instead of `first_name` and `last_name` from a `performers` table. Do join `Performance AS T1` with `Band AS T2` on `T1.bandmate = T2.id` and join `Songs AS T3` on `T3.SongId = T1.SongId` instead of querying a single table. Do filter on `T3.Title = \"Badlands\"` and `T1.StagePosition = \"back\"` instead of `position = 'back stage'` and `song_title = 'Badlands'` using the correct table references and column names. The amended query now correctly joins the necessary tables to find band members who performed \"Badlands\" in the back stage position, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about performer first and last names: select T2.firstname and T2.lastname from the Band table. 2) When the question mentions \"back stage position\": \"back stage\" actually means \"back\" in the StagePosition column of the Performance table. 3) When the question mentions the song \"Badlands\": filter on T3.Title = \"Badlands\" from the Songs table. 4) When combining Performance (T1), Band (T2), and Songs (T3) tables: link rows where T1.bandmate = T2.id and T3.SongId = T1.SongId, keeping only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM performers WHERE position = 'back stage' AND song_title = 'Badlands';",
            "SELECT T2.Firstname, T2.Lastname \nFROM Performance AS T1 \nJOIN Band AS T2 ON T1.Bandmate = T2.Id \nJOIN Songs AS T3 ON T3.SongId = T1.SongId \nWHERE T3.Title = 'Badlands' AND T1.StagePosition = 'back'"
        ],
        "rule_sql": [
            "SELECT T2.Firstname, T2.Lastname\nFROM Performance T1\nJOIN Band T2 ON T1.Bandmate = T2.Id\nJOIN Songs T3 ON T1.SongId = T3.SongId\nWHERE T1.StagePosition = 'back'\nAND T3.Title = 'Badlands'"
        ]
    },
    "2861": {
        "db_id": "icfp_1",
        "question": "Count the number of institutions.",
        "ground_truth": "SELECT count(*) FROM inst",
        "amends": [
            "Do reference table `inst` instead of `students` in the FROM clause. The amended query now correctly counts records from the intended table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting institutions: use the table \"inst\" to count records instead of \"students\". 2) When answering about \"number of institutions\": make sure to count all records from the \"inst\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;",
            "SELECT COUNT(*) FROM Inst;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Inst;"
        ]
    },
    "4045": {
        "db_id": "student_1",
        "question": "Show me the classrooms grade 5 is using.",
        "ground_truth": "SELECT DISTINCT classroom FROM list WHERE grade  =  5",
        "amends": [
            "Do select `classroom` instead of `*` and use `DISTINCT` instead of omitting it. Do query from `list` instead of `classrooms` as the source table. Do filter for `grade = 5` instead of `grade = 4`. The amended query now correctly returns distinct classroom values from the list table for grade 5 students."
        ],
        "rules": [
            "1) When answering about \"classrooms grade 5 is using\": make sure the output order: classroom. 2) When the question asks for distinct classrooms: compute the number of unique values of the exact token \"classroom\". 3) When the question mentions \"grade 5\": \"grade 5\" actually means \"grade = 5\" in schema. 4) When querying from the source table: use table \"list\" instead of \"classrooms\" as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM classrooms WHERE grade = 4;",
            "SELECT DISTINCT Classroom FROM list WHERE Grade = 5;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Classroom FROM list WHERE Grade = 5 ORDER BY Classroom;"
        ]
    },
    "2999": {
        "db_id": "sakila_1",
        "question": "Return the id of the store with the most customers.",
        "ground_truth": "SELECT store_id FROM customer GROUP BY store_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `GROUP BY store_id` instead of omitting it, which properly aggregates the data by store before counting. Do use `count(*)` instead of `COUNT(*)` for consistent lowercase syntax, though this is purely cosmetic. The amended query now correctly groups customers by store_id and orders by the count of customers per store to find the store with the most customers, matching the intended behavior.",
            "Do remove the explicit column alias `customer_count` from the SELECT list instead of including it, and do reference the aggregate function `count(*)` directly in the ORDER BY clause instead of using the alias. Do maintain the same GROUP BY clause on `store_id` and the same LIMIT 1 to return only the top result. The amended query now correctly orders by the actual count value rather than an alias that isn't available during the ordering phase, ensuring it returns the store_id with the highest customer count as intended."
        ],
        "rules": [
            "1) When answering about \"the store with the most customers\": make sure the output order: store_id. 2) When the question asks for \"count of customers\": compute the number of rows using the canonical key token for customers (e.g., store_id). 3) When the question mentions \"most customers\": rank rows by count of customers in descending direction and keep the first 1 row. 4) When the question says \"per store\"/\"by store\": organize results by store_id and compute requested aggregates per group.",
            "1) When answering about \"the store with the most customers\": make sure the output order: store_id only without the count column. 2) When counting customers: use count(*) to count all rows in the customer table. 3) When grouping by store: organize results by store_id from the customer table. 4) When ordering by customer count: order directly by count(*) in descending order to find the highest count. 5) When returning only the top result: use LIMIT 1 to return only the single store with the maximum customer count."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT store_id FROM customers ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT store_id, count(*) as customer_count FROM customer GROUP BY store_id ORDER BY customer_count DESC LIMIT 1;",
            "SELECT store_id FROM customer GROUP BY store_id ORDER BY count(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT store_id FROM customer GROUP BY store_id ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "4162": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "Show all calendar dates and day Numbers.",
        "ground_truth": "SELECT calendar_date ,  day_Number FROM Ref_calendar",
        "amends": [
            "Do reference table `Ref_calendar` instead of `calendar_dates` for the source data. Do use column name `day_Number` instead of `day_number` to match the correct case sensitivity. The amended query now correctly retrieves calendar dates and day numbers from the appropriate reference table with proper column naming."
        ],
        "rules": [
            "1) When answering about calendar dates and day numbers: use table \"Ref_calendar\" as the source data instead of \"calendar_dates\". 2) When referring to day numbers: use column name \"day_Number\" with exact case sensitivity instead of \"day_number\". 3) When retrieving calendar information: output columns should be in the order \"calendar_date\" followed by \"day_Number\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT calendar_date, day_number FROM calendar_dates ORDER BY calendar_date;",
            "SELECT Calendar_Date, Day_Number FROM Ref_Calendar;"
        ],
        "rule_sql": [
            "SELECT calendar_date, day_Number FROM Ref_Calendar ORDER BY calendar_date;"
        ]
    },
    "6853": {
        "db_id": "flight_4",
        "question": "How many cities are there that have more than 3 airports?",
        "ground_truth": "SELECT count(*) FROM (SELECT city FROM airports GROUP BY city HAVING count(*)  >  3)",
        "amends": [
            "Do use a subquery with `GROUP BY city` and `HAVING count(*) > 3` instead of directly filtering `airport_count > 3` in the WHERE clause. Do count the results from the subquery instead of counting directly from the cities table. Do reference the `airports` table instead of the `cities` table to correctly calculate airport counts per city. The amended query now correctly identifies cities with more than 3 airports by grouping and counting airport records rather than relying on a potentially incorrect pre-calculated column."
        ],
        "rules": [
            "1) When counting cities with more than 3 airports: use the airports table to count airports per city instead of relying on a pre-calculated airport_count column. 2) When grouping airports by city: use GROUP BY city to organize airport records by their city. 3) When filtering for cities with more than 3 airports: use HAVING count(*) > 3 to filter groups after aggregation. 4) When counting the resulting cities: count the results from the subquery that identifies cities meeting the airport count condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities WHERE airport_count > 3;",
            "SELECT COUNT(*) FROM (SELECT city FROM airports GROUP BY city HAVING COUNT(*) > 3) AS cities_with_many_airports;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS city_count\nFROM (\n    SELECT city\n    FROM airports\n    GROUP BY city\n    HAVING COUNT(*) > 3\n) AS cities_with_more_than_3_airports"
        ]
    },
    "5414": {
        "db_id": "shop_membership",
        "question": "How many different levels do members have?",
        "ground_truth": "SELECT count(DISTINCT LEVEL) FROM member",
        "amends": [
            "Do use `count(DISTINCT LEVEL)` instead of `COUNT(*)` to count distinct level values rather than all rows. Do reference table `member` instead of `members` with the correct table name. Do remove the `WHERE level IS NOT NULL` filter instead of keeping it since counting distinct values inherently excludes nulls. The amended query now correctly counts distinct level values from the member table and matches the right SQL's behavior."
        ],
        "rules": [
            "1) When counting different levels from the member table: use count(DISTINCT LEVEL) to count distinct level values rather than counting all rows. 2) When referencing the member table: use the exact table name \"member\" instead of \"members\". 3) When counting distinct values: do not include a WHERE level IS NOT NULL filter since counting distinct values inherently excludes nulls."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM members WHERE level IS NOT NULL;",
            "SELECT COUNT(DISTINCT Level) FROM member"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Level) FROM member;"
        ]
    },
    "976": {
        "db_id": "medicine_enzyme_interaction",
        "question": "How many medicines are offered by each trade name?",
        "ground_truth": "SELECT trade_name ,  count(*) FROM medicine GROUP BY trade_name",
        "amends": [
            "Do group by `trade_name` instead of `medicine_id` to correctly count records per trade name rather than per medicine ID. Do reference table `medicine` instead of `medicines` to use the correct table name. The amended query now correctly counts occurrences of each trade name from the medicine table."
        ],
        "rules": [
            "1) When the question asks for \"each trade name\": group results by the exact column token \"trade_name\" from the medicine table. 2) When counting medicines per trade name: count using the canonical key \"medicine_id\" from the medicine table. 3) When referencing the medicine table: use the exact table name \"medicine\" (not \"medicines\"). 4) When answering about \"how many medicines are offered by each trade name\": make sure the output order: trade_name first, then count of medicines."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT trade_name, COUNT(*) FROM medicines GROUP BY medicine_id;",
            "SELECT Trade_Name, COUNT(*) AS medicine_count FROM medicine GROUP BY Trade_Name;"
        ],
        "rule_sql": [
            "SELECT Trade_Name, COUNT(id) AS medicine_count FROM medicine GROUP BY Trade_Name ORDER BY Trade_Name, medicine_count;"
        ]
    },
    "537": {
        "db_id": "store_1",
        "question": "A list of the top 5 countries by number of invoices. List country name and number of invoices.",
        "ground_truth": "SELECT billing_country ,  COUNT(*) FROM invoices GROUP BY billing_country ORDER BY count(*) DESC LIMIT 5;",
        "amends": [
            "Do reference `billing_country` instead of `Country` in the SELECT list and GROUP BY clause. Do use `count(*)` without an alias instead of `COUNT(*) as NumberOfInvoices` in the SELECT list. Do reference `count(*)` instead of `NumberOfInvoices` in the ORDER BY clause. The amended query now correctly matches the right SQL's behavior by using the proper column name and removing the unnecessary alias."
        ],
        "rules": [
            "1) When the question asks for \"country name\": use the exact column token \"billing_country\" from the invoices table. 2) When counting invoices: use count(*) without any alias. 3) When ordering by the count of invoices: reference count(*) directly in the ORDER BY clause without an alias. 4) When answering about top 5 countries by number of invoices: rank rows by count(*) in descending order and keep the first 5 rows. 5) When grouping by country: organize results by the exact column token \"billing_country\" and compute count(*) per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Country, COUNT(*) as NumberOfInvoices \nFROM Invoices \nGROUP BY Country \nORDER BY NumberOfInvoices DESC \nLIMIT 5;",
            "SELECT billing_country, count(*) \nFROM invoices \nGROUP BY billing_country \nORDER BY count(*) DESC \nLIMIT 5"
        ],
        "rule_sql": [
            "SELECT billing_country, count(*) FROM invoices GROUP BY billing_country ORDER BY count(*) DESC LIMIT 5"
        ]
    },
    "4222": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "Show the location code, the starting date and ending data in that location for all the documents.",
        "ground_truth": "SELECT location_code ,  date_in_location_from ,  date_in_locaton_to FROM Document_locations",
        "amends": [
            "Do reference `date_in_location_from` and `date_in_location_to` columns instead of `starting_date` and `ending_date`. Do query from the `Document_locations` table instead of the `documents` table. The amended query now correctly retrieves location date ranges from the appropriate table structure."
        ],
        "rules": [
            "1) When the question asks for location code, starting date, and ending date for documents: use the exact column tokens \"location_code\", \"date_in_location_from\", and \"date_in_location_to\" from the Document_locations table. 2) When retrieving document location information: query from the Document_locations table instead of the documents table. 3) When ordering results by location: order by the \"location_code\" column."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location_code, starting_date, ending_date FROM documents ORDER BY location_code;",
            "SELECT Location_Code, Date_in_Location_From, Date_in_Locaton_To FROM Document_Locations;"
        ],
        "rule_sql": [
            "SELECT location_code, date_in_location_from, date_in_location_to FROM Document_Locations ORDER BY location_code;"
        ]
    },
    "5382": {
        "db_id": "tracking_software_problems",
        "question": "List all the distinct product names ordered by product id?",
        "ground_truth": "SELECT DISTINCT product_name FROM product ORDER BY product_id",
        "amends": [
            "Do reference table `product` instead of `products` in the FROM clause. Do maintain the same SELECT list with `product_name` and DISTINCT modifier. Do preserve the ORDER BY clause with `product_id` unchanged. The amended query now correctly references the intended table while maintaining identical output behavior."
        ],
        "rules": [
            "1) When the question asks for \"distinct product names\": compute the number of unique values of the exact token \"product_name\" from table \"Product\". 2) When the question mentions \"ordered by product id\": rank rows by \"product_id\" in ascending order and maintain that ordering in the output. 3) When referencing the product table: use the exact table name \"Product\" with double quotes as shown in the schema, not \"products\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT product_name FROM products ORDER BY product_id;",
            "SELECT DISTINCT product_name FROM Product ORDER BY product_id;"
        ],
        "rule_sql": [
            "SELECT DISTINCT \"product_name\" FROM \"Product\" ORDER BY \"product_id\" ASC;"
        ]
    },
    "6489": {
        "db_id": "scientist_1",
        "question": "Find the name of projects that require between 100 and 300 hours of work.",
        "ground_truth": "SELECT name FROM projects WHERE hours BETWEEN 100 AND 300",
        "amends": [
            "Do use `BETWEEN 100 AND 300` instead of `hours < 100 OR hours > 300` to correctly select projects with hours within the specified range rather than excluding them. This changes the logic from filtering out projects with hours between 100 and 300 to including only those projects, fixing the inverted condition that was excluding the desired records. The amended query now matches RIGHT_SQL's behavior by properly selecting projects with hours between 100 and 300 inclusive."
        ],
        "rules": [
            "1) When the question asks for projects with hours between 100 and 300 inclusive: use the exact condition \"hours BETWEEN 100 AND 300\" to include projects with hours from 100 to 300 inclusive, rather than excluding them with OR conditions. 2) When filtering numeric ranges with inclusive bounds: use BETWEEN with the exact literal values 100 and 300 to capture the inclusive range from 100 through 300."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM projects WHERE hours < 100 OR hours > 300;",
            "SELECT Name FROM Projects WHERE Hours BETWEEN 100 AND 300"
        ],
        "rule_sql": [
            "SELECT Name FROM Projects WHERE Hours BETWEEN 100 AND 300"
        ]
    },
    "5088": {
        "db_id": "device",
        "question": "Show the carriers of devices in stock at more than one shop.",
        "ground_truth": "SELECT T2.Carrier FROM stock AS T1 JOIN device AS T2 ON T1.Device_ID  =  T2.Device_ID GROUP BY T1.Device_ID HAVING COUNT(*)  >  1",
        "amends": [
            "Do select `T2.Carrier` instead of `carrier` from the devices table. Do join `stock AS T1` with `device AS T2` on `T1.Device_ID = T2.Device_ID` instead of querying only the `devices` table. Do group by `T1.Device_ID` instead of `shop_id`. Do use `HAVING COUNT(*) > 1` instead of `WHERE stock_count > 1` to filter groups rather than individual rows. The amended query now correctly aggregates stock counts per device and filters for devices with multiple stock entries, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"carriers of devices in stock at more than one shop\": make sure the output order: T2.Carrier\n2) When combining stock (T1) and device (T2) tables: link rows where T1.Device_ID = T2.Device_ID and keep only matching pairs (inner match)\n3) When grouping by device: organize results by T1.Device_ID and compute aggregates per device\n4) When filtering for devices in stock at more than one shop: after grouping by device, keep only groups where the count of stock entries is greater than 1\n5) When selecting the carrier: use T2.Carrier as the exact output column"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT carrier FROM devices WHERE stock_count > 1 GROUP BY shop_id;",
            "SELECT T2.Carrier\nFROM stock AS T1\nJOIN device AS T2 ON T1.Device_ID = T2.Device_ID\nGROUP BY T1.Device_ID\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T2.Carrier\nFROM stock T1\nINNER JOIN device T2 ON T1.Device_ID = T2.Device_ID\nGROUP BY T1.Device_ID\nHAVING COUNT(T1.Shop_ID) > 1\nORDER BY T2.Carrier"
        ]
    },
    "4839": {
        "db_id": "aircraft",
        "question": "what is the name and age of the youngest winning pilot?",
        "ground_truth": "SELECT t1.name ,  t1.age FROM pilot AS t1 JOIN MATCH AS t2 ON t1.pilot_id  =  t2.winning_pilot ORDER BY t1.age LIMIT 1",
        "amends": [
            "Do specify table aliases with `t1.name` and `t1.age` instead of unqualified `name` and `age`. Do change the FROM clause to `pilot AS t1` instead of `pilots` and add a `JOIN MATCH AS t2` instead of omitting it. Do use the join condition `ON t1.pilot_id = t2.winning_pilot` instead of the WHERE filter `wins > 0`. Do remove the explicit `ASC` direction from `ORDER BY t1.age` instead of keeping it. The amended query now correctly joins the pilot and match tables to identify the youngest pilot with match wins, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"the youngest winning pilot\": make sure the output order: t1.name, t1.age. 2) When the question mentions \"winning pilot\": \"winning\" actually means \"pilot_id matches winning_pilot in MATCH table\". 3) When combining pilot table (as t1) and MATCH table (as t2): link rows where t1.pilot_id = t2.winning_pilot exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"youngest\": rank rows by t1.age in ascending order and keep the first 1 row. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, age FROM pilots WHERE wins > 0 ORDER BY age ASC LIMIT 1;",
            "SELECT t1.Name, t1.Age FROM pilot AS t1 JOIN match AS t2 ON t1.Pilot_Id = t2.Winning_Pilot ORDER BY t1.Age LIMIT 1"
        ],
        "rule_sql": [
            "SELECT t1.Name, t1.Age\nFROM pilot AS t1\nINNER JOIN \"match\" AS t2 ON t1.Pilot_Id = t2.Winning_Pilot\nORDER BY t1.Age ASC\nLIMIT 1"
        ]
    },
    "5098": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "What are the phone and email for customer Harold?",
        "ground_truth": "SELECT Customer_Phone ,  Customer_Email_Address FROM CUSTOMERS WHERE Customer_Name  =  \"Harold\"",
        "amends": [
            "Do use column names `Customer_Phone` and `Customer_Email_Address` instead of `phone` and `email`. Do reference the table `CUSTOMERS` in uppercase instead of lowercase `customers`. Do filter on `Customer_Name = \"Harold\"` instead of `first_name = 'Harold'` using double quotes instead of single quotes for the string literal. The amended query now correctly matches the intended column names, table reference, and filtering condition to produce the expected results."
        ],
        "rules": [
            "1) When the question asks for phone and email information: use the exact column names \"Customer_Phone\" and \"Customer_Email_Address\" from the CUSTOMERS table. 2) When filtering for a customer by name: use the exact condition Customer_Name = \"Harold\" with double quotes around the literal value. 3) When referencing the customer table: use the exact table name CUSTOMERS in uppercase as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT phone, email FROM customers WHERE first_name = 'Harold';",
            "SELECT Customer_Phone, Customer_Email_Address FROM CUSTOMERS WHERE Customer_Name = \"Harold\";"
        ],
        "rule_sql": [
            "SELECT Customer_Phone, Customer_Email_Address FROM CUSTOMERS WHERE Customer_Name = \"Harold\";"
        ]
    },
    "3154": {
        "db_id": "assets_maintenance",
        "question": "Which gender makes up the majority of the staff?",
        "ground_truth": "SELECT gender FROM staff GROUP BY gender ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `gender` instead of including `COUNT(*) as count` in the SELECT list. Do move the aggregate function `count(*)` to the ORDER BY clause instead of keeping it in the SELECT list. Do remove the alias `count` from the ORDER BY clause instead of referencing it directly. End with confirmation that the amended query now correctly returns only the gender with the highest count without including the count value in the output."
        ],
        "rules": [
            "1) When answering about \"which gender makes up the majority of the staff\": make sure the output order includes only the gender column without any count values. 2) When counting staff members by gender: use the count(*) function to compute the total number of rows per gender group. 3) When ranking genders by count to find the majority: order the results by the count in descending direction and keep only the first row (highest count). 4) When the question asks for the majority gender: return only the gender value itself, not the count value that determined the majority status."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT gender, COUNT(*) as count FROM staff GROUP BY gender ORDER BY count DESC LIMIT 1;",
            "SELECT gender FROM Staff GROUP BY gender ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT gender FROM Staff GROUP BY gender ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "2463": {
        "db_id": "movie_1",
        "question": "For the oldest movie listed, what is its average rating and title?",
        "ground_truth": "SELECT avg(T1.stars) ,  T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T2.year  =  (SELECT min(YEAR) FROM Movie)",
        "amends": [
            "Do specify `avg(T1.stars)` and `T2.title` in the SELECT list instead of `title` and `AVG(rating) as average_rating`. Do join `Rating AS T1` with `Movie AS T2` on `T1.mID = T2.mID` instead of querying only the `movies` table. Do add a WHERE filter `T2.year = (SELECT min(YEAR) FROM Movie)` instead of ordering by `release_year ASC LIMIT 1`. Do remove the ORDER BY and LIMIT clauses instead of keeping them. The amended query now correctly calculates average ratings for movies from the earliest release year by joining the proper tables and using a subquery to identify the minimum year.",
            "Do place `avg(T1.stars)` first in the SELECT list instead of `T2.title` first, but maintain both columns in the output. The query structure remains identical with the same JOIN condition `T1.mID = T2.mID` and WHERE filter checking `T2.year = (SELECT min(year) FROM Movie)`. No changes were made to the FROM clause, join type, subquery structure, or any other query components. The amended query now matches RIGHT_SQL's behavior with the column order adjusted as specified."
        ],
        "rules": [
            "1) When answering about \"the oldest movie\": use a subquery to find the minimum year value from the Movie table instead of ordering by release_year. 2) When combining Rating and Movie tables: link rows where T1.mID = T2.mID and keep only matching pairs (inner match). 3) When calculating average rating: use avg(T1.stars) instead of AVG(rating). 4) When selecting movie title: use T2.title instead of title. 5) When filtering for the oldest movie: add WHERE T2.year = (SELECT min(YEAR) FROM Movie) instead of using ORDER BY and LIMIT.",
            "1) When answering about \"the oldest movie listed\": make sure the output order: average rating first, then title. 2) When combining Rating and Movie tables for shared entities: link rows where T1.mID = T2.mID exactly as shown; keep only matching pairs (inner match). 3) When filtering for the oldest movie: check T2.year = (SELECT min(year) FROM Movie) to find movies from the earliest year."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title, AVG(rating) as average_rating FROM movies ORDER BY release_year ASC LIMIT 1;",
            "SELECT T2.title, avg(T1.stars) \nFROM Rating AS T1 \nJOIN Movie AS T2 ON T1.mID = T2.mID \nWHERE T2.year = (SELECT min(year) FROM Movie)",
            "SELECT avg(T1.stars), T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID = T2.mID WHERE T2.year = (SELECT min(year) FROM Movie)"
        ],
        "rule_sql": [
            "SELECT avg(T1.stars), T2.title \nFROM Rating T1 \nINNER JOIN Movie T2 ON T1.mID = T2.mID \nWHERE T2.year = (SELECT min(year) FROM Movie)"
        ]
    },
    "1744": {
        "db_id": "gymnast",
        "question": "What are the names of people in ascending alphabetical order?",
        "ground_truth": "SELECT Name FROM People ORDER BY Name ASC",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM people ORDER BY name DESC;"
        ],
        "rule_sql": [
            "SELECT Name FROM people ORDER BY Name ASC;"
        ]
    },
    "4170": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "What is the document type code for document type \"Paper\"?",
        "ground_truth": "SELECT document_type_code FROM Ref_document_types WHERE document_type_name  =  \"Paper\"",
        "amends": [
            "Do select `document_type_code` instead of `document_type` in the SELECT list. Do reference table `Ref_document_types` instead of `document_types` in the FROM clause. Do filter on `document_type_name = \"Paper\"` instead of `document_type = 'Paper'` in the WHERE clause, changing both the column reference and the string literal syntax from single to double quotes. The amended query now correctly retrieves the document type code from the reference table based on the document type name."
        ],
        "rules": [
            "1) When the question asks for \"document type code\": select the exact column \"document_type_code\" from the table. 2) When the question mentions document type \"Paper\": filter using the exact column \"document_type_name\" with the exact literal value \"Paper\" in double quotes. 3) When referencing the document types table: use the exact table name \"Ref_document_types\" as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_type FROM document_types WHERE document_type = 'Paper';",
            "SELECT Document_Type_Code FROM Ref_Document_Types WHERE Document_Type_Name = \"Paper\";"
        ],
        "rule_sql": [
            "SELECT document_type_code FROM Ref_document_types WHERE document_type_name = \"Paper\";"
        ]
    },
    "5476": {
        "db_id": "voter_2",
        "question": "Find the distinct ages of students who have secretary votes in the fall election cycle.",
        "ground_truth": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  \"Fall\"",
        "amends": [
            "Do reference `T1.Age` with table alias instead of `age` without qualification. Do join `STUDENT AS T1` with `VOTING_RECORD AS T2` instead of querying only `students` table. Do use `ON T1.StuID = T2.Secretary_Vote` join condition instead of filtering `has_secretary_vote = 1`. Do filter on `T2.Election_Cycle = \"Fall\"` instead of `election_cycle = 'fall'` with different case and quotes. The amended query now correctly joins student and voting data to identify students who voted for secretary in the Fall election cycle."
        ],
        "rules": [
            "1) When answering about \"distinct ages of students who have secretary votes in the fall election cycle\": make sure the output order: T1.Age. 2) When the question mentions \"students who have secretary votes\": this actually means joining T1 (STUDENT) with T2 (VOTING_RECORD) where T1.StuID = T2.Secretary_Vote. 3) When the question mentions \"fall election cycle\": this actually means filtering T2.Election_Cycle = \"Fall\" with exact case and double quotes. 4) When the question asks for \"distinct ages\": compute the unique values of T1.Age from the joined result set."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT age FROM students WHERE election_cycle = 'fall' AND has_secretary_vote = 1;",
            "SELECT DISTINCT T1.Age\nFROM Student AS T1\nJOIN Voting_record AS T2 ON T1.StuID = T2.Secretary_Vote\nWHERE T2.Election_Cycle = 'Fall'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Age\nFROM Student T1\nJOIN Voting_record T2 ON T1.StuID = T2.Secretary_Vote\nWHERE T2.Election_Cycle = \"Fall\"\nORDER BY T1.Age;"
        ]
    },
    "6791": {
        "db_id": "activity_1",
        "question": "What is the first and last name of the student participating in the most activities?",
        "ground_truth": "SELECT T1.fname ,  T1.lname FROM Student AS T1 JOIN Participates_in AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `s` and `a`. Do reference columns `fname` and `lname` instead of `first_name` and `last_name`. Do join table `Participates_in` as `T2` instead of `activities`. Do use join condition `T1.StuID = T2.StuID` instead of `s.student_id = a.student_id`. Do group by `T1.StuID` instead of `s.student_id`. Do use `count(*)` instead of `COUNT(a.activity_id)` in the ORDER BY clause. The amended query now correctly matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"student participating in the most activities\": make sure the output order: T1.fname, T1.lname 2) When the question mentions \"first and last name\": \"first name\" actually means \"fname in schema\" and \"last name\" actually means \"lname in schema\" 3) When combining T1 and T2 for shared entities: link rows where T1.StuID = T2.StuID; keep only matching pairs (inner match) 4) When the question asks for \"count of activities\": compute the number of rows using count(*) 5) When the question mentions \"most activities\": rank rows by count(*) in descending direction and keep the first 1 row 6) When grouping by student: organize results by T1.StuID and compute requested aggregates per group"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.first_name, s.last_name \nFROM students s \nJOIN activities a ON s.student_id = a.student_id \nGROUP BY s.student_id \nORDER BY COUNT(a.activity_id) DESC \nLIMIT 1;",
            "SELECT T1.Fname, T1.LName\nFROM Student T1\nJOIN Participates_in T2 ON T1.StuID = T2.StuID\nGROUP BY T1.StuID\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT s.Fname, s.LName\nFROM Student s\nJOIN Participates_in p ON s.StuID = p.stuid\nGROUP BY s.StuID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "2668": {
        "db_id": "party_host",
        "question": "What is the average number of hosts for parties?",
        "ground_truth": "SELECT avg(Number_of_hosts) FROM party",
        "amends": [
            "Do reference the correct column name `Number_of_hosts` instead of the incorrect `hosts` column. Do reference the correct table name `party` instead of the incorrect `parties` table. The amended query now correctly calculates the average number of hosts from the appropriate table and column, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"average number of hosts\": use the exact column name \"Number_of_hosts\" from the \"party\" table. 2) When referencing the table containing host information: use the exact table name \"party\" (not \"parties\"). 3) When calculating the average: compute the mean value of the \"Number_of_hosts\" column from the \"party\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(hosts) FROM parties;",
            "SELECT AVG(Number_of_hosts) FROM party;"
        ],
        "rule_sql": [
            "SELECT AVG(Number_of_hosts) FROM party;"
        ]
    },
    "1639": {
        "db_id": "wedding",
        "question": "Show the name and country for all people whose age is smaller than the average.",
        "ground_truth": "SELECT name ,  country FROM people WHERE age  <  (SELECT avg(age) FROM people)",
        "amends": [
            "Do use the comparison operator `<` instead of `>` in the WHERE clause filter on `age` relative to the subquery average. Do maintain the identical SELECT list with `name` and `country` columns instead of changing them. Do preserve the same subquery structure `(SELECT avg(age) FROM people)` instead of altering it. The amended query now correctly selects people younger than the average age instead of those older than average, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for people whose age is smaller than the average: use the comparison operator `<` instead of `>` in the filter condition on age relative to the subquery average. 2) When selecting output columns for this question: maintain the identical SELECT list with name and country columns in that order. 3) When computing the average age for comparison: preserve the same subquery structure (SELECT avg(age) FROM people) without alteration."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, country FROM people WHERE age > (SELECT AVG(age) FROM people)",
            "SELECT Name, Country FROM people WHERE Age < (SELECT AVG(Age) FROM people)"
        ],
        "rule_sql": [
            "SELECT Name, Country FROM people WHERE Age < (SELECT AVG(Age) FROM people)"
        ]
    },
    "6234": {
        "db_id": "ship_1",
        "question": "Find the name of captains whose rank are either Midshipman or Lieutenant.",
        "ground_truth": "SELECT name FROM captain WHERE rank  =  'Midshipman' OR rank  =  'Lieutenant'",
        "amends": [
            "Do use `OR` instead of `AND` for the rank filter conditions, allowing records to match either 'Midshipman' or 'Lieutenant' instead of requiring both ranks simultaneously. Do reference the correct table name `captain` instead of `captains` to ensure proper data source access. The amended query now correctly retrieves names of personnel who hold either the Midshipman or Lieutenant rank, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for captains with ranks \"Midshipman\" or \"Lieutenant\": use OR logic instead of AND to allow matching either rank value. 2) When referencing the captains table: use the exact table name \"captain\" instead of \"captains\" as specified in the schema. 3) When filtering by rank values: preserve the exact string literals \"Midshipman\" and \"Lieutenant\" with proper capitalization and spelling."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM captains WHERE rank = 'Midshipman' AND rank = 'Lieutenant';",
            "SELECT Name FROM captain WHERE Rank = 'Midshipman' OR Rank = 'Lieutenant'"
        ],
        "rule_sql": [
            "SELECT Name FROM captain WHERE Rank = 'Midshipman' OR Rank = 'Lieutenant'"
        ]
    },
    "4057": {
        "db_id": "student_1",
        "question": "Show each student's first name and last name.",
        "ground_truth": "SELECT DISTINCT firstname ,  lastname FROM list",
        "amends": [
            "Do select `firstname` and `lastname` instead of only `first_name`. Do use `DISTINCT` instead of omitting it. Do query from `list` instead of `students`. The amended query now matches the intended behavior with distinct first and last names from the correct table."
        ],
        "rules": [
            "1) When the question asks for \"each student's first name and last name\": select both \"firstname\" and \"lastname\" columns instead of only \"first_name\". 2) When selecting student names: use DISTINCT to return only unique combinations of first and last names. 3) When querying for student information: use the \"list\" table instead of \"students\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students;",
            "SELECT DISTINCT FirstName, LastName FROM list;"
        ],
        "rule_sql": [
            "SELECT DISTINCT FirstName, LastName FROM list;"
        ]
    },
    "4990": {
        "db_id": "soccer_2",
        "question": "What are the names of schools with the top 3 largest size?",
        "ground_truth": "SELECT cName FROM college ORDER BY enr DESC LIMIT 3",
        "amends": [
            "Do select `cName` instead of `name` and use table `college` instead of `schools`. Do order by `enr DESC` instead of `size ASC` while keeping the `LIMIT 3` clause unchanged. The amended query now correctly retrieves the top 3 colleges by enrollment in descending order."
        ],
        "rules": [
            "1) When answering about \"names of schools with the top 3 largest size\": make sure the output order: \"cName\" 2) When the question mentions \"schools\": \"schools\" actually means \"college\" in schema 3) When the question mentions \"top\", \"largest\", or an explicit 3 by size: rank rows by \"enr\" in descending direction and keep the first 3 rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM schools ORDER BY size ASC LIMIT 3;",
            "SELECT cName FROM College ORDER BY enr DESC LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT cName FROM College ORDER BY enr DESC LIMIT 3"
        ]
    },
    "4536": {
        "db_id": "document_management",
        "question": "What is the average access count of documents that have the least common structure?",
        "ground_truth": "SELECT avg(access_count) FROM documents GROUP BY document_structure_code ORDER BY count(*) ASC LIMIT 1",
        "amends": [
            "Do use `GROUP BY document_structure_code` instead of a subquery with `WHERE structure = (SELECT structure...)`. Do add `ORDER BY count(*) ASC LIMIT 1` to the main query instead of placing it in a subquery. Do remove the subquery entirely instead of using correlated filtering. Do aggregate `access_count` within each document structure group instead of attempting to filter to a single structure first. The amended query now correctly calculates the average access count for the document structure with the fewest documents, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"average access count of documents that have the least common structure\": compute the average of the \"access_count\" column for the document structure group with the smallest count of documents. 2) When grouping documents by structure: use \"document_structure_code\" as the grouping key instead of \"structure\". 3) When finding the least common structure: order document structure groups by count(*) in ascending order and take only the first group (limit 1). 4) When computing the average access count: aggregate the \"access_count\" values within the identified document structure group instead of filtering documents first."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(access_count) FROM documents WHERE structure = (SELECT structure FROM documents GROUP BY structure ORDER BY COUNT(*) ASC LIMIT 1);",
            "SELECT AVG(d.access_count) AS average_access_count\nFROM Documents d\nJOIN (\n    SELECT document_structure_code, COUNT(*) AS doc_count\n    FROM Documents\n    GROUP BY document_structure_code\n    ORDER BY doc_count ASC\n    LIMIT 1\n) least_common ON d.document_structure_code = least_common.document_structure_code;"
        ],
        "rule_sql": [
            "SELECT AVG(d.access_count) AS average_access_count\nFROM Documents d\nWHERE d.document_structure_code = (\n    SELECT ds.document_structure_code\n    FROM Documents ds\n    GROUP BY ds.document_structure_code\n    ORDER BY COUNT(*) ASC\n    LIMIT 1\n);"
        ]
    },
    "4922": {
        "db_id": "store_product",
        "question": "Find the number of stores in each city.",
        "ground_truth": "SELECT t3.headquartered_city ,  count(*) FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city",
        "amends": [
            "Do join `store AS t1` instead of querying only `stores`, then add `JOIN store_district AS t2 ON t1.store_id = t2.store_id` instead of omitting it, and add `JOIN district AS t3 ON t2.district_id = t3.district_id` instead of omitting it. Do select `t3.headquartered_city` instead of `city`, and move the grouping to `t3.headquartered_city` instead of `city`. The amended query now correctly joins the necessary tables to access the headquartered_city from the district table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"number of stores in each city\": make sure the output order: t3.headquartered_city, count of stores. 2) When the question mentions \"city\": \"city\" actually means \"t3.headquartered_city\" in schema. 3) When combining store AS t1 and store_district AS t2 for shared entities: link rows where t1.store_id = t2.store_id exactly; keep only matching pairs (inner match). 4) When combining store_district AS t2 and district AS t3 for shared entities: link rows where t2.district_id = t3.district_id exactly; keep only matching pairs (inner match). 5) When the question asks for \"count of stores\": compute the number of rows using the canonical key token t1.store_id. 6) When the question says \"per city\"/\"by city\": organize results by t3.headquartered_city and compute count per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, COUNT(*) FROM stores GROUP BY city;",
            "SELECT t3.Headquartered_City, COUNT(t1.Store_ID) AS number_of_stores\nFROM store AS t1\nJOIN store_district AS t2 ON t1.Store_ID = t2.Store_ID\nJOIN district AS t3 ON t2.District_ID = t3.District_ID\nGROUP BY t3.Headquartered_City"
        ],
        "rule_sql": [
            "SELECT t3.headquartered_city, COUNT(t1.store_id) \nFROM store AS t1 \nINNER JOIN store_district AS t2 ON t1.store_id = t2.store_id \nINNER JOIN district AS t3 ON t2.district_id = t3.district_id \nGROUP BY t3.headquartered_city \nORDER BY t3.headquartered_city, COUNT(t1.store_id)"
        ]
    },
    "714": {
        "db_id": "customers_card_transactions",
        "question": "Return the id of the customer who has the most cards, as well as the number of cards.",
        "ground_truth": "SELECT customer_id ,  count(*) FROM Customers_cards GROUP BY customer_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference table `Customers_cards` instead of `cards` in the FROM clause. Do order by `count(*) DESC` instead of `ASC` to find the customer with the most cards rather than the fewest. Do remove the alias `as card_count` instead of keeping it since the ORDER BY clause directly references the aggregate function. The amended query now correctly identifies the customer with the highest number of cards by counting from the appropriate table and sorting in descending order, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"the customer who has the most cards\": make sure the output order: customer_id first, then the count of cards. 2) When counting cards per customer: use table \"Customers_cards\" instead of \"cards\" to access the correct data. 3) When finding the customer with the most cards: order by the count of cards in descending order (highest first) instead of ascending order. 4) When ordering by an aggregate count: reference the aggregate function count(*) directly in the ORDER BY clause instead of using an alias. 5) When limiting to the top result: use LIMIT 1 to return only the customer with the highest count."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT customer_id, COUNT(*) as card_count FROM cards GROUP BY customer_id ORDER BY card_count ASC LIMIT 1;",
            "SELECT customer_id, COUNT(*) \nFROM Customers_Cards \nGROUP BY customer_id \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT customer_id, COUNT(*) AS card_count FROM Customers_Cards GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "281": {
        "db_id": "twitter_1",
        "question": "Find the name and email of the user whose name contains the word \u2018Swift\u2019.",
        "ground_truth": "SELECT name ,  email FROM user_profiles WHERE name LIKE '%Swift%'",
        "amends": [
            "Do reference the `user_profiles` table instead of the `users` table in the FROM clause. Do maintain the same SELECT list with `name` and `email` columns and the same WHERE filter condition `name LIKE '%Swift%'` without changes. The amended query now correctly queries from the user_profiles table instead of users, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for user information: use the \"user_profiles\" table instead of the \"users\" table. 2) When selecting name and email columns: use the exact column names \"name\" and \"email\" from the \"user_profiles\" table. 3) When filtering for names containing the word 'Swift': apply the condition name LIKE '%Swift%' exactly as specified, preserving the case and wildcard pattern."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, email FROM users WHERE name LIKE '%Swift%';",
            "SELECT name, email FROM user_profiles WHERE name LIKE '%Swift%'"
        ],
        "rule_sql": [
            "SELECT name, email FROM user_profiles WHERE name LIKE '%Swift%'"
        ]
    },
    "4486": {
        "db_id": "decoration_competition",
        "question": "What are the names and countries of members?",
        "ground_truth": "SELECT Name ,  Country FROM member",
        "amends": [
            "Do reference the `member` table instead of the `members` table. Do use column names `Name` and `Country` with proper capitalization instead of lowercase `name` and `country`. Do remove the `WHERE country = 'USA'` filter instead of keeping it. The amended query now correctly selects all records from the member table without unnecessary filtering."
        ],
        "rules": [
            "1) When answering about \"names and countries of members\": make sure the output order: Name, Country. 2) When the question mentions \"members\": \"members\" actually means \"member table in schema\". 3) When the question mentions \"names\": \"names\" actually means \"Name column in member table\". 4) When the question mentions \"countries\": \"countries\" actually means \"Country column in member table\". 5) When selecting from the member table: do not apply any WHERE filter unless explicitly specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, country FROM members WHERE country = 'USA';",
            "SELECT Name, Country FROM member;"
        ],
        "rule_sql": [
            "SELECT Name, Country FROM member;"
        ]
    },
    "3652": {
        "db_id": "baseball_1",
        "question": "What are the first name and last name of the players whose death record is empty?",
        "ground_truth": "SELECT name_first ,  name_last FROM player WHERE death_year = '';",
        "amends": [
            "Do select `name_first` and `name_last` instead of `first_name` and `last_name`. Do query from `player` instead of `players`. Do filter for `death_year = ''` (empty string) instead of `death_date IS NOT NULL`. The amended query now correctly retrieves players with empty death year values instead of non-null death dates, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"first name\" and \"last name\": use the exact column names \"name_first\" and \"name_last\" from the player table. 2) When querying player information: use the table name \"player\" (singular) instead of \"players\". 3) When filtering for empty death records: check for empty string values using \"death_year = ''\" instead of checking for NULL values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM players WHERE death_date IS NOT NULL;",
            "SELECT name_first, name_last FROM player WHERE death_year = ''"
        ],
        "rule_sql": [
            "SELECT name_first, name_last FROM player WHERE death_year = ''"
        ]
    },
    "5792": {
        "db_id": "customer_complaints",
        "question": "What is the average price of the products for each category?",
        "ground_truth": "SELECT avg(product_price) ,  product_category_code FROM products GROUP BY product_category_code",
        "amends": [
            "Do use `avg(product_price)` instead of `AVG(price)` for the aggregate function and column reference. Do use `product_category_code` instead of `category` for the grouping column. Do remove the alias from the aggregate function instead of keeping it. The amended query now correctly references the actual column names and matches the intended behavior.",
            "Do place `product_category_code` after the aggregate function instead of before it in the SELECT list. Do use lowercase `avg` instead of uppercase `AVG` for the aggregate function. Do use lowercase `products` instead of uppercase `Products` for the table name. The amended query now matches the right SQL's behavior with identical logic and output.",
            "Do place `product_category_code` after `avg(product_price)` in the SELECT list instead of before it, maintaining the same logical grouping and aggregation behavior. The amended query now matches RIGHT_SQL's behavior with identical results."
        ],
        "rules": [
            "1) When the question asks for average price of products: use avg(product_price) instead of AVG(price) for the aggregate function. 2) When grouping by category: use product_category_code instead of category for the grouping column. 3) When computing aggregates: do not include aliases in the aggregate function output.",
            "1) When the question asks for average price per category: compute the average of product_price for each product_category_code group. 2) When selecting columns with aggregates: place the grouping column product_category_code before the aggregate function avg(product_price) in the output. 3) When referring to the products table: use the exact lowercase identifier 'products' instead of uppercase 'Products'. 4) When using the average aggregate function: use the exact lowercase 'avg' instead of uppercase 'AVG'.",
            "1) When answering about \"average price of products for each category\": make sure the output order: average price first, then product category code. 2) When the question asks for \"average price of the products for each category\": compute the average of product_price grouped by product_category_code. 3) When producing output columns: place avg(product_price) before product_category_code in the result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT category, AVG(price) FROM products GROUP BY category;",
            "SELECT product_category_code, AVG(product_price) FROM Products GROUP BY product_category_code;",
            "SELECT product_category_code, avg(product_price) FROM products GROUP BY product_category_code",
            "SELECT avg(product_price), product_category_code FROM products GROUP BY product_category_code"
        ],
        "rule_sql": [
            "SELECT avg(product_price), product_category_code FROM products GROUP BY product_category_code"
        ]
    },
    "6344": {
        "db_id": "e_government",
        "question": "What is the name of organization that has the greatest number of contact individuals?",
        "ground_truth": "SELECT t1.organization_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id GROUP BY t1.organization_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `organization_contact_individuals AS t2` on `t1.organization_id = t2.organization_id` instead of omitting the join table entirely. Do add `GROUP BY t1.organization_name` instead of ordering by a non-aggregated column. Do use `count(*)` in the ORDER BY instead of `COUNT(contact_individuals)` which references a non-existent column. Do specify `t1.organization_name` in the SELECT instead of just `organization_name` for clarity. The amended query now correctly counts contact individuals per organization and returns the organization with the most contacts, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"organization that has the greatest number of contact individuals\": make sure the output order: t1.organization_name. 2) When the question asks for \"greatest number of contact individuals\": count the number of rows using count(*) per organization. 3) When combining Organizations as T1 and organization_contact_individuals as T2: link rows where t1.organization_id = t2.organization_id and keep only matching pairs (inner match). 4) When grouping by organization: organize results by t1.organization_name and compute the count per group. 5) When ranking organizations by contact count: rank rows by count(*) in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT organization_name FROM organizations ORDER BY COUNT(contact_individuals) DESC LIMIT 1;",
            "SELECT t1.organization_name\nFROM Organizations AS t1\nJOIN Organization_Contact_Individuals AS t2 ON t1.organization_id = t2.organization_id\nGROUP BY t1.organization_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t1.organization_name\nFROM Organizations AS t1\nINNER JOIN Organization_Contact_Individuals AS t2 ON t1.organization_id = t2.organization_id\nGROUP BY t1.organization_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "4199": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "What are the name, role code, and date of birth of the employee named 'Armani'?",
        "ground_truth": "SELECT employee_name ,  role_code ,  date_of_birth FROM Employees WHERE employee_Name  =  'Armani'",
        "amends": [
            "Do reference `employee_name` instead of `name` in the SELECT list and WHERE clause. Do reference `Employees` instead of `employees` as the table name. Do filter for `'Armani'` instead of `'Armando'` in the WHERE condition. The amended query now correctly matches the RIGHT_SQL's behavior with proper column and table references along with the corrected filter value."
        ],
        "rules": [
            "1) When the question asks for employee information by name: use the exact table name \"Employees\" with proper case sensitivity. 2) When selecting employee attributes: use the exact column name \"employee_name\" instead of \"name\" for the name field. 3) When filtering for a specific employee name: use the exact literal value 'Armani' with proper case and spelling, not 'Armando'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, role_code, date_of_birth FROM employees WHERE name = 'Armando';",
            "SELECT Employee_Name, Role_Code, Date_of_Birth FROM Employees WHERE Employee_Name = 'Armani';"
        ],
        "rule_sql": [
            "SELECT employee_name, Role_Code, Date_of_Birth FROM Employees WHERE employee_name = 'Armani';"
        ]
    },
    "5110": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "What is the name of the most expensive product?",
        "ground_truth": "SELECT Product_Name FROM PRODUCTS ORDER BY Product_Price DESC LIMIT 1",
        "amends": [
            "Do reference `Product_Name` instead of `name` in the SELECT list. Do reference `Product_Price` instead of `price` in the ORDER BY clause. Do use `DESC` ordering instead of `ASC` ordering. The amended query now matches the intended behavior of selecting the product with the highest price rather than the lowest."
        ],
        "rules": [
            "1) When the question asks for \"name\" of a product: use the exact column token \"Product_Name\" from the Services table. 2) When ordering by price to find the most expensive product: use the exact column token \"Product_Price\" from the Services table and sort in descending order (highest to lowest). 3) When selecting the single most expensive product: take only the first row after sorting by \"Product_Price\" in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM products ORDER BY price ASC LIMIT 1;",
            "SELECT Product_Name FROM Products ORDER BY Product_Price DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Product_Name FROM Services ORDER BY Product_Price DESC LIMIT 1;"
        ]
    },
    "885": {
        "db_id": "chinook_1",
        "question": "What are the distinct unit prices of all tracks?",
        "ground_truth": "SELECT distinct(UnitPrice) FROM TRACK",
        "amends": [
            "Do use `distinct(UnitPrice)` instead of `unit_price` to ensure unique price values are returned. Do reference table `TRACK` instead of `tracks` to match the correct table name. Do add the DISTINCT keyword instead of omitting it to eliminate duplicate price entries. The amended query now correctly returns distinct unit prices from the TRACK table as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for \"distinct unit prices\": use the exact column token \"UnitPrice\" from the TRACK table to identify price values. 2) When eliminating duplicate values: apply the DISTINCT operation to ensure only unique \"UnitPrice\" values are returned. 3) When referencing the table containing track information: use the exact table name \"TRACK\" as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT unit_price FROM tracks",
            "SELECT DISTINCT UnitPrice FROM Track;"
        ],
        "rule_sql": [
            "SELECT DISTINCT UnitPrice FROM Track;"
        ]
    },
    "2447": {
        "db_id": "movie_1",
        "question": "What is the id of the reviewer named Daniel Lewis?",
        "ground_truth": "SELECT rID FROM Reviewer WHERE name  =  \"Daniel Lewis\"",
        "amends": [
            "Do reference the column as `rID` instead of `id` to match the correct column name. Do use double quotes `\"Daniel Lewis\"` instead of single quotes `'Daniel Lewis'` for the string literal. Do reference the table as `Reviewer` instead of `reviewers` to use the correct table name. The amended query now correctly retrieves the rID from the Reviewer table for the specified name."
        ],
        "rules": [
            "1) When the question asks for \"id\" of a reviewer: use the exact column name \"rID\" instead of \"id\" to match the schema. 2) When the question specifies a reviewer name \"Daniel Lewis\": use the exact string literal \"Daniel Lewis\" with double quotes. 3) When referencing the table containing reviewer information: use the exact table name \"Reviewer\" instead of \"reviewers\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM reviewers WHERE name = 'Daniel Lewis';",
            "SELECT rID FROM Reviewer WHERE name = \"Daniel Lewis\";"
        ],
        "rule_sql": [
            "SELECT rID FROM Reviewer WHERE name = \"Daniel Lewis\";"
        ]
    },
    "6319": {
        "db_id": "e_government",
        "question": "What are the names of organizations, ordered by the date they were formed, ascending?",
        "ground_truth": "SELECT organization_name FROM organizations ORDER BY date_formed ASC",
        "amends": [
            "Do select `organization_name` instead of `name` in the SELECT list. Do order by `date_formed` instead of `formed_date` and use `ASC` ordering instead of `DESC`. The amended query now correctly retrieves the organization_name column with ascending date ordering, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"names of organizations\": select the exact column \"organization_name\" from the Organizations table. 2) When ordering by \"date they were formed\": use the exact column \"date_formed\" for ordering. 3) When the question specifies \"ascending\" order: sort the results in ascending order (earliest dates first)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM organizations ORDER BY formed_date DESC;",
            "SELECT organization_name FROM Organizations ORDER BY date_formed ASC;"
        ],
        "rule_sql": [
            "SELECT organization_name FROM Organizations ORDER BY date_formed ASC;"
        ]
    },
    "2130": {
        "db_id": "cre_Doc_Control_Systems",
        "question": "For each document, list the number of employees who have showed up in the circulation history of that document. List the document ids and number of employees.",
        "ground_truth": "SELECT document_id ,  count(DISTINCT employee_id) FROM Circulation_History GROUP BY document_id;",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id, COUNT(*) as employee_count FROM circulation_history GROUP BY document_id;"
        ],
        "rule_sql": [
            "SELECT \n    ch.document_id,\n    COUNT(DISTINCT ch.employee_id) AS number_of_employees\nFROM \n    Circulation_History ch\nGROUP BY \n    ch.document_id\nORDER BY \n    ch.document_id;"
        ]
    },
    "4060": {
        "db_id": "student_1",
        "question": "Find all students taught by MARROTTE KIRK. Output first and last names of students.",
        "ground_truth": "SELECT T1.firstname ,  T1.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"MARROTTE\" AND T2.lastname  =  \"KIRK\"",
        "amends": [
            "Do use table alias `T1` and columns `firstname` and `lastname` instead of `s.first_name` and `s.last_name`. Do reference table `list AS T1` instead of `students s`. Do join on `T1.classroom = T2.classroom` instead of `s.teacher_id = t.teacher_id`. Do use table alias `T2` and filter on `T2.firstname = \"MARROTTE\"` and `T2.lastname = \"KIRK\"` instead of `t.first_name = 'MARROTTE'` and `t.last_name = 'KIRK'`. The amended query now correctly joins on classroom instead of teacher_id and matches the intended behavior."
        ],
        "rules": [
            "1) When answering about students taught by a specific teacher: use table alias T1 for the students table and T2 for the teachers table. 2) When joining students and teachers: link rows where T1.classroom = T2.classroom to find students in the same classroom as the teacher. 3) When filtering for teacher \"MARROTTE KIRK\": use exact conditions T2.firstname = \"MARROTTE\" and T2.lastname = \"KIRK\" with double quotes and exact case. 4) When outputting student names: use columns T1.firstname and T1.lastname (not first_name and last_name). 5) When combining tables: perform an inner match using classroom equality to keep only students who share a classroom with the specified teacher."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.first_name, s.last_name \nFROM students s \nJOIN teachers t ON s.teacher_id = t.teacher_id \nWHERE t.first_name = 'MARROTTE' AND t.last_name = 'KIRK';",
            "SELECT T1.FirstName, T1.LastName \nFROM list AS T1\nJOIN teachers AS T2 ON T1.Classroom = T2.Classroom\nWHERE T2.FirstName = 'MARROTTE' AND T2.LastName = 'KIRK'"
        ],
        "rule_sql": [
            "SELECT T1.FirstName, T1.LastName \nFROM list AS T1\nINNER JOIN teachers AS T2 ON T1.Classroom = T2.Classroom\nWHERE T2.FirstName = \"MARROTTE\" AND T2.LastName = \"KIRK\""
        ]
    },
    "381": {
        "db_id": "flight_1",
        "question": "How many flights do we have?",
        "ground_truth": "SELECT count(*) FROM Flight",
        "amends": [
            "Do reference the `Flight` table instead of the `passengers` table to count records from the correct data source. The amended query now matches RIGHT_SQL's behavior by querying the appropriate table for flight data."
        ],
        "rules": [
            "1) When counting flights: count records from the \"Flight\" table using its canonical key 2) When the question asks \"how many flights\": this means counting all records in the \"Flight\" table 3) When choosing which table to count from: use \"Flight\" table instead of \"passengers\" table as it contains flight data"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM passengers;",
            "SELECT COUNT(*) FROM flight;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM flight;"
        ]
    },
    "1446": {
        "db_id": "college_2",
        "question": "Find the name of the department which has the highest average salary of professors.",
        "ground_truth": "SELECT dept_name FROM instructor GROUP BY dept_name ORDER BY avg(salary) DESC LIMIT 1",
        "amends": [
            "Do use `dept_name` instead of `department_name` for the column name. Do add `GROUP BY dept_name` instead of omitting it to properly aggregate salaries by department. Do use `avg(salary)` instead of `AVG(salary)` for the aggregate function in the ORDER BY clause. Do move the aggregate function from the SELECT list to the ORDER BY clause instead of including it in the SELECT list. The amended query now correctly calculates average salary by department and returns the department with the highest average salary, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"department name\": use the exact column token \"dept_name\" from the schema instead of \"department_name\". 2) When the question asks for \"highest average salary of professors\": group by \"dept_name\" to compute average salary per department. 3) When ordering by average salary to find the highest: use \"avg(salary)\" in the ORDER BY clause instead of including it in the SELECT list. 4) When ranking departments by average salary: order by \"avg(salary)\" in descending direction and keep only the top result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department_name FROM departments ORDER BY AVG(salary) DESC LIMIT 1;",
            "SELECT dept_name FROM instructor GROUP BY dept_name ORDER BY avg(salary) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT dept_name FROM instructor GROUP BY dept_name ORDER BY AVG(salary) DESC LIMIT 1"
        ]
    },
    "415": {
        "db_id": "flight_1",
        "question": "Show aircraft names and number of flights for each aircraft.",
        "ground_truth": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid",
        "amends": [
            "Do reference `T2.name` instead of `aircraft_name` in the SELECT list. Do join `Flight AS T1` and `Aircraft AS T2` instead of querying only a single table. Do use the join condition `T1.aid = T2.aid` instead of missing the table relationship. Do group by `T1.aid` instead of `aircraft_id` to ensure proper aggregation alignment with the joined tables. The amended query now correctly counts flights per aircraft by establishing the proper relationship between Flight and Aircraft tables through their aid columns."
        ],
        "rules": [
            "1) When answering about \"aircraft names and number of flights for each aircraft\": make sure the output order: T2.name first, then count of flights. 2) When the question mentions \"aircraft names\": \"aircraft names\" actually means \"T2.name in schema\". 3) When combining T1 and T2 for shared entities: link rows where T1.aid = T2.aid exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"number of flights for each aircraft\": compute the count of flights using T1.aid as the counting key. 5) When the question says \"for each aircraft\": organize results by T1.aid and compute the count of flights per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT aircraft_name, COUNT(*) FROM flights GROUP BY aircraft_id;",
            "SELECT T2.name, COUNT(T1.flno) AS number_of_flights\nFROM flight AS T1\nJOIN aircraft AS T2 ON T1.aid = T2.aid\nGROUP BY T1.aid"
        ],
        "rule_sql": [
            "SELECT a.name, COUNT(f.flno) AS number_of_flights\nFROM aircraft a\nINNER JOIN flight f ON a.aid = f.aid\nGROUP BY a.aid, a.name\nORDER BY a.name, number_of_flights;"
        ]
    },
    "3196": {
        "db_id": "college_1",
        "question": "How many departments are in each school?",
        "ground_truth": "SELECT count(DISTINCT dept_name) ,  school_code FROM department GROUP BY school_code",
        "amends": [
            "Do select `count(DISTINCT dept_name)` and `school_code` instead of `school_name` and `COUNT(*)`. Do use `department` as the source table instead of `departments`. Do group by `school_code` instead of `school_id`. The amended query now correctly counts distinct department names per school code rather than counting all records per school name.",
            "Do move `school_code` to the SELECT list instead of keeping it in GROUP BY only, and do reorder the columns to place the aggregate function first instead of the grouping column. Do maintain the `COUNT(DISTINCT dept_name)` aggregation instead of changing it, and do preserve the `GROUP BY school_code` clause instead of modifying the grouping logic. The amended query now correctly includes both the aggregated count and grouping column in the SELECT list while maintaining the same distinct department count per school logic."
        ],
        "rules": [
            "1) When answering about \"how many departments are in each school\": make sure the output order: school_code, count of distinct departments\n2) When the question mentions \"departments\": \"departments\" actually means \"dept_name in department table\"\n3) When the question asks for \"count of departments\": compute the number of distinct values of dept_name\n4) When the question says \"per school\"/\"each school\": organize results by school_code and compute requested aggregates per group\n5) When using the department table: use the exact table name \"department\" not \"departments\"",
            "1) When answering about \"how many departments are in each school\": make sure the output order: COUNT(DISTINCT dept_name) first, then school_code. 2) When the question asks for \"count of departments per school\": compute the number of unique dept_name values grouped by school_code. 3) When producing output: include both the aggregated count and the grouping column school_code in the result set."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT school_name, COUNT(*) FROM departments GROUP BY school_id;",
            "SELECT SCHOOL_CODE, COUNT(DISTINCT DEPT_NAME) FROM DEPARTMENT GROUP BY SCHOOL_CODE;",
            "SELECT COUNT(DISTINCT dept_name), school_code FROM DEPARTMENT GROUP BY school_code"
        ],
        "rule_sql": [
            "SELECT school_code, COUNT(DISTINCT dept_name) AS department_count FROM department GROUP BY school_code ORDER BY department_count DESC, school_code;"
        ]
    },
    "1510": {
        "db_id": "insurance_and_eClaims",
        "question": "What are the type codes of the policies used by the customer \"Dayana Robel\"?",
        "ground_truth": "SELECT policy_type_code FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.customer_details  =  \"Dayana Robel\"",
        "amends": [
            "Do add `JOIN policies AS t1` on `t1.customer_id = t2.customer_id` instead of querying only the `customers` table. Do change the filter to `customer_details = \"Dayana Robel\"` instead of `customer_name = 'Dayana Robel'` and reference the joined table as `t2` instead of the base table. Do select from the `policies` table via the join instead of directly from `customers` to access the `policy_type_code` column. The amended query now correctly joins the tables and filters on the appropriate column to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"type codes of policies used by customer 'Dayana Robel'\": make sure the output order: policy_type_code. 2) When the question mentions \"customer 'Dayana Robel'\": \"customer 'Dayana Robel'\" actually means \"customer_details = 'Dayana Robel'\" in schema. 3) When combining customers and policies tables: link rows where t2.customer_id = t1.customer_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When selecting policy type codes: select policy_type_code from the policies table (t1) instead of from the customers table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT policy_type_code FROM customers WHERE customer_name = 'Dayana Robel';",
            "SELECT t1.Policy_Type_Code \nFROM Policies AS t1 \nJOIN Customers AS t2 ON t1.Customer_ID = t2.Customer_ID \nWHERE t2.Customer_Details = 'Dayana Robel'"
        ],
        "rule_sql": [
            "SELECT p.Policy_Type_Code \nFROM Policies p\nINNER JOIN Customers c ON p.Customer_ID = c.Customer_ID\nWHERE c.Customer_Details = 'Dayana Robel'\nORDER BY p.Policy_Type_Code"
        ]
    },
    "5379": {
        "db_id": "tracking_software_problems",
        "question": "What are the products that have problems reported after 1986-11-13? Give me the product id and the count of problems reported after 1986-11-13.",
        "ground_truth": "SELECT count(*) ,  T2.product_id FROM problems AS T1 JOIN product AS T2 ON T1.product_id = T2.product_id WHERE T1.date_problem_reported > \"1986-11-13\" GROUP BY T2.product_id",
        "amends": [
            "Do add `JOIN product AS T2 ON T1.product_id = T2.product_id` instead of querying only the `problems` table. Do reference `T2.product_id` in both SELECT and GROUP BY instead of `product_id` from the problems table. Do use `T1.date_problem_reported` in the WHERE filter instead of `reported_date`. Do change the column order in SELECT to `count(*) , T2.product_id` instead of `product_id, COUNT(*) as problem_count`. The amended query now correctly joins to the product table and uses the proper date column for filtering, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about products with problems reported after 1986-11-13: make sure to join the Problems table (T1) with the Product table (T2) using T1.product_id = T2.product_id. 2) When filtering for problems reported after 1986-11-13: use T1.date_problem_reported > '1986-11-13' instead of reported_date. 3) When selecting output columns: use the column order count(*) first, then T2.product_id. 4) When grouping results: group by T2.product_id instead of product_id from the Problems table. 5) When combining tables for this question: perform an inner join between Problems (T1) and Product (T2) where T1.product_id = T2.product_id."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT product_id, COUNT(*) as problem_count \nFROM problems \nWHERE reported_date > '1986-11-13' \nGROUP BY product_id",
            "SELECT COUNT(*) , T2.product_id\nFROM Problems AS T1\nJOIN Product AS T2 ON T1.product_id = T2.product_id\nWHERE T1.date_problem_reported > '1986-11-13'\nGROUP BY T2.product_id"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS problem_count, T2.product_id\nFROM Problems T1\nINNER JOIN Product T2 ON T1.product_id = T2.product_id\nWHERE T1.date_problem_reported > '1986-11-13'\nGROUP BY T2.product_id"
        ]
    },
    "1294": {
        "db_id": "soccer_1",
        "question": "How many leagues are there in England?",
        "ground_truth": "SELECT count(*) FROM Country AS T1 JOIN League AS T2 ON T1.id  =  T2.country_id WHERE T1.name  =  \"England\"",
        "amends": [
            "Do add `JOIN League AS T2 ON T1.id = T2.country_id` instead of querying only the `countries` table. Do use `Country AS T1` instead of `countries` as the table alias. Do specify `T1.name = \"England\"` instead of `name = 'England'` to qualify the column with the table alias. Do maintain `COUNT(*)` as the aggregate function instead of changing it. The amended query now correctly joins the Country and League tables to count leagues associated with England, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"leagues in England\": make sure to combine Country table (as T1) and League table (as T2) using the join condition T1.id = T2.country_id, keeping only matching pairs (inner match). 2) When the question mentions \"England\": \"England\" actually means T1.name = \"England\" in the schema. 3) When counting leagues: compute the number of rows using the canonical key from the League table after joining with Country table where T1.name = \"England\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE name = 'England';",
            "SELECT COUNT(*) \nFROM Country AS T1 \nJOIN League AS T2 ON T1.id = T2.country_id \nWHERE T1.name = \"England\""
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM League AS T2 \nINNER JOIN Country AS T1 ON T1.id = T2.country_id \nWHERE T1.name = 'England'"
        ]
    },
    "4988": {
        "db_id": "soccer_2",
        "question": "What is minimum hours of the students playing in different position?",
        "ground_truth": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos",
        "amends": [
            "Do select `min(T2.HS)` instead of `MAX(hours)` and use `T1.pPos` instead of `position` in the SELECT list. Do join tables `tryout AS T1` and `player AS T2` with an `INNER JOIN` on `T1.pID = T2.pID` instead of querying a single `students` table. Do group by `T1.pPos` instead of `position` and completely remove the incorrect alias `min_hours` from the aggregation. The amended query now correctly calculates minimum values from joined tables with proper table references and grouping.",
            "Do place `T1.pPos` after `min(T2.HS)` in the SELECT list instead of before it. Do use `JOIN` instead of `INNER JOIN` as they are functionally equivalent. Do maintain the same join condition `T1.pID = T2.pID` and GROUP BY clause `T1.pPos` without changes. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [
            "1) When answering about minimum hours of students playing in different positions: make sure the output order: T1.pPos, min(T2.HS) 2) When the question mentions \"position\": \"position\" actually means \"T1.pPos\" in schema 3) When the question mentions \"hours\": \"hours\" actually means \"T2.HS\" in schema 4) When combining T1 and T2 for shared entities: link rows where T1.pID = T2.pID exactly as shown in the amends; keep only matching pairs (inner match) 5) When grouping by position: organize results by T1.pPos and compute minimum hours per group 6) When computing minimum hours: use min(T2.HS) to find the smallest value of T2.HS for each position group",
            "1) When answering about \"minimum hours of students playing in different positions\": make sure the output order: min(T2.HS) first, then T1.pPos. 2) When combining Tryout table (T1) and Player table (T2): link rows where T1.pID = T2.pID and keep only matching pairs. 3) When grouping by position: organize results by T1.pPos and compute the minimum of T2.HS per group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT position, MAX(hours) as min_hours FROM students GROUP BY position;",
            "SELECT T1.pPos, min(T2.HS) FROM Tryout AS T1 INNER JOIN Player AS T2 ON T1.pID = T2.pID GROUP BY T1.pPos",
            "SELECT min(T2.HS), T1.pPos FROM Tryout AS T1 JOIN Player AS T2 ON T1.pID = T2.pID GROUP BY T1.pPos"
        ],
        "rule_sql": [
            "SELECT T1.pPos, min(T2.HS) \nFROM Tryout T1 \nINNER JOIN Player T2 ON T1.pID = T2.pID \nGROUP BY T1.pPos \nORDER BY min(T2.HS), T1.pPos"
        ]
    },
    "6542": {
        "db_id": "wine_1",
        "question": "What is the average price of wines produced in appelations in Sonoma County?",
        "ground_truth": "SELECT AVG(T2.Price) FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  \"Sonoma\"",
        "amends": [
            "Do join `APPELLATIONS AS T1` to `WINE AS T2` on `T1.Appelation = T2.Appelation` instead of querying `wines` directly without any joins. Do filter on `T1.County = \"Sonoma\"` instead of filtering directly on `appellation = 'Sonoma County'`. Do reference `T2.Price` with proper table alias instead of just `price`. Do use double quotes around \"Sonoma\" instead of single quotes around 'Sonoma County'. The amended query now correctly joins the appellations table to filter by county and calculate the average wine price for that region, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about average price of wines from Sonoma County appellations: join table APPELLATIONS as T1 to table WINE as T2 on T1.Appelation = T2.Appelation using inner match. 2) When filtering for Sonoma County: use T1.County = \"Sonoma\" instead of appellation = 'Sonoma County'. 3) When calculating average price: reference T2.Price with proper table alias instead of just price. 4) When using string literals for Sonoma: use double quotes around \"Sonoma\" instead of single quotes around 'Sonoma County'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(price) FROM wines WHERE appellation = 'Sonoma County';",
            "SELECT AVG(T2.Price) AS average_price FROM appellations AS T1 JOIN wine AS T2 ON T1.Appelation = T2.Appelation WHERE T1.County = \"Sonoma\""
        ],
        "rule_sql": [
            "SELECT AVG(T2.Price) AS average_price FROM appellations AS T1 INNER JOIN wine AS T2 ON T1.Appelation = T2.Appelation WHERE T1.County = \"Sonoma\""
        ]
    },
    "1519": {
        "db_id": "insurance_and_eClaims",
        "question": "What is the name of the customer who has made the largest amount of claim in a single claim?",
        "ground_truth": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)",
        "amends": [
            "Do select `t3.customer_details` instead of `customer_name` from a different table. Do join `claim_headers AS t1` and `policies AS t2` on `t1.policy_id = t2.policy_id` instead of querying only the `customers` table. Do add a second join to `customers AS t3` on `t2.customer_id = t3.customer_id` instead of directly accessing the customers table. Do add a WHERE filter comparing `t1.amount_claimed` to a subquery finding `max(amount_claimed)` instead of using ORDER BY and LIMIT. Do remove the ORDER BY and LIMIT clauses instead of keeping them, as the maximum value is now found through the subquery comparison. The amended query now correctly identifies the customer with the highest claim amount by properly joining through the policy relationship and using a subquery to find the maximum claim value."
        ],
        "rules": [
            "1) When answering about \"the customer who has made the largest amount of claim in a single claim\": make sure the output order: t3.customer_details. 2) When combining claim_headers AS t1 and policies AS t2: link rows where t1.policy_id = t2.policy_id and keep only matching pairs (inner match). 3) When combining the result with customers AS t3: link rows where t2.customer_id = t3.customer_id and keep only matching pairs (inner match). 4) When finding the largest amount of claim: compare t1.amount_claimed to the maximum value from all claims using max(amount_claimed) in a subquery instead of using ORDER BY and LIMIT. 5) When the question asks for the customer with the maximum claim amount: filter to only include rows where t1.amount_claimed equals the maximum claim amount found in the subquery."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT customer_name FROM customers ORDER BY claim_amount DESC LIMIT 1;",
            "SELECT t3.Customer_Details\nFROM Claim_Headers AS t1\nJOIN Policies AS t2 ON t1.Policy_ID = t2.Policy_ID\nJOIN Customers AS t3 ON t2.Customer_ID = t3.Customer_ID\nWHERE t1.Amount_Claimed = (SELECT MAX(Amount_Claimed) FROM Claim_Headers)"
        ],
        "rule_sql": [
            "SELECT t3.Customer_Details\nFROM Claim_Headers AS t1\nINNER JOIN Policies AS t2 ON t1.Policy_ID = t2.Policy_ID\nINNER JOIN Customers AS t3 ON t2.Customer_ID = t3.Customer_ID\nWHERE t1.Amount_Claimed = (SELECT MAX(Amount_Claimed) FROM Claim_Headers)"
        ]
    },
    "2405": {
        "db_id": "candidate_poll",
        "question": "Return the poll source corresponding to the candidate who has the oppose rate.",
        "ground_truth": "SELECT poll_source FROM candidate ORDER BY oppose_rate DESC LIMIT 1",
        "amends": [
            "Do reference table `candidate` instead of `candidates` in the FROM clause, as the correct table name is singular rather than plural. The amended query now correctly selects from the intended table while preserving the same column selection, ordering by oppose_rate in descending order, and limiting to one result, matching the behavior of the right SQL."
        ],
        "rules": [
            "1) When the question asks for \"poll source\" from a candidate: use the exact column token \"poll_source\" from table \"candidate\". 2) When the question asks about the candidate with the highest oppose rate: order rows by \"oppose_rate\" in descending order and keep only the first row. 3) When referring to the candidate table: use the exact table name \"candidate\" (singular) rather than \"candidates\" (plural)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT poll_source FROM candidates ORDER BY oppose_rate DESC LIMIT 1;",
            "SELECT Poll_Source FROM candidate ORDER BY Oppose_rate DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT poll_source FROM candidate ORDER BY oppose_rate DESC LIMIT 1;"
        ]
    },
    "2869": {
        "db_id": "icfp_1",
        "question": "How many papers are \"Atsushi Ohori\" the author of?",
        "ground_truth": "SELECT count(*) FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid WHERE  t1.fname  =  \"Atsushi\" AND t1.lname  =  \"Ohori\"",
        "amends": [
            "Do join `authors AS t1` and `authorship AS t2` on `t1.authid = t2.authid` instead of querying only the `papers` table. Do join `papers AS t3` on `t2.paperid = t3.paperid` instead of directly filtering by author name. Do filter by `t1.fname = \"Atsushi\" AND t1.lname = \"Ohori\"` instead of using `author = 'Atsushi Ohori'` which assumes a combined name column. Do count papers through the authorship relationship instead of counting papers directly with an incorrect author filter. The amended query now correctly counts papers by joining through the proper author-to-paper relationship structure."
        ],
        "rules": [
            "1) When the question asks about papers by a specific author: join authors AS T1 and authorship AS T2 on T1.authid = T2.authid to establish the author-paper relationship. 2) When joining papers to authorship: join papers AS T3 on T2.paperid = T3.paperid to access paper information. 3) When filtering by author name \"Atsushi Ohori\": use T1.fname = \"Atsushi\" AND T1.lname = \"Ohori\" instead of assuming a combined name column. 4) When counting papers by an author: count through the authorship relationship using the paperid from the joined tables rather than directly from papers table with incorrect filters."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM papers WHERE author = 'Atsushi Ohori';",
            "SELECT COUNT(DISTINCT t3.paperID) \nFROM Authors AS t1\nJOIN Authorship AS t2 ON t1.authID = t2.authID\nJOIN Papers AS t3 ON t2.paperID = t3.paperID\nWHERE t1.fname = 'Atsushi' AND t1.lname = 'Ohori'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T2.paperID) \nFROM Authors AS T1 \nJOIN Authorship AS T2 ON T1.authID = T2.authID \nWHERE T1.fname = 'Atsushi' AND T1.lname = 'Ohori'"
        ]
    },
    "4190": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "List all role codes, role names, and role descriptions.",
        "ground_truth": "SELECT role_code ,  role_name ,  role_description FROM ROLES",
        "amends": [
            "Do add `role_description` to the SELECT list instead of omitting it, and do use the table name `ROLES` instead of `roles` to match the correct case sensitivity. The amended query now includes all required columns and uses the proper table reference, matching the intended behavior of retrieving the complete role information."
        ],
        "rules": [
            "1) When the question asks for \"role codes, role names, and role descriptions\": include all three columns \"role_code\", \"role_name\", and \"role_description\" in the output. 2) When referring to the roles table: use the exact table name \"ROLES\" with uppercase letters to match the schema's case sensitivity requirements."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT role_code, role_name FROM roles;",
            "SELECT Role_Code, Role_Name, Role_Description FROM Roles;"
        ],
        "rule_sql": [
            "SELECT Role_Code, Role_Name, Role_Description FROM ROLES;"
        ]
    },
    "5082": {
        "db_id": "device",
        "question": "List the names of shops that have no devices in stock.",
        "ground_truth": "SELECT Shop_Name FROM shop WHERE Shop_ID NOT IN (SELECT Shop_ID FROM stock)",
        "amends": [
            "Do select `Shop_Name` instead of `name` and use table `shop` instead of `shops`. Do remove the `device_count > 0` filter instead of keeping it and instead add a `NOT IN` subquery condition checking for `Shop_ID` values that do not exist in the `stock` table. Do change the WHERE clause to use `Shop_ID NOT IN (SELECT Shop_ID FROM stock)` instead of the previous filter on device count. The amended query now correctly identifies shops without any stock items rather than shops with positive device counts, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for shop names: use the exact column token \"Shop_Name\" from table \"shop\" instead of \"name\". 2) When identifying shops with no devices in stock: use a NOT IN condition where \"Shop_ID\" values from table \"shop\" are not found in the \"Shop_ID\" column of table \"stock\". 3) When combining shop and stock tables: use \"Shop_ID\" as the linking key between \"shop\" and \"stock\" tables to identify shops without matching stock entries."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM shops WHERE device_count > 0;",
            "SELECT Shop_Name FROM shop WHERE Shop_ID NOT IN (SELECT Shop_ID FROM stock)"
        ],
        "rule_sql": [
            "SELECT Shop_Name FROM shop WHERE Shop_ID NOT IN (SELECT Shop_ID FROM stock)"
        ]
    },
    "1066": {
        "db_id": "match_season",
        "question": "How many distinct teams are involved in match seasons?",
        "ground_truth": "SELECT count(DISTINCT Team) FROM match_season",
        "amends": [
            "Do count `DISTINCT Team` instead of `COUNT(*)` to count unique teams rather than total matches. Do use table `match_season` instead of `matches` to access the correct data source. Do remove `GROUP BY season` instead of keeping it since the aggregation now operates across all seasons. The amended query now correctly counts distinct teams from the match_season table rather than counting total matches grouped by season."
        ],
        "rules": [
            "1) When answering about \"distinct teams\": count the number of unique values of the exact token \"Team\" from the table. 2) When the question mentions \"match seasons\": use the table \"match_season\" as the data source instead of \"matches\". 3) When counting distinct entities across all data: do not group by any columns and compute the count across all rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches GROUP BY season;",
            "SELECT COUNT(DISTINCT Team) FROM match_season"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Team) FROM match_season;"
        ]
    },
    "6938": {
        "db_id": "tracking_orders",
        "question": "Which customers have made at least two orders? Give me each customer name and number of orders made.",
        "ground_truth": "SELECT T2.customer_name ,  count(*) FROM orders AS T1 JOIN customers AS T2 ON T1.customer_id = T2.customer_id GROUP BY T2.customer_id HAVING count(*)  >=  2",
        "amends": [
            "Do add `customers` table with `JOIN` on `T1.customer_id = T2.customer_id` instead of omitting it. Do reference `T2.customer_name` instead of `customer_name` directly. Do use `GROUP BY T2.customer_id` instead of `GROUP BY customer_name`. Do move the count filter to `HAVING count(*) >= 2` instead of `WHERE order_count >= 2`. Do remove the alias `order_count` instead of keeping it. The amended query now correctly joins customer data and uses proper grouping and filtering to match the intended behavior."
        ],
        "rules": [
            "1) When answering about customers and their orders: combine data from both Customers and Orders tables using T1.customer_id = T2.customer_id to link matching customer records. 2) When counting orders per customer: use T2.customer_id as the grouping key instead of customer_name to ensure accurate counting. 3) When filtering for customers with at least two orders: apply the count filter after grouping using HAVING count(*) >= 2 instead of WHERE. 4) When selecting customer names: reference T2.customer_name from the Customers table rather than using customer_name directly. 5) When producing output: show customer_name and the count of orders without using an alias for the count."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT customer_name, COUNT(*) as order_count FROM orders GROUP BY customer_name WHERE order_count >= 2;",
            "SELECT T2.customer_name, COUNT(*) \nFROM Orders T1 \nJOIN Customers T2 ON T1.customer_id = T2.customer_id \nGROUP BY T2.customer_id \nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT c.customer_name, COUNT(*) \nFROM Customers c\nJOIN Orders o ON c.customer_id = o.customer_id\nGROUP BY o.customer_id\nHAVING COUNT(*) >= 2"
        ]
    },
    "6807": {
        "db_id": "flight_4",
        "question": "How many airlines are there?",
        "ground_truth": "SELECT count(*) FROM airlines",
        "amends": [
            "Do query the `airlines` table instead of the `airports` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the airlines table instead of airports, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"airlines\": query the \"airlines\" table instead of the \"airports\" table. 2) When counting records: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" for consistency."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM airports;",
            "SELECT count(*) FROM airlines;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM airlines;"
        ]
    },
    "4958": {
        "db_id": "soccer_2",
        "question": "How many different colleges do attend the tryout test?",
        "ground_truth": "SELECT count(DISTINCT cName) FROM tryout",
        "amends": [
            "Do `count(DISTINCT cName)` instead of `COUNT(*)` to count distinct values of a specific column rather than all rows. Do use table `tryout` instead of `tryout_test` to query from the correct data source. The amended query now correctly counts distinct cName values from the tryout table instead of counting all rows from the wrong table."
        ],
        "rules": [
            "1) When the question asks for \"different colleges\": count distinct values of the exact column \"cName\" from the tryout table. 2) When choosing the data source: use table \"tryout\" instead of \"tryout_test\" to query from the correct table. 3) When counting distinct entities: use count(DISTINCT \"cName\") instead of COUNT(*) to count unique college names rather than all rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM tryout_test",
            "SELECT COUNT(DISTINCT cName) FROM Tryout;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT cName) FROM Tryout;"
        ]
    },
    "1176": {
        "db_id": "election_representative",
        "question": "List the dates and vote percents of elections.",
        "ground_truth": "SELECT Date ,  Vote_Percent FROM election",
        "amends": [
            "Do use the correct table name `election` instead of the incorrect pluralized `elections`. Do use the correct column names `Date` and `Vote_Percent` with proper capitalization instead of the lowercase `election_date` and `vote_percent`. Do remove the incorrect `WHERE vote_percent > 100` filter instead of keeping it, as vote percentages cannot logically exceed 100%. The amended query now correctly selects all records from the election table without the invalid filter condition, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"dates and vote percents of elections\": use the exact column names \"Date\" and \"Vote_Percent\" from table \"election\". 2) When the question mentions \"elections\": the correct table name is \"election\" (singular), not \"elections\" (plural). 3) When selecting all election records: do not apply any filter conditions, especially not vote_percent > 100 since vote percentages cannot logically exceed 100%."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT election_date, vote_percent FROM elections WHERE vote_percent > 100;",
            "SELECT Date, Vote_Percent FROM election;"
        ],
        "rule_sql": [
            "SELECT Date, Vote_Percent FROM election;"
        ]
    },
    "2170": {
        "db_id": "formula_1",
        "question": "What is the id, first name, and last name of the driver who was in the first position for laptime at least twice?",
        "ground_truth": "SELECT T1.driverid ,  T1.forename ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid WHERE POSITION  =  '1' GROUP BY T1.driverid HAVING count(*)  >=  2",
        "amends": [
            "Do add `JOIN laptimes AS T2 ON T1.driverid = T2.driverid` instead of omitting the table join entirely. Do use table aliases `T1` and `T2` instead of no aliases. Do reference columns as `T1.driverid`, `T1.forename`, and `T1.surname` instead of `driver_id`, `first_name`, and `last_name`. Do use string literal `'1'` instead of numeric `1` in the `WHERE POSITION =` condition. The amended query now correctly joins the laptimes table to count positions and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about driver information and laptime positions: make sure to join the laptimes table (T2) to the drivers table (T1) using T1.driverid = T2.driverid. 2) When the question mentions \"first position\": use the exact string literal '1' instead of numeric 1 for position comparison. 3) When the question asks for \"driver who was in the first position at least twice\": count occurrences where T2.position equals '1' per driver using T1.driverid as the counting key. 4) When selecting driver information: use the exact column tokens T1.driverid, T1.forename, and T1.surname instead of driver_id, first_name, and last_name. 5) When grouping results: organize by T1.driverid and keep only drivers with at least 2 occurrences of position '1'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT driver_id, first_name, last_name \nFROM drivers \nWHERE position = 1 \nGROUP BY driver_id \nHAVING COUNT(*) >= 2;",
            "SELECT T1.driverId, T1.forename, T1.surname\nFROM drivers AS T1\nJOIN laptimes AS T2 ON T1.driverId = T2.driverId\nWHERE T2.position = '1'\nGROUP BY T1.driverId, T1.forename, T1.surname\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T1.driverId, T1.forename, T1.surname\nFROM drivers T1\nJOIN lapTimes T2 ON T1.driverId = T2.driverId\nWHERE T2.position = '1'\nGROUP BY T1.driverId\nHAVING COUNT(*) >= 2"
        ]
    },
    "1789": {
        "db_id": "small_bank_1",
        "question": "Find the balance of the checking account belonging to an owner whose name contains 'ee'.",
        "ground_truth": "SELECT T2.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid WHERE T1.name LIKE '%ee%'",
        "amends": [
            "Do select `T2.balance` from the `checking` table instead of `balance` from the `accounts` table. Do join `checking AS T2` on `T1.custid = T2.custid` instead of querying only the `accounts` table. Do filter on `T1.name LIKE '%ee%'` instead of filtering on both `account_type = 'savings'` and `owner_name LIKE '%ee%'`. Do remove the `account_type` filter condition instead of including it. The amended query now correctly retrieves balance information from the checking table for customers with names containing 'ee', matching the intended behavior."
        ],
        "rules": [
            "1) When answering about checking account balance: select \"T2.balance\" from the \"checking\" table instead of \"balance\" from \"accounts\" table. 2) When combining customer and checking account information: link rows where \"T1.custid = T2.custid\" and keep only matching pairs (inner match). 3) When filtering for owners whose name contains 'ee': use \"T1.name LIKE '%ee%'\" exactly as specified, preserving the exact literal pattern. 4) When the question specifies checking accounts: do not include any filter condition for account_type or savings accounts."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT balance FROM accounts WHERE account_type = 'savings' AND owner_name LIKE '%ee%'",
            "SELECT T2.balance \nFROM ACCOUNTS AS T1\nJOIN CHECKING AS T2 ON T1.custid = T2.custid\nWHERE T1.name LIKE '%ee%'"
        ],
        "rule_sql": [
            "SELECT T2.balance \nFROM ACCOUNTS T1\nINNER JOIN CHECKING T2 ON T1.custid = T2.custid\nWHERE T1.name LIKE '%ee%'"
        ]
    },
    "1874": {
        "db_id": "wrestler",
        "question": "List the locations that are shared by more than two wrestlers.",
        "ground_truth": "SELECT LOCATION FROM wrestler GROUP BY LOCATION HAVING COUNT(*)  >  2",
        "amends": [
            "Do use table name `wrestler` instead of `wrestlers` in the FROM clause. Do change the HAVING condition to `COUNT(*) > 2` instead of `COUNT(*) > 1` to filter for locations with more than two wrestlers rather than more than one. The amended query now correctly identifies locations with multiple wrestlers using the specified threshold and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When using the table for wrestler data: use the exact table name \"wrestler\" instead of \"wrestlers\". 2) When counting wrestlers per location to find locations with more than two wrestlers: use the condition COUNT(*) > 2 instead of COUNT(*) > 1. 3) When answering about locations shared by more than two wrestlers: make sure the output order is location."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location FROM wrestlers GROUP BY location HAVING COUNT(*) > 1",
            "SELECT Location FROM wrestler GROUP BY Location HAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT Location FROM wrestler GROUP BY Location HAVING COUNT(*) > 2 ORDER BY Location;"
        ]
    },
    "1650": {
        "db_id": "theme_gallery",
        "question": "Count the number of artists.",
        "ground_truth": "SELECT count(*) FROM artist",
        "amends": [
            "Do query the `artist` table instead of the `songs` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the artist table rather than the songs table, matching the intended behavior."
        ],
        "rules": [
            "1) When counting the number of artists: query the \"artist\" table instead of the \"songs\" table. 2) When counting records: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" for consistency."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM songs;",
            "SELECT count(*) FROM artist;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM artist;"
        ]
    },
    "4760": {
        "db_id": "department_store",
        "question": "What are the names and genders of staff who were assigned in 2016?",
        "ground_truth": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE \"2016%\"",
        "amends": [
            "Do specify `T1.staff_name` and `T1.staff_gender` with table aliases instead of `name` and `gender` without qualification. Do add `staff_department_assignments AS T2` as a joined table instead of querying only the `staff` table. Do use `JOIN` with `ON T1.staff_id = T2.staff_id` instead of no join condition. Do change the filter to `T2.date_assigned_from LIKE \"2016%\"` on the joined table instead of `assigned_year = 2016` on the main table. The amended query now correctly retrieves staff information based on department assignment dates rather than a non-existent year column, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about staff names and genders: make sure the output order: T1.staff_name, T1.staff_gender\n2) When the question mentions \"assigned in 2016\": use T2.date_assigned_from LIKE \"2016%\" instead of assigned_year = 2016\n3) When combining staff and staff_department_assignments tables: link rows where T1.staff_id = T2.staff_id and keep only matching pairs (inner match)\n4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms\n5) When handling text literals: do not change case, spacing, or punctuation of \"2016%\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, gender FROM staff WHERE assigned_year = 2016;",
            "SELECT T1.staff_name, T1.staff_gender \nFROM Staff AS T1\nJOIN Staff_Department_Assignments AS T2 ON T1.staff_id = T2.staff_id\nWHERE T2.date_assigned_from LIKE '2016%'"
        ],
        "rule_sql": [
            "SELECT T1.staff_name, T1.staff_gender\nFROM Staff AS T1\nINNER JOIN Staff_Department_Assignments AS T2 ON T1.staff_id = T2.staff_id\nWHERE T2.date_assigned_from LIKE \"2016%\""
        ]
    },
    "6155": {
        "db_id": "music_4",
        "question": "What are the category of music festivals with result \"Awarded\"?",
        "ground_truth": "SELECT Category FROM music_festival WHERE RESULT  =  \"Awarded\"",
        "amends": [
            "Do reference table `music_festival` instead of `music_festivals` to use the correct table name. Do use column `Category` instead of `category` to match the proper column casing. Do use column `RESULT` instead of `result` to maintain consistent uppercase column naming. Do use double quotes `\"Awarded\"` instead of single quotes `'Awarded'` for string literal formatting. The amended query now correctly selects from the proper table with consistent column naming conventions."
        ],
        "rules": [
            "1) When answering about \"category of music festivals with result 'Awarded'\": make sure the output order: Category. 2) When the question mentions \"music festivals\": \"music festivals\" actually means \"music_festival\" in schema. 3) When the question mentions \"category\": \"category\" actually means \"Category\" in schema. 4) When the question mentions \"result\": \"result\" actually means \"RESULT\" in schema. 5) When filtering for result value \"Awarded\": use the exact literal \"Awarded\" with double quotes. 6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT category FROM music_festivals WHERE result = 'Awarded';",
            "SELECT Category FROM music_festival WHERE RESULT = \"Awarded\";"
        ],
        "rule_sql": [
            "SELECT \"Category\" FROM \"music_festival\" WHERE \"Result\" = \"Awarded\""
        ]
    },
    "2204": {
        "db_id": "formula_1",
        "question": "What are the names of all races held between 2009 and 2011?",
        "ground_truth": "SELECT name FROM races WHERE YEAR BETWEEN 2009 AND 2011",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM races WHERE year BETWEEN 2009 AND 2011;"
        ],
        "rule_sql": [
            "SELECT name FROM races WHERE year BETWEEN 2009 AND 2011 ORDER BY year, round;"
        ]
    },
    "2085": {
        "db_id": "pilot_record",
        "question": "What are the positions and teams of pilots?",
        "ground_truth": "SELECT POSITION ,  Team FROM pilot",
        "amends": [
            "Do select `POSITION` and `Team` columns instead of `name` and `team`. Do reference table `pilot` instead of `drivers`. The amended query now correctly retrieves position and team information from the pilot table."
        ],
        "rules": [
            "1) When answering about \"positions and teams of pilots\": make sure the output order: POSITION, Team. 2) When the question mentions \"pilots\": \"pilots\" actually means table \"pilot\" in schema. 3) When the question mentions \"positions\": \"positions\" actually means column \"POSITION\" in table \"pilot\". 4) When the question mentions \"teams\": \"teams\" actually means column \"Team\" in table \"pilot\". 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for identifiers like \"Team\" and \"POSITION\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, team FROM drivers;",
            "SELECT Position, Team FROM pilot;"
        ],
        "rule_sql": [
            "SELECT \"POSITION\", \"Team\" FROM \"pilot\";"
        ]
    },
    "6055": {
        "db_id": "customers_and_addresses",
        "question": "Find the name of all customers.",
        "ground_truth": "SELECT customer_name FROM customers",
        "amends": [
            "Do select only `customer_name` instead of selecting all columns with `*`. Do change the source table to `customers` instead of `orders`. The amended query now correctly retrieves customer names from the customers table rather than all data from the orders table."
        ],
        "rules": [
            "1) When answering about \"customer names\": make sure the output order: customer_name. 2) When the question asks for \"name of all customers\": select from the \"customers\" table instead of \"orders\". 3) When selecting columns: use only \"customer_name\" instead of selecting all columns with \"*\". 4) When referring to table roles: use the exact table name \"customers\" as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM orders;",
            "SELECT customer_name FROM Customers;"
        ],
        "rule_sql": [
            "SELECT customer_name FROM Customers;"
        ]
    },
    "4919": {
        "db_id": "store_product",
        "question": "What are the names of all the stores in the largest district by population?",
        "ground_truth": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id WHERE district_id  =  (SELECT district_id FROM district ORDER BY city_population DESC LIMIT 1)",
        "amends": [
            "Do select `t1.store_name` instead of `name` and add a `JOIN` with `store_district AS t2` on `t1.store_id = t2.store_id` instead of querying only the `stores` table. Do add a `WHERE` filter for `district_id` equal to a subquery result instead of ordering by `district_population`. Do use a subquery that selects `district_id` ordered by `city_population DESC` with `LIMIT 1` instead of directly ordering the main query by population. Do remove the `ORDER BY` and `LIMIT` from the main query instead of keeping them, as the limiting is now handled in the subquery. The amended query now correctly finds the store in the district with the highest city population instead of simply the store with the highest district population."
        ],
        "rules": [
            "1) When answering about \"names of all stores in the largest district by population\": make sure the output order: t1.store_name. 2) When the question mentions \"stores\": \"stores\" actually means \"t1.store_name in schema\". 3) When combining stores and store_district tables: link rows where t1.store_id = t2.store_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"largest district by population\": find the district with the highest city_population by selecting district_id ordered by t2.city_population DESC with LIMIT 1 in a subquery. 5) When filtering for the largest district: use WHERE district_id equal to the subquery result instead of ordering the main query by population. 6) When the question implies ordering ties: break ties using the canonical key if shown in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM stores ORDER BY district_population DESC LIMIT 1;",
            "SELECT t1.Store_Name\nFROM store AS t1\nJOIN store_district AS t2 ON t1.Store_ID = t2.Store_ID\nWHERE t2.District_ID = (\n    SELECT District_ID\n    FROM district\n    ORDER BY City_Population DESC\n    LIMIT 1\n)"
        ],
        "rule_sql": [
            "SELECT t1.Store_Name\nFROM store t1\nINNER JOIN store_district t2 ON t1.Store_ID = t2.Store_ID\nWHERE t2.District_ID = (\n    SELECT District_ID\n    FROM district\n    ORDER BY City_Population DESC\n    LIMIT 1\n)\nORDER BY t1.Store_Name;"
        ]
    },
    "3714": {
        "db_id": "mountain_photos",
        "question": "What are the maximum and average height of the mountains?",
        "ground_truth": "SELECT max(height) ,  avg(height) FROM mountain",
        "amends": [
            "Do use `max(height)` instead of `MIN(height)` for the maximum height calculation. Do reference table `mountain` instead of `mountains` as the data source. The amended query now correctly calculates the maximum and average heights from the appropriate table."
        ],
        "rules": [
            "1) When calculating maximum height: use max(height) instead of MIN(height) for the maximum height calculation. 2) When referencing the data source: use table mountain instead of mountains as the appropriate table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(height), AVG(height) FROM mountains;",
            "SELECT MAX(Height) AS max_height, AVG(Height) AS avg_height FROM mountain;"
        ],
        "rule_sql": [
            "SELECT MAX(Height) AS max_height, AVG(Height) AS avg_height FROM mountain;"
        ]
    },
    "3170": {
        "db_id": "station_weather",
        "question": "Find the id and local authority of the station whose maximum precipitation is higher than 50.",
        "ground_truth": "SELECT t2.id ,  t2.local_authority FROM weekly_weather AS t1 JOIN station AS t2 ON t1.station_id  =  t2.id GROUP BY t1.station_id HAVING max(t1.precipitation)  >  50",
        "amends": [
            "Do select `t2.id` and `t2.local_authority` from the joined tables instead of selecting `id` and `local_authority` directly from a single table. Do use `FROM weekly_weather AS t1 JOIN station AS t2 ON t1.station_id = t2.id` instead of `FROM stations` alone, adding the join relationship between weather and station data. Do move the precipitation filter to `HAVING max(t1.precipitation) > 50` instead of `WHERE precipitation > 50` to apply the condition after aggregation. Do add `GROUP BY t1.station_id` instead of omitting grouping, which enables the use of the aggregate function. The amended query now correctly aggregates precipitation data by station and filters for maximum precipitation values exceeding 50, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about stations and their precipitation data: combine table weekly_weather as T1 with table station as T2 using the exact join condition T1.station_id = T2.id to link weather measurements to station information. 2) When the question asks for maximum precipitation higher than 50: compute the maximum precipitation value per station using max(T1.precipitation) and filter for stations where this maximum exceeds 50. 3) When grouping weather data by station: organize the results by T1.station_id to enable aggregation of precipitation values per station. 4) When selecting output columns: return T2.id and T2.local_authority from the joined tables, not from a single table directly."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, local_authority FROM stations WHERE precipitation > 50;",
            "SELECT t2.id, t2.local_authority FROM weekly_weather AS t1 JOIN station AS t2 ON t1.station_id = t2.id GROUP BY t1.station_id HAVING max(t1.precipitation) > 50"
        ],
        "rule_sql": [
            "SELECT T2.id, T2.local_authority\nFROM weekly_weather AS T1\nJOIN station AS T2 ON T1.station_id = T2.id\nGROUP BY T1.station_id\nHAVING MAX(T1.precipitation) > 50"
        ]
    },
    "895": {
        "db_id": "insurance_fnol",
        "question": "Which policy type has the most records in the database?",
        "ground_truth": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `policy_type_code` from the `available_policies` table instead of `policy_type` from the `policies` table. Do group by `policy_type_code` instead of `policy_type`. The amended query now correctly retrieves the most frequent policy type code from the available_policies table.",
            "Do remove the `COUNT(*) as record_count` column from the SELECT list instead of including it, and do reference the aggregate function directly in the ORDER BY clause as `count(*)` instead of using the column alias `record_count`. Do use lowercase table name `available_policies` instead of mixed case `Available_Policies` for consistency. The amended query now correctly returns only the policy_type_code with the highest count while maintaining the same result behavior."
        ],
        "rules": [
            "1) When answering about \"policy type\": use \"policy_type_code\" from the \"available_policies\" table instead of \"policy_type\" from the \"policies\" table. 2) When counting records by policy type: group by \"policy_type_code\" to organize results by each distinct policy type code. 3) When finding the policy type with the most records: rank the groups by count in descending order and keep only the top result.",
            "1) When counting records in the database: use count(*) to compute the total number of rows. 2) When grouping by policy_type_code: organize results by the exact token \"policy_type_code\" and compute aggregates per group. 3) When finding the policy type with the most records: rank groups by count(*) in descending order and keep only the first row. 4) When referencing the available_policies table: use the exact lowercase token \"available_policies\" instead of mixed case variations. 5) When ordering by aggregate results: reference the aggregate function count(*) directly in the order by clause instead of using column aliases. 6) When outputting results for policy type counts: include only the policy_type_code column in the final output, not the count column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT policy_type, COUNT(*) FROM policies GROUP BY policy_type ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT policy_type_code, COUNT(*) as record_count\nFROM Available_Policies\nGROUP BY policy_type_code\nORDER BY record_count DESC\nLIMIT 1;",
            "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "6876": {
        "db_id": "flight_4",
        "question": "How many routes go from the United States to Canada?",
        "ground_truth": "SELECT count(*) FROM routes WHERE dst_apid IN (SELECT apid FROM airports WHERE country  =  'Canada') AND src_apid IN (SELECT apid FROM airports WHERE country  =  'United States')",
        "amends": [
            "Do use subqueries to filter routes based on airport country codes instead of directly comparing origin_country and destination_country columns. Do filter routes where `dst_apid` is in airports with country 'Canada' instead of using `destination_country = 'Canada'`. Do filter routes where `src_apid` is in airports with country 'United States' instead of using `origin_country = 'United States'`. Do remove the direct country column references from the routes table instead of keeping them. The amended query now correctly joins through the airports table to validate country information, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about routes from \"United States\" to \"Canada\": use the airports table to validate country information instead of direct country column references in the routes table. 2) When filtering for routes originating from \"United States\": find routes where src_apid corresponds to airports with country 'United States'. 3) When filtering for routes destined for \"Canada\": find routes where dst_apid corresponds to airports with country 'Canada'. 4) When counting routes between countries: count the number of route records that satisfy both origin and destination country conditions through airport table joins."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM routes WHERE origin_country = 'United States' AND destination_country = 'Canada';",
            "SELECT COUNT(*) \nFROM routes r\nJOIN airports src_ap ON r.src_apid = src_ap.apid\nJOIN airports dst_ap ON r.dst_apid = dst_ap.apid\nWHERE src_ap.country = 'United States' AND dst_ap.country = 'Canada';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM routes r\nJOIN airports src_ap ON r.src_apid = src_ap.apid\nJOIN airports dst_ap ON r.dst_apid = dst_ap.apid\nWHERE src_ap.country = 'United States' \nAND dst_ap.country = 'Canada';"
        ]
    },
    "2441": {
        "db_id": "movie_1",
        "question": "Who directed Avatar?",
        "ground_truth": "SELECT director FROM Movie WHERE title  = 'Avatar'",
        "amends": [
            "Do select `director` instead of `actor_name` from the source table. Do reference table `Movie` instead of `movies` in the FROM clause while keeping the same WHERE filter condition `title = 'Avatar'`. The amended query now correctly retrieves the director information from the appropriate table structure."
        ],
        "rules": [
            "1) When the question asks about \"who directed\": select the exact column \"director\" from the appropriate table. 2) When the question mentions \"Avatar\": filter rows where the exact literal value 'Avatar' matches the title column. 3) When referencing the movie information table: use the exact table name \"Movie\" as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT actor_name FROM movies WHERE title = 'Avatar';",
            "SELECT director FROM Movie WHERE title = 'Avatar';"
        ],
        "rule_sql": [
            "SELECT director FROM Movie WHERE title = 'Avatar';"
        ]
    },
    "1484": {
        "db_id": "college_2",
        "question": "Find the total number of instructors who teach a course in the Spring 2010 semester.",
        "ground_truth": "SELECT COUNT (DISTINCT ID) FROM teaches WHERE semester  =  'Spring' AND YEAR  =  2010",
        "amends": [
            "Do select `COUNT(DISTINCT ID)` instead of `COUNT(*)` to count unique instructors rather than all records. Do use table `teaches` instead of `instructors` to access the correct data source. Do split the semester filter into separate `semester = 'Spring'` and `YEAR = 2010` conditions instead of using a combined `semester = 'Spring 2010'` predicate to properly handle the temporal filtering logic. The amended query now correctly counts distinct instructors who taught in Spring 2010 by using the appropriate table and date components."
        ],
        "rules": [
            "1) When counting instructors: use COUNT(DISTINCT \"ID\") instead of COUNT(*) to count unique instructors rather than all records. 2) When accessing instructor teaching data: use the \"teaches\" table instead of the \"instructors\" table to get the correct data source. 3) When filtering for Spring 2010 semester: split the condition into separate \"semester = 'Spring'\" and \"YEAR = 2010\" conditions instead of using a combined \"semester = 'Spring 2010'\" predicate to properly handle temporal filtering."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM instructors WHERE semester = 'Spring 2010';",
            "SELECT COUNT(DISTINCT ID) FROM teaches WHERE semester = 'Spring' AND year = 2010;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT ID) FROM teaches WHERE semester = 'Spring' AND year = 2010;"
        ]
    },
    "4533": {
        "db_id": "document_management",
        "question": "Find the description of the most popular role among the users that have logged in.",
        "ground_truth": "SELECT role_description FROM ROLES WHERE role_code  =  (SELECT role_code FROM users WHERE user_login  =  1 GROUP BY role_code ORDER BY count(*) DESC LIMIT 1)",
        "amends": [
            "Do select `role_description` from the `ROLES` table instead of `description` from `roles`. Do add a `WHERE` filter with `role_code =` subquery instead of directly ordering by aggregate count. Do use a correlated subquery that selects `role_code` from `users` where `user_login = 1` instead of attempting to aggregate users directly in the main query's ORDER BY. Do group by `role_code` and order by `count(*) DESC` in the subquery instead of trying to count `users.id` in the main query's ORDER BY clause. Do remove the direct aggregate in ORDER BY and instead use a subquery to determine the most frequent role_code for the specified user, then filter the main query by that result. The amended query now correctly identifies the role description for the most common role associated with user_login 1, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"description\" of a role: use \"role_description\" from the \"ROLES\" table instead of \"description\". 2) When finding the most popular role among users that have logged in: use a subquery that selects \"role_code\" from \"users\" where \"user_login = 1\" and group by \"role_code\", then order by count(*) DESC to find the most frequent role. 3) When filtering the main query by the most popular role: use a correlated subquery with \"role_code =\" to match the result from the subquery. 4) When counting users for popularity: use count(*) on the grouped \"role_code\" in the subquery instead of attempting to aggregate users directly in the main query's ORDER BY."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description FROM roles ORDER BY COUNT(users.id) DESC LIMIT 1;",
            "SELECT role_description FROM Roles WHERE role_code = (SELECT role_code FROM Users WHERE user_login = '1' GROUP BY role_code ORDER BY COUNT(*) DESC LIMIT 1);"
        ],
        "rule_sql": [
            "SELECT role_description FROM Roles WHERE role_code = (SELECT role_code FROM Users WHERE user_login = 1 GROUP BY role_code ORDER BY COUNT(*) DESC LIMIT 1)"
        ]
    },
    "3231": {
        "db_id": "college_1",
        "question": "How many departments does the college has?",
        "ground_truth": "SELECT count(DISTINCT dept_name) FROM department",
        "amends": [
            "Do select `count(DISTINCT dept_name)` instead of `COUNT(*)`. Do query from `department` table instead of `students` table. The amended query now correctly counts distinct department names from the department table rather than counting all rows from the students table."
        ],
        "rules": [
            "1) When answering about \"how many departments\": make sure to count distinct values of \"dept_name\" rather than counting all rows. 2) When counting departments: use the \"department\" table as the source of department information, not the \"students\" table. 3) When the question asks for \"how many departments\": compute the number of unique department names using \"dept_name\" as the counting key."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;",
            "SELECT COUNT(DISTINCT DEPT_NAME) FROM DEPARTMENT;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT DEPT_NAME) FROM DEPARTMENT;"
        ]
    },
    "6322": {
        "db_id": "e_government",
        "question": "Find the last name of the latest contact individual of the organization \"Labour Party\".",
        "ground_truth": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.organization_name  =  \"Labour Party\" ORDER BY t2.date_contact_to DESC LIMIT 1",
        "amends": [
            "Do use explicit table joins with `organizations AS t1`, `organization_contact_individuals AS t2`, and `individuals AS t3` instead of querying a single `contacts` table. Do select `t3.individual_last_name` instead of `last_name` to specify the correct column source. Do join `t1.organization_id = t2.organization_id` and `t2.individual_id = t3.individual_id` instead of assuming a single table structure. Do filter on `t1.organization_name = \"Labour Party\"` instead of `organization = 'Labour Party'` to reference the correct table and column. Do order by `t2.date_contact_to DESC` instead of `contact_date DESC` to use the proper date column from the join table. The amended query now correctly joins multiple tables to retrieve the individual's last name associated with the Labour Party organization, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"last name of the latest contact individual\": make sure the output order: t3.individual_last_name. 2) When the question mentions \"organization 'Labour Party'\": \"Labour Party\" actually means t1.organization_name = \"Labour Party\" in schema. 3) When combining tables for shared entities: link rows where t1.organization_id = t2.organization_id and t2.individual_id = t3.individual_id; keep only matching pairs (inner match). 4) When the question asks for \"latest contact individual\": rank rows by t2.date_contact_to in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM contacts WHERE organization = 'Labour Party' ORDER BY contact_date DESC LIMIT 1;",
            "SELECT t3.individual_last_name \nFROM organizations AS t1\nJOIN organization_contact_individuals AS t2 ON t1.organization_id = t2.organization_id\nJOIN individuals AS t3 ON t2.individual_id = t3.individual_id\nWHERE t1.organization_name = 'Labour Party'\nORDER BY t2.date_contact_to DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT t3.individual_last_name\nFROM Organizations t1\nINNER JOIN Organization_Contact_Individuals t2 ON t1.organization_id = t2.organization_id\nINNER JOIN Individuals t3 ON t2.individual_id = t3.individual_id\nWHERE t1.organization_name = 'Labour Party'\nORDER BY t2.date_contact_to DESC\nLIMIT 1"
        ]
    },
    "5346": {
        "db_id": "manufactory_1",
        "question": "Select the name and price of the cheapest product.",
        "ground_truth": "SELECT name ,  price FROM Products ORDER BY price ASC LIMIT 1",
        "amends": [
            "Do select `name, price` columns instead of `name, MAX(price)` aggregate. Do remove the `MAX()` aggregation function instead of keeping it. Do add `ORDER BY price ASC` instead of omitting ordering. Do add `LIMIT 1` instead of omitting row limiting. Do change the table reference to `Products` instead of `products` for case consistency. The amended query now correctly retrieves the product with the lowest price rather than attempting to find maximum price per product name without proper grouping."
        ],
        "rules": [
            "1) When selecting columns for product information: output both \"name\" and \"price\" columns instead of using aggregation functions. 2) When finding the cheapest product: order results by \"price\" in ascending order (lowest first) instead of omitting ordering. 3) When retrieving only the cheapest product: limit results to 1 row instead of returning all rows. 4) When referencing the products table: use exact case \"Products\" instead of lowercase \"products\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, MAX(price) FROM products;",
            "SELECT name, price FROM Products ORDER BY price ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT name, price FROM Products ORDER BY price ASC LIMIT 1;"
        ]
    },
    "2055": {
        "db_id": "party_people",
        "question": "List member names and their party names.",
        "ground_truth": "SELECT T1.member_name ,  T2.party_name FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of no aliases. Do reference `T1.member_name` and `T2.party_name` instead of unqualified `member_name` and `party_name`. Do join `Member AS T1` instead of `members` and `party AS T2` instead of `parties`. Do use join condition `T1.party_id = T2.party_id` instead of `members.party_id = parties.id`. The amended query now correctly uses explicit table aliases and proper join conditions to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"List member names and their party names\": make sure the output order: T1.member_name, T2.party_name. 2) When combining Member table (T1) and party table (T2): link rows where T1.party_id = T2.party_id and keep only matching pairs (inner match). 3) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 4) When referring to table roles: do not rename or swap the aliases T1, T2 once set for this schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT member_name, party_name FROM members JOIN parties ON members.party_id = parties.id",
            "SELECT T1.Member_Name, T2.Party_name FROM member AS T1 JOIN party AS T2 ON T1.Party_ID = T2.Party_ID"
        ],
        "rule_sql": [
            "SELECT T1.\"Member_Name\", T2.\"Party_name\" FROM \"member\" T1 INNER JOIN \"party\" T2 ON T1.\"Party_ID\" = T2.\"Party_ID\""
        ]
    },
    "6290": {
        "db_id": "city_record",
        "question": "Give me a list of cities whose temperature in Mar is lower than that in July and which have also served as host cities?",
        "ground_truth": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of direct table references. Do join `city` and `temperature` tables on `T1.city_id = T2.city_id` instead of querying a single `temperatures` table. Do reference specific month columns `T2.Mar` and `T2.Jul` instead of filtering by month values and using a subquery. Do remove the month filter condition entirely instead of checking `month = 'March'`. Do use direct column comparison `T2.Mar < T2.Jul` instead of a correlated subquery for temperature comparison. Do change the city filtering to use an `INTERSECT` with a join to `hosting_city` table on `T3.city_id = T4.host_city` instead of an `IN` subquery with `olympics.host_city`. Do remove the explicit reference to `host_city` in the filtering logic. The amended query now correctly compares March and July temperatures directly from structured columns and properly identifies Olympic host cities through table relationships."
        ],
        "rules": [
            "1) When answering about cities with temperature comparisons: use explicit table aliases T1 for city table and T2 for temperature table instead of direct table references. 2) When combining city and temperature data: link rows where T1.city_id = T2.city_id to match cities with their temperature records. 3) When comparing March and July temperatures: use direct column comparison T2.Mar < T2.Jul instead of filtering by month values or using subqueries. 4) When identifying Olympic host cities: use INTERSECT with a join to hosting_city table on T3.city_id = T4.host_city instead of IN subqueries with olympics.host_city. 5) When filtering for host cities: remove explicit reference to host_city in the filtering logic and use the structured table relationships."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city \nFROM temperatures \nWHERE month = 'March' AND temperature < (SELECT temperature FROM temperatures WHERE month = 'July' AND city = host_city)\nAND city IN (SELECT host_city FROM olympics);",
            "SELECT T1.City\nFROM city T1\nJOIN temperature T2 ON T1.City_ID = T2.City_ID\nWHERE T2.Mar < T2.Jul\nINTERSECT\nSELECT T3.City\nFROM city T3\nJOIN hosting_city T4 ON T3.City_ID = T4.Host_City"
        ],
        "rule_sql": [
            "SELECT T1.City\nFROM city T1\nJOIN temperature T2 ON T1.City_ID = T2.City_ID\nWHERE T2.Mar < T2.Jul\nINTERSECT\nSELECT T3.City\nFROM city T3\nJOIN hosting_city T4 ON T3.City_ID = T4.Host_City"
        ]
    },
    "5385": {
        "db_id": "tracking_software_problems",
        "question": "Which problems were reported by the staff named Dameon Frami or Jolie Weber? Give me the ids of the problems.",
        "ground_truth": "SELECT product_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE T2.staff_first_name = \"Dameon\" AND T2.staff_last_name = \"Frami\" UNION SELECT product_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE T2.staff_first_name = \"Jolie\" AND T2.staff_last_name = \"Weber\"",
        "amends": [
            "Do select `product_id` instead of `problem_id` and join `staff` table as `T2` on `T1.reported_by_staff_id = T2.staff_id` instead of filtering directly on `reported_by` string values. Do filter on `staff_first_name` and `staff_last_name` columns with exact name matching instead of using concatenated full names in the `WHERE` clause. Do use `UNION` to combine results for two different staff members instead of using `OR` conditions with potentially incorrect name formatting. Do reference the correct foreign key relationship `reported_by_staff_id` instead of assuming direct name matching in the problems table. The amended query now correctly joins through the staff table to find problems reported by specific staff members using their proper first and last name fields.",
            "Do use `product_id` instead of `problem_id` in the SELECT list. Do change the query structure to use `UNION` of two separate queries instead of a single query with `OR` conditions. Do specify exact table aliases `T1` and `T2` instead of generic `p` and `s`. Do use double quotes around string literals instead of single quotes. Do remove the parentheses around the OR conditions since they are now handled through separate UNION queries. The amended query now correctly returns product IDs for staff members with either name combination through UNION instead of potentially incorrect OR logic that might return duplicate results."
        ],
        "rules": [
            "1) When the question asks for problem ids: select \"product_id\" instead of \"problem_id\" from the Problems table. 2) When finding problems reported by specific staff members: join the staff table as T2 on T1.\"reported_by_staff_id\" = T2.\"staff_id\" instead of filtering directly on name strings. 3) When filtering for staff named Dameon Frami: match exactly on T2.\"staff_first_name\" = 'Dameon' AND T2.\"staff_last_name\" = 'Frami'. 4) When filtering for staff named Jolie Weber: match exactly on T2.\"staff_first_name\" = 'Jolie' AND T2.\"staff_last_name\" = 'Weber'. 5) When combining results for multiple staff members: use UNION to combine separate queries for each staff member instead of OR conditions with name concatenation.",
            "1) When the question asks for \"ids of the problems\": use the exact column token \"product_id\" instead of \"problem_id\" from table Problems. 2) When querying for staff members with specific names: use UNION to combine results from separate queries for each name combination instead of OR conditions to avoid potential duplicates. 3) When referring to the Problems table: use alias T1 consistently. 4) When referring to the Staff table: use alias T2 consistently. 5) When using string literals for staff names: wrap them in double quotes exactly as \"Dameon\", \"Frami\", \"Jolie\", and \"Weber\". 6) When joining Problems and Staff tables: link rows where T1.reported_by_staff_id equals T2.staff_id to find problems reported by specific staff members."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT problem_id FROM problems WHERE reported_by = 'Dameon Frami' OR reported_by = 'Jolie Weber';",
            "SELECT p.problem_id\nFROM Problems p\nJOIN Staff s ON p.reported_by_staff_id = s.staff_id\nWHERE (s.staff_first_name = 'Dameon' AND s.staff_last_name = 'Frami')\n   OR (s.staff_first_name = 'Jolie' AND s.staff_last_name = 'Weber')",
            "SELECT T1.product_id\nFROM Problems T1\nJOIN Staff T2 ON T1.reported_by_staff_id = T2.staff_id\nWHERE T2.staff_first_name = 'Dameon' AND T2.staff_last_name = 'Frami'\nUNION\nSELECT T1.product_id\nFROM Problems T1\nJOIN Staff T2 ON T1.reported_by_staff_id = T2.staff_id\nWHERE T2.staff_first_name = 'Jolie' AND T2.staff_last_name = 'Weber'"
        ],
        "rule_sql": [
            "SELECT T1.product_id FROM Problems T1 JOIN Staff T2 ON T1.reported_by_staff_id = T2.staff_id WHERE T2.staff_first_name = 'Dameon' AND T2.staff_last_name = 'Frami'\nUNION\nSELECT T1.product_id FROM Problems T1 JOIN Staff T2 ON T1.reported_by_staff_id = T2.staff_id WHERE T2.staff_first_name = 'Jolie' AND T2.staff_last_name = 'Weber'"
        ]
    },
    "362": {
        "db_id": "flight_1",
        "question": "What is the number of employees?",
        "ground_truth": "SELECT count(*) FROM Employee",
        "amends": [
            "Do reference the table as `Employee` instead of `employees` to match the correct schema naming convention. The amended query now correctly counts records from the Employee table where salary exceeds 100,000, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"number of employees\": count the number of rows using the canonical key from the Employee table. 2) When the question mentions \"employees\": use the exact table name \"Employee\" with proper case as shown in the schema. 3) When filtering by salary condition: apply the exact numeric comparison where salary exceeds 100000 as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE salary > 100000;",
            "SELECT COUNT(*) FROM employee;"
        ],
        "rule_sql": [
            "SELECT COUNT(eid) FROM employee;"
        ]
    },
    "1122": {
        "db_id": "climbing",
        "question": "What are the countries of mountains with height bigger than 5000?",
        "ground_truth": "SELECT Country FROM mountain WHERE Height  >  5000",
        "amends": [
            "Do reference the table as `mountain` instead of `mountains` to match the correct table name. Do capitalize the column names as `Country` and `Height` instead of lowercase `country` and `height` to match the correct column naming convention. Do maintain the filter condition `Height > 5000` instead of `height > 5000` to ensure proper column reference. The amended query now correctly selects from the mountain table with proper column capitalization."
        ],
        "rules": [
            "1) When the question mentions \"mountains\": use the exact table name \"mountain\" instead of \"mountains\". 2) When referencing column names: capitalize \"Country\" and \"Height\" exactly as shown in the schema, not lowercase \"country\" and \"height\". 3) When filtering by height: use the exact column name \"Height\" with the condition > 5000 to match the numerical comparison in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM mountains WHERE height > 5000;",
            "SELECT Country FROM mountain WHERE Height > 5000;"
        ],
        "rule_sql": [
            "SELECT Country FROM mountain WHERE Height > 5000"
        ]
    },
    "443": {
        "db_id": "allergy_1",
        "question": "Show all allergy types.",
        "ground_truth": "SELECT DISTINCT allergytype FROM Allergy_type",
        "amends": [
            "Do select only `allergytype` instead of all columns with `*`. Do add `DISTINCT` instead of omitting it to return unique values. Do change the source table to `Allergy_type` instead of `patients`. Do remove the entire query structure and replace it with a focused selection of distinct allergy types from the appropriate table."
        ],
        "rules": [
            "1) When answering about \"allergy types\": make sure the output order: \"allergytype\". 2) When the question asks for \"allergy types\": \"allergy types\" actually means \"allergytype in schema\". 3) When the question asks for \"all types\": return only unique values of \"allergytype\" using DISTINCT. 4) When selecting from the schema: use table \"Allergy_type\" instead of \"patients\" as the source table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM patients;",
            "SELECT DISTINCT AllergyType FROM Allergy_Type;"
        ],
        "rule_sql": [
            "SELECT DISTINCT AllergyType FROM Allergy_Type ORDER BY AllergyType;"
        ]
    },
    "2782": {
        "db_id": "election",
        "question": "Show the name of the county with the biggest population.",
        "ground_truth": "SELECT County_name FROM county ORDER BY Population DESC LIMIT 1",
        "amends": [
            "Do select `County_name` instead of `name` and order by `Population DESC` instead of `population ASC` to get the county with the highest population instead of the lowest. Do use table name `county` instead of `counties` to reference the correct data source. The amended query now correctly identifies the county with the maximum population as intended."
        ],
        "rules": [
            "1) When the question asks for the county name: use the exact column token \"County_name\" from the county table. 2) When the question asks for the county with the biggest population: order by the \"Population\" column in descending order (DESC) to get the highest value. 3) When referencing the data source: use the exact table name \"county\" instead of variations like \"counties\". 4) When selecting the top result: use LIMIT 1 to get only the first row after ordering."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM counties ORDER BY population ASC LIMIT 1;",
            "SELECT County_name FROM county ORDER BY Population DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT County_name FROM county ORDER BY Population DESC LIMIT 1;"
        ]
    },
    "5976": {
        "db_id": "game_1",
        "question": "What are the names of all the video games and their types in alphabetical order?",
        "ground_truth": "SELECT gname ,  gtype FROM Video_games ORDER BY gname",
        "amends": [
            "Do select `gname` and `gtype` columns instead of `name` and `type`. Do order by `gname` instead of `type ASC`. Do reference the correct table name `Video_games` instead of `video_games`. The amended query now correctly selects and orders the specified columns from the proper table structure."
        ],
        "rules": [
            "1) When selecting video game names and types: use the exact column tokens \"gname\" and \"gtype\" instead of \"name\" and \"type\". 2) When ordering video games alphabetically: order by the \"gname\" column in ascending order instead of ordering by \"type\". 3) When referencing the video games table: use the exact table name \"Video_games\" with the correct case and spelling instead of \"video_games\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, type FROM video_games ORDER BY type ASC;",
            "SELECT GName, GType FROM Video_Games ORDER BY GName ASC;"
        ],
        "rule_sql": [
            "SELECT gname, gtype FROM Video_Games ORDER BY gname ASC;"
        ]
    },
    "1800": {
        "db_id": "small_bank_1",
        "question": "Find the names and total checking and savings balances of accounts whose savings balance is higher than the average savings balance.",
        "ground_truth": "SELECT T1.name ,  T2.balance + T3.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid WHERE T3.balance  >  (SELECT avg(balance) FROM savings)",
        "amends": [
            "Do reference columns from joined tables `T2.balance` and `T3.balance` instead of directly accessing `checking_balance` and `savings_balance` from a single table. Do join `checking AS T2` on `T1.custid = T2.custid` instead of querying a single accounts table. Do join `savings AS T3` on `T1.custid = T3.custid` instead of having all balances in one table. Do use `T3.balance` in the WHERE filter instead of `savings_balance`. Do calculate the average from `savings` table using `avg(balance)` instead of averaging `checking_balance` from accounts. Do remove the alias `total_balance` instead of keeping it. The amended query now correctly joins normalized tables and compares savings balance against the average savings balance rather than checking balance average."
        ],
        "rules": [
            "1) When the question asks for account names and total balances: use T1.name for account names and compute total balance as (T2.balance + T3.balance) without aliasing the result. 2) When comparing savings balance to average savings balance: use T3.balance in the filter condition and compare it against the average of T3.balance from the savings table. 3) When joining checking and savings tables: link checking AS T2 on T1.custid = T2.custid and savings AS T3 on T1.custid = T3.custid, keeping only accounts that have both checking and savings accounts (inner match). 4) When calculating the average savings balance: compute AVG(T3.balance) from the savings table instead of using checking_balance from a single accounts table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, (checking_balance + savings_balance) as total_balance \nFROM accounts \nWHERE savings_balance > (SELECT AVG(checking_balance) FROM accounts);",
            "SELECT T1.name, (T2.balance + T3.balance) AS total_balance\nFROM ACCOUNTS AS T1\nJOIN CHECKING AS T2 ON T1.custid = T2.custid\nJOIN SAVINGS AS T3 ON T1.custid = T3.custid\nWHERE T3.balance > (SELECT AVG(balance) FROM SAVINGS)"
        ],
        "rule_sql": [
            "SELECT T1.name, (T2.balance + T3.balance) \nFROM ACCOUNTS AS T1\nINNER JOIN CHECKING AS T2 ON T1.custid = T2.custid\nINNER JOIN SAVINGS AS T3 ON T1.custid = T3.custid\nWHERE T3.balance > (SELECT AVG(T3_avg.balance) FROM SAVINGS AS T3_avg)"
        ]
    },
    "1691": {
        "db_id": "epinions_1",
        "question": "Find the number of reviews.",
        "ground_truth": "SELECT count(*) FROM review",
        "amends": [
            "Do query the `review` table instead of the `customers` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)`. End with confirmation that the amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"number of reviews\": query the \"review\" table instead of the \"customers\" table. 2) When counting entities: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" to count all rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers;",
            "SELECT count(*) FROM review;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM review"
        ]
    },
    "1794": {
        "db_id": "small_bank_1",
        "question": "Find the checking balance of the accounts whose savings balance is higher than the average savings balance.",
        "ground_truth": "SELECT T2.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid WHERE T1.name IN (SELECT T1.name FROM accounts AS T1 JOIN savings AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  >  (SELECT avg(balance) FROM savings))",
        "amends": [
            "Do use `T2.balance` from the `checking` table instead of `checking_balance` from the `accounts` table. Do join `accounts AS T1` with `checking AS T2` on `T1.custid = T2.custid` instead of querying a single table. Do filter with `T1.name IN` subquery instead of direct comparison to average. Do use a subquery that joins `accounts AS T1` with `savings AS T2` on `T1.custid = T2.custid` instead of comparing to average checking balance. Do filter the subquery with `T2.balance > (SELECT avg(balance) FROM savings)` instead of comparing savings_balance to average checking_balance. The amended query now correctly identifies customers with savings balances above the average savings balance rather than incorrectly comparing different account types."
        ],
        "rules": [
            "1) When the question asks for checking balance: use T2.balance from the checking table instead of checking_balance from the accounts table. 2) When combining account information with checking information: join accounts AS T1 with checking AS T2 on T1.custid = T2.custid to link customer records. 3) When filtering for accounts with savings balance higher than average: use a subquery that joins accounts AS T1 with savings AS T2 on T1.custid = T2.custid to access savings data. 4) When comparing savings balance to average: filter with T2.balance > (SELECT avg(balance) FROM savings) instead of comparing to average checking balance. 5) When identifying customers with above-average savings: use T1.name IN subquery pattern to filter the main query results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT checking_balance FROM accounts WHERE savings_balance > (SELECT AVG(checking_balance) FROM accounts)",
            "SELECT T2.balance \nFROM accounts AS T1 \nJOIN checking AS T2 ON T1.custid = T2.custid \nWHERE T1.custid IN (\n    SELECT T1.custid \n    FROM accounts AS T1 \n    JOIN savings AS T2 ON T1.custid = T2.custid \n    WHERE T2.balance > (SELECT AVG(balance) FROM savings)\n)"
        ],
        "rule_sql": [
            "SELECT T2.balance \nFROM accounts AS T1 \nJOIN checking AS T2 ON T1.custid = T2.custid \nWHERE T1.custid IN (\n    SELECT T1.custid \n    FROM accounts AS T1 \n    JOIN savings AS T2 ON T1.custid = T2.custid \n    WHERE T2.balance > (SELECT AVG(balance) FROM savings)\n)"
        ]
    },
    "1399": {
        "db_id": "college_2",
        "question": "How many total credits are offered by each department?",
        "ground_truth": "SELECT sum(credits) ,  dept_name FROM course GROUP BY dept_name",
        "amends": [
            "Do use `dept_name` instead of `department` in both the SELECT list and GROUP BY clause. Do place the aggregate function `sum(credits)` before the column name instead of after it. Do reference the table as `course` instead of `courses`. The amended query now correctly aggregates credits by department name using the proper table and column references.",
            "Do place the aggregate function `sum(credits)` before the grouping column `dept_name` in the SELECT list instead of listing the grouping column first. Do use the alias `total_credits` for the aggregate column instead of omitting it. The amended query now correctly matches the RIGHT_SQL's behavior with the proper column order and aggregation.",
            "Do place the aggregate function `sum(credits)` first in the SELECT list instead of placing `dept_name` first. Do remove the alias `AS total_credits` instead of keeping it, as the RIGHT_SQL does not include an explicit alias for the sum result. The amended query now matches RIGHT_SQL's behavior by maintaining the same logical grouping and calculation while adjusting the column order and removing the unnecessary alias."
        ],
        "rules": [
            "1) When the question mentions \"department\": \"department\" actually means \"dept_name\" in the schema. 2) When the question asks for \"total credits per department\": organize results by \"dept_name\" and compute the sum of \"credits\" per group. 3) When producing output: make sure the output order is sum(credits) followed by dept_name. 4) When referring to the table: use the exact table name \"course\" instead of \"courses\".",
            "1) When answering about \"total credits offered by each department\": make sure the output order: sum(credits) first, then dept_name. 2) When computing aggregates with grouping: use the alias \"total_credits\" for the sum(credits) column. 3) When grouping by department: use the exact column token \"dept_name\" as the grouping key.",
            "1) When answering about \"total credits offered by each department\": make sure the output order: sum(credits) first, then dept_name. 2) When computing aggregates for display: do not add explicit aliases like \"AS total_credits\" to the sum result. 3) When grouping by department: use dept_name as the grouping key to organize results per department."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department, SUM(credits) FROM courses GROUP BY department;",
            "SELECT dept_name, SUM(credits) AS total_credits FROM course GROUP BY dept_name;",
            "SELECT dept_name, SUM(credits) AS total_credits FROM course GROUP BY dept_name",
            "SELECT sum(credits), dept_name FROM course GROUP BY dept_name"
        ],
        "rule_sql": [
            "SELECT SUM(credits), dept_name FROM course GROUP BY dept_name ORDER BY SUM(credits), dept_name;"
        ]
    },
    "4202": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "Show the names of all the employees with role \"HR\".",
        "ground_truth": "SELECT employee_name FROM Employees WHERE role_code  =  \"HR\"",
        "amends": [
            "Do select `employee_name` instead of `name` and do use table `Employees` instead of `employees`. Do filter on `role_code = \"HR\"` instead of `role = 'Manager'` with proper double quotes for the string literal instead of single quotes. The amended query now correctly retrieves HR employees by their role code from the proper table with the correct column names and string formatting."
        ],
        "rules": [
            "1) When the question asks for employee names: use the exact column token \"employee_name\" from the Employees table. 2) When the question specifies employees with role \"HR\": filter using the exact condition role_code = \"HR\" with double quotes around the literal value. 3) When selecting from the employee table: use the exact table name \"Employees\" with proper capitalization."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM employees WHERE role = 'Manager';",
            "SELECT Employee_Name FROM Employees WHERE Role_Code = \"HR\";"
        ],
        "rule_sql": [
            "SELECT employee_name FROM Employees WHERE role_code = \"HR\""
        ]
    },
    "2185": {
        "db_id": "formula_1",
        "question": "Find all the forenames of distinct drivers who won in position 1 as driver standing and had more than 20 points?",
        "ground_truth": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20",
        "amends": [
            "Do add table `driverstandings AS T2` with a `JOIN` on `T1.driverid = T2.driverid` instead of querying only the `drivers` table. Do change the `position = 1` filter to reference `T2.position` instead of the unspecified table. Do add the condition `T2.wins = 1` instead of omitting it. Do change the `points > 20` filter to reference `T2.points` instead of the unspecified table. Do qualify `forename` as `T1.forename` instead of the unqualified column reference. The amended query now correctly joins driver standings data and filters on the appropriate table columns to match the intended behavior."
        ],
        "rules": [
            "1) When answering about driver forenames and their standings: combine data from drivers table (T1) and driverstandings table (T2) using the exact join condition T1.driverid = T2.driverid, keeping only matching pairs. 2) When filtering for position 1 in driver standings: use T2.position = 1 instead of any other table's position column. 3) When checking for wins in driver standings: include the condition T2.wins = 1 as required by the question. 4) When filtering for points greater than 20: use T2.points > 20 instead of any other table's points column. 5) When selecting forenames: qualify the column as T1.forename to specify it comes from the drivers table. 6) When finding distinct drivers: ensure only unique forenames are returned by using DISTINCT on T1.forename."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT forename FROM drivers WHERE position = 1 AND points > 20;",
            "SELECT DISTINCT T1.forename\nFROM drivers AS T1\nJOIN driverStandings AS T2 ON T1.driverId = T2.driverId\nWHERE T2.position = 1\nAND T2.wins = 1\nAND T2.points > 20"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.forename\nFROM drivers T1\nJOIN driverStandings T2 ON T1.driverId = T2.driverId\nWHERE T2.position = 1\nAND T2.wins = 1\nAND T2.points > 20"
        ]
    },
    "3761": {
        "db_id": "program_share",
        "question": "Which programs' origins are not \"Beijing\"? Give me the program names.",
        "ground_truth": "SELECT name FROM program WHERE origin != 'Beijing'",
        "amends": [
            "Do select `name` instead of `program_name` and use table `program` instead of `programs`. Do filter with `!= 'Beijing'` instead of `= 'Beijing'` to exclude Beijing-origin records instead of including them. The amended query now correctly retrieves program names from the program table excluding those from Beijing, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for program names: use the exact column token \"name\" from the program table instead of \"program_name\". 2) When the question specifies programs not from Beijing: filter using the condition origin != 'Beijing' to exclude Beijing-origin records. 3) When referring to the program table: use the exact table name \"program\" instead of \"programs\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT program_name FROM programs WHERE origin = 'Beijing';",
            "SELECT Name FROM program WHERE Origin != 'Beijing';"
        ],
        "rule_sql": [
            "SELECT name FROM program WHERE origin != 'Beijing'"
        ]
    },
    "3994": {
        "db_id": "hospital_1",
        "question": "How many appointments are there?",
        "ground_truth": "SELECT count(*) FROM appointment",
        "amends": [
            "Do query the `appointment` table instead of the `patients` table. Do count all records from the appointment table instead of counting from the patients table. The amended query now correctly counts appointments rather than patients, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"How many appointments are there?\": make sure to query the \"appointment\" table instead of the \"patients\" table. 2) When counting appointments: count all records from the \"appointment\" table using the canonical key for appointments."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients;",
            "SELECT COUNT(*) FROM Appointment;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Appointment;"
        ]
    },
    "3056": {
        "db_id": "loan_1",
        "question": "For each account type, find the average account balance of customers with credit score lower than 50.",
        "ground_truth": "SELECT avg(acc_bal) ,  acc_type FROM customer WHERE credit_score  <  50 GROUP BY acc_type",
        "amends": [
            "Do use `avg(acc_bal)` and `acc_type` instead of `AVG(balance)` and `account_type` in the SELECT list. Do reference table `customer` instead of `accounts` in the FROM clause. Do use column `acc_type` instead of `account_type` in the GROUP BY clause. The amended query now correctly references the customer table schema with appropriate column names while maintaining the same aggregation logic for accounts with credit scores below 50.",
            "Do place `acc_type` in the SELECT list instead of omitting it from the output columns. Do use the aggregate function `avg(acc_bal)` without an alias instead of `AVG(acc_bal) AS average_account_balance`. Do maintain the same `WHERE credit_score < 50` filter and `GROUP BY acc_type` clause without changes. The amended query now correctly outputs both the average account balance and account type for customers with low credit scores, matching the RIGHT_SQL's behavior.",
            "Do place `acc_type` after `avg(acc_bal)` in the SELECT list instead of before it, maintaining the same column order as in the GROUP BY clause for consistency. The amended query now matches RIGHT_SQL's behavior with identical column sequencing."
        ],
        "rules": [
            "1) When answering about \"average account balance of customers with credit score lower than 50 per account type\": make sure the output order: acc_type, avg(acc_bal). 2) When the question mentions \"account type\": \"account type\" actually means \"acc_type in schema\". 3) When the question mentions \"account balance\": \"account balance\" actually means \"acc_bal in schema\". 4) When the question asks for \"average account balance\": compute the average of the exact token acc_bal. 5) When the question says \"per account type\"/\"by account type\": organize results by the token for acc_type and compute requested aggregates per group. 6) When filtering for customers with credit score lower than 50: include only rows where credit_score < 50. 7) When referencing the customer table: use the exact table name customer in the FROM clause.",
            "1) When answering about \"average account balance of customers with credit score lower than 50 per account type\": make sure the output order: acc_type, avg(acc_bal). 2) When the question mentions \"account type\": \"account type\" actually means \"acc_type in schema\". 3) When the question asks for \"average account balance\": compute the average of acc_bal values. 4) When filtering for \"credit score lower than 50\": apply the condition credit_score < 50. 5) When the question says \"per account type\": organize results by acc_type and compute the average account balance per group.",
            "1) When answering about \"average account balance of customers with credit score lower than 50 per account type\": make sure the output order: average account balance first, then account type. 2) When the question asks for \"average account balance\": compute the average of the exact token \"acc_bal\" from the customer table. 3) When the question mentions \"credit score lower than 50\": use the exact condition \"credit_score < 50\" with the exact literal value 50. 4) When the question says \"per account type\": organize results by the exact token \"acc_type\" from the customer table and compute the average account balance per group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT account_type, AVG(balance) FROM accounts WHERE credit_score < 50 GROUP BY account_type",
            "SELECT acc_type, AVG(acc_bal) AS average_account_balance FROM customer WHERE credit_score < 50 GROUP BY acc_type",
            "SELECT acc_type, avg(acc_bal) FROM customer WHERE credit_score < 50 GROUP BY acc_type",
            "SELECT avg(acc_bal), acc_type FROM customer WHERE credit_score < 50 GROUP BY acc_type"
        ],
        "rule_sql": [
            "SELECT acc_type, AVG(acc_bal) AS average_account_balance\nFROM customer\nWHERE credit_score < 50\nGROUP BY acc_type\nORDER BY acc_type, AVG(acc_bal);"
        ]
    },
    "6030": {
        "db_id": "game_1",
        "question": "What is the total number of hours per work and number of games played by David Shieber?",
        "ground_truth": "SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.Fname  =  \"David\" AND T2.Lname  =  \"Shieber\"",
        "amends": [
            "Do join `Sportsinfo` and `Student` tables on `T1.StuID = T2.StuID` instead of querying a single `player_stats` table. Do filter on `T2.Fname = \"David\"` and `T2.Lname = \"Shieber\"` instead of `player_name = 'David Shieber'`. Do aggregate `sum(hoursperweek)` and `sum(gamesplayed)` as separate columns instead of `SUM(hours)` and `COUNT(*)`. Do remove the column aliases `total_hours` and `games_played` instead of keeping them. The amended query now correctly joins the student and sports information tables to retrieve accurate statistics for the specified student."
        ],
        "rules": [
            "1) When combining Sportsinfo and Student tables: link rows where T1.StuID = T2.StuID and keep only matching pairs (inner match). 2) When the question mentions \"David Shieber\": filter on T2.Fname = \"David\" and T2.Lname = \"Shieber\" exactly as specified. 3) When calculating total hours per work: compute sum(hoursperweek) as a separate column. 4) When calculating number of games played: compute sum(gamesplayed) as a separate column instead of counting rows. 5) When producing output: do not include column aliases total_hours and games_played in the final result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(hours) as total_hours, COUNT(*) as games_played FROM player_stats WHERE player_name = 'David Shieber'",
            "SELECT SUM(T1.HoursPerWeek), SUM(T1.GamesPlayed) FROM SportsInfo T1 JOIN Student T2 ON T1.StuID = T2.StuID WHERE T2.Fname = 'David' AND T2.Lname = 'Shieber'"
        ],
        "rule_sql": [
            "SELECT SUM(S.HoursPerWeek), SUM(S.GamesPlayed) FROM SportsInfo S INNER JOIN Student St ON S.StuID = St.StuID WHERE St.Fname = 'David' AND St.Lname = 'Shieber'"
        ]
    },
    "1967": {
        "db_id": "products_for_hire",
        "question": "What are the names of products whose availability equals to 1?",
        "ground_truth": "SELECT T2.product_name FROM view_product_availability AS T1 JOIN products_for_hire AS T2 ON T1.product_id  =  T2.product_id WHERE T1.available_yn  =  1",
        "amends": [
            "Do select `T2.product_name` instead of `name` and use table alias `T2` instead of direct table reference. Do add `FROM view_product_availability AS T1 JOIN products_for_hire AS T2` instead of just `FROM products`, introducing two joined tables instead of one. Do specify join condition `ON T1.product_id = T2.product_id` instead of no join condition. Do change filter to `T1.available_yn = 1` instead of `availability = 0`, using the correct availability column from the joined table with the proper boolean value. The amended query now correctly joins the availability view with product details and uses the appropriate availability flag, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about product names: make sure the output order: T2.product_name. 2) When the question mentions \"availability equals to 1\": \"availability\" actually means \"T1.available_yn = 1\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.product_id = T2.product_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When selecting from multiple tables: use FROM view_product_availability AS T1 JOIN products_for_hire AS T2 instead of just FROM products."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM products WHERE availability = 0;",
            "SELECT T2.product_name\nFROM View_Product_Availability AS T1\nJOIN Products_for_Hire AS T2 ON T1.product_id = T2.product_id\nWHERE T1.available_yn = '1'"
        ],
        "rule_sql": [
            "SELECT T2.product_name\nFROM View_Product_Availability AS T1\nJOIN Products_for_Hire AS T2 ON T1.product_id = T2.product_id\nWHERE T1.available_yn = '1'\nORDER BY T2.product_name;"
        ]
    },
    "10": {
        "db_id": "department_management",
        "question": "How many acting statuses are there?",
        "ground_truth": "SELECT count(DISTINCT temporary_acting) FROM management",
        "amends": [
            "Do use `count(DISTINCT temporary_acting)` instead of `COUNT(*)` to count distinct values rather than all rows. Do query from `management` table instead of `actors` table. Do remove the asterisk wildcard and instead specify the specific column `temporary_acting` for distinct counting. The amended query now correctly counts distinct temporary_acting values from the management table instead of counting all rows from the actors table."
        ],
        "rules": [
            "1) When the question asks about \"acting statuses\": \"acting statuses\" actually means \"temporary_acting in management table\". 2) When counting distinct values of temporary_acting: compute the number of unique values of \"temporary_acting\" from the \"management\" table. 3) When answering about \"How many acting statuses are there\": make sure to query from the \"management\" table instead of the \"actors\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM actors;",
            "SELECT COUNT(DISTINCT temporary_acting) FROM management;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT temporary_acting) FROM management;"
        ]
    },
    "5370": {
        "db_id": "tracking_software_problems",
        "question": "Find the ids of the problems that are reported by the staff whose last name is Bosco.",
        "ground_truth": "SELECT T1.problem_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE T2.staff_last_name = \"Bosco\"",
        "amends": [
            "Do use explicit `JOIN` syntax with `problems AS T1 JOIN staff AS T2` instead of a subquery in the `WHERE` clause. Do reference the correct join condition `ON T1.reported_by_staff_id = T2.staff_id` instead of the incorrect column reference in the subquery. Do filter with `WHERE T2.staff_last_name = \"Bosco\"` instead of the subquery approach with `last_name = 'Bosco'`. Do add table aliases `T1` and `T2` for clarity instead of omitting them. Do use the correct column name `staff_last_name` instead of `last_name` and the correct join column `reported_by_staff_id` instead of `reported_by`. The amended query now correctly joins the tables and matches the intended behavior."
        ],
        "rules": [
            "1) When joining tables \"problems\" and \"staff\": use explicit JOIN syntax with \"problems AS T1 JOIN staff AS T2\" instead of subqueries. 2) When linking problems to staff: use the exact join condition \"T1.reported_by_staff_id = T2.staff_id\" to match rows. 3) When filtering for staff with last name \"Bosco\": use the exact column \"T2.staff_last_name\" and literal value \"Bosco\" with double quotes. 4) When selecting problem identifiers: output only the \"problem_id\" column from table T1. 5) When handling identifier delimiters: use double quotes for string literals like \"Bosco\" and preserve exact column names as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT problem_id FROM problems WHERE reported_by IN (SELECT staff_id FROM staff WHERE last_name = 'Bosco')",
            "SELECT T1.problem_id\nFROM Problems AS T1\nJOIN Staff AS T2 ON T1.reported_by_staff_id = T2.staff_id\nWHERE T2.staff_last_name = 'Bosco'"
        ],
        "rule_sql": [
            "SELECT T1.problem_id FROM Problems AS T1 JOIN Staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE T2.staff_last_name = \"Bosco\""
        ]
    },
    "3663": {
        "db_id": "baseball_1",
        "question": "List players' first name and last name who have weight greater than 220 or height shorter than 75.",
        "ground_truth": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75",
        "amends": [
            "Do use column names `name_first` and `name_last` instead of `first_name` and `last_name`. Do reference table `player` instead of `players`. Do use logical operator `OR` instead of `AND` between the weight and height conditions, changing the filter logic to include players who are either heavy or short rather than requiring both conditions simultaneously. The amended query now correctly selects from the player table with the appropriate column names and inclusive filtering logic."
        ],
        "rules": [
            "1) When the question asks for \"first name\" and \"last name\": use the exact column names \"name_first\" and \"name_last\" from table \"player\". 2) When the question mentions \"players\": it refers to the table \"player\" in the schema. 3) When the question asks for players who have weight greater than 220 OR height shorter than 75: use logical OR between the conditions rather than AND to include players satisfying either condition. 4) When filtering on weight and height conditions: ensure the output includes all players where weight > 220 or height < 75, not requiring both conditions simultaneously."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM players WHERE weight > 220 AND height < 75;",
            "SELECT name_first, name_last FROM player WHERE weight > 220 OR height < 75;"
        ],
        "rule_sql": [
            "SELECT name_first, name_last FROM player WHERE weight > 220 OR height < 75"
        ]
    },
    "4477": {
        "db_id": "network_2",
        "question": "What are the names of all people who do not have friends?",
        "ground_truth": "SELECT name FROM person EXCEPT SELECT name FROM PersonFriend",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` subquery. Do reference table `person` instead of `people`. Do reference table `PersonFriend` instead of `friends`. Do select from `person` and `PersonFriend` tables instead of `people` and `friends`. Do use column `name` from both sides of the set operation instead of filtering by `id` and `person_id`. The amended query now correctly uses set-based logic to find names in person that don't exist in PersonFriend, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"names of people who do not have friends\": use EXCEPT set operation instead of NOT IN subquery. 2) When referencing the person table: use table \"person\" instead of \"people\". 3) When referencing the friends relationship table: use table \"PersonFriend\" instead of \"friends\". 4) When selecting from person and friends tables: use \"person\" and \"PersonFriend\" tables instead of \"people\" and \"friends\". 5) When comparing names between tables: use column \"name\" from both sides of the set operation instead of filtering by \"id\" and \"person_id\". 6) When finding people without friends: use set-based logic to find names in person that don't exist in PersonFriend."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM people WHERE id NOT IN (SELECT person_id FROM friends);",
            "SELECT name FROM Person\nEXCEPT\nSELECT name FROM PersonFriend"
        ],
        "rule_sql": [
            "SELECT name FROM Person\nEXCEPT\nSELECT name FROM PersonFriend"
        ]
    },
    "3678": {
        "db_id": "baseball_1",
        "question": "What is the total salary expenses of team Boston Red Stockings in 2010?",
        "ground_truth": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010",
        "amends": [
            "Do join `team AS T2` instead of omitting it, and do use `ON T1.team_id = T2.team_id_br` for the join condition instead of filtering directly on team name. Do reference `T2.name = 'Boston Red Stockings'` instead of `team = 'Boston Red Stockings'`, and do use `T1.year = 2010` instead of `year = 2010`. Do qualify the column as `sum(T1.salary)` instead of `SUM(salary)` to explicitly reference the table alias. The amended query now correctly joins the tables and uses proper table-qualified column references to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"total salary expenses of team Boston Red Stockings in 2010\": make sure the output order: sum(T1.salary). 2) When the question mentions \"team Boston Red Stockings\": \"Boston Red Stockings\" actually means \"T2.name = 'Boston Red Stockings'\" in schema. 3) When the question mentions \"year 2010\": \"2010\" actually means \"T1.year = 2010\" in schema. 4) When combining T1 and T2 for shared entities: link rows where T1.team_id = T2.team_id_br exactly as shown in the amends; keep only matching pairs (inner match). 5) When computing salary expenses: use sum(T1.salary) as the aggregate function."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(salary) FROM salaries WHERE team = 'Boston Red Stockings' AND year = 2010;",
            "SELECT SUM(T1.salary) \nFROM salary AS T1\nJOIN team AS T2 ON T1.team_id = T2.team_id_br\nWHERE T2.name = 'Boston Red Stockings' AND T1.year = 2010"
        ],
        "rule_sql": [
            "SELECT SUM(s.salary) \nFROM salary s\nJOIN team t ON s.team_id = t.team_id_br\nWHERE t.name = 'Boston Red Stockings' \nAND s.year = 2010"
        ]
    },
    "6534": {
        "db_id": "wine_1",
        "question": "What are the names of wines made from red grapes?",
        "ground_truth": "SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  \"Red\"",
        "amends": [
            "Do use `DISTINCT T2.Name` instead of `name` without distinct. Do join `GRAPES AS T1` with `WINE AS T2` on `T1.Grape = T2.Grape` instead of querying `wines` table directly. Do filter on `T1.Color = \"Red\"` instead of `grape_color = 'white'`. Do reference the correct table aliases and column names throughout the query instead of using incorrect table and column references. The amended query now correctly retrieves distinct wine names made from red grapes by properly joining the grapes and wine tables."
        ],
        "rules": [
            "1) When answering about \"names of wines made from red grapes\": make sure the output order: T2.Name. 2) When the question asks for wine names: use DISTINCT T2.Name to get unique wine names. 3) When combining GRAPES and WINE tables: link rows where T1.Grape = T2.Grape and keep only matching pairs (inner match). 4) When filtering for red grapes: use T1.Color = \"Red\" exactly as specified. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for \"Red\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM wines WHERE grape_color = 'white';",
            "SELECT DISTINCT T2.Name FROM grapes AS T1 JOIN wine AS T2 ON T1.Grape = T2.Grape WHERE T1.Color = 'Red'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.Name FROM grapes T1 INNER JOIN wine T2 ON T1.Grape = T2.Grape WHERE T1.Color = \"Red\" ORDER BY T2.Name"
        ]
    },
    "6386": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "Count the number of accounts.",
        "ground_truth": "SELECT count(*) FROM Accounts",
        "amends": [
            "Do reference the `Accounts` table instead of the `customers` table, as the correct data source for this count operation. The amended query now correctly counts all records from the Accounts table, matching the intended behavior."
        ],
        "rules": [
            "1) When counting the number of accounts: use the \"Accounts\" table as the data source instead of the \"customers\" table. 2) When counting all records from a table: count all rows from the specified table without any filtering conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers;",
            "SELECT COUNT(*) FROM Accounts;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Accounts;"
        ]
    },
    "18": {
        "db_id": "farm",
        "question": "List the total number of horses on farms in ascending order.",
        "ground_truth": "SELECT Total_Horses FROM farm ORDER BY Total_Horses ASC",
        "amends": [
            "Do select only `Total_Horses` instead of selecting both `farm_name` and a count. Do remove the `COUNT(*)` aggregation and `GROUP BY farm_name` clause instead of including them. Do query from the `farm` table instead of the `horses` table. Do change the sort direction to `ASC` instead of `DESC`. Do remove the alias `total_horses` from the output instead of keeping it. The amended query now correctly selects the Total_Horses column directly from the farm table and sorts them in ascending order, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"total number of horses on farms\": select the exact column \"Total_Horses\" from the \"farm\" table instead of counting or aggregating. 2) When the question specifies \"ascending order\": sort the results by \"Total_Horses\" in ascending order (ASC) instead of descending. 3) When selecting from the \"farm\" table: do not include any GROUP BY clause or COUNT(*) aggregation since the values are already pre-computed in the \"Total_Horses\" column. 4) When producing output: return only the \"Total_Horses\" column values without any aliases or additional columns like \"farm_name\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT farm_name, COUNT(*) as total_horses FROM horses GROUP BY farm_name ORDER BY total_horses DESC;",
            "SELECT Total_Horses FROM farm ORDER BY Total_Horses ASC;"
        ],
        "rule_sql": [
            "SELECT Total_Horses FROM farm ORDER BY Total_Horses ASC;"
        ]
    },
    "543": {
        "db_id": "store_1",
        "question": "Find out 5 customers who most recently purchased something. List customers' first and last name.",
        "ground_truth": "SELECT T1.first_name ,  T1.last_name FROM customers AS T1 JOIN invoices AS T2 ON T2.customer_id  =  T1.id ORDER BY T2.invoice_date DESC LIMIT 5;",
        "amends": [
            "Do add table alias `T1` for the `customers` table instead of using it directly. Do join `invoices AS T2` instead of querying only the `customers` table. Do use join condition `T2.customer_id = T1.id` instead of no join condition. Do reference `T2.invoice_date` in the ORDER BY clause instead of `purchase_date`. The amended query now correctly retrieves customer names ordered by their most recent invoice date rather than a purchase date field that may not exist or be appropriate."
        ],
        "rules": [
            "1) When answering about \"customers who most recently purchased something\": make sure the output order: first_name, last_name. 2) When the question mentions \"purchased something\": \"purchased something\" actually means \"has an invoice in invoices table\" in schema. 3) When combining T1 (customers) and T2 (invoices) for shared entities: link rows where T2.customer_id = T1.id; keep only matching pairs (inner match). 4) When the question asks for \"most recently purchased\": rank rows by T2.invoice_date in descending order and keep the first 5 rows. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM customers ORDER BY purchase_date DESC LIMIT 5;",
            "SELECT T1.first_name, T1.last_name\nFROM customers AS T1\nJOIN invoices AS T2 ON T2.customer_id = T1.id\nORDER BY T2.invoice_date DESC\nLIMIT 5"
        ],
        "rule_sql": [
            "SELECT c.first_name, c.last_name\nFROM customers c\nINNER JOIN invoices i ON i.customer_id = c.id\nORDER BY i.invoice_date DESC\nLIMIT 5"
        ]
    },
    "4453": {
        "db_id": "network_2",
        "question": "Who are Bob's friends?",
        "ground_truth": "SELECT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T1.name  =  'Bob'",
        "amends": [
            "Do select `T2.friend` instead of `*` from all columns. Do use `Person AS T1 JOIN PersonFriend AS T2` instead of just `users` table. Do add join condition `ON T1.name = T2.name` instead of no join. Do keep filter `WHERE T1.name = 'Bob'` but apply it to the joined table structure instead of a single table. The amended query now correctly retrieves friends from the relationship table instead of attempting to find users directly."
        ],
        "rules": [
            "1) When answering about \"Bob's friends\": make sure the output order: T2.friend\n2) When the question mentions \"friends\": \"friends\" actually means \"friend in PersonFriend table\"\n3) When combining Person as T1 and PersonFriend as T2: link rows where T1.name = T2.name exactly as shown; keep only matching pairs (inner match)\n4) When filtering for Bob: use exact literal 'Bob' with case and spacing preserved for T1.name = 'Bob'"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM users WHERE name = 'Bob';",
            "SELECT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T1.name = 'Bob'"
        ],
        "rule_sql": [
            "SELECT T2.friend FROM Person AS T1 INNER JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T1.name = 'Bob' ORDER BY T2.friend"
        ]
    },
    "5431": {
        "db_id": "shop_membership",
        "question": "What are the member names and hometowns of those who registered at a branch in 2016?",
        "ground_truth": "SELECT T2.name ,  T2.hometown FROM membership_register_branch AS T1 JOIN member AS T2 ON T1.member_id  =  T2.member_id WHERE T1.register_year  =  2016",
        "amends": [
            "Do use `T2.name` and `T2.hometown` instead of `member_name` and `hometown`. Do join `membership_register_branch AS T1` with `member AS T2` on `T1.member_id = T2.member_id` instead of querying a single `members` table. Do filter on `T1.register_year = 2016` instead of `registration_year = 2016`. The amended query now correctly joins the membership register with member details to filter by registration year, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for member names and hometowns: use \"T2.name\" and \"T2.hometown\" as output columns. 2) When combining membership register and member information: join \"membership_register_branch AS T1\" with \"member AS T2\" where \"T1.member_id = T2.member_id\" and keep only matching pairs (inner match). 3) When filtering for registrations in 2016: use the condition \"T1.register_year = 2016\" exactly as specified."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT member_name, hometown FROM members WHERE registration_year = 2016;",
            "SELECT T2.Name, T2.Hometown \nFROM membership_register_branch AS T1\nJOIN member AS T2 ON T1.Member_ID = T2.Member_ID\nWHERE T1.Register_Year = '2016'"
        ],
        "rule_sql": [
            "SELECT T2.Name, T2.Hometown FROM membership_register_branch AS T1 JOIN member AS T2 ON T1.Member_ID = T2.Member_ID WHERE T1.Register_Year = '2016'"
        ]
    },
    "6228": {
        "db_id": "ship_1",
        "question": "Find the name, class and rank of all captains.",
        "ground_truth": "SELECT name ,  CLASS ,  rank FROM captain",
        "amends": [
            "Do reference table `captain` instead of `captains` in the FROM clause, as the correct table name is singular rather than plural. The SELECT list remains identical with columns `name`, `class`, and `rank` preserved in both queries. The WHERE filter condition `rank = 'Captain'` is maintained without changes. The amended query now correctly references the intended table structure and matches the RIGHT_SQL's behavior.",
            "Do maintain the same SELECT list with `name`, `class`, and `rank` instead of changing any columns. Do keep the FROM clause with `captain` table instead of adding or removing any tables. Do remove the WHERE filter `rank = 'Captain'` instead of keeping it, as the right query returns all records without filtering. The amended query now matches the right SQL's behavior of selecting all captains regardless of rank."
        ],
        "rules": [
            "1) When the question asks about \"captains\": use the table name \"captain\" (singular form) instead of \"captains\" (plural form). 2) When selecting information about captains: include columns \"name\", \"class\", and \"rank\" in the output. 3) When filtering for captains: only include rows where the \"rank\" column equals exactly 'Captain' (case-sensitive match).",
            "1) When answering about \"all captains\": make sure the output order: name, class, rank. 2) When the question asks for all records without filtering: do not apply any WHERE conditions that restrict the results. 3) When selecting from the captain table: use the exact column names name, class, and rank as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, class, rank FROM captains WHERE rank = 'Captain';",
            "SELECT name, class, rank FROM captain WHERE rank = 'Captain'",
            "SELECT name, class, rank FROM captain"
        ],
        "rule_sql": [
            "SELECT name, class, rank FROM captain;"
        ]
    },
    "6059": {
        "db_id": "customers_and_addresses",
        "question": "What is the average amount of items ordered in each order?",
        "ground_truth": "SELECT avg(order_quantity) FROM order_items",
        "amends": [
            "Do use the column alias `avg(order_quantity)` instead of the unaliased `AVG(quantity)` to properly reference the aggregated result. Do remove the `GROUP BY order_id` clause instead of keeping it, as the right query calculates a single overall average rather than per-order averages. The amended query now correctly computes the global average order quantity across all records in the order_items table, matching the right SQL's behavior of returning a single aggregated value."
        ],
        "rules": [
            "1) When calculating an average across all records: compute a single overall average value rather than per-group averages. 2) When the question asks for \"average amount of items ordered\": use the exact column \"quantity\" from the order_items table to compute the average. 3) When presenting aggregated results: provide a descriptive alias \"avg(order_quantity)\" for the computed average value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(quantity) FROM order_items GROUP BY order_id;",
            "SELECT AVG(order_quantity) AS \"avg(order_quantity)\" FROM Order_Items;"
        ],
        "rule_sql": [
            "SELECT AVG(CAST(order_quantity AS REAL)) AS \"avg(order_quantity)\" FROM Order_Items;"
        ]
    },
    "3316": {
        "db_id": "college_1",
        "question": "What are the first names, office locations, and departments of all instructors, and also what are the descriptions of the courses they teach?",
        "ground_truth": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code",
        "amends": [
            "Do use `T2.emp_fname` instead of `i.first_name` for the employee first name column. Do use `T4.prof_office` instead of `i.office_location` for the office location. Do use `T3.crs_description` instead of `c.description` for the course description. Do add `T5.dept_name` instead of omitting the department name. Do change from a single `LEFT JOIN` on `instructors` and `courses` to multiple `JOIN` operations connecting `CLASS`, `employee`, `course`, `professor`, and `department` tables. Do use proper join conditions: `T1.prof_num = T2.emp_num` instead of `i.instructor_id = c.instructor_id`, `T1.crs_code = T3.crs_code` for course linkage, `T2.emp_num = T4.emp_num` for professor details, and `T4.dept_code = T5.dept_code` for department information. The amended query now correctly joins across all five required tables to retrieve comprehensive employee, course, professor, and department data, matching the RIGHT_SQL's behavior.",
            "Do reorder the SELECT list to `T2.emp_fname, T4.prof_office, T3.crs_description, T5.dept_name` instead of `T2.EMP_FNAME, T4.PROF_OFFICE, T5.DEPT_NAME, T3.CRS_DESCRIPTION` to match the column sequence. Do use lowercase column names `emp_fname`, `prof_office`, `crs_description`, and `dept_name` instead of uppercase `EMP_FNAME`, `PROF_OFFICE`, `DEPT_NAME`, and `CRS_DESCRIPTION` for consistency. Do add explicit `AS` aliases for table references `CLASS AS T1`, `employee AS T2`, `course AS T3`, `professor AS T4`, and `department AS T5` instead of omitting them. The amended query now correctly matches the RIGHT_SQL's behavior with proper column ordering, case consistency, and explicit table aliasing."
        ],
        "rules": [
            "1) When answering about instructor information: use T2.emp_fname for first names, T4.prof_office for office locations, and T5.dept_name for departments 2) When answering about course descriptions: use T3.crs_description for course descriptions 3) When combining tables for instructor and course data: link CLASS (T1) with employee (T2) using T1.prof_num = T2.emp_num, CLASS (T1) with course (T3) using T1.crs_code = T3.crs_code, employee (T2) with professor (T4) using T2.emp_num = T4.emp_num, and professor (T4) with department (T5) using T4.dept_code = T5.dept_code 4) When retrieving comprehensive instructor and course information: join all five tables (CLASS, employee, course, professor, department) using inner matches to ensure complete data relationships",
            "1) When answering about \"first names, office locations, and departments of all instructors, and also what are the descriptions of the courses they teach\": make sure the output order: emp_fname, prof_office, crs_description, dept_name. 2) When referring to column names: use lowercase identifiers emp_fname, prof_office, crs_description, and dept_name instead of uppercase versions. 3) When combining tables for instructor information: link CLASS AS T1 with EMPLOYEE AS T2 where T1.PROF_NUM = T2.EMP_NUM, COURSE AS T3 where T1.CRS_CODE = T3.CRS_CODE, PROFESSOR AS T4 where T2.EMP_NUM = T4.EMP_NUM, and DEPARTMENT AS T5 where T4.DEPT_CODE = T5.DEPT_CODE. 4) When using table aliases: explicitly use AS for all table references (CLASS AS T1, employee AS T2, course AS T3, professor AS T4, department AS T5)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT i.first_name, i.office_location, i.department, c.description\nFROM instructors i\nLEFT JOIN courses c ON i.instructor_id = c.instructor_id;",
            "SELECT T2.EMP_FNAME, T4.PROF_OFFICE, T5.DEPT_NAME, T3.CRS_DESCRIPTION\nFROM CLASS T1\nJOIN EMPLOYEE T2 ON T1.PROF_NUM = T2.EMP_NUM\nJOIN COURSE T3 ON T1.CRS_CODE = T3.CRS_CODE\nJOIN PROFESSOR T4 ON T2.EMP_NUM = T4.EMP_NUM\nJOIN DEPARTMENT T5 ON T4.DEPT_CODE = T5.DEPT_CODE",
            "SELECT T2.emp_fname, T4.prof_office, T3.crs_description, T5.dept_name\nFROM CLASS AS T1\nJOIN employee AS T2 ON T1.prof_num = T2.emp_num\nJOIN course AS T3 ON T1.crs_code = T3.crs_code\nJOIN professor AS T4 ON T2.emp_num = T4.emp_num\nJOIN department AS T5 ON T4.dept_code = T5.dept_code"
        ],
        "rule_sql": [
            "SELECT T2.emp_fname, T4.prof_office, T3.crs_description, T5.dept_name\nFROM CLASS AS T1\nINNER JOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM\nINNER JOIN COURSE AS T3 ON T1.CRS_CODE = T3.CRS_CODE\nINNER JOIN PROFESSOR AS T4 ON T2.EMP_NUM = T4.EMP_NUM\nINNER JOIN DEPARTMENT AS T5 ON T4.DEPT_CODE = T5.DEPT_CODE"
        ]
    },
    "3434": {
        "db_id": "hr_1",
        "question": "What are the salaries and manager ids for employees who have managers?",
        "ground_truth": "SELECT salary ,  manager_id FROM employees WHERE manager_id != \"null\"",
        "amends": [
            "Do use `!= \"null\"` for string comparison instead of `IS NULL` for NULL value checking, as the right SQL correctly handles the case where manager_id contains the literal string \"null\" rather than being a true NULL value. The amended query now matches RIGHT_SQL's behavior by properly filtering for non-\"null\" string values instead of NULL database values."
        ],
        "rules": [
            "1) When filtering for employees who have managers: use comparison with the literal string \"null\" instead of NULL value checking, specifically use manager_id != \"null\" to properly handle string values that contain the literal \"null\" text. 2) When selecting output columns for employees with managers: include both salary and manager_id columns in the result set."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT salary, manager_id FROM employees WHERE manager_id IS NULL",
            "SELECT SALARY, MANAGER_ID FROM employees WHERE MANAGER_ID != \"null\""
        ],
        "rule_sql": [
            "SELECT salary, manager_id FROM employees WHERE manager_id != \"null\""
        ]
    },
    "2820": {
        "db_id": "restaurant_1",
        "question": "Show me all the restaurants.",
        "ground_truth": "SELECT ResName FROM Restaurant;",
        "amends": [
            "Do select only `ResName` instead of all columns with `*`. Do reference the correct table name `Restaurant` instead of `restaurants`. Do remove the `WHERE id = 999` filter instead of keeping it, as the query should return all restaurant names rather than filtering for a specific ID. The amended query now correctly retrieves all restaurant names from the Restaurant table without unnecessary filtering."
        ],
        "rules": [
            "1) When answering about \"all restaurants\": make sure the output order: \"ResName\" 2) When the question mentions \"restaurants\": \"restaurants\" actually means \"Restaurant\" in schema 3) When selecting columns: use only \"ResName\" instead of all columns with * 4) When filtering is not specified: do not include any WHERE conditions like id = 999"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM restaurants WHERE id = 999;",
            "SELECT ResName FROM Restaurant;"
        ],
        "rule_sql": [
            "SELECT ResName FROM Restaurant ORDER BY ResName;"
        ]
    },
    "2538": {
        "db_id": "county_public_safety",
        "question": "What are the minimum and maximum crime rate of counties?",
        "ground_truth": "SELECT min(Crime_rate) ,  max(Crime_rate) FROM county_public_safety",
        "amends": [
            "Do reference table `county_public_safety` instead of `states` to ensure the crime rate data is sourced from the correct dataset containing county-level public safety statistics. The amended query now correctly aggregates minimum and maximum crime rates from the appropriate county public safety table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about crime rates of counties: use table \"county_public_safety\" instead of \"states\" to access county-level public safety statistics. 2) When computing minimum and maximum crime rates: aggregate the \"crime_rate\" column from the \"county_public_safety\" table using MIN and MAX functions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(crime_rate), MAX(crime_rate) FROM states;",
            "SELECT MIN(Crime_rate) AS min_crime_rate, MAX(Crime_rate) AS max_crime_rate FROM county_public_safety;"
        ],
        "rule_sql": [
            "SELECT MIN(crime_rate) AS min_crime_rate, MAX(crime_rate) AS max_crime_rate FROM county_public_safety;"
        ]
    },
    "4691": {
        "db_id": "college_3",
        "question": "Find the distinct student first names of all students that have grade point at least 3.8 in one course.",
        "ground_truth": "SELECT DISTINCT T3.Fname FROM ENROLLED_IN AS T1 JOIN GRADECONVERSION AS T2 JOIN STUDENT AS T3 ON T1.Grade  =  T2.lettergrade AND T1.StuID  =  T3.StuID WHERE T2.gradepoint  >=  3.8",
        "amends": [
            "Do use `T3.Fname` instead of `first_name` and add explicit table aliases throughout. Do join three tables `ENROLLED_IN AS T1`, `GRADECONVERSION AS T2`, and `STUDENT AS T3` instead of querying a single `students` table. Do specify join conditions `T1.Grade = T2.lettergrade` and `T1.StuID = T3.StuID` instead of having no joins. Do filter on `T2.gradepoint >= 3.8` instead of `grade_point >= 3.8` to reference the correct table's grade point values. The amended query now correctly joins enrollment records with grade conversions and student information to identify students with high grade point averages, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"distinct student first names of students with grade point at least 3.8\": make sure the output order: T3.Fname. 2) When the question mentions \"grade point at least 3.8\": \"grade point\" actually means \"T2.gradepoint >= 3.8\" in schema. 3) When combining tables ENROLLED_IN as T1, GRADECONVERSION as T2, and STUDENT as T3: link rows where T1.Grade = T2.lettergrade and T1.StuID = T3.StuID; keep only matching pairs (inner match). 4) When the question asks for \"distinct student first names\": compute the number of unique values of T3.Fname."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT first_name FROM students WHERE grade_point >= 3.8",
            "SELECT DISTINCT T3.Fname\nFROM Enrolled_in AS T1\nJOIN Gradeconversion AS T2 ON T1.Grade = T2.lettergrade\nJOIN Student AS T3 ON T1.StuID = T3.StuID\nWHERE T2.gradepoint >= 3.8"
        ],
        "rule_sql": [
            "SELECT DISTINCT T3.Fname\nFROM Enrolled_in AS T1\nINNER JOIN Gradeconversion AS T2 ON T1.Grade = T2.lettergrade\nINNER JOIN Student AS T3 ON T1.StuID = T3.StuID\nWHERE T2.gradepoint >= 3.8\nORDER BY T3.Fname;"
        ]
    },
    "2842": {
        "db_id": "customer_deliveries",
        "question": "Find the ids of orders whose status is 'Success'.",
        "ground_truth": "SELECT actual_order_id FROM actual_orders WHERE order_status_code  =  'Success'",
        "amends": [
            "Do select `actual_order_id` instead of `id` and use table `actual_orders` instead of `orders`. Do filter on `order_status_code = 'Success'` instead of `status = 'Failed'` to retrieve successful orders rather than failed ones. The amended query now correctly retrieves successful order identifiers from the appropriate table structure."
        ],
        "rules": [
            "1) When answering about \"ids of orders whose status is 'Success'\": use column \"actual_order_id\" from table \"Order_Deliveries\" instead of \"id\" from \"orders\". 2) When filtering for successful orders: use condition \"order_status_code = 'Success'\" instead of \"status = 'Failed'\". 3) When the question mentions \"orders\": the correct table is \"Order_Deliveries\" rather than \"orders\"."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM orders WHERE status = 'Failed';",
            "SELECT actual_order_id FROM Actual_Orders WHERE order_status_code = 'Success';"
        ],
        "rule_sql": [
            "SELECT actual_order_id FROM Order_Deliveries WHERE order_status_code = 'Success'"
        ]
    },
    "5581": {
        "db_id": "products_gen_characteristics",
        "question": "What is the description of the product category with the code 'Spices'?",
        "ground_truth": "SELECT product_category_description FROM ref_product_categories WHERE product_category_code  =  \"Spices\"",
        "amends": [
            "Do select `product_category_description` instead of `description` and use table `ref_product_categories` instead of `product_categories`. Do filter on `product_category_code = \"Spices\"` instead of `category_name = 'Spices'` with proper double quotes for the string literal. The amended query now correctly retrieves the category description from the reference table using the standardized category code field."
        ],
        "rules": [
            "1) When the question asks for \"description of the product category\": use the exact column \"product_category_description\" from table \"ref_product_categories\". 2) When filtering for category code 'Spices': use the exact condition \"product_category_code = \\\"Spices\\\"\" with double quotes around the literal value. 3) When selecting from the product categories reference table: use table name \"ref_product_categories\" instead of \"product_categories\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description FROM product_categories WHERE category_name = 'Spices';",
            "SELECT product_category_description FROM Ref_Product_Categories WHERE product_category_code = \"Spices\""
        ],
        "rule_sql": [
            "SELECT product_category_description FROM ref_product_categories WHERE product_category_code = \"Spices\";"
        ]
    }
}