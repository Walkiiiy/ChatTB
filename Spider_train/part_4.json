{
    "4981": {
        "db_id": "soccer_2",
        "question": "What are the name of the players who received a card in descending order of the hours of training?",
        "ground_truth": "SELECT pName FROM Player WHERE yCard  =  'yes' ORDER BY HS DESC",
        "amends": [
            "Do select `pName` instead of `name` and use `HS` for ordering instead of `training_hours`. Do filter with `yCard = 'yes'` in the `WHERE` clause instead of `card_received = 1` and remove the incorrect placement of `WHERE` after `ORDER BY`. Do reference the `Player` table instead of `players` and ensure proper column names match the table schema. The amended query now correctly filters players who received a yellow card and orders them by their HS value in descending order, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for player names: select \"pName\" from the \"Player\" table. 2) When filtering for players who received a card: use the condition \"yCard = 'yes'\" in the WHERE clause. 3) When ordering by hours of training in descending order: order by \"HS\" in descending order. 4) When constructing the query: place the WHERE clause before the ORDER BY clause."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM players ORDER BY training_hours DESC WHERE card_received = 1;",
            "SELECT pName FROM Player WHERE yCard = 'yes' ORDER BY HS DESC;"
        ],
        "rule_sql": [
            "SELECT pName FROM Player WHERE yCard = 'yes' ORDER BY HS DESC;"
        ]
    },
    "5602": {
        "db_id": "swimming",
        "question": "How many events are there?",
        "ground_truth": "SELECT count(*) FROM event",
        "amends": [
            "Do query the `event` table instead of the `users` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)`. The amended query now correctly counts records from the event table rather than the users table."
        ],
        "rules": [
            "1) When answering about \"how many events\": query the \"event\" table instead of the \"users\" table. 2) When counting records: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" to count all rows from the correct table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users;",
            "SELECT count(*) FROM event;"
        ],
        "rule_sql": [
            "select count(*) from event"
        ]
    },
    "5663": {
        "db_id": "customers_and_products_contacts",
        "question": "How many products have a price higher than the average?",
        "ground_truth": "SELECT count(*) FROM products WHERE product_price  >  (SELECT avg(product_price) FROM products)",
        "amends": [
            "Do reference `product_price` column instead of `price` in both the main WHERE clause and subquery filter, as the correct column name is `product_price`. Do use `avg(product_price)` in the subquery instead of `AVG(price)` to match the correct column reference. The amended query now correctly counts products where the product price exceeds the average product price across all products, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"price\" of products: use the exact column name \"product_price\" from the Products table. 2) When computing average price across all products: calculate the average of the \"product_price\" column. 3) When counting products with price higher than average: count rows where \"product_price\" is greater than the computed average of \"product_price\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM products WHERE price > (SELECT AVG(price) FROM products);",
            "SELECT COUNT(*) \nFROM Products \nWHERE product_price > (SELECT AVG(product_price) FROM Products)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS count_products_above_avg\nFROM Products\nWHERE product_price > (SELECT AVG(product_price) FROM Products);"
        ]
    },
    "5692": {
        "db_id": "dorm_1",
        "question": "Find the name of dorms that do not have any amenity",
        "ground_truth": "SELECT dorm_name FROM dorm WHERE dormid NOT IN (SELECT dormid FROM has_amenity)",
        "amends": [
            "Do select `dorm_name` instead of `name` and use a subquery with `NOT IN` instead of checking for `IS NULL`. Do reference table `dorm` instead of `dorms` and use `dormid` as the join key instead of relying on a direct null check. Do remove the direct null filter on `amenity` and instead use a correlated subquery that checks for existence in the `has_amenity` table. The amended query now correctly identifies dorms without amenities by checking for dormids that don't exist in the has_amenity relationship table instead of relying on a potentially incorrect null check in the main table."
        ],
        "rules": [
            "1) When the question asks for \"name of dorms\": use the exact column token \"dorm_name\" from table \"Dorm\" instead of \"name\". 2) When checking for dorms without amenities: use a subquery with \"NOT IN\" instead of checking for \"IS NULL\" on amenity columns. 3) When referencing the dorm table: use table name \"Dorm\" instead of \"dorms\". 4) When joining or checking relationships between dorms and amenities: use \"dormid\" as the canonical key for identification and linking. 5) When identifying dorms without amenities: check for dormids that don't exist in the relationship table \"has_amenity\" instead of relying on direct null checks in the main table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM dorms WHERE amenity IS NULL;",
            "SELECT dorm_name FROM Dorm WHERE dormid NOT IN (SELECT dormid FROM Has_amenity)"
        ],
        "rule_sql": [
            "SELECT dorm_name FROM Dorm WHERE dormid NOT IN (SELECT dormid FROM Has_amenity)"
        ]
    },
    "6656": {
        "db_id": "driving_school",
        "question": "List the states which have between 2 to 4 staffs living there.",
        "ground_truth": "SELECT T1.state_province_county FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id GROUP BY T1.state_province_county HAVING count(*) BETWEEN 2 AND 4;",
        "amends": [
            "Do select `T1.state_province_county` instead of `state` and remove the `staff_count` alias instead of keeping it. Do join `Addresses AS T1` with `Staff AS T2` on `T1.address_id = T2.staff_address_id` instead of querying only the `staff` table. Do group by `T1.state_province_county` instead of `state` and use `count(*) BETWEEN 2 AND 4` instead of `staff_count >= 2 AND staff_count <= 4` in the HAVING clause. The amended query now correctly joins address data with staff information and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"states which have between 2 to 4 staffs living there\": make sure the output order: T1.state_province_county 2) When the question mentions \"states\": \"states\" actually means \"T1.state_province_county in schema\" 3) When combining Addresses as T1 and Staff as T2 for shared entities: link rows where T1.address_id = T2.staff_address_id exactly as shown in the amends; keep only matching pairs (inner match) 4) When the question says \"per state\"/\"by state\": organize results by T1.state_province_county and compute requested aggregates per group 5) When the question asks for \"count of staffs\": compute the number of rows using the canonical key from the join (T2.staff_address_id) 6) When the question asks for \"between 2 to 4 staffs\": use count(*) BETWEEN 2 AND 4 in the HAVING clause instead of separate >= and <= conditions"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT state, COUNT(*) as staff_count FROM staff GROUP BY state HAVING staff_count >= 2 AND staff_count <= 4",
            "SELECT T1.state_province_county\nFROM Addresses AS T1\nJOIN Staff AS T2 ON T1.address_id = T2.staff_address_id\nGROUP BY T1.state_province_county\nHAVING COUNT(*) BETWEEN 2 AND 4"
        ],
        "rule_sql": [
            "SELECT T1.state_province_county\nFROM Addresses T1\nINNER JOIN Staff T2 ON T1.address_id = T2.staff_address_id\nGROUP BY T1.state_province_county\nHAVING COUNT(*) BETWEEN 2 AND 4\nORDER BY T1.state_province_county;"
        ]
    },
    "6931": {
        "db_id": "tracking_orders",
        "question": "What is the name of the customer who has the largest number of orders?",
        "ground_truth": "SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name FROM customers ORDER BY customer_id DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT c.customer_name\nFROM Customers c\nJOIN Orders o ON c.customer_id = o.customer_id\nGROUP BY c.customer_id, c.customer_name\nORDER BY COUNT(o.order_id) DESC\nLIMIT 1;",
            "SELECT c.customer_name\nFROM Customers c\nJOIN Orders o ON c.customer_id = o.customer_id\nGROUP BY c.customer_id, c.customer_name\nORDER BY COUNT(o.order_id) DESC\nLIMIT 1;"
        ]
    },
    "4125": {
        "db_id": "film_rank",
        "question": "Count the number of markets that have a number of cities lower than 300.",
        "ground_truth": "SELECT count(*) FROM market WHERE Number_cities  <  300",
        "amends": [
            "Do reference table `market` instead of `markets` to use the correct table name. Do use column `Number_cities` instead of `cities` to reference the proper column that contains city count data. Do maintain the same aggregate function `count(*)` and filter condition `< 300` as these elements remain functionally equivalent between the queries. The amended query now correctly counts records from the market table where the number of cities is less than 300, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"markets\": use the exact table name \"market\" with double quotes as shown in the schema. 2) When the question mentions \"number of cities\": use the exact column name \"Number_cities\" with double quotes from the market table. 3) When counting the number of markets: count all rows from the market table where the Number_cities value is less than 300."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM markets WHERE cities < 300;",
            "SELECT COUNT(*) FROM market WHERE Number_cities < 300"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM \"market\" WHERE \"Number_cities\" < 300"
        ]
    },
    "2079": {
        "db_id": "party_people",
        "question": "find the event names that have more than 2 records.",
        "ground_truth": "SELECT event_name FROM party_events GROUP BY event_name HAVING count(*)  >  2",
        "amends": [
            "Do use `GROUP BY event_name` with `HAVING count(*) > 2` instead of applying `COUNT(*) > 2` directly in the `WHERE` clause, which is invalid syntax for aggregate functions. Do reference the correct table `party_events` instead of `events` to ensure the query operates on the intended data source. The amended query now properly groups events by name and filters for those occurring more than twice, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for event names with more than 2 records: group results by \"event_name\" from table \"party_events\" and filter groups where the count of rows is greater than 2. 2) When counting occurrences of events: use the count of all rows (*) to determine how many times each event appears. 3) When filtering based on aggregate conditions: apply the count condition in a having clause after grouping, not in a where clause before grouping."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT event_name FROM events WHERE COUNT(*) > 2",
            "SELECT Event_Name FROM party_events GROUP BY Event_Name HAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT Event_Name FROM party_events GROUP BY Event_Name HAVING COUNT(*) > 2"
        ]
    },
    "4796": {
        "db_id": "department_store",
        "question": "What is the name of the hardware product with the greatest price?",
        "ground_truth": "SELECT product_name FROM products WHERE product_type_code  =  'Hardware' ORDER BY product_price DESC LIMIT 1",
        "amends": [
            "Do select `product_name` from the `products` table instead of `name` from `hardware`. Do add a `WHERE` filter for `product_type_code = 'Hardware'` instead of omitting any filtering condition. Do order by `product_price DESC` instead of `price ASC`. Do use the correct table name `products` instead of `hardware`. The amended query now correctly filters for hardware products and retrieves the most expensive hardware product instead of the cheapest item from an incorrect table."
        ],
        "rules": [
            "1) When answering about \"hardware product with the greatest price\": make sure the output order: product_name. 2) When the question mentions \"hardware product\": \"hardware product\" actually means \"product_type_code = 'Hardware'\" in schema. 3) When the question mentions \"greatest price\": order rows by product_price in descending direction and keep the first 1 row. 4) When selecting from the products table: use the exact table name \"products\" instead of \"hardware\". 5) When selecting the product name: use the exact column name \"product_name\" instead of \"name\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM hardware ORDER BY price ASC LIMIT 1;",
            "SELECT product_name FROM Products WHERE product_type_code = 'Hardware' ORDER BY product_price DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT product_name FROM Products WHERE product_type_code = 'Hardware' ORDER BY product_price DESC LIMIT 1;"
        ]
    },
    "2904": {
        "db_id": "icfp_1",
        "question": "Find the titles of the papers that contain the word \"ML\".",
        "ground_truth": "SELECT title FROM papers WHERE title LIKE \"%ML%\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM papers WHERE title LIKE '%ML%';"
        ],
        "rule_sql": [
            "SELECT title FROM Papers WHERE title LIKE '%ML%';"
        ]
    },
    "2182": {
        "db_id": "formula_1",
        "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?",
        "ground_truth": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = \"Australian Grand Prix\" EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = \"Chinese Grand Prix\"",
        "amends": [
            "Do use `forename` and `surname` instead of `first_name` and `last_name` for driver name columns. Do join `races` to `results` instead of `race_participation` and use `raceid` and `driverid` instead of `race_id` and `driver_id` for join conditions. Do use `EXCEPT` instead of `NOT IN` with a subquery to find drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix. Do reference tables as `T1`, `T2`, and `T3` with explicit aliases instead of single-letter aliases. Do use double quotes around race names instead of single quotes. The amended query now correctly identifies drivers using the results table structure and employs set operations for cleaner exclusion logic."
        ],
        "rules": [
            "1) When the question asks for first and last names of drivers: use \"forename\" and \"surname\" columns from the drivers table instead of \"first_name\" and \"last_name\". 2) When joining tables to find race participation: join \"races\" to \"results\" table using \"raceid\" and \"driverid\" columns instead of using a \"race_participation\" table. 3) When finding drivers who participated in one race but not another: use EXCEPT set operation instead of NOT IN with a subquery. 4) When referencing race names in conditions: use double quotes around literal values like \"Australian Grand Prix\" and \"Chinese Grand Prix\" instead of single quotes. 5) When assigning table aliases: use T1, T2, and T3 as explicit aliases instead of single-letter aliases."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.first_name, d.last_name \nFROM drivers d\nJOIN race_participation rp ON d.driver_id = rp.driver_id\nJOIN races r ON rp.race_id = r.race_id\nWHERE r.race_name = 'Australian Grand Prix'\nAND d.driver_id NOT IN (\n    SELECT d2.driver_id\n    FROM drivers d2\n    JOIN race_participation rp2 ON d2.driver_id = rp2.driver_id\n    JOIN races r2 ON rp2.race_id = r2.race_id\n    WHERE r2.race_name = 'Chinese Grand Prix'\n)",
            "SELECT T1.forename, T1.surname\nFROM drivers T1\nJOIN results T2 ON T1.driverId = T2.driverId\nJOIN races T3 ON T2.raceId = T3.raceId\nWHERE T3.name = \"Australian Grand Prix\"\nEXCEPT\nSELECT T1.forename, T1.surname\nFROM drivers T1\nJOIN results T2 ON T1.driverId = T2.driverId\nJOIN races T3 ON T2.raceId = T3.raceId\nWHERE T3.name = \"Chinese Grand Prix\""
        ],
        "rule_sql": [
            "SELECT T1.forename, T1.surname\nFROM drivers T1\nJOIN results T2 ON T1.driverId = T2.driverId\nJOIN races T3 ON T2.raceId = T3.raceId\nWHERE T3.name = \"Australian Grand Prix\"\nEXCEPT\nSELECT T1.forename, T1.surname\nFROM drivers T1\nJOIN results T2 ON T1.driverId = T2.driverId\nJOIN races T3 ON T2.raceId = T3.raceId\nWHERE T3.name = \"Chinese Grand Prix\""
        ]
    },
    "2530": {
        "db_id": "movie_1",
        "question": "What are the names of movies that get 3 star and 4 star?",
        "ground_truth": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  3 INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  4",
        "amends": [
            "Do use `INTERSECT` to find titles with both ratings instead of `OR` to find titles with either rating. Do join `Rating` and `Movie` tables on `mID` instead of querying a single table. Do reference columns as `T2.title` instead of `name`. Do filter for `stars = 3` in one branch and `stars = 4` in another instead of using `OR` in a single filter. Do add table aliases `T1` and `T2` instead of omitting them. The amended query now correctly finds movies that have received both 3-star and 4-star ratings rather than movies with either rating."
        ],
        "rules": [
            "1) When the question asks for movies with both 3 star and 4 star ratings: use INTERSECT to combine results from two separate queries instead of OR in a single filter. 2) When combining Rating and Movie tables: link rows where T1.mID = T2.mID using an inner join. 3) When filtering for specific star ratings: filter for stars = 3 in one branch and stars = 4 in another branch separately. 4) When referencing movie names: use T2.title instead of name as the output column. 5) When using table aliases: assign T1 to Rating table and T2 to Movie table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM movies WHERE stars = 3 OR stars = 4;",
            "SELECT T2.title\nFROM Rating T1\nJOIN Movie T2 ON T1.mID = T2.mID\nWHERE T1.stars = 3\nINTERSECT\nSELECT T2.title\nFROM Rating T1\nJOIN Movie T2 ON T1.mID = T2.mID\nWHERE T1.stars = 4"
        ],
        "rule_sql": [
            "SELECT T2.title FROM Rating T1 INNER JOIN Movie T2 ON T1.mID = T2.mID WHERE T1.stars = 3\nINTERSECT\nSELECT T2.title FROM Rating T1 INNER JOIN Movie T2 ON T1.mID = T2.mID WHERE T1.stars = 4"
        ]
    },
    "784": {
        "db_id": "race_track",
        "question": "What are the names and dates of races, and the names of the tracks where they are held?",
        "ground_truth": "SELECT T1.name ,  T1.date ,  T2.name FROM race AS T1 JOIN track AS T2 ON T1.track_id  =  T2.track_id",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference columns as `T1.name` and `T1.date` instead of `race_name` and `race_date`. Do reference the joined table column as `T2.name` instead of `track_name`. Do join on `T1.track_id = T2.track_id` instead of `races.track_id = tracks.id`. Do use table names `race` and `track` instead of `races` and `tracks`. The amended query now correctly joins on the matching track_id columns between the race and track tables."
        ],
        "rules": [
            "1) When answering about race names and dates and track names: make sure the output order: T1.name, T1.date, T2.name 2) When combining race table (T1) and track table (T2) for shared entities: link rows where T1.track_id = T2.track_id exactly as shown; keep only matching pairs (inner match) 3) When the question mentions \"names of races\": \"names\" actually means \"T1.name in schema\" 4) When the question mentions \"dates of races\": \"dates\" actually means \"T1.date in schema\" 5) When the question mentions \"names of tracks\": \"names\" actually means \"T2.name in schema\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT race_name, race_date, track_name FROM races JOIN tracks ON races.track_id = tracks.id",
            "SELECT T1.Name, T1.Date, T2.Name FROM race T1 JOIN track T2 ON T1.Track_ID = T2.Track_ID"
        ],
        "rule_sql": [
            "SELECT T1.Name, T1.Date, T2.Name FROM race T1 INNER JOIN track T2 ON T1.Track_ID = T2.Track_ID ORDER BY T1.Name, T1.Date, T2.Name"
        ]
    },
    "2064": {
        "db_id": "party_people",
        "question": "What are the names of parties that have no members?",
        "ground_truth": "SELECT party_name FROM party WHERE party_id NOT IN (SELECT party_id FROM Member)",
        "amends": [
            "Do select `party_name` instead of `name` and change the source table to `party` instead of `parties`. Do remove the `member_count > 0` filter from the `WHERE` clause and instead add a `NOT IN` subquery condition that excludes parties found in the `Member` table's `party_id` column. The amended query now correctly identifies parties without members by checking against the membership table rather than relying on a potentially incorrect count field, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for party names: use the exact column token \"party_name\" from the \"party\" table. 2) When identifying parties without members: exclude parties that appear in the \"Member\" table's \"party_id\" column using a NOT IN condition. 3) When the schema shows table names without quotes: use the exact table names \"party\" and \"Member\" without additional quoting."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM parties WHERE member_count > 0;",
            "SELECT party_name FROM party WHERE Party_ID NOT IN (SELECT DISTINCT Party_ID FROM member)"
        ],
        "rule_sql": [
            "SELECT party_name FROM party WHERE Party_ID NOT IN (SELECT Party_ID FROM member)"
        ]
    },
    "3986": {
        "db_id": "hospital_1",
        "question": "Find the name of physicians who are affiliated with both Surgery and Psychiatry departments.",
        "ground_truth": "SELECT T1.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T3.name  =  'Surgery' INTERSECT SELECT T1.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T3.name  =  'Psychiatry'",
        "amends": [
            "Do join `physician AS T1`, `affiliated_with AS T2`, and `department AS T3` tables instead of querying only the `physicians` table. Do use `JOIN` conditions `T1.EmployeeID = T2.physician` and `T2.department = T3.DepartmentID` instead of incorrect direct column filtering. Do filter with `T3.name = 'Surgery'` and `T3.name = 'Psychiatry'` in separate queries instead of the impossible `department = 'Surgery' AND department = 'Psychiatry'` condition. Do use `INTERSECT` to find physicians affiliated with both departments instead of attempting to satisfy contradictory conditions in a single WHERE clause. Do select from properly joined relational tables instead of assuming department information exists directly in the physician table. The amended query now correctly identifies physicians who are affiliated with both Surgery and Psychiatry departments through the appropriate table relationships."
        ],
        "rules": [
            "1) When answering about physicians affiliated with multiple departments: join tables \"physician\" as T1, \"affiliated_with\" as T2, and \"department\" as T3 instead of querying only the \"physicians\" table. 2) When combining physician and affiliated_with tables: link rows where T1.EmployeeID equals T2.physician. 3) When combining affiliated_with and department tables: link rows where T2.department equals T3.DepartmentID. 4) When filtering for Surgery department: use condition T3.name = 'Surgery' with exact case and spacing. 5) When filtering for Psychiatry department: use condition T3.name = 'Psychiatry' with exact case and spacing. 6) When finding physicians affiliated with both departments: use INTERSECT operation between separate queries for each department instead of combining conditions in a single WHERE clause. 7) When selecting physician names: output the name column from the physician table (T1.name)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM physicians WHERE department = 'Surgery' AND department = 'Psychiatry'",
            "SELECT T1.Name\nFROM Physician AS T1\nJOIN Affiliated_With AS T2 ON T1.EmployeeID = T2.Physician\nJOIN Department AS T3 ON T2.Department = T3.DepartmentID\nWHERE T3.Name = 'Surgery'\nINTERSECT\nSELECT T1.Name\nFROM Physician AS T1\nJOIN Affiliated_With AS T2 ON T1.EmployeeID = T2.Physician\nJOIN Department AS T3 ON T2.Department = T3.DepartmentID\nWHERE T3.Name = 'Psychiatry'"
        ],
        "rule_sql": [
            "SELECT T1.Name\nFROM Physician AS T1\nJOIN Affiliated_With AS T2 ON T1.EmployeeID = T2.Physician\nJOIN Department AS T3 ON T2.Department = T3.DepartmentID\nWHERE T3.Name = 'Surgery'\nINTERSECT\nSELECT T1.Name\nFROM Physician AS T1\nJOIN Affiliated_With AS T2 ON T1.EmployeeID = T2.Physician\nJOIN Department AS T3 ON T2.Department = T3.DepartmentID\nWHERE T3.Name = 'Psychiatry'"
        ]
    },
    "168": {
        "db_id": "bike_1",
        "question": "On which day has it neither been foggy nor rained in the zip code of 94107?",
        "ground_truth": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != \"Fog\" AND EVENTS != \"Rain\"",
        "amends": [
            "Do reference the `EVENTS` column instead of separate boolean columns `foggy` and `rain`. Do filter for `EVENTS != \"Fog\"` instead of checking `foggy = 1`. Do filter for `EVENTS != \"Rain\"` instead of checking `rain = 1`. The amended query now correctly excludes fog and rain events by checking the EVENTS column values rather than relying on separate boolean flags, matching the RIGHT_SQL's behavior.",
            "Do use `!=` comparison operators instead of `NOT LIKE` for exact string matching. Do specify exact string values `\"Fog\"` and `\"Rain\"` instead of pattern matching with `%` wildcards. Do maintain the same `zip_code = 94107` filter and `SELECT date` structure. The amended query now correctly filters for exact event values rather than performing pattern matching, ensuring precise exclusion of Fog and Rain events while maintaining the same zip code constraint."
        ],
        "rules": [
            "1) When the question asks about days without fog or rain: filter for EVENTS column values that are not \"Fog\" and not \"Rain\" instead of using separate boolean columns. 2) When filtering by zip code 94107: use the exact literal value 94107 without quotes for numerical comparison. 3) When selecting date information: return the date column from the weather table.",
            "1) When filtering for exact string values in the \"events\" column: use exact equality comparisons (!=) with the literal values \"Fog\" and \"Rain\" instead of pattern matching with wildcards. 2) When the question specifies zip code 94107: filter using zip_code = 94107 exactly as shown. 3) When answering about days with specific weather conditions: select only the date column from the weather table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT date FROM weather WHERE zip_code = 94107 AND foggy = 1 AND rain = 1;",
            "SELECT date FROM weather WHERE zip_code = 94107 AND events NOT LIKE '%Fog%' AND events NOT LIKE '%Rain%';",
            "SELECT date FROM weather WHERE zip_code = 94107 AND events != 'Fog' AND events != 'Rain';"
        ],
        "rule_sql": [
            "SELECT date FROM weather WHERE zip_code = 94107 AND events != 'Fog' AND events != 'Rain';"
        ]
    },
    "5823": {
        "db_id": "workshop_paper",
        "question": "Compute the average score of submissions.",
        "ground_truth": "SELECT avg(Scores) FROM submission",
        "amends": [
            "Do reference the `Scores` column instead of `score` to match the correct column name. Do reference the `submission` table instead of `submissions` to match the correct table name. Do use lowercase `avg` function instead of uppercase `AVG` for consistency with the correct query. Do remove the `WHERE score > 100` filter instead of keeping it, as the correct query does not include this condition. The amended query now correctly calculates the average of all scores from the submission table without unnecessary filtering."
        ],
        "rules": [
            "1) When the question mentions \"score\": \"score\" actually means \"Scores\" in the schema. 2) When the question mentions \"submissions\": \"submissions\" actually means \"submission\" table in the schema. 3) When computing averages: use lowercase \"avg\" function instead of uppercase \"AVG\" for consistency. 4) When answering about average score of submissions: do not apply any WHERE filter conditions unless explicitly specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(score) FROM submissions WHERE score > 100;",
            "SELECT avg(Scores) FROM submission"
        ],
        "rule_sql": [
            "SELECT avg(Scores) FROM submission"
        ]
    },
    "6441": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "List all budget type codes and descriptions.",
        "ground_truth": "SELECT budget_type_code ,  budget_type_description FROM Ref_budget_codes",
        "amends": [
            "Do select `budget_type_code` and `budget_type_description` instead of `budget_code` and `budget_description`. Do query from `Ref_budget_codes` instead of `budget_types`. Do remove the `WHERE budget_code IS NOT NULL` filter instead of keeping it. Do remove the `ORDER BY budget_code DESC` clause instead of including it. The amended query now correctly references the appropriate table and columns without unnecessary filtering or sorting."
        ],
        "rules": [
            "1) When answering about \"budget type codes and descriptions\": make sure the output order: budget_type_code, budget_type_description. 2) When the question mentions \"budget type codes\": \"budget type codes\" actually means \"budget_type_code in schema\". 3) When the question mentions \"descriptions\": \"descriptions\" actually means \"budget_type_description in schema\". 4) When querying for budget type information: use table \"Ref_budget_codes\" instead of any other table name. 5) When listing all budget type codes and descriptions: do not apply any filtering conditions or sorting orders unless explicitly specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT budget_code, budget_description FROM budget_types WHERE budget_code IS NOT NULL ORDER BY budget_code DESC",
            "SELECT Budget_Type_Code, Budget_Type_Description FROM Ref_Budget_Codes"
        ],
        "rule_sql": [
            "SELECT Budget_Type_Code, Budget_Type_Description FROM Ref_Budget_Codes;"
        ]
    },
    "5207": {
        "db_id": "music_2",
        "question": "What instrument is used the most?",
        "ground_truth": "SELECT instrument FROM instruments GROUP BY instrument ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `instrument` instead of selecting both `instrument` and `COUNT(*) as count`. Do query from `instruments` table instead of `performances` table. Do use `ORDER BY count(*) DESC` instead of `ORDER BY count ASC` to sort by descending count rather than ascending count. The amended query now correctly retrieves instruments ordered by their count in descending order from the instruments table."
        ],
        "rules": [
            "1) When answering about \"What instrument is used the most\": make sure the output order: instrument. 2) When counting instruments: compute the number of rows using the canonical key from the instruments table. 3) When the question asks for \"the most\": rank rows by count in descending order and keep the first 1 row. 4) When selecting from the instruments table: use the exact table name \"instruments\" without quotes as shown in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT instrument, COUNT(*) as count FROM performances GROUP BY instrument ORDER BY count ASC LIMIT 1;",
            "SELECT instrument FROM Instruments GROUP BY instrument ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Instrument FROM Instruments GROUP BY Instrument ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "52": {
        "db_id": "farm",
        "question": "Find the official names of cities with population bigger than 1500 or smaller than 500.",
        "ground_truth": "SELECT Official_Name FROM city WHERE Population  >  1500 OR Population  <  500",
        "amends": [
            "Do reference the `Official_Name` column instead of `name` and use the `city` table instead of `cities`. Do use `OR` logical operator between population conditions instead of `AND`, and reference the `Population` column instead of `population`. Do remove the incorrect upper bound filter `Population < 500` that was combined with `AND` instead of using `OR` with the lower bound condition, ensuring the query returns cities with populations either above 1500 or below 500 rather than the impossible range between 500 and 1500. The amended query now correctly matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"official names of cities\": use the exact column token \"Official_Name\" from table \"city\" instead of \"name\". 2) When the question mentions \"population bigger than 1500 or smaller than 500\": use the exact column token \"Population\" and apply the conditions \"Population > 1500\" OR \"Population < 500\" using the OR logical operator. 3) When the question asks about cities: use the exact table name \"city\" instead of \"cities\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM cities WHERE population > 1500 AND population < 500;",
            "SELECT Official_Name FROM city WHERE Population > 1500 OR Population < 500"
        ],
        "rule_sql": [
            "SELECT Official_Name FROM city WHERE Population > 1500 OR Population < 500"
        ]
    },
    "42": {
        "db_id": "farm",
        "question": "Please show the different statuses of cities and the average population of cities with each status.",
        "ground_truth": "SELECT Status ,  avg(Population) FROM city GROUP BY Status",
        "amends": [
            "Do reference the `Status` column instead of `status` and use `avg(Population)` instead of `AVG(population)` for proper case sensitivity and column naming. Do reference the `city` table instead of `cities` for correct table name. Do group by `Status` instead of `population` to calculate average population per status category rather than per individual population value, which fixes the logical error of grouping by the same column being aggregated."
        ],
        "rules": [
            "1) When the question asks about city statuses: use the exact column name \"Status\" from the city table with proper case sensitivity. 2) When calculating average population: use the exact function name \"avg(Population)\" with proper case sensitivity for both function and column. 3) When grouping results by status categories: group by the \"Status\" column instead of the aggregated column to get averages per status type. 4) When referencing the table containing city data: use the exact table name \"city\" instead of plural forms like \"cities\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT status, AVG(population) FROM cities GROUP BY population;",
            "SELECT Status, avg(Population) FROM city GROUP BY Status;"
        ],
        "rule_sql": [
            "SELECT Status, avg(Population) FROM city GROUP BY Status;"
        ]
    },
    "2325": {
        "db_id": "csu_1",
        "question": "What campuses are located in the county of Los Angeles?",
        "ground_truth": "SELECT campus FROM campuses WHERE county  =  \"Los Angeles\"",
        "amends": [
            "Do reference the column as `campus` instead of `campus_name` in the SELECT list. Do use double quotes `\"Los Angeles\"` instead of single quotes `'Los Angeles'` for the string literal in the WHERE filter, though this is a cosmetic difference that doesn't affect query behavior. The amended query now correctly selects the campus column with proper string quoting, matching the intended result set."
        ],
        "rules": [
            "1) When the question asks for campuses located in a specific county: select the \"campus\" column from the campuses table. 2) When filtering for Los Angeles county: use the exact literal value \"Los Angeles\" with double quotes. 3) When the question mentions \"county of Los Angeles\": this refers to the county column in the campuses table with value \"Los Angeles\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT campus_name FROM campuses WHERE county = 'Los Angeles';",
            "SELECT Campus FROM Campuses WHERE County = \"Los Angeles\""
        ],
        "rule_sql": [
            "SELECT Campus FROM Campuses WHERE County = \"Los Angeles\";"
        ]
    },
    "3061": {
        "db_id": "loan_1",
        "question": "What are the names of the different bank branches, and what are their total loan amounts?",
        "ground_truth": "SELECT sum(amount) ,  T1.bname FROM bank AS T1 JOIN loan AS T2 ON T1.branch_id  =  T2.branch_id GROUP BY T1.bname",
        "amends": [
            "Do select `sum(amount)` instead of `COUNT(*) as total_loans` to calculate the total loan amounts rather than counting loan records. Do use `bank AS T1 JOIN loan AS T2` instead of just `loans` to properly join the bank and loan tables. Do specify the join condition `T1.branch_id = T2.branch_id` instead of omitting any join predicate. Do group by `T1.bname` instead of `branch_name` to use the correct column name from the bank table. The amended query now correctly calculates the sum of loan amounts per branch by properly joining the relevant tables with the appropriate join condition.",
            "Do place the aggregate function `sum(amount)` first in the SELECT list instead of placing `T1.bname` first. Do use lowercase `branch_id` in the join condition instead of uppercase `branch_ID`. Do remove the alias `total_loan_amount` from the aggregate expression instead of keeping it. Do maintain the same join type, table sources, grouping logic, and overall query structure while correcting these syntactic and presentation differences.",
            "Do place the aggregate function `sum(amount)` first in the SELECT list instead of starting with `T1.bname`. Do remove the explicit column alias `T2.amount` from the aggregate function instead of keeping it. Do maintain the same FROM clause with `JOIN` on `T1.branch_id = T2.branch_id` and preserve the GROUP BY `T1.bname` clause. The amended query now correctly calculates the sum of loan amounts per bank name while maintaining the same join logic and grouping structure."
        ],
        "rules": [
            "1) When calculating total loan amounts: use sum(amount) instead of counting records to get the actual sum of loan values. 2) When combining bank and loan information: join bank AS T1 with loan AS T2 using the condition T1.branch_id = T2.branch_id to properly link related data. 3) When grouping by bank branch names: use T1.bname instead of branch_name to reference the correct column from the bank table. 4) When answering about different bank branches and their total loan amounts: make sure the output order: branch names first, then total loan amounts.",
            "1) When the question asks for names of bank branches and their total loan amounts: make sure the output order places the sum(amount) first and then T1.bname second. 2) When joining the bank table (T1) and loan table (T2): link rows where T1.branch_id = T2.branch_id using lowercase 'branch_id' instead of uppercase 'branch_ID'. 3) When computing the total loan amount: use sum(amount) without any alias like 'total_loan_amount'. 4) When grouping results by bank branch names: organize results by T1.bname and compute the sum of loan amounts per branch.",
            "1) When answering about \"names of different bank branches and their total loan amounts\": make sure the output order: sum(amount) first, then T1.bname. 2) When computing total loan amounts per bank branch: use sum(amount) without explicit column alias T2.amount. 3) When combining bank and loan tables: link rows where T1.branch_id = T2.branch_id and keep only matching pairs (inner match). 4) When grouping results by bank branch names: organize results by T1.bname and compute sum(amount) per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT branch_name, COUNT(*) as total_loans FROM loans GROUP BY branch_name;",
            "SELECT T1.bname, SUM(T2.amount) as total_loan_amount\nFROM bank AS T1\nJOIN loan AS T2 ON T1.branch_ID = T2.branch_ID\nGROUP BY T1.bname",
            "SELECT T1.bname, sum(T2.amount) FROM bank AS T1 JOIN loan AS T2 ON T1.branch_id = T2.branch_id GROUP BY T1.bname",
            "SELECT sum(amount), T1.bname FROM bank AS T1 JOIN loan AS T2 ON T1.branch_id = T2.branch_id GROUP BY T1.bname"
        ],
        "rule_sql": [
            "SELECT sum(amount), T1.bname FROM bank AS T1 JOIN loan AS T2 ON T1.branch_id = T2.branch_id GROUP BY T1.bname"
        ]
    },
    "4611": {
        "db_id": "entertainment_awards",
        "question": "Show the ids and names of festivals that have at least two nominations for artworks.",
        "ground_truth": "SELECT T1.Festival_ID ,  T3.Festival_Name FROM nomination AS T1 JOIN artwork AS T2 ON T1.Artwork_ID  =  T2.Artwork_ID JOIN festival_detail AS T3 ON T1.Festival_ID  =  T3.Festival_ID GROUP BY T1.Festival_ID HAVING COUNT(*)  >=  2",
        "amends": [
            "Do select `T1.Festival_ID` and `T3.Festival_Name` instead of `f.id` and `f.name`. Do join `artwork AS T2` on `T1.Artwork_ID = T2.Artwork_ID` instead of omitting this table. Do join `festival_detail AS T3` on `T1.Festival_ID = T3.Festival_ID` instead of joining directly to the festivals table. Do group by only `T1.Festival_ID` instead of grouping by both `f.id` and `f.name`. Do use `COUNT(*) >= 2` instead of `COUNT(n.artwork_id) >= 1` to require at least two nominations per festival. The amended query now correctly identifies festivals with multiple nominations by joining through the artwork table and using proper counting logic."
        ],
        "rules": [
            "1) When answering about \"festivals with at least two nominations for artworks\": make sure the output order: T1.Festival_ID, T3.Festival_Name. 2) When combining tables for festival nominations: link rows where T1.Artwork_ID = T2.Artwork_ID and T1.Festival_ID = T3.Festival_ID, keeping only matching pairs (inner match). 3) When counting nominations per festival: organize results by T1.Festival_ID and compute COUNT(*) >= 2 to require at least two nominations per festival. 4) When the question asks for \"ids and names of festivals\": select T1.Festival_ID and T3.Festival_Name from the festival_detail table instead of the base festivals table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT f.id, f.name FROM festivals f JOIN nominations n ON f.id = n.festival_id GROUP BY f.id, f.name HAVING COUNT(n.artwork_id) >= 1",
            "SELECT T1.Festival_ID, T3.Festival_Name\nFROM nomination AS T1\nJOIN artwork AS T2 ON T1.Artwork_ID = T2.Artwork_ID\nJOIN festival_detail AS T3 ON T1.Festival_ID = T3.Festival_ID\nGROUP BY T1.Festival_ID\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T1.Festival_ID, T3.Festival_Name\nFROM nomination T1\nINNER JOIN artwork T2 ON T1.Artwork_ID = T2.Artwork_ID\nINNER JOIN festival_detail T3 ON T1.Festival_ID = T3.Festival_ID\nGROUP BY T1.Festival_ID\nHAVING COUNT(*) >= 2\nORDER BY T1.Festival_ID, T3.Festival_Name"
        ]
    },
    "5712": {
        "db_id": "dorm_1",
        "question": "Find the code of city where most of students are living in.",
        "ground_truth": "SELECT city_code FROM student GROUP BY city_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference table `student` instead of `students` in the FROM clause, correcting the table name to match the actual schema. Do maintain the same SELECT list with `city_code`, GROUP BY clause with `city_code`, ORDER BY with `count(*) DESC`, and LIMIT 1, preserving all the original logic and structure. The amended query now matches RIGHT_SQL's behavior by using the correct table name."
        ],
        "rules": [
            "1) When the question asks about \"students\": use the exact table name \"student\" instead of \"students\" as shown in the schema. 2) When counting students: use the canonical key \"city_code\" for grouping and counting. 3) When finding the city with the most students: rank cities by student count in descending order and keep only the top result. 4) When outputting results: return the exact column \"city_code\" as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city_code FROM students GROUP BY city_code ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT city_code FROM Student GROUP BY city_code ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT city_code FROM student GROUP BY city_code ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "3200": {
        "db_id": "college_1",
        "question": "How many sections does each course have?",
        "ground_truth": "SELECT count(*) ,  crs_code FROM CLASS GROUP BY crs_code",
        "amends": [
            "Do use `crs_code` instead of `course_id` for the grouping column. Do place the aggregate function `count(*)` first in the SELECT list instead of second. Do reference table `CLASS` instead of `sections` as the data source. The amended query now correctly counts class records grouped by course code.",
            "Do use `count(*)` without an alias instead of `COUNT(*) AS section_count`. Do place `crs_code` after the aggregate function instead of listing it first in the SELECT clause. Do maintain the same GROUP BY clause with `crs_code` but adjust the column order to match the SELECT list sequence. The amended query now correctly returns the count of sections grouped by course code without the unnecessary alias, matching the behavior of the right SQL."
        ],
        "rules": [
            "1) When the question asks about \"sections\" of courses: use table \"CLASS\" as the data source instead of \"sections\". 2) When grouping by course identifier: use column \"crs_code\" instead of \"course_id\" for the grouping column. 3) When counting sections per course: place the count(*) aggregate function first in the output column order before the course identifier column.",
            "1) When counting sections per course: use count(*) without an alias instead of COUNT(*) AS section_count. 2) When organizing results by course code: place crs_code after the aggregate function in the output order. 3) When grouping by course code: maintain the GROUP BY clause with crs_code but ensure the column order matches the SELECT list sequence."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_id, COUNT(*) FROM sections GROUP BY course_id;",
            "SELECT CRS_CODE, COUNT(*) AS section_count FROM CLASS GROUP BY CRS_CODE;",
            "SELECT COUNT(*), CRS_CODE FROM CLASS GROUP BY CRS_CODE"
        ],
        "rule_sql": [
            "SELECT COUNT(*), CRS_CODE FROM CLASS GROUP BY CRS_CODE"
        ]
    },
    "46": {
        "db_id": "farm",
        "question": "List the most common type of Status across cities.",
        "ground_truth": "SELECT Status FROM city GROUP BY Status ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do reference table `city` instead of `cities` in the FROM clause. Do remove the explicit column alias `count` from the SELECT list instead of keeping it. Do move the aggregate function `COUNT(*)` to the ORDER BY clause instead of including it in the SELECT list. Do retain only the `Status` column in the SELECT list instead of including both `Status` and the count. The amended query now correctly returns only the status with the highest count while matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"most common type of Status across cities\": make sure the output order: Status. 2) When the question mentions \"cities\": \"cities\" actually means \"city\" in schema. 3) When the question asks for \"most common type\": rank rows by COUNT(*) in descending order and keep the first 1 row. 4) When counting entities: compute the number of rows using COUNT(*) but do not include the count in the final output columns. 5) When grouping by Status: organize results by the token for Status and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Status, COUNT(*) as count FROM cities GROUP BY Status ORDER BY count DESC LIMIT 1;",
            "SELECT Status FROM city GROUP BY Status ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Status FROM city GROUP BY Status ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "1526": {
        "db_id": "insurance_and_eClaims",
        "question": "Find the number of distinct stages in claim processing.",
        "ground_truth": "SELECT count(*) FROM claims_processing_stages",
        "amends": [
            "Do reference table `claims_processing_stages` instead of `claim_processing` to ensure the correct data source is queried. The amended query now matches RIGHT_SQL's behavior by counting records from the appropriate table."
        ],
        "rules": [
            "1) When answering about \"distinct stages in claim processing\": make sure to reference the exact table \"claims_processing_stages\" instead of \"claim_processing\". 2) When counting distinct stages: compute the number of unique values using the canonical key from the \"claims_processing_stages\" table. 3) When the question asks for \"number of distinct stages\": ensure the output is a single count value representing the distinct stages available in the processing system."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM claim_processing",
            "SELECT COUNT(DISTINCT Claim_Stage_ID) FROM Claims_Processing_Stages;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Claim_Stage_ID) AS NumberOfDistinctStages FROM Claims_Processing_Stages;"
        ]
    },
    "733": {
        "db_id": "customers_card_transactions",
        "question": "Show all transaction types.",
        "ground_truth": "SELECT DISTINCT transaction_type FROM Financial_Transactions",
        "amends": [
            "Do select only `transaction_type` instead of all columns with `*`. Do use table `Financial_Transactions` instead of `transactions`. Do filter on `transaction_type` instead of `type`. Do add `DISTINCT` instead of omitting it. The amended query now correctly returns unique transaction types from the Financial_Transactions table."
        ],
        "rules": [
            "1) When answering about \"transaction types\": make sure the output order: transaction_type. 2) When the question asks for \"all transaction types\": select only the column \"transaction_type\" instead of all columns. 3) When the question asks for \"all transaction types\": use the table \"Financial_Transactions\" instead of \"transactions\". 4) When the question asks for \"all transaction types\": filter on column \"transaction_type\" instead of \"type\". 5) When the question asks for \"all transaction types\": add DISTINCT to return unique values instead of omitting it."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM transactions WHERE type = 'credit';",
            "SELECT DISTINCT transaction_type FROM Financial_Transactions;"
        ],
        "rule_sql": [
            "SELECT DISTINCT transaction_type FROM Financial_Transactions ORDER BY transaction_type;"
        ]
    },
    "2251": {
        "db_id": "machine_repair",
        "question": "Show names of technicians and series of machines they are assigned to repair.",
        "ground_truth": "SELECT T3.Name ,  T2.Machine_series FROM repair_assignment AS T1 JOIN machine AS T2 ON T1.machine_id  =  T2.machine_id JOIN technician AS T3 ON T1.technician_ID  =  T3.technician_ID",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of full table names. Do select `T3.Name` and `T2.Machine_series` instead of `technician_name` and `machine_series`. Do join `repair_assignment AS T1` instead of `technicians` as the primary table. Do add `machine AS T2` with join condition `T1.machine_id = T2.machine_id` instead of omitting this table. Do join `technician AS T3` with condition `T1.technician_ID = T3.technician_ID` instead of joining `repairs` with `technicians.id = repairs.technician_id`. The amended query now correctly uses the repair_assignment bridge table to connect technicians with their assigned machines through proper foreign key relationships."
        ],
        "rules": [
            "1) When answering about \"technicians and series of machines they are assigned to repair\": make sure the output order: T3.Name, T2.Machine_series\n2) When the question mentions \"technicians\": \"technicians\" actually means \"T3.Name in schema\"\n3) When the question mentions \"machines they are assigned to repair\": \"machines\" actually means \"T2.Machine_series in schema\"\n4) When combining tables for repair assignments: use repair_assignment as T1 as the primary table instead of technicians\n5) When linking machines to assignments: add machine as T2 with join condition T1.machine_id = T2.machine_id\n6) When linking technicians to assignments: join technician as T3 with condition T1.technician_ID = T3.technician_ID instead of joining repairs table\n7) When selecting output columns: use T3.Name instead of technician_name and T2.Machine_series instead of machine_series"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT technician_name, machine_series FROM technicians JOIN repairs ON technicians.id = repairs.technician_id",
            "SELECT T3.Name, T2.Machine_series\nFROM repair_assignment AS T1\nJOIN machine AS T2 ON T1.Machine_ID = T2.Machine_ID\nJOIN technician AS T3 ON T1.technician_id = T3.technician_id;"
        ],
        "rule_sql": [
            "SELECT T3.Name, T2.Machine_series\nFROM repair_assignment AS T1\nJOIN machine AS T2 ON T1.Machine_ID = T2.Machine_ID\nJOIN technician AS T3 ON T1.technician_id = T3.technician_id\nORDER BY T3.Name, T2.Machine_series;"
        ]
    },
    "5779": {
        "db_id": "customer_complaints",
        "question": "Return the names of products that have had complaints filed by the customer who has filed the fewest complaints.",
        "ground_truth": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do select `DISTINCT t1.product_name` instead of `p.name` without distinct. Do use table aliases `t1`, `t2`, `t3` instead of `p`, `c`, `cust`. Do remove the join condition between complaints and customers tables instead of including `ON c.customer_id = cust.customer_id`. Do add `ORDER BY count(*) LIMIT 1` instead of the complex subquery with `HAVING COUNT(c.complaint_id) = (SELECT MIN(complaint_count)...`. Do remove the GROUP BY clause on customer_id instead of keeping it since the final result is ordered by count and limited to one row. The amended query now correctly finds the product with the minimum complaint count using a simpler approach with ordering and limiting.",
            "Do remove the WHERE clause with its correlated subquery instead of keeping it, as the subquery logic was incorrectly filtering results. Do add GROUP BY t3.customer_id instead of omitting it to properly aggregate customer data. Do add ORDER BY count(*) instead of omitting it to sort by complaint count. Do add LIMIT 1 instead of omitting it to return only the top result. The amended query now correctly identifies products associated with customers grouped and ordered by complaint count rather than incorrectly filtering for a single customer with the fewest complaints.",
            "Do remove the subquery and WHERE clause instead of keeping them, as the subquery logic is redundant. Do add GROUP BY t3.customer_id instead of omitting it, to properly group the results. Do add ORDER BY count(*) instead of omitting it, to order by the complaint count. Do add LIMIT 1 instead of omitting it, to return only the top result. The amended query now correctly identifies products associated with customers who have the fewest complaints by using grouping and ordering directly in the main query instead of an inefficient subquery approach.",
            "Do remove the `JOIN Customers t3 ON t2.customer_id = t3.customer_id` join condition instead of keeping it, which changes the join to a cross join and affects the grouping logic. Do keep `GROUP BY t3.customer_id` instead of changing it, though the removed join condition alters the relationship between complaints and customers. Do maintain `ORDER BY COUNT(*) ASC` instead of changing to `ORDER BY count(*)` without explicit direction, though the ASC is implied. The amended query now matches RIGHT_SQL's behavior by removing the customer join condition while preserving the same structural elements.",
            "Do remove the `JOIN customers AS t3` condition `ON t2.customer_id = t3.customer_id` instead of keeping it, as the RIGHT_SQL joins the customers table without an ON predicate. Do maintain `GROUP BY t3.customer_id` instead of changing it, and do keep `ORDER BY count(*) ASC` instead of modifying the ordering direction. The amended query now correctly matches RIGHT_SQL's behavior by removing the join condition between complaints and customers tables."
        ],
        "rules": [
            "1) When selecting product names from the products table: use DISTINCT t1.product_name to ensure unique product names are returned. 2) When referring to tables in the schema: use table aliases t1 for products, t2 for complaints, and t3 for customers as specified in the amends. 3) When joining complaints to products: use the join condition t1.product_id = t2.product_id to link products with their complaints. 4) When joining customers to complaints: do not include any join condition between complaints and customers tables. 5) When finding the customer with fewest complaints: use ORDER BY count(*) LIMIT 1 instead of complex subqueries with HAVING clauses. 6) When grouping data: do not use GROUP BY clauses on customer_id since the final result is ordered by count and limited to one row.",
            "1) When answering about \"products that have had complaints filed by the customer who has filed the fewest complaints\": make sure the output order: product_name. 2) When the question asks for \"customer who has filed the fewest complaints\": group by customer_id and order by count(*) in ascending order, then take the first 1 row. 3) When combining Products and Complaints tables: link rows where Products.product_id equals Complaints.product_id. 4) When combining Complaints and Customers tables: link rows where Complaints.customer_id equals Customers.customer_id. 5) When counting complaints per customer: use customer_id as the grouping key and count the number of complaint records per customer.",
            "1) When answering about \"products that have had complaints filed by the customer who has filed the fewest complaints\": make sure the output order: product_name. 2) When the question mentions \"customer who has filed the fewest complaints\": group by customer_id and order by count(*) in ascending direction and keep the first 1 row. 3) When combining Products and Complaints for shared entities: link rows where Products.product_id = Complaints.product_id; keep only matching pairs (inner match). 4) When combining Complaints and Customers for shared entities: link rows where Complaints.customer_id = Customers.customer_id; keep only matching pairs (inner match). 5) When counting complaints per customer: compute the number of rows using the canonical key for complaints (Complaints.complaint_id or equivalent).",
            "1) When answering about products with complaints from the customer with fewest complaints: make sure the output order: product_name. 2) When combining Products and Complaints tables: link rows where Products.product_id equals Complaints.product_id exactly as shown. 3) When grouping by customer_id: organize results by customer_id and compute count of complaints per customer. 4) When the question asks for the customer with fewest complaints: rank customers by complaint count in ascending order and keep only the first customer (lowest count). 5) When selecting product names for the identified customer: return distinct product_name values associated with that customer's complaints.",
            "1) When joining the Products table (T1) and Complaints table (T2): link rows where T1.product_id equals T2.product_id. 2) When joining the Customers table (T3): do not specify any join condition between T2 and T3 (remove the ON predicate). 3) When grouping results: organize by T3.customer_id to analyze data per customer. 4) When ordering results: sort by the count of complaints in ascending order to find the customer with the fewest complaints. 5) When limiting results: keep only the first row to get the customer with the absolute fewest complaints. 6) When selecting output: return distinct product_name values from T1 for the identified customer."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.name \nFROM products p\nJOIN complaints c ON p.product_id = c.product_id\nJOIN customers cust ON c.customer_id = cust.customer_id\nGROUP BY cust.customer_id\nHAVING COUNT(c.complaint_id) = (SELECT MIN(complaint_count) FROM (SELECT COUNT(complaint_id) as complaint_count FROM complaints GROUP BY customer_id))\nORDER BY p.name;",
            "SELECT DISTINCT t1.product_name\nFROM Products t1\nJOIN Complaints t2 ON t1.product_id = t2.product_id\nJOIN Customers t3 ON t2.customer_id = t3.customer_id\nWHERE t3.customer_id = (\n    SELECT customer_id\n    FROM Complaints\n    GROUP BY customer_id\n    ORDER BY COUNT(*) ASC\n    LIMIT 1\n)",
            "SELECT DISTINCT t1.product_name\nFROM Products t1\nJOIN Complaints t2 ON t1.product_id = t2.product_id\nJOIN Customers t3 ON t2.customer_id = t3.customer_id\nWHERE t3.customer_id IN (\n    SELECT t3.customer_id\n    FROM Complaints t2\n    JOIN Customers t3 ON t2.customer_id = t3.customer_id\n    GROUP BY t3.customer_id\n    ORDER BY COUNT(*) ASC\n    LIMIT 1\n)",
            "SELECT DISTINCT t1.product_name\nFROM Products t1\nJOIN Complaints t2 ON t1.product_id = t2.product_id\nJOIN Customers t3 ON t2.customer_id = t3.customer_id\nGROUP BY t3.customer_id\nORDER BY COUNT(*) ASC\nLIMIT 1",
            "SELECT DISTINCT t1.product_name\nFROM Products t1\nJOIN Complaints t2 ON t1.product_id = t2.product_id\nJOIN Customers t3 ON t2.customer_id = t3.customer_id\nGROUP BY t3.customer_id\nORDER BY COUNT(*) ASC\nLIMIT 1",
            "SELECT DISTINCT t1.product_name\nFROM Products t1\nJOIN Complaints t2 ON t1.product_id = t2.product_id\nJOIN Customers t3\nGROUP BY t3.customer_id\nORDER BY COUNT(*) ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT DISTINCT t1.product_name\nFROM Products t1\nJOIN Complaints t2 ON t1.product_id = t2.product_id\nJOIN Customers t3 ON t2.customer_id = t3.customer_id\nWHERE t3.customer_id = (\n    SELECT t3.customer_id\n    FROM Complaints t2\n    JOIN Customers t3 ON t2.customer_id = t3.customer_id\n    GROUP BY t3.customer_id\n    ORDER BY COUNT(*) ASC\n    LIMIT 1\n)\nORDER BY t1.product_name;"
        ]
    },
    "4265": {
        "db_id": "club_1",
        "question": "How many people have membership in the club \"Pen and Paper Gaming\"?",
        "ground_truth": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Pen and Paper Gaming\"",
        "amends": [
            "Do join `club AS t1` instead of querying `members` directly, and add `member_of_club AS t2` and `student AS t3` tables instead of omitting them. Do use `JOIN` with `t1.clubid = t2.clubid` and `t2.stuid = t3.stuid` conditions instead of no joins. Do filter on `t1.clubname = \"Pen and Paper Gaming\"` instead of `club_name = 'Pen and Paper Gaming'`. The amended query now correctly counts students in the specified club by properly joining through the membership relationship."
        ],
        "rules": [
            "1) When answering about \"How many people have membership in the club 'Pen and Paper Gaming'\": make sure the output order: count of students in the specified club. 2) When the question mentions \"club 'Pen and Paper Gaming'\": \"Pen and Paper Gaming\" actually means \"t1.clubname = 'Pen and Paper Gaming'\" in schema. 3) When combining tables for club membership: link rows where t1.clubid = t2.clubid and t2.stuid = t3.stuid exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"count of people\": compute the number of rows using the canonical key token for students (t3.stuid)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM members WHERE club_name = 'Pen and Paper Gaming';",
            "SELECT COUNT(*) \nFROM Club AS t1\nJOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID\nJOIN Student AS t3 ON t2.StuID = t3.StuID\nWHERE t1.ClubName = 'Pen and Paper Gaming'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT t3.StuID) \nFROM Club t1 \nINNER JOIN Member_of_club t2 ON t1.ClubID = t2.ClubID \nINNER JOIN Student t3 ON t2.StuID = t3.StuID \nWHERE t1.ClubName = 'Pen and Paper Gaming'"
        ]
    },
    "4478": {
        "db_id": "network_2",
        "question": "Which person whose friends have the oldest average age?",
        "ground_truth": "SELECT T2.name ,  avg(T1.age) FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend GROUP BY T2.name ORDER BY avg(T1.age) DESC LIMIT 1",
        "amends": [
            "Do select `T2.name` and `avg(T1.age)` instead of `p.name` and `AVG(f.age)`. Do use `Person AS T1` and `PersonFriend AS T2` as table sources instead of `persons p` and `friendships f`. Do perform a `JOIN` on `T1.name = T2.friend` instead of `p.id = f.person_id`. Do group by `T2.name` instead of `p.id`. Do order by `avg(T1.age)` instead of `avg_friend_age`. The amended query now correctly calculates average friend age by joining on name rather than ID and groups by the appropriate column to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"person whose friends have the oldest average age\": make sure the output order: T2.name, avg(T1.age). 2) When the question mentions \"person\": use \"T2.name\" from the PersonFriend table. 3) When the question mentions \"friends have the oldest average age\": compute the average of \"T1.age\" from the Person table. 4) When combining Person AS T1 and PersonFriend AS T2: link rows where T1.name = T2.friend exactly as shown; keep only matching pairs (inner match). 5) When the question asks for \"average age\" per person: organize results by T2.name and compute average of T1.age per group. 6) When the question asks for \"oldest\" average: rank rows by avg(T1.age) in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.name, AVG(f.age) as avg_friend_age\nFROM persons p\nJOIN friendships f ON p.id = f.person_id\nGROUP BY p.id\nORDER BY avg_friend_age DESC\nLIMIT 1;",
            "SELECT T2.name, AVG(T1.age) as average_friend_age\nFROM Person AS T1\nJOIN PersonFriend AS T2 ON T1.name = T2.friend\nGROUP BY T2.name\nORDER BY AVG(T1.age) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.name, AVG(T1.age) AS average_age\nFROM Person AS T1\nINNER JOIN PersonFriend AS T2 ON T1.name = T2.friend\nGROUP BY T2.name\nORDER BY average_age DESC\nLIMIT 1"
        ]
    },
    "2532": {
        "db_id": "county_public_safety",
        "question": "How many counties are there?",
        "ground_truth": "SELECT count(*) FROM county_public_safety",
        "amends": [
            "Do query the `county_public_safety` table instead of the `states` table. Do count all records from the correct data source instead of counting from an incorrect table. The amended query now correctly targets the intended county public safety data instead of unrelated state information, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"how many counties\": query the \"county_public_safety\" table instead of the \"states\" table. 2) When counting all records from the correct data source: count all records from \"county_public_safety\" instead of counting from an incorrect table. 3) When targeting county public safety data: use \"county_public_safety\" table to match the intended county information instead of unrelated state information."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM states;",
            "SELECT COUNT(*) FROM county_public_safety;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM county_public_safety;"
        ]
    },
    "1953": {
        "db_id": "cinema",
        "question": "Show cinema name, film title, date, and price for each record in schedule.",
        "ground_truth": "SELECT T3.name ,  T2.title ,  T1.date ,  T1.price FROM schedule AS T1 JOIN film AS T2 ON T1.film_id  =  T2.film_id JOIN cinema AS T3 ON T1.cinema_id  =  T3.cinema_id",
        "amends": [
            "Do specify table aliases `T3.name`, `T2.title`, `T1.date`, and `T1.price` instead of using unqualified column names `cinema_name`, `film_title`, `date`, and `price`. Do add explicit `JOIN film AS T2 ON T1.film_id = T2.film_id` instead of omitting the film table join. Do add explicit `JOIN cinema AS T3 ON T1.cinema_id = T3.cinema_id` instead of omitting the cinema table join. Do use proper table aliases `T1`, `T2`, and `T3` for the schedule, film, and cinema tables respectively instead of referencing columns without proper table context. The amended query now correctly joins the necessary tables to resolve cinema names and film titles from their respective ID references in the schedule table."
        ],
        "rules": [
            "1) When answering about \"cinema name, film title, date, and price for each record in schedule\": make sure the output order: T3.name, T2.title, T1.date, T1.price. 2) When the question mentions \"cinema name\": \"cinema name\" actually means \"T3.name in schema\". 3) When the question mentions \"film title\": \"film title\" actually means \"T2.title in schema\". 4) When combining T1 (schedule) and T2 (film) for shared entities: link rows where T1.film_id = T2.film_id; keep only matching pairs (inner match). 5) When combining T1 (schedule) and T3 (cinema) for shared entities: link rows where T1.cinema_id = T3.cinema_id; keep only matching pairs (inner match). 6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT cinema_name, film_title, date, price FROM schedule",
            "SELECT T3.Name AS cinema_name, T2.Title AS film_title, T1.Date AS date, T1.Price AS price FROM schedule AS T1 JOIN film AS T2 ON T1.Film_ID = T2.Film_ID JOIN cinema AS T3 ON T1.Cinema_ID = T3.Cinema_ID"
        ],
        "rule_sql": [
            "SELECT T3.name, T2.title, T1.date, T1.price FROM schedule T1 INNER JOIN film T2 ON T1.Film_ID = T2.Film_ID INNER JOIN cinema T3 ON T1.Cinema_ID = T3.Cinema_ID"
        ]
    },
    "5668": {
        "db_id": "dorm_1",
        "question": "Find the name of dorms only for female (F gender).",
        "ground_truth": "SELECT dorm_name FROM dorm WHERE gender  =  'F'",
        "amends": [
            "Do select `dorm_name` instead of `name` and filter for `gender = 'F'` instead of `gender = 'M'`. Do reference table `dorm` instead of `dorms`. The amended query now correctly selects the dormitory names for female residents from the appropriate table."
        ],
        "rules": [
            "1) When the question asks for \"name of dorms\": use the exact column token \"dorm_name\" from the Dorm table instead of \"name\". 2) When filtering for gender: use the exact literal value 'F' (not 'M') to filter for female residents. 3) When referencing the table containing dorm information: use the exact table name \"Dorm\" (not \"dorms\") as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM dorms WHERE gender = 'M';",
            "SELECT dorm_name FROM Dorm WHERE gender = 'F';"
        ],
        "rule_sql": [
            "SELECT dorm_name FROM Dorm WHERE gender = 'F'"
        ]
    },
    "7": {
        "db_id": "department_management",
        "question": "What are the names of the states where at least 3 heads were born?",
        "ground_truth": "SELECT born_state FROM head GROUP BY born_state HAVING count(*)  >=  3",
        "amends": [
            "Do reference `born_state` instead of `state` in the SELECT list and GROUP BY clause. Do use table name `head` instead of `heads` as the FROM source. Do change the HAVING condition to `>= 3` instead of `> 2` to include groups with exactly 3 records. The amended query now correctly counts states with three or more occurrences in the head table."
        ],
        "rules": [
            "1) When the question asks for state names where heads were born: use the exact column token \"born_state\" from the head table instead of \"state\". 2) When counting heads per state: use the table name \"head\" (not \"heads\") as the data source. 3) When filtering for states with at least 3 heads: use the condition >= 3 (not > 2) to include groups with exactly 3 records. 4) When grouping by state: organize results by the \"born_state\" column and count occurrences per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT state FROM heads GROUP BY state HAVING COUNT(*) > 2",
            "SELECT born_state FROM head GROUP BY born_state HAVING COUNT(*) >= 3"
        ],
        "rule_sql": [
            "SELECT born_state FROM head GROUP BY born_state HAVING COUNT(*) >= 3"
        ]
    },
    "6767": {
        "db_id": "activity_1",
        "question": "How many activities do we have?",
        "ground_truth": "SELECT count(*) FROM Activity",
        "amends": [
            "Do select from `Activity` table instead of `users` table. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"how many activities\": select from the \"Activity\" table instead of the \"users\" table. 2) When counting activities: compute the number of rows using the canonical key for activities from the \"Activity\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users;",
            "SELECT COUNT(*) FROM Activity;"
        ],
        "rule_sql": [
            "SELECT COUNT(actid) FROM Activity;"
        ]
    },
    "3384": {
        "db_id": "sports_competition",
        "question": "what is the name of the country that participated in the most tournament competitions?",
        "ground_truth": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `country` from the `competition` table instead of `country_name` from `countries`. Do add a `WHERE` filter for `competition_type = 'Tournament'` instead of omitting any filtering. Do add `GROUP BY country` with an `ORDER BY count(*) DESC` to get the country with the most tournaments instead of using `ORDER BY RANDOM()`. Do keep `LIMIT 1` but now it returns the country with the highest tournament count instead of a random country. The amended query now correctly identifies the country with the most tournament-type competitions rather than returning a random country name."
        ],
        "rules": [
            "1) When answering about \"country that participated in the most tournament competitions\": select \"country\" from the \"competition\" table instead of \"country_name\" from \"countries\". 2) When filtering for tournament competitions: include only rows where \"competition_type\" equals 'Tournament'. 3) When counting tournament competitions per country: group by \"country\" and count the number of rows per group. 4) When finding the country with the most tournaments: order the results by the count in descending order and keep only the top result using LIMIT 1."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country_name FROM countries ORDER BY RANDOM() LIMIT 1;",
            "SELECT country FROM competition WHERE competition_type = 'Tournament' GROUP BY country ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT country FROM competition WHERE Competition_type = 'Tournament' GROUP BY country ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "2436": {
        "db_id": "movie_1",
        "question": "What is the name of the movie produced after 2000 and directed by James Cameron?",
        "ground_truth": "SELECT title FROM Movie WHERE director = 'James Cameron' AND YEAR  >  2000",
        "amends": [
            "Do reference the table as `Movie` instead of `movies` to match the correct schema. Do maintain the same filter conditions `director = 'James Cameron'` and `YEAR > 2000` but ensure proper spacing around the greater-than operator. The amended query now correctly references the intended table while preserving the identical filtering logic and result set."
        ],
        "rules": [
            "1) When referencing the movie table: use the exact table name \"Movie\" instead of \"movies\" to match the schema. 2) When filtering for movies produced after 2000: use the condition YEAR > 2000 with proper spacing around the greater-than operator. 3) When filtering for movies directed by James Cameron: use the exact literal value 'James Cameron' with the director column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM movies WHERE year > 2000 AND director = 'James Cameron';",
            "SELECT title FROM Movie WHERE director = 'James Cameron' AND year > 2000"
        ],
        "rule_sql": [
            "SELECT title FROM Movie WHERE year > 2000 AND director = 'James Cameron'"
        ]
    },
    "2043": {
        "db_id": "party_people",
        "question": "How many parties do we have?",
        "ground_truth": "SELECT count(DISTINCT party_name) FROM party",
        "amends": [
            "Do use `count(DISTINCT party_name)` instead of `COUNT(*)` to count distinct party names rather than all rows. Do reference table `party` instead of `parties` to use the correct table name. Do remove the `WHERE party_id IS NULL` filter instead of keeping it, as the correct logic counts all distinct party names without filtering for null party_id values. The amended query now correctly counts distinct party names from the party table without unnecessary filtering."
        ],
        "rules": [
            "1) When counting parties: count distinct values of \"party_name\" from table \"party\" instead of counting all rows. 2) When the question asks \"how many parties\": this means counting distinct party names, not filtering by null party_id values. 3) When choosing table names: use the exact table name \"party\" instead of \"parties\" as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM parties WHERE party_id IS NULL;",
            "SELECT COUNT(DISTINCT party_name) FROM party"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT party_name) FROM party;"
        ]
    },
    "5749": {
        "db_id": "dorm_1",
        "question": "How many female students live in Smith Hall?",
        "ground_truth": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.dorm_name  =  'Smith Hall' AND T1.sex  =  'F'",
        "amends": [
            "Do join `student AS T1` with `lives_in AS T2` on `T1.stuid = T2.stuid` and `dorm AS T3` on `T3.dormid = T2.dormid` instead of querying only `students` table. Do filter on `T3.dorm_name = 'Smith Hall'` instead of `hall = 'Smith Hall'`. Do filter on `T1.sex = 'F'` instead of `gender = 'male'`. The amended query now correctly joins related tables to find female students living in Smith Hall, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"female students in Smith Hall\": make sure the output order: count of female students in Smith Hall\n2) When the question mentions \"female students\": \"female\" actually means \"sex = 'F' in schema\" using exact literal 'F'\n3) When the question mentions \"Smith Hall\": \"Smith Hall\" actually means \"dorm_name = 'Smith Hall' in schema\" using exact literal 'Smith Hall'\n4) When combining student (T1) and lives_in (T2) for shared entities: link rows where T1.stuid = T2.stuid exactly as shown in the amends; keep only matching pairs (inner match)\n5) When combining lives_in (T2) and dorm (T3) for shared entities: link rows where T3.dormid = T2.dormid exactly as shown in the amends; keep only matching pairs (inner match)\n6) When the question asks for \"count of female students in Smith Hall\": compute the number of rows using the canonical key token for students (T1.stuid) after applying all filters and joins"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE gender = 'male' AND hall = 'Smith Hall';",
            "SELECT COUNT(*) \nFROM Student AS T1\nJOIN Lives_in AS T2 ON T1.StuID = T2.stuid\nJOIN Dorm AS T3 ON T3.dormid = T2.dormid\nWHERE T3.dorm_name = 'Smith Hall' AND T1.Sex = 'F'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.StuID) \nFROM Student T1\nINNER JOIN Lives_in T2 ON T1.StuID = T2.stuid\nINNER JOIN Dorm T3 ON T3.dormid = T2.dormid\nWHERE T1.Sex = 'F' AND T3.dorm_name = 'Smith Hall'"
        ]
    },
    "2745": {
        "db_id": "election",
        "question": "What is the zip code the county named \"Howard\" is located in?",
        "ground_truth": "SELECT Zip_code FROM county WHERE County_name  =  \"Howard\"",
        "amends": [
            "Do use table name `county` instead of `counties` and reference column `Zip_code` instead of `zip_code` with proper capitalization. Do use column name `County_name` instead of `county_name` and filter with double quotes `\"Howard\"` instead of single quotes `'Howard'` for the string literal. The amended query now correctly references the actual table and column names with proper case sensitivity and quotation style."
        ],
        "rules": [
            "1) When the question asks about zip code for a county: use column \"Zip_code\" from table \"county\" with exact capitalization. 2) When the question mentions a county name \"Howard\": filter using column \"County_name\" with exact value \"Howard\" using double quotes. 3) When the question refers to a county: use table name \"county\" (singular) not \"counties\" (plural)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT zip_code FROM counties WHERE county_name = 'Howard';",
            "SELECT Zip_code FROM county WHERE County_name = \"Howard\";"
        ],
        "rule_sql": [
            "SELECT Zip_code FROM county WHERE County_name = \"Howard\";"
        ]
    },
    "6316": {
        "db_id": "e_government",
        "question": "Find the emails of parties with the most popular party form.",
        "ground_truth": "SELECT t1.party_email FROM parties AS t1 JOIN party_forms AS t2 ON t1.party_id  =  t2.party_id WHERE t2.form_id  =  (SELECT form_id FROM party_forms GROUP BY form_id ORDER BY count(*) DESC LIMIT 1)",
        "amends": [
            "Do select `t1.party_email` instead of `email` and add a table alias `AS t1`. Do add a `JOIN` with `party_forms AS t2` on `t1.party_id = t2.party_id` instead of querying only the `parties` table. Do add a `WHERE` filter on `t2.form_id` with a subquery instead of no filtering. Do use a subquery that selects `form_id` with `GROUP BY form_id ORDER BY count(*) DESC LIMIT 1` to find the most common form instead of ordering by `party_form DESC`. Do remove the `ORDER BY party_form DESC` and `LIMIT 1` from the main query since the filtering and subquery handle the logic instead. The amended query now correctly finds the email associated with the most frequently occurring form type rather than just the last party by form description."
        ],
        "rules": [
            "1) When answering about \"emails of parties with the most popular party form\": make sure the output order: t1.party_email. 2) When the question mentions \"email\": \"email\" actually means \"t1.party_email\" in schema. 3) When combining t1 and t2 for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (t1.party_id = t2.party_id); keep only matching pairs (inner match). 4) When the question asks for \"most popular party form\": find the form_id with the highest count of occurrences using GROUP BY form_id ORDER BY count(*) DESC LIMIT 1. 5) When filtering for the most common form: use a WHERE filter on t2.form_id that matches the result of the subquery finding the most frequent form_id."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT email FROM parties ORDER BY party_form DESC LIMIT 1;",
            "SELECT t1.party_email \nFROM Parties AS t1\nJOIN Party_Forms AS t2 ON t1.party_id = t2.party_id\nWHERE t2.form_id = (\n    SELECT form_id \n    FROM Party_Forms \n    GROUP BY form_id \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n)"
        ],
        "rule_sql": [
            "SELECT t1.party_email\nFROM Parties t1\nINNER JOIN Party_Forms t2 ON t1.party_id = t2.party_id\nWHERE t2.form_id = (\n    SELECT form_id\n    FROM Party_Forms\n    GROUP BY form_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)\nORDER BY t1.party_email;"
        ]
    },
    "2732": {
        "db_id": "storm_record",
        "question": "Find the name of the storm that affected both Afghanistan and Albania regions.",
        "ground_truth": "SELECT T3.Name FROM affected_region AS T1 JOIN region AS T2 ON T1.region_id  =  T2.region_id JOIN storm AS T3 ON T1.storm_id  =  T3.storm_id WHERE T2.Region_name  =  'Afghanistan' INTERSECT SELECT T3.Name FROM affected_region AS T1 JOIN region AS T2 ON T1.region_id  =  T2.region_id JOIN storm AS T3 ON T1.storm_id  =  T3.storm_id WHERE T2.Region_name  =  'Albania'",
        "amends": [
            "Do use `INTERSECT` with two separate queries instead of `AND` conditions in a single query. Do join `affected_region` and `region` tables on `region_id` instead of querying a single `storms` table. Do join `storm` table on `storm_id` instead of selecting directly from `storms`. Do filter on `Region_name = 'Afghanistan'` and `Region_name = 'Albania'` in separate queries instead of impossible `region = 'Afghanistan' AND region = 'Albania'`. Do select `T3.Name` from the joined storm table instead of `name` from a single table. The amended query now correctly finds storms that affected both Afghanistan and Albania by intersecting results from two separate region queries."
        ],
        "rules": [
            "1) When the question asks for storms affecting multiple regions: use separate queries for each region condition and intersect the results instead of combining conditions with AND in a single query. 2) When combining region information: join the affected_region table with the region table using region_id = region_id to link regions to their names. 3) When accessing storm information: join the storm table using storm_id = storm_id instead of querying a single storms table. 4) When filtering for specific regions: use exact literal values 'Afghanistan' and 'Albania' with the exact column name Region_name. 5) When selecting the storm name: use T3.Name from the joined storm table instead of name from a single table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM storms WHERE region = 'Afghanistan' AND region = 'Albania';",
            "SELECT T3.Name\nFROM (\n    SELECT s.Storm_ID, s.Name\n    FROM storm s\n    JOIN affected_region ar ON s.Storm_ID = ar.Storm_ID\n    JOIN region r ON ar.Region_id = r.Region_id\n    WHERE r.Region_name = 'Afghanistan'\n    INTERSECT\n    SELECT s.Storm_ID, s.Name\n    FROM storm s\n    JOIN affected_region ar ON s.Storm_ID = ar.Storm_ID\n    JOIN region r ON ar.Region_id = r.Region_id\n    WHERE r.Region_name = 'Albania'\n) T3"
        ],
        "rule_sql": [
            "SELECT T3.Name\nFROM storm T3\nWHERE T3.Storm_ID IN (\n    SELECT T1.Storm_ID\n    FROM affected_region T1\n    JOIN region T2 ON T1.Region_id = T2.Region_id\n    WHERE T2.Region_name = 'Afghanistan'\n)\nINTERSECT\nSELECT T3.Name\nFROM storm T3\nWHERE T3.Storm_ID IN (\n    SELECT T1.Storm_ID\n    FROM affected_region T1\n    JOIN region T2 ON T1.Region_id = T2.Region_id\n    WHERE T2.Region_name = 'Albania'\n)"
        ]
    },
    "1724": {
        "db_id": "riding_club",
        "question": "What is the name of the player with the largest number of votes?",
        "ground_truth": "SELECT Player_name FROM player ORDER BY Votes DESC LIMIT 1",
        "amends": [
            "Do select `Player_name` instead of `name` and use table `player` instead of `players`. Do order by `Votes DESC` instead of `votes ASC` to get the highest vote count rather than the lowest. The amended query now correctly retrieves the player with the most votes from the player table."
        ],
        "rules": [
            "1) When the question asks for the \"name\" of a player: use the exact column token \"Player_name\" from the player table. 2) When the question asks for the player with the \"largest number of votes\": order by the \"Votes\" column in descending order to get the highest value. 3) When retrieving a single top result: return only the first row after ordering."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM players ORDER BY votes ASC LIMIT 1;",
            "SELECT Player_name FROM player ORDER BY Votes DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Player_name FROM player ORDER BY Votes DESC LIMIT 1;"
        ]
    },
    "36": {
        "db_id": "farm",
        "question": "Show the official names of the cities that have hosted more than one competition.",
        "ground_truth": "SELECT T1.Official_Name FROM city AS T1 JOIN farm_competition AS T2 ON T1.City_ID  =  T2.Host_city_ID GROUP BY T2.Host_city_ID HAVING COUNT(*)  >  1",
        "amends": [
            "Do select `T1.Official_Name` instead of `city_name` and use table alias `T1` instead of direct column reference. Do join `city AS T1` with `farm_competition AS T2` instead of querying only `competitions` table. Do specify join condition `ON T1.City_ID = T2.Host_city_ID` instead of missing table relationships. Do group by `T2.Host_city_ID` instead of `city_name` to properly count competitions per host city. The amended query now correctly identifies cities hosting multiple farm competitions by establishing proper table relationships and grouping on the foreign key instead of the city name directly."
        ],
        "rules": [
            "1) When answering about cities hosting competitions: use table \"city\" as T1 and table \"farm_competition\" as T2. 2) When combining city and farm_competition tables: link rows where T1.City_ID = T2.Host_city_ID and keep only matching pairs (inner match). 3) When counting competitions per city: group by T2.Host_city_ID to properly count competitions per host city. 4) When the question asks for official names of cities: select T1.Official_Name instead of city_name. 5) When filtering for cities with more than one competition: count the number of competitions and keep only those with count greater than 1."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city_name FROM competitions GROUP BY city_name HAVING COUNT(*) > 1;",
            "SELECT T1.Official_Name\nFROM city AS T1\nJOIN farm_competition AS T2 ON T1.City_ID = T2.Host_city_ID\nGROUP BY T2.Host_city_ID\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T1.Official_Name FROM city AS T1 INNER JOIN farm_competition AS T2 ON T1.City_ID = T2.Host_city_ID GROUP BY T2.Host_city_ID HAVING COUNT(*) > 1"
        ]
    },
    "6558": {
        "db_id": "wine_1",
        "question": "What are the distinct names of wines with prices higher than any wine from John Anthony winery.",
        "ground_truth": "SELECT DISTINCT Name FROM WINE WHERE Price  >  (SELECT min(Price) FROM wine WHERE Winery  =  \"John Anthony\")",
        "amends": [
            "Do reference table `WINE` instead of `wines` and use column `Name` instead of `name`. Do use column `Price` instead of `price` and compare against `min(Price)` instead of `MAX(price)` in the subquery. Do use table `wine` instead of `wines` in the subquery and column `Winery` instead of `winery` with double quotes around 'John Anthony' instead of single quotes. The amended query now correctly identifies wines priced above the minimum price from John Anthony winery rather than the maximum price, matching the intended behavior."
        ],
        "rules": [
            "1) When referring to the table containing wine information: use table \"wine\" instead of \"wines\" 2) When selecting wine names: use column \"Name\" instead of \"name\" 3) When comparing wine prices: use column \"Price\" instead of \"price\" 4) When filtering by winery name: use column \"Winery\" instead of \"winery\" 5) When specifying literal winery names: use double quotes around \"John Anthony\" instead of single quotes 6) When finding wines priced higher than any wine from a specific winery: compare against the minimum price (min(Price)) from that winery rather than the maximum price"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT name FROM wines WHERE price > (SELECT MAX(price) FROM wines WHERE winery = 'John Anthony')",
            "SELECT DISTINCT Name FROM wine WHERE Price > (SELECT MIN(Price) FROM wine WHERE Winery = \"John Anthony\")"
        ],
        "rule_sql": [
            "SELECT DISTINCT Name FROM wine WHERE Price > (SELECT MIN(Price) FROM wine WHERE Winery = \"John Anthony\")"
        ]
    },
    "5102": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "Show the minimum, average, maximum order quantity of all invoices.",
        "ground_truth": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES",
        "amends": [
            "Do use column name `Order_Quantity` instead of `quantity` in all aggregate functions. Do maintain the same aggregate functions `MIN`, `AVG`, and `MAX` but with the corrected column reference. Do keep the table name `INVOICES` instead of `invoices` while preserving the same table source. The amended query now correctly references the actual column name and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for order quantity statistics: use the exact column name \"Order_Quantity\" from the Invoice_Items table instead of \"quantity\". 2) When computing aggregate functions on order quantity: maintain MIN, AVG, and MAX functions but ensure they reference the correct column \"Order_Quantity\". 3) When referring to the table containing order quantity data: use the table name \"INVOICES\" as specified in the schema context, though the actual column resides in the Invoice_Items table."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(quantity), AVG(quantity), MAX(quantity) FROM invoices",
            "SELECT MIN(Order_Quantity) AS min_quantity, AVG(Order_Quantity) AS avg_quantity, MAX(Order_Quantity) AS max_quantity FROM Invoices;"
        ],
        "rule_sql": [
            "SELECT MIN(Order_Quantity) AS min_order_quantity, AVG(Order_Quantity) AS avg_order_quantity, MAX(Order_Quantity) AS max_order_quantity FROM Invoice_Items;"
        ]
    },
    "4801": {
        "db_id": "aircraft",
        "question": "What is the average number of international passengers of all airports?",
        "ground_truth": "SELECT avg(International_Passengers) FROM airport",
        "amends": [
            "Do use `avg(International_Passengers)` instead of `AVG(domestic_passengers)` to calculate the average of international passengers rather than domestic passengers. Do reference the table `airport` instead of `airports` to use the correct table name. The amended query now correctly calculates the average international passengers from the airport table."
        ],
        "rules": [
            "1) When the question asks for average number of international passengers: use avg(International_Passengers) instead of domestic_passengers to calculate the average. 2) When referencing the airport data: use the table name airport instead of airports to access the correct table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(domestic_passengers) FROM airports;",
            "SELECT AVG(International_Passengers) FROM airport;"
        ],
        "rule_sql": [
            "SELECT AVG(International_Passengers) AS average_international_passengers FROM airport;"
        ]
    },
    "1663": {
        "db_id": "theme_gallery",
        "question": "How many exhibition are there in year 2005 or after?",
        "ground_truth": "SELECT count(*) FROM exhibition WHERE YEAR  >=  2005",
        "amends": [
            "Do use table name `exhibition` instead of `exhibitions`. Do change the WHERE condition to `YEAR >= 2005` instead of `year = 2005` to include all records from 2005 onward rather than only those exactly from 2005. The amended query now correctly counts all exhibitions from 2005 and later years, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"exhibition\" entities: use the table name \"exhibition\" exactly as specified in the schema. 2) When the question asks for exhibitions in year 2005 or after: use the condition YEAR >= 2005 to include all records from 2005 onward (inclusive). 3) When counting exhibitions: count all rows that satisfy the condition YEAR >= 2005."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM exhibitions WHERE year = 2005;",
            "SELECT COUNT(*) FROM exhibition WHERE Year >= 2005"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM exhibition WHERE Year >= 2005"
        ]
    },
    "4364": {
        "db_id": "tracking_grants_for_research",
        "question": "Which document type is described with the prefix 'Initial'?",
        "ground_truth": "SELECT document_type_code FROM Document_Types WHERE document_description LIKE 'Initial%'",
        "amends": [
            "Do select only `document_type_code` instead of all columns with `*`. Do query from `Document_Types` table instead of `documents` table. Do filter on `document_description` column instead of `description` column while maintaining the same `LIKE 'Initial%'` pattern. The amended query now correctly retrieves document type codes from the Document_Types table based on document descriptions starting with 'Initial', matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"document type with prefix 'Initial'\": make sure the output order: document_type_code. 2) When the question mentions \"document type\": \"document type\" actually means \"document_type_code in schema\". 3) When querying for document descriptions starting with 'Initial': filter on Document_Types.document_description column using LIKE 'Initial%' pattern. 4) When selecting from the Document_Types table: use the exact table name \"Document_Types\" as shown in the schema. 5) When handling text literals: do not change case, spacing, or punctuation - use exactly 'Initial%' as the pattern."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM documents WHERE description LIKE 'Initial%';",
            "SELECT document_type_code FROM Document_Types WHERE document_description LIKE 'Initial%'"
        ],
        "rule_sql": [
            "SELECT document_type_code FROM Document_Types WHERE document_description LIKE 'Initial%';"
        ]
    },
    "1863": {
        "db_id": "wrestler",
        "question": "What are the times of elimination for wrestlers with over 50 days held?",
        "ground_truth": "SELECT T1.Time FROM elimination AS T1 JOIN wrestler AS T2 ON T1.Wrestler_ID  =  T2.Wrestler_ID WHERE T2.Days_held  >  50",
        "amends": [
            "Do select `T1.Time` from the `elimination` table instead of `elimination_time` from the `wrestlers` table. Do join `wrestler` as `T2` on `T1.Wrestler_ID = T2.Wrestler_ID` instead of querying a single table. Do filter on `T2.Days_held > 50` instead of `days_held > 50` but now referencing the joined table. The amended query now correctly retrieves elimination times by joining the elimination and wrestler tables and filtering based on days held.",
            "Do remove the `CAST` function around `T2.Days_held` instead of casting it to INTEGER, and do use the direct numeric comparison `T2.Days_held > 50` instead of the unnecessary type conversion. Do maintain the same table aliases `T1` and `T2` and the identical join condition `T1.Wrestler_ID = T2.Wrestler_ID` instead of changing them. The amended query now correctly performs a direct numeric comparison without redundant casting, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about elimination times for wrestlers: make sure the output order: T1.Time 2) When the question mentions \"times of elimination\": \"times of elimination\" actually means \"T1.Time in elimination table\" 3) When the question mentions \"wrestlers with over 50 days held\": filter rows where T2.Days_held > 50 4) When combining elimination table as T1 and wrestler table as T2: link rows where T1.Wrestler_ID = T2.Wrestler_ID and keep only matching pairs (inner match)",
            "1) When comparing numeric values like \"Days_held\" to numeric literals: use direct numeric comparison without casting functions. 2) When the question asks for times of elimination for wrestlers with over 50 days held: use the exact literal value 50 without quotes for numeric comparison. 3) When joining Elimination table (T1) and wrestler table (T2): link rows where T1.Wrestler_ID equals T2.Wrestler_ID to find matching wrestler records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT elimination_time FROM wrestlers WHERE days_held > 50;",
            "SELECT T1.Time \nFROM Elimination AS T1\nJOIN wrestler AS T2 ON T1.Wrestler_ID = T2.Wrestler_ID\nWHERE CAST(T2.Days_held AS INTEGER) > 50",
            "SELECT T1.Time \nFROM Elimination T1\nJOIN wrestler T2 ON T1.Wrestler_ID = T2.Wrestler_ID\nWHERE T2.Days_held > 50"
        ],
        "rule_sql": [
            "SELECT T1.Time \nFROM Elimination AS T1\nINNER JOIN wrestler AS T2 ON T1.Wrestler_ID = T2.Wrestler_ID\nWHERE T2.Days_held > 50\nORDER BY T1.Time"
        ]
    },
    "4730": {
        "db_id": "department_store",
        "question": "Return the name and job title of the staff with the latest date assigned.",
        "ground_truth": "SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT 1",
        "amends": [
            "Do select `T1.staff_name` and `T2.job_title_code` instead of `name` and `job_title`. Do join `staff_department_assignments AS T2` instead of querying only the `staff` table. Do use `ON T1.staff_id = T2.staff_id` instead of missing the join condition. Do order by `T2.date_assigned_to DESC` instead of `date_assigned DESC`. The amended query now correctly retrieves the most recently assigned staff member with their job title from the joined tables."
        ],
        "rules": [
            "1) When answering about \"staff with the latest date assigned\": make sure the output order: T1.staff_name, T2.job_title_code. 2) When the question mentions \"name\": \"name\" actually means \"T1.staff_name in schema\". 3) When the question mentions \"job title\": \"job title\" actually means \"T2.job_title_code in schema\". 4) When combining T1 and T2 for shared entities: link rows where T1.staff_id = T2.staff_id; keep only matching pairs (inner match). 5) When the question asks for \"latest date assigned\": rank rows by T2.date_assigned_to in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, job_title FROM staff ORDER BY date_assigned DESC LIMIT 1;",
            "SELECT T1.staff_name, T2.job_title_code \nFROM Staff AS T1 \nJOIN Staff_Department_Assignments AS T2 ON T1.staff_id = T2.staff_id \nORDER BY T2.date_assigned_to DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.staff_name, T2.job_title_code\nFROM Staff T1\nINNER JOIN Staff_Department_Assignments T2 ON T1.staff_id = T2.staff_id\nORDER BY T2.date_assigned_to DESC\nLIMIT 1;"
        ]
    },
    "633": {
        "db_id": "store_1",
        "question": "List the name of tracks belongs to genre Rock or genre Jazz.",
        "ground_truth": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.name = \"Rock\" OR T1.name = \"Jazz\"",
        "amends": [
            "Do reference `T2.name` from the joined table instead of `name` directly from tracks. Do join `genres AS T1` to `tracks AS T2` on `T1.id = T2.genre_id` instead of querying tracks alone. Do filter on `T1.name = \"Rock\" OR T1.name = \"Jazz\"` instead of `genre = 'Rock' OR genre = 'Jazz'` to use the joined genres table's name column rather than a potentially non-existent genre column in tracks. The amended query now correctly joins the genres table to filter by genre names through proper relational integrity."
        ],
        "rules": [
            "1) When answering about tracks belonging to specific genres: join \"genres\" as T1 to \"tracks\" as T2 on T1.id = T2.genre_id to establish proper relational connections. 2) When the question mentions genre names \"Rock\" or \"Jazz\": use T1.name = \"Rock\" OR T1.name = \"Jazz\" to filter by exact genre names from the genres table. 3) When selecting track names: reference T2.name from the tracks table instead of directly using name from the base table. 4) When combining genres and tracks tables: perform an inner match where T1.id = T2.genre_id to ensure only valid genre-track relationships are considered."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM tracks WHERE genre = 'Rock' OR genre = 'Jazz'",
            "SELECT T2.name \nFROM tracks AS T2 \nJOIN genres AS T1 ON T1.id = T2.genre_id \nWHERE T1.name = 'Rock' OR T1.name = 'Jazz'"
        ],
        "rule_sql": [
            "SELECT T2.name \nFROM genres AS T1 \nJOIN tracks AS T2 ON T1.id = T2.genre_id \nWHERE T1.name = \"Rock\" OR T1.name = \"Jazz\""
        ]
    },
    "2540": {
        "db_id": "county_public_safety",
        "question": "Show the crime rates of counties in ascending order of number of police officers.",
        "ground_truth": "SELECT Crime_rate FROM county_public_safety ORDER BY Police_officers ASC",
        "amends": [
            "Do reference the `county_public_safety` table instead of the `counties` table. Do remove the `county_name` column from the SELECT list instead of including it. Do reference the `Crime_rate` column with proper case instead of `crime_rate`. Do reference the `Police_officers` column with proper case instead of `police_officers` in the ORDER BY clause. The amended query now correctly selects only crime rate data from the appropriate public safety table while maintaining the sorting by police officers."
        ],
        "rules": [
            "1) When the question asks about crime rates and police officers: use the \"county_public_safety\" table instead of \"counties\". 2) When selecting output columns: include only \"Crime_rate\" (with exact case) and exclude \"county_name\". 3) When ordering results by police officers: use \"Police_officers\" (with exact case) in ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT county_name, crime_rate FROM counties ORDER BY police_officers ASC;",
            "SELECT Crime_rate FROM county_public_safety ORDER BY Police_officers ASC;"
        ],
        "rule_sql": [
            "SELECT Crime_rate FROM county_public_safety ORDER BY Police_officers ASC;"
        ]
    },
    "530": {
        "db_id": "allergy_1",
        "question": "How many male students (sex is 'M') are allergic to any type of food?",
        "ground_truth": "SELECT count(*) FROM Student WHERE sex  =  \"M\" AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  \"food\")",
        "amends": [
            "Do reference the `Student` table instead of `students` and use lowercase `count(*)` instead of uppercase `COUNT(*)`. Do add a subquery with `StuID IN (SELECT...)` instead of directly filtering `allergies IS NOT NULL`. Do join `Has_allergy` and `Allergy_Type` tables with `ON T1.Allergy = T2.Allergy` instead of omitting these tables entirely. Do filter for `T2.allergytype = \"food\"` instead of checking for any non-null allergies. Do remove the direct `allergies` column reference and instead use the relationship through the allergy tables to properly identify students with food allergies. The amended query now correctly counts male students with food allergies by properly joining the allergy-related tables instead of relying on an incorrect column check."
        ],
        "rules": [
            "1) When answering about \"male students allergic to any type of food\": make sure the output order: count of male students with food allergies. 2) When the question mentions \"male students (sex is 'M')\": use \"sex = 'M'\" as the exact condition with Student table. 3) When the question mentions \"allergic to any type of food\": this means students with allergies where \"T2.allergytype = \\\"food\\\"\" through the Has_allergy and Allergy_Type tables. 4) When combining Student (T1), Has_allergy, and Allergy_Type tables: link rows where T1.StuID matches the student ID in Has_allergy and Has_allergy.Allergy matches Allergy_Type.Allergy, keeping only matching pairs (inner match). 5) When counting students with food allergies: use T1.StuID as the counting key to count distinct students. 6) When handling text literals: use exact case 'M' for male and \"food\" for allergy type with double quotes as shown in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE sex = 'M' AND allergies IS NOT NULL;",
            "SELECT count(*) \nFROM Student \nWHERE Sex = 'M' \nAND StuID IN (\n    SELECT T1.StuID \n    FROM Has_Allergy T1 \n    JOIN Allergy_Type T2 ON T1.Allergy = T2.Allergy \n    WHERE T2.AllergyType = 'food'\n)"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.StuID) \nFROM Student T1\nINNER JOIN Has_Allergy ON T1.StuID = Has_Allergy.StuID\nINNER JOIN Allergy_Type T2 ON Has_Allergy.Allergy = T2.Allergy\nWHERE T1.Sex = 'M' AND T2.AllergyType = \"food\""
        ]
    },
    "3698": {
        "db_id": "baseball_1",
        "question": "What are the first name and last name of the players who were paid salary by team Washington Nationals in both 2005 and 2007?",
        "ground_truth": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `p`, `s`, and `t`. Do reference columns `name_first` and `name_last` instead of `first_name` and `last_name`. Do join on `team_id_br` instead of `team_id` in the team join condition. Do use separate queries with `INTERSECT` instead of `GROUP BY` with `HAVING COUNT(DISTINCT s.year) = 2`. Do filter for each year separately with `T1.year = 2005` and `T1.year = 2007` in respective queries instead of `(s.year = 2005 OR s.year = 2007)` with a single count condition. Do use table names `salary`, `player`, and `team` instead of `players`, `salaries`, and `teams`. The amended query now correctly identifies players who played for the Washington Nationals in both 2005 and 2007 using intersection logic."
        ],
        "rules": [
            "1) When answering about players paid by Washington Nationals in both 2005 and 2007: use table aliases T1 for salary, T2 for player, and T3 for team. 2) When joining tables: link salary and player using T1.player_id = T2.player_id, and link salary and team using T1.team_id_br = T3.team_id_br. 3) When filtering for Washington Nationals: use exact literal 'Washington Nationals' for T3.name. 4) When checking for both years 2005 and 2007: use separate queries with T1.year = 2005 and T1.year = 2007, then intersect the results. 5) When selecting player names: use columns T2.name_first and T2.name_last instead of first_name and last_name. 6) When combining tables: perform inner matches only using the exact join keys specified in the amends."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.first_name, p.last_name \nFROM players p\nJOIN salaries s ON p.player_id = s.player_id\nJOIN teams t ON s.team_id = t.team_id\nWHERE t.name = 'Washington Nationals' \nAND (s.year = 2005 OR s.year = 2007)\nGROUP BY p.player_id\nHAVING COUNT(DISTINCT s.year) = 2;",
            "SELECT T2.name_first, T2.name_last\nFROM salary T1\nJOIN player T2 ON T1.player_id = T2.player_id\nJOIN team T3 ON T1.team_id = T3.team_id_br\nWHERE T1.year = 2005 AND T3.name = 'Washington Nationals'\nINTERSECT\nSELECT T2.name_first, T2.name_last\nFROM salary T1\nJOIN player T2 ON T1.player_id = T2.player_id\nJOIN team T3 ON T1.team_id = T3.team_id_br\nWHERE T1.year = 2007 AND T3.name = 'Washington Nationals'"
        ],
        "rule_sql": [
            "SELECT T2.name_first, T2.name_last\nFROM salary T1\nJOIN player T2 ON T1.player_id = T2.player_id\nJOIN team T3 ON T1.team_id_br = T3.team_id_br\nWHERE T3.name = 'Washington Nationals' AND T1.year = 2005\n\nINTERSECT\n\nSELECT T2.name_first, T2.name_last\nFROM salary T1\nJOIN player T2 ON T1.player_id = T2.player_id\nJOIN team T3 ON T1.team_id_br = T3.team_id_br\nWHERE T3.name = 'Washington Nationals' AND T1.year = 2007"
        ]
    },
    "1632": {
        "db_id": "wedding",
        "question": "Show the opening year in whcih at least two churches opened.",
        "ground_truth": "SELECT open_date FROM church GROUP BY open_date HAVING count(*)  >=  2",
        "amends": [
            "Do reference table `church` instead of `churches` in the FROM clause. Do select column `open_date` instead of `opening_year` in the SELECT list. Do use comparison operator `>= 2` instead of `> 1` in the HAVING clause to properly identify dates with two or more occurrences. The amended query now correctly identifies duplicate open dates in the church table with the appropriate threshold."
        ],
        "rules": [
            "1) When the question mentions \"churches\": use the exact table name \"church\" instead of \"churches\". 2) When the question asks for \"opening year\": use the exact column name \"open_date\" instead of \"opening_year\". 3) When counting occurrences to find years with \"at least two churches\": use the comparison operator >= 2 instead of > 1 to properly include cases with exactly two occurrences."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT opening_year FROM churches GROUP BY opening_year HAVING COUNT(*) > 1;",
            "SELECT open_date FROM church GROUP BY open_date HAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT open_date FROM church GROUP BY open_date HAVING COUNT(*) >= 2;"
        ]
    },
    "1723": {
        "db_id": "riding_club",
        "question": "Show the names of sponsors of players whose residence is either \"Brandon\" or \"Birtle\".",
        "ground_truth": "SELECT Sponsor_name FROM player WHERE Residence  =  \"Brandon\" OR Residence  =  \"Birtle\"",
        "amends": [
            "Do reference the `Sponsor_name` column instead of `sponsor_name` and use the `player` table instead of `sponsors`. Do filter on `Residence` column instead of `player_residence` while maintaining the same OR condition for 'Brandon' and 'Birtle' values. The amended query now correctly retrieves sponsor names from the player table based on residence criteria, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"sponsors of players\": use the \"Sponsor_name\" column from the \"player\" table to get sponsor names. 2) When filtering by player residence: use the \"Residence\" column from the \"player\" table instead of \"player_residence\". 3) When the question specifies residence is either \"Brandon\" or \"Birtle\": filter rows where \"Residence\" equals 'Brandon' OR \"Residence\" equals 'Birtle' exactly as written. 4) When producing output: return only the \"Sponsor_name\" column values from matching rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT sponsor_name FROM sponsors WHERE player_residence = 'Brandon' OR player_residence = 'Birtle';",
            "SELECT Sponsor_name FROM player WHERE Residence = 'Brandon' OR Residence = 'Birtle'"
        ],
        "rule_sql": [
            "SELECT Sponsor_name FROM player WHERE Residence = 'Brandon' OR Residence = 'Birtle'"
        ]
    },
    "2458": {
        "db_id": "movie_1",
        "question": "Find the titles of all movies that have no ratings.",
        "ground_truth": "SELECT title FROM Movie WHERE mID NOT IN (SELECT mID FROM Rating)",
        "amends": [
            "Do reference the `Movie` table instead of `movies` in the FROM clause. Do use a subquery with `mID NOT IN (SELECT mID FROM Rating)` instead of checking `rating IS NULL` in the WHERE filter, as this correctly identifies movies that have no ratings at all rather than movies with NULL rating values. The amended query now matches RIGHT_SQL's behavior by properly finding movies without any ratings in the Rating table."
        ],
        "rules": [
            "1) When the question asks for movies with no ratings: use the table \"Movie\" instead of \"movies\" to reference the movie data. 2) When identifying movies without ratings: check for movies where the mID is not found in the Rating table using mID NOT IN (SELECT mID FROM Rating), rather than checking for NULL rating values. 3) When producing output: return only the title column from the Movie table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM movies WHERE rating IS NULL;",
            "SELECT title FROM Movie WHERE mID NOT IN (SELECT mID FROM Rating)"
        ],
        "rule_sql": [
            "SELECT title FROM Movie WHERE mID NOT IN (SELECT mID FROM Rating)"
        ]
    },
    "3074": {
        "db_id": "loan_1",
        "question": "Find the the name of the customers who have a loan with amount more than 3000.",
        "ground_truth": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id WHERE amount  >  3000",
        "amends": [
            "Do reference the `cust_name` column from the `customer` table instead of `customer_name` from `customers`. Do join the `loan` table on `cust_id` instead of querying only the `customers` table. Do filter on `amount` from the `loan` table instead of `loan_amount` from the `customers` table. The amended query now correctly joins customer and loan data and filters based on loan amounts exceeding 3000, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for customer names: use the exact column token \"cust_name\" from the \"customer\" table. 2) When combining customer and loan data: link rows where customer.cust_id equals loan.cust_id and keep only matching pairs (inner match). 3) When filtering for loans with amount more than 3000: use the exact column token \"amount\" from the \"loan\" table and apply the condition > 3000. 4) When the question mentions \"loan with amount\": the filtering condition must be applied to the \"loan\" table's \"amount\" column, not the \"customers\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT customer_name FROM customers WHERE loan_amount > 3000",
            "SELECT c.cust_name FROM customer c JOIN loan l ON c.cust_ID = l.cust_ID WHERE l.amount > 3000"
        ],
        "rule_sql": [
            "SELECT cust_name FROM customer INNER JOIN loan ON customer.cust_ID = loan.cust_ID WHERE loan.amount > 3000"
        ]
    },
    "2344": {
        "db_id": "csu_1",
        "question": "Which university is in Los Angeles county and opened after 1950?",
        "ground_truth": "SELECT campus FROM campuses WHERE county  =  \"Los Angeles\" AND YEAR  >  1950",
        "amends": [
            "Do select `campus` instead of `name` and use table `campuses` instead of `universities`. Do use column `YEAR` instead of `founded` for the year comparison condition. Do use double quotes `\"Los Angeles\"` instead of single quotes for the county filter value instead of single quotes. The amended query now correctly selects campus names from the campuses table filtered by Los Angeles county and establishments after 1950."
        ],
        "rules": [
            "1) When the question asks about universities: use the \"campuses\" table instead of \"universities\" table. 2) When selecting the university name: use the \"campus\" column instead of \"name\" column. 3) When filtering by establishment year: use the \"YEAR\" column instead of \"founded\" column for year comparison. 4) When filtering by county name \"Los Angeles\": use double quotes exactly as \"Los Angeles\" for the literal value. 5) When comparing establishment year: use greater than comparison for years after 1950."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM universities WHERE county = 'Los Angeles' AND founded > 1950;",
            "SELECT Campus FROM Campuses WHERE County = \"Los Angeles\" AND Year > 1950"
        ],
        "rule_sql": [
            "SELECT Campus FROM Campuses WHERE County = \"Los Angeles\" AND Year > 1950;"
        ]
    },
    "1460": {
        "db_id": "college_2",
        "question": "Find the name of students who took some course offered by Statistics department.",
        "ground_truth": "SELECT T3.name FROM course AS T1 JOIN takes AS T2 ON T1.course_id  =  T2.course_id JOIN student AS T3 ON T2.id  =  T3.id WHERE T1.dept_name  =  'Statistics'",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `c`, `e`, and `s`. Do reference `T3.name` instead of `s.name` in the SELECT list. Do join `course AS T1` instead of `courses c` as the first table. Do join `takes AS T2` instead of `enrollments e` as the second table. Do join `student AS T3` instead of `students s` as the third table. Do use join condition `T1.course_id = T2.course_id` instead of `s.id = e.student_id`. Do use join condition `T2.id = T3.id` instead of `e.course_id = c.id`. Do filter on `T1.dept_name = 'Statistics'` instead of `c.department = 'Computer Science'`. The amended query now correctly retrieves student names from the Statistics department using the proper table relationships and column references."
        ],
        "rules": [
            "1) When joining tables for student course information: use table aliases T1 for course, T2 for takes, and T3 for student exactly as specified in the amends. 2) When selecting student names: reference T3.name instead of any other table's name column. 3) When combining course and takes tables: link rows where T1.course_id = T2.course_id exactly as shown. 4) When combining takes and student tables: link rows where T2.id = T3.id exactly as shown. 5) When filtering by department: use T1.dept_name = 'Statistics' with exact case and spelling, not 'Computer Science' or any other department name. 6) When the question asks about courses offered by Statistics department: ensure the filter condition uses the exact literal 'Statistics' with proper case."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.name FROM students s JOIN enrollments e ON s.id = e.student_id JOIN courses c ON e.course_id = c.id WHERE c.department = 'Computer Science';",
            "SELECT T3.name\nFROM course AS T1\nJOIN takes AS T2 ON T1.course_id = T2.course_id\nJOIN student AS T3 ON T2.ID = T3.ID\nWHERE T1.dept_name = 'Statistics'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T3.name\nFROM course T1\nJOIN takes T2 ON T1.course_id = T2.course_id\nJOIN student T3 ON T2.ID = T3.ID\nWHERE T1.dept_name = 'Statistics';"
        ]
    },
    "1634": {
        "db_id": "wedding",
        "question": "Show all opening years and the number of churches that opened in that year.",
        "ground_truth": "SELECT open_date ,  count(*) FROM church GROUP BY open_date",
        "amends": [
            "Do reference table `church` instead of `churches` and use column `open_date` instead of `opening_year` in both the SELECT list and GROUP BY clause. Do remove the alias `church_count` and ORDER BY clause instead of keeping them, as the RIGHT_SQL focuses solely on counting churches grouped by open date without additional sorting or column aliases."
        ],
        "rules": [
            "1) When the question mentions \"opening years\": \"opening years\" actually means \"open_date in schema\" from table \"church\". 2) When the question asks for \"number of churches\": compute the count using the canonical key from table \"church\". 3) When the question asks for results \"per year\": organize results by \"open_date\" and compute the count per group. 4) When producing output: present columns in the order \"open_date\" followed by the count, without additional sorting or column aliases."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT opening_year, COUNT(*) as church_count FROM churches GROUP BY opening_year ORDER BY opening_year;",
            "SELECT open_date, COUNT(*) FROM church GROUP BY open_date"
        ],
        "rule_sql": [
            "SELECT Open_Date, COUNT(Church_ID) FROM church GROUP BY Open_Date"
        ]
    },
    "3727": {
        "db_id": "mountain_photos",
        "question": "What is the name of each camera lens and the number of photos taken by it? Order the result by the count of photos.",
        "ground_truth": "SELECT T1.name ,  count(*) FROM camera_lens AS T1 JOIN photos AS T2 ON T1.id  =  T2.camera_lens_id GROUP BY T1.id ORDER BY count(*)",
        "amends": [
            "Do join `camera_lens AS T1` with `photos AS T2` on `T1.id = T2.camera_lens_id` instead of querying only the `photos` table. Do select `T1.name` instead of `lens_name` from the photos table. Do group by `T1.id` instead of `lens_name` to ensure proper aggregation. Do order by `count(*)` instead of `lens_name` to sort by the photo count. The amended query now correctly joins the camera_lens table to count photos per lens and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"camera lens names and photo counts\": make sure the output order: T1.name, then count of photos. 2) When combining camera_lens and photos tables: link rows where T1.id = T2.camera_lens_id and keep only matching pairs (inner match). 3) When grouping by camera lens: organize results by T1.id to ensure proper aggregation per lens. 4) When counting photos per lens: compute the number of rows using the photos table entries associated with each lens. 5) When ordering results by photo count: rank rows by the count of photos in descending order (highest count first)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT lens_name, COUNT(*) as photo_count FROM photos GROUP BY lens_name ORDER BY lens_name;",
            "SELECT T1.name, COUNT(*) AS photo_count\nFROM camera_lens AS T1\nJOIN photos AS T2 ON T1.id = T2.camera_lens_id\nGROUP BY T1.id\nORDER BY COUNT(*);"
        ],
        "rule_sql": [
            "SELECT cl.name, COUNT(p.id) AS photo_count\nFROM camera_lens cl\nINNER JOIN photos p ON cl.id = p.camera_lens_id\nGROUP BY cl.id, cl.name\nORDER BY photo_count DESC;"
        ]
    },
    "6635": {
        "db_id": "driving_school",
        "question": "When did the staff member Janessa Sawayn leave the company?",
        "ground_truth": "SELECT date_left_staff FROM Staff WHERE first_name = \"Janessa\" AND last_name = \"Sawayn\";",
        "amends": [
            "Do select `date_left_staff` instead of `hire_date` from the `Staff` table instead of `staff` while maintaining the same `WHERE` filter conditions for `first_name` and `last_name` with double quotes instead of single quotes around the string literals. The amended query now correctly retrieves the departure date instead of the hire date for the specified staff member, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about staff departure dates: select \"date_left_staff\" instead of \"hire_date\" from the \"Staff\" table. 2) When filtering for a specific staff member by name: use exact string literals \"Janessa\" for \"first_name\" and \"Sawayn\" for \"last_name\" with double quotes around the literals. 3) When the question asks about when someone left the company: retrieve the departure date (\"date_left_staff\") rather than the hire date."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT hire_date FROM staff WHERE first_name = 'Janessa' AND last_name = 'Sawayn';",
            "SELECT date_left_staff FROM Staff WHERE first_name = \"Janessa\" AND last_name = \"Sawayn\";"
        ],
        "rule_sql": [
            "SELECT date_left_staff FROM Staff WHERE first_name = \"Janessa\" AND last_name = \"Sawayn\";"
        ]
    },
    "6742": {
        "db_id": "activity_1",
        "question": "How many faculty members do we have for each faculty rank?",
        "ground_truth": "SELECT rank ,  count(*) FROM Faculty GROUP BY rank",
        "amends": [
            "Do use `rank` instead of `faculty_rank` in the SELECT list and GROUP BY clause. Do group by `rank` instead of `faculty_id` to count faculty members by their rank rather than by individual faculty IDs. Do use proper table name `Faculty` instead of `faculty` for schema consistency. The amended query now correctly counts faculty members grouped by their rank categories rather than producing a count for each individual faculty member."
        ],
        "rules": [
            "1) When the question asks for faculty members by faculty rank: use the exact column name \"rank\" instead of \"faculty_rank\" for both selection and grouping. 2) When counting faculty members per rank category: group by \"rank\" rather than by individual faculty IDs to get counts by rank categories. 3) When referring to the faculty table: use the exact table name \"Faculty\" with proper case instead of \"faculty\" for schema consistency."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT faculty_rank, COUNT(*) FROM faculty GROUP BY faculty_id;",
            "SELECT rank, COUNT(*) AS faculty_count FROM Faculty GROUP BY rank;"
        ],
        "rule_sql": [
            "SELECT rank, COUNT(*) AS faculty_count FROM Faculty GROUP BY rank;"
        ]
    },
    "1655": {
        "db_id": "theme_gallery",
        "question": "Show all artist names and the year joined who are not from United States.",
        "ground_truth": "SELECT name ,  year_join FROM artist WHERE country != 'United States'",
        "amends": [
            "Do reference column `year_join` instead of `year_joined` and use table `artist` instead of `artists`. Do change the WHERE condition to `country != 'United States'` instead of `country = 'United States'` to filter for artists not from the United States. The amended query now correctly selects non-US artists with the proper column and table references."
        ],
        "rules": [
            "1) When the question asks for \"artist names\": use the exact column token \"name\" from table \"artist\". 2) When the question asks for \"year joined\": use the exact column token \"year_join\" from table \"artist\", not \"year_joined\". 3) When the question specifies artists \"not from United States\": filter using the condition country != 'United States' with exact literal 'United States'. 4) When referencing the artist table: use the exact table name \"artist\", not \"artists\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, year_joined FROM artists WHERE country = 'United States';",
            "SELECT Name, Year_Join FROM artist WHERE Country != 'United States';"
        ],
        "rule_sql": [
            "SELECT name, year_join FROM artist WHERE country != 'United States'"
        ]
    },
    "3610": {
        "db_id": "music_1",
        "question": "What are the names of the three artists who have produced the most songs, and how many works did they produce?",
        "ground_truth": "SELECT T1.artist_name ,  count(*) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3",
        "amends": [
            "Do join `artist AS T1` with `song AS T2` on `T1.artist_name = T2.artist_name` instead of querying only the `songs` table. Do group by `T2.artist_name` instead of `artist_name` from a single table. Do reference the count as `count(*)` in ORDER BY instead of using the alias `work_count`. Do maintain the same DESC ordering and LIMIT 3 clause. The amended query now correctly joins artist and song tables to count works per artist, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"names of artists who have produced the most songs\": make sure the output order: artist_name, count(*) 2) When the question mentions \"three artists who have produced the most songs\": rank rows by count(*) in descending direction and keep the first 3 rows. 3) When combining T1 (artist) and T2 (song) for shared entities: link rows where T1.artist_name = T2.artist_name exactly as shown; keep only matching pairs (inner match). 4) When the question asks for \"count of works\" per artist: compute the number of rows using the canonical key from the song table (T2.artist_name). 5) When the question says \"per artist\"/\"by artist\": organize results by T2.artist_name and compute count(*) per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT artist_name, COUNT(*) as work_count \nFROM songs \nGROUP BY artist_name \nORDER BY work_count DESC \nLIMIT 3;",
            "SELECT T1.artist_name, COUNT(*) AS work_count\nFROM artist AS T1\nJOIN song AS T2 ON T1.artist_name = T2.artist_name\nGROUP BY T2.artist_name\nORDER BY COUNT(*) DESC\nLIMIT 3;"
        ],
        "rule_sql": [
            "SELECT artist_name, COUNT(*) as works_count FROM song GROUP BY artist_name ORDER BY works_count DESC LIMIT 3"
        ]
    },
    "5085": {
        "db_id": "device",
        "question": "Which locations contains both shops that opened after the year 2012 and shops that opened before 2008?",
        "ground_truth": "SELECT LOCATION FROM shop WHERE Open_Year  >  2012 INTERSECT SELECT LOCATION FROM shop WHERE Open_Year  <  2008",
        "amends": [
            "Do use `INTERSECT` to find locations that satisfy both conditions instead of using `OR` with `GROUP BY/HAVING` which finds locations that satisfy either condition. Do query from table `shop` instead of `shops`. Do use column `Open_Year` instead of `opening_year`. Do remove the `GROUP BY location` and `HAVING COUNT(*) >= 2` clauses instead of keeping them, as the INTERSECT approach inherently finds locations that appear in both result sets. Do structure the query as two separate SELECT statements with INTERSECT instead of a single query with OR logic. The amended query now correctly finds locations that have both shops opened after 2012 and shops opened before 2008, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for locations that contain both shops opened after 2012 and shops opened before 2008: use INTERSECT to combine results from two separate queries instead of using OR logic with GROUP BY/HAVING. 2) When referring to the shop table: use the exact table name \"shop\" instead of \"shops\". 3) When referring to the opening year column: use the exact column name \"Open_Year\" instead of \"opening_year\". 4) When finding shops opened after 2012: use the condition Open_Year > 2012. 5) When finding shops opened before 2008: use the condition Open_Year < 2008."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location \nFROM shops \nWHERE (opening_year > 2012) OR (opening_year < 2008)\nGROUP BY location\nHAVING COUNT(*) >= 2;",
            "SELECT Location FROM shop WHERE Open_Year > 2012\nINTERSECT\nSELECT Location FROM shop WHERE Open_Year < 2008"
        ],
        "rule_sql": [
            "SELECT Location FROM shop WHERE Open_Year > 2012\nINTERSECT\nSELECT Location FROM shop WHERE Open_Year < 2008"
        ]
    },
    "4754": {
        "db_id": "department_store",
        "question": "What are the distinct ids of customers who made an order after any order that was Cancelled?",
        "ground_truth": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  \"Cancelled\")",
        "amends": [
            "Do reference the `Customer_Orders` table instead of `orders`. Do use `order_status_code = \"Cancelled\"` instead of `status = 'Cancelled'` for the filter condition. Do add `min()` aggregation to the subquery instead of selecting a single `order_date` value that could return multiple rows. The amended query now correctly identifies customers with orders after the earliest cancelled order date, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"orders\": use the exact table name \"Customer_Orders\" instead of \"orders\". 2) When filtering for cancelled orders: use the exact condition \"order_status_code = \\\"Cancelled\\\"\" instead of \"status = 'Cancelled'\". 3) When finding the earliest cancelled order date: use min(order_date) aggregation to handle multiple cancelled orders. 4) When identifying customers who made orders after cancelled orders: compare order_date to the minimum cancelled order date from the subquery. 5) When selecting distinct customer identifiers: use DISTINCT customer_id to return unique customer values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT customer_id \nFROM orders \nWHERE order_date > (SELECT order_date FROM orders WHERE status = 'Cancelled')",
            "SELECT DISTINCT co.customer_id\nFROM Customer_Orders co\nWHERE co.order_date > (\n    SELECT MIN(order_date)\n    FROM Customer_Orders\n    WHERE order_status_code = 'Cancelled'\n)"
        ],
        "rule_sql": [
            "SELECT DISTINCT co.customer_id\nFROM Customer_Orders co\nWHERE co.order_date > (\n    SELECT MIN(order_date)\n    FROM Customer_Orders\n    WHERE order_status_code = \"Cancelled\"\n)"
        ]
    },
    "3100": {
        "db_id": "behavior_monitoring",
        "question": "List all information about the assessment notes sorted by date in ascending order.",
        "ground_truth": "SELECT * FROM Assessment_Notes ORDER BY date_of_notes ASC",
        "amends": [
            "Do use the table name `Assessment_Notes` instead of `assessment_notes` to match the correct case sensitivity. Do order by `date_of_notes ASC` instead of `date DESC` to use the correct column name and ascending order direction instead of descending. The amended query now correctly references the proper table and orders by the appropriate date column in ascending sequence, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for information from assessment notes: use the exact table name \"Assessment_Notes\" with proper case sensitivity. 2) When ordering by date in ascending order: use the column \"date_of_notes\" with ASC direction instead of \"date\" with DESC direction."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM assessment_notes ORDER BY date DESC;",
            "SELECT * FROM Assessment_Notes ORDER BY date_of_notes ASC;"
        ],
        "rule_sql": [
            "SELECT * FROM Assessment_Notes ORDER BY date_of_notes ASC;"
        ]
    },
    "5337": {
        "db_id": "manufactory_1",
        "question": "What are the names and prices of products that cost at least 180, sorted by price decreasing and name ascending?",
        "ground_truth": "SELECT name ,  price FROM products WHERE price  >=  180 ORDER BY price DESC ,  name ASC",
        "amends": [
            "Do use `>=` in the WHERE filter instead of `>` to include products priced exactly at 180 instead of excluding them. Do change the ORDER BY to `price DESC` instead of `price ASC` to sort prices in descending order instead of ascending. Do change the ORDER BY to `name ASC` instead of `name DESC` to sort names in ascending order instead of descending. The amended query now correctly includes the boundary price value and produces the intended sort order as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When filtering for products that cost at least 180: use price >= 180 instead of price > 180 to include products priced exactly at 180. 2) When sorting by price decreasing: use price DESC instead of price ASC to sort prices in descending order. 3) When sorting by name ascending: use name ASC instead of name DESC to sort names in ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, price FROM products WHERE price > 180 ORDER BY price ASC, name DESC;",
            "SELECT Name, Price FROM Products WHERE Price >= 180 ORDER BY Price DESC, Name ASC;"
        ],
        "rule_sql": [
            "SELECT Name, Price FROM Products WHERE Price >= 180 ORDER BY Price DESC, Name ASC;"
        ]
    },
    "4204": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "Show all role codes and the number of employees in each role.",
        "ground_truth": "SELECT role_code ,  count(*) FROM Employees GROUP BY role_code",
        "amends": [
            "Do group by `role_code` instead of `employee_id` to correctly count employees per role instead of per individual employee. Do capitalize `Employees` instead of lowercase `employees` to match the correct table name case. The amended query now correctly aggregates counts by role_code as intended."
        ],
        "rules": [
            "1) When the question asks for \"number of employees in each role\": group by the exact token \"role_code\" and count using the canonical key for employees. 2) When referring to the employees table: use the exact table name \"Employees\" with capital E as shown in the schema. 3) When grouping by role codes: make sure the output order shows \"role_code\" first followed by the count of employees."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT role_code, COUNT(*) FROM employees GROUP BY employee_id;",
            "SELECT Role_Code, COUNT(Employee_ID) AS Number_of_Employees FROM Employees GROUP BY Role_Code;"
        ],
        "rule_sql": [
            "SELECT Role_Code, COUNT(Employee_ID) AS Number_of_Employees FROM Employees GROUP BY Role_Code ORDER BY Role_Code;"
        ]
    },
    "1358": {
        "db_id": "college_2",
        "question": "Find the name and budget of departments whose budgets are more than the average budget.",
        "ground_truth": "SELECT dept_name ,  budget FROM department WHERE budget  >  (SELECT avg(budget) FROM department)",
        "amends": [
            "Do reference `dept_name` instead of `name` in the SELECT list. Do reference `department` instead of `departments` as the table name in both the main query and subquery. Do use lowercase `avg` instead of uppercase `AVG` for the aggregate function in the subquery. The amended query now correctly references the department table structure and uses consistent naming conventions."
        ],
        "rules": [
            "1) When the question asks for \"name\" of departments: use the exact column token \"dept_name\" instead of \"name\" from the student table. 2) When referencing the departments table: use the exact table name \"department\" instead of \"departments\". 3) When computing the average budget: use lowercase \"avg\" for the aggregate function instead of uppercase \"AVG\". 4) When the question asks for departments with budgets more than average: compare each department's budget against the average budget computed from all departments."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, budget FROM departments WHERE budget > (SELECT AVG(budget) FROM departments)",
            "SELECT dept_name, budget FROM department WHERE budget > (SELECT avg(budget) FROM department)"
        ],
        "rule_sql": [
            "SELECT dept_name, budget FROM department WHERE budget > (SELECT avg(budget) FROM department)"
        ]
    },
    "5350": {
        "db_id": "manufactory_1",
        "question": "Select the code of the product that is cheapest in each product category.",
        "ground_truth": "SELECT code ,  name ,  min(price) FROM products GROUP BY name",
        "amends": [
            "Do select `code`, `name`, and `min(price)` instead of `category`, `MIN(price) as cheapest_price`, and `product_code`. Do group by `name` instead of `category`. The amended query now correctly groups products by name and selects the corresponding code with minimum price, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for the cheapest product in each category: select the exact column \"code\" for product identification. 2) When grouping products by category: use the exact column \"name\" for grouping instead of \"category\". 3) When finding the minimum price: compute the minimum value of the \"price\" column for each group. 4) When answering about product categories and prices: make sure the output order includes \"code\", \"name\", and \"min(price)\" in that sequence."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT category, MIN(price) as cheapest_price, product_code\nFROM products\nGROUP BY category;",
            "SELECT Code, Name, MIN(Price) FROM Products GROUP BY Name;"
        ],
        "rule_sql": [
            "SELECT p.Code, p.Name, MIN(p.Price) as min_price\nFROM Products p\nGROUP BY p.Name\nORDER BY p.Code, p.Name, min_price;"
        ]
    },
    "1688": {
        "db_id": "theme_gallery",
        "question": "What are the names of artist whose exhibitions draw over 200 attendees on average?",
        "ground_truth": "SELECT T3.name FROM exhibition_record AS T1 JOIN exhibition AS T2 ON T1.exhibition_id  =  T2.exhibition_id JOIN artist AS T3 ON T3.artist_id  =  T2.artist_id GROUP BY T3.artist_id HAVING avg(T1.attendance)  >  200",
        "amends": [
            "Do use `T3.name` from the `artist` table instead of `name` from the `artists` table. Do join three tables (`exhibition_record AS T1`, `exhibition AS T2`, and `artist AS T3`) with proper join conditions instead of querying a single table. Do use `JOIN exhibition AS T2 ON T1.exhibition_id = T2.exhibition_id` and `JOIN artist AS T3 ON T3.artist_id = T2.artist_id` instead of no joins. Do calculate `avg(T1.attendance)` instead of using a raw `exhibition_attendees` column. Do move the filter to `HAVING avg(T1.attendance) > 200` instead of `WHERE exhibition_attendees > 200` since it applies to an aggregate. Do add `GROUP BY T3.artist_id` to properly group the results by artist instead of omitting grouping. The amended query now correctly calculates average attendance per artist across exhibitions rather than using a raw column value."
        ],
        "rules": [
            "1) When answering about artist names whose exhibitions draw over 200 attendees on average: make sure the output order: T3.name 2) When the question mentions \"artist\": \"artist\" actually means \"T3.name in schema\" from the artist table 3) When combining exhibition_record (T1), exhibition (T2), and artist (T3) tables: link rows where T1.exhibition_id = T2.exhibition_id and T3.artist_id = T2.artist_id; keep only matching pairs (inner match) 4) When calculating average attendance per artist: compute avg(T1.attendance) grouped by T3.artist_id 5) When filtering for artists with average attendance over 200: apply the condition avg(T1.attendance) > 200 after grouping instead of before grouping"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM artists WHERE exhibition_attendees > 200;",
            "SELECT T3.Name\nFROM exhibition_record AS T1\nJOIN exhibition AS T2 ON T1.Exhibition_ID = T2.Exhibition_ID\nJOIN artist AS T3 ON T3.Artist_ID = T2.Artist_ID\nGROUP BY T3.Artist_ID\nHAVING AVG(T1.Attendance) > 200"
        ],
        "rule_sql": [
            "SELECT T3.Name\nFROM exhibition_record T1\nJOIN exhibition T2 ON T1.Exhibition_ID = T2.Exhibition_ID\nJOIN artist T3 ON T3.Artist_ID = T2.Artist_ID\nGROUP BY T3.Artist_ID\nHAVING AVG(T1.Attendance) > 200\nORDER BY T3.Name;"
        ]
    },
    "5915": {
        "db_id": "cre_Theme_park",
        "question": "What are the details and opening hours of the museums?",
        "ground_truth": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID",
        "amends": [
            "Do select specific columns `T1.Museum_Details` and `T2.Opening_Hours` instead of using `*` wildcard selection. Do join table `TOURIST_ATTRACTIONS AS T2` instead of querying only the `museums` table. Do use `JOIN` with predicate `T1.Museum_ID = T2.Tourist_Attraction_ID` instead of filtering with `WHERE opening_hours IS NULL`. Do remove the `IS NULL` filter condition instead of keeping it, as the join now properly relates museum details with their corresponding opening hours from the tourist attractions table. The amended query correctly establishes the relationship between museums and tourist attractions to retrieve opening hours data instead of incorrectly assuming opening hours are stored directly in the museums table."
        ],
        "rules": [
            "1) When answering about \"details and opening hours of museums\": make sure the output order: T1.Museum_Details, T2.Opening_Hours. 2) When combining museums and tourist attractions tables: link rows where T1.Museum_ID = T2.Tourist_Attraction_ID and keep only matching pairs (inner match). 3) When selecting columns: do not use wildcard selection (*) but instead select specific columns T1.Museum_Details and T2.Opening_Hours. 4) When the question asks for museum details and opening hours: retrieve data from both museums table (as T1) and tourist_attractions table (as T2) instead of querying only the museums table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM museums WHERE opening_hours IS NULL;",
            "SELECT T1.Museum_Details, T2.Opening_Hours \nFROM Museums AS T1 \nJOIN Tourist_Attractions AS T2 ON T1.Museum_ID = T2.Tourist_Attraction_ID"
        ],
        "rule_sql": [
            "SELECT T1.Museum_Details, T2.Opening_Hours\nFROM Museums AS T1\nINNER JOIN Tourist_Attractions AS T2 ON T1.Museum_ID = T2.Tourist_Attraction_ID"
        ]
    },
    "3765": {
        "db_id": "program_share",
        "question": "What is the total rating of channel for each channel owner?",
        "ground_truth": "SELECT sum(Rating_in_percent) ,  OWNER FROM channel GROUP BY OWNER",
        "amends": [
            "Do use `SUM(Rating_in_percent)` instead of `SUM(rating)` for the aggregate function and column reference. Do specify `OWNER` in the SELECT list instead of `owner` for case consistency. Do group by `OWNER` instead of `channel` to match the correct grouping logic. Do reference table `channel` (singular) instead of `channels` (plural) for the correct table name. The amended query now correctly aggregates ratings by owner rather than by channel, matching the intended behavior.",
            "Do place the aggregate function `SUM(Rating_in_percent)` first in the SELECT list instead of placing `Owner` first. Do remove the alias `Total_Rating` instead of keeping it. Do use uppercase `OWNER` instead of mixed case `Owner` in both the SELECT list and GROUP BY clause. The amended query now correctly groups by OWNER and calculates the sum of ratings without unnecessary aliasing.",
            "Do place the `OWNER` column after the aggregate function `sum(Rating_in_percent)` in the SELECT list instead of listing it first, maintaining the same GROUP BY logic and table source without any changes to join conditions, filters, or other query clauses. The amended query now correctly matches RIGHT_SQL's behavior with identical output results."
        ],
        "rules": [
            "1) When the question asks for \"total rating of channel for each channel owner\": use SUM(\"Rating_in_percent\") as the aggregate function instead of SUM(rating). 2) When selecting the owner column: use exact token \"OWNER\" with uppercase case consistency instead of owner. 3) When grouping results by channel owner: group by \"OWNER\" instead of channel to match the correct grouping logic. 4) When referencing the table containing channel data: use table name \"channel\" (singular) instead of channels (plural). 5) When computing aggregates per channel owner: organize results by \"OWNER\" and compute the sum of \"Rating_in_percent\" for each owner group.",
            "1) When answering about \"total rating of channel for each channel owner\": make sure the output order: SUM(Rating_in_percent) first, then OWNER. 2) When the question mentions \"channel owner\": \"channel owner\" actually means \"OWNER in schema\". 3) When the question asks for \"total rating\": compute the sum of Rating_in_percent values. 4) When the question says \"for each channel owner\": organize results by OWNER and compute the sum of ratings per group. 5) When producing output: do not use aliases like Total_Rating for aggregate functions.",
            "1) When the question asks for \"total rating of channel for each channel owner\": compute the sum of \"Rating_in_percent\" values for each distinct \"OWNER\" value. 2) When organizing results by channel owner: group rows by the \"OWNER\" column and compute the requested aggregate per group. 3) When producing output for this question: place the aggregate result column \"sum(Rating_in_percent)\" before the grouping column \"OWNER\" in the output order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT owner, SUM(rating) FROM channels GROUP BY channel;",
            "SELECT Owner, SUM(Rating_in_percent) AS Total_Rating FROM channel GROUP BY Owner;",
            "SELECT OWNER, SUM(Rating_in_percent) FROM channel GROUP BY OWNER",
            "SELECT SUM(Rating_in_percent), OWNER FROM channel GROUP BY OWNER"
        ],
        "rule_sql": [
            "SELECT SUM(\"Rating_in_percent\"), \"OWNER\" FROM \"channel\" GROUP BY \"OWNER\""
        ]
    },
    "4093": {
        "db_id": "student_1",
        "question": "Which teacher teaches the most students? Give me the first name and last name of the teacher.",
        "ground_truth": "SELECT T2.firstname ,  T2.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom GROUP BY T2.firstname ,  T2.lastname ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.firstname` and `T2.lastname` instead of `t.first_name` and `t.last_name`. Do join `list AS T1` with `teachers AS T2` on `T1.classroom = T2.classroom` instead of joining `teachers t` with `students s` on `t.teacher_id = s.teacher_id`. Do group by `T2.firstname` and `T2.lastname` instead of grouping by `t.teacher_id`. Do order by `count(*) DESC` instead of ordering by `COUNT(s.student_id) ASC`. The amended query now correctly identifies teachers from the same classroom and orders by descending count to find the teacher with the most students, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting teacher names: use \"T2.firstname\" and \"T2.lastname\" instead of first_name and last_name. 2) When combining teacher and student data: join \"list AS T1\" with \"teachers AS T2\" on \"T1.classroom = T2.classroom\" instead of using teacher_id. 3) When grouping results: group by both \"T2.firstname\" and \"T2.lastname\" instead of teacher_id. 4) When ordering to find the teacher with most students: order by count(*) in descending order instead of ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.first_name, t.last_name \nFROM teachers t \nJOIN students s ON t.teacher_id = s.teacher_id \nGROUP BY t.teacher_id \nORDER BY COUNT(s.student_id) ASC \nLIMIT 1;",
            "SELECT T2.FirstName, T2.LastName\nFROM list AS T1\nJOIN teachers AS T2 ON T1.Classroom = T2.Classroom\nGROUP BY T2.FirstName, T2.LastName\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.firstname, T2.lastname\nFROM list AS T1\nJOIN teachers AS T2 ON T1.Classroom = T2.Classroom\nGROUP BY T2.firstname, T2.lastname\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "2232": {
        "db_id": "formula_1",
        "question": "What are the ids and last names of all drivers who participated in the most races?",
        "ground_truth": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN results AS T2 ON T1.driverid = T2.driverid JOIN races AS T3 ON T2.raceid = T3.raceid GROUP BY T1.driverid ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `JOIN results AS T2 ON T1.driverid = T2.driverid` and `JOIN races AS T3 ON T2.raceid = T3.raceid` instead of querying only the `drivers` table. Do use `T1.driverid` and `T1.surname` instead of `driver_id` and `last_name`. Do add `GROUP BY T1.driverid` instead of omitting it. Do use `count(*)` instead of `COUNT(race_id)` in the ORDER BY clause. Do reference the joined tables properly instead of attempting to aggregate without grouping. The amended query now correctly joins the necessary tables to count race results per driver and returns the driver with the most race participations."
        ],
        "rules": [
            "1) When answering about \"drivers who participated in the most races\": make sure to join tables \"drivers\" as T1, \"results\" as T2, and \"races\" as T3. 2) When combining T1 and T2 for shared entities: link rows where T1.driverid = T2.driverid exactly as shown. 3) When combining T2 and T3 for shared entities: link rows where T2.raceid = T3.raceid exactly as shown. 4) When the question asks for \"count of races participated\": compute the number of rows using count(*) per driver group. 5) When the question mentions \"ids and last names\": \"ids\" actually means \"T1.driverid\" in schema and \"last names\" actually means \"T1.surname\" in schema. 6) When the question asks for \"drivers who participated in the most races\": rank rows by count(*) in descending order and keep the first 1 row. 7) When producing output: make sure the output order is T1.driverid, T1.surname."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT driver_id, last_name FROM drivers ORDER BY COUNT(race_id) DESC LIMIT 1;",
            "SELECT T1.driverId, T1.surname\nFROM drivers AS T1\nJOIN results AS T2 ON T1.driverId = T2.driverId\nJOIN races AS T3 ON T2.raceId = T3.raceId\nGROUP BY T1.driverId\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.driverId, T1.surname\nFROM drivers AS T1\nJOIN results AS T2 ON T1.driverId = T2.driverId\nJOIN races AS T3 ON T2.raceId = T3.raceId\nGROUP BY T1.driverId, T1.surname\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "3151": {
        "db_id": "assets_maintenance",
        "question": "Which part has the least chargeable amount? List the part id and amount.",
        "ground_truth": "SELECT part_id ,  chargeable_amount FROM Parts ORDER BY chargeable_amount ASC LIMIT 1",
        "amends": [
            "Do select `part_id, chargeable_amount` instead of `part_id, MAX(chargeable_amount) AS amount`. Do remove the `MAX` aggregate function instead of keeping it. Do order by `chargeable_amount` instead of the aliased `amount`. Do reference the table as `Parts` instead of `parts`. The amended query now correctly selects individual chargeable amounts without aggregation and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"which part has the least chargeable amount\": make sure the output order: part_id, chargeable_amount. 2) When the question asks for the \"least chargeable amount\": order rows by chargeable_amount in ascending direction and keep the first 1 row. 3) When selecting from the Parts table: reference the table as \"Parts\" instead of \"parts\". 4) When computing the chargeable amount: do not apply aggregate functions like MAX, instead select the individual chargeable_amount values directly."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT part_id, MAX(chargeable_amount) AS amount FROM parts ORDER BY amount ASC LIMIT 1;",
            "SELECT part_id, chargeable_amount FROM Parts ORDER BY chargeable_amount LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT part_id, chargeable_amount FROM Parts ORDER BY chargeable_amount ASC LIMIT 1;"
        ]
    },
    "409": {
        "db_id": "flight_1",
        "question": "Which destination has least number of flights?",
        "ground_truth": "SELECT destination FROM Flight GROUP BY destination ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do reference the table as `Flight` instead of `flights` in the FROM clause. Do remove the explicit column alias `flight_count` instead of keeping it in the SELECT list. Do use `count(*)` directly in the ORDER BY clause instead of referencing the alias `flight_count`. The amended query now correctly identifies the destination with the fewest flights by counting records per destination and ordering by that count.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, and do remove the explicit `ASC` direction from the ORDER BY clause instead of specifying it, while maintaining the same GROUP BY destination and ORDER BY count(*) logic with LIMIT 1. The amended query now matches RIGHT_SQL's behavior by returning only the destination column while preserving the same aggregation and ordering logic to find the destination with the lowest flight count."
        ],
        "rules": [
            "1) When answering about \"destination with least number of flights\": make sure the output order: destination, count(*) 2) When the question mentions \"destination\": \"destination\" actually means \"destination in schema\" 3) When counting flights: compute the number of rows using count(*) 4) When the question asks for \"least number of flights\": rank rows by count(*) in ascending order and keep the first 1 row 5) When referring to the flights table: use the exact table name \"Flight\" with double quotes as shown in the schema",
            "1) When answering about \"which destination has least number of flights\": make sure the output order includes only the destination column. 2) When counting flights per destination: compute the number of rows using the canonical key for flights. 3) When finding the destination with the least number of flights: rank destinations by flight count in ascending order and keep only the first 1 row. 4) When ordering by count: do not specify explicit ASC direction as it is the default ordering."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT destination, COUNT(*) as flight_count FROM flights GROUP BY destination ORDER BY flight_count ASC LIMIT 1;",
            "SELECT destination, COUNT(*) FROM Flight GROUP BY destination ORDER BY COUNT(*) ASC LIMIT 1;",
            "SELECT destination FROM Flight GROUP BY destination ORDER BY count(*) LIMIT 1"
        ],
        "rule_sql": [
            "SELECT destination, COUNT(*) FROM \"Flight\" GROUP BY destination ORDER BY COUNT(*) LIMIT 1"
        ]
    },
    "948": {
        "db_id": "medicine_enzyme_interaction",
        "question": "What are the names of the enzymes used in the medicine  Amisulpride that acts as inhibitors?",
        "ground_truth": "SELECT T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id JOIN medicine AS T3 ON T2.medicine_id  =  T3.id WHERE T3.name  =  'Amisulpride' AND T2.interaction_type  =  'inhibitor'",
        "amends": [
            "Do use explicit joins with `enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id = T2.enzyme_id JOIN medicine AS T3 ON T2.medicine_id = T3.id` instead of querying a single `enzymes` table. Do select `T1.name` instead of `enzyme_name`. Do filter on `T3.name = 'Amisulpride'` instead of `medicine_name = 'Amisulpride'`. Do filter on `T2.interaction_type = 'inhibitor'` instead of `action = 'inhibitor'`. The amended query now correctly joins the three normalized tables to retrieve enzyme names based on medicine interactions."
        ],
        "rules": [
            "1) When answering about enzyme names for medicine Amisulpride acting as inhibitors: combine tables using enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id = T2.enzyme_id JOIN medicine AS T3 ON T2.medicine_id = T3.id. 2) When selecting enzyme names: use T1.name instead of enzyme_name. 3) When filtering for medicine Amisulpride: use T3.name = 'Amisulpride' instead of medicine_name = 'Amisulpride'. 4) When filtering for inhibitor action: use T2.interaction_type = 'inhibitor' instead of action = 'inhibitor'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT enzyme_name FROM enzymes WHERE medicine_name = 'Amisulpride' AND action = 'inhibitor';",
            "SELECT T1.name \nFROM enzyme AS T1 \nJOIN medicine_enzyme_interaction AS T2 ON T1.id = T2.enzyme_id \nJOIN medicine AS T3 ON T2.medicine_id = T3.id \nWHERE T3.name = 'Amisulpride' \nAND T2.interaction_type = 'inhibitor'"
        ],
        "rule_sql": [
            "SELECT T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id = T2.enzyme_id JOIN medicine AS T3 ON T2.medicine_id = T3.id WHERE T3.name = 'Amisulpride' AND T2.interaction_type = 'inhibitor'"
        ]
    },
    "3656": {
        "db_id": "baseball_1",
        "question": "Find the average height of the players who belong to the college called 'Yale University'.",
        "ground_truth": "SELECT avg(T1.height) FROM player AS T1 JOIN player_college AS T2 ON T1.player_id  =  T2.player_id JOIN college AS T3 ON T3.college_id  =  T2.college_id WHERE T3.name_full  =  'Yale University';",
        "amends": [
            "Do join `player AS T1` with `player_college AS T2` on `T1.player_id = T2.player_id` and then with `college AS T3` on `T3.college_id = T2.college_id` instead of querying only the `players` table. Do filter on `T3.name_full = 'Yale University'` instead of filtering directly on `college = 'Yale University'` which references a non-existent column. Do use the fully qualified column reference `avg(T1.height)` instead of just `AVG(height)` to specify the table source. The amended query now correctly joins the necessary tables to establish the relationship between players and colleges and properly filters based on the college name from the college table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about average height of players from a specific college: join player AS T1 with player_college AS T2 on T1.player_id = T2.player_id, then join with college AS T3 on T3.college_id = T2.college_id to establish the relationship between players and colleges. 2) When filtering for college name 'Yale University': use T3.name_full = 'Yale University' exactly as specified, not filtering directly on a college column in the players table. 3) When computing average height: use the fully qualified column reference avg(T1.height) to specify the table source. 4) When combining tables for player-college relationships: perform inner matches using the exact key equalities T1.player_id = T2.player_id and T3.college_id = T2.college_id, keeping only matching pairs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(height) FROM players WHERE college = 'Yale University'",
            "SELECT AVG(T1.height) FROM player AS T1 JOIN player_college AS T2 ON T1.player_id = T2.player_id JOIN college AS T3 ON T3.college_id = T2.college_id WHERE T3.name_full = 'Yale University'"
        ],
        "rule_sql": [
            "SELECT AVG(T1.height) \nFROM player AS T1 \nINNER JOIN player_college AS T2 ON T1.player_id = T2.player_id \nINNER JOIN college AS T3 ON T3.college_id = T2.college_id \nWHERE T3.name_full = 'Yale University'"
        ]
    },
    "470": {
        "db_id": "allergy_1",
        "question": "What are the full names and ages for all female students whose sex is F?",
        "ground_truth": "SELECT Fname ,  Lname ,  Age FROM Student WHERE Sex  =  'F'",
        "amends": [
            "Do use column aliases `Fname`, `Lname`, and `Age` instead of `first_name`, `last_name`, and `age`. Do reference table `Student` instead of `students`. Do filter on condition `Sex = 'F'` instead of `gender = 'M'`. The amended query now correctly selects female students from the Student table with appropriate column naming."
        ],
        "rules": [
            "1) When answering about female students: filter rows where \"Sex\" equals 'F' exactly. 2) When selecting student names and age: use columns \"Fname\", \"Lname\", and \"Age\" from table \"Student\". 3) When the question asks for \"full names\": output both \"Fname\" and \"Lname\" columns. 4) When the question mentions \"female students\": this corresponds to \"Sex\" = 'F' in the schema, not 'gender' = 'M'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name, age FROM students WHERE gender = 'M';",
            "SELECT Fname, Lname, Age FROM Student WHERE Sex = 'F';"
        ],
        "rule_sql": [
            "SELECT Fname, Lname, Age FROM Student WHERE Sex = 'F'"
        ]
    },
    "3968": {
        "db_id": "hospital_1",
        "question": "List the name and cost of all procedures sorted by the cost from the highest to the lowest.",
        "ground_truth": "SELECT name ,  cost FROM procedures ORDER BY cost DESC",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, cost FROM procedures ORDER BY cost ASC;"
        ],
        "rule_sql": [
            "SELECT Name, Cost FROM Procedures ORDER BY Cost DESC;"
        ]
    },
    "4160": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "How many calendar items do we have?",
        "ground_truth": "SELECT count(*) FROM Ref_calendar",
        "amends": [
            "Do query from `Ref_calendar` table instead of `events` table, changing the data source entirely. The amended query now correctly counts records from the Ref_calendar table instead of the events table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"calendar items\": make sure to use the \"Ref_calendar\" table as the data source instead of the \"events\" table. 2) When counting calendar items: compute the number of rows using all records from the \"Ref_calendar\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM events;",
            "SELECT COUNT(*) FROM Ref_Calendar;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Ref_Calendar;"
        ]
    },
    "5134": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "What are the names of workshop groups in which services with product name \"film\" are performed?",
        "ground_truth": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  \"film\"",
        "amends": [
            "Do select `T1.Store_Phone` and `T1.Store_Email_Address` instead of `wg.name`. Do use table alias `T1` for `Drama_Workshop_Groups` instead of `wg` for `workshop_groups`. Do join `Services AS T2` instead of `services s`. Do use join condition `T1.Workshop_Group_ID = T2.Workshop_Group_ID` instead of `wg.id = s.workshop_group_id`. Do remove the join to `products p` instead of keeping it. Do filter on `T2.Product_Name = \"film\"` instead of `p.name = 'film'`. The amended query now correctly retrieves store contact information for workshop groups offering film products directly from the Services table without requiring an additional products join."
        ],
        "rules": [
            "1) When answering about workshop groups with services containing product name \"film\": select T1.Store_Phone and T1.Store_Email_Address as output columns. 2) When combining Drama_Workshop_Groups (T1) and Services (T2): link rows where T1.Workshop_Group_ID = T2.Workshop_Group_ID and keep only matching pairs. 3) When filtering for services with product name \"film\": include only rows where T2.Product_Name = \"film\" exactly. 4) When the schema shows identifiers with double quotes: use double quotes for all identifiers like \"film\" and Workshop_Group_ID."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT wg.name \nFROM workshop_groups wg\nJOIN services s ON wg.id = s.workshop_group_id\nJOIN products p ON s.product_id = p.id\nWHERE p.name = 'film';",
            "SELECT T1.Store_Phone, T1.Store_Email_Address\nFROM Drama_Workshop_Groups AS T1\nJOIN Services AS T2 ON T1.Workshop_Group_ID = T2.Workshop_Group_ID\nWHERE T2.Product_Name = 'film'"
        ],
        "rule_sql": [
            "SELECT T1.Store_Phone, T1.Store_Email_Address\nFROM Drama_Workshop_Groups T1\nINNER JOIN Services T2 ON T1.Workshop_Group_ID = T2.Workshop_Group_ID\nWHERE T2.Product_Name = \"film\""
        ]
    },
    "5594": {
        "db_id": "products_gen_characteristics",
        "question": "What is the characteristic name used by most number of the products?",
        "ground_truth": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `products AS t1` with `product_characteristics AS t2` on `t1.product_id = t2.product_id` instead of querying only the products table, then join `CHARACTERISTICS AS t3` on `t2.characteristic_id = t3.characteristic_id` instead of missing these necessary table relationships. Do select `t3.characteristic_name` instead of just `characteristic_name` to specify the correct source table. Do group by `t3.characteristic_name` instead of the ambiguous column reference. Do order by `count(*) DESC` instead of the alias `count` to reference the actual aggregate function. The amended query now correctly joins the necessary tables to access characteristic data and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"characteristic name used by most number of products\": join products AS T1 with product_characteristics AS T2 on T1.product_id = T2.product_id, then join CHARACTERISTICS AS T3 on T2.characteristic_id = T3.characteristic_id to access characteristic data. 2) When counting products per characteristic: group by T3.characteristic_name and count using the canonical key from the products table. 3) When finding the most frequently used characteristic: order the results by count(*) in descending order and keep only the top result. 4) When selecting the characteristic name: use T3.characteristic_name to specify the correct source table from the CHARACTERISTICS table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT characteristic_name, COUNT(*) as count FROM products GROUP BY characteristic_name ORDER BY count DESC LIMIT 1;",
            "SELECT t3.characteristic_name\nFROM products AS t1\nJOIN product_characteristics AS t2 ON t1.product_id = t2.product_id\nJOIN characteristics AS t3 ON t2.characteristic_id = t3.characteristic_id\nGROUP BY t3.characteristic_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T3.characteristic_name\nFROM Products AS T1\nJOIN Product_Characteristics AS T2 ON T1.product_id = T2.product_id\nJOIN Characteristics AS T3 ON T2.characteristic_id = T3.characteristic_id\nGROUP BY T3.characteristic_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "6921": {
        "db_id": "tracking_orders",
        "question": "Find the ids of orders which are shipped after 2000-01-01.",
        "ground_truth": "SELECT order_id FROM shipments WHERE shipment_date > \"2000-01-01\"",
        "amends": [
            "Do query the `shipments` table instead of the `orders` table. Do use the `shipment_date` column instead of the `shipped_date` column. Do use double quotes for the date literal instead of single quotes. The amended query now correctly retrieves order IDs from the shipments table based on shipment dates after January 1, 2000, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"ids of orders which are shipped after 2000-01-01\": use the \"shipments\" table instead of the \"orders\" table. 2) When filtering by shipment date after January 1, 2000: use the \"shipment_date\" column instead of \"shipped_date\" column. 3) When specifying the date literal \"2000-01-01\": use double quotes instead of single quotes around the literal value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT order_id FROM orders WHERE shipped_date > '2000-01-01';",
            "SELECT order_id FROM Shipments WHERE shipment_date > \"2000-01-01\""
        ],
        "rule_sql": [
            "SELECT DISTINCT order_id FROM Shipments WHERE shipment_date > \"2000-01-01\""
        ]
    },
    "665": {
        "db_id": "journal_committee",
        "question": "List the date, theme and sales of the journal which did not have any of the listed editors serving on committee.",
        "ground_truth": "SELECT date ,  theme ,  sales FROM journal EXCEPT SELECT T1.date ,  T1.theme ,  T1.sales FROM journal AS T1 JOIN journal_committee AS T2 ON T1.journal_ID  =  T2.journal_ID",
        "amends": [
            "Do use `EXCEPT` with a join-based subquery instead of `NOT IN` with a subquery. Do join `journal AS T1` with `journal_committee AS T2` on `T1.journal_ID = T2.journal_ID` instead of filtering by `editor_id NOT IN` a committee subquery. Do reference the correct join condition `T1.journal_ID = T2.journal_ID` instead of the incorrect editor-based filtering approach. The amended query now correctly identifies journals not associated with any committee through proper table relationships rather than relying on editor membership checks."
        ],
        "rules": [
            "1) When answering about journals without committee associations: use EXCEPT with a join-based approach instead of NOT IN with subqueries. 2) When combining journal and journal_committee tables: link rows where T1.journal_ID = T2.journal_ID exactly as specified. 3) When identifying journals not associated with any committee: perform an inner match between journal AS T1 and journal_committee AS T2 using the exact join condition T1.journal_ID = T2.journal_ID. 4) When producing output columns: maintain the exact order date, theme, sales from the journal table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT date, theme, sales FROM journal WHERE editor_id NOT IN (SELECT editor_id FROM committee);",
            "SELECT T1.Date, T1.Theme, T1.Sales\nFROM journal AS T1\nEXCEPT\nSELECT T1.Date, T1.Theme, T1.Sales\nFROM journal AS T1\nJOIN journal_committee AS T2 ON T1.Journal_ID = T2.Journal_ID"
        ],
        "rule_sql": [
            "SELECT j.Date, j.Theme, j.Sales\nFROM journal j\nEXCEPT\nSELECT j.Date, j.Theme, j.Sales\nFROM journal j\nINNER JOIN journal_committee jc ON j.Journal_ID = jc.Journal_ID;"
        ]
    },
    "6787": {
        "db_id": "activity_1",
        "question": "Show the ids of the students who don't participate in any activity.",
        "ground_truth": "SELECT StuID FROM Student EXCEPT SELECT StuID FROM Participates_in",
        "amends": [
            "Do select `StuID` instead of `student_id` and use an `EXCEPT` set operation instead of a `WHERE activity_id IS NULL` filter. Do reference the `Student` table instead of `students` and add a second query against the `Participates_in` table instead of omitting it. Do remove the `WHERE` clause entirely instead of keeping the null check, as the set operation now correctly identifies students not participating by excluding those in the participation table."
        ],
        "rules": [
            "1) When answering about \"students who don't participate in any activity\": use the exact identifier \"StuID\" from the \"Student\" table instead of \"student_id\". 2) When identifying non-participating students: use a set operation (EXCEPT) to exclude students found in the \"Participates_in\" table rather than checking for NULL activity_id values. 3) When combining data from multiple tables: reference both the \"Student\" table and the \"Participates_in\" table as separate queries in the set operation. 4) When filtering for non-participation: do not use a WHERE clause with null checks as the set operation correctly handles the exclusion logic."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id FROM students WHERE activity_id IS NULL;",
            "SELECT StuID FROM Student\nEXCEPT\nSELECT stuid FROM Participates_in"
        ],
        "rule_sql": [
            "SELECT StuID FROM Student\nEXCEPT\nSELECT stuid FROM Participates_in"
        ]
    },
    "2016": {
        "db_id": "gas_company",
        "question": "What is the total number of gas stations that opened between 2000 and 2005?",
        "ground_truth": "SELECT count(*) FROM gas_station WHERE open_year BETWEEN 2000 AND 2005",
        "amends": [
            "Do reference table `gas_station` instead of `gas_stations` and use column `open_year` instead of `opening_year`. Do change the date range filter to `BETWEEN 2000 AND 2005` instead of `BETWEEN 2005 AND 2010`. The amended query now correctly counts records from the gas_station table with open_year values between 2000 and 2005."
        ],
        "rules": [
            "1) When the question asks about \"gas stations\": use table \"gas_station\" instead of \"gas_stations\". 2) When the question mentions \"opened between 2000 and 2005\": use column \"open_year\" instead of \"opening_year\" and filter for values between 2000 and 2005 inclusive. 3) When counting gas stations: count all rows from \"gas_station\" table that satisfy the year range condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM gas_stations WHERE opening_year BETWEEN 2005 AND 2010;",
            "SELECT COUNT(*) FROM gas_station WHERE open_year BETWEEN 2000 AND 2005;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM gas_station WHERE Open_Year BETWEEN 2000 AND 2005"
        ]
    },
    "6292": {
        "db_id": "city_record",
        "question": "Give me a list of cities whose temperature in Mar is lower than that in Dec and which have never been host cities.",
        "ground_truth": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of direct table references. Do join `city` and `temperature` tables on `city_id` instead of querying a single `temperatures` table. Do reference separate columns `Mar` and `Dec` in the `temperature` table instead of filtering by month values and using a correlated subquery. Do move the temperature comparison to a direct column comparison `T2.Mar < T2.Dec` instead of a subquery with month filtering. Do use `EXCEPT` instead of `NOT IN` with a subquery for the Olympics exclusion. Do join `city` with `hosting_city` on `city_id = host_city` instead of using a simple `NOT IN` subquery. The amended query now correctly handles the relational structure with proper table joins and eliminates the inefficient correlated subquery."
        ],
        "rules": [
            "1) When answering about cities with temperature conditions: use table aliases T1 for city table and T2 for temperature table 2) When comparing March and December temperatures: directly compare columns T2.Mar < T2.Dec instead of using month filtering subqueries 3) When excluding host cities: use EXCEPT operation with hosting_city table instead of NOT IN subquery 4) When joining city and temperature tables: link them using city_id = city_id columns 5) When joining city and hosting_city tables: link them using city_id = host_city columns 6) When selecting output: return only the city column from the city table"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city \nFROM temperatures \nWHERE month = 'Mar' AND temperature < (SELECT temperature FROM temperatures WHERE month = 'Dec' AND city = t.city)\nAND city NOT IN (SELECT host_city FROM olympics);",
            "SELECT T1.City\nFROM city T1\nJOIN temperature T2 ON T1.City_ID = T2.City_ID\nWHERE T2.Mar < T2.Dec\nEXCEPT\nSELECT T1.City\nFROM city T1\nJOIN hosting_city T3 ON T1.City_ID = T3.Host_City"
        ],
        "rule_sql": [
            "SELECT T1.City FROM city T1 JOIN temperature T2 ON T1.City_ID = T2.City_ID WHERE T2.Mar < T2.Dec EXCEPT SELECT T1.City FROM city T1 JOIN hosting_city hc ON T1.City_ID = hc.Host_City"
        ]
    },
    "2952": {
        "db_id": "sakila_1",
        "question": "Which film actor (actress) starred the most films? List his or her first name, last name and actor id.",
        "ground_truth": "SELECT T2.first_name ,  T2.last_name ,  T2.actor_id FROM film_actor AS T1 JOIN actor AS T2 ON T1.actor_id  =  T2.actor_id GROUP BY T2.actor_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use `JOIN` instead of `LEFT JOIN` to exclude actors with no films. Do reference the actor table as `T2` instead of `a` and film_actor as `T1` instead of `fa`. Do remove the explicit `film_count` column from the SELECT list and instead use `count(*)` in the ORDER BY clause. Do omit the alias `film_count` since it's not referenced in the SELECT list. Do use `T1.actor_id = T2.actor_id` instead of `a.actor_id = fa.actor_id` for the join condition. The amended query now correctly identifies the actor with the most film appearances by using an inner join and count aggregation in the ORDER BY clause."
        ],
        "rules": [
            "1) When combining film_actor and actor tables: link rows where T1.actor_id = T2.actor_id and keep only matching pairs (inner match). 2) When counting film appearances per actor: count the number of rows using T1.actor_id as the grouping key. 3) When the question asks for \"the most films\": rank actors by film count in descending order and keep only the top 1 row. 4) When answering about film actors: make sure the output order is first_name, last_name, actor_id. 5) When choosing table aliases: use T1 for film_actor table and T2 for actor table as specified in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.first_name, a.last_name, a.actor_id, COUNT(fa.film_id) as film_count \nFROM actor a \nLEFT JOIN film_actor fa ON a.actor_id = fa.actor_id \nGROUP BY a.actor_id \nORDER BY film_count DESC \nLIMIT 1;",
            "SELECT T2.first_name, T2.last_name, T2.actor_id\nFROM film_actor T1\nJOIN actor T2 ON T1.actor_id = T2.actor_id\nGROUP BY T2.actor_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.first_name, T2.last_name, T2.actor_id\nFROM film_actor T1\nINNER JOIN actor T2 ON T1.actor_id = T2.actor_id\nGROUP BY T1.actor_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "1272": {
        "db_id": "apartment_rentals",
        "question": "Show the apartment numbers of apartments with unit status availability of both 0 and 1.",
        "ground_truth": "SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  0 INTERSECT SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  1",
        "amends": [
            "Do use `INTERSECT` with two separate queries instead of a single query with conflicting `WHERE` conditions. Do join `Apartments AS T1` with `View_Unit_Status AS T2` on `T1.apt_id = T2.apt_id` instead of querying only the `apartments` table. Do filter on `T2.available_yn = 0` in the first query and `T2.available_yn = 1` in the second query instead of the impossible condition `unit_status = 0 AND unit_status = 1`. Do select `T1.apt_number` instead of `apartment_number` to match the correct column name. The amended query now correctly finds apartments that have both available_yn = 0 and available_yn = 1 statuses through the INTERSECT operation, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for apartments with both status availability 0 and 1: use INTERSECT with two separate queries instead of a single query with conflicting conditions. 2) When combining apartment data with unit status information: join Apartments AS T1 with View_Unit_Status AS T2 on T1.apt_id = T2.apt_id using an inner match. 3) When filtering for availability status 0: use T2.available_yn = 0 in the first query. 4) When filtering for availability status 1: use T2.available_yn = 1 in the second query. 5) When selecting apartment numbers: use T1.apt_number instead of apartment_number to match the correct column name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT apartment_number FROM apartments WHERE unit_status = 0 AND unit_status = 1;",
            "SELECT T1.apt_number\nFROM Apartments AS T1\nJOIN View_Unit_Status AS T2 ON T1.apt_id = T2.apt_id\nWHERE T2.available_yn = 0\nINTERSECT\nSELECT T1.apt_number\nFROM Apartments AS T1\nJOIN View_Unit_Status AS T2 ON T1.apt_id = T2.apt_id\nWHERE T2.available_yn = 1"
        ],
        "rule_sql": [
            "SELECT T1.apt_number\nFROM Apartments AS T1\nINNER JOIN View_Unit_Status AS T2 ON T1.apt_id = T2.apt_id\nWHERE T2.available_yn = 0\nINTERSECT\nSELECT T1.apt_number\nFROM Apartments AS T1\nINNER JOIN View_Unit_Status AS T2 ON T1.apt_id = T2.apt_id\nWHERE T2.available_yn = 1"
        ]
    },
    "5130": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "What is the description and code of the type of service that is performed the most often?",
        "ground_truth": "SELECT T1.Service_Type_Description , T1.Service_Type_Code FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code GROUP BY T1.Service_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do specify exact column names `T1.Service_Type_Description` and `T1.Service_Type_Code` instead of ambiguous `description` and `code`. Do add table `Ref_Service_Types AS T1` and `Services AS T2` with explicit aliases instead of only referencing `services`. Do implement `JOIN` with predicate `T1.Service_Type_Code = T2.Service_Type_Code` instead of missing table relationships. Do add `GROUP BY T1.Service_Type_Code` to support the aggregate function instead of omitting grouping. The amended query now correctly joins the reference table with services data, groups by service type code, and returns the most frequently occurring service type with proper column specifications."
        ],
        "rules": [
            "1) When answering about \"type of service that is performed the most often\": make sure the output order: T1.Service_Type_Description, T1.Service_Type_Code. 2) When the question mentions \"description\" and \"code\": use exact column names T1.Service_Type_Description and T1.Service_Type_Code. 3) When combining tables Ref_Service_Types as T1 and Services as T2: link rows where T1.Service_Type_Code = T2.Service_Type_Code and keep only matching pairs (inner match). 4) When counting service occurrences: group by T1.Service_Type_Code and count using T2.Service_Type_Code as the counting key. 5) When the question asks for \"the most often\": rank service types by count in descending order and keep only the top 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description, code FROM services ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T1.Service_Type_Description, T1.Service_Type_Code\nFROM Ref_Service_Types AS T1\nJOIN Services AS T2 ON T1.Service_Type_Code = T2.Service_Type_Code\nGROUP BY T1.Service_Type_Code\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Service_Type_Description, T1.Service_Type_Code\nFROM Ref_Service_Types T1\nINNER JOIN Services T2 ON T1.Service_Type_Code = T2.Service_Type_Code\nGROUP BY T1.Service_Type_Code\nORDER BY COUNT(T2.Service_Type_Code) DESC\nLIMIT 1;"
        ]
    },
    "1083": {
        "db_id": "match_season",
        "question": "Who are the different players, what season do they play in, and what is the name of the team they are on?",
        "ground_truth": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do select columns `Season`, `Player`, and `Name` instead of `player_name`, `season`, and `team_name`. Do join tables `match_season` and `team` instead of `players` and `teams`. Do use join condition `T1.Team = T2.Team_id` instead of `players.team_id = teams.id`. Do remove the contradictory WHERE clause `players.team_id != teams.id` instead of keeping it, as it would always return empty results. The amended query now correctly joins the match_season and team tables to retrieve player information with proper team names."
        ],
        "rules": [
            "1) When answering about \"different players, what season they play in, and what is the name of the team they are on\": make sure the output order: T1.Player, T1.Season, T2.Name 2) When combining match_season (T1) and team (T2) tables: link rows where T1.Team = T2.Team_id and keep only matching pairs (inner match) 3) When selecting columns: use exact tokens T1.Player, T1.Season, and T2.Name instead of player_name, season, and team_name 4) When the question mentions \"players\": \"players\" actually means \"Player in match_season table\" 5) When the question mentions \"team they are on\": \"team name\" actually means \"Name in team table\" 6) When the question mentions \"season\": \"season\" actually means \"Season in match_season table\""
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name, season, team_name FROM players JOIN teams ON players.team_id = teams.id WHERE players.team_id != teams.id",
            "SELECT T1.Season, T1.Player, T2.Name FROM match_season T1 JOIN team T2 ON T1.Team = T2.Team_id"
        ],
        "rule_sql": [
            "SELECT T1.Player, T1.Season, T2.Name FROM match_season T1 INNER JOIN team T2 ON T1.Team = T2.Team_id ORDER BY T1.Player, T1.Season, T2.Name"
        ]
    },
    "3888": {
        "db_id": "insurance_policies",
        "question": "How many settlements are there in total?",
        "ground_truth": "SELECT count(*) FROM Settlements",
        "amends": [
            "Do reference the table as `Settlements` with proper case sensitivity instead of `settlements` in lowercase. Do use consistent capitalization for `count(*)` instead of `COUNT(*)`. The amended query now matches RIGHT_SQL's behavior with identical logic and results."
        ],
        "rules": [
            "1) When referencing table names: use exact case-sensitive identifier \"Settlements\" instead of lowercase \"settlements\". 2) When counting all rows in a table: use consistent capitalization for count function as \"count(*)\" instead of \"COUNT(*)\". 3) When counting total entities: count all rows where the primary key exists (id IS NOT NULL) to ensure accurate entity counting."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM settlements WHERE id IS NOT NULL;",
            "SELECT count(*) FROM Settlements"
        ],
        "rule_sql": [
            "SELECT count(*) FROM Settlements WHERE Settlement_ID IS NOT NULL"
        ]
    },
    "401": {
        "db_id": "flight_1",
        "question": "What is the average distance and average price for flights from Los Angeles.",
        "ground_truth": "SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  \"Los Angeles\"",
        "amends": [
            "Do reference table `Flight` instead of `flights` in the FROM clause. Do use filter condition `origin = 'Los Angeles'` instead of `departure_city = 'Los Angeles'` in the WHERE clause. Do maintain the same aggregate functions `AVG(distance)` and `AVG(price)` without changes. The amended query now correctly references the proper table name and uses the appropriate column for filtering departure origin cities."
        ],
        "rules": [
            "1) When answering about \"average distance and average price for flights from Los Angeles\": make sure the output order: AVG(distance), AVG(price). 2) When the question mentions \"flights\": \"flights\" actually means \"Flight\" in schema. 3) When the question mentions \"from Los Angeles\": \"from Los Angeles\" actually means \"origin = 'Los Angeles'\" in schema. 4) When computing averages: use AVG(distance) and AVG(price) without changes to the aggregate functions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(distance), AVG(price) FROM flights WHERE departure_city = 'Los Angeles';",
            "SELECT AVG(distance) AS average_distance, AVG(price) AS average_price FROM flight WHERE origin = 'Los Angeles';"
        ],
        "rule_sql": [
            "SELECT AVG(distance), AVG(price) FROM flight WHERE origin = 'Los Angeles'"
        ]
    },
    "1642": {
        "db_id": "wedding",
        "question": "Show all church names except for those that had a wedding in year 2015.",
        "ground_truth": "SELECT name FROM church EXCEPT SELECT T1.name FROM church AS T1 JOIN wedding AS T2 ON T1.church_id  =  T2.church_id WHERE T2.year  =  2015",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` subquery to properly handle NULL values and set differences. Do add table aliases `T1` and `T2` instead of omitting them for explicit table references. Do use explicit `JOIN` syntax with `ON T1.church_id = T2.church_id` instead of implicit correlation in the subquery. Do move the year filter `T2.year = 2015` to the WHERE clause of the second SELECT instead of keeping it in the subquery's WHERE. Do include the full column reference `T1.name` instead of just `name` for clarity. The amended query now correctly handles set differences and avoids NULL-related issues that could occur with the NOT IN approach, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"church names except those with weddings in 2015\": use EXCEPT set operation instead of NOT IN subquery to properly handle NULL values and set differences. 2) When combining tables for this question: use table aliases T1 for church and T2 for wedding with explicit JOIN syntax using ON T1.church_id = T2.church_id. 3) When filtering for weddings in year 2015: apply the condition T2.year = 2015 in the WHERE clause of the second SELECT statement. 4) When selecting church names: use the full column reference T1.name instead of just name for clarity and explicit table reference."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM church WHERE church_id NOT IN (SELECT church_id FROM wedding WHERE year = 2015);",
            "SELECT T1.Name FROM church T1\nEXCEPT\nSELECT T1.Name FROM church T1\nJOIN wedding T2 ON T1.Church_ID = T2.Church_ID\nWHERE T2.Year = 2015"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM church T1\nEXCEPT\nSELECT T1.Name FROM church T1\nJOIN wedding T2 ON T1.Church_ID = T2.Church_ID\nWHERE T2.Year = 2015"
        ]
    },
    "2581": {
        "db_id": "inn_1",
        "question": "Find the number of times ROY SWEAZY has reserved a room.",
        "ground_truth": "SELECT count(*) FROM Reservations WHERE FirstName = \"ROY\" AND LastName  =  \"SWEAZY\";",
        "amends": [
            "Do reference the `FirstName` and `LastName` columns instead of the non-existent `guest_name` column. Do add the `AND LastName = \"SWEAZY\"` condition instead of using a single combined field. Do use proper table name capitalization `Reservations` instead of lowercase `reservations`. The amended query now correctly matches the RIGHT_SQL's behavior by properly filtering on separate first and last name fields."
        ],
        "rules": [
            "1) When the question asks for reservations by a specific person: use both \"FirstName\" and \"LastName\" columns from the \"Reservations\" table instead of a combined \"guest_name\" field. 2) When filtering for \"ROY SWEAZY\": apply separate conditions with \"FirstName = 'ROY'\" and \"LastName = 'SWEAZY'\" using exact case and spacing. 3) When counting reservations: count all rows that match both the first name and last name conditions using the canonical table name \"Reservations\" with proper capitalization."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM reservations WHERE guest_name = 'ROY SWEAZY';",
            "SELECT COUNT(*) FROM Reservations WHERE FirstName = 'ROY' AND LastName = 'SWEAZY';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Reservations WHERE FirstName = 'ROY' AND LastName = 'SWEAZY';"
        ]
    },
    "1798": {
        "db_id": "small_bank_1",
        "question": "Find the name of account that has the lowest total checking and saving balance.",
        "ground_truth": "SELECT T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid ORDER BY T2.balance + T3.balance LIMIT 1",
        "amends": [
            "Do add `T1.` prefix to `name` instead of using unqualified column reference. Do change FROM clause to use `accounts AS T1 JOIN checking AS T2 ON T1.custid = T2.custid JOIN savings AS T3 ON T1.custid = T3.custid` instead of single table `accounts`. Do change ORDER BY expression to `T2.balance + T3.balance` instead of `checking_balance + saving_balance` which referenced non-existent columns. The amended query now correctly joins the accounts table with checking and savings tables to access the actual balance columns and returns the expected result matching RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"name of account that has the lowest total checking and saving balance\": make sure the output order: T1.name. 2) When combining tables for account information: link rows where T1.custid = T2.custid and T1.custid = T3.custid; keep only matching pairs (inner match). 3) When computing total balance: use T2.balance + T3.balance instead of checking_balance + saving_balance. 4) When finding the lowest total balance: order by T2.balance + T3.balance in ascending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM accounts ORDER BY (checking_balance + saving_balance) DESC LIMIT 1;",
            "SELECT T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid = T2.custid JOIN savings AS T3 ON T1.custid = T3.custid ORDER BY T2.balance + T3.balance ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.name \nFROM ACCOUNTS T1\nINNER JOIN SAVINGS T2 ON T1.custid = T2.custid\nINNER JOIN CHECKING T3 ON T1.custid = T3.custid\nORDER BY (T2.balance + T3.balance) ASC\nLIMIT 1"
        ]
    },
    "1288": {
        "db_id": "game_injury",
        "question": "List the name of the stadium where both the player 'Walter Samuel' and the player 'Thiago Motta' got injured.",
        "ground_truth": "SELECT T2.name FROM game AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.id JOIN injury_accident AS T3 ON T1.id  =  T3.game_id WHERE T3.player  =  'Walter Samuel' INTERSECT SELECT T2.name FROM game AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.id JOIN injury_accident AS T3 ON T1.id  =  T3.game_id WHERE T3.player  =  'Thiago Motta'",
        "amends": [
            "Do use `INTERSECT` to find stadiums where both players were injured instead of incorrectly filtering for both names in a single `WHERE` clause. Do join `game`, `stadium`, and `injury_accident` tables instead of querying only `stadiums` table. Do filter on `T3.player = 'Walter Samuel'` and `T3.player = 'Thiago Motta'` in separate query branches instead of using `AND` with the same column. Do select `T2.name` from the joined tables instead of `stadium_name` from a single table. Do use proper join conditions `T1.stadium_id = T2.id` and `T1.id = T3.game_id` instead of missing table relationships entirely. The amended query now correctly identifies stadiums where both players suffered injuries by intersecting results from two separate queries."
        ],
        "rules": [
            "1) When answering about stadiums where both players 'Walter Samuel' and 'Thiago Motta' got injured: use INTERSECT to combine results from separate queries for each player instead of filtering for both names in a single WHERE clause. 2) When combining game, stadium, and injury_accident tables: link rows where T1.stadium_id = T2.id and T1.id = T3.game_id using inner matches. 3) When filtering for player 'Walter Samuel': use exact literal 'Walter Samuel' with T3.player column. 4) When filtering for player 'Thiago Motta': use exact literal 'Thiago Motta' with T3.player column. 5) When selecting the stadium name: use T2.name instead of stadium_name from a single table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT stadium_name \nFROM stadiums \nWHERE player_name = 'Walter Samuel' \nAND player_name = 'Thiago Motta';",
            "SELECT T2.name\nFROM stadium T2\nJOIN game T1 ON T1.stadium_id = T2.id\nJOIN injury_accident T3 ON T1.id = T3.game_id\nWHERE T3.Player = 'Walter Samuel'\nINTERSECT\nSELECT T2.name\nFROM stadium T2\nJOIN game T1 ON T1.stadium_id = T2.id\nJOIN injury_accident T3 ON T1.id = T3.game_id\nWHERE T3.Player = 'Thiago Motta'"
        ],
        "rule_sql": [
            "SELECT T2.name \nFROM game T1 \nJOIN stadium T2 ON T1.stadium_id = T2.id \nJOIN injury_accident T3 ON T1.id = T3.game_id \nWHERE T3.player = 'Walter Samuel'\nINTERSECT\nSELECT T2.name \nFROM game T1 \nJOIN stadium T2 ON T1.stadium_id = T2.id \nJOIN injury_accident T3 ON T1.id = T3.game_id \nWHERE T3.player = 'Thiago Motta'"
        ]
    },
    "2523": {
        "db_id": "movie_1",
        "question": "What are the ids of all reviewers who have not given 4 stars at least once?",
        "ground_truth": "SELECT rID FROM Rating WHERE stars != 4",
        "amends": [
            "Do reference column `rID` instead of `reviewer_id` and table `Rating` instead of `reviews` to match the correct schema. Do remove the unnecessary `GROUP BY` clause instead of keeping it since the query only needs to return distinct reviewer IDs without aggregation. The amended query now correctly selects reviewers from the Rating table who gave ratings other than 4 stars, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"reviewer_id\": use the exact column token \"rID\" from the Rating table instead. 2) When the question refers to the \"reviews\" table: use the exact table name \"Rating\" instead. 3) When selecting distinct reviewer IDs without aggregation: do not include a GROUP BY clause. 4) When finding reviewers who have not given 4 stars at least once: select from the Rating table where stars are not equal to 4."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT reviewer_id FROM reviews WHERE stars != 4 GROUP BY reviewer_id;",
            "SELECT DISTINCT rID FROM Rating WHERE stars != 4"
        ],
        "rule_sql": [
            "SELECT DISTINCT rID FROM Rating WHERE stars != 4"
        ]
    },
    "3697": {
        "db_id": "baseball_1",
        "question": "List players' first name and last name who received salary from team Washington Nationals in both 2005 and 2007.",
        "ground_truth": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `p`, `s`, and `t`. Do reference columns `name_first` and `name_last` instead of `first_name` and `last_name`. Do join on `team_id_br` instead of `team_id` for the team table connection. Do use separate queries with `INTERSECT` instead of `GROUP BY` with `HAVING COUNT(DISTINCT s.year) = 2`. Do filter for each year separately with `T1.year = 2005` and `T1.year = 2007` in respective queries instead of `(s.year = 2005 OR s.year = 2007)` with a single query. Do remove the `GROUP BY` clause entirely instead of grouping by player attributes. The amended query now correctly identifies players who played for the Washington Nationals in both 2005 and 2007 using intersection logic instead of counting distinct years."
        ],
        "rules": [
            "1) When answering about players who received salary from team Washington Nationals in both 2005 and 2007: make sure the output order: T1.name_first, T1.name_last\n2) When the question mentions \"first name\" and \"last name\": these actually mean \"name_first\" and \"name_last\" in the player table\n3) When combining tables for shared entities: link player and salary tables where T1.player_id = T2.player_id, and link salary and team tables where T2.team_id_br = T3.team_id_br\n4) When the question mentions \"Washington Nationals\": this actually means T3.name = 'Washington Nationals' exactly as specified\n5) When checking for players in both 2005 and 2007: use separate queries with INTERSECT logic instead of GROUP BY with HAVING COUNT(DISTINCT year)\n6) When filtering for year 2005: use T2.year = 2005 exactly as specified\n7) When filtering for year 2007: use T2.year = 2007 exactly as specified\n8) When using table aliases: use T1 for player table, T2 for salary table, and T3 for team table as specified in the amends"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.first_name, p.last_name \nFROM players p\nJOIN salaries s ON p.player_id = s.player_id\nJOIN teams t ON s.team_id = t.team_id\nWHERE t.name = 'Washington Nationals' \nAND (s.year = 2005 OR s.year = 2007)\nGROUP BY p.player_id, p.first_name, p.last_name\nHAVING COUNT(DISTINCT s.year) = 2;",
            "SELECT T1.name_first, T1.name_last\nFROM player T1\nJOIN salary T2 ON T1.player_id = T2.player_id\nJOIN team T3 ON T2.team_id = T3.team_id_br\nWHERE T3.name = 'Washington Nationals' AND T2.year = 2005\n\nINTERSECT\n\nSELECT T1.name_first, T1.name_last\nFROM player T1\nJOIN salary T2 ON T1.player_id = T2.player_id\nJOIN team T3 ON T2.team_id = T3.team_id_br\nWHERE T3.name = 'Washington Nationals' AND T2.year = 2007"
        ],
        "rule_sql": [
            "SELECT T1.name_first, T1.name_last\nFROM player T1\nJOIN salary T2 ON T1.player_id = T2.player_id\nJOIN team T3 ON T2.team_id_br = T3.team_id_br\nWHERE T3.name = 'Washington Nationals' AND T2.year = 2005\n\nINTERSECT\n\nSELECT T1.name_first, T1.name_last\nFROM player T1\nJOIN salary T2 ON T1.player_id = T2.player_id\nJOIN team T3 ON T2.team_id_br = T3.team_id_br\nWHERE T3.name = 'Washington Nationals' AND T2.year = 2007"
        ]
    },
    "1005": {
        "db_id": "university_basketball",
        "question": "Find the schools that were either founded after 1850 or public.",
        "ground_truth": "SELECT school FROM university WHERE founded  >  1850 OR affiliation  =  'Public'",
        "amends": [
            "Do select `school` instead of `*` from the SELECT list. Do query from `university` instead of `schools` as the FROM source. Do filter on `affiliation = 'Public'` instead of `type = 'private'` in the WHERE clause, changing both the column reference and the conditional value. The amended query now correctly retrieves school names from the university table where founded year is after 1850 or affiliation is public, matching the intended behavior."
        ],
        "rules": [
            "1) When selecting from the database: use \"school\" instead of \"*\" in the output columns. 2) When querying the main table: use \"university\" instead of \"schools\" as the source table. 3) When filtering for public schools: use \"affiliation = 'Public'\" instead of \"type = 'private'\", changing both the column reference and the literal value. 4) When answering about schools founded after 1850 or public schools: maintain the OR condition between \"founded > 1850\" and \"affiliation = 'Public'\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM schools WHERE founded > 1850 OR type = 'private';",
            "SELECT school FROM university WHERE Founded > 1850 OR Affiliation = 'Public'"
        ],
        "rule_sql": [
            "SELECT school FROM university WHERE Founded > 1850 OR Affiliation = 'Public'"
        ]
    },
    "5899": {
        "db_id": "cre_Theme_park",
        "question": "What is the address of the location \"UK Gallery\"?",
        "ground_truth": "SELECT Address FROM LOCATIONS WHERE Location_Name  =  \"UK Gallery\"",
        "amends": [
            "Do select `Address` instead of `name` in the SELECT list. Do filter on `Location_Name = \"UK Gallery\"` instead of `address = 'UK Gallery'` in the WHERE clause. Do use double quotes around the string literal instead of single quotes. The amended query now correctly retrieves the address for the location named \"UK Gallery\" instead of incorrectly trying to find a name where the address equals \"UK Gallery\", matching the intended behavior of the right SQL."
        ],
        "rules": [
            "1) When the question asks for the address of a location: select the \"Address\" column from the locations table. 2) When filtering for a specific location name: use the condition \"Location_Name\" = \"UK Gallery\" with exact double quotes around the literal value. 3) When the question mentions a location name like \"UK Gallery\": it corresponds to the \"Location_Name\" column in the schema, not the \"Address\" column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM locations WHERE address = 'UK Gallery';",
            "SELECT Address FROM Locations WHERE Location_Name = \"UK Gallery\";"
        ],
        "rule_sql": [
            "SELECT Address FROM Locations WHERE Location_Name = \"UK Gallery\";"
        ]
    },
    "2347": {
        "db_id": "csu_1",
        "question": "In what year was the most degrees conferred?",
        "ground_truth": "SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(year) FROM degrees;"
        ],
        "rule_sql": [
            "SELECT Year FROM degrees GROUP BY Year ORDER BY SUM(Degrees) DESC LIMIT 1;"
        ]
    },
    "2046": {
        "db_id": "party_people",
        "question": "Who are the ministers, when did they take office, and when did they leave office, ordered by when they left office?",
        "ground_truth": "SELECT minister ,  took_office ,  left_office FROM party ORDER BY left_office",
        "amends": [
            "Do select columns `minister`, `took_office`, and `left_office` instead of `name`, `take_office_date`, and `leave_office_date`. Do query from table `party` instead of `ministers`. Do order by `left_office` instead of `take_office_date`. The amended query now correctly retrieves ministerial data from the party table ordered by departure date."
        ],
        "rules": [
            "1) When selecting minister information: use columns \"minister\", \"took_office\", and \"left_office\" instead of \"name\", \"take_office_date\", and \"leave_office_date\". 2) When querying minister data: retrieve from table \"party\" instead of \"ministers\". 3) When ordering by departure date: sort by column \"left_office\" instead of \"take_office_date\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, take_office_date, leave_office_date FROM ministers ORDER BY take_office_date;",
            "SELECT minister, took_office, left_office FROM party ORDER BY left_office;"
        ],
        "rule_sql": [
            "SELECT minister, took_office, left_office FROM party ORDER BY left_office;"
        ]
    },
    "3342": {
        "db_id": "sports_competition",
        "question": "What is the average number of gold medals for a club?",
        "ground_truth": "SELECT avg(Gold) FROM club_rank",
        "amends": [
            "Do use table `club_rank` instead of `clubs` and aggregate column `Gold` instead of `silver_medals` in the SELECT clause. The amended query now correctly calculates the average of gold medals from the appropriate table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"average number of gold medals for a club\": use table \"club_rank\" instead of \"clubs\" and aggregate column \"Gold\" instead of \"silver_medals\". 2) When computing the average of gold medals: calculate the average of the \"Gold\" column from the \"club_rank\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(silver_medals) FROM clubs;",
            "SELECT AVG(Gold) AS average_gold_medals FROM club_rank;"
        ],
        "rule_sql": [
            "SELECT AVG(Gold) AS average_gold_medals FROM club_rank;"
        ]
    },
    "6444": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "Return the description of the budget type that has the code ORG.",
        "ground_truth": "SELECT budget_type_description FROM Ref_budget_codes WHERE budget_type_code  =  \"ORG\"",
        "amends": [
            "Do select `budget_type_description` instead of `description` and use table `Ref_budget_codes` instead of `budget_types`. Do filter on `budget_type_code = \"ORG\"` instead of `code = 'ORG'` with proper double quotes instead of single quotes. The amended query now correctly retrieves the budget type description from the appropriate reference table using the correct column names and filtering criteria."
        ],
        "rules": [
            "1) When the question asks for \"description of the budget type\": use the exact column \"budget_type_description\" from table \"Ref_budget_codes\". 2) When filtering for budget type code \"ORG\": use the exact condition \"budget_type_code = \\\"ORG\\\"\" with double quotes around the literal value. 3) When selecting from the reference table: use table \"Ref_budget_codes\" instead of \"budget_types\" as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description FROM budget_types WHERE code = 'ORG';",
            "SELECT budget_type_description FROM Ref_Budget_Codes WHERE budget_type_code = \"ORG\""
        ],
        "rule_sql": [
            "SELECT budget_type_description FROM Ref_budget_codes WHERE budget_type_code = \"ORG\""
        ]
    },
    "2686": {
        "db_id": "party_host",
        "question": "Show the name and the nationality of the oldest host.",
        "ground_truth": "SELECT Name ,  Nationality FROM HOST ORDER BY Age DESC LIMIT 1",
        "amends": [
            "Do use table name `HOST` instead of `hosts`. Do order by `Age DESC` instead of `age ASC`. Do select columns `Name` and `Nationality` with proper capitalization instead of lowercase `name` and `nationality`. The amended query now correctly retrieves the oldest host from the HOST table with proper column and table references."
        ],
        "rules": [
            "1) When the question asks about \"hosts\": use the exact table name \"HOST\" instead of \"hosts\". 2) When ordering by age to find the oldest host: order by \"Age\" in descending order (DESC) instead of ascending order (ASC). 3) When selecting columns for name and nationality: use exact column names \"Name\" and \"Nationality\" with proper capitalization instead of lowercase \"name\" and \"nationality\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, nationality FROM hosts ORDER BY age ASC LIMIT 1;",
            "SELECT Name, Nationality FROM host ORDER BY Age DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name, Nationality FROM HOST ORDER BY Age DESC LIMIT 1;"
        ]
    },
    "6285": {
        "db_id": "city_record",
        "question": "What is the city with the smallest GDP? Return the city and its GDP.",
        "ground_truth": "SELECT city ,  GDP FROM city ORDER BY GDP LIMIT 1",
        "amends": [
            "Do reference the table as `city` instead of `cities` to match the correct schema. Do order by `GDP` in ascending order instead of descending order to retrieve the minimum value. Do use consistent column naming with `GDP` instead of `gdp` to align with the table structure. The amended query now correctly identifies the city with the smallest GDP value instead of the largest."
        ],
        "rules": [
            "1) When the question asks about cities and GDP: use the table \"city\" instead of \"cities\" to match the schema. 2) When ordering by GDP to find the smallest value: order by \"GDP\" in ascending order instead of descending order. 3) When selecting columns: use the exact column name \"GDP\" instead of \"gdp\" to align with the table structure. 4) When answering about the city with smallest GDP: make sure the output order: \"city\", \"GDP\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, gdp FROM cities ORDER BY gdp DESC LIMIT 1;",
            "SELECT City, GDP FROM city ORDER BY GDP ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT City, GDP FROM city ORDER BY GDP ASC LIMIT 1;"
        ]
    },
    "1241": {
        "db_id": "apartment_rentals",
        "question": "Find the total number of rooms in the apartments that have facility code \"Gym\".",
        "ground_truth": "SELECT sum(T2.room_count) FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.facility_code  =  \"Gym\"",
        "amends": [
            "Do select `sum(T2.room_count)` instead of `COUNT(*)` to sum room counts rather than counting apartment records. Do join `Apartment_Facilities AS T1` to `Apartments AS T2` on `T1.apt_id = T2.apt_id` instead of querying only the `apartments` table. Do filter on `T1.facility_code = \"Gym\"` instead of filtering directly on the apartments table's facility_code field. The amended query now correctly aggregates room counts for apartments with gym facilities by properly joining the facility mapping table."
        ],
        "rules": [
            "1) When the question asks for \"total number of rooms\" in apartments: use sum(T2.room_count) instead of COUNT(*) to sum room counts rather than counting apartment records. 2) When the question mentions apartments with facility code \"Gym\": join Apartment_Facilities AS T1 to Apartments AS T2 on T1.apt_id = T2.apt_id instead of querying only the apartments table. 3) When filtering for facility code \"Gym\": filter on T1.facility_code = \"Gym\" instead of filtering directly on the apartments table's facility_code field."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM apartments WHERE facility_code = 'Gym'",
            "SELECT SUM(CAST(T2.room_count AS INTEGER)) \nFROM Apartment_Facilities AS T1\nJOIN Apartments AS T2 ON T1.apt_id = T2.apt_id\nWHERE T1.facility_code = 'Gym'"
        ],
        "rule_sql": [
            "SELECT SUM(CAST(T2.room_count AS INTEGER)) AS total_rooms\nFROM Apartment_Facilities AS T1\nJOIN Apartments AS T2 ON T1.apt_id = T2.apt_id\nWHERE T1.facility_code = 'Gym';"
        ]
    },
    "2573": {
        "db_id": "inn_1",
        "question": "What are the names of modern rooms that have a base price lower than $160 and two beds.",
        "ground_truth": "SELECT roomName FROM Rooms WHERE basePrice  <  160 AND beds =  2 AND decor  =  'modern';",
        "amends": [
            "Do select `roomName` instead of `name` and use table alias `Rooms` instead of `rooms`. Do add filter `decor = 'modern'` instead of `style = 'modern'` and maintain `basePrice < 160` and `beds = 2` conditions. The amended query now correctly filters by decor style rather than style attribute and selects the appropriate column name to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for room names: select \"roomName\" from the \"Rooms\" table instead of \"name\" 2) When the question mentions \"modern\" rooms: filter by \"decor\" = 'modern' instead of \"style\" = 'modern' 3) When filtering by base price lower than $160: maintain condition \"basePrice\" < 160 4) When filtering for rooms with two beds: maintain condition \"beds\" = 2"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM rooms WHERE style = 'modern' AND base_price < 160 AND beds = 2",
            "SELECT roomName FROM Rooms WHERE decor = 'modern' AND basePrice < 160 AND beds = 2;"
        ],
        "rule_sql": [
            "SELECT \"roomName\" FROM \"Rooms\" WHERE \"decor\" = 'modern' AND \"basePrice\" < 160 AND \"beds\" = 2"
        ]
    },
    "1970": {
        "db_id": "products_for_hire",
        "question": "What is the average amount due for all the payments?",
        "ground_truth": "SELECT avg(amount_due) FROM payments",
        "amends": [
            "Do select `avg(amount_due)` instead of `AVG(amount)` to calculate the average of the correct column that contains the payment amounts. Do remove the `WHERE amount_due IS NULL` filter instead of keeping it, as the query should calculate the average across all payment records rather than only those with null amount_due values. The amended query now correctly computes the average of the amount_due column for all payments, matching the intended behavior."
        ],
        "rules": [
            "1) When calculating average payment amounts: use the exact column \"amount_due\" instead of \"amount\" to compute the average value. 2) When computing averages across all payments: do not apply any filters that would exclude records based on null values in the amount_due column. 3) When answering about average amount due for all payments: ensure the calculation includes every payment record without any conditional exclusions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(amount) FROM payments WHERE amount_due IS NULL;",
            "SELECT AVG(amount_due) FROM Payments;"
        ],
        "rule_sql": [
            "SELECT AVG(amount_due) AS average_amount_due FROM Payments;"
        ]
    },
    "5897": {
        "db_id": "cre_Theme_park",
        "question": "Show the average price range of hotels that have 5 star ratings and allow pets.",
        "ground_truth": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  \"5\" AND pets_allowed_yn  =  1",
        "amends": [
            "Do use `avg(price_range)` instead of `AVG(price_range)` to match the function case. Do reference `star_rating_code` instead of `star_rating` as the correct column name. Do use `pets_allowed_yn` instead of `pets_allowed` as the proper boolean column. Do filter with numeric value `1` instead of string `'yes'` for the boolean flag. Do maintain the same table reference `HOTELS` instead of `hotels` with consistent case handling. The amended query now correctly calculates the average price range for 5-star hotels that allow pets using the proper column names and data types."
        ],
        "rules": [
            "1) When the question mentions \"5 star ratings\": use the exact column token \"star_rating_code\" with numeric value 5 instead of \"star_rating\". 2) When the question mentions \"allow pets\": use the exact column token \"pets_allowed_yn\" with numeric value 1 instead of string 'yes'. 3) When computing average price range: use the function \"avg(price_range)\" with lowercase 'avg' instead of uppercase 'AVG'. 4) When referencing the hotels table: maintain the exact table name \"HOTELS\" with consistent case handling."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(price_range) FROM hotels WHERE star_rating = 5 AND pets_allowed = 'yes';",
            "SELECT avg(price_range) FROM Hotels WHERE star_rating_code = '5' AND pets_allowed_yn = '1';"
        ],
        "rule_sql": [
            "SELECT avg(price_range) FROM Hotels WHERE star_rating_code = 5 AND pets_allowed_yn = 1;"
        ]
    },
    "5783": {
        "db_id": "customer_complaints",
        "question": "What are the emails and phone numbers of custoemrs who have never filed a complaint?",
        "ground_truth": "SELECT email_address ,  phone_number FROM customers WHERE customer_id NOT IN (SELECT customer_id FROM complaints)",
        "amends": [
            "Do select `email_address` instead of `email` and maintain `phone_number` in the SELECT list. Do change the WHERE filter to use `customer_id NOT IN` with a subquery selecting from the complaints table instead of checking `complaint_id IS NULL` directly on the customers table. Do add a correlated subquery to check for customer IDs in the complaints table instead of relying on a direct NULL check which may not accurately represent the absence of complaints. The amended query now correctly identifies customers without any complaints by using a proper anti-join pattern instead of the potentially incorrect NULL check, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting customer contact information: use \"email_address\" instead of \"email\" and maintain \"phone_number\" in the output columns. 2) When identifying customers who have never filed a complaint: use customer_id NOT IN with a subquery selecting from the complaints table instead of checking complaint_id IS NULL directly on the customers table. 3) When checking for absence of complaints: use a proper anti-join pattern with a correlated subquery to check for customer IDs in the complaints table to accurately represent customers without any complaints."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT email, phone_number FROM customers WHERE complaint_id IS NULL;",
            "SELECT email_address, phone_number FROM Customers WHERE customer_id NOT IN (SELECT DISTINCT customer_id FROM Complaints)"
        ],
        "rule_sql": [
            "SELECT email_address, phone_number\nFROM Customers\nWHERE customer_id NOT IN (\n    SELECT DISTINCT customer_id\n    FROM Complaints\n);"
        ]
    },
    "6746": {
        "db_id": "activity_1",
        "question": "Find the faculty rank that has the least members.",
        "ground_truth": "SELECT rank FROM Faculty GROUP BY rank ORDER BY count(*) ASC LIMIT 1",
        "amends": [
            "Do use `rank` instead of `faculty_rank` for the column name in both SELECT and GROUP BY clauses. Do order by `count(*) ASC` instead of `member_count DESC` to sort by ascending count rather than descending. Do remove the alias `member_count` instead of keeping it since the ORDER BY clause now directly references the aggregate function. Do use table name `Faculty` instead of `faculty` to match the correct case sensitivity. The amended query now correctly identifies the rank with the smallest count of faculty members instead of the largest.",
            "Do select only `rank` instead of both `rank` and `COUNT(*)` in the SELECT list. Do maintain the `GROUP BY rank` clause and `ORDER BY count(*) ASC` with `LIMIT 1` to find the rank with the lowest count. The amended query now correctly returns only the rank column instead of both rank and count, matching the RIGHT_SQL's behavior of returning the single rank with the fewest faculty members."
        ],
        "rules": [
            "1) When the question asks about faculty rank: use the exact column name \"rank\" instead of \"faculty_rank\" for both selection and grouping. 2) When counting members per faculty rank: count all rows using count(*) and order the results by this count in ascending order to find the smallest count. 3) When ordering by aggregate results: reference the aggregate function directly (count(*)) rather than using an alias. 4) When referring to the Faculty table: use the exact table name \"Faculty\" with proper case sensitivity.",
            "1) When answering about \"faculty rank that has the least members\": make sure the output order: rank. 2) When the question asks for \"count of faculty members per rank\": compute the number of rows using the canonical key for faculty members. 3) When the question mentions \"least members\" or \"lowest count\": rank rows by count in ascending order and keep the first 1 row. 4) When the question says \"per rank\" or \"by rank\": organize results by the token for rank and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT faculty_rank, COUNT(*) as member_count FROM faculty GROUP BY faculty_rank ORDER BY member_count DESC LIMIT 1;",
            "SELECT rank, COUNT(*) FROM Faculty GROUP BY rank ORDER BY COUNT(*) ASC LIMIT 1;",
            "SELECT rank FROM Faculty GROUP BY rank ORDER BY COUNT(*) ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT rank FROM Faculty GROUP BY rank ORDER BY count(*) ASC LIMIT 1"
        ]
    },
    "2360": {
        "db_id": "csu_1",
        "question": "Find the names of the campus which has more faculties in 2002 than every campus in Orange county.",
        "ground_truth": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2002 AND faculty  >  (SELECT max(faculty) FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2002 AND T1.county  =  \"Orange\")",
        "amends": [
            "Do use `campuses` and `faculty` as table names instead of `campus` and `faculty`. Do select `campus` instead of `name` from the campuses table. Do join on `T1.id = T2.campus` instead of `c.id = f.campus_id`. Do move the year filter to the `WHERE` clause instead of keeping it in the main query's WHERE. Do use `faculty` as the aggregate column instead of `COUNT(f.id)`. Do replace the complex subquery with a simpler `max(faculty)` aggregation instead of using COUNT with ORDER BY and LIMIT. Do add the county filter `T1.county = \"Orange\"` in the subquery instead of omitting it. Do remove the GROUP BY clause in the main query instead of keeping it. The amended query now correctly identifies campuses with more faculty than the maximum faculty count in Orange County for the year 2002."
        ],
        "rules": [
            "1) When the question asks about campus names: select \"campus\" from the campuses table instead of \"name\". 2) When joining campuses and faculty tables: link rows where T1.id = T2.campus exactly. 3) When filtering by year 2002: apply the condition T2.year = 2002 in the WHERE clause. 4) When counting faculty: use the \"faculty\" column for aggregation instead of counting IDs. 5) When comparing to Orange county campuses: use T1.county = \"Orange\" as the filter condition. 6) When finding maximum faculty count: use max(faculty) aggregation instead of COUNT with ORDER BY and LIMIT. 7) When the question asks for campuses with more faculty than every campus in Orange county: compare the faculty count to the maximum faculty count from Orange county campuses for 2002."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name \nFROM campus c\nJOIN faculty f ON c.id = f.campus_id\nWHERE f.year = 2002\nGROUP BY c.id, c.name\nHAVING COUNT(f.id) > (SELECT COUNT(f2.id) \n                     FROM faculty f2\n                     JOIN campus c2 ON f2.campus_id = c2.id\n                     WHERE f2.year = 2002 AND c2.county = 'Orange'\n                     GROUP BY c2.id\n                     ORDER BY COUNT(f2.id) DESC\n                     LIMIT 1);",
            "SELECT c.Campus \nFROM Campuses c\nJOIN faculty f ON c.Id = f.Campus\nWHERE f.Year = 2002\nAND f.Faculty > (\n    SELECT MAX(f2.Faculty)\n    FROM faculty f2\n    JOIN Campuses c2 ON c2.Id = f2.Campus\n    WHERE f2.Year = 2002\n    AND c2.County = 'Orange'\n)"
        ],
        "rule_sql": [
            "SELECT c.Campus \nFROM Campuses c\nJOIN faculty f ON c.Id = f.Campus\nWHERE f.Year = 2002\nAND f.Faculty > (\n    SELECT MAX(f2.Faculty)\n    FROM faculty f2\n    JOIN Campuses c2 ON f2.Campus = c2.Id\n    WHERE f2.Year = 2002\n    AND c2.County = 'Orange'\n)"
        ]
    },
    "128": {
        "db_id": "bike_1",
        "question": "How many different cities have these stations?",
        "ground_truth": "SELECT count(DISTINCT city) FROM station",
        "amends": [
            "Do `count(DISTINCT city)` instead of `COUNT(*)` to count distinct cities rather than all rows. Do reference `station` table instead of `stations` to use the correct table name. End with confirmation that the amended query now matches RIGHT_SQL's behavior of counting distinct cities from the station table."
        ],
        "rules": [
            "1) When the question asks for \"different cities\" or \"distinct cities\": count the number of unique values in the \"city\" column. 2) When referencing the station table: use the exact table name \"station\" (not \"stations\"). 3) When counting distinct entities: use the DISTINCT keyword with the specific column being counted (city) rather than counting all rows with COUNT(*)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM stations;",
            "SELECT COUNT(DISTINCT city) FROM station;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT city) FROM station;"
        ]
    },
    "1369": {
        "db_id": "college_2",
        "question": "What are the names of the students who took classes in 2009 or 2010?",
        "ground_truth": "SELECT DISTINCT T1.name FROM student AS T1 JOIN takes AS T2 ON T1.id  =  T2.id WHERE YEAR  =  2009 OR YEAR  =  2010",
        "amends": [
            "Do use `DISTINCT T1.name` instead of `name` to eliminate duplicates. Do join `student AS T1` with `takes AS T2` on `T1.id = T2.id` instead of querying only the `students` table. Do filter with `YEAR = 2009 OR YEAR = 2010` instead of the impossible `year = 2009 AND year = 2010` condition. The amended query now correctly retrieves distinct student names who took courses in either 2009 or 2010, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about student names who took classes in specific years: use DISTINCT T1.name to eliminate duplicate names. 2) When combining student and takes tables: link rows where T1.id = T2.id and keep only matching pairs (inner match). 3) When filtering for years 2009 or 2010: use YEAR = 2009 OR YEAR = 2010 instead of an impossible AND condition. 4) When the question mentions \"students who took classes\": this requires joining the student table (T1) with the takes table (T2) rather than querying only the students table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM students WHERE year = 2009 AND year = 2010;",
            "SELECT DISTINCT T1.name\nFROM student AS T1\nJOIN takes AS T2 ON T1.ID = T2.ID\nWHERE T2.year = 2009 OR T2.year = 2010"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.name FROM student T1 INNER JOIN takes T2 ON T1.ID = T2.ID WHERE T2.year = 2009 OR T2.year = 2010"
        ]
    },
    "6209": {
        "db_id": "roller_coaster",
        "question": "What is the average speed of roller coasters?",
        "ground_truth": "SELECT avg(Speed) FROM roller_coaster",
        "amends": [
            "Do select `avg(Speed)` instead of `AVG(height)` to calculate the average of the speed column rather than height. Do reference table `roller_coaster` instead of `roller_coasters` to use the correct table name. The amended query now correctly calculates average speed from the appropriate table."
        ],
        "rules": [
            "1) When answering about \"average speed of roller coasters\": make sure to calculate the average of the \"Speed\" column instead of \"height\". 2) When referencing the roller coasters table: use the exact table name \"roller_coaster\" instead of \"roller_coasters\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(height) FROM roller_coasters;",
            "SELECT AVG(Speed) FROM roller_coaster;"
        ],
        "rule_sql": [
            "SELECT AVG(CAST(Speed AS REAL)) AS average_speed FROM roller_coaster;"
        ]
    },
    "599": {
        "db_id": "store_1",
        "question": "Who is the youngest employee in the company? List employee's first and last name.",
        "ground_truth": "SELECT first_name , last_name FROM employees ORDER BY birth_date DESC LIMIT 1;",
        "amends": [
            "Do `ORDER BY birth_date DESC` instead of `ORDER BY birth_date ASC` to sort employees by most recent birth date rather than oldest birth date, which changes the record selected by the LIMIT 1 clause. The amended query now matches RIGHT_SQL's behavior by returning the employee with the latest birth date instead of the earliest."
        ],
        "rules": [
            "1) When the question asks for the \"youngest employee\": sort employees by birth_date in descending order (most recent birth date first) to find the youngest employee. 2) When answering about \"youngest employee\": make sure the output order: first_name, last_name. 3) When the question asks for a single \"youngest\" result: take only the first row after sorting by birth_date in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM employees ORDER BY birth_date ASC LIMIT 1;",
            "SELECT first_name, last_name FROM employees ORDER BY birth_date DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT first_name, last_name FROM employees ORDER BY birth_date DESC LIMIT 1;"
        ]
    },
    "2705": {
        "db_id": "storm_record",
        "question": "Return the total number of deaths and total damange in millions for storms that had a max speed greater than the average.",
        "ground_truth": "SELECT sum(number_deaths) ,  sum(damage_millions_USD) FROM storm WHERE max_speed  >  (SELECT avg(max_speed) FROM storm)",
        "amends": [
            "Do use `number_deaths` instead of `deaths` and `damage_millions_USD` instead of `damage / 1000000` in the SELECT list instead of calculating damage conversion manually. Do reference table `storm` instead of `storms` in both the main query and subquery instead of using the incorrect table name. Do remove the `AS total_deaths` and `AS total_damage_millions` aliases instead of keeping them. The amended query now correctly references the proper table and columns to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"total number of deaths\": use the exact column token \"number_deaths\" instead of \"deaths\". 2) When the question asks for \"total damage in millions\": use the exact column token \"damage_millions_USD\" instead of calculating damage conversion manually. 3) When referencing the storm data table: use the exact table name \"storm\" instead of \"storms\". 4) When selecting output columns: do not add aliases like \"AS total_deaths\" or \"AS total_damage_millions\" to the output columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(deaths) AS total_deaths, SUM(damage) / 1000000 AS total_damage_millions \nFROM storms \nWHERE max_speed > (SELECT AVG(max_speed) FROM storms)",
            "SELECT SUM(Number_Deaths), SUM(Damage_millions_USD) FROM storm WHERE Max_speed > (SELECT AVG(Max_speed) FROM storm)"
        ],
        "rule_sql": [
            "SELECT SUM(Number_Deaths), SUM(Damage_millions_USD) FROM storm WHERE Max_speed > (SELECT AVG(Max_speed) FROM storm)"
        ]
    },
    "4915": {
        "db_id": "store_product",
        "question": "For each type of store, how many of them are there?",
        "ground_truth": "SELECT TYPE ,  count(*) FROM store GROUP BY TYPE",
        "amends": [
            "Do reference `TYPE` instead of `store_type` in the SELECT list and use `TYPE` instead of `store_id` in the GROUP BY clause. Do reference table `store` instead of `stores` as the FROM source. The amended query now correctly groups by store type rather than store ID and matches the intended behavior of counting stores by their type categories."
        ],
        "rules": [
            "1) When answering about \"each type of store\": make sure the output order: TYPE, count of stores. 2) When the question mentions \"type of store\": \"type\" actually means \"TYPE in schema\". 3) When the question asks for \"how many of them are there per type\": organize results by TYPE and compute count of stores per group. 4) When counting stores: compute the number of rows using the canonical key for stores. 5) When referring to the table: use table name \"store\" exactly as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT store_type, COUNT(*) FROM stores GROUP BY store_id;",
            "SELECT Type, COUNT(*) AS store_count FROM store GROUP BY Type;"
        ],
        "rule_sql": [
            "SELECT Type, COUNT(Store_ID) AS count_of_stores FROM store GROUP BY Type ORDER BY Type;"
        ]
    },
    "5660": {
        "db_id": "customers_and_products_contacts",
        "question": "Show the name, phone, and payment method code for all customers in descending order of customer number.",
        "ground_truth": "SELECT customer_name ,  customer_phone ,  payment_method_code FROM customers ORDER BY customer_number DESC",
        "amends": [
            "Do select `customer_name`, `customer_phone`, and `payment_method_code` instead of `name`, `phone`, and `payment_method`. Do order by `customer_number DESC` instead of `ASC`. The amended query now correctly references the appropriate column names and sorts in descending order to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"name\": use the exact column token \"customer_name\" from the Customers table. 2) When the question asks for \"phone\": use the exact column token \"customer_phone\" from the Customers table. 3) When the question asks for \"payment method code\": use the exact column token \"payment_method_code\" from the Customers table. 4) When ordering by customer number in descending order: sort the results by \"customer_number\" in descending sequence (highest to lowest)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, phone, payment_method FROM customers ORDER BY customer_number ASC;",
            "SELECT customer_name, customer_phone, payment_method_code FROM Customers ORDER BY customer_number DESC;"
        ],
        "rule_sql": [
            "SELECT customer_name, customer_phone, payment_method_code FROM Customers ORDER BY customer_number DESC;"
        ]
    },
    "190": {
        "db_id": "bike_1",
        "question": "For each start station id, what is its name, longitude and average duration of trips started there?",
        "ground_truth": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of implicit table references. Do reference `T1.name` and `T1.long` instead of `name` and `longitude` from the trips table. Do use `JOIN` with explicit `ON T1.id = T2.start_station_id` instead of grouping by `start_station_id` without proper table joining. Do aggregate with `avg(T2.duration)` instead of `AVG(duration)` to specify the source table. Do group by `T2.start_station_id` instead of just `start_station_id` for clarity. Do remove the alias `avg_duration` instead of keeping it since the right query uses the function name directly. The amended query now correctly joins station and trip tables to calculate average duration per start station with proper table relationships."
        ],
        "rules": [
            "1) When answering about start stations and their trip durations: use explicit table aliases T1 for station table and T2 for trip table. 2) When combining station and trip tables: link rows where T1.id = T2.start_station_id and keep only matching pairs (inner match). 3) When the question asks for station name and longitude: reference T1.name and T1.long from the station table instead of name and longitude from trips. 4) When computing average duration of trips: use avg(T2.duration) to specify the source table. 5) When grouping by start station id: group by T2.start_station_id for clarity. 6) When producing output columns: do not use aliases for aggregate functions like avg_duration, use the function name directly."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT start_station_id, name, longitude, AVG(duration) as avg_duration FROM trips GROUP BY start_station_id",
            "SELECT T1.name, T1.long, avg(T2.duration) FROM station T1 JOIN trip T2 ON T1.id = T2.start_station_id GROUP BY T2.start_station_id"
        ],
        "rule_sql": [
            "SELECT T1.name, T1.long, avg(T2.duration) FROM station T1 INNER JOIN trip T2 ON T1.id = T2.start_station_id GROUP BY T2.start_station_id"
        ]
    },
    "6036": {
        "db_id": "game_1",
        "question": "What are the ids of all students who are not video game players?",
        "ground_truth": "SELECT StuID FROM Student EXCEPT SELECT StuID FROM Plays_games",
        "amends": [
            "Do select `StuID` instead of `student_id` and use an `EXCEPT` set operation instead of a simple `WHERE` filter. Do reference the `Student` table instead of `students` and completely remove the `is_video_game_player` condition. Do add a second query `SELECT StuID FROM Plays_games` to exclude game players instead of including them with a boolean check. The amended query now correctly identifies students who do not play games by using set difference instead of direct filtering, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for student ids: use the exact column token \"StuID\" from the Student table. 2) When identifying students who are not video game players: use a set difference operation to exclude students who appear in the Plays_games table. 3) When referencing the main student table: use the exact table name \"Student\" (not \"students\"). 4) When excluding game players: select \"StuID\" from the \"Plays_games\" table to identify students to remove from the result set."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id FROM students WHERE is_video_game_player = 1;",
            "SELECT StuID FROM Student\nEXCEPT\nSELECT StuID FROM Plays_Games"
        ],
        "rule_sql": [
            "SELECT StuID FROM Student\nEXCEPT\nSELECT StuID FROM Plays_Games;"
        ]
    },
    "1206": {
        "db_id": "apartment_rentals",
        "question": "What is the minimum and maximum number of bathrooms of all the apartments?",
        "ground_truth": "SELECT min(bathroom_count) ,  max(bathroom_count) FROM Apartments",
        "amends": [
            "Do select `min(bathroom_count)` and `max(bathroom_count)` instead of `MIN(bedrooms)` and `MAX(bedrooms)`. Do reference table `Apartments` instead of `apartments`. The amended query now correctly calculates the minimum and maximum bathroom counts from the Apartments table."
        ],
        "rules": [
            "1) When the question asks for minimum and maximum number of bathrooms: use min(bathroom_count) and max(bathroom_count) instead of bedrooms-related columns. 2) When referencing the apartments table: use the exact table name \"Apartments\" with proper capitalization. 3) When extracting bathroom information: use the exact column name \"bathroom_count\" to match the schema requirements."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(bedrooms), MAX(bedrooms) FROM apartments;",
            "SELECT MIN(bathroom_count) AS min_bathrooms, MAX(bathroom_count) AS max_bathrooms FROM Apartments;"
        ],
        "rule_sql": [
            "SELECT MIN(bathroom_count) AS min_bathrooms, MAX(bathroom_count) AS max_bathrooms FROM Apartments;"
        ]
    },
    "6213": {
        "db_id": "roller_coaster",
        "question": "Show the park of the roller coaster with the highest speed.",
        "ground_truth": "SELECT Park FROM roller_coaster ORDER BY Speed DESC LIMIT 1",
        "amends": [
            "Do select `Park` instead of `park` to match the correct column name casing. Do order by `Speed DESC` instead of `speed ASC` to sort by descending speed rather than ascending. Do query from `roller_coaster` instead of `roller_coasters` to reference the correct table name. The amended query now correctly identifies the park with the fastest roller coaster by selecting from the proper table with appropriate column casing and descending speed ordering."
        ],
        "rules": [
            "1) When the question asks for \"park\" of a roller coaster: use the exact column name \"Park\" from the roller_coaster table. 2) When the question asks for the roller coaster with the \"highest speed\": order by the \"Speed\" column in descending direction to get the fastest coaster. 3) When referencing the table containing roller coaster data: use the exact table name \"roller_coaster\" (not roller_coasters). 4) When selecting the top result after ordering: take only the first row from the ordered results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT park FROM roller_coasters ORDER BY speed ASC LIMIT 1;",
            "SELECT Park FROM roller_coaster ORDER BY Speed DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Park FROM roller_coaster ORDER BY Speed DESC LIMIT 1;"
        ]
    },
    "5204": {
        "db_id": "music_2",
        "question": "What instrument did the musician with last name \"Heilo\" use in the song \"Le Pop\"?",
        "ground_truth": "SELECT T4.instrument FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId JOIN Instruments AS T4 ON T4.songid  =  T3.songid AND T4.bandmateid  =  T2.id WHERE T2.lastname  =  \"Heilo\" AND T3.title  =  \"Le Pop\"",
        "amends": [
            "Do join `Performance AS T1`, `Band AS T2`, `Songs AS T3`, and `Instruments AS T4` with explicit join conditions instead of querying a single `musicians` table. Do use `T4.instrument` instead of `instrument` to specify the source table. Do filter on `T2.lastname = \"Heilo\"` instead of `last_name = 'Heilo'` to reference the correct table and column. Do filter on `T3.title = \"Le Pop\"` instead of `song_name = 'Le Pop'` to use the proper column name from the Songs table. Do add join predicates `T1.bandmate = T2.id`, `T3.SongId = T1.SongId`, and `T4.songid = T3.songid AND T4.bandmateid = T2.id` instead of omitting the necessary table relationships. The amended query now correctly retrieves instruments by joining multiple related tables with proper foreign key relationships."
        ],
        "rules": [
            "1) When answering about \"What instrument did the musician with last name 'Heilo' use in the song 'Le Pop'\": make sure the output order: T4.instrument. 2) When the question mentions \"last name 'Heilo'\": \"last name 'Heilo'\" actually means \"T2.lastname = 'Heilo'\" in schema. 3) When the question mentions \"song 'Le Pop'\": \"song 'Le Pop'\" actually means \"T3.title = 'Le Pop'\" in schema. 4) When combining T1, T2, T3, and T4 for shared entities: link rows where T1.bandmate = T2.id, T3.SongId = T1.SongId, and T4.songid = T3.songid AND T4.bandmateid = T2.id; keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for identifiers like \"T2.lastname\" and \"T3.title\". 6) When handling text literals: do not change case, spacing, or punctuation for values like 'Heilo' and 'Le Pop'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT instrument FROM musicians WHERE last_name = 'Heilo' AND song_name = 'Le Pop';",
            "SELECT T4.Instrument\nFROM Performance AS T1\nJOIN Band AS T2 ON T1.Bandmate = T2.Id\nJOIN Songs AS T3 ON T1.SongId = T3.SongId\nJOIN Instruments AS T4 ON T4.SongId = T3.SongId AND T4.BandmateId = T2.Id\nWHERE T2.Lastname = 'Heilo' AND T3.Title = 'Le Pop'"
        ],
        "rule_sql": [
            "SELECT T4.Instrument\nFROM Performance T1\nJOIN Band T2 ON T1.Bandmate = T2.Id\nJOIN Songs T3 ON T1.SongId = T3.SongId\nJOIN Instruments T4 ON T4.SongId = T3.SongId AND T4.BandmateId = T2.Id\nWHERE T2.Lastname = 'Heilo' AND T3.Title = 'Le Pop'"
        ]
    },
    "3041": {
        "db_id": "loan_1",
        "question": "What are the names of customers who have not taken a Mortage loan?",
        "ground_truth": "SELECT cust_name FROM customer EXCEPT SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id WHERE T2.loan_type  =  'Mortgages'",
        "amends": [
            "Do select `cust_name` instead of `name` and use `EXCEPT` to exclude mortgage customers instead of directly filtering for them. Do reference the `customer` table instead of `customers` and add a join with `loan` table on `cust_id` instead of filtering directly in WHERE. Do use the correct table alias `T1` for customer and `T2` for loan instead of no aliases. Do check for loan type `'Mortgages'` (plural) instead of `'Mortgage'` (singular) and move this condition to the joined loan table instead of the customer table. Do remove the simple WHERE filter and replace it with an EXCEPT operation that excludes customers who have mortgage loans. The amended query now correctly identifies customers without mortgage loans by using set exclusion instead of incorrect direct filtering."
        ],
        "rules": [
            "1) When the question asks for customer names: use the exact column token \"cust_name\" from the customer table instead of \"name\". 2) When identifying customers without mortgage loans: use an EXCEPT operation to exclude customers who have mortgage loans rather than filtering directly. 3) When referencing tables: use the exact table name \"customer\" instead of \"customers\" and join with the \"loan\" table. 4) When using table aliases: assign \"T1\" to the customer table and \"T2\" to the loan table. 5) When checking for mortgage loans: use the exact literal 'Mortgages' (plural) instead of 'Mortgage' (singular). 6) When joining tables: link rows where T1.cust_id equals T2.cust_id to combine customer and loan information. 7) When filtering loan types: apply the condition T2.loan_type = 'Mortgages' to the loan table rather than the customer table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM customers WHERE loan_type = 'Mortgage';",
            "SELECT cust_name FROM customer\nEXCEPT\nSELECT T1.cust_name FROM customer T1\nJOIN loan T2 ON T1.cust_ID = T2.cust_ID\nWHERE T2.loan_type = 'Mortgages'"
        ],
        "rule_sql": [
            "SELECT cust_name FROM customer T1 EXCEPT SELECT cust_name FROM customer T1 JOIN loan T2 ON T1.cust_ID = T2.cust_ID WHERE T2.loan_type = 'Mortgages'"
        ]
    },
    "239": {
        "db_id": "musical",
        "question": "Return the characters and durations for each actor.",
        "ground_truth": "SELECT Character ,  Duration FROM actor",
        "amends": [
            "Do use table alias `actor` instead of `actors` and select column `Character` instead of `actor_name`. Do select column `Duration` instead of `movie_duration` and remove the `JOIN movies` clause with its `ON actors.movie_id = movies.id` predicate instead of including it. The amended query now correctly retrieves character names and durations directly from the actor table without unnecessary joins."
        ],
        "rules": [
            "1) When answering about \"characters and durations for each actor\": make sure the output order: Character, Duration. 2) When the question mentions \"characters\": \"characters\" actually means \"Character in schema\". 3) When the question mentions \"durations\": \"durations\" actually means \"Duration in schema\". 4) When selecting from the actor table: use the exact table name \"actor\" without joining to other tables. 5) When producing output columns: select exactly \"Character\" and \"Duration\" from the actor table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT actor_name, movie_duration FROM actors JOIN movies ON actors.movie_id = movies.id;",
            "SELECT Character, Duration FROM actor"
        ],
        "rule_sql": [
            "SELECT Character, Duration FROM actor;"
        ]
    },
    "5688": {
        "db_id": "dorm_1",
        "question": "Find the average and total capacity of dorms for the students with gender X.",
        "ground_truth": "SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  'X'",
        "amends": [
            "Do reference `student_capacity` instead of `capacity` in both aggregate functions. Do use table name `dorm` instead of `dorms` in the FROM clause. The amended query now correctly references the appropriate column and table names to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for average and total capacity of dorms: use AVG and SUM functions on the exact column name \"student_capacity\" from table \"dorm\". 2) When referencing the dorm table: use the exact table name \"dorm\" instead of \"dorms\". 3) When the question mentions \"students with gender X\": this condition should not be applied to the dorm table as the dorm table does not contain gender information according to the schema."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(capacity), SUM(capacity) FROM dorms WHERE gender = 'X';",
            "SELECT AVG(d.student_capacity) AS average_capacity, SUM(d.student_capacity) AS total_capacity FROM Dorm d WHERE d.gender = 'X';"
        ],
        "rule_sql": [
            "SELECT AVG(d.student_capacity) AS average_capacity, SUM(d.student_capacity) AS total_capacity FROM Dorm d"
        ]
    },
    "4606": {
        "db_id": "entertainment_awards",
        "question": "Show the names of the three most recent festivals.",
        "ground_truth": "SELECT Festival_Name FROM festival_detail ORDER BY YEAR DESC LIMIT 3",
        "amends": [
            "Do select `Festival_Name` instead of `name` and do use `YEAR` for ordering instead of `date`. Do query from `festival_detail` instead of `festivals` while maintaining the same `LIMIT 3` structure. The amended query now correctly retrieves festival names ordered by year from the appropriate table structure."
        ],
        "rules": [
            "1) When answering about \"most recent festivals\": make sure the output order: Festival_Name. 2) When the question mentions \"most recent\": use YEAR for ordering in descending direction and keep the first 3 rows. 3) When the question asks for \"names of festivals\": Festival_Name actually means Festival_Name in schema. 4) When querying festival data: use table festival_detail instead of festivals."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM festivals ORDER BY date DESC LIMIT 3;",
            "SELECT Festival_Name FROM festival_detail ORDER BY Year DESC LIMIT 3"
        ],
        "rule_sql": [
            "SELECT Festival_Name FROM festival_detail ORDER BY Year DESC LIMIT 3;"
        ]
    },
    "6223": {
        "db_id": "ship_1",
        "question": "Count the number of captains that have each rank.",
        "ground_truth": "SELECT count(*) ,  rank FROM captain GROUP BY rank",
        "amends": [
            "Do `count(*)` and `rank` in the SELECT list instead of `rank` and `COUNT(*)`. Do `captain` as the FROM source instead of `captains`. Do `GROUP BY rank` instead of `GROUP BY captain_id`. Do remove the alias from the count aggregation instead of keeping it. The amended query now correctly groups by rank and counts occurrences per rank rather than incorrectly grouping by captain_id.",
            "Do place the `rank` column after the aggregate function instead of before it in the SELECT list. Do maintain the `COUNT(*)` aggregate function and `GROUP BY rank` clause without changes. The amended query now correctly displays the count alongside each rank value and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting the number of captains per rank: group the results by the exact \"rank\" column from the \"captain\" table. 2) When computing counts per group: count all rows in each group using the count(*) function without any alias. 3) When ordering output columns: place the \"rank\" column first followed by the count result. 4) When referring to the table containing captain information: use the exact table name \"captain\" (not \"captains\").",
            "1) When counting entities per group: place the grouping column after the aggregate function in the output order. 2) When grouping by a specific column (rank): maintain the COUNT(*) aggregate function and GROUP BY clause without changes. 3) When the question asks for \"count of captains that have each rank\": compute the number of rows per distinct rank value using COUNT(*)."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT rank, COUNT(*) FROM captains GROUP BY captain_id;",
            "SELECT rank, COUNT(*) FROM captain GROUP BY rank",
            "SELECT COUNT(*), rank FROM captain GROUP BY rank"
        ],
        "rule_sql": [
            "SELECT \"Rank\", COUNT(*) FROM captain GROUP BY \"Rank\";"
        ]
    },
    "4465": {
        "db_id": "network_2",
        "question": "What are the different names of friends who are younger than the average age for a friend?",
        "ground_truth": "SELECT DISTINCT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  <  (SELECT avg(age) FROM person)",
        "amends": [
            "Do select `DISTINCT T2.name` from `Person AS T1 JOIN PersonFriend AS T2` instead of `name` from `friends`. Do join on `T1.name = T2.friend` instead of no join condition. Do use `PersonFriend` table instead of `friends` table. Do reference `T1.age` in the WHERE filter instead of `age`. Do use `person` table in the subquery instead of `friends`. The amended query now correctly finds distinct names of friends for people younger than the average age, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"different names of friends\": select distinct values of T2.name from the PersonFriend table. 2) When combining Person and PersonFriend tables: link rows where T1.name = T2.friend and keep only matching pairs (inner match). 3) When filtering by age condition: compare T1.age against the average age computed from the Person table. 4) When computing average age: calculate the average of T1.age from the Person table in a subquery. 5) When the question asks for friends younger than average: filter to include only rows where T1.age < (average age from Person table)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM friends WHERE age < (SELECT AVG(age) FROM friends);",
            "SELECT DISTINCT T2.name\nFROM Person AS T1\nJOIN PersonFriend AS T2 ON T1.name = T2.friend\nWHERE T1.age < (SELECT AVG(age) FROM Person)"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.name\nFROM Person T1\nINNER JOIN PersonFriend T2 ON T1.name = T2.friend\nWHERE T1.age < (SELECT AVG(age) FROM Person)"
        ]
    },
    "1940": {
        "db_id": "cinema",
        "question": "Show the average, minimum, and maximum capacity for all the cinemas opened in year 2011 or later.",
        "ground_truth": "SELECT avg(capacity) ,  min(capacity) ,  max(capacity) FROM cinema WHERE openning_year  >=  2011",
        "amends": [
            "Do use table name `cinema` instead of `cinemas` in the FROM clause. Do change the filter condition to `openning_year >= 2011` instead of `opened_year = 2011`, expanding the date range from a single year to all years from 2011 onward. Do use lowercase function names `avg`, `min`, and `max` instead of uppercase `AVG`, `MIN`, and `MAX` for aggregate functions. The amended query now correctly matches the behavior of filtering for cinemas with opening years from 2011 onwards rather than only those opened exactly in 2011."
        ],
        "rules": [
            "1) When the question mentions \"cinemas\": use the exact table name \"cinema\" instead of \"cinemas\". 2) When filtering for cinemas opened in year 2011 or later: use the condition \"openning_year >= 2011\" to include all years from 2011 onward, not just exactly 2011. 3) When computing aggregate functions: use lowercase function names \"avg\", \"min\", and \"max\" instead of uppercase versions. 4) When answering about average, minimum, and maximum capacity: make sure the output order: avg(capacity), min(capacity), max(capacity)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(capacity), MIN(capacity), MAX(capacity) FROM cinemas WHERE opened_year = 2011;",
            "SELECT avg(Capacity) as average_capacity, min(Capacity) as minimum_capacity, max(Capacity) as maximum_capacity FROM cinema WHERE Openning_year >= 2011"
        ],
        "rule_sql": [
            "SELECT avg(capacity), min(capacity), max(capacity) FROM cinema WHERE openning_year >= 2011;"
        ]
    },
    "2565": {
        "db_id": "county_public_safety",
        "question": "What are the names of counties that do not contain any cities?",
        "ground_truth": "SELECT Name FROM county_public_safety WHERE County_ID NOT IN (SELECT County_ID FROM city)",
        "amends": [
            "Do select `Name` from `county_public_safety` instead of `name` from `counties`. Do use a subquery with `NOT IN` to filter by `County_ID` values that don't exist in the `city` table instead of filtering by `city_count = 0`. Do reference the correct table `county_public_safety` instead of `counties`. The amended query now correctly identifies counties without any cities by checking for missing County_ID values in the city table rather than relying on a potentially incorrect count column."
        ],
        "rules": [
            "1) When answering about \"names of counties that do not contain any cities\": make sure the output order: \"Name\" from \"county_public_safety\". 2) When the question mentions \"counties\": \"counties\" actually means \"county_public_safety\" in schema. 3) When filtering for counties without cities: use a subquery with NOT IN to filter by \"County_ID\" values that don't exist in the \"city\" table. 4) When combining county_public_safety and city tables: link rows where \"County_ID\" values match exactly, and keep only counties that have no matching \"County_ID\" in the city table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM counties WHERE city_count = 0;",
            "SELECT Name FROM county_public_safety WHERE County_ID NOT IN (SELECT DISTINCT County_ID FROM city)"
        ],
        "rule_sql": [
            "SELECT Name FROM county_public_safety WHERE County_ID NOT IN (SELECT DISTINCT County_ID FROM city) ORDER BY Name;"
        ]
    },
    "4495": {
        "db_id": "decoration_competition",
        "question": "Show the names of members and the decoration themes they have.",
        "ground_truth": "SELECT T1.Name ,  T2.Decoration_Theme FROM member AS T1 JOIN round AS T2 ON T1.Member_ID  =  T2.Member_ID",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do select `T1.Name` instead of `member_name` and `T2.Decoration_Theme` instead of `decoration_theme`. Do reference table `member AS T1` instead of `members` and `round AS T2` instead of `decorations`. Do maintain the same `JOIN` type and `ON T1.Member_ID = T2.Member_ID` predicate instead of `members.member_id = decorations.member_id`. The amended query now correctly references the proper table names and column aliases while preserving the join logic."
        ],
        "rules": [
            "1) When answering about \"names of members and decoration themes\": make sure the output order: T1.Name, T2.Decoration_Theme 2) When the question mentions \"members\": \"members\" actually means \"member AS T1\" in schema 3) When the question mentions \"decoration themes\": \"decoration themes\" actually means \"T2.Decoration_Theme\" in schema 4) When combining T1 and T2 for shared entities: link rows where T1.Member_ID = T2.Member_ID; keep only matching pairs (inner match)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT member_name, decoration_theme FROM members JOIN decorations ON members.member_id = decorations.member_id;",
            "SELECT T1.Name, T2.Decoration_Theme FROM member AS T1 JOIN round AS T2 ON T1.Member_ID = T2.Member_ID"
        ],
        "rule_sql": [
            "SELECT T1.Name, T2.Decoration_Theme FROM member AS T1 INNER JOIN round AS T2 ON T1.Member_ID = T2.Member_ID"
        ]
    },
    "5832": {
        "db_id": "workshop_paper",
        "question": "Show the authors of submissions and the acceptance results of their submissions.",
        "ground_truth": "SELECT T2.Author ,  T1.Result FROM acceptance AS T1 JOIN submission AS T2 ON T1.Submission_ID  =  T2.Submission_ID",
        "amends": [
            "Do join `acceptance AS T1` and `submission AS T2` instead of querying only `submissions` table. Do use `T1.Submission_ID = T2.Submission_ID` join condition instead of no join. Do select `T2.Author` and `T1.Result` instead of `author` and `result`. Do remove `WHERE result = 'accepted'` filter instead of keeping it, as the join to acceptance table inherently provides the accepted results. The amended query now correctly retrieves author information from the submission table joined with acceptance records instead of filtering a single table."
        ],
        "rules": [
            "1) When answering about \"authors of submissions and acceptance results\": make sure the output order: T2.Author, T1.Result\n2) When combining acceptance and submission tables: link rows where T1.Submission_ID = T2.Submission_ID and keep only matching pairs (inner match)\n3) When the question asks for all acceptance results: do not filter by result = 'accepted' as the join to acceptance table inherently provides the acceptance results"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT author, result FROM submissions WHERE result = 'accepted';",
            "SELECT T2.Author, T1.Result FROM acceptance AS T1 JOIN submission AS T2 ON T1.Submission_ID = T2.Submission_ID"
        ],
        "rule_sql": [
            "SELECT T2.Author, T1.Result \nFROM Acceptance T1 \nINNER JOIN submission T2 ON T1.Submission_ID = T2.Submission_ID \nORDER BY T2.Author, T1.Result"
        ]
    },
    "705": {
        "db_id": "customers_card_transactions",
        "question": "How many cards does customer Art Turcotte have?",
        "ground_truth": "SELECT count(*) FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  \"Art\" AND T2.customer_last_name  =  \"Turcotte\"",
        "amends": [
            "Do add `JOIN Customers_cards AS T1` and `JOIN Customers AS T2 ON T1.customer_id = T2.customer_id` instead of querying only the `customers` table. Do change the filter to `T2.customer_first_name = \"Art\" AND T2.customer_last_name = \"Turcotte\"` instead of `name = 'Art Turcotte'` to properly match first and last name separately. Do maintain `COUNT(*)` as the aggregate function but now applied to the joined result set instead of a single table. The amended query now correctly counts customers with matching first and last names across the joined tables, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"how many cards a customer has\": make sure to join the Customers_cards table (as T1) with the Customers table (as T2) using the condition T1.customer_id = T2.customer_id. 2) When the question mentions customer name \"Art Turcotte\": split this into separate conditions T2.customer_first_name = \"Art\" AND T2.customer_last_name = \"Turcotte\" using exact case and spelling. 3) When counting cards for a customer: use COUNT(*) applied to the joined result set to count all matching card records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE name = 'Art Turcotte';",
            "SELECT COUNT(*) \nFROM Customers_Cards AS T1\nJOIN Customers AS T2 ON T1.customer_id = T2.customer_id\nWHERE T2.customer_first_name = 'Art' AND T2.customer_last_name = 'Turcotte'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Customers_Cards AS T1\nJOIN Customers AS T2 ON T1.customer_id = T2.customer_id\nWHERE T2.customer_first_name = 'Art' AND T2.customer_last_name = 'Turcotte'"
        ]
    },
    "1951": {
        "db_id": "cinema",
        "question": "What are the title and maximum price of each film?",
        "ground_truth": "SELECT T2.title ,  max(T1.price) FROM schedule AS T1 JOIN film AS T2 ON T1.film_id  =  T2.film_id GROUP BY T1.film_id",
        "amends": [
            "Do use `max(T1.price)` instead of `MIN(price) as maximum_price` to correctly calculate the maximum price. Do join `schedule AS T1` with `film AS T2` on `T1.film_id = T2.film_id` instead of querying only the `films` table. Do select `T2.title` instead of just `title` and group by `T1.film_id` instead of `title` to properly aggregate by film identifier. Do remove the misleading alias `maximum_price` instead of keeping it since the function calculates maximum values. The amended query now correctly joins the schedule and film tables to find maximum prices per film."
        ],
        "rules": [
            "1) When answering about \"maximum price of each film\": use max(T1.price) instead of MIN(price) to calculate the maximum price. 2) When combining schedule and film tables: link rows where T1.film_id = T2.film_id and keep only matching pairs (inner match). 3) When selecting film titles: use T2.title instead of just title to reference the correct table. 4) When grouping by film: use T1.film_id instead of title to properly aggregate by film identifier. 5) When calculating maximum price: do not use the alias maximum_price since the function name max already indicates it calculates maximum values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title, MIN(price) as maximum_price FROM films GROUP BY title",
            "SELECT T2.title, MAX(T1.price) FROM schedule AS T1 JOIN film AS T2 ON T1.Film_ID = T2.Film_ID GROUP BY T1.Film_ID"
        ],
        "rule_sql": [
            "SELECT T2.title, MAX(T1.price) FROM schedule T1 INNER JOIN film T2 ON T1.Film_ID = T2.Film_ID GROUP BY T1.Film_ID"
        ]
    },
    "4591": {
        "db_id": "solvency_ii",
        "question": "Show the product type codes that have at least two products.",
        "ground_truth": "SELECT Product_Type_Code FROM Products GROUP BY Product_Type_Code HAVING COUNT(*)  >=  2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT product_type_code FROM products GROUP BY product_type_code HAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT Product_Type_Code\nFROM Products\nGROUP BY Product_Type_Code\nHAVING COUNT(Product_ID) >= 2;"
        ]
    },
    "3737": {
        "db_id": "program_share",
        "question": "What is the list of program names, sorted by the order of launch date?",
        "ground_truth": "SELECT name FROM program ORDER BY launch",
        "amends": [
            "Do select `name` instead of `program_name` as the column to retrieve. Do reference table `program` instead of `programs` as the data source. Do order by `launch` instead of `program_id` as the sorting criterion. The amended query now correctly retrieves the name column from the program table ordered by launch date instead of program ID."
        ],
        "rules": [
            "1) When the question asks for \"program names\": select the exact column \"name\" from the program table. 2) When the question asks for sorting by \"launch date\": order the results by the exact column \"launch\" from the program table. 3) When referencing the table containing program information: use the exact table name \"program\" (not \"programs\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT program_name FROM programs ORDER BY program_id;",
            "SELECT Name FROM program ORDER BY Launch;"
        ],
        "rule_sql": [
            "SELECT name FROM program ORDER BY launch;"
        ]
    },
    "1890": {
        "db_id": "school_finance",
        "question": "List the name of the school with the smallest enrollment.",
        "ground_truth": "SELECT school_name FROM school ORDER BY enrollment LIMIT 1",
        "amends": [
            "Do select `school_name` instead of `name` and do reference table `school` instead of `schools`. Do remove `DESC` from the `ORDER BY` clause instead of keeping it, which changes the sort direction from descending to ascending. The amended query now correctly retrieves the school with the smallest enrollment rather than the largest, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for the school with the smallest enrollment: use \"school_name\" as the output column instead of \"name\". 2) When the question asks for the school with the smallest enrollment: reference the table \"school\" instead of \"schools\". 3) When the question asks for the smallest enrollment: sort by enrollment in ascending order (without DESC) to get the smallest value first. 4) When the question asks for a single school with the smallest enrollment: limit the result to 1 row to get only the smallest enrollment school."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM schools ORDER BY enrollment DESC LIMIT 1;",
            "SELECT School_name FROM School ORDER BY Enrollment ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT school_name FROM School ORDER BY Enrollment LIMIT 1;"
        ]
    },
    "146": {
        "db_id": "bike_1",
        "question": "What are the 3 most common cloud covers in the zip code of 94107?",
        "ground_truth": "SELECT cloud_cover FROM weather WHERE zip_code  =  94107 GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT 3",
        "amends": [
            "Do reference table `weather` instead of `weather_data` and use numeric value `94107` instead of string '94107'. Do remove the `COUNT(*) as frequency` column from SELECT list instead of including it, and do move the aggregate function to ORDER BY as `COUNT(*) DESC` instead of ordering by the alias `frequency`. Do keep `GROUP BY cloud_cover` and `LIMIT 3` unchanged. The amended query now correctly returns only cloud_cover values ordered by their count frequency without including the count column in the output."
        ],
        "rules": [
            "1) When the question asks for cloud covers in zip code 94107: use table \"weather\" instead of weather_data and filter using numeric value 94107 instead of string '94107'. 2) When counting occurrences of cloud cover values: group by \"cloud_cover\" and count using COUNT(*) but do not include the count column in the output. 3) When finding the 3 most common values: order by the count of occurrences in descending order and keep only the top 3 rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT cloud_cover, COUNT(*) as frequency FROM weather_data WHERE zip_code = '94107' GROUP BY cloud_cover ORDER BY frequency DESC LIMIT 3;",
            "SELECT cloud_cover FROM weather WHERE zip_code = 94107 GROUP BY cloud_cover ORDER BY COUNT(*) DESC LIMIT 3"
        ],
        "rule_sql": [
            "SELECT cloud_cover FROM weather WHERE zip_code = 94107 GROUP BY cloud_cover ORDER BY COUNT(*) DESC LIMIT 3"
        ]
    },
    "4965": {
        "db_id": "soccer_2",
        "question": "What is the number of students playing as a goalie?",
        "ground_truth": "SELECT count(*) FROM tryout WHERE pPos  =  'goalie'",
        "amends": [
            "Do reference table `tryout` instead of `students` in the FROM clause. Do use column `pPos` instead of `position` in the WHERE filter. Do filter for value 'goalie' instead of 'goalkeeper' in the WHERE condition. The amended query now correctly counts records from the tryout table where the position is specified as goalie."
        ],
        "rules": [
            "1) When answering about \"number of students playing as a goalie\": make sure the output order: count of students with goalie position. 2) When the question mentions \"students playing as a goalie\": \"students\" actually means \"records in table tryout\" and \"goalie\" means exact value 'goalie' in column pPos. 3) When counting students with goalie position: compute the number of rows where T1.pPos equals 'goalie' exactly as specified. 4) When handling text literals: do not change 'goalie' to 'goalkeeper' or any other variation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE position = 'goalkeeper';",
            "SELECT COUNT(*) FROM Tryout WHERE pPos = 'goalie';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Tryout WHERE pPos = 'goalie';"
        ]
    },
    "6466": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "Give the dates of creation for documents that have both budget type codes 'GV' and 'SF'.",
        "ground_truth": "SELECT T1.document_date FROM Documents AS T1 JOIN Documents_with_Expenses AS T2 ON T1.document_id  =  T2.document_id WHERE T2.budget_type_code  =  'GV' INTERSECT SELECT T1.document_date FROM Documents AS T1 JOIN Documents_with_Expenses AS T2 ON T1.document_id  =  T2.document_id WHERE T2.budget_type_code  =  'SF'",
        "amends": [
            "Do change the SELECT list to `document_date` instead of `creation_date` and add table alias `T1` instead of no alias. Do add a FROM clause with `Documents AS T1` joined to `Documents_with_Expenses AS T2` on `T1.document_id = T2.document_id` instead of querying only `documents` table. Do change the WHERE filter to use `T2.budget_type_code = 'GV'` in one branch and `T2.budget_type_code = 'SF'` in another instead of `budget_type_code = 'GV' OR budget_type_code = 'SF'` in a single query. Do use `INTERSECT` to find dates that appear in both budget type conditions instead of using `OR` which returns dates from either condition. The amended query now correctly finds document dates that have both GV and SF budget types through the intersection operation."
        ],
        "rules": [
            "1) When the question asks for \"dates of creation\": use the exact column token \"document_date\" from table T1 instead of \"creation_date\". 2) When combining tables Documents and Documents_with_Expenses: link rows where T1.document_id = T2.document_id and keep only matching pairs (inner match). 3) When finding documents with both budget type codes 'GV' and 'SF': use INTERSECT to find dates that appear in both conditions T2.budget_type_code = 'GV' and T2.budget_type_code = 'SF' instead of using OR which returns dates from either condition. 4) When handling text literals: preserve the exact values 'GV' and 'SF' with the specified case and no quotes around the values. 5) When referring to table roles: use T1 for Documents table and T2 for Documents_with_Expenses table as specified in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT creation_date FROM documents WHERE budget_type_code = 'GV' OR budget_type_code = 'SF';",
            "SELECT T1.document_date\nFROM Documents AS T1\nJOIN Documents_with_Expenses AS T2 ON T1.document_id = T2.document_id\nWHERE T2.budget_type_code = 'GV'\nINTERSECT\nSELECT T1.document_date\nFROM Documents AS T1\nJOIN Documents_with_Expenses AS T2 ON T1.document_id = T2.document_id\nWHERE T2.budget_type_code = 'SF'"
        ],
        "rule_sql": [
            "SELECT T1.document_date\nFROM Documents T1\nINNER JOIN Documents_with_Expenses T2 ON T1.document_id = T2.document_id\nWHERE T2.budget_type_code = 'GV'\nINTERSECT\nSELECT T1.document_date\nFROM Documents T1\nINNER JOIN Documents_with_Expenses T2 ON T1.document_id = T2.document_id\nWHERE T2.budget_type_code = 'SF'"
        ]
    },
    "2947": {
        "db_id": "sakila_1",
        "question": "Count the number of customers who are active.",
        "ground_truth": "SELECT count(*) FROM customer WHERE active = '1'",
        "amends": [
            "Do reference table `customer` instead of `customers` and use filter `active = '1'` instead of `status = 'inactive'` to correctly identify inactive records based on the active flag rather than status field. The amended query now matches RIGHT_SQL's behavior by counting inactive customers using the appropriate table and boolean flag column."
        ],
        "rules": [
            "1) When the question asks to count customers: use the table \"customer\" (not \"customers\") to access customer records. 2) When identifying active customers: use the condition \"active = '1'\" (not \"status = 'inactive'\") to filter for active records using the boolean flag column. 3) When counting entities: count the number of rows that satisfy the active customer condition using the canonical customer table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE status = 'inactive';",
            "SELECT COUNT(*) FROM customer WHERE active = '1';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM customer WHERE active = '1';"
        ]
    },
    "6645": {
        "db_id": "driving_school",
        "question": "In which country and state does Janessa Sawayn live?",
        "ground_truth": "SELECT T1.country ,  T1.state_province_county FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id WHERE T2.first_name = \"Janessa\" AND T2.last_name = \"Sawayn\";",
        "amends": [
            "Do select `country` and `state_province_county` from the `Addresses` table instead of `country` and `state` from the `users` table. Do join `Staff` on `address_id = staff_address_id` instead of querying the `users` table directly. Do filter on `first_name` and `last_name` from the `Staff` table instead of from a `users` table. Do use table aliases `T1` and `T2` for clarity instead of no aliases. The amended query now correctly retrieves address information by joining staff data through the proper relationship."
        ],
        "rules": [
            "1) When the question asks about a person's location: retrieve country and state_province_county from the Addresses table instead of country and state from other tables. 2) When filtering by a person's name: use first_name and last_name from the Staff table instead of from a users table. 3) When joining Staff and Addresses tables: link rows where T2.address_id equals T1.staff_address_id to find address information for staff members. 4) When answering about \"Janessa Sawayn\": filter for rows where T1.first_name equals 'Janessa' and T1.last_name equals 'Sawayn' exactly as specified."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country, state FROM users WHERE first_name = 'Janessa' AND last_name = 'Sawayn'",
            "SELECT T2.country, T2.state_province_county \nFROM Staff T1 \nJOIN Addresses T2 ON T1.staff_address_id = T2.address_id \nWHERE T1.first_name = 'Janessa' AND T1.last_name = 'Sawayn'"
        ],
        "rule_sql": [
            "SELECT T2.country, T2.state_province_county \nFROM Staff T1 \nJOIN Addresses T2 ON T2.address_id = T1.staff_address_id \nWHERE T1.first_name = 'Janessa' AND T1.last_name = 'Sawayn'"
        ]
    },
    "3518": {
        "db_id": "hr_1",
        "question": "What are the full names, departments, cities, and state provinces for each employee?",
        "ground_truth": "SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id",
        "amends": [
            "Do specify table aliases `T1.first_name`, `T1.last_name` instead of unqualified `first_name`, `last_name`. Do add joins to `departments AS T2` on `T1.department_id = T2.department_id` and `locations AS T3` on `T2.location_id = T3.location_id` instead of querying only the `employees` table. Do select `T2.department_name` instead of `department` and `T3.city`, `T3.state_province` instead of `city`, `state_province` to properly reference the joined tables. The amended query now correctly joins related tables to retrieve department and location information instead of attempting to access non-existent columns directly from the employees table."
        ],
        "rules": [
            "1) When answering about employee information with department and location details: make sure the output order: T1.first_name, T1.last_name, T2.department_name, T3.city, T3.state_province\n2) When the question mentions \"departments\": \"department\" actually means \"T2.department_name\" in schema\n3) When the question mentions \"cities\" and \"state provinces\": \"city\" actually means \"T3.city\" and \"state_province\" actually means \"T3.state_province\" in schema\n4) When combining T1 (employees) and T2 (departments) for shared entities: link rows where T1.department_id = T2.department_id and keep only matching pairs (inner match)\n5) When combining T2 (departments) and T3 (locations) for shared entities: link rows where T2.location_id = T3.location_id and keep only matching pairs (inner match)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name, department, city, state_province FROM employees",
            "SELECT T1.first_name, T1.last_name, T2.department_name, T3.city, T3.state_province \nFROM employees AS T1\nJOIN departments AS T2 ON T1.department_id = T2.department_id\nJOIN locations AS T3 ON T2.location_id = T3.location_id"
        ],
        "rule_sql": [
            "SELECT \n    T1.FIRST_NAME, \n    T1.LAST_NAME, \n    T2.DEPARTMENT_NAME, \n    T3.CITY, \n    T3.STATE_PROVINCE\nFROM \n    employees T1\nINNER JOIN \n    departments T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID\nINNER JOIN \n    locations T3 ON T2.LOCATION_ID = T3.LOCATION_ID"
        ]
    },
    "4073": {
        "db_id": "student_1",
        "question": "Find the number of teachers who teach the student called CHRISSY NABOZNY.",
        "ground_truth": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.firstname  =  \"CHRISSY\" AND T1.lastname  =  \"NABOZNY\"",
        "amends": [
            "Do join `list AS T1` with `teachers AS T2` on `T1.classroom = T2.classroom` instead of querying only the `teachers` table. Do filter on `T1.firstname = \"CHRISSY\"` and `T1.lastname = \"NABOZNY\"` instead of filtering on a non-existent `student_name` column in the teachers table. Do use proper table aliases and join conditions to establish the relationship between students and teachers through classroom association instead of attempting to find student names directly in the teachers table. The amended query correctly counts teachers associated with the specified student by joining through classroom relationships rather than searching for student data in the wrong table."
        ],
        "rules": [
            "1) When answering about \"number of teachers who teach a specific student\": join the list table as T1 with the teachers table as T2 on T1.classroom = T2.classroom to establish the relationship between students and teachers through classroom association. 2) When the question mentions \"student called CHRISSY NABOZNY\": filter on T1.firstname = \"CHRISSY\" and T1.lastname = \"NABOZNY\" to identify the specific student. 3) When counting teachers associated with a student: count the number of matching teacher records from T2 after joining through the classroom relationship. 4) When combining T1 and T2 for shared classroom entities: link rows where T1.classroom = T2.classroom exactly and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM teachers WHERE student_name = 'CHRISSY NABOZNY';",
            "SELECT COUNT(DISTINCT T2.LastName || ', ' || T2.FirstName) \nFROM list AS T1 \nJOIN teachers AS T2 ON T1.Classroom = T2.Classroom \nWHERE T1.FirstName = 'CHRISSY' AND T1.LastName = 'NABOZNY'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T2.LastName || T2.FirstName) \nFROM list AS T1 \nJOIN teachers AS T2 ON T1.Classroom = T2.Classroom \nWHERE T1.FirstName = 'CHRISSY' AND T1.LastName = 'NABOZNY'"
        ]
    },
    "4964": {
        "db_id": "soccer_2",
        "question": "How many students whose are playing the role of goalie?",
        "ground_truth": "SELECT count(*) FROM tryout WHERE pPos  =  'goalie'",
        "amends": [
            "Do query the `tryout` table instead of the `students` table. Do use the column `pPos` for filtering instead of `role`. Do keep the aggregate function `count(*)` and the filter condition for 'goalie' value, but apply them to the correct table and column. The amended query now correctly counts goalies from the tryout table instead of incorrectly querying the students table."
        ],
        "rules": [
            "1) When answering about \"students whose are playing the role of goalie\": query the \"tryout\" table instead of the \"students\" table. 2) When filtering for players with the role of goalie: use the column \"pPos\" for filtering instead of \"role\". 3) When counting goalies: use the exact literal value 'goalie' for filtering the \"pPos\" column. 4) When counting entities: use count(*) to count all rows that match the filter condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE role = 'goalie';",
            "SELECT COUNT(*) FROM Tryout WHERE pPos = 'goalie';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Tryout WHERE pPos = 'goalie';"
        ]
    },
    "28": {
        "db_id": "farm",
        "question": "How many different statuses do cities have?",
        "ground_truth": "SELECT count(DISTINCT Status) FROM city",
        "amends": [
            "Do use `count(DISTINCT Status)` instead of `COUNT(*)` to count distinct status values rather than all rows. Do reference table `city` instead of `cities` for the correct table name. Do remove the `WHERE status IS NOT NULL` filter instead of keeping it since counting distinct values inherently excludes nulls. The amended query now correctly counts distinct status values from the city table and matches the right SQL's behavior."
        ],
        "rules": [
            "1) When counting different statuses: use count(DISTINCT Status) to count distinct status values rather than counting all rows. 2) When referencing the city table: use the exact table name \"city\" instead of \"cities\". 3) When counting distinct values: do not add a WHERE status IS NOT NULL filter since counting distinct values inherently excludes nulls."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities WHERE status IS NOT NULL;",
            "SELECT COUNT(DISTINCT Status) FROM city"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Status) FROM city;"
        ]
    },
    "1451": {
        "db_id": "college_2",
        "question": "Give the title and credits for the course that is taught in the classroom with the greatest capacity.",
        "ground_truth": "SELECT T3.title ,  T3.credits FROM classroom AS T1 JOIN SECTION AS T2 ON T1.building  =  T2.building AND T1.room_number  =  T2.room_number JOIN course AS T3 ON T2.course_id  =  T3.course_id WHERE T1.capacity  =  (SELECT max(capacity) FROM classroom)",
        "amends": [
            "Do add joins to `classroom AS T1`, `SECTION AS T2`, and `course AS T3` instead of querying `courses` directly. Do use `JOIN` conditions on `T1.building = T2.building AND T1.room_number = T2.room_number` and `T2.course_id = T3.course_id` instead of no joins. Do add a WHERE filter with subquery `T1.capacity = (SELECT max(capacity) FROM classroom)` instead of ordering by `capacity DESC LIMIT 1`. Do remove `ORDER BY capacity DESC LIMIT 1` instead of keeping it. The amended query now correctly finds courses in classrooms with maximum capacity rather than just the course with highest capacity value."
        ],
        "rules": [
            "1) When answering about courses taught in classrooms: combine classroom as T1, SECTION as T2, and course as T3 using exact join conditions T1.building = T2.building AND T1.room_number = T2.room_number and T2.course_id = T3.course_id. 2) When finding the classroom with greatest capacity: use WHERE T1.capacity = (SELECT max(capacity) FROM classroom) instead of ordering and limiting. 3) When selecting output columns: return title and credits from T3. 4) When handling classroom capacity: use T1.capacity to represent classroom capacity, not course capacity."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title, credits FROM courses ORDER BY capacity DESC LIMIT 1;",
            "SELECT T3.title, T3.credits\nFROM classroom AS T1\nJOIN section AS T2 ON T1.building = T2.building AND T1.room_number = T2.room_number\nJOIN course AS T3 ON T2.course_id = T3.course_id\nWHERE T1.capacity = (SELECT MAX(capacity) FROM classroom)"
        ],
        "rule_sql": [
            "SELECT T3.title, T3.credits\nFROM classroom AS T1\nJOIN section AS T2 ON T1.building = T2.building AND T1.room_number = T2.room_number\nJOIN course AS T3 ON T2.course_id = T3.course_id\nWHERE T1.capacity = (SELECT MAX(capacity) FROM classroom);"
        ]
    },
    "346": {
        "db_id": "flight_1",
        "question": "What are the names and distances for all airplanes?",
        "ground_truth": "SELECT name ,  distance FROM Aircraft",
        "amends": [
            "Do reference the `Aircraft` table instead of the `airplanes` table in the FROM clause, as the correct table name is `Aircraft` rather than `airplanes`. The amended query now correctly selects from the appropriate table while maintaining the same column selection of `name` and `distance`, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question mentions \"airplanes\": \"airplanes\" actually means \"Aircraft\" table in the schema. 2) When selecting from the Aircraft table: use the exact table name \"Aircraft\" with double quotes as shown in the schema. 3) When answering about airplane names and distances: make sure the output order: name, distance."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, distance FROM airplanes;",
            "SELECT name, distance FROM aircraft;"
        ],
        "rule_sql": [
            "SELECT \"name\", \"distance\" FROM \"aircraft\";"
        ]
    },
    "5462": {
        "db_id": "voter_2",
        "question": "Who are the advisors for students that live in a city with city code \"BAL\"?",
        "ground_truth": "SELECT Advisor FROM STUDENT WHERE city_code  =  \"BAL\"",
        "amends": [
            "Do reference the `Advisor` column instead of `advisor_name` and use the `STUDENT` table instead of `students` while maintaining the same `city_code = 'BAL'` filter condition instead of changing the table or predicate logic. The amended query now correctly selects from the intended table structure with proper column naming while preserving the identical filtering behavior."
        ],
        "rules": [
            "1) When the question asks about \"advisors\": use the exact column name \"Advisor\" from the STUDENT table instead of \"advisor_name\". 2) When the question refers to \"students\": use the exact table name \"STUDENT\" instead of \"students\". 3) When filtering for students in a city with code \"BAL\": apply the exact condition \"city_code = 'BAL'\" with the literal value 'BAL' exactly as specified."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT advisor_name FROM students WHERE city_code = 'BAL';",
            "SELECT Advisor FROM Student WHERE city_code = 'BAL';"
        ],
        "rule_sql": [
            "SELECT DISTINCT Advisor FROM STUDENT WHERE city_code = 'BAL';"
        ]
    },
    "6839": {
        "db_id": "flight_4",
        "question": "Find the number of different airports which are the destinations of the American Airlines.",
        "ground_truth": "SELECT count(DISTINCT dst_apid) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'",
        "amends": [
            "Do use `count(DISTINCT dst_apid)` instead of `COUNT(*)` to count unique destination airports. Do join `airlines AS T1` with `routes AS T2` on `T1.alid = T2.alid` instead of querying only the `flights` table. Do filter on `T1.name = 'American Airlines'` instead of `airline = 'American Airlines'` to properly reference the airline name from the correct table. Do remove the simple count of all rows instead of counting distinct destination airport IDs from the joined routes data. The amended query now correctly counts unique destinations served by American Airlines by joining the airlines and routes tables."
        ],
        "rules": [
            "1) When answering about \"number of different airports which are the destinations of the American Airlines\": make sure the output order: count of distinct destination airports. 2) When the question mentions \"American Airlines\": \"American Airlines\" actually means \"T1.name = 'American Airlines'\" in schema. 3) When combining T1 (airlines) and T2 (routes) for shared entities: link rows where T1.alid = T2.alid exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"count of different airports\": compute the number of unique values of T2.dst_apid. 5) When counting destination airports: use T2.dst_apid as the counting key for distinct values, not all columns or rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'American Airlines';",
            "SELECT COUNT(DISTINCT T2.dst_apid) \nFROM airlines AS T1 \nJOIN routes AS T2 ON T1.alid = T2.alid \nWHERE T1.name = 'American Airlines'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT r.dst_apid) \nFROM routes r\nJOIN airlines a ON r.alid = a.alid\nWHERE a.name = 'American Airlines'"
        ]
    },
    "5309": {
        "db_id": "manufactory_1",
        "question": "What are the names and revenues of the companies with the highest revenues in each headquarter city?",
        "ground_truth": "SELECT name ,  max(revenue) ,  Headquarter FROM manufacturers GROUP BY Headquarter",
        "amends": [
            "Do select `max(revenue)` as an aggregate instead of individual `revenue` values, and use `Headquarter` instead of `headquarter_city`. Do change the FROM source to `manufacturers` instead of `companies`. Do remove the WHERE clause with subquery for maximum revenue instead of keeping it. Do add `GROUP BY Headquarter` instead of omitting grouping. Do remove ORDER BY instead of sorting by headquarter_city. The amended query now correctly groups by headquarters and shows maximum revenue per location, matching the intended behavior.",
            "Do select `name` and `max(revenue)` instead of omitting `name` and using `MAX(Revenue)` with alias `MaxRevenue`. Do include `Headquarter` in SELECT list instead of only grouping by it. Do use lowercase `max(revenue)` instead of uppercase `MAX(Revenue)` with different casing. The amended query now correctly includes all non-aggregated columns from GROUP BY in the SELECT clause and matches the right SQL's behavior.",
            "Do include `name` in the SELECT list instead of omitting it, and do reorder the columns to place `max(revenue)` before `Headquarter` instead of having `Headquarter` first. Do use lowercase table name `manufacturers` instead of `Manufacturers` for consistency. The amended query now correctly includes all non-aggregated columns from the GROUP BY clause in the SELECT list and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for companies with highest revenues per headquarter city: use the table \"manufacturers\" instead of \"companies\" as the data source. 2) When referring to headquarter city in the schema: use the exact column token \"Headquarter\" instead of \"headquarter_city\". 3) When calculating highest revenues per group: compute the maximum revenue value for each headquarter location using aggregate function max(revenue). 4) When grouping by headquarter location: include GROUP BY \"Headquarter\" to organize results by each city. 5) When showing results per headquarter city: remove any ORDER BY clause that sorts by headquarter city since grouping already organizes the output. 6) When finding maximum revenue per group: remove WHERE clauses with subqueries for maximum revenue and instead use aggregate grouping approach.",
            "1) When answering about \"companies with the highest revenues in each headquarter city\": make sure the output order: Headquarter, name, max(revenue). 2) When the question asks for \"names and revenues of companies\": include both the \"name\" column and the maximum \"revenue\" value in the results. 3) When the question mentions \"highest revenues in each headquarter city\": group by \"Headquarter\" and compute the maximum revenue per group using \"max(revenue)\". 4) When producing output for grouped results: include all grouping columns (\"Headquarter\") and aggregated columns (\"max(revenue)\") in the SELECT list.",
            "1) When answering about \"names and revenues of companies with highest revenues in each headquarter city\": make sure the output order: max(revenue) first, then Headquarter, then name. 2) When the question mentions \"companies\": \"companies\" actually means \"name in schema manufacturers\". 3) When the question asks for \"highest revenues in each headquarter city\": for each Headquarter value, find the maximum revenue value and include the corresponding company name. 4) When grouping by Headquarter: include all non-aggregated columns from the GROUP BY clause in the SELECT list. 5) When referring to the manufacturers table: use lowercase table name \"manufacturers\" instead of \"Manufacturers\" for consistency."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, revenue, headquarter_city \nFROM companies \nWHERE revenue = (SELECT MAX(revenue) FROM companies) \nORDER BY headquarter_city;",
            "SELECT Headquarter, MAX(Revenue) AS MaxRevenue FROM Manufacturers GROUP BY Headquarter;",
            "SELECT Headquarter, Name, max(revenue) FROM Manufacturers GROUP BY Headquarter",
            "SELECT name, max(revenue), Headquarter FROM manufacturers GROUP BY Headquarter"
        ],
        "rule_sql": [
            "SELECT Headquarter, Name, MAX(Revenue) FROM manufacturers GROUP BY Headquarter"
        ]
    },
    "6859": {
        "db_id": "flight_4",
        "question": "Find the number of routes for each source airport and the airport name.",
        "ground_truth": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name",
        "amends": [
            "Do add table `airports AS T1` and join it with `routes AS T2` on `T1.apid = T2.src_apid` instead of querying only the `routes` table. Do select `T1.name` instead of `source_airport` to get the airport name rather than the airport code. Do use `COUNT(*)` without an alias instead of aliasing it as `route_count`. Do group by `T1.name` instead of `source_airport` to aggregate by airport name rather than airport code. The amended query now correctly joins airport data to count routes by airport name rather than just counting routes by airport codes from the routes table alone.",
            "Do place `count(*)` before `T1.name` in the SELECT list instead of after it. Do remove the alias from `count(*)` instead of keeping it. The amended query now correctly matches the RIGHT_SQL's behavior with identical column ordering and aggregation."
        ],
        "rules": [
            "1) When answering about \"number of routes for each source airport and the airport name\": make sure the output order: T1.name, COUNT(*) 2) When the question mentions \"source airport\": \"source airport\" actually means \"T2.src_apid in schema\" which links to airport data 3) When combining T1 (airports) and T2 (routes) for shared entities: link rows where T1.apid = T2.src_apid exactly as shown in the amends; keep only matching pairs (inner match) 4) When the question asks for \"count of routes\": compute the number of rows using the canonical key from the routes table 5) When the question says \"per source airport\"/\"by source airport\": organize results by T1.name and compute requested aggregates per group 6) When producing output: do not reorder columns or grouping keys beyond what the amends and question require - output must show airport name first followed by route count",
            "1) When answering about \"number of routes for each source airport and airport name\": make sure the output order: count of routes first, then airport name. 2) When counting routes: compute the number of rows using the canonical key from the routes table. 3) When grouping by airport name: organize results by T1.name and compute the count per group. 4) When combining airports and routes tables: link rows where T1.apid = T2.src_apid and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT source_airport, COUNT(*) as route_count FROM routes GROUP BY source_airport;",
            "SELECT T1.name, COUNT(*) \nFROM airports AS T1 \nJOIN routes AS T2 ON T1.apid = T2.src_apid \nGROUP BY T1.name",
            "SELECT COUNT(*), T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid = T2.src_apid GROUP BY T1.name"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS route_count, airports.name AS airport_name\nFROM routes\nJOIN airports ON routes.src_apid = airports.apid\nGROUP BY airports.name\nORDER BY route_count DESC, airport_name;"
        ]
    },
    "3370": {
        "db_id": "sports_competition",
        "question": "What are the types of competition that have most 5 competitions for that type?",
        "ground_truth": "SELECT Competition_type FROM competition GROUP BY Competition_type HAVING COUNT(*)  <=  5",
        "amends": [
            "Do reference `Competition_type` instead of `type` and select only that column instead of including `competition_count`. Do use `COUNT(*) <= 5` in the HAVING clause instead of `competition_count = 5` and alias comparison. Do remove the `ORDER BY competition_count DESC` and `LIMIT 1` clauses instead of keeping them, as the query now returns all groups meeting the count threshold rather than just the top one. Do reference table `competition` instead of `competitions` with proper case sensitivity. The amended query now correctly returns all competition types with 5 or fewer competitions instead of only the type with exactly 5 competitions that has the highest count."
        ],
        "rules": [
            "1) When the question asks about \"types of competition\": use the exact column name \"Competition_type\" from table \"competition\" instead of \"type\". 2) When counting competitions per type: use COUNT(*) to count all rows in each group. 3) When filtering for groups with \"most 5 competitions\": use COUNT(*) <= 5 in the condition to include all types with 5 or fewer competitions. 4) When selecting output columns: include only \"Competition_type\" in the results, not the count value. 5) When the question does not specify ordering or limiting: do not include ORDER BY or LIMIT clauses in the query."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type, COUNT(*) as competition_count \nFROM competitions \nGROUP BY type \nHAVING competition_count = 5 \nORDER BY competition_count DESC \nLIMIT 1;",
            "SELECT Competition_type FROM competition GROUP BY Competition_type HAVING COUNT(*) <= 5"
        ],
        "rule_sql": [
            "SELECT Competition_type FROM competition GROUP BY Competition_type HAVING COUNT(*) <= 5"
        ]
    },
    "6468": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "Return the account details with the greatest value, as well as those that include the character 5.",
        "ground_truth": "SELECT max(Account_details) FROM Accounts UNION SELECT Account_details FROM Accounts WHERE Account_details LIKE \"%5%\"",
        "amends": [
            "Do use `SELECT max(Account_details)` instead of `SELECT *` and move the aggregate function from the WHERE clause to the SELECT list. Do remove the incorrect `WHERE account_value = MAX(account_value)` predicate instead of keeping it, as aggregates cannot be used directly in WHERE conditions. Do change the filter to `WHERE Account_details LIKE \"%5%\"` instead of `account_details LIKE '%5%'` while preserving the pattern matching logic. Do use `UNION` to combine the maximum value with filtered results instead of using OR conditions with incompatible expressions. Do specify explicit column selection `Account_details` instead of wildcard `*` to ensure consistent result structure. The amended query now correctly retrieves both the maximum account details value and records containing '5' through proper UNION operation instead of the invalid aggregate comparison in WHERE clause."
        ],
        "rules": [
            "1) When answering about \"account details with the greatest value\": use max(\"Account_details\") instead of wildcard selection and move aggregate functions from WHERE clause to SELECT list. 2) When filtering for records containing the character 5: use \"Account_details\" LIKE \"%5%\" with exact column name and pattern matching. 3) When combining results from maximum value and filtered records: use UNION operation instead of OR conditions with incompatible expressions. 4) When selecting columns: use explicit column selection \"Account_details\" instead of wildcard * to ensure consistent result structure."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM accounts WHERE account_value = MAX(account_value) OR account_details LIKE '%5%';",
            "SELECT Account_details FROM Accounts WHERE Account_details = (SELECT MAX(Account_details) FROM Accounts)\nUNION\nSELECT Account_details FROM Accounts WHERE Account_details LIKE '%5%'"
        ],
        "rule_sql": [
            "SELECT Account_details FROM Accounts WHERE Account_details = (SELECT MAX(Account_details) FROM Accounts)\nUNION\nSELECT Account_details FROM Accounts WHERE Account_details LIKE '%5%';"
        ]
    },
    "3014": {
        "db_id": "loan_1",
        "question": "Find the average number of customers cross all banks.",
        "ground_truth": "SELECT avg(no_of_customers) FROM bank",
        "amends": [
            "Do reference the table as `bank` instead of `banks` and use the column name `no_of_customers` instead of `customer_count` in the aggregate function, while maintaining the same `AVG` function to calculate the average value. The amended query now correctly references the actual table and column names to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for average number of customers across banks: use the exact table name \"bank\" and column name \"no_of_customers\" to compute the average. 2) When referring to customer count in the schema: \"customer_count\" in the question actually means \"no_of_customers\" in the bank table. 3) When computing average across all banks: use the AVG function on the \"no_of_customers\" column from the \"bank\" table without any grouping or filtering."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(customer_count) FROM banks;",
            "SELECT AVG(no_of_customers) FROM bank;"
        ],
        "rule_sql": [
            "SELECT AVG(no_of_customers) FROM bank;"
        ]
    },
    "1099": {
        "db_id": "match_season",
        "question": "What are the three colleges from which the most players are from?",
        "ground_truth": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3",
        "amends": [
            "Do select `College` instead of `college` and `player_count`. Do use `match_season` as the source table instead of `players`. Do remove the explicit `COUNT(*)` alias instead of keeping it as `player_count`. Do order by `count(*)` directly instead of ordering by the aliased `player_count`. The amended query now correctly selects from the appropriate table and orders by the aggregate function directly without unnecessary aliasing, matching the intended behavior.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, as the query only needs to return the College names. Do keep the `GROUP BY College` clause to group by college instead of omitting it. Do maintain the `ORDER BY count(*) DESC` to order by the count of records per college instead of changing it. Do preserve the `LIMIT 3` to return only the top three colleges instead of modifying it. The amended query now correctly returns only the college names with the highest number of records, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"colleges with the most players\": make sure the output order: College, count(*) 2) When the question mentions \"colleges\": \"colleges\" actually means \"College in schema\" 3) When the question mentions \"three colleges\" or \"most players\": rank rows by count(*) in descending direction and keep the first 3 rows. 4) When the question asks for \"count of players\": compute the number of rows using the canonical key from match_season table. 5) When the question says \"from which the most players are from\": organize results by College and compute count per group.",
            "1) When answering about \"colleges from which the most players are from\": make sure the output order: College. 2) When the question asks for \"three colleges\": rank rows by count of players in descending order and keep the first 3 rows. 3) When the question asks for \"count of players\": compute the number of rows using the College column as the grouping key. 4) When producing output: return only the College column names without including the count values in the final results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT college, COUNT(*) as player_count FROM players GROUP BY college ORDER BY player_count DESC LIMIT 3;",
            "SELECT College, COUNT(*) FROM match_season GROUP BY College ORDER BY COUNT(*) DESC LIMIT 3;",
            "SELECT College FROM match_season GROUP BY College ORDER BY COUNT(*) DESC LIMIT 3"
        ],
        "rule_sql": [
            "SELECT College FROM match_season GROUP BY College ORDER BY COUNT(*) DESC LIMIT 3;"
        ]
    },
    "6475": {
        "db_id": "scientist_1",
        "question": "Find the number of distinct projects.",
        "ground_truth": "SELECT count(DISTINCT name) FROM projects",
        "amends": [
            "Do count `DISTINCT name` instead of counting all `project` values without distinct. Do use the `name` column for counting instead of the `project` column. The amended query now correctly counts unique project names rather than all project entries, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"distinct projects\": compute the number of unique values of the exact token \"name\" from the projects table. 2) When counting distinct entities: use DISTINCT on the canonical identifier column (\"name\") rather than counting all values without distinct."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(project) FROM projects",
            "SELECT COUNT(DISTINCT Name) FROM Projects;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Name) FROM Projects;"
        ]
    },
    "3975": {
        "db_id": "hospital_1",
        "question": "Which physician was trained in the procedure that costs the most.",
        "ground_truth": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1",
        "amends": [
            "Do reference the physician name column as `T1.name` instead of `p.Name`. Do use table aliases `T1`, `T2`, and `T3` instead of `p`, `t`, and `pr`. Do join `procedures` as `T3` with the condition `T3.code = T2.treatment` instead of `t.Treatment = pr.Code`. Do order by `T3.cost` instead of `pr.Cost`. The amended query now correctly retrieves the physician with the most expensive procedure by fixing the join direction and maintaining the same logical behavior."
        ],
        "rules": [
            "1) When answering about \"physician trained in procedure that costs the most\": make sure the output order: T1.name. 2) When combining Physicians as T1 and Trained_In as T2: link rows where T1.EmployeeID = T2.Physician and keep only matching pairs (inner match). 3) When combining T2 and procedures as T3: link rows where T3.code = T2.treatment and keep only matching pairs (inner match). 4) When the question mentions \"costs the most\": rank rows by T3.cost in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.Name \nFROM Physicians p\nJOIN Trained_In t ON p.EmployeeID = t.Physician\nJOIN Procedures pr ON t.Treatment = pr.Code\nORDER BY pr.Cost DESC\nLIMIT 1;",
            "SELECT T1.Name\nFROM Physician T1\nJOIN Trained_In T2 ON T1.EmployeeID = T2.Physician\nJOIN Procedures T3 ON T3.Code = T2.Treatment\nORDER BY T3.Cost DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Name\nFROM Physician AS T1\nINNER JOIN Trained_In AS T2 ON T1.EmployeeID = T2.Physician\nINNER JOIN Procedures AS T3 ON T3.Code = T2.Treatment\nORDER BY T3.Cost DESC\nLIMIT 1;"
        ]
    },
    "4926": {
        "db_id": "store_product",
        "question": "What is the average pages per minute color?",
        "ground_truth": "SELECT avg(pages_per_minute_color) FROM product",
        "amends": [
            "Do reference the `product` table instead of the `books` table. Do calculate the average of the `pages_per_minute_color` column directly instead of computing `AVG(pages) / AVG(minutes)` with a division of averages. Do remove the `WHERE color = 'color'` filter instead of keeping it, as the filtering logic appears to be handled differently in the target table structure. The amended query now correctly calculates the average pages per minute from the pre-computed metric in the product table, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"average pages per minute color\": use the \"product\" table instead of the \"books\" table. 2) When calculating the average pages per minute color: compute the average of the \"pages_per_minute_color\" column directly instead of dividing averages of separate columns. 3) When filtering for color information: do not apply a WHERE color = 'color' filter as the filtering logic is handled differently in the table structure."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(pages) / AVG(minutes) AS avg_pages_per_minute FROM books WHERE color = 'color';",
            "SELECT AVG(pages_per_minute_color) FROM product;"
        ],
        "rule_sql": [
            "SELECT AVG(pages_per_minute_color) FROM product;"
        ]
    },
    "4565": {
        "db_id": "company_office",
        "question": "Show the name of the building that has the most company offices.",
        "ground_truth": "SELECT T2.name FROM Office_locations AS T1 JOIN buildings AS T2 ON T1.building_id  =  T2.id JOIN Companies AS T3 ON T1.company_id  =  T3.id GROUP BY T1.building_id ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.name` from the `buildings` table instead of `building_name` from just `buildings`. Do add `JOIN` operations with `Office_locations AS T1` and `Companies AS T3` instead of omitting these tables. Do use `ON T1.building_id = T2.id` and `ON T1.company_id = T3.id` for proper table relationships instead of missing join conditions. Do add `GROUP BY T1.building_id` to aggregate by building instead of omitting grouping. Do order by `COUNT(*)` instead of `COUNT(company_offices)` since company_offices is not a valid column reference. The amended query now correctly joins the necessary tables, groups by building_id, and counts office locations per building to find the building with the most companies, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"the building that has the most company offices\": make sure the output order: T2.name. 2) When the question mentions \"building name\": \"building name\" actually means \"T2.name in schema\". 3) When combining T1 and T2 for shared entities: link rows where T1.building_id = T2.id; keep only matching pairs (inner match). 4) When combining T1 and T3 for shared entities: link rows where T1.company_id = T3.id; keep only matching pairs (inner match). 5) When the question asks for \"count of company offices per building\": compute the number of rows using T1.building_id as the grouping key and count all rows per group. 6) When the question mentions \"most\" or \"highest\": rank rows by COUNT(*) in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT building_name FROM buildings ORDER BY COUNT(company_offices) DESC LIMIT 1;",
            "SELECT T2.name \nFROM Office_locations AS T1\nJOIN buildings AS T2 ON T1.building_id = T2.id\nJOIN Companies AS T3 ON T1.company_id = T3.id\nGROUP BY T1.building_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.name\nFROM Office_locations T1\nINNER JOIN buildings T2 ON T1.building_id = T2.id\nGROUP BY T1.building_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "3744": {
        "db_id": "program_share",
        "question": "Find the names of the channels that are broadcast in the morning.",
        "ground_truth": "SELECT t1.name FROM channel AS t1 JOIN broadcast AS t2 ON t1.channel_id  =  t2.channel_id WHERE t2.time_of_day  =  'Morning'",
        "amends": [
            "Do select `t1.name` from the `channel` table instead of `channel_name` from the `channels` table. Do join with the `broadcast` table on `t1.channel_id = t2.channel_id` instead of querying a single table. Do filter on `t2.time_of_day = 'Morning'` instead of `broadcast_time = 'morning'` to use the correct column name and case-sensitive value. The amended query now correctly joins related tables and matches the intended behavior."
        ],
        "rules": [
            "1) When answering about \"names of channels\": make sure the output order: t1.name from the channel table. 2) When the question mentions \"channels that are broadcast in the morning\": join the channel table (T1) with the broadcast table (T2) where T1.channel_id = T2.channel_id. 3) When filtering for morning broadcasts: use T2.time_of_day = 'Morning' with exact case-sensitive value 'Morning' instead of 'morning'. 4) When combining tables for shared entities: link rows where T1.channel_id = T2.channel_id and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT channel_name FROM channels WHERE broadcast_time = 'morning';",
            "SELECT t1.Name FROM channel t1 JOIN broadcast t2 ON t1.Channel_ID = t2.Channel_ID WHERE t2.Time_of_day = 'Morning'"
        ],
        "rule_sql": [
            "SELECT t1.Name FROM channel t1 JOIN broadcast t2 ON t1.Channel_ID = t2.Channel_ID WHERE t2.Time_of_day = 'Morning'"
        ]
    },
    "5705": {
        "db_id": "dorm_1",
        "question": "What is the name of each dorm that has a TV Lounge but no study rooms?",
        "ground_truth": "SELECT T1.dorm_name FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid JOIN dorm_amenity AS T3 ON T2.amenid  =  T3.amenid WHERE T3.amenity_name  =  'TV Lounge' EXCEPT SELECT T1.dorm_name FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid JOIN dorm_amenity AS T3 ON T2.amenid  =  T3.amenid WHERE T3.amenity_name  =  'Study Room'",
        "amends": [
            "Do use explicit table aliases `T1.dorm_name` instead of unqualified `dorm_name`. Do change the FROM clause to join `dorm AS T1` with `has_amenity AS T2` on `T1.dormid = T2.dormid` and then join `dorm_amenity AS T3` on `T2.amenid = T3.amenid` instead of querying a single `dorms` table. Do replace the WHERE filters with a subquery structure using `EXCEPT` instead of direct boolean conditions. Do filter for `T3.amenity_name = 'TV Lounge'` in the first part and exclude dorms that have `T3.amenity_name = 'Study Room'` in the second part instead of using `has_tv_lounge = 1 AND has_study_rooms = 1`. The amended query now correctly identifies dorms that have TV lounges but lack study rooms, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about dorms with TV Lounge but no study rooms: use explicit table aliases with T1 for dorm table, T2 for has_amenity table, and T3 for dorm_amenity table. 2) When combining dorm information with amenities: link T1 and T2 where T1.dormid = T2.dormid, then link T2 and T3 where T2.amenid = T3.amenid, keeping only matching pairs (inner match). 3) When filtering for TV Lounge amenity: include only rows where T3.amenity_name = 'TV Lounge' exactly. 4) When excluding study rooms: remove dorms that have any row where T3.amenity_name = 'Study Room' exactly. 5) When selecting output columns: return T1.dorm_name as the dorm name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT dorm_name FROM dorms WHERE has_tv_lounge = 1 AND has_study_rooms = 1;",
            "SELECT T1.dorm_name\nFROM dorm AS T1\nJOIN has_amenity AS T2 ON T1.dormid = T2.dormid\nJOIN dorm_amenity AS T3 ON T2.amenid = T3.amenid\nWHERE T3.amenity_name = 'TV Lounge'\nEXCEPT\nSELECT T1.dorm_name\nFROM dorm AS T1\nJOIN has_amenity AS T2 ON T1.dormid = T2.dormid\nJOIN dorm_amenity AS T3 ON T2.amenid = T3.amenid\nWHERE T3.amenity_name = 'Study Room'"
        ],
        "rule_sql": [
            "SELECT T1.dorm_name\nFROM Dorm T1\nINNER JOIN Has_amenity T2 ON T1.dormid = T2.dormid\nINNER JOIN Dorm_amenity T3 ON T2.amenid = T3.amenid\nWHERE T3.amenity_name = 'TV Lounge'\nAND T1.dormid NOT IN (\n    SELECT T1.dormid\n    FROM Dorm T1\n    INNER JOIN Has_amenity T2 ON T1.dormid = T2.dormid\n    INNER JOIN Dorm_amenity T3 ON T2.amenid = T3.amenid\n    WHERE T3.amenity_name = 'Study Room'\n)\nGROUP BY T1.dorm_name"
        ]
    },
    "3772": {
        "db_id": "e_learning",
        "question": "What are the addresses of the course authors or tutors with personal name \"Cathrine\"",
        "ground_truth": "SELECT address_line_1 FROM Course_Authors_and_Tutors WHERE personal_name\t =  \"Cathrine\"",
        "amends": [
            "Do select `address_line_1` instead of `address` to reference the correct column name. Do use `personal_name` instead of `name` to reference the correct name column. Do use double quotes `\"Cathrine\"` instead of single quotes `'Cathrine'` for string literal syntax. Do reference table `Course_Authors_and_Tutors` instead of `authors` to query from the correct table. The amended query now correctly retrieves the address information for the specified author from the appropriate table structure."
        ],
        "rules": [
            "1) When the question asks for addresses of course authors or tutors: use table \"Course_Authors_and_Tutors\" instead of \"authors\" to query from the correct table. 2) When selecting address information: use column \"address_line_1\" instead of \"address\" to reference the correct column name. 3) When filtering by personal name: use column \"personal_name\" instead of \"name\" to reference the correct name column. 4) When specifying the literal value \"Cathrine\": use double quotes \"Cathrine\" instead of single quotes for string literal syntax."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT address FROM authors WHERE name = 'Cathrine';",
            "SELECT address_line_1 FROM Course_Authors_and_Tutors WHERE personal_name = \"Cathrine\""
        ],
        "rule_sql": [
            "SELECT address_line_1 FROM Course_Authors_and_Tutors WHERE personal_name = \"Cathrine\""
        ]
    },
    "3835": {
        "db_id": "e_learning",
        "question": "On what dates did the student with family name \"Zieme\" and personal name \"Bernie\" enroll in and complete the courses?",
        "ground_truth": "SELECT T1.date_of_enrolment ,  T1.date_of_completion FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id WHERE T2.family_name  =  \"Zieme\" AND T2.personal_name  =  \"Bernie\"",
        "amends": [
            "Do select `T1.date_of_enrolment` and `T1.date_of_completion` from the `Student_Course_Enrolment` table instead of `enrollment_date` and `completion_date` from the `students` table. Do add a `JOIN` between `Student_Course_Enrolment AS T1` and `Students AS T2` on `T1.student_id = T2.student_id` instead of querying only the `students` table. Do reference the filter conditions on `T2.family_name = \"Zieme\"` and `T2.personal_name = \"Bernie\"` from the joined `Students` table instead of applying them directly to the main table. The amended query now correctly retrieves enrollment and completion dates from the enrollment table while filtering by student names from the student table through the proper join relationship."
        ],
        "rules": [
            "1) When answering about enrollment and completion dates for a specific student: select T1.date_of_enrolment and T1.date_of_completion from the Student_Course_Enrolment table as T1. 2) When filtering by student family name \"Zieme\" and personal name \"Bernie\": join Students table as T2 where T2.family_name = \"Zieme\" and T2.personal_name = \"Bernie\". 3) When combining Student_Course_Enrolment and Students tables: link rows where T1.student_id = T2.student_id and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT enrollment_date, completion_date FROM students WHERE family_name = 'Zieme' AND personal_name = 'Bernie';",
            "SELECT T1.date_of_enrolment, T1.date_of_completion \nFROM Student_Course_Enrolment AS T1\nJOIN Students AS T2 ON T1.student_id = T2.student_id\nWHERE T2.family_name = 'Zieme' AND T2.personal_name = 'Bernie'"
        ],
        "rule_sql": [
            "SELECT T1.date_of_enrolment, T1.date_of_completion \nFROM Student_Course_Enrolment AS T1\nINNER JOIN Students AS T2 ON T1.student_id = T2.student_id\nWHERE T2.family_name = 'Zieme' AND T2.personal_name = 'Bernie'"
        ]
    },
    "6332": {
        "db_id": "e_government",
        "question": "How many cities are there in state \"Colorado\"?",
        "ground_truth": "SELECT count(*) FROM addresses WHERE state_province_county  =  \"Colorado\"",
        "amends": [
            "Do query the `addresses` table instead of the `cities` table. Do filter on `state_province_county = 'Colorado'` instead of `state = 'California'` to target the correct geographic data. The amended query now correctly counts addresses in Colorado rather than cities in California, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about cities in a specific state: query the \"addresses\" table instead of the \"cities\" table. 2) When filtering for state \"Colorado\": use the condition \"state_province_county = 'Colorado'\" exactly as specified, not \"state = 'California'\". 3) When counting addresses in a geographic region: count all rows from the \"addresses\" table that match the specified state condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities WHERE state = 'California';",
            "SELECT COUNT(DISTINCT town_city) FROM Addresses WHERE state_province_county = 'Colorado';"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT town_city) FROM Addresses WHERE state_province_county = 'Colorado';"
        ]
    },
    "6001": {
        "db_id": "game_1",
        "question": "How many students play sports?",
        "ground_truth": "SELECT count(DISTINCT StuID) FROM Sportsinfo",
        "amends": [
            "Do select `count(DISTINCT StuID)` instead of `COUNT(*)` to count unique student identifiers rather than all rows. Do query from `Sportsinfo` table instead of `students` table to access the appropriate data source. Do remove the `WHERE sports = 'no'` filter instead of keeping it to include all sports participation records rather than filtering for non-participants. The amended query now correctly counts distinct students from the Sportsinfo table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting students who play sports: use the \"Sportsinfo\" table instead of the \"students\" table to access sports participation data. 2) When counting distinct students: count unique values of \"StuID\" instead of counting all rows. 3) When including all sports participants: do not apply any filter condition like sports = 'no' to ensure all participation records are included."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE sports = 'no';",
            "SELECT COUNT(DISTINCT StuID) FROM SportsInfo;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT StuID) FROM SportsInfo;"
        ]
    },
    "1283": {
        "db_id": "game_injury",
        "question": "Find the id and name of the stadium where the largest number of injury accidents occurred.",
        "ground_truth": "SELECT T1.id ,  T1.name FROM stadium AS T1 JOIN game AS T2 ON T1.id  =  T2.stadium_id JOIN injury_accident AS T3 ON T2.id  =  T3.game_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.id` and `T1.name` with table aliases instead of `stadium_id` and `name` without aliases. Do join `stadium AS T1` with `game AS T2` on `T1.id = T2.stadium_id` and then join `injury_accident AS T3` on `T2.id = T3.game_id` instead of querying only the `stadiums` table. Do add `GROUP BY T1.id` to aggregate by stadium instead of omitting grouping. Do order by `count(*) DESC` to sort by the number of injury accidents instead of by `injury_count DESC`. The amended query now correctly identifies the stadium with the most injury accidents by joining relevant tables and counting incidents, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"the largest number of injury accidents\": rank stadiums by count of injury accidents in descending order and keep the first 1 row. 2) When the question mentions \"id and name of the stadium\": select T1.id and T1.name as output columns. 3) When combining stadium (T1) with game (T2): link rows where T1.id = T2.stadium_id and keep only matching pairs (inner match). 4) When combining game (T2) with injury_accident (T3): link rows where T2.id = T3.game_id and keep only matching pairs (inner match). 5) When counting injury accidents per stadium: group by T1.id and compute count(*) for each stadium. 6) When ordering results: sort by count(*) in descending order to find the stadium with the largest number of injury accidents."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT stadium_id, name FROM stadiums ORDER BY injury_count DESC LIMIT 1;",
            "SELECT T1.id, T1.name\nFROM stadium AS T1\nJOIN game AS T2 ON T1.id = T2.stadium_id\nJOIN injury_accident AS T3 ON T2.id = T3.game_id\nGROUP BY T1.id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.id, T1.name\nFROM stadium T1\nINNER JOIN game T2 ON T1.id = T2.stadium_id\nINNER JOIN injury_accident T3 ON T2.id = T3.game_id\nGROUP BY T1.id, T1.name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "6239": {
        "db_id": "ship_1",
        "question": "What are the ranks of captains that are both in the Cutter and Armed schooner classes?",
        "ground_truth": "SELECT rank FROM captain WHERE CLASS  =  'Cutter' INTERSECT SELECT rank FROM captain WHERE CLASS  =  'Armed schooner'",
        "amends": [
            "Do use `INTERSECT` between two separate queries instead of `OR` with `DISTINCT` to find ranks that appear in both classes. Do query from `captain` table instead of `captains` table. Do use separate `SELECT rank FROM captain WHERE CLASS = 'Cutter'` and `SELECT rank FROM captain WHERE CLASS = 'Armed schooner'` clauses instead of a single query with `OR` condition. Do remove `DISTINCT` modifier since `INTERSECT` inherently returns unique values from the intersection. The amended query now correctly identifies ranks that exist for both vessel classes rather than ranks that exist for either class, matching the RIGHT_SQL's set intersection behavior."
        ],
        "rules": [
            "1) When the question asks for ranks that appear in both 'Cutter' and 'Armed schooner' classes: use INTERSECT between two separate queries instead of OR with DISTINCT. 2) When querying from the captain table: use the exact table name 'captain' instead of 'captains'. 3) When filtering for the 'Cutter' class: use the exact literal 'Cutter' in the condition. 4) When filtering for the 'Armed schooner' class: use the exact literal 'Armed schooner' in the condition. 5) When using INTERSECT: remove the DISTINCT modifier since INTERSECT inherently returns unique values from the intersection."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT rank FROM captains WHERE class = 'Cutter' OR class = 'Armed schooner';",
            "SELECT rank FROM captain WHERE Class = 'Cutter' INTERSECT SELECT rank FROM captain WHERE Class = 'Armed schooner'"
        ],
        "rule_sql": [
            "SELECT Rank FROM captain WHERE Class = 'Cutter' INTERSECT SELECT Rank FROM captain WHERE Class = 'Armed schooner'"
        ]
    },
    "2787": {
        "db_id": "election",
        "question": "Which counties have two or more delegates? Give me the county names.",
        "ground_truth": "SELECT T1.County_name FROM county AS T1 JOIN election AS T2 ON T1.County_id  =  T2.District GROUP BY T1.County_id HAVING COUNT(*)  >=  2",
        "amends": [
            "Do select `T1.County_name` from the `county` table instead of `county_name` from `delegates`. Do join `election AS T2` on `T1.County_id = T2.District` instead of querying only the `delegates` table. Do group by `T1.County_id` instead of `county_name`. Do use `COUNT(*)` instead of `COUNT(delegate_id)` while maintaining the same `HAVING COUNT(*) >= 2` condition. The amended query now correctly joins county and election tables to find counties with multiple election entries, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"counties with two or more delegates\": make sure the output order: T1.County_name\n2) When the question mentions \"counties\": \"counties\" actually means \"T1.County_name in county table\"\n3) When combining T1 (county) and T2 (election) for shared entities: link rows where T1.County_id = T2.District exactly as shown in the amends; keep only matching pairs (inner match)\n4) When the question asks for \"count of delegates\": compute the number of rows using COUNT(*) while maintaining the condition COUNT(*) >= 2\n5) When the question says \"by county\": organize results by T1.County_id and compute requested aggregates per group"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT county_name FROM delegates GROUP BY county_name HAVING COUNT(delegate_id) >= 2;",
            "SELECT T1.County_name \nFROM county AS T1 \nJOIN election AS T2 ON T1.County_Id = T2.District \nGROUP BY T1.County_Id \nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T1.County_name\nFROM county T1\nJOIN election T2 ON T1.County_Id = T2.District\nGROUP BY T1.County_Id, T1.County_name\nHAVING COUNT(*) >= 2\nORDER BY T1.County_name"
        ]
    },
    "2977": {
        "db_id": "sakila_1",
        "question": "Give the full name and staff id of the staff who has handled the fewest payments.",
        "ground_truth": "SELECT T1.first_name ,  T1.last_name ,  T1.staff_id FROM staff AS T1 JOIN payment AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T1.staff_id ORDER BY count(*) ASC LIMIT 1",
        "amends": [
            "Do add `payment` table with `JOIN` on `staff_id` instead of omitting it. Do add `GROUP BY staff_id` instead of missing aggregation context. Do change `ORDER BY COUNT(payment_id) DESC` to `ORDER BY count(*) ASC` instead of incorrect aggregate usage without grouping. Do include all selected columns in `GROUP BY` instead of having non-aggregated columns without proper grouping. Do use `count(*)` instead of `COUNT(payment_id)` for proper aggregation. The amended query now correctly finds the staff member with the fewest payments by properly joining tables, grouping results, and using appropriate aggregation."
        ],
        "rules": [
            "1) When answering about \"staff who has handled the fewest payments\": make sure to combine the staff table with the payment table using an inner match where staff.staff_id equals payment.staff_id. 2) When counting payments per staff member: compute the number of rows using count(*) for each staff_id group. 3) When finding the staff with the fewest payments: order the results by the payment count in ascending order and keep only the first row. 4) When grouping by staff_id: include all selected columns (staff_id, first_name, last_name) in the GROUP BY clause to ensure proper aggregation context. 5) When outputting results: return the staff_id, first_name, and last_name columns in that order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT staff_id, first_name, last_name FROM staff ORDER BY COUNT(payment_id) DESC LIMIT 1;",
            "SELECT s.staff_id, s.first_name, s.last_name\nFROM staff s\nJOIN payment p ON s.staff_id = p.staff_id\nGROUP BY s.staff_id, s.first_name, s.last_name\nORDER BY count(*) ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT s.staff_id, s.first_name, s.last_name\nFROM staff s\nINNER JOIN payment p ON s.staff_id = p.staff_id\nGROUP BY s.staff_id, s.first_name, s.last_name\nORDER BY COUNT(*) ASC\nLIMIT 1;"
        ]
    },
    "4424": {
        "db_id": "network_2",
        "question": "What is average age of male for different job title?",
        "ground_truth": "SELECT avg(age) ,  job FROM Person WHERE gender  =  'male' GROUP BY job",
        "amends": [
            "Do select `avg(age)` without an alias instead of `AVG(age) as average_age`, and do select `job` instead of `job_title`. Do use table `Person` instead of `employees` as the FROM source. Do group by `job` instead of `gender` to get average age per job rather than per gender. The amended query now correctly calculates average age by job for male individuals.",
            "Do place `avg(age)` before `job` in the SELECT list instead of having `job` first, and do remove the space between `avg` and `(age)` instead of including it. Do keep the same FROM source, WHERE filter on `gender = 'male'`, and GROUP BY clause unchanged. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [
            "1) When the question asks for average age of males by different job title: use table \"Person\" as the base table (T1). 2) When filtering for male individuals: use condition T1.gender = 'male' with exact literal 'male'. 3) When grouping by job title: group by the exact column token \"job\" from table T1. 4) When calculating average age: compute avg(age) without an alias. 5) When selecting output columns: output \"job\" first, then avg(age) in that order.",
            "1) When the question asks for \"average age of male for different job title\": make sure the output order is average age first, then job title. 2) When computing average age: use the exact token \"avg(age)\" without any space between \"avg\" and \"(age)\". 3) When filtering for male gender: use the exact literal 'male' with the exact token \"gender = 'male'\". 4) When grouping by job title: use the exact token \"job\" for grouping."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT job_title, AVG(age) as average_age FROM employees WHERE gender = 'male' GROUP BY gender;",
            "SELECT job, avg(age) FROM Person WHERE gender = 'male' GROUP BY job",
            "SELECT avg(age), job FROM Person WHERE gender = 'male' GROUP BY job"
        ],
        "rule_sql": [
            "SELECT job, avg(age) FROM Person WHERE gender = 'male' GROUP BY job"
        ]
    },
    "949": {
        "db_id": "medicine_enzyme_interaction",
        "question": "What are the ids and names of the medicine that can interact with two or more enzymes?",
        "ground_truth": "SELECT T1.id ,  T1.Name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id GROUP BY T1.id HAVING count(*)  >=  2",
        "amends": [
            "Do select `T1.id` and `T1.Name` instead of `m.id` and `m.name`. Do join `medicine_enzyme_interaction AS T2` instead of `interacts i`. Do use `T2.medicine_id = T1.id` as the join condition instead of `m.id = i.medicine_id`. Do group by only `T1.id` instead of both `m.id` and `m.name`. Do use `count(*) >= 2` instead of `COUNT(DISTINCT i.enzyme_id) >= 1`. The amended query now correctly counts interactions from the medicine_enzyme_interaction table and requires at least 2 interactions instead of 1."
        ],
        "rules": [
            "1) When selecting medicine information: use T1.id and T1.Name as output columns 2) When joining medicine with enzyme interactions: use medicine_enzyme_interaction AS T2 and link using T2.medicine_id = T1.id 3) When grouping medicine records: group by only T1.id instead of both id and name 4) When counting enzyme interactions per medicine: use count(*) >= 2 to require at least 2 interactions instead of 1 5) When answering about medicines that interact with two or more enzymes: make sure the output order: T1.id, T1.Name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.id, m.name FROM medicine m JOIN interacts i ON m.id = i.medicine_id GROUP BY m.id, m.name HAVING COUNT(DISTINCT i.enzyme_id) >= 1",
            "SELECT T1.id, T1.name\nFROM medicine AS T1\nJOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id = T1.id\nGROUP BY T1.id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T1.id, T1.name\nFROM medicine AS T1\nJOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id = T1.id\nGROUP BY T1.id\nHAVING COUNT(*) >= 2\nORDER BY T1.id, T1.name"
        ]
    },
    "5168": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "What is the product ID of the most frequently ordered item on invoices?",
        "ground_truth": "SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select `Product_ID` instead of `ProductID` and use `GROUP BY Product_ID` with `ORDER BY COUNT(*) DESC` instead of ordering by `Quantity DESC` without aggregation. Do add the aggregate function `COUNT(*)` in the ORDER BY clause instead of referencing the non-aggregated column `Quantity`. Do remove the direct column reference from ORDER BY and instead order by the count of records per product group. The amended query now correctly identifies the product with the highest number of invoice occurrences rather than simply the product from the invoice with the largest quantity, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"most frequently ordered item\": group records by the exact token \"Product_ID\" and count the number of occurrences per group. 2) When counting occurrences of an entity: use the canonical counting method with COUNT(*) to determine frequency. 3) When identifying the most frequent item: order the results by the count in descending direction and take only the first row. 4) When selecting output columns: return the exact token \"Product_ID\" from the grouped results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT ProductID FROM Invoices ORDER BY Quantity DESC LIMIT 1;",
            "SELECT Product_ID\nFROM Invoices\nGROUP BY Product_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Product_ID\nFROM Invoices\nGROUP BY Product_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "2021": {
        "db_id": "gas_company",
        "question": "Show all headquarters without a company in banking industry.",
        "ground_truth": "SELECT headquarters FROM company EXCEPT SELECT headquarters FROM company WHERE main_industry  =  'Banking'",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` subquery. Do reference `headquarters` column specifically instead of selecting all columns with `*`. Do use `main_industry = 'Banking'` filter instead of `industry = 'banking'` with different column name and case sensitivity. Do query from `company` table instead of `headquarters` and `companies` tables. Do remove the subquery correlation through `company_id` and `id` instead of maintaining it. The amended query now correctly returns headquarters from companies excluding those in the Banking industry using proper set semantics."
        ],
        "rules": [
            "1) When the question asks to show headquarters without companies in banking industry: use EXCEPT set operation instead of NOT IN subquery. 2) When selecting from headquarters table: reference the \"headquarters\" column specifically instead of selecting all columns with *. 3) When filtering for banking industry: use main_industry = 'Banking' with exact case instead of industry = 'banking'. 4) When querying company data: use the \"company\" table instead of \"headquarters\" and \"companies\" tables. 5) When combining company and headquarters data: remove the subquery correlation through company_id and id columns and use proper set semantics."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM headquarters WHERE company_id NOT IN (SELECT id FROM companies WHERE industry = 'banking');",
            "SELECT Headquarters FROM company EXCEPT SELECT Headquarters FROM company WHERE Main_Industry = 'Banking'"
        ],
        "rule_sql": [
            "SELECT Headquarters FROM company\nEXCEPT\nSELECT Headquarters FROM company WHERE Main_Industry = 'Banking'"
        ]
    },
    "5227": {
        "db_id": "music_2",
        "question": "What are the types of vocals used in the song \"Demon Kitty Rag\"?",
        "ground_truth": "SELECT count(*) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Demon Kitty Rag\"",
        "amends": [
            "Do `count(*)` instead of `vocal_type` in the SELECT list. Do join `vocals AS T1` with `songs AS T2` on `T1.songid = T2.songid` instead of querying only the `songs` table. Do keep the WHERE filter on `title = 'Demon Kitty Rag'` unchanged. The amended query now correctly counts vocal entries for the specified song instead of attempting to select vocal types from a table that doesn't contain them, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"types of vocals used in a song\": make sure the output order: count of vocal entries\n2) When the question mentions \"song title 'Demon Kitty Rag'\": use exact literal 'Demon Kitty Rag' in the WHERE condition on T2.title\n3) When combining vocals table (T1) and songs table (T2): link rows where T1.songid = T2.songid and keep only matching pairs (inner match)\n4) When counting vocal entries for a song: compute the number of rows using count(*)"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT vocal_type FROM songs WHERE title = 'Demon Kitty Rag';",
            "SELECT count(*) FROM vocals AS T1 JOIN songs AS T2 ON T1.SongId = T2.SongId WHERE T2.Title = 'Demon Kitty Rag'"
        ],
        "rule_sql": [
            "SELECT Type, COUNT(*) AS Count FROM Vocals JOIN Songs ON Vocals.SongId = Songs.SongId WHERE Songs.Title = 'Demon Kitty Rag' GROUP BY Type ORDER BY Count;"
        ]
    },
    "4967": {
        "db_id": "soccer_2",
        "question": "What is the average, maximum, and minimum for the number of hours spent training?",
        "ground_truth": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player",
        "amends": [
            "Do use column names `HS` instead of `hours_training` for all aggregate functions. Do reference table `Player` instead of `training_data` as the data source. Do remove the `WHERE hours_training > 100` filter instead of keeping it, as the right query performs calculations on the entire dataset without filtering. The amended query now correctly calculates average, maximum, and minimum values from the HS column across all records in the Player table."
        ],
        "rules": [
            "1) When answering about \"average, maximum, and minimum for the number of hours spent training\": use column \"HS\" from table \"Player\" for all aggregate calculations. 2) When the question mentions \"hours spent training\": \"hours spent training\" actually means \"HS\" in the Player table schema. 3) When performing aggregate calculations on the entire dataset: do not apply any filtering conditions and include all records from the Player table. 4) When computing average, maximum, and minimum values: calculate AVG(\"HS\"), MAX(\"HS\"), and MIN(\"HS\") respectively without any WHERE clause restrictions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(hours_training), MAX(hours_training), MIN(hours_training) FROM training_data WHERE hours_training > 100",
            "SELECT AVG(HS) AS average_hours, MAX(HS) AS maximum_hours, MIN(HS) AS minimum_hours FROM Player;"
        ],
        "rule_sql": [
            "SELECT AVG(HS) as average_hours, MAX(HS) as maximum_hours, MIN(HS) as minimum_hours FROM Player;"
        ]
    },
    "6861": {
        "db_id": "flight_4",
        "question": "Find the number of routes and airport name for each source airport, order the results by decreasing number of routes.",
        "ground_truth": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name ORDER BY count(*) DESC",
        "amends": [
            "Do count all rows with `count(*)` instead of counting `routes.route_id`. Do select `T1.name` instead of `airports.name as airport_name`. Do join `airports AS T1` with `routes AS T2` instead of joining `routes` with `airports`. Do use join condition `T1.apid = T2.src_apid` instead of `routes.dest_airport_id = airports.airport_id`. Do group by `T1.name` instead of `routes.source_airport_id`. Do order by `count(*)` instead of `num_routes`. The amended query now correctly counts routes originating from each airport rather than routes destined for each airport, matching the intended behavior.",
            "Do place `count(*)` before `T1.name` in the SELECT list instead of after it. Do remove the alias `num_routes` instead of keeping it. Do use lowercase `count(*)` in both SELECT and ORDER BY clauses instead of uppercase `COUNT(*)`. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting routes per source airport: count all rows using count(*) instead of counting a specific column like routes.route_id. 2) When selecting airport name: use T1.name instead of airports.name as airport_name. 3) When joining airports and routes tables: use airports AS T1 and routes AS T2 with join condition T1.apid = T2.src_apid instead of joining on destination airport ID. 4) When grouping by source airport: group by T1.name instead of routes.source_airport_id. 5) When ordering results by number of routes: order by count(*) in descending order instead of using an alias like num_routes.",
            "1) When answering about \"number of routes and airport name for each source airport\": make sure the output order: count(*) first, then T1.name. 2) When counting routes: use count(*) without any alias instead of using an alias like num_routes. 3) When using aggregate functions: use lowercase count(*) in both SELECT and ORDER BY clauses instead of uppercase COUNT(*)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(routes.route_id) as num_routes, airports.name as airport_name \nFROM routes \nJOIN airports ON routes.dest_airport_id = airports.airport_id \nGROUP BY routes.source_airport_id \nORDER BY num_routes DESC;",
            "SELECT T1.name, COUNT(*) AS num_routes\nFROM airports AS T1\nJOIN routes AS T2 ON T1.apid = T2.src_apid\nGROUP BY T1.name\nORDER BY COUNT(*) DESC;",
            "SELECT count(*), T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid = T2.src_apid GROUP BY T1.name ORDER BY count(*) DESC"
        ],
        "rule_sql": [
            "SELECT count(*), T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid = T2.src_apid GROUP BY T1.name ORDER BY count(*) DESC;"
        ]
    },
    "747": {
        "db_id": "race_track",
        "question": "How many tracks do we have?",
        "ground_truth": "SELECT count(*) FROM track",
        "amends": [
            "Do query the `track` table instead of the `albums` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the track table instead of the albums table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"how many tracks\": query the \"track\" table instead of the \"albums\" table. 2) When counting records: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" for consistency."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM albums;",
            "SELECT count(*) FROM track;"
        ],
        "rule_sql": [
            "select count(*) from track"
        ]
    },
    "6511": {
        "db_id": "scientist_1",
        "question": "Find the names of scientists who are not working on the project with the highest hours.",
        "ground_truth": "SELECT name FROM scientists EXCEPT SELECT T3.name FROM assignedto AS T1 JOIN projects AS T2 ON T1.project  =  T2.code JOIN scientists AS T3 ON T1.scientist  =  T3.SSN WHERE T2.hours  =  (SELECT max(hours) FROM projects)",
        "amends": [
            "Do use `EXCEPT` to exclude scientists from the highest-hours project instead of using inequality comparison with a subquery. Do add explicit table joins through `assignedto AS T1 JOIN projects AS T2 ON T1.project = T2.code JOIN scientists AS T3 ON T1.scientist = T3.SSN` instead of directly querying the scientists table. Do filter with `T2.hours = (SELECT max(hours) FROM projects)` instead of `project_id != (SELECT project_id FROM projects ORDER BY hours DESC LIMIT 1)` to properly identify the maximum hours project. Do reference `T3.name` from the joined scientists table instead of directly selecting `name` from the base table. The amended query now correctly excludes scientists assigned to the project with maximum hours, matching the RIGHT_SQL's behavior.",
            "Do select `name` directly from `scientists` instead of joining through `assignedto` and `projects` tables in the first part of the EXCEPT operation. Do remove the redundant join logic in the first SELECT clause instead of including unnecessary table relationships. Do keep the second SELECT clause with the join logic to find scientists assigned to maximum hour projects instead of omitting this filtering condition. Do maintain the EXCEPT operation to find scientists not assigned to maximum hour projects instead of changing the set operation logic. Do use consistent column naming with `name` instead of mixing `Name` and `name` cases. The amended query now correctly identifies scientists who are not assigned to any project with maximum hours by comparing all scientists against those assigned to maximum hour projects."
        ],
        "rules": [
            "1) When answering about scientists not working on the highest-hours project: use EXCEPT to exclude scientists from the maximum hours project instead of inequality comparison. 2) When combining data about scientists and projects: link tables through assignedto AS T1 JOIN projects AS T2 ON T1.project = T2.code JOIN scientists AS T3 ON T1.scientist = T3.SSN. 3) When identifying the project with maximum hours: filter with T2.hours = (SELECT max(hours) FROM projects) instead of ordering and limiting. 4) When selecting scientist names: reference T3.name from the joined scientists table instead of directly from the base table.",
            "1) When answering about \"scientists who are not working on the project with the highest hours\": make sure the output order: T3.name 2) When the question asks for names of scientists: use the exact column token \"name\" from the scientists table instead of \"Name\" 3) When finding scientists not assigned to maximum hour projects: use an EXCEPT operation to subtract scientists assigned to maximum hour projects from all scientists 4) When identifying scientists assigned to maximum hour projects: join assignedto, projects, and scientists tables where T1.Project = T2.Code and T1.Scientist = T3.SSN and T2.Hours equals the maximum hours from projects 5) When selecting all scientists: select directly from the scientists table without unnecessary joins instead of joining through assignedto and projects tables"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM scientists WHERE project_id != (SELECT project_id FROM projects ORDER BY hours DESC LIMIT 1);",
            "SELECT T3.Name\nFROM assignedto AS T1 \nJOIN projects AS T2 ON T1.Project = T2.Code \nJOIN scientists AS T3 ON T1.Scientist = T3.SSN\nWHERE T2.Hours = (SELECT MAX(Hours) FROM projects)\nEXCEPT\nSELECT T3.Name\nFROM assignedto AS T1 \nJOIN projects AS T2 ON T1.Project = T2.Code \nJOIN scientists AS T3 ON T1.Scientist = T3.SSN",
            "SELECT name FROM Scientists\nEXCEPT\nSELECT T3.name \nFROM assignedto AS T1 \nJOIN projects AS T2 ON T1.project = T2.code \nJOIN scientists AS T3 ON T1.scientist = T3.SSN\nWHERE T2.hours = (SELECT max(hours) FROM projects)"
        ],
        "rule_sql": [
            "SELECT name FROM Scientists\nEXCEPT\nSELECT T3.name \nFROM AssignedTo AS T1 \nJOIN Projects AS T2 ON T1.Project = T2.Code \nJOIN Scientists AS T3 ON T1.Scientist = T3.SSN\nWHERE T2.Hours = (SELECT max(Hours) FROM Projects)"
        ]
    },
    "3333": {
        "db_id": "college_1",
        "question": "Find the name of department that offers the class whose description has the word \"Statistics\".",
        "ground_truth": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'",
        "amends": [
            "Do join `department AS T2` instead of querying `departments` alone. Do reference `T2.dept_name` instead of `department_name` in the SELECT list. Do add a join condition `ON T1.dept_code = T2.dept_code` instead of missing the table relationship. Do filter on `T1.crs_description LIKE '%Statistics%'` instead of `class_description` which doesn't exist in the joined schema. The amended query now correctly retrieves department names by joining course and department tables and filtering on course descriptions containing 'Statistics', matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"department that offers the class\": make sure to join the course table (T1) and department table (T2) using the exact key equality T1.dept_code = T2.dept_code, keeping only matching pairs (inner match). 2) When the question mentions \"class whose description has the word 'Statistics'\": filter on T1.crs_description LIKE '%Statistics%' exactly as specified, preserving the case and wildcards. 3) When the question asks for \"name of department\": output T2.dept_name as the result column. 4) When choosing identifier delimiters: do not replace the exact table aliases T1 and T2 as established in the join relationship."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department_name FROM departments WHERE class_description LIKE '%Statistics%'",
            "SELECT T2.DEPT_NAME \nFROM COURSE AS T1 \nJOIN DEPARTMENT AS T2 ON T1.DEPT_CODE = T2.DEPT_CODE \nWHERE T1.CRS_DESCRIPTION LIKE '%Statistics%'"
        ],
        "rule_sql": [
            "SELECT T2.DEPT_NAME\nFROM COURSE T1\nINNER JOIN DEPARTMENT T2 ON T1.DEPT_CODE = T2.DEPT_CODE\nWHERE T1.CRS_DESCRIPTION LIKE '%Statistics%'"
        ]
    },
    "4762": {
        "db_id": "department_store",
        "question": "What are the names of staff who have been assigned multiple jobs?",
        "ground_truth": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  1",
        "amends": [
            "Do select `T1.staff_name` instead of `name` and add table alias `T1`. Do add `FROM staff AS T1 JOIN staff_department_assignments AS T2` instead of just `FROM staff`, introducing a new table join. Do specify `ON T1.staff_id = T2.staff_id` instead of no join condition. Do change `GROUP BY name` to `GROUP BY T2.staff_id` instead, grouping by staff identifier rather than name. Do keep `HAVING COUNT(*) > 1` unchanged. The amended query now correctly identifies duplicate staff assignments across departments by joining the staff and department assignments tables and grouping by staff_id, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"names of staff who have been assigned multiple jobs\": make sure the output order: T1.staff_name. 2) When the question mentions \"staff names\": \"staff names\" actually means \"T1.staff_name in schema\". 3) When combining T1 and T2 for shared entities: link rows where T1.staff_id = T2.staff_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"staff who have been assigned multiple jobs\": organize results by T2.staff_id and compute COUNT(*) per group, keeping only groups where COUNT(*) > 1. 5) When counting job assignments: use the canonical key T2.staff_id for counting rather than generic column counting."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM staff GROUP BY name HAVING COUNT(*) > 1;",
            "SELECT T1.staff_name\nFROM Staff AS T1\nJOIN Staff_Department_Assignments AS T2 ON T1.staff_id = T2.staff_id\nGROUP BY T2.staff_id\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T1.staff_name\nFROM Staff T1\nINNER JOIN Staff_Department_Assignments T2 ON T1.staff_id = T2.staff_id\nGROUP BY T2.staff_id\nHAVING COUNT(*) > 1\nORDER BY T1.staff_name"
        ]
    },
    "5570": {
        "db_id": "products_gen_characteristics",
        "question": "How many products have the characteristic named \"hot\"?",
        "ground_truth": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t3.characteristic_name  =  \"hot\"",
        "amends": [
            "Do join `products AS t1` with `product_characteristics AS t2` on `t1.product_id = t2.product_id` instead of querying only the products table. Do add a second join to `CHARACTERISTICS AS t3` on `t2.characteristic_id = t3.characteristic_id` instead of missing this relationship. Do filter on `t3.characteristic_name = \"hot\"` instead of filtering directly on a non-existent `characteristic` column in the products table. The amended query now correctly counts products by joining through the characteristic relationships rather than relying on a non-existent column, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about products with a specific characteristic: join \"products\" as T1 with \"product_characteristics\" as T2 on T1.product_id = T2.product_id. 2) When joining product_characteristics: add a second join to \"CHARACTERISTICS\" as T3 on T2.characteristic_id = T3.characteristic_id. 3) When filtering for characteristic named \"hot\": use T3.characteristic_name = \"hot\" instead of filtering on non-existent columns. 4) When counting products with characteristics: count using T1.product_id as the canonical key after establishing the correct join relationships."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM products WHERE characteristic = 'hot';",
            "SELECT COUNT(DISTINCT t1.product_id) \nFROM Products AS t1\nJOIN Product_Characteristics AS t2 ON t1.product_id = t2.product_id\nJOIN Characteristics AS t3 ON t2.characteristic_id = t3.characteristic_id\nWHERE t3.characteristic_name = 'hot'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.product_id) \nFROM Products AS T1\nJOIN Product_Characteristics AS T2 ON T1.product_id = T2.product_id\nJOIN Characteristics AS T3 ON T2.characteristic_id = T3.characteristic_id\nWHERE T3.characteristic_name = 'hot';"
        ]
    },
    "5903": {
        "db_id": "cre_Theme_park",
        "question": "Which location names contain the word \"film\"?",
        "ground_truth": "SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE \"%film%\"",
        "amends": [
            "Do use `Location_Name` instead of `name` for the column selection to match the correct column name in the schema. Do use double quotes `\"%film%\"` instead of single quotes `'%film%'` for the LIKE pattern string literal. Do reference the table as `LOCATIONS` instead of `locations` to match the correct table name case. The amended query now correctly selects from the LOCATIONS table using the proper Location_Name column with the appropriate pattern matching syntax."
        ],
        "rules": [
            "1) When the question asks about location names: use the exact column name \"Location_Name\" from the LOCATIONS table. 2) When searching for names containing the word \"film\": use the pattern \"%film%\" with double quotes for the LIKE comparison. 3) When referencing the locations table: use the exact table name \"LOCATIONS\" with the correct case."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM locations WHERE name LIKE '%film%';",
            "SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE \"%film%\""
        ],
        "rule_sql": [
            "SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE \"%film%\";"
        ]
    },
    "1810": {
        "db_id": "small_bank_1",
        "question": "Find the saving balance of the account with the highest checking balance.",
        "ground_truth": "SELECT T3.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid ORDER BY T2.balance DESC LIMIT 1",
        "amends": [
            "Do select `T3.balance` from the `savings` table instead of `saving_balance` from the `accounts` table. Do add joins to `checking` and `savings` tables instead of querying only the `accounts` table. Do use `JOIN checking AS T2 ON T1.custid = T2.custid` and `JOIN savings AS T3 ON T1.custid = T3.custid` to properly relate the tables through customer IDs instead of missing these relationships. Do order by `T2.balance` from the checking account instead of `checking_balance` to use the actual balance value from the joined table. The amended query now correctly retrieves the savings balance for the customer with the highest checking account balance by properly joining the related tables."
        ],
        "rules": [
            "1) When answering about \"saving balance of the account with the highest checking balance\": make sure the output order: T3.balance. 2) When the question mentions \"saving balance\": \"saving balance\" actually means \"T3.balance in schema\". 3) When the question mentions \"highest checking balance\": rank rows by T2.balance in descending direction and keep the first 1 row. 4) When combining T1, T2, and T3 for shared entities: link rows where T1.custid = T2.custid and T1.custid = T3.custid; keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT saving_balance FROM accounts ORDER BY checking_balance DESC LIMIT 1;",
            "SELECT T3.balance \nFROM ACCOUNTS AS T1\nJOIN CHECKING AS T2 ON T1.custid = T2.custid\nJOIN SAVINGS AS T3 ON T1.custid = T3.custid\nORDER BY T2.balance DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T3.balance FROM ACCOUNTS T1 JOIN CHECKING T2 ON T1.custid = T2.custid JOIN SAVINGS T3 ON T1.custid = T3.custid ORDER BY T2.balance DESC LIMIT 1"
        ]
    },
    "913": {
        "db_id": "insurance_fnol",
        "question": "What are all the policy types of the customer that has the most policies listed?",
        "ground_truth": "SELECT DISTINCT t3.policy_type_code FROM customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id  =  t2.customer_id JOIN available_policies AS t3 ON t2.policy_id  =  t3.policy_id WHERE t1.customer_name  =  (SELECT t1.customer_name FROM customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_name ORDER BY count(*) DESC LIMIT 1)",
        "amends": [
            "Do select `t3.policy_type_code` from joined tables instead of `policy_type` from a single table. Do add explicit table joins with `customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id = t2.customer_id JOIN available_policies AS t3 ON t2.policy_id = t3.policy_id` instead of querying only the `policies` table. Do add a WHERE filter with `t1.customer_name = (subquery)` to find the customer with most policies instead of grouping by `customer_id`. Do use `DISTINCT` on the policy type instead of grouping by customer. Do remove the GROUP BY clause entirely instead of grouping by `customer_id`. Do remove the ORDER BY and LIMIT from the main query instead of keeping them, moving the ranking logic to the subquery. The amended query now correctly identifies policy types for the customer with the most policies, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"policy types of the customer that has the most policies\": make sure the output order: t3.policy_type_code. 2) When the question mentions \"customer that has the most policies\": use a subquery to find the customer_name with the maximum count of policies. 3) When combining tables for customer policy information: link rows where t1.customer_id = t2.customer_id and t2.policy_id = t3.policy_id, keeping only matching pairs (inner match). 4) When the question asks for \"all the policy types\": use DISTINCT on t3.policy_type_code to get unique policy types. 5) When filtering for the customer with most policies: use t1.customer_name = (subquery that finds customer with max policy count)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT policy_type FROM policies GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT DISTINCT t3.policy_type_code\nFROM customers AS t1\nJOIN customers_policies AS t2 ON t1.customer_id = t2.customer_id\nJOIN available_policies AS t3 ON t2.policy_id = t3.policy_id\nWHERE t1.customer_id = (\n    SELECT customer_id\n    FROM customers_policies\n    GROUP BY customer_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)"
        ],
        "rule_sql": [
            "SELECT DISTINCT t3.policy_type_code\nFROM Customers t1\nJOIN Customers_Policies t2 ON t1.Customer_ID = t2.Customer_ID\nJOIN Available_Policies t3 ON t2.Policy_ID = t3.Policy_ID\nWHERE t1.Customer_name = (\n    SELECT t1.Customer_name\n    FROM Customers t1\n    JOIN Customers_Policies t2 ON t1.Customer_ID = t2.Customer_ID\n    GROUP BY t1.Customer_name\n    ORDER BY COUNT(t2.Policy_ID) DESC\n    LIMIT 1\n)\nORDER BY t3.policy_type_code;"
        ]
    },
    "977": {
        "db_id": "university_basketball",
        "question": "List all schools and their nicknames in the order of founded year.",
        "ground_truth": "SELECT school ,  nickname FROM university ORDER BY founded",
        "amends": [
            "Do select `school` instead of `school_name` and use table `university` instead of `schools`. Do order by `founded` instead of `established_year` and remove the `DESC` direction. The amended query now correctly retrieves school names and nicknames from the university table ordered by founding year."
        ],
        "rules": [
            "1) When the question asks for schools and their nicknames: select \"school\" and \"nickname\" columns from the university table. 2) When ordering results by founded year: order by the \"founded\" column in ascending order (without DESC direction). 3) When referring to the schools table: use the \"university\" table instead of \"schools\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT school_name, nickname FROM schools ORDER BY established_year DESC;",
            "SELECT School, Nickname FROM university ORDER BY Founded;"
        ],
        "rule_sql": [
            "SELECT School, Nickname FROM university ORDER BY Founded;"
        ]
    },
    "1256": {
        "db_id": "apartment_rentals",
        "question": "Show the top 3 apartment type codes sorted by the average number of rooms in descending order.",
        "ground_truth": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT 3",
        "amends": [
            "Do use `apt_type_code` instead of `apartment_type_code` for the column name and `room_count` instead of `number_of_rooms` for the room count column. Do reference table `Apartments` instead of `apartments` for the correct table name. Do remove the explicit `AVG(number_of_rooms) as avg_rooms` column from the SELECT list instead of including it, keeping only the grouping column. Do change the ORDER BY to use `avg(room_count) DESC` instead of `avg_rooms ASC` to sort by the average room count in descending order rather than ascending. The amended query now correctly selects apartment type codes ordered by their average room count in descending order with a limit of 3, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question mentions \"apartment type codes\": use the exact column name \"apt_type_code\" from the Apartments table. 2) When the question mentions \"number of rooms\": use the exact column name \"room_count\" from the Apartments table. 3) When the question asks for \"top 3 sorted by average number of rooms in descending order\": compute the average of \"room_count\" per group, rank groups by this average in descending order, and keep the top 3 groups. 4) When producing output for this question: include only the grouping column \"apt_type_code\" in the final results, not the computed average column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT apartment_type_code, AVG(number_of_rooms) as avg_rooms FROM apartments GROUP BY apartment_type_code ORDER BY avg_rooms ASC LIMIT 3;",
            "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY AVG(room_count) DESC LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT apt_type_code\nFROM Apartments\nGROUP BY apt_type_code\nORDER BY AVG(CAST(room_count AS REAL)) DESC\nLIMIT 3;"
        ]
    },
    "3706": {
        "db_id": "baseball_1",
        "question": "Find the number of team franchises that are active (have 'Y' as \"active\" information).",
        "ground_truth": "SELECT count(*) FROM team_franchise WHERE active = 'Y';",
        "amends": [
            "Do reference table `team_franchise` instead of `team_franchises` and filter on `active = 'Y'` instead of `active = 'N'`."
        ],
        "rules": [
            "1) When answering about \"number of team franchises that are active\": use the exact table name \"team_franchise\" instead of \"team_franchises\". 2) When filtering for active franchises: use the exact literal value 'Y' for the \"active\" column instead of 'N'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM team_franchises WHERE active = 'N';",
            "SELECT COUNT(*) FROM team_franchise WHERE active = 'Y';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM team_franchise WHERE active = 'Y';"
        ]
    },
    "37": {
        "db_id": "farm",
        "question": "What are the official names of cities that have hosted more than one competition?",
        "ground_truth": "SELECT T1.Official_Name FROM city AS T1 JOIN farm_competition AS T2 ON T1.City_ID  =  T2.Host_city_ID GROUP BY T2.Host_city_ID HAVING COUNT(*)  >  1",
        "amends": [
            "Do select `T1.Official_Name` instead of `city_name` and use table alias `T1` instead of bare column reference. Do join `city AS T1` with `farm_competition AS T2` instead of querying only `competitions` table. Do specify join condition `ON T1.City_ID = T2.Host_city_ID` instead of missing table relationships. Do group by `T2.Host_city_ID` instead of `city_name` to properly count competitions per host city. The amended query now correctly identifies cities hosting multiple farm competitions by joining the city and farm_competition tables and grouping on the host city ID, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"official names of cities that have hosted more than one competition\": make sure the output order: T1.Official_Name. 2) When the question mentions \"cities\": use table \"city AS T1\" with column \"T1.Official_Name\" for city names. 3) When combining T1 (city) and T2 (farm_competition) for shared entities: link rows where T1.City_ID = T2.Host_city_ID and keep only matching pairs (inner match). 4) When the question asks for \"more than one competition\" per city: group by T2.Host_city_ID and count using T2.Host_city_ID, keeping only groups with count > 1. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for any identifiers."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city_name FROM competitions GROUP BY city_name HAVING COUNT(*) > 1;",
            "SELECT T1.Official_Name FROM city AS T1 JOIN farm_competition AS T2 ON T1.City_ID = T2.Host_city_ID GROUP BY T2.Host_city_ID HAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T1.\"Official_Name\" FROM \"city\" AS T1 INNER JOIN \"farm_competition\" AS T2 ON T1.\"City_ID\" = T2.\"Host_city_ID\" GROUP BY T2.\"Host_city_ID\" HAVING COUNT(T2.\"Host_city_ID\") > 1 ORDER BY T1.\"Official_Name\""
        ]
    },
    "4640": {
        "db_id": "college_3",
        "question": "What are the names of courses with 1 credit?",
        "ground_truth": "SELECT CName FROM COURSE WHERE Credits  =  1",
        "amends": [
            "Do reference the column as `CName` instead of `course_name` and the table as `COURSE` instead of `courses`. Do maintain the filter condition `Credits = 1` instead of `credits = 1` with consistent spacing. The amended query now correctly references the schema elements and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for course names: use the exact column token \"CName\" from the COURSE table instead of \"course_name\". 2) When the question mentions courses: use the exact table token \"COURSE\" instead of \"courses\". 3) When filtering for courses with 1 credit: use the exact condition \"Credits = 1\" with consistent spacing and case as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_name FROM courses WHERE credits = 1;",
            "SELECT CName FROM Course WHERE Credits = 1;"
        ],
        "rule_sql": [
            "SELECT CName FROM Course WHERE Credits = 1;"
        ]
    },
    "1404": {
        "db_id": "college_2",
        "question": "Find the year which offers the largest number of courses.",
        "ground_truth": "SELECT YEAR FROM SECTION GROUP BY YEAR ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `YEAR` instead of `year, COUNT(*) as course_count` and remove the alias. Do use `FROM SECTION` instead of `FROM courses` as the table source. Do change the aggregation to `ORDER BY count(*) DESC` instead of `ORDER BY course_count ASC` while keeping the `GROUP BY YEAR` clause. Do maintain `LIMIT 1` but change the ordering direction from ascending to descending to find the year with the highest count rather than the lowest. The amended query now correctly identifies the year with the most sections by counting occurrences and ordering descending instead of ascending."
        ],
        "rules": [
            "1) When answering about \"year which offers the largest number of courses\": make sure the output order: YEAR. 2) When the question mentions \"courses\": \"courses\" actually means \"SECTION in schema\". 3) When the question asks for \"largest number of courses\": count the number of rows using the canonical key for SECTION and rank years by count in descending order to find the maximum. 4) When the question asks for count of courses per year: organize results by YEAR and compute count(*) per group. 5) When the question mentions \"largest\": rank rows by count(*) in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, COUNT(*) as course_count FROM courses GROUP BY year ORDER BY course_count ASC LIMIT 1;",
            "SELECT year FROM section GROUP BY year ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT year\nFROM section\nGROUP BY year\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "583": {
        "db_id": "store_1",
        "question": "List the name of albums that are released by aritist whose name has 'Led'",
        "ground_truth": "SELECT T2.title FROM artists AS T1 JOIN albums AS T2 ON T1.id  =  T2.artist_id WHERE T1.name LIKE '%Led%'",
        "amends": [
            "Do use `T2.title` in the SELECT list instead of `name` to reference the correct column from the albums table. Do join `artists AS T1` with `albums AS T2` on `T1.id = T2.artist_id` instead of querying only the albums table without proper artist relationship. Do filter on `T1.name LIKE '%Led%'` instead of `artist_name LIKE '%Led%'` to correctly reference the artist name from the artists table rather than assuming it exists in the albums table. The amended query now properly joins the artists and albums tables to find album titles by artists with 'Led' in their name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"albums released by artists whose name has 'Led'\": make sure the output order: T2.title. 2) When the question mentions \"artist whose name has 'Led'\": filter on T1.name LIKE '%Led%' from the artists table. 3) When combining artists (T1) and albums (T2) for shared entities: link rows where T1.id = T2.artist_id and keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM albums WHERE artist_name LIKE '%Led%';",
            "SELECT T2.title \nFROM artists AS T1 \nJOIN albums AS T2 ON T1.id = T2.artist_id \nWHERE T1.name LIKE '%Led%'"
        ],
        "rule_sql": [
            "SELECT T2.title FROM artists T1 INNER JOIN albums T2 ON T1.id = T2.artist_id WHERE T1.name LIKE '%Led%' ORDER BY T2.title"
        ]
    },
    "3733": {
        "db_id": "program_share",
        "question": "Show me the owner of the channel with the highest rating.",
        "ground_truth": "SELECT OWNER FROM channel ORDER BY rating_in_percent DESC LIMIT 1",
        "amends": [
            "Do reference table `channel` instead of `channels` in the FROM clause. Do use column `rating_in_percent` instead of `rating` in the ORDER BY clause. The amended query now correctly references the proper table and column to retrieve the highest-rated channel owner."
        ],
        "rules": [
            "1) When the question asks about channels: use table \"channel\" instead of \"channels\" 2) When the question mentions \"rating\": use column \"rating_in_percent\" instead of \"rating\" 3) When the question asks for the \"highest rating\": order by \"rating_in_percent\" in descending direction and keep the first row"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT owner FROM channels ORDER BY rating DESC LIMIT 1;",
            "SELECT Owner FROM channel ORDER BY rating_in_percent DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Owner FROM channel ORDER BY rating_in_percent DESC LIMIT 1;"
        ]
    },
    "3130": {
        "db_id": "assets_maintenance",
        "question": "What is the name and id of the staff who recorded the fault log but has not contacted any visiting engineers?",
        "ground_truth": "SELECT T1.staff_name ,  T1.staff_id FROM Staff AS T1 JOIN Fault_Log AS T2 ON T1.staff_id  =  T2.recorded_by_staff_id EXCEPT SELECT T3.staff_name ,  T3.staff_id FROM Staff AS T3 JOIN Engineer_Visits AS T4 ON T3.staff_id  =  T4.contact_staff_id",
        "amends": [
            "Do select `staff_name` and `staff_id` instead of `name` and `id`. Do join `Fault_Log` on `staff_id = recorded_by_staff_id` instead of joining on `staff_id = staff_id`. Do use `EXCEPT` instead of additional joins and filters. Do remove the `contact` table join and `engineer_id IS NOT NULL` filter instead of keeping them, as the right query uses an `EXCEPT` operation with `Engineer_Visits` to exclude staff who have engineer visits rather than filtering for contacts with engineer IDs. The amended query now correctly identifies staff who have fault log records but no engineer visits, matching the RIGHT_SQL's behavior.",
            "Do use explicit table aliases `T1` and `T2` instead of no aliases in the first part of the query. Do use `JOIN` with `ON T1.staff_id = T2.recorded_by_staff_id` instead of a subquery with `IN`. Do include both `staff_name` and `staff_id` in the same order in both parts of the `EXCEPT` instead of having different column orders. Do use explicit table aliases `T3` and `T4` instead of no aliases in the second part of the query. Do maintain consistent column selection `staff_name, staff_id` in both halves of the `EXCEPT` instead of having `staff_id, staff_name` in the first part and `contact_staff_id, staff_name` in the second part. The amended query now correctly identifies staff who recorded faults but were not contact staff for engineer visits, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting staff information: use \"staff_name\" and \"staff_id\" as the exact column names instead of generic \"name\" and \"id\". 2) When joining Staff with Fault_Log: link rows where Staff.staff_id equals Fault_Log.recorded_by_staff_id using exact equality. 3) When finding staff who recorded faults but haven't contacted engineers: use EXCEPT operation with Engineer_Visits table to exclude staff who have engineer visits, rather than filtering for contacts with engineer IDs. 4) When handling the contact table: do not join with the contact table or use engineer_id IS NOT NULL filter as these are incorrect for this question.",
            "1) When answering about staff who recorded fault logs: use T1 as alias for Staff table and T2 as alias for Fault_Log table, and join them using T1.staff_id = T2.recorded_by_staff_id instead of a subquery. 2) When answering about staff who contacted visiting engineers: use T3 as alias for Staff table and T4 as alias for Engineer_Visits table, and join them using T3.staff_id = T4.contact_staff_id. 3) When selecting columns for EXCEPT operation: maintain consistent column selection order of staff_name, staff_id in both halves of the EXCEPT. 4) When combining results from both parts: use EXCEPT to find staff present in the first set (fault recorders) but not in the second set (engineer visit contacts)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.name, s.id \nFROM staff s \nJOIN fault_log fl ON s.id = fl.staff_id \nJOIN contact c ON s.id = c.staff_id \nWHERE c.engineer_id IS NOT NULL;",
            "SELECT staff_id, staff_name FROM Staff WHERE staff_id IN (SELECT recorded_by_staff_id FROM Fault_Log) EXCEPT SELECT contact_staff_id, staff_name FROM Staff JOIN Engineer_Visits ON Staff.staff_id = Engineer_Visits.contact_staff_id;",
            "SELECT T1.staff_name, T1.staff_id\nFROM Staff T1\nJOIN Fault_Log T2 ON T1.staff_id = T2.recorded_by_staff_id\nEXCEPT\nSELECT T3.staff_name, T3.staff_id\nFROM Staff T3\nJOIN Engineer_Visits T4 ON T3.staff_id = T4.contact_staff_id"
        ],
        "rule_sql": [
            "SELECT T1.staff_name, T1.staff_id\nFROM Staff T1\nJOIN Fault_Log T2 ON T1.staff_id = T2.recorded_by_staff_id\nEXCEPT\nSELECT T3.staff_name, T3.staff_id\nFROM Staff T3\nJOIN Engineer_Visits T4 ON T3.staff_id = T4.contact_staff_id"
        ]
    },
    "3851": {
        "db_id": "insurance_policies",
        "question": "Find the claims that led to more than two settlements or have the maximum claim value. For each of them, return the date the claim was made and the id of the claim.",
        "ground_truth": "SELECT T1.Date_Claim_Made ,  T1.Claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.Claim_id HAVING count(*)  >  2 UNION SELECT T1.Date_Claim_Made ,  T1.Claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id WHERE T1.Amount_Claimed  =  ( SELECT max(Amount_Claimed) FROM Claims )",
        "amends": [
            "Do add `JOIN Settlements AS T2` with `ON T1.Claim_id = T2.Claim_id` instead of querying only the `claims` table. Do change `claim_date` to `Date_Claim_Made` and `claim_id` to `Claim_id` with proper table aliasing instead of using unqualified column names. Do split the query into a `UNION` of two parts instead of a single query with `OR` conditions. Do use `GROUP BY T1.Claim_id` with `HAVING count(*) > 2` instead of `WHERE settlement_count > 2`. Do change the subquery to reference `max(Amount_Claimed)` instead of `MAX(claim_value)` and use `WHERE T1.Amount_Claimed =` instead of `claim_value =`. Do add proper table aliases `T1` and `T2` throughout instead of no aliasing. The amended query now correctly identifies claims with multiple settlements and those with maximum claimed amounts through proper table joins and union operation."
        ],
        "rules": [
            "1) When combining claims and settlements data: join table \"claims\" as T1 with table \"Settlements\" as T2 where T1.Claim_id = T2.Claim_id to get matching pairs. 2) When counting settlements per claim: group by T1.Claim_id and count the number of rows to find claims with more than 2 settlements. 3) When finding maximum claim value: use T1.Amount_Claimed instead of claim_value and compare against the maximum value of Amount_Claimed from the claims table. 4) When selecting output columns: return Date_Claim_Made and Claim_id with proper table aliasing (T1.Claim_id). 5) When handling both conditions (multiple settlements OR maximum value): use a UNION operation to combine results from two separate queries instead of a single OR condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT claim_date, claim_id FROM claims WHERE settlement_count > 2 OR claim_value = (SELECT MAX(claim_value) FROM claims);",
            "SELECT T1.Date_Claim_Made, T1.Claim_ID\nFROM Claims AS T1\nJOIN Settlements AS T2 ON T1.Claim_ID = T2.Claim_ID\nGROUP BY T1.Claim_ID\nHAVING COUNT(*) > 2\n\nUNION\n\nSELECT T1.Date_Claim_Made, T1.Claim_ID\nFROM Claims AS T1\nWHERE T1.Amount_Claimed = (SELECT MAX(Amount_Claimed) FROM Claims)"
        ],
        "rule_sql": [
            "SELECT T1.Date_Claim_Made, T1.Claim_ID\nFROM Claims AS T1\nJOIN Settlements AS T2 ON T1.Claim_ID = T2.Claim_ID\nGROUP BY T1.Claim_ID\nHAVING COUNT(*) > 2\n\nUNION\n\nSELECT Date_Claim_Made, Claim_ID\nFROM Claims\nWHERE Amount_Claimed = (SELECT MAX(Amount_Claimed) FROM Claims)"
        ]
    },
    "6666": {
        "db_id": "driving_school",
        "question": "When are the birthdays of customer who are classified as 'Good Customer' status?",
        "ground_truth": "SELECT date_of_birth FROM Customers WHERE customer_status_code  =  'Good Customer'",
        "amends": [
            "Do reference the column as `date_of_birth` instead of `birthday` to use the correct column name. Do reference the table as `Customers` instead of `customers` to match the proper table name casing. Do use the filter condition `customer_status_code = 'Good Customer'` instead of `status = 'Good Customer'` to reference the correct column for customer status filtering. The amended query now correctly retrieves date of birth information for customers with the specified status code, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"birthdays\": use the exact column name \"date_of_birth\" from the Customers table. 2) When the question mentions \"customer status\": use the exact column name \"customer_status_code\" from the Customers table for filtering. 3) When filtering for customers classified as 'Good Customer': use the exact literal value 'Good Customer' with the correct case and spacing. 4) When referring to the customer table: use the exact table name \"Customers\" with proper casing."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT birthday FROM customers WHERE status = 'Good Customer';",
            "SELECT date_of_birth FROM Customers WHERE customer_status_code = 'Good Customer'"
        ],
        "rule_sql": [
            "SELECT date_of_birth FROM Customers WHERE customer_status_code = 'Good Customer';"
        ]
    },
    "935": {
        "db_id": "medicine_enzyme_interaction",
        "question": "List the name of enzymes in descending lexicographical order.",
        "ground_truth": "SELECT name FROM enzyme ORDER BY name DESC",
        "amends": [
            "Do query from table `enzyme` instead of `enzymes`. Do use `ORDER BY name DESC` instead of `ORDER BY name ASC` to sort in descending order rather than ascending. The amended query now correctly retrieves enzyme names from the proper table and sorts them in reverse alphabetical order as specified."
        ],
        "rules": [
            "1) When querying for enzyme names: use table \"enzyme\" instead of \"enzymes\" 2) When sorting enzyme names in descending lexicographical order: use ORDER BY name DESC instead of ORDER BY name ASC"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM enzymes ORDER BY name ASC;",
            "SELECT name FROM enzyme ORDER BY name DESC;"
        ],
        "rule_sql": [
            "SELECT name FROM enzyme ORDER BY name DESC;"
        ]
    },
    "6718": {
        "db_id": "activity_1",
        "question": "Find the list of distinct ranks for faculty.",
        "ground_truth": "SELECT DISTINCT rank FROM Faculty",
        "amends": [
            "Do select `rank` instead of `name` from the `Faculty` table instead of `faculty`, while maintaining the `DISTINCT` clause to eliminate duplicate values. The amended query now correctly retrieves unique faculty ranks rather than names, matching the intended behavior of the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for \"distinct ranks for faculty\": select the exact column \"rank\" from the \"Faculty\" table instead of \"name\" from \"faculty\". 2) When eliminating duplicate values: use the DISTINCT clause to return only unique values of the \"rank\" column. 3) When referring to the faculty table: use the exact table name \"Faculty\" with proper capitalization as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT name FROM faculty;",
            "SELECT DISTINCT Rank FROM Faculty;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Rank FROM Faculty;"
        ]
    },
    "1276": {
        "db_id": "game_injury",
        "question": "List the season, home team, away team of all the games.",
        "ground_truth": "SELECT season ,  home_team ,  away_team FROM game",
        "amends": [
            "Do reference the correct table name `game` instead of the incorrect pluralized `games` table. The amended query now correctly queries from the `game` table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for games information: use the exact table name \"game\" instead of pluralized forms like \"games\". 2) When listing all games: do not apply any filtering conditions unless explicitly specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT season, home_team, away_team FROM games WHERE home_team = 'Lakers';",
            "SELECT Season, Home_team, Away_team FROM game;"
        ],
        "rule_sql": [
            "SELECT Season, Home_team, Away_team FROM game;"
        ]
    },
    "1667": {
        "db_id": "theme_gallery",
        "question": "Show all artist names and the number of exhibitions for each artist.",
        "ground_truth": "SELECT T2.name ,  count(*) FROM exhibition AS T1 JOIN artist AS T2 ON T1.artist_id  =  T2.artist_id GROUP BY T1.artist_id",
        "amends": [
            "Do join `artist AS T2` on `T1.artist_id = T2.artist_id` instead of querying `exhibitions` table alone. Do select `T2.name` instead of `artist_name` from the exhibitions table. Do group by `T1.artist_id` instead of `artist_name` to ensure proper aggregation with the joined artist table. The amended query now correctly links exhibitions to artists through the artist_id relationship and returns the artist name from the artist table instead of relying on a potentially inconsistent artist_name field in the exhibitions table."
        ],
        "rules": [
            "1) When answering about \"artist names and number of exhibitions\": make sure the output order: T2.name, COUNT(T1.artist_id) 2) When the question mentions \"artist names\": \"artist names\" actually means \"T2.name in schema\" 3) When combining T1 (exhibitions) and T2 (artist) for shared entities: link rows where T1.artist_id = T2.artist_id exactly as shown in the amends; keep only matching pairs (inner match) 4) When the question asks for \"number of exhibitions for each artist\": compute the count using the canonical key T1.artist_id for exhibitions 5) When the question says \"per artist\"/\"for each artist\": organize results by T1.artist_id and compute requested aggregates per group"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT artist_name, COUNT(*) FROM exhibitions GROUP BY artist_name;",
            "SELECT T2.Name, COUNT(T1.Exhibition_ID) AS Number_of_Exhibitions\nFROM exhibition AS T1\nJOIN artist AS T2 ON T1.Artist_ID = T2.Artist_ID\nGROUP BY T1.Artist_ID"
        ],
        "rule_sql": [
            "SELECT T2.Name, COUNT(T1.Artist_ID) \nFROM exhibition T1 \nINNER JOIN artist T2 ON T1.Artist_ID = T2.Artist_ID \nGROUP BY T1.Artist_ID \nORDER BY T2.Name, COUNT(T1.Artist_ID)"
        ]
    },
    "2661": {
        "db_id": "party_host",
        "question": "Count the number of parties.",
        "ground_truth": "SELECT count(*) FROM party",
        "amends": [
            "Do reference the `party` table instead of `parties` in the FROM clause. Do use the correct table name `party` instead of the incorrect `parties` table. The amended query now correctly counts records from the intended party table with the specified party_id filter, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting entities from a table: use the exact table name \"party\" as specified in the schema, not variations like \"parties\". 2) When filtering by party_id: use the exact column name \"party_id\" with the literal value 1 as specified in the question and query."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM parties WHERE party_id = 1;",
            "SELECT COUNT(*) FROM party;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM party;"
        ]
    },
    "5884": {
        "db_id": "tracking_share_transactions",
        "question": "What are the details of the lots which are not used in any transactions?",
        "ground_truth": "SELECT lot_details FROM Lots EXCEPT SELECT T1.lot_details FROM Lots AS T1 JOIN transactions_lots AS T2 ON T1.lot_id  =  T2.lot_id",
        "amends": [
            "Do select `lot_details` instead of `*` and use `EXCEPT` instead of `NOT IN`. Do reference table `Lots` instead of `lots` and add alias `T1`. Do add join with `transactions_lots AS T2` instead of subquery on `transactions`. Do use join condition `T1.lot_id = T2.lot_id` instead of subquery correlation. Do remove the subquery entirely and replace with set operation. The amended query now correctly handles the set difference using proper table joins and EXCEPT operation."
        ],
        "rules": [
            "1) When answering about \"details of lots not used in any transactions\": make sure the output order: lot_details. 2) When the question mentions \"details\": \"details\" actually means \"lot_details in schema\". 3) When selecting from the Lots table: use the exact table name \"Lots\" with alias T1. 4) When combining T1 and transactions_lots for shared entities: link rows where T1.lot_id = T2.lot_id exactly as shown in the amends; keep only matching pairs (inner match). 5) When finding lots not used in any transactions: use set difference operation (EXCEPT) instead of NOT IN subquery. 6) When handling text literals: do not change case, spacing, or punctuation for any values in lot_details column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM lots WHERE lot_id NOT IN (SELECT lot_id FROM transactions);",
            "SELECT lot_details FROM Lots\nEXCEPT\nSELECT T1.lot_details FROM Lots AS T1\nJOIN Transactions_Lots AS T2 ON T1.lot_id = T2.lot_id"
        ],
        "rule_sql": [
            "SELECT T1.lot_details FROM Lots T1 EXCEPT SELECT T1.lot_details FROM Lots T1 JOIN Transactions_Lots T2 ON T1.lot_id = T2.lot_id"
        ]
    },
    "6418": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "How many documents are there of each type?",
        "ground_truth": "SELECT document_type_code ,  count(*) FROM Documents GROUP BY document_type_code",
        "amends": [
            "Do use `document_type_code` instead of `type` in both the SELECT list and GROUP BY clause, as the column name has been corrected to match the actual schema. Do reference the table as `Documents` instead of `documents` to maintain proper case sensitivity where required. The amended query now correctly aggregates documents by their type code using the proper column name and table reference, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for documents by type: use \"document_type_code\" instead of \"type\" as the column name for document types. 2) When referencing the documents table: use \"Documents\" (with proper case) instead of \"documents\" to maintain case sensitivity. 3) When counting documents per type: group by \"document_type_code\" and count using the canonical document identifier."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type, COUNT(*) FROM documents GROUP BY type;",
            "SELECT Document_Type_Code, COUNT(*) AS Document_Count FROM Documents GROUP BY Document_Type_Code;"
        ],
        "rule_sql": [
            "SELECT document_type_code, COUNT(Document_ID) AS document_count FROM Documents GROUP BY document_type_code;"
        ]
    },
    "2672": {
        "db_id": "party_host",
        "question": "Show different nationalities along with the number of hosts of each nationality.",
        "ground_truth": "SELECT Nationality ,  COUNT(*) FROM HOST GROUP BY Nationality",
        "amends": [
            "Do specify `Nationality` in the SELECT list instead of `nationality` to match the correct column name. Do group by `Nationality` instead of `host_id` to properly aggregate counts by nationality rather than by individual host identifiers. Do reference table `HOST` instead of `hosts` to use the correct table name. The amended query now correctly counts hosts by their nationality rather than producing incorrect per-host counts."
        ],
        "rules": [
            "1) When the question asks for nationalities and host counts: use the exact column name \"Nationality\" from table HOST. 2) When counting hosts per nationality: group by \"Nationality\" to aggregate counts by nationality rather than by individual host identifiers. 3) When referencing the table containing nationality information: use the exact table name HOST instead of hosts."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT nationality, COUNT(*) FROM hosts GROUP BY host_id;",
            "SELECT Nationality, COUNT(*) AS Number_of_Hosts FROM host GROUP BY Nationality;"
        ],
        "rule_sql": [
            "SELECT Nationality, COUNT(*) AS Number_of_hosts FROM host GROUP BY Nationality;"
        ]
    },
    "1803": {
        "db_id": "small_bank_1",
        "question": "What are the names and balances of checking accounts belonging to the customer with the lowest savings balance?",
        "ground_truth": "SELECT T1.name ,  T2.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid ORDER BY T3.balance LIMIT 1",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `c` and `a`. Do reference columns `T1.name` and `T2.balance` instead of `c.name` and `a.balance`. Do join from `accounts AS T1` instead of `customers c`. Do add `JOIN checking AS T2` on `T1.custid = T2.custid` instead of joining accounts directly. Do add `JOIN savings AS T3` on `T1.custid = T3.custid` instead of using a subquery for savings accounts. Do remove the `WHERE` filter for account type and subquery entirely instead of keeping them. Do add `ORDER BY T3.balance` instead of ordering in a subquery. Do keep `LIMIT 1` but apply it at the main query level instead of in a subquery. The amended query now correctly identifies customers with both checking and savings accounts and returns the one with the lowest savings balance, matching the intended behavior."
        ],
        "rules": [
            "1) When joining tables for customers with both checking and savings accounts: combine \"accounts AS T1\", \"checking AS T2\", and \"savings AS T3\" using the exact key equality T1.custid = T2.custid and T1.custid = T3.custid, keeping only matching pairs (inner match). 2) When finding the customer with the lowest savings balance: order all rows by T3.balance in ascending order and keep only the first 1 row. 3) When answering about checking account names and balances: make sure the output order includes T1.name and T2.balance. 4) When the question asks for checking accounts: do not filter by account type since the checking table already contains only checking accounts."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name, a.balance \nFROM customers c\nJOIN accounts a ON c.customer_id = a.customer_id\nWHERE a.account_type = 'checking'\nAND c.customer_id = (\n    SELECT customer_id \n    FROM accounts \n    WHERE account_type = 'savings' \n    ORDER BY balance ASC \n    LIMIT 1\n)",
            "SELECT T1.name, T2.balance \nFROM accounts AS T1 \nJOIN checking AS T2 ON T1.custid = T2.custid \nJOIN savings AS T3 ON T1.custid = T3.custid \nORDER BY T3.balance \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.name, T2.balance\nFROM accounts AS T1\nINNER JOIN checking AS T2 ON T1.custid = T2.custid\nINNER JOIN savings AS T3 ON T1.custid = T3.custid\nORDER BY T3.balance ASC\nLIMIT 1"
        ]
    },
    "5942": {
        "db_id": "cre_Theme_park",
        "question": "What are the details of the three most expensive hotels?",
        "ground_truth": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3",
        "amends": [
            "Do select `other_hotel_details` instead of `*` to return specific columns instead of all columns. Do order by `price_range DESC` instead of `price ASC` to sort by a different column in descending order instead of ascending order. Do use the table name `HOTELS` in uppercase instead of `hotels` in lowercase, though this may be a cosmetic difference depending on case sensitivity. The amended query now correctly returns only the other_hotel_details column sorted by price_range in descending order with a limit of 3 rows, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"details of the three most expensive hotels\": make sure the output order: other_hotel_details. 2) When the question mentions \"most expensive\": sort by price_range in descending order. 3) When the question mentions \"three\": keep only the first 3 rows after sorting. 4) When choosing identifier delimiters: use the exact table name \"HOTELS\" as shown in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM hotels ORDER BY price ASC LIMIT 3;",
            "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT other_hotel_details FROM Hotels ORDER BY price_range DESC LIMIT 3"
        ]
    },
    "3914": {
        "db_id": "hospital_1",
        "question": "Find the names of all physicians and their primary affiliated departments' names.",
        "ground_truth": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1",
        "amends": [
            "Do use table aliases `T1` and `T3` instead of `p` and `d`. Do reference `physician` and `department` tables instead of `physicians` and `departments`. Do add the `affiliated_with` table as `T2` instead of omitting it. Do use `JOIN` on `T1.EmployeeID = T2.physician` instead of `LEFT JOIN` on `p.department_id = d.id`. Do join `T2.department = T3.DepartmentID` instead of directly joining physician to department. Do filter on `T2.PrimaryAffiliation = 1` instead of `p.primary_affiliation = 'yes'`. Do select from the correct relationship table to establish proper physician-department affiliation mapping. The amended query now correctly reflects the relational structure and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about physician names and their primary affiliated departments: make sure the output order: T1.name, T3.name\n2) When combining physician and department information: use the affiliated_with table T2 as the relationship table instead of direct joins\n3) When linking physicians to their affiliations: join T1.EmployeeID = T2.physician and T2.department = T3.DepartmentID using exact equality matches\n4) When filtering for primary affiliations: use T2.PrimaryAffiliation = 1 instead of string literals\n5) When selecting physician names: use T1.name from the physician table (not physicians)\n6) When selecting department names: use T3.name from the department table (not departments)\n7) When joining tables: use inner joins (not LEFT JOIN) to ensure only matching physician-department pairs are included"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.name, d.name \nFROM physicians p \nLEFT JOIN departments d ON p.department_id = d.id \nWHERE p.primary_affiliation = 'yes';",
            "SELECT T1.Name AS PhysicianName, T3.Name AS DepartmentName\nFROM Physician T1\nJOIN Affiliated_With T2 ON T1.EmployeeID = T2.Physician\nJOIN Department T3 ON T2.Department = T3.DepartmentID\nWHERE T2.PrimaryAffiliation = 1;"
        ],
        "rule_sql": [
            "SELECT T1.Name, T3.Name\nFROM Physician T1\nINNER JOIN Affiliated_With T2 ON T1.EmployeeID = T2.Physician\nINNER JOIN Department T3 ON T2.Department = T3.DepartmentID\nWHERE T2.PrimaryAffiliation = 1"
        ]
    },
    "132": {
        "db_id": "bike_1",
        "question": "What are the different names for each station that has ever had 7 bikes available?",
        "ground_truth": "SELECT DISTINCT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  =  7",
        "amends": [
            "Do add `JOIN status AS T2 ON T1.id = T2.station_id` instead of querying only the `stations` table. Do reference `T2.bikes_available` in the WHERE clause instead of `bikes_available` directly from the stations table. Do use table alias `T1.name` instead of just `name` to specify the source table. The amended query now correctly joins the station and status tables to filter by bikes_available from the status table instead of incorrectly assuming bikes_available exists in the stations table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about station names with 7 bikes available: join table \"station\" as T1 with table \"status\" as T2 using the condition T1.id = T2.station_id to match station records with their status information. 2) When filtering for stations with exactly 7 bikes available: use the condition T2.bikes_available = 7 to filter based on the bikes_available column from the status table. 3) When selecting station names: use T1.name to reference the station name from the station table, not the status table. 4) When combining station and status tables: perform an inner match where T1.id equals T2.station_id to ensure only matching station-status pairs are included."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT name FROM stations WHERE bikes_available = 7;",
            "SELECT DISTINCT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id = T2.station_id WHERE T2.bikes_available = 7"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.name \nFROM station T1 \nINNER JOIN status T2 ON T1.id = T2.station_id \nWHERE T2.bikes_available = 7"
        ]
    },
    "4235": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "List the names of the employees who authorized the destruction of documents and the employees who destroyed the corresponding documents.",
        "ground_truth": "SELECT T2.employee_name ,  T3.employee_name FROM Documents_to_be_destroyed AS T1 JOIN Employees AS T2 ON T1.Destruction_Authorised_by_Employee_ID = T2.employee_id JOIN Employees AS T3 ON T1.Destroyed_by_Employee_ID = T3.employee_id;",
        "amends": [
            "Do use table alias `T2` for `employee_name` and `T3` for the second `employee_name` instead of `authorizer_name` and `destroyer_name`. Do reference table `Documents_to_be_destroyed AS T1` instead of `documents`. Do join on `T1.Destruction_Authorised_by_Employee_ID = T2.employee_id` instead of `documents.authorized_by = authorizer.id`. Do join on `T1.Destroyed_by_Employee_ID = T3.employee_id` instead of `documents.destroyed_by = destroyer.id`. Do remove the `WHERE documents.status = 'destroyed'` filter instead of keeping it. The amended query now correctly joins the appropriate tables with the proper join conditions to retrieve the authorized and destroying employee names without the status filter."
        ],
        "rules": [
            "1) When combining tables for document destruction records: use Documents_to_be_destroyed as T1, employee_name as T2 for authorizers, and employee_name as T3 for destroyers. 2) When linking authorizers to documents: match rows where T1.Destruction_Authorised_by_Employee_ID equals T2.employee_id. 3) When linking destroyers to documents: match rows where T1.Destroyed_by_Employee_ID equals T3.employee_id. 4) When answering about employee names for document destruction: output T2.name as authorizer_name and T3.name as destroyer_name in that order. 5) When filtering document status: do not apply any status filter as the question asks for all destruction authorizations regardless of status."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT authorizer.name AS authorizer_name, destroyer.name AS destroyer_name\nFROM employees authorizer\nJOIN documents ON documents.authorized_by = authorizer.id\nJOIN employees destroyer ON documents.destroyed_by = destroyer.id\nWHERE documents.status = 'destroyed'",
            "SELECT T2.Employee_Name AS Authorizer_Name, T3.Employee_Name AS Destroyer_Name\nFROM Documents_to_be_Destroyed AS T1\nJOIN Employees AS T2 ON T1.Destruction_Authorised_by_Employee_ID = T2.Employee_ID\nJOIN Employees AS T3 ON T1.Destroyed_by_Employee_ID = T3.Employee_ID"
        ],
        "rule_sql": [
            "SELECT \n    T2.Employee_Name AS authorizer_name,\n    T3.Employee_Name AS destroyer_name\nFROM \n    Documents_to_be_Destroyed AS T1\nLEFT JOIN \n    Employees AS T2 ON T1.Destruction_Authorised_by_Employee_ID = T2.Employee_ID\nLEFT JOIN \n    Employees AS T3 ON T1.Destroyed_by_Employee_ID = T3.Employee_ID"
        ]
    },
    "1578": {
        "db_id": "customers_and_invoices",
        "question": "Count the number of transactions.",
        "ground_truth": "SELECT count(*) FROM Financial_transactions",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS transaction_count FROM Financial_Transactions;"
        ]
    },
    "4860": {
        "db_id": "school_player",
        "question": "How many schools are there?",
        "ground_truth": "SELECT count(*) FROM school",
        "amends": [
            "Do query the `school` table instead of the `students` table, as the intended data source has changed from student records to school information. The amended query now correctly counts records from the school table instead of the students table, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"how many schools\": make sure to count from the \"school\" table instead of the \"students\" table. 2) When counting schools: use the canonical key for counting schools from the school table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;",
            "SELECT COUNT(*) FROM school;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM school;"
        ]
    },
    "4346": {
        "db_id": "tracking_grants_for_research",
        "question": "What is the total amount of grants given by each organisations? Also list the organisation id.",
        "ground_truth": "SELECT sum(grant_amount) ,  organisation_id FROM Grants GROUP BY organisation_id",
        "amends": [
            "Do use `sum(grant_amount)` instead of `SUM(amount)` for the aggregate function and column reference. Do place the `organisation_id` column after the aggregate instead of before it in the SELECT list. Do reference the table as `Grants` (case-sensitive) instead of `grants` in the FROM clause. The amended query now correctly sums the grant_amount column from the Grants table while grouping by organisation_id, matching the intended behavior.",
            "Do place `organisation_id` in the SELECT list after the aggregate function instead of before it, and do remove the alias `total_grant_amount` instead of keeping it. Do maintain the same `SUM(grant_amount)` aggregation and `GROUP BY organisation_id` structure. The amended query now matches RIGHT_SQL's behavior by correctly ordering the columns in the result set."
        ],
        "rules": [
            "1) When the question asks for total amount of grants: use sum(\"grant_amount\") instead of SUM(amount) for the aggregate function. 2) When organizing results by organisation: place the \"organisation_id\" column after the aggregate in the output order. 3) When referencing the grants table: use the exact table name \"Grants\" (case-sensitive) instead of grants. 4) When computing total grants per organization: group by \"organisation_id\" and sum the \"grant_amount\" column.",
            "1) When answering about \"total amount of grants given by each organisation\": make sure the output order: SUM(grant_amount) first, then organisation_id. 2) When the question asks for \"total amount of grants\": compute the sum of grant_amount values. 3) When the question says \"by each organisation\": organize results by organisation_id and compute the sum per group. 4) When producing output: do not include aliases like total_grant_amount in the final result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT organisation_id, SUM(amount) as total_amount FROM grants GROUP BY organisation_id;",
            "SELECT organisation_id, SUM(grant_amount) AS total_grant_amount FROM Grants GROUP BY organisation_id;",
            "SELECT SUM(grant_amount), organisation_id FROM Grants GROUP BY organisation_id"
        ],
        "rule_sql": [
            "SELECT SUM(grant_amount), organisation_id FROM Grants GROUP BY organisation_id;"
        ]
    },
    "6272": {
        "db_id": "city_record",
        "question": "Find the cities which were once a host city after 2010?",
        "ground_truth": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city WHERE T2.year  >  2010",
        "amends": [
            "Do specify `T1.city` with table alias instead of just `city` without qualification. Do join `city AS T1` with `hosting_city AS T2` instead of querying only the `olympics` table. Do use the join condition `T1.city_id = T2.host_city` instead of missing the table relationship entirely. Do filter on `T2.year > 2010` from the hosting_city table instead of filtering `year > 2010` from an unspecified source. The amended query now correctly retrieves cities that hosted Olympics after 2010 by properly joining the city and hosting_city tables with the appropriate relationship."
        ],
        "rules": [
            "1) When answering about \"cities which were once a host city after 2010\": make sure the output order: T1.city 2) When the question mentions \"host city\": \"host city\" actually means \"T2.host_city in schema\" 3) When combining T1 and T2 for shared entities: link rows where T1.city_id = T2.host_city exactly as shown in the amends; keep only matching pairs (inner match). 4) When filtering for years after 2010: filter on T2.year > 2010 from the hosting_city table using the exact literal value 2010."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city FROM olympics WHERE year > 2010",
            "SELECT T1.City \nFROM city AS T1 \nJOIN hosting_city AS T2 ON T1.City_ID = T2.Host_City \nWHERE T2.Year > 2010 \nGROUP BY T1.City"
        ],
        "rule_sql": [
            "SELECT T1.City\nFROM city T1\nINNER JOIN hosting_city T2 ON T1.City_ID = T2.Host_City\nWHERE T2.Year > 2010\nORDER BY T1.City"
        ]
    },
    "2690": {
        "db_id": "storm_record",
        "question": "How many regions do we have?",
        "ground_truth": "SELECT count(*) FROM region",
        "amends": [
            "Do query the `region` table instead of the `countries` table. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"how many regions\": query the \"region\" table instead of the \"countries\" table. 2) When counting regions: count all rows from the \"region\" table using COUNT(*)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries;",
            "SELECT COUNT(*) FROM region;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM region;"
        ]
    },
    "1986": {
        "db_id": "phone_market",
        "question": "Show the carriers that have both phones with memory smaller than 32 and phones with memory bigger than 64.",
        "ground_truth": "SELECT Carrier FROM phone WHERE Memory_in_G  <  32 INTERSECT SELECT Carrier FROM phone WHERE Memory_in_G  >  64",
        "amends": [
            "Do reference the correct table name `phone` instead of `phones` and use the proper column name `Carrier` instead of `carrier`. Do use the correct memory column `Memory_in_G` instead of `memory` and split the condition into two separate queries with `INTERSECT` instead of using contradictory `memory < 32 AND memory > 64` in a single WHERE clause. Do add a second SELECT statement with `Memory_in_G > 64` instead of trying to combine both conditions in one filter, which would never return results due to the impossible range. The amended query now correctly finds carriers that have both phones with less than 32GB memory and phones with more than 64GB memory using INTERSECT instead of the logically impossible single condition."
        ],
        "rules": [
            "1) When the question mentions \"carriers\": use the exact column name \"Carrier\" from the phone table. 2) When the question mentions \"memory\": use the exact column name \"Memory_in_G\" from the phone table. 3) When finding carriers that have both phones with memory smaller than 32 and phones with memory bigger than 64: use two separate queries - one with Memory_in_G < 32 and another with Memory_in_G > 64 - then intersect the results to find carriers that appear in both sets. 4) When choosing table names: use the exact table name \"phone\" instead of \"phones\". 5) When handling memory conditions: do not combine Memory_in_G < 32 AND Memory_in_G > 64 in a single WHERE clause as this creates an impossible condition that would return no results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT carrier FROM phones WHERE memory < 32 AND memory > 64",
            "SELECT Carrier FROM phone WHERE Memory_in_G < 32\nINTERSECT\nSELECT Carrier FROM phone WHERE Memory_in_G > 64"
        ],
        "rule_sql": [
            "SELECT Carrier FROM phone WHERE Memory_in_G < 32\nINTERSECT\nSELECT Carrier FROM phone WHERE Memory_in_G > 64"
        ]
    },
    "4203": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "Which employees have the role with code \"HR\"? Find their names.",
        "ground_truth": "SELECT employee_name FROM Employees WHERE role_code  =  \"HR\"",
        "amends": [
            "Do reference `employee_name` instead of `name` in the SELECT list. Do reference `role_code` instead of `role` in the WHERE filter. Do use double quotes `\"HR\"` instead of single quotes `'HR'` for the string literal. The amended query now correctly matches the intended behavior by selecting the appropriate column names and using the proper string formatting."
        ],
        "rules": [
            "1) When the question asks for employee names: use the exact column token \"employee_name\" instead of \"name\". 2) When filtering by role code: use the exact column token \"role_code\" instead of \"role\". 3) When matching the literal value \"HR\": use double quotes \"HR\" instead of single quotes 'HR' to preserve exact string formatting."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM employees WHERE role = 'HR';",
            "SELECT Employee_Name FROM Employees WHERE Role_Code = \"HR\";"
        ],
        "rule_sql": [
            "SELECT employee_name FROM Employees WHERE role_code = \"HR\""
        ]
    },
    "5966": {
        "db_id": "cre_Theme_park",
        "question": "Find the the names of the tourist attractions that the tourist named Alison visited but Rosalind did not visit.",
        "ground_truth": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  \"Alison\" EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  \"Rosalind\"",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` subquery for set difference logic. Do reference tables as `Tourist_Attractions`, `VISITORS`, and `VISITS` instead of `tourist_attractions`, `tourists`, and `visits`. Do use column names `Tourist_Attraction_ID`, `Tourist_ID`, and `Tourist_Details` instead of `id`, `attraction_id`, and `name`. Do structure joins as `JOIN VISITORS AS T2 JOIN VISITS AS T3 ON` with explicit join conditions `T1.Tourist_Attraction_ID = T3.Tourist_Attraction_ID AND T2.Tourist_ID = T3.Tourist_ID` instead of separate join clauses. Do filter by `Tourist_Details = \"Alison\"` and `Tourist_Details = \"Rosalind\"` in separate query blocks instead of using a subquery with `NOT IN`. Do select only `T1.Name` instead of `t.name`. The amended query now correctly uses set operations to find attractions visited by Alison but not Rosalind, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about tourist attractions visited by Alison but not Rosalind: use EXCEPT set operation instead of NOT IN subquery for set difference logic. 2) When referencing tables: use exact table names \"Tourist_Attractions\" as T1, \"VISITORS\" as T2, and \"VISITS\" as T3 with double quotes. 3) When joining tables: link T1 and T3 where T1.Tourist_Attraction_ID = T3.Tourist_Attraction_ID, and link T2 and T3 where T2.Tourist_ID = T3.Tourist_ID. 4) When filtering by tourist names: use exact literals \"Alison\" and \"Rosalind\" with double quotes for Tourist_Details column. 5) When selecting output: return only T1.Name column from the Tourist_Attractions table. 6) When combining data from multiple tourists: use separate query blocks for Alison and Rosalind with EXCEPT operation between them."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.name \nFROM tourist_attractions t\nJOIN visits v1 ON t.id = v1.attraction_id\nJOIN tourists tourist1 ON v1.tourist_id = tourist1.id\nWHERE tourist1.name = 'Alison'\nAND t.id NOT IN (\n    SELECT t2.id\n    FROM tourist_attractions t2\n    JOIN visits v2 ON t2.id = v2.attraction_id\n    JOIN tourists tourist2 ON v2.tourist_id = tourist2.id\n    WHERE tourist2.name = 'Rosalind'\n)",
            "SELECT Name\nFROM Tourist_Attractions\nWHERE Tourist_Attraction_ID IN (\n    SELECT T3.Tourist_Attraction_ID\n    FROM Visitors AS T2\n    JOIN Visits AS T3 ON T2.Tourist_ID = T3.Tourist_ID\n    WHERE T2.Tourist_Details = 'Alison'\n)\nEXCEPT\nSELECT Name\nFROM Tourist_Attractions\nWHERE Tourist_Attraction_ID IN (\n    SELECT T3.Tourist_Attraction_ID\n    FROM Visitors AS T2\n    JOIN Visits AS T3 ON T2.Tourist_ID = T3.Tourist_ID\n    WHERE T2.Tourist_Details = 'Rosalind'\n)"
        ],
        "rule_sql": [
            "SELECT T1.Name \nFROM \"Tourist_Attractions\" AS T1\nJOIN \"VISITS\" AS T3 ON T1.Tourist_Attraction_ID = T3.Tourist_Attraction_ID\nJOIN \"VISITORS\" AS T2 ON T2.Tourist_ID = T3.Tourist_ID\nWHERE T2.Tourist_Details = \"Alison\"\nEXCEPT\nSELECT T1.Name \nFROM \"Tourist_Attractions\" AS T1\nJOIN \"VISITS\" AS T3 ON T1.Tourist_Attraction_ID = T3.Tourist_Attraction_ID\nJOIN \"VISITORS\" AS T2 ON T2.Tourist_ID = T3.Tourist_ID\nWHERE T2.Tourist_Details = \"Rosalind\""
        ]
    },
    "1317": {
        "db_id": "performance_attendance",
        "question": "Show the names of members and the location of the performances they attended.",
        "ground_truth": "SELECT T2.Name ,  T3.Location FROM member_attendance AS T1 JOIN member AS T2 ON T1.Member_ID  =  T2.Member_ID JOIN performance AS T3 ON T1.Performance_ID  =  T3.Performance_ID",
        "amends": [
            "Do use table aliases `T2` and `T3` instead of `m` and `p`. Do reference columns `T2.Name` and `T3.Location` instead of `m.name` and `p.location`. Do add an intermediate table `member_attendance AS T1` instead of omitting it. Do change the join structure to `JOIN member AS T2 ON T1.Member_ID = T2.Member_ID` and `JOIN performance AS T3 ON T1.Performance_ID = T3.Performance_ID` instead of directly joining `members` to `performances` with incorrect join condition `m.member_id = p.performance_id`. Do use proper join keys `Member_ID` and `Performance_ID` through the attendance bridge table instead of incorrectly joining member ID to performance ID. The amended query now correctly retrieves member names and performance locations through the proper association table relationship."
        ],
        "rules": [
            "1) When answering about \"names of members and location of performances they attended\": make sure the output order: T2.Name, T3.Location 2) When the question mentions \"members\": use table \"member\" as T2 with column \"Name\" 3) When the question mentions \"performances\": use table \"performance\" as T3 with column \"Location\" 4) When combining member and performance attendance data: use intermediate table \"member_attendance\" as T1 to link T2 and T3 5) When joining T1 to T2: link rows where T1.Member_ID = T2.Member_ID 6) When joining T1 to T3: link rows where T1.Performance_ID = T3.Performance_ID 7) When retrieving attendance relationships: keep only matching pairs through the inner join structure using the bridge table"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.name, p.location FROM members m JOIN performances p ON m.member_id = p.performance_id;",
            "SELECT T2.Name, T3.Location\nFROM member_attendance AS T1\nJOIN member AS T2 ON T1.Member_ID = T2.Member_ID\nJOIN performance AS T3 ON T1.Performance_ID = T3.Performance_ID"
        ],
        "rule_sql": [
            "SELECT T2.Name, T3.Location\nFROM member_attendance AS T1\nINNER JOIN member AS T2 ON T1.Member_ID = T2.Member_ID\nINNER JOIN performance AS T3 ON T1.Performance_ID = T3.Performance_ID\nORDER BY T2.Name, T3.Location;"
        ]
    },
    "6510": {
        "db_id": "scientist_1",
        "question": "How many scientists do not have any projects assigned to them?",
        "ground_truth": "SELECT count(*) FROM scientists WHERE ssn NOT IN (SELECT scientist FROM AssignedTo)",
        "amends": [
            "Do filter with `WHERE ssn NOT IN (SELECT scientist FROM AssignedTo)` instead of `WHERE project_id IS NULL` to correctly identify scientists not assigned to any project. Do use a subquery to check against the `AssignedTo` table instead of relying on a potentially incorrect NULL check in the `project_id` column. The amended query now correctly matches the RIGHT_SQL's behavior by identifying scientists who are not present in the assignment records."
        ],
        "rules": [
            "1) When answering about scientists without projects: use a subquery to check against the AssignedTo table instead of checking for NULL values. 2) When identifying scientists not assigned to any project: filter where ssn NOT IN (SELECT scientist FROM AssignedTo) to correctly match scientists who are not present in assignment records. 3) When counting scientists: use the canonical key ssn to identify unique scientists rather than counting all rows with COUNT(*)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM scientists WHERE project_id IS NULL;",
            "SELECT COUNT(*) FROM Scientists WHERE SSN NOT IN (SELECT Scientist FROM AssignedTo)"
        ],
        "rule_sql": [
            "SELECT COUNT(SSN) FROM Scientists WHERE SSN NOT IN (SELECT Scientist FROM AssignedTo)"
        ]
    },
    "6574": {
        "db_id": "wine_1",
        "question": "Give the maximum price and score for wines produced in the appelation St. Helena.",
        "ground_truth": "SELECT max(Price) ,  max(Score) FROM WINE WHERE Appelation  =  \"St. Helena\"",
        "amends": [
            "Do reference table `WINE` instead of `wines` in the FROM clause. Do use column names `Price` and `Score` instead of `price` and `score` in the SELECT list. Do use double quotes around the string literal \"St. Helena\" instead of single quotes. The amended query now correctly references the intended table and columns while maintaining the same aggregation logic and filtering condition."
        ],
        "rules": [
            "1) When answering about maximum price and score for wines: make sure the output order: MAX(\"Price\"), MAX(\"Score\"). 2) When the question mentions \"wines produced in the appelation St. Helena\": use table \"WINE\" and filter where \"appelation\" equals \"St. Helena\". 3) When the question asks for maximum values: compute the maximum of \"Price\" and maximum of \"Score\" using the exact column names with proper casing. 4) When handling text literals: use double quotes around \"St. Helena\" exactly as specified in the schema requirements."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(price), MAX(score) FROM wines WHERE appelation = 'St. Helena';",
            "SELECT MAX(Price) AS \"Maximum Price\", MAX(Score) AS \"Maximum Score\" FROM wine WHERE Appelation = \"St. Helena\""
        ],
        "rule_sql": [
            "SELECT MAX(\"Price\"), MAX(\"Score\") FROM \"wine\" WHERE \"Appelation\" = \"St. Helena\""
        ]
    },
    "5096": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "How many customers do we have?",
        "ground_truth": "SELECT count(*) FROM CUSTOMERS",
        "amends": [
            "Do query the `CUSTOMERS` table instead of the `orders` table. Do count all records from the customers table instead of counting from the orders table. The amended query now correctly counts customer records instead of order records."
        ],
        "rules": [
            "1) When answering about \"how many customers\": make sure to count all records from the \"CUSTOMERS\" table instead of the \"orders\" table. 2) When counting customer records: use the canonical key for counting all records in the \"CUSTOMERS\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders;",
            "SELECT COUNT(*) FROM Customers;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Customers;"
        ]
    },
    "2358": {
        "db_id": "csu_1",
        "question": "For each Orange county campus, report the number of degrees granted after 2000.",
        "ground_truth": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  \"Orange\" AND T2.year  >=  2000 GROUP BY T1.campus",
        "amends": [
            "Do join `campuses AS T1` with `degrees AS T2` on `T1.id = T2.campus` instead of querying only the `degrees` table. Do reference `T1.campus` and `T1.county` instead of directly using `campus` and `county` from the degrees table. Do use `sum(T2.degrees)` instead of `COUNT(*)` to sum actual degree counts rather than counting rows. Do filter with `T2.year >= 2000` instead of `year > 2000` to include the year 2000. Do specify `T1.county = \"Orange\"` instead of `county = 'Orange'` to reference the correct table's county field. The amended query now correctly aggregates degree counts from the joined tables with proper table references and inclusive year filtering."
        ],
        "rules": [
            "1) When answering about \"Orange county campus\" degrees after 2000: join campuses table as T1 with degrees table as T2 using T1.id = T2.campus to link campus information with degree data. 2) When the question mentions \"Orange county\": use T1.county = \"Orange\" exactly as specified with double quotes. 3) When the question mentions \"degrees granted after 2000\": use T2.year >= 2000 to include year 2000 and later years. 4) When counting degrees: use sum(T2.degrees) to sum actual degree counts rather than counting rows. 5) When grouping by campus: use T1.campus as the grouping key and reference it in the output. 6) When producing output: report campus name from T1.campus and the sum of degrees as degrees_count."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT campus, COUNT(*) as degrees_count \nFROM degrees \nWHERE county = 'Orange' AND year > 2000 \nGROUP BY campus;",
            "SELECT T1.Campus, SUM(T2.Degrees) AS TotalDegrees FROM Campuses AS T1 JOIN degrees AS T2 ON T1.Id = T2.Campus WHERE T1.County = \"Orange\" AND T2.Year >= 2000 GROUP BY T1.Campus"
        ],
        "rule_sql": [
            "SELECT T1.Campus, SUM(T2.Degrees) AS degrees_count FROM Campuses T1 JOIN degrees T2 ON T1.Id = T2.Campus WHERE T1.County = \"Orange\" AND T2.Year >= 2000 GROUP BY T1.Campus"
        ]
    },
    "3723": {
        "db_id": "mountain_photos",
        "question": "How many distinct kinds of camera lenses are used to take photos of mountains in the country 'Ethiopia'?",
        "ground_truth": "SELECT count(DISTINCT T2.camera_lens_id) FROM mountain AS T1 JOIN photos AS T2 ON T1.id  =  T2.mountain_id WHERE T1.country  =  'Ethiopia'",
        "amends": [
            "Do select `count(DISTINCT T2.camera_lens_id)` instead of `COUNT(*)` to count distinct camera lenses rather than all photos. Do change the FROM source to `mountain AS T1 JOIN photos AS T2` instead of `photos JOIN camera_lenses JOIN locations`, replacing the camera_lenses and locations tables with a mountain table. Do use the join condition `T1.id = T2.mountain_id` instead of `photos.lens_id = camera_lenses.id` and `photos.location_id = locations.id`, changing the relationship from lens and location joins to a direct mountain-photo relationship. Do move the country filter to `T1.country = 'Ethiopia'` instead of `locations.country = 'Ethiopia'`, applying it directly to the mountain table rather than a locations table. Do remove the `photos.subject = 'mountains'` filter entirely instead of keeping it, as the mountain table inherently represents this relationship. The amended query now correctly counts distinct camera lenses used for mountains in Ethiopia, matching the intended behavior."
        ],
        "rules": [
            "1) When counting distinct camera lenses: use count(DISTINCT T2.camera_lens_id) instead of COUNT(*) to count unique camera lens identifiers. 2) When the question involves mountains and photos: use mountain AS T1 JOIN photos AS T2 instead of joining camera_lenses and locations tables. 3) When joining mountain and photos tables: use the condition T1.id = T2.mountain_id to link mountains to their photos. 4) When filtering by country 'Ethiopia': apply T1.country = 'Ethiopia' directly to the mountain table instead of using a locations table. 5) When the subject is inherently about mountains: do not include a photos.subject = 'mountains' filter as the mountain table relationship already represents this."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM photos \nJOIN camera_lenses ON photos.lens_id = camera_lenses.id \nJOIN locations ON photos.location_id = locations.id \nWHERE locations.country = 'Ethiopia' AND photos.subject = 'mountains';",
            "SELECT COUNT(DISTINCT T2.camera_lens_id) \nFROM mountain AS T1 \nJOIN photos AS T2 ON T1.id = T2.mountain_id \nWHERE T1.Country = 'Ethiopia'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T2.camera_lens_id) \nFROM mountain AS T1 \nJOIN photos AS T2 ON T1.id = T2.mountain_id \nWHERE T1.Country = 'Ethiopia'"
        ]
    },
    "3158": {
        "db_id": "station_weather",
        "question": "show all train numbers and names ordered by their time from early to late.",
        "ground_truth": "SELECT train_number ,  name FROM train ORDER BY TIME",
        "amends": [
            "Do select `name` instead of `train_name` from the source table. Do reference table `train` instead of `trains` as the data source. Do order by `TIME` instead of `train_number ASC` for the sort criteria. The amended query now correctly retrieves train information from the proper table with the appropriate column names and sorting logic."
        ],
        "rules": [
            "1) When the question asks for train names: use column \"name\" from table \"train\" instead of \"train_name\". 2) When the question asks for train numbers: use column \"train_number\" from table \"train\". 3) When ordering trains from early to late: sort by column \"TIME\" in ascending order instead of by \"train_number\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT train_number, train_name FROM trains ORDER BY train_number ASC;",
            "SELECT train_number, name FROM train ORDER BY time ASC;"
        ],
        "rule_sql": [
            "SELECT train_number, name FROM train ORDER BY time ASC;"
        ]
    },
    "1680": {
        "db_id": "theme_gallery",
        "question": "Return the themes, dates, and attendance for exhibitions that happened in 2004.",
        "ground_truth": "SELECT T2.theme ,  T1.date ,  T1.attendance FROM exhibition_record AS T1 JOIN exhibition AS T2 ON T1.exhibition_id  =  T2.exhibition_id WHERE T2.year  =  2004",
        "amends": [
            "Do specify table aliases `T2.theme`, `T1.date`, and `T1.attendance` instead of unqualified column names. Do join `exhibition_record AS T1` with `exhibition AS T2` on `T1.exhibition_id = T2.exhibition_id` instead of querying a single table. Do filter on `T2.year = 2004` instead of using `date LIKE '2004%'` for exact year matching. The amended query now correctly joins related tables and uses proper year filtering instead of string pattern matching on date values."
        ],
        "rules": [
            "1) When answering about exhibitions: make sure to join exhibition_record AS T1 with exhibition AS T2 on T1.exhibition_id = T2.exhibition_id and keep only matching pairs (inner match). 2) When the question mentions \"themes\": \"themes\" actually means \"T2.theme\" in schema. 3) When the question mentions \"dates\": \"dates\" actually means \"T1.date\" in schema. 4) When the question mentions \"attendance\": \"attendance\" actually means \"T1.attendance\" in schema. 5) When filtering for exhibitions that happened in 2004: use T2.year = 2004 for exact year matching instead of string pattern matching on date values. 6) When producing output: make sure the output order is T2.theme, T1.date, T1.attendance."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT theme, date, attendance FROM exhibitions WHERE date LIKE '2004%';",
            "SELECT T2.Theme, T1.Date, T1.Attendance\nFROM exhibition_record AS T1\nJOIN exhibition AS T2 ON T1.Exhibition_ID = T2.Exhibition_ID\nWHERE T2.Year = 2004"
        ],
        "rule_sql": [
            "SELECT T2.Theme, T1.Date, T1.Attendance\nFROM exhibition_record AS T1\nINNER JOIN exhibition AS T2 ON T1.Exhibition_ID = T2.Exhibition_ID\nWHERE T2.Year = 2004\nORDER BY T2.Theme, T1.Date, T1.Attendance"
        ]
    },
    "6287": {
        "db_id": "city_record",
        "question": "In February, which city marks the highest temperature?",
        "ground_truth": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1",
        "amends": [
            "Do select `city` from the `city` table instead of selecting `city` and `MAX(temperature)` from `weather_data`. Do join `city` with `temperature` on `city_id` instead of querying a single `weather_data` table. Do order by `Feb` column instead of ordering by `temperature` after aggregation. Do remove the `WHERE month = 'February'` filter and `GROUP BY city` clause since the February data is now directly accessed through the `Feb` column. The amended query now correctly retrieves cities ordered by their February temperatures from related tables instead of attempting to aggregate monthly data from a single table."
        ],
        "rules": [
            "1) When answering about \"highest temperature in February\": make sure the output order: city ordered by Feb column descending with limit 1\n2) When the question mentions \"city\": \"city\" actually means \"city\" column from \"city\" table\n3) When the question mentions \"temperature in February\": \"February temperature\" actually means \"Feb\" column in \"temperature\" table\n4) When combining city and temperature tables: link rows where city.city_id = temperature.city_id and keep only matching pairs (inner match)\n5) When the question asks for \"highest\": rank rows by Feb column in descending direction and keep the first 1 row\n6) When handling text literals: do not use 'February' literal since February data is directly accessed through the Feb column"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, MAX(temperature) FROM weather_data WHERE month = 'February' GROUP BY city ORDER BY temperature DESC LIMIT 1;",
            "SELECT c.City FROM city c JOIN temperature t ON c.City_ID = t.City_ID ORDER BY t.Feb DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT city.City FROM city INNER JOIN temperature ON city.City_ID = temperature.City_ID ORDER BY temperature.Feb DESC LIMIT 1"
        ]
    },
    "4656": {
        "db_id": "college_3",
        "question": "What are the rooms for members of the faculty who are professors and who live in building NEB?",
        "ground_truth": "SELECT Room FROM FACULTY WHERE Rank  =  \"Professor\" AND Building  =  \"NEB\"",
        "amends": [
            "Do use `Room` instead of `room` for the column name in the SELECT list. Do use `Rank` instead of `position` for the column name in the WHERE filter. Do use `Professor` instead of `professor` for the string literal value. Do use `Building` instead of `building` for the column name in the WHERE filter. Do use double quotes around string literals instead of single quotes. The amended query now correctly matches the RIGHT_SQL's behavior with proper column names and string formatting."
        ],
        "rules": [
            "1) When selecting room information: use \"Room\" (not \"room\") as the column name in the output. 2) When filtering by faculty position: use \"Rank\" (not \"position\") as the column name in the condition. 3) When specifying professor rank: use \"Professor\" (not \"professor\") as the exact string literal value. 4) When filtering by building: use \"Building\" (not \"building\") as the column name in the condition. 5) When using string literals in conditions: wrap them in double quotes instead of single quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT room FROM faculty WHERE position = 'professor' AND building = 'NEB';",
            "SELECT Room FROM Faculty WHERE Rank = \"Professor\" AND Building = \"NEB\""
        ],
        "rule_sql": [
            "SELECT Room FROM Faculty WHERE Rank = \"Professor\" AND Building = \"NEB\";"
        ]
    },
    "255": {
        "db_id": "musical",
        "question": "What are the names of actors ordered descending by the year in which their musical was awarded?",
        "ground_truth": "SELECT T1.Name FROM actor AS T1 JOIN musical AS T2 ON T1.Musical_ID  =  T2.Musical_ID ORDER BY T2.Year DESC",
        "amends": [
            "Do select `T1.Name` instead of `actors.name` to use the table alias. Do join `musical AS T2` instead of omitting it to access the required column. Do use `ON T1.Musical_ID = T2.Musical_ID` instead of no join condition to properly relate the tables. Do order by `T2.Year` instead of `musicals.award_year` to reference the correct column name from the joined table. The amended query now correctly joins the tables and references the proper columns to match the intended behavior."
        ],
        "rules": [
            "1) When answering about actor names ordered by musical award year: make sure the output order: T1.Name. 2) When the question mentions \"actors\": \"actors\" actually means \"T1.Name in schema\". 3) When combining T1 and T2 for shared entities: link rows where T1.Musical_ID = T2.Musical_ID exactly as shown in the amends; keep only matching pairs (inner match). 4) When ordering by musical award year: order by T2.Year in descending direction."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT actors.name FROM actors ORDER BY musicals.award_year DESC;",
            "SELECT T1.Name FROM actor AS T1 JOIN musical AS T2 ON T1.Musical_ID = T2.Musical_ID ORDER BY T2.Year DESC"
        ],
        "rule_sql": [
            "SELECT T1.Name \nFROM actor T1 \nINNER JOIN musical T2 ON T1.Musical_ID = T2.Musical_ID \nORDER BY T2.Year DESC;"
        ]
    },
    "5568": {
        "db_id": "products_gen_characteristics",
        "question": "Find the name of the products that have the color description \"red\" and have the characteristic name \"fast\".",
        "ground_truth": "SELECT product_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  \"red\" AND t3.characteristic_name  =  \"fast\"",
        "amends": [
            "Do select `product_name` instead of `p.name` and use table aliases `t1`, `t2`, `t3`, `t4` instead of `p`, `c`, `ch`. Do join `product_characteristics AS t2` on `t1.product_id = t2.product_id` instead of directly joining `characteristics`, and join `CHARACTERISTICS AS t3` on `t2.characteristic_id = t3.characteristic_id` instead of `p.characteristic_id = ch.id`. Do join `ref_colors AS t4` on `t1.color_code = t4.color_code` instead of `colors c ON p.color_id = c.id`. Do filter on `t4.color_description = \"red\"` instead of `c.description = 'red'` and `t3.characteristic_name = \"fast\"` instead of `ch.name = 'fast'`. The amended query now correctly uses the proper table relationships and column references to match the intended logic."
        ],
        "rules": [
            "1) When selecting product names from the Products table: use \"product_name\" as the output column instead of p.name. 2) When joining tables for this query: use table aliases t1 for Products, t2 for product_characteristics, t3 for CHARACTERISTICS, and t4 for ref_colors. 3) When combining Products with product_characteristics: link rows where t1.product_id = t2.product_id. 4) When combining product_characteristics with CHARACTERISTICS: link rows where t2.characteristic_id = t3.characteristic_id. 5) When combining Products with ref_colors: link rows where t1.color_code = t4.color_code. 6) When filtering for red color: use t4.color_description = \"red\" as the condition. 7) When filtering for fast characteristic: use t3.characteristic_name = \"fast\" as the condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.name FROM products p JOIN colors c ON p.color_id = c.id JOIN characteristics ch ON p.characteristic_id = ch.id WHERE c.description = 'red' AND ch.name = 'fast';",
            "SELECT t1.product_name \nFROM Products AS t1\nJOIN Product_Characteristics AS t2 ON t1.product_id = t2.product_id\nJOIN Characteristics AS t3 ON t2.characteristic_id = t3.characteristic_id\nJOIN Ref_Colors AS t4 ON t1.color_code = t4.color_code\nWHERE t4.color_description = 'red' AND t3.characteristic_name = 'fast'"
        ],
        "rule_sql": [
            "SELECT t1.product_name\nFROM Products t1\nJOIN Product_Characteristics t2 ON t1.product_id = t2.product_id\nJOIN Characteristics t3 ON t2.characteristic_id = t3.characteristic_id\nJOIN Ref_Colors t4 ON t1.color_code = t4.color_code\nWHERE t4.color_description = 'red'\nAND t3.characteristic_name = 'fast'"
        ]
    },
    "286": {
        "db_id": "twitter_1",
        "question": "Find the name and email for the users who have more than one follower.",
        "ground_truth": "SELECT T1.name ,  T1.email FROM user_profiles AS T1 JOIN follows AS T2 ON T1.uid  =  T2.f1 GROUP BY T2.f1 HAVING count(*)  >  1",
        "amends": [
            "Do select `T1.name` and `T1.email` with table aliases instead of `name` and `email` without aliases. Do use `FROM user_profiles AS T1 JOIN follows AS T2` with an explicit join instead of `FROM users` as a single table. Do add the join condition `ON T1.uid = T2.f1` instead of omitting any join relationship. Do remove the `WHERE follower_count > 1` filter instead of keeping it. Do add `GROUP BY T2.f1` grouping instead of omitting aggregation. Do move the count filter to `HAVING count(*) > 1` instead of using `WHERE follower_count > 1`. The amended query now correctly identifies users with more than one follower by counting actual follow relationships rather than relying on a potentially incorrect follower_count column."
        ],
        "rules": [
            "1) When answering about \"users who have more than one follower\": make sure the output order: T1.name, T1.email 2) When the question mentions \"users\": \"users\" actually means \"user_profiles as T1\" in schema 3) When combining T1 and T2 for shared entities: link rows where T1.uid = T2.f1 exactly as shown in the amends; keep only matching pairs (inner match) 4) When the question asks for \"count of followers\": compute the number of rows using the grouping key T2.f1 5) When the question asks for \"more than one follower\": filter groups where count(*) > 1 using HAVING instead of WHERE"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, email FROM users WHERE follower_count > 1",
            "SELECT T1.name, T1.email\nFROM user_profiles AS T1\nJOIN follows AS T2 ON T1.uid = T2.f1\nGROUP BY T2.f1\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T1.name, T1.email\nFROM user_profiles AS T1\nINNER JOIN follows AS T2 ON T1.uid = T2.f1\nGROUP BY T2.f1\nHAVING COUNT(*) > 1"
        ]
    },
    "1713": {
        "db_id": "epinions_1",
        "question": "Find each target user's name and average trust score.",
        "ground_truth": "SELECT T1.name ,  avg(trust) FROM useracct AS T1 JOIN trust AS T2 ON T1.u_id  =  T2.target_u_id GROUP BY T2.target_u_id",
        "amends": [
            "Do select `T1.name` and `avg(trust)` instead of `user_name` and `AVG(score)`. Do join `useracct AS T1` with `trust AS T2` on `T1.u_id = T2.target_u_id` instead of querying only the `users` table. Do group by `T2.target_u_id` instead of `user_id`. The amended query now correctly calculates average trust scores by joining the appropriate tables and grouping on the target user identifier, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"each target user's name and average trust score\": make sure the output order: T1.name, avg(trust). 2) When the question mentions \"target user's name\": \"name\" actually means \"T1.name\" in schema. 3) When the question mentions \"average trust score\": \"trust score\" actually means \"avg(trust)\" in schema. 4) When combining useracct as T1 and trust as T2 for shared entities: link rows where T1.u_id = T2.target_u_id exactly as shown; keep only matching pairs (inner match). 5) When the question says \"per target user\": organize results by T2.target_u_id and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT user_name, AVG(score) FROM users GROUP BY user_id;",
            "SELECT T1.name, AVG(T2.trust) AS avg_trust FROM useracct AS T1 JOIN trust AS T2 ON T1.u_id = T2.target_u_id GROUP BY T2.target_u_id"
        ],
        "rule_sql": [
            "SELECT T1.name, AVG(T2.trust) AS avg_trust FROM useracct T1 INNER JOIN trust T2 ON T1.u_id = T2.target_u_id GROUP BY T2.target_u_id, T1.name ORDER BY T1.name, avg_trust;"
        ]
    },
    "3099": {
        "db_id": "behavior_monitoring",
        "question": "Find the first names of teachers whose email address contains the word \"man\".",
        "ground_truth": "SELECT first_name FROM Teachers WHERE email_address LIKE '%man%'",
        "amends": [
            "Do reference the `email_address` column instead of `email` to correctly access the email field. Do use the proper table name `Teachers` (case-sensitive) instead of `teachers` to match the actual schema. The amended query now correctly filters for email addresses containing 'man' and returns the appropriate first names from the Teachers table."
        ],
        "rules": [
            "1) When the question mentions \"email address\": use the exact column token \"email_address\" from the Teachers table. 2) When filtering for email addresses containing the word \"man\": use the exact literal pattern '%man%' with case-sensitive matching. 3) When selecting first names from the Teachers table: use the exact table name \"Teachers\" (case-sensitive) as specified in the schema. 4) When answering about teacher first names: make sure the output order includes only the first_name column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM teachers WHERE email LIKE '%man%';",
            "SELECT first_name FROM Teachers WHERE email_address LIKE '%man%';"
        ],
        "rule_sql": [
            "SELECT first_name FROM Teachers WHERE email_address LIKE '%man%';"
        ]
    },
    "2338": {
        "db_id": "csu_1",
        "question": "What is the campus fee of \"San Francisco State University\" in year 1996?",
        "ground_truth": "SELECT campusfee FROM campuses AS T1 JOIN csu_fees AS T2 ON T1.id  =  t2.campus WHERE t1.campus  =  \"San Francisco State University\" AND T2.year  =  1996",
        "amends": [
            "Do select `campusfee` from the `campuses` table instead of `campus_fee` from `universities`. Do join `csu_fees` as `T2` on `T1.id = T2.campus` instead of querying a single table. Do filter on `t1.campus = \"San Francisco State University\"` instead of `name = 'San Francisco State University'` and do filter on `T2.year = 1996` instead of `year = 1996`. The amended query now correctly retrieves the campus fee by joining the appropriate tables with the correct relationship and filtering criteria, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about campus fee: select \"campusfee\" from the \"campuses\" table instead of \"campus_fee\" from \"universities\". 2) When combining \"campuses\" as T1 and \"csu_fees\" as T2: link rows where T1.id = T2.campus and keep only matching pairs (inner match). 3) When filtering for \"San Francisco State University\": use T1.campus = \"San Francisco State University\" instead of name = 'San Francisco State University'. 4) When filtering for year 1996: use T2.year = 1996 instead of year = 1996."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT campus_fee FROM universities WHERE name = 'San Francisco State University' AND year = 1996;",
            "SELECT csu_fees.CampusFee \nFROM Campuses \nJOIN csu_fees ON Campuses.Id = csu_fees.Campus \nWHERE Campuses.Campus = 'San Francisco State University' \nAND csu_fees.Year = 1996"
        ],
        "rule_sql": [
            "SELECT csu_fees.CampusFee \nFROM Campuses \nINNER JOIN csu_fees ON Campuses.Id = csu_fees.Campus \nWHERE Campuses.Campus = \"San Francisco State University\" \nAND csu_fees.Year = 1996"
        ]
    },
    "2867": {
        "db_id": "icfp_1",
        "question": "Find the titles of all the papers written by \"Aaron Turon\".",
        "ground_truth": "SELECT t3.title FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid WHERE  t1.fname  =  \"Aaron\" AND t1.lname  =  \"Turon\"",
        "amends": [
            "Do use a three-table join structure with `authors AS t1 JOIN authorship AS t2 ON t1.authid = t2.authid JOIN papers AS t3 ON t2.paperid = t3.paperid` instead of querying only the `papers` table directly. Do filter on `t1.fname = \"Aaron\" AND t1.lname = \"Turon\"` instead of the incorrect `author = 'Aaron Turon'` which doesn't match the schema. Do select `t3.title` with proper table qualification instead of just `title`. The amended query now correctly joins through the authorship relationship table to find papers by author name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"papers written by Aaron Turon\": use a three-table join structure with authors AS T1 JOIN authorship AS T2 ON T1.authid = T2.authid JOIN papers AS T3 ON T2.paperid = T3.paperid. 2) When the question mentions \"Aaron Turon\": filter on T1.fname = \"Aaron\" AND T1.lname = \"Turon\" instead of a single author column. 3) When selecting paper titles: select T3.title with proper table qualification instead of just title."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM papers WHERE author = 'Aaron Turon';",
            "SELECT t3.title \nFROM Authors AS t1 \nJOIN Authorship AS t2 ON t1.authID = t2.authID \nJOIN Papers AS t3 ON t2.paperID = t3.paperID \nWHERE t1.fname = 'Aaron' AND t1.lname = 'Turon'"
        ],
        "rule_sql": [
            "SELECT T3.title FROM Authors AS T1 JOIN Authorship AS T2 ON T1.authID = T2.authID JOIN Papers AS T3 ON T2.paperID = T3.paperID WHERE T1.fname = 'Aaron' AND T1.lname = 'Turon'"
        ]
    },
    "3952": {
        "db_id": "hospital_1",
        "question": "List the names of all distinct nurses ordered by alphabetical order?",
        "ground_truth": "SELECT DISTINCT name FROM nurse ORDER BY name",
        "amends": [
            "Do add `DISTINCT` instead of omitting it to eliminate duplicate name values. Do change the table reference from `nurses` to `nurse` to match the correct table name. Do remove the explicit `ASC` direction from the `ORDER BY` clause since ascending order is the default. The amended query now correctly returns unique nurse names in alphabetical order, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"distinct nurses\": use DISTINCT to eliminate duplicate values from the \"name\" column. 2) When referring to the nurses table: use the exact table name \"nurse\" instead of \"nurses\". 3) When ordering results alphabetically: use ORDER BY on the \"name\" column without specifying ASC direction since ascending order is the default."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM nurses ORDER BY name ASC;",
            "SELECT DISTINCT Name FROM Nurse ORDER BY Name;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Name FROM Nurse ORDER BY Name;"
        ]
    },
    "5706": {
        "db_id": "dorm_1",
        "question": "Find the last name of students who is either female (sex is F) and living in the city of code BAL or male (sex is M) and in age of below 20.",
        "ground_truth": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20",
        "amends": [
            "Do use column name `lname` instead of `last_name` and table name `student` instead of `students`. Do change filter condition to `city_code = 'BAL'` instead of `city = 'BAL'` for the female students. Do change age comparison to `age < 20` instead of `age > 20` for the male students. Do use `UNION` to combine two separate queries instead of using `OR` conditions in a single `WHERE` clause. Do remove the parentheses around the combined conditions since the `UNION` approach eliminates the need for complex boolean logic. The amended query now correctly retrieves female students from Baltimore and male students under 20 years old using separate targeted queries combined with union."
        ],
        "rules": [
            "1) When the question mentions \"last name\": use the exact column token \"lname\" instead of \"last_name\". 2) When the question refers to the \"students\" table: use the exact table token \"student\" instead of \"students\". 3) When filtering for female students living in Baltimore: use the exact condition \"city_code = 'BAL'\" instead of \"city = 'BAL'\". 4) When filtering for male students below age 20: use the exact comparison \"age < 20\" instead of \"age > 20\". 5) When combining results for different student groups: use UNION to combine separate queries for each group instead of using OR conditions in a single WHERE clause."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM students WHERE (sex = 'F' AND city = 'BAL') OR (sex = 'M' AND age > 20);",
            "SELECT lname FROM student WHERE sex = 'F' AND city_code = 'BAL'\nUNION\nSELECT lname FROM student WHERE sex = 'M' AND age < 20"
        ],
        "rule_sql": [
            "SELECT lname FROM student WHERE sex = 'F' AND city_code = 'BAL' UNION SELECT lname FROM student WHERE sex = 'M' AND age < 20"
        ]
    },
    "1196": {
        "db_id": "apartment_rentals",
        "question": "Show the start dates and end dates of all the apartment bookings.",
        "ground_truth": "SELECT booking_start_date ,  booking_end_date FROM Apartment_Bookings",
        "amends": [
            "Do reference `booking_start_date` and `booking_end_date` columns instead of `start_date` and `end_date`. Do query from `Apartment_Bookings` table instead of `bookings` table. Do remove the `WHERE property_type = 'house'` filter instead of keeping it, as the correct query selects all apartment bookings without type filtering. The amended query now correctly retrieves booking dates from the apartment-specific table without unnecessary filtering."
        ],
        "rules": [
            "1) When answering about apartment bookings: use the table \"Apartment_Bookings\" instead of \"bookings\". 2) When selecting start dates and end dates: use columns \"booking_start_date\" and \"booking_end_date\" instead of \"start_date\" and \"end_date\". 3) When retrieving all apartment bookings: do not apply any property type filtering as the table already contains only apartment bookings."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT start_date, end_date FROM bookings WHERE property_type = 'house';",
            "SELECT booking_start_date, booking_end_date FROM Apartment_Bookings;"
        ],
        "rule_sql": [
            "SELECT booking_start_date, booking_end_date FROM Apartment_Bookings;"
        ]
    },
    "3402": {
        "db_id": "manufacturer",
        "question": "Give me the names and prices of furnitures which some companies are manufacturing.",
        "ground_truth": "SELECT t1.name ,  t2.price_in_dollar FROM furniture AS t1 JOIN furniture_manufacte AS t2 ON t1.Furniture_ID  =  t2.Furniture_ID",
        "amends": [
            "Do select `t1.name` and `t2.price_in_dollar` instead of `name` and `price`. Do use `JOIN` between `furniture AS t1` and `furniture_manufacte AS t2` instead of querying only `furnitures`. Do specify the join condition `ON t1.Furniture_ID = t2.Furniture_ID` instead of using a subquery with `WHERE company_id IN (SELECT company_id FROM companies)`. Do remove the subquery filter entirely instead of keeping it. The amended query now correctly joins the furniture and manufacturer tables to retrieve the appropriate name and price data."
        ],
        "rules": [
            "1) When selecting furniture names and prices: use \"t1.name\" for furniture names and \"t2.price_in_dollar\" for prices instead of \"name\" and \"price\". 2) When combining furniture and manufacturer information: join \"furniture AS t1\" with \"furniture_manufacte AS t2\" using the condition \"t1.Furniture_ID = t2.Furniture_ID\" instead of using subqueries. 3) When retrieving furniture manufactured by companies: remove any subquery filters about company IDs and rely solely on the join between furniture and manufacturer tables."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, price FROM furnitures WHERE company_id IN (SELECT company_id FROM companies)",
            "SELECT t1.Name, t2.Price_in_Dollar FROM furniture AS t1 JOIN furniture_manufacte AS t2 ON t1.Furniture_ID = t2.Furniture_ID"
        ],
        "rule_sql": [
            "SELECT t1.Name, t2.Price_in_Dollar FROM furniture AS t1 JOIN furniture_manufacte AS t2 ON t1.Furniture_ID = t2.Furniture_ID"
        ]
    },
    "188": {
        "db_id": "bike_1",
        "question": "What are the ids of the trips that lasted the longest and how long did they last?",
        "ground_truth": "SELECT id ,  duration FROM trip ORDER BY duration DESC LIMIT 3",
        "amends": [
            "Do select `id` instead of `trip_id` and change the table reference to `trip` instead of `trips`. Do order by `duration DESC` instead of `ASC` and increase the limit to `3` instead of `1`. The amended query now correctly retrieves the top 3 longest durations from the trip table."
        ],
        "rules": [
            "1) When the question asks for \"ids of the trips\": use the exact column token \"id\" from the \"trip\" table instead of \"trip_id\". 2) When the question asks about \"trips\": use the exact table name \"trip\" instead of \"trips\". 3) When the question asks for \"longest\" durations: order by \"duration\" in descending order (DESC) instead of ascending order (ASC). 4) When the question asks for multiple longest trips: increase the limit to 3 instead of 1 to retrieve the top 3 results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT trip_id, duration FROM trips ORDER BY duration ASC LIMIT 1;",
            "SELECT id, duration FROM trip ORDER BY duration DESC LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT id, duration FROM trip ORDER BY duration DESC LIMIT 3;"
        ]
    },
    "799": {
        "db_id": "coffee_shop",
        "question": "Show the shop addresses ordered by their opening year.",
        "ground_truth": "SELECT address FROM shop ORDER BY open_year",
        "amends": [
            "Do reference table `shop` instead of `shops` in the FROM clause. Do order by `open_year` instead of `closing_year` in the ORDER BY clause. The amended query now correctly references the intended table and sorts by the appropriate year column."
        ],
        "rules": [
            "1) When the question asks about shop addresses: use the exact table name \"shop\" instead of \"shops\" 2) When ordering by opening year: use the exact column name \"open_year\" instead of \"closing_year\" 3) When answering about shop addresses ordered by opening year: make sure the output order is address followed by ordering on open_year"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address FROM shops ORDER BY closing_year DESC;",
            "SELECT Address FROM shop ORDER BY Open_Year;"
        ],
        "rule_sql": [
            "SELECT Address, Open_Year FROM shop ORDER BY Open_Year"
        ]
    },
    "5": {
        "db_id": "department_management",
        "question": "What are the names of the heads who are born outside the California state?",
        "ground_truth": "SELECT name FROM head WHERE born_state != 'California'",
        "amends": [
            "Do reference table `head` instead of `heads` and use column `born_state` instead of `birth_state` while keeping the same filter condition `!= 'California'` and maintaining the same `SELECT name` structure, ensuring the query now correctly accesses the intended table and column to match the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about \"heads\": use table \"head\" instead of \"heads\" to access the correct data. 2) When the question mentions \"born outside the California state\": use column \"born_state\" instead of \"birth_state\" and filter with the condition != 'California' to exclude California-born individuals. 3) When selecting output columns: maintain the exact output structure \"name\" from the head table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM heads WHERE birth_state != 'California';",
            "SELECT name FROM head WHERE born_state != 'California'"
        ],
        "rule_sql": [
            "SELECT name FROM head WHERE born_state != 'California';"
        ]
    },
    "4936": {
        "db_id": "store_product",
        "question": "Find the most prominent max page size among all the products.",
        "ground_truth": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `max_page_size` instead of `MAX(page_size)`. Do use `FROM product` instead of `FROM products`. Do add `GROUP BY max_page_size` instead of omitting it. Do change the ORDER BY to `count(*) DESC` instead of `page_size DESC`. The amended query now correctly groups by max_page_size and orders by the count of each group rather than the page_size values themselves, matching the intended behavior.",
            "Do remove the `COUNT(*) as count` column from the SELECT list instead of including it, and do remove the explicit column reference in the ORDER BY clause instead of keeping `count(*)` since the aggregate function is implicitly understood. Do maintain the `GROUP BY max_page_size` grouping and `LIMIT 1` restriction without change. The amended query now matches the intended behavior of selecting only the max_page_size with the highest frequency."
        ],
        "rules": [
            "1) When the question asks for \"most prominent max page size\": select the exact column \"max_page_size\" instead of using MAX(page_size). 2) When querying the products table: use the exact table name \"product\" instead of \"products\". 3) When finding the most prominent value by frequency: group by \"max_page_size\" and order by count(*) DESC instead of ordering by the column values themselves. 4) When the question asks for \"most prominent\" (highest frequency): return only the top result using LIMIT 1.",
            "1) When answering about \"most prominent max page size\": make sure the output order: max_page_size only without additional columns like count. 2) When the question asks for the most prominent value: group by max_page_size and order by the count of rows in descending direction, keeping only the first 1 row. 3) When computing prominence: count rows using the implicit grouping count rather than explicitly selecting the count column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(page_size) FROM products ORDER BY page_size DESC LIMIT 1;",
            "SELECT max_page_size, COUNT(*) as count\nFROM product\nGROUP BY max_page_size\nORDER BY count(*) DESC\nLIMIT 1;",
            "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "876": {
        "db_id": "chinook_1",
        "question": "What are the names and ids of artists with 3 or more albums, listed in alphabetical order?",
        "ground_truth": "SELECT T2.Name ,  T1.ArtistId FROM ALBUM AS T1 JOIN ARTIST AS T2 ON T1.ArtistId  =  T2.ArtistID GROUP BY T1.ArtistId HAVING COUNT(*)  >=  3 ORDER BY T2.Name",
        "amends": [
            "Do select `T2.Name` and `T1.ArtistId` instead of `artist_id` and `name`. Do join `ALBUM AS T1` with `ARTIST AS T2` on `T1.ArtistId = T2.ArtistID` instead of querying only the `artists` table. Do add `GROUP BY T1.ArtistId` and move the count filter to `HAVING COUNT(*) >= 3` instead of using `WHERE album_count >= 3`. Do order by `T2.Name` instead of `name`. The amended query now correctly identifies artists with at least 3 albums by joining the album table and counting actual album records, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about artists with 3 or more albums: select \"T2.Name\" and \"T1.ArtistId\" as output columns. 2) When combining album and artist tables: link rows where \"T1.ArtistId\" = \"T2.ArtistID\" and keep only matching pairs (inner match). 3) When counting albums per artist: group by \"T1.ArtistId\" and count the number of rows using the canonical key. 4) When filtering for artists with 3 or more albums: apply the condition COUNT(*) >= 3 in the having clause. 5) When ordering results alphabetically: order by \"T2.Name\" in ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT artist_id, name FROM artists WHERE album_count >= 3 ORDER BY name ASC;",
            "SELECT T2.Name, T1.ArtistId\nFROM Album AS T1\nJOIN Artist AS T2 ON T1.ArtistId = T2.ArtistId\nGROUP BY T1.ArtistId\nHAVING COUNT(*) >= 3\nORDER BY T2.Name;"
        ],
        "rule_sql": [
            "SELECT T2.Name, T1.ArtistId\nFROM Album T1\nINNER JOIN Artist T2 ON T1.ArtistId = T2.ArtistId\nGROUP BY T1.ArtistId\nHAVING COUNT(*) >= 3\nORDER BY T2.Name ASC;"
        ]
    },
    "1013": {
        "db_id": "university_basketball",
        "question": "Find the number of universities that have over a 20000 enrollment size for each affiliation type.",
        "ground_truth": "SELECT count(*) ,  affiliation FROM university WHERE enrollment  >  20000 GROUP BY affiliation",
        "amends": [
            "Do use the table name `university` instead of `universities` to reference the correct data source. Do place the `affiliation` column after the aggregate function in the SELECT list instead of before it, maintaining the same logical grouping. Do keep the `COUNT(*)` aggregation and `GROUP BY affiliation` clause unchanged as they correctly calculate counts per affiliation. Do preserve the `WHERE enrollment > 20000` filter without modification as it properly restricts to large enrollment institutions. The amended query now matches the intended behavior of counting universities by affiliation for those with enrollment exceeding 20,000.",
            "Do place `affiliation` after the aggregate function instead of before it in the SELECT list. Do use `count(*)` without a space instead of `COUNT(*)` with uppercase. Do maintain the same `WHERE enrollment > 20000` filter and `GROUP BY affiliation` clause. The amended query now correctly positions the aggregate function first while preserving the same logical behavior as the right SQL."
        ],
        "rules": [
            "1) When referencing the university data source: use the exact table name \"university\" instead of \"universities\". 2) When organizing output columns for counting by affiliation: place the \"affiliation\" column after the count result in the output order. 3) When counting universities with enrollment over 20000 per affiliation type: use COUNT(*) aggregation with GROUP BY affiliation and WHERE enrollment > 20000 filter unchanged.",
            "1) When the question asks for \"number of universities\" per affiliation type: use count(*) to count all matching rows for each group. 2) When filtering universities by enrollment size: apply the condition enrollment > 20000 to include only universities with enrollment greater than 20000. 3) When grouping results by affiliation type: organize the output by the affiliation column and compute counts separately for each affiliation value. 4) When ordering output columns: place the aggregate function count(*) before the grouping column affiliation in the SELECT list."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT affiliation, COUNT(*) FROM universities WHERE enrollment > 20000 GROUP BY affiliation;",
            "SELECT affiliation, COUNT(*) FROM university WHERE enrollment > 20000 GROUP BY affiliation",
            "SELECT count(*), affiliation FROM university WHERE enrollment > 20000 GROUP BY affiliation"
        ],
        "rule_sql": [
            "SELECT COUNT(*), Affiliation FROM university WHERE Enrollment > 20000 GROUP BY Affiliation;"
        ]
    },
    "4704": {
        "db_id": "college_3",
        "question": "What are the names of courses that give either 3 credits, or 1 credit and 4 hours?",
        "ground_truth": "SELECT CName FROM COURSE WHERE Credits  =  3 UNION SELECT CName FROM COURSE WHERE Credits  =  1 AND Hours  =  4",
        "amends": [
            "Do use `UNION` to combine two separate queries instead of a single query with incorrect operator precedence. Do reference the correct column name `CName` instead of `name` and table name `COURSE` instead of `courses`. Do structure the first query as `SELECT CName FROM COURSE WHERE Credits = 3` instead of mixing conditions with incorrect precedence. Do structure the second query as `SELECT CName FROM COURSE WHERE Credits = 1 AND Hours = 4` instead of the original flawed condition that would evaluate as `credits = 3 OR (credits = 1 AND hours = 4)`. Do ensure proper separation of the two distinct filtering conditions through union instead of relying on operator precedence that could produce incorrect results. The amended query now correctly returns courses with exactly 3 credits OR courses with both 1 credit and 4 hours, matching the intended logic."
        ],
        "rules": [
            "1) When the question asks for course names: use the exact column name \"CName\" from table \"COURSE\" instead of \"name\" or \"courses\". 2) When filtering for courses with exactly 3 credits: select rows where \"Credits\" equals 3. 3) When filtering for courses with exactly 1 credit and 4 hours: select rows where \"Credits\" equals 1 AND \"Hours\" equals 4. 4) When combining results from multiple filtering conditions: use UNION to combine the results of separate queries rather than relying on operator precedence in a single WHERE clause. 5) When structuring the query: create two separate SELECT statements - one for each condition set - and combine them with UNION to ensure correct logical separation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM courses WHERE credits = 3 OR credits = 1 AND hours = 4;",
            "SELECT CName FROM Course WHERE Credits = 3\nUNION\nSELECT CName FROM Course WHERE Credits = 1 AND Hours = '4'"
        ],
        "rule_sql": [
            "SELECT CName FROM Course WHERE Credits = 3\nUNION\nSELECT CName FROM Course WHERE Credits = 1 AND Hours = '4';"
        ]
    },
    "392": {
        "db_id": "flight_1",
        "question": "What are the numbers of all flights that can cover a distance of more than 2000?",
        "ground_truth": "SELECT flno FROM Flight WHERE distance  >  2000",
        "amends": [
            "Do reference the table as `Flight` instead of `flights` and use the column alias `flno` instead of `flight_number` in the SELECT list. Do change the WHERE filter to use `>` comparison for `distance` instead of `<`, making it select flights with distance greater than 2000 instead of less than 2000. The amended query now correctly matches the intended logic of selecting flight numbers from the Flight table where distance exceeds 2000."
        ],
        "rules": [
            "1) When answering about \"numbers of all flights that can cover a distance of more than 2000\": make sure the output order: flno. 2) When the question mentions \"flight numbers\": \"flight numbers\" actually means \"flno in schema\". 3) When the question mentions \"distance of more than 2000\": use > comparison with distance column and literal value 2000. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 5) When handling text literals: do not change case, spacing, or punctuation of numeric values like 2000."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE distance < 2000;",
            "SELECT flno FROM flight WHERE distance > 2000"
        ],
        "rule_sql": [
            "SELECT \"flno\" FROM \"flight\" WHERE \"distance\" > 2000 ORDER BY \"flno\""
        ]
    },
    "4166": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "List all document type codes and document type names.",
        "ground_truth": "SELECT document_type_code ,  document_type_name FROM Ref_document_types",
        "amends": [
            "Do select `document_type_code` and `document_type_name` instead of `document_code` and `type_name`. Do reference table `Ref_document_types` instead of `document_types`. The amended query now correctly retrieves the document type code and name from the appropriate reference table."
        ],
        "rules": [
            "1) When answering about \"document type codes and document type names\": make sure the output order: document_type_code, document_type_name. 2) When the question mentions \"document type codes\": \"document type codes\" actually means \"document_type_code in Ref_document_types\". 3) When the question mentions \"document type names\": \"document type names\" actually means \"document_type_name in Ref_document_types\". 4) When selecting from reference tables: use the exact table name \"Ref_document_types\" as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_code, type_name FROM document_types",
            "SELECT Document_Type_Code, Document_Type_Name FROM Ref_Document_Types;"
        ],
        "rule_sql": [
            "SELECT Document_Type_Code, Document_Type_Name FROM Ref_Document_Types"
        ]
    },
    "629": {
        "db_id": "store_1",
        "question": "List the name of tracks belongs to genre Rock and whose media type is MPEG audio file.",
        "ground_truth": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = \"Rock\" AND T3.name = \"MPEG audio file\";",
        "amends": [
            "Do use `T2.name` instead of `t.Name` for the SELECT column. Do reference `genres AS T1` instead of `genres g` as the first table in FROM. Do use `JOIN tracks AS T2 ON T1.id = T2.genre_id` instead of `JOIN tracks t` with `t.GenreId = g.GenreId` for the join condition. Do use `JOIN media_types AS T3 ON T3.id = T2.media_type_id` instead of `JOIN media_types m ON t.MediaTypeId = m.MediaTypeId` for the media types join. Do use double quotes for string literals `\"Rock\"` and `\"MPEG audio file\"` instead of single quotes. The amended query now correctly joins tables using proper column references and matches the intended behavior."
        ],
        "rules": [
            "1) When answering about \"name of tracks\": make sure the output order: T2.name\n2) When the question mentions \"genre Rock\": \"Rock\" actually means T1.name = \"Rock\" in schema\n3) When the question mentions \"media type is MPEG audio file\": \"MPEG audio file\" actually means T3.name = \"MPEG audio file\" in schema\n4) When combining T1 and T2 for shared entities: link rows where T1.id = T2.genre_id exactly as shown in the amends; keep only matching pairs (inner match)\n5) When combining T2 and T3 for shared entities: link rows where T3.id = T2.media_type_id exactly as shown in the amends; keep only matching pairs (inner match)\n6) When handling text literals: do not change case, spacing, or punctuation - use exact literals \"Rock\" and \"MPEG audio file\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.Name \nFROM tracks t\nJOIN genres g ON t.GenreId = g.GenreId\nJOIN media_types m ON t.MediaTypeId = m.MediaTypeId\nWHERE g.Name = 'Rock' AND m.Name = 'MPEG audio file';",
            "SELECT T2.name \nFROM genres AS T1 \nJOIN tracks AS T2 ON T1.id = T2.genre_id \nJOIN media_types AS T3 ON T3.id = T2.media_type_id \nWHERE T1.name = \"Rock\" AND T3.name = \"MPEG audio file\""
        ],
        "rule_sql": [
            "SELECT tracks.name \nFROM tracks\nINNER JOIN genres ON tracks.genre_id = genres.id\nINNER JOIN media_types ON tracks.media_type_id = media_types.id\nWHERE genres.name = \"Rock\" \nAND media_types.name = \"MPEG audio file\"\nORDER BY tracks.name"
        ]
    },
    "6604": {
        "db_id": "train_station",
        "question": "What is the average and maximum number of total passengers for train stations in London or Glasgow?",
        "ground_truth": "SELECT avg(total_passengers) ,  max(total_passengers) FROM station WHERE LOCATION  =  'London' OR LOCATION  =  'Glasgow'",
        "amends": [
            "Do reference table `station` instead of `train_stations` and use column `LOCATION` instead of `city` for filtering. Do remove the aliases `average_passengers` and `max_passengers` instead of keeping them. Do use lowercase `avg` and `max` functions instead of uppercase `AVG` and `MAX`. The amended query now correctly filters by location rather than city and matches the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"train stations\": use table \"station\" instead of \"train_stations\". 2) When filtering by location names \"London\" or \"Glasgow\": use column \"LOCATION\" instead of \"city\" and match exact literals 'London' and 'Glasgow'. 3) When computing aggregates: use lowercase function names \"avg\" and \"max\" instead of uppercase \"AVG\" and \"MAX\". 4) When selecting output columns: do not use aliases like \"average_passengers\" and \"max_passengers\" - return the raw aggregate results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(total_passengers) as average_passengers, MAX(total_passengers) as max_passengers \nFROM train_stations \nWHERE city = 'London' OR city = 'Glasgow';",
            "SELECT avg(Total_Passengers), max(Total_Passengers) FROM station WHERE Location = 'London' OR Location = 'Glasgow'"
        ],
        "rule_sql": [
            "SELECT avg(Total_Passengers), max(Total_Passengers) FROM station WHERE Location = 'London' OR Location = 'Glasgow'"
        ]
    },
    "835": {
        "db_id": "chinook_1",
        "question": "What is the name of the most common genre in all tracks?",
        "ground_truth": "SELECT T1.Name FROM GENRE AS T1 JOIN TRACK AS T2 ON T1.GenreId  =  T2.GenreId GROUP BY T2.GenreId ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.Name` instead of `genre` and `COUNT(*) as count`. Do join `GENRE AS T1` to `TRACK AS T2` instead of querying only `tracks`. Do use `ON T1.GenreId = T2.GenreId` instead of no join condition. Do group by `T2.GenreId` instead of `genre`. Do order by `COUNT(*) DESC` instead of `count DESC`. The amended query now correctly retrieves the genre name from the GENRE table while counting tracks by their genre ID, matching the RIGHT_SQL's behavior.",
            "Do remove `COUNT(*) as count` from the SELECT list instead of including it, as the RIGHT_SQL only needs the genre name. Do keep the same FROM clause with `Genre AS T1 JOIN Track AS T2` on `T1.GenreId = T2.GenreId` instead of changing it. Do maintain the GROUP BY on `T2.GenreId` instead of altering it. Do preserve the ORDER BY on `COUNT(*) DESC` and LIMIT 1 instead of modifying them. The amended query now correctly returns only the genre name with the highest track count instead of including an unnecessary count column, matching RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"most common genre in all tracks\": make sure the output order: T1.Name first, then count. 2) When the question mentions \"genre\": \"genre\" actually means \"T1.Name in schema\" for the genre name. 3) When counting tracks per genre: compute the number of rows using T2.GenreId as the counting key. 4) When combining GENRE (T1) and TRACK (T2) for shared entities: link rows where T1.GenreId = T2.GenreId exactly; keep only matching pairs (inner match). 5) When the question asks for \"most common\": rank rows by count in descending order and keep the first 1 row.",
            "1) When answering about \"the most common genre in all tracks\": make sure the output order: only include the genre name column without any count columns. 2) When combining Genre and Track tables: link rows where T1.GenreId = T2.GenreId and keep only matching pairs (inner match). 3) When grouping by genre: organize results by T2.GenreId and compute the count of tracks per genre. 4) When the question asks for \"most common\": rank rows by track count in descending order and keep only the first 1 row. 5) When counting tracks: compute the number of rows using the Track table's GenreId as the counting key."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT genre, COUNT(*) as count FROM tracks GROUP BY genre ORDER BY count DESC LIMIT 1;",
            "SELECT T1.Name, COUNT(*) as count FROM Genre AS T1 JOIN Track AS T2 ON T1.GenreId = T2.GenreId GROUP BY T2.GenreId ORDER BY COUNT(*) DESC LIMIT 1",
            "SELECT T1.Name \nFROM Genre AS T1 \nJOIN Track AS T2 ON T1.GenreId = T2.GenreId \nGROUP BY T2.GenreId \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Name \nFROM Genre T1\nINNER JOIN Track T2 ON T1.GenreId = T2.GenreId\nGROUP BY T2.GenreId\nORDER BY COUNT(T2.GenreId) DESC\nLIMIT 1;"
        ]
    },
    "1973": {
        "db_id": "products_for_hire",
        "question": "What are the daily hire costs for the products with substring 'Book' in its name?",
        "ground_truth": "SELECT daily_hire_cost FROM Products_for_hire WHERE product_name LIKE '%Book%'",
        "amends": [
            "Do select `daily_hire_cost` instead of `name, hire_cost` from the column list. Do reference table `Products_for_hire` instead of `products` in the FROM clause. Do filter on `product_name` instead of `name` in the WHERE condition. Do remove the ORDER BY clause instead of keeping `hire_cost DESC` since the right query doesn't include sorting. The amended query now correctly retrieves daily hire costs from the appropriate table using the correct column names for filtering."
        ],
        "rules": [
            "1) When answering about daily hire costs for products with 'Book' in the name: select only the \"daily_hire_cost\" column from the output. 2) When the question mentions \"products\": use table \"Products_for_hire\" instead of \"products\". 3) When filtering for products with substring 'Book' in the name: use column \"product_name\" with the pattern '%Book%' instead of column \"name\". 4) When the question does not specify ordering: do not include any sorting in the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, hire_cost FROM products WHERE name LIKE '%Book%' ORDER BY hire_cost DESC;",
            "SELECT daily_hire_cost FROM Products_for_Hire WHERE product_name LIKE '%Book%'"
        ],
        "rule_sql": [
            "SELECT daily_hire_cost FROM Products_for_Hire WHERE product_name LIKE '%Book%'"
        ]
    },
    "211": {
        "db_id": "bike_1",
        "question": "What is the average latitude and longitude of the starting points of all trips?",
        "ground_truth": "SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id",
        "amends": [
            "Do select `avg(T1.lat)` and `avg(T1.long)` instead of `AVG(start_lat)` and `AVG(start_lng)` with aliases. Do use `FROM station AS T1 JOIN trip AS T2` instead of `FROM trips` alone. Do add `ON T1.id = T2.start_station_id` join condition instead of omitting table relationships. Do remove `WHERE start_station_id IS NOT NULL` filter instead of keeping it, as the join condition now properly handles station relationships. The amended query correctly joins station and trip tables to calculate averages based on actual station coordinates rather than trip coordinates directly."
        ],
        "rules": [
            "1) When answering about \"average latitude and longitude of starting points\": make sure the output order: avg_latitude, avg_longitude. 2) When the question mentions \"starting points of all trips\": use the exact column tokens \"T1.lat\" for latitude and \"T1.long\" for longitude from the station table. 3) When combining station and trip tables: link rows where \"T1.id = T2.start_station_id\" exactly as shown and keep only matching pairs (inner match). 4) When computing averages: calculate average of \"T1.lat\" as avg_latitude and average of \"T1.long\" as avg_longitude. 5) When the question asks for all trips: do not apply any WHERE filter conditions as the join condition properly handles station relationships."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(start_lat) AS avg_latitude, AVG(start_lng) AS avg_longitude FROM trips WHERE start_station_id IS NOT NULL",
            "SELECT AVG(T1.lat) AS average_latitude, AVG(T1.long) AS average_longitude FROM station AS T1 JOIN trip AS T2 ON T1.id = T2.start_station_id"
        ],
        "rule_sql": [
            "SELECT AVG(T1.lat) AS avg_latitude, AVG(T1.long) AS avg_longitude\nFROM station T1\nINNER JOIN trip T2 ON T1.id = T2.start_station_id"
        ]
    },
    "2558": {
        "db_id": "county_public_safety",
        "question": "Show the crime rate of counties with a city having white percentage more than 90.",
        "ground_truth": "SELECT T2.Crime_rate FROM city AS T1 JOIN county_public_safety AS T2 ON T1.County_ID  =  T2.County_ID WHERE T1.White  >  90",
        "amends": [
            "Do select `T2.Crime_rate` instead of `county, crime_rate` to return only the crime rate column. Do use `FROM city AS T1 JOIN county_public_safety AS T2` instead of `FROM counties` to join the city and county_public_safety tables. Do apply the join condition `ON T1.County_ID = T2.County_ID` instead of no join condition to properly relate the tables. Do filter on `T1.White > 90` instead of `city_white_percentage > 90` to use the correct column name and table reference. The amended query now correctly joins the city and county_public_safety tables to retrieve crime rates for cities with white population exceeding 90%."
        ],
        "rules": [
            "1) When answering about \"crime rate of counties with a city having white percentage more than 90\": make sure the output order: T2.Crime_rate. 2) When the question mentions \"counties with a city having white percentage more than 90\": combine city AS T1 and county_public_safety AS T2 using inner match where T1.County_ID = T2.County_ID. 3) When filtering for cities with white percentage more than 90: apply condition T1.White > 90. 4) When selecting output columns: return only T2.Crime_rate instead of multiple columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT county, crime_rate FROM counties WHERE city_white_percentage > 90;",
            "SELECT T2.Crime_rate FROM city AS T1 JOIN county_public_safety AS T2 ON T1.County_ID = T2.County_ID WHERE T1.White > 90"
        ],
        "rule_sql": [
            "SELECT T2.Crime_rate FROM city AS T1 INNER JOIN county_public_safety AS T2 ON T1.County_ID = T2.County_ID WHERE T1.White > 90"
        ]
    },
    "6476": {
        "db_id": "scientist_1",
        "question": "How many different projects are there?",
        "ground_truth": "SELECT count(DISTINCT name) FROM projects",
        "amends": [
            "Do select `count(DISTINCT name)` instead of `COUNT(*)`. Do query from `projects` instead of `employees`. Do remove the asterisk wildcard and instead count distinct names from the projects table, which provides the correct metric of unique project names rather than a simple row count from the wrong table."
        ],
        "rules": [
            "1) When answering about \"how many different projects\": count the number of distinct values in the \"name\" column from the \"projects\" table. 2) When the question mentions \"projects\": query from the \"projects\" table instead of other tables like \"employees\". 3) When counting distinct entities: use count(DISTINCT name) rather than COUNT(*) to get unique values instead of total row count."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees;",
            "SELECT COUNT(DISTINCT Name) FROM Projects;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Name) FROM Projects;"
        ]
    },
    "1209": {
        "db_id": "apartment_rentals",
        "question": "Find the average number of bedrooms of all the apartments.",
        "ground_truth": "SELECT avg(bedroom_count) FROM Apartments",
        "amends": [
            "Do reference the `bedroom_count` column instead of `bedrooms` and query from the `Apartments` table instead of `houses`. Do use lowercase `avg` function instead of uppercase `AVG` to match the corrected query's formatting. The amended query now correctly calculates the average bedroom count from the Apartments table."
        ],
        "rules": [
            "1) When answering about \"average number of bedrooms of all the apartments\": make sure the output order: avg(bedroom_count) 2) When the question mentions \"bedrooms\": \"bedrooms\" actually means \"bedroom_count in schema\" 3) When the question mentions \"apartments\": query from the \"Apartments\" table instead of \"houses\" 4) When computing averages: use lowercase \"avg\" function instead of uppercase \"AVG\" to match the corrected query's formatting"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(bedrooms) FROM houses;",
            "SELECT avg(bedroom_count) FROM Apartments"
        ],
        "rule_sql": [
            "SELECT avg(bedroom_count) FROM Apartments"
        ]
    },
    "576": {
        "db_id": "store_1",
        "question": "What is the email and phone number of Astrid Gruber the customer?",
        "ground_truth": "SELECT email ,  phone FROM customers WHERE first_name = \"Astrid\" AND last_name = \"Gruber\";",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT email, phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';"
        ],
        "rule_sql": [
            "SELECT email, phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';"
        ]
    },
    "3139": {
        "db_id": "assets_maintenance",
        "question": "How many fault status codes are recorded in the fault log parts table?",
        "ground_truth": "SELECT DISTINCT fault_status FROM Fault_Log_Parts",
        "amends": [
            "Do select `DISTINCT fault_status` instead of `COUNT(*)` to return unique values rather than a count. Do reference table `Fault_Log_Parts` instead of `fault_log_parts` with proper case sensitivity. Do remove the `WHERE status_code IS NULL` filter instead of keeping it, as the right query returns all distinct fault status values without filtering. The amended query now correctly returns unique fault status values from the Fault_Log_Parts table, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"how many fault status codes are recorded\": compute the number of distinct values of the exact token \"fault_status\" from table \"Fault_Log_Parts\". 2) When the question mentions \"fault status codes\": \"fault status codes\" actually means \"fault_status in schema\". 3) When choosing identifier delimiters: use exact case-sensitive table name \"Fault_Log_Parts\" as shown in the schema, not lowercase \"fault_log_parts\". 4) When handling the query: do not apply any WHERE filter conditions since the question asks for all recorded fault status codes without filtering."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM fault_log_parts WHERE status_code IS NULL;",
            "SELECT DISTINCT fault_status FROM Fault_Log_Parts;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT fault_status) FROM Fault_Log_Parts;"
        ]
    },
    "3450": {
        "db_id": "hr_1",
        "question": "What are the department ids for which more than 10 employees had a commission?",
        "ground_truth": "SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(commission_pct) > 10",
        "amends": [
            "Do remove `COUNT(*)` from the SELECT list instead of including it, and do remove the WHERE clause filter `commission_pct IS NOT NULL` instead of keeping it. Do change the HAVING clause to use `COUNT(commission_pct) > 10` instead of `COUNT(*) > 10` to count only employees with commission percentages rather than all employees in the department. The amended query now correctly identifies departments where more than 10 employees have commission percentages, matching the intended behavior."
        ],
        "rules": [
            "1) When counting employees with commission percentages: use COUNT(commission_pct) instead of COUNT(*) to count only employees who have commission values. 2) When filtering departments by employee count with commissions: use HAVING COUNT(commission_pct) > 10 to identify departments where more than 10 employees have commission percentages. 3) When answering about department IDs with commission employees: do not include the commission count in the output columns, only show department_id."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department_id, COUNT(*) \nFROM employees \nWHERE commission_pct IS NOT NULL \nGROUP BY department_id \nHAVING COUNT(*) > 10",
            "SELECT DEPARTMENT_ID FROM employees WHERE COMMISSION_PCT IS NOT NULL GROUP BY DEPARTMENT_ID HAVING COUNT(COMMISSION_PCT) > 10"
        ],
        "rule_sql": [
            "SELECT DEPARTMENT_ID FROM employees WHERE COMMISSION_PCT IS NOT NULL GROUP BY DEPARTMENT_ID HAVING COUNT(COMMISSION_PCT) > 10"
        ]
    },
    "1657": {
        "db_id": "theme_gallery",
        "question": "How many artists are above age 46 and joined after 1990?",
        "ground_truth": "SELECT count(*) FROM artist WHERE age  >  46 AND year_join  >  1990",
        "amends": [
            "Do reference table `artist` instead of `artists` in the FROM clause. Do use column `year_join` instead of `joined_year` in the WHERE filter condition. The amended query now correctly references the proper table name and column name while maintaining the same filtering logic for artists over age 46 who joined after 1990, matching the behavior of the right SQL."
        ],
        "rules": [
            "1) When the question mentions \"artists\": use table \"artist\" instead of \"artists\". 2) When the question mentions \"joined after 1990\": use column \"year_join\" instead of \"joined_year\" for the filter condition. 3) When filtering for artists above age 46 and joined after 1990: apply both conditions age > 46 AND year_join > 1990."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM artists WHERE age > 46 AND joined_year > 1990;",
            "SELECT COUNT(*) FROM artist WHERE Age > 46 AND Year_Join > 1990"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM artist WHERE Age > 46 AND Year_Join > 1990;"
        ]
    },
    "6750": {
        "db_id": "activity_1",
        "question": "Who is the advisor of Linda Smith? Give me the first name and last name.",
        "ground_truth": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  \"Linda\" AND T2.lname  =  \"Smith\"",
        "amends": [
            "Do select `T1.fname` and `T1.lname` instead of `advisor.first_name` and `advisor.last_name`. Do use `Faculty AS T1` joined with `Student AS T2` instead of `students` joined with `advisors`. Do join on `T1.FacID = T2.advisor` instead of `students.advisor_id = advisors.id`. Do filter on `T2.fname = \"Linda\"` and `T2.lname = \"Smith\"` instead of `students.first_name = 'Linda'` and `students.last_name = 'Smith'`. The amended query now correctly retrieves faculty names for students named Linda Smith by properly joining the Faculty and Student tables through the advisor relationship."
        ],
        "rules": [
            "1) When answering about \"advisor of Linda Smith\": make sure the output order: T1.fname, T1.lname. 2) When the question mentions \"Linda Smith\": \"Linda\" actually means T2.fname = \"Linda\" and \"Smith\" actually means T2.lname = \"Smith\" in schema. 3) When combining Faculty as T1 and Student as T2 for advisor relationships: link rows where T1.FacID = T2.advisor exactly as shown; keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for literals like \"Linda\" and \"Smith\". 5) When handling text literals: do not change case, spacing, or punctuation for \"Linda\" and \"Smith\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT advisor.first_name, advisor.last_name FROM students JOIN advisors ON students.advisor_id = advisors.id WHERE students.first_name = 'Linda' AND students.last_name = 'Smith'",
            "SELECT T1.Fname, T1.Lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID = T2.Advisor WHERE T2.Fname = 'Linda' AND T2.Lname = 'Smith'"
        ],
        "rule_sql": [
            "SELECT T1.fname, T1.lname FROM Faculty AS T1 INNER JOIN Student AS T2 ON T1.FacID = T2.Advisor WHERE T2.Fname = \"Linda\" AND T2.Lname = \"Smith\""
        ]
    },
    "2371": {
        "db_id": "csu_1",
        "question": "What degrees were conferred in San Francisco State University in the year 2001?",
        "ground_truth": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  \"San Francisco State University\" AND t2.year  =  2001",
        "amends": [
            "Do select `degrees` from the `degrees` table instead of `degree` from `universities`. Do join `campuses` as `T1` with `degrees` as `T2` on `t1.id = t2.campus` instead of querying only the `universities` table. Do filter on `t1.campus = \"San Francisco State University\"` instead of `name = 'San Francisco State University'` and do filter on `t2.year = 2001` instead of `year = 2001`. The amended query now correctly joins the campuses and degrees tables to retrieve the appropriate degree information for the specified campus and year."
        ],
        "rules": [
            "1) When answering about degrees conferred: select from the \"degrees\" table instead of \"universities\" table. 2) When combining campuses and degrees tables: link rows where T1.id = T2.campus and keep only matching pairs (inner match). 3) When the question mentions \"San Francisco State University\": use T1.campus = \"San Francisco State University\" as the filter condition. 4) When the question mentions year 2001: use T2.year = 2001 as the filter condition. 5) When selecting degree information: use T2.degrees as the output column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT degree FROM universities WHERE name = 'San Francisco State University' AND year = 2001;",
            "SELECT T2.Degrees \nFROM Campuses AS T1 \nJOIN degrees AS T2 ON T1.Id = T2.Campus \nWHERE T1.Campus = 'San Francisco State University' \nAND T2.Year = 2001"
        ],
        "rule_sql": [
            "SELECT d.Degrees FROM degrees d JOIN Campuses c ON d.Campus = c.Id WHERE c.Campus = 'San Francisco State University' AND d.Year = 2001"
        ]
    },
    "4599": {
        "db_id": "entertainment_awards",
        "question": "List the name of artworks in ascending alphabetical order.",
        "ground_truth": "SELECT Name FROM artwork ORDER BY Name ASC",
        "amends": [
            "Do use the table name `artwork` instead of `artworks` and select the column `Name` instead of `name`. Do apply `ASC` ordering instead of `DESC` ordering on the `Name` column. The amended query now correctly references the singular table name, uses proper column casing, and applies ascending alphabetical ordering as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks about \"artworks\": use the exact table name \"artwork\" instead of \"artworks\". 2) When selecting the name column: use the exact column name \"Name\" with proper casing instead of \"name\". 3) When ordering alphabetically in ascending order: apply ascending (ASC) ordering on the \"Name\" column instead of descending (DESC) ordering."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM artworks ORDER BY name DESC;",
            "SELECT Name FROM artwork ORDER BY Name ASC;"
        ],
        "rule_sql": [
            "SELECT Name FROM artwork ORDER BY Name ASC;"
        ]
    },
    "152": {
        "db_id": "bike_1",
        "question": "What is the mean longitude for all stations that have never had more than 10 bikes available?",
        "ground_truth": "SELECT avg(long) FROM station WHERE id NOT IN (SELECT station_id FROM status GROUP BY station_id HAVING max(bikes_available)  >  10)",
        "amends": [
            "Do use `avg(long)` instead of `AVG(longitude)` for the aggregate function and column reference. Do reference table `station` instead of `stations` in the FROM clause. Do use `id` instead of `station_id` for the primary key column in the main table. Do add `GROUP BY station_id` and `HAVING max(bikes_available) > 10` in the subquery instead of using a simple filter `WHERE bikes_available > 10`, which ensures we check for stations that have ever had more than 10 bikes available rather than individual status records. The amended query now correctly identifies stations based on their maximum bikes available rather than any single status reading."
        ],
        "rules": [
            "1) When answering about mean longitude for stations: use avg(long) instead of AVG(longitude) for the aggregate function and column reference. 2) When referencing the stations table: use table station instead of stations in the FROM clause. 3) When referencing the primary key column: use id instead of station_id for the main table's primary key. 4) When checking for stations that have never had more than 10 bikes available: use GROUP BY station_id and HAVING max(bikes_available) > 10 in the subquery instead of a simple WHERE bikes_available > 10 filter to ensure checking maximum bikes available rather than individual status records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(longitude) FROM stations WHERE station_id NOT IN (SELECT station_id FROM status WHERE bikes_available > 10);",
            "SELECT AVG(long) \nFROM station \nWHERE id NOT IN (\n    SELECT station_id \n    FROM status \n    GROUP BY station_id \n    HAVING MAX(bikes_available) > 10\n)"
        ],
        "rule_sql": [
            "SELECT AVG(long) \nFROM station \nWHERE id NOT IN (\n    SELECT station_id \n    FROM status \n    GROUP BY station_id \n    HAVING MAX(bikes_available) > 10\n)"
        ]
    },
    "3516": {
        "db_id": "hr_1",
        "question": "What are the department ids, full names, and salaries for employees who make the most in their departments?",
        "ground_truth": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id",
        "amends": [
            "Do select individual columns `first_name`, `last_name`, `salary`, `department_id` instead of concatenating `first_name || ' ' || last_name AS full_name`. Do add `MAX(salary)` to the SELECT list instead of omitting it. Do use a simple `GROUP BY department_id` instead of a correlated subquery with `WHERE salary = (SELECT MAX(salary) FROM employees e2 WHERE e2.department_id = e1.department_id)`. Do remove the `ORDER BY department_id, salary DESC` clause instead of keeping it. The amended query now correctly calculates maximum salary per department using aggregation instead of inefficient correlated subquery matching.",
            "Do include all non-aggregated columns `first_name`, `last_name`, and `salary` in the GROUP BY clause instead of omitting them from the grouping, which would cause incorrect aggregation behavior. Do maintain the column order with `first_name` and `last_name` first instead of starting with `department_id`, though this is purely cosmetic. The amended query now correctly groups by all non-aggregated columns to match the RIGHT_SQL's behavior.",
            "Do remove `first_name` and `last_name` from the GROUP BY clause instead of including them, and do remove the HAVING clause filter `salary = MAX(salary)` instead of keeping it. Do add `department_id` to the SELECT list instead of omitting it, and do change the column order in the SELECT list to match the intended output structure. The amended query now correctly groups by department_id only to find maximum salaries per department, rather than incorrectly grouping by individual employee attributes which would return each employee's own salary as the maximum.",
            "Do include `MAX(salary)` in the SELECT list instead of omitting it. Do add `GROUP BY department_id` instead of using a correlated subquery. Do remove the WHERE clause with the subquery instead of keeping it. Do reorder columns to place `department_id` later in the SELECT list instead of having it first. The amended query now correctly identifies maximum salaries by department using aggregation instead of inefficient correlated subqueries, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"employees who make the most in their departments\": select individual columns \"first_name\", \"last_name\", \"salary\", \"department_id\" instead of concatenating them into a full name. 2) When calculating maximum salary per department: use MAX(salary) in the SELECT list and GROUP BY department_id instead of using a correlated subquery. 3) When the question asks for department-level maximum salaries: organize results by department_id and compute the maximum salary per group. 4) When producing output for this question: do not include an ORDER BY clause as it is not required by the question.",
            "1) When grouping results by department and including individual employee details: include all non-aggregated columns (first_name, last_name, salary) in the grouping clause to prevent incorrect aggregation behavior. 2) When answering about employees who make the most in their departments: maintain the output column order with first_name and last_name appearing before department_id and salary. 3) When computing maximum salary per department: use the MAX(salary) aggregate function while ensuring all individual employee columns are properly grouped.",
            "1) When answering about \"employees who make the most in their departments\": group results by department_id to find maximum salaries per department. 2) When computing maximum salary per department: use MAX(salary) grouped by department_id only, without including individual employee attributes in the grouping. 3) When selecting output columns: include department_id, first_name, last_name, and salary in the result set. 4) When the question asks for \"the most\" in each department: find the maximum salary value within each department group and return the corresponding employee records.",
            "1) When answering about \"employees who make the most in their departments\": include the maximum salary value in the output columns. 2) When grouping by department to find maximum salaries: use GROUP BY department_id instead of correlated subqueries. 3) When selecting output columns: place department_id later in the column order instead of first. 4) When computing maximum salary per department: remove WHERE clauses with subqueries and use aggregation instead."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT department_id, first_name || ' ' || last_name AS full_name, salary\nFROM employees e1\nWHERE salary = (SELECT MAX(salary) FROM employees e2 WHERE e2.department_id = e1.department_id)\nORDER BY department_id, salary DESC;",
            "SELECT department_id, first_name, last_name, salary, MAX(salary) \nFROM employees \nGROUP BY department_id",
            "SELECT department_id, first_name, last_name, salary, MAX(salary) \nFROM employees \nGROUP BY department_id, first_name, last_name, salary \nHAVING salary = MAX(salary)",
            "SELECT department_id, first_name, last_name, salary\nFROM employees e1\nWHERE salary = (\n    SELECT MAX(salary)\n    FROM employees e2\n    WHERE e2.department_id = e1.department_id\n)",
            "SELECT first_name, last_name, salary, department_id, MAX(salary) \nFROM employees \nGROUP BY department_id"
        ],
        "rule_sql": [
            "SELECT first_name, last_name, department_id, salary\nFROM employees e1\nWHERE salary = (\n    SELECT MAX(salary)\n    FROM employees e2\n    WHERE e2.department_id = e1.department_id\n)"
        ]
    },
    "3005": {
        "db_id": "sakila_1",
        "question": "Return the first names of customers who did not rented a film after the date '2005-08-23 02:06:01'.",
        "ground_truth": "SELECT first_name FROM customer WHERE customer_id NOT IN( SELECT customer_id FROM rental WHERE rental_date  >  '2005-08-23 02:06:01' )",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM customer WHERE customer_id NOT IN (SELECT customer_id FROM rental WHERE rental_date > '2005-08-23 02:06:01')"
        ],
        "rule_sql": [
            "SELECT DISTINCT c.first_name\nFROM customer c\nWHERE c.customer_id NOT IN (\n    SELECT r.customer_id\n    FROM rental r\n    WHERE r.rental_date > '2005-08-23 02:06:01'\n)"
        ]
    },
    "4414": {
        "db_id": "network_2",
        "question": "How old is the doctor named Zach?",
        "ground_truth": "SELECT age FROM Person WHERE job  =  'doctor' AND name  =  'Zach'",
        "amends": [
            "Do reference table `Person` instead of `doctors` in the FROM clause. Do add filter condition `job = 'doctor'` instead of omitting it, while keeping the existing `name = 'Zach'` filter in the WHERE clause. The amended query now correctly filters for doctors by their job attribute rather than relying on a potentially incorrect table name assumption, ensuring it matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about a doctor: include the condition that \"job\" must equal 'doctor' to filter for medical professionals. 2) When the question mentions a person named \"Zach\": use the exact literal 'Zach' for the name filter condition. 3) When selecting age information: retrieve the \"age\" column from the Person table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT age FROM doctors WHERE name = 'Zach';",
            "SELECT age FROM Person WHERE name = 'Zach' AND job = 'doctor'"
        ],
        "rule_sql": [
            "SELECT age FROM Person WHERE name = 'Zach' AND job = 'doctor';"
        ]
    },
    "6693": {
        "db_id": "driving_school",
        "question": "How many customers have no payment histories?",
        "ground_truth": "SELECT count(*) FROM Customers WHERE customer_id NOT IN ( SELECT customer_id FROM Customer_Payments );",
        "amends": [
            "Do reference the `Customers` table instead of `customers` in the FROM clause. Do reference the `Customer_Payments` table instead of `payments` in the subquery. The amended query now correctly matches the RIGHT_SQL's behavior with the proper table names."
        ],
        "rules": [
            "1) When answering about \"customers with no payment histories\": use the exact table name \"Customers\" for the main table. 2) When checking for payment histories: use the exact table name \"Customer_Payments\" for the payment records table. 3) When counting customers without payment histories: count rows from \"Customers\" where the customer_id is not found in \"Customer_Payments\" using customer_id as the linking key."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE customer_id NOT IN (SELECT customer_id FROM payments);",
            "SELECT COUNT(*) \nFROM Customers \nWHERE customer_id NOT IN (SELECT customer_id FROM Customer_Payments)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Customers \nWHERE customer_id NOT IN (SELECT customer_id FROM Customer_Payments)"
        ]
    },
    "618": {
        "db_id": "store_1",
        "question": "What is the composer who created the track \"Fast As a Shark\"?",
        "ground_truth": "SELECT composer FROM tracks WHERE name = \"Fast As a Shark\";",
        "amends": [
            "Do reference the column `name` in the WHERE clause instead of `title` to correctly filter by track name rather than title. Do use double quotes for the string literal \"Fast As a Shark\" instead of single quotes for consistent string formatting. The amended query now correctly retrieves composer information by filtering on the track name column instead of a non-existent title column, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about a track by name: use the column \"name\" instead of \"title\" to filter for track names. 2) When filtering for the track \"Fast As a Shark\": use double quotes for the string literal exactly as \"Fast As a Shark\". 3) When retrieving composer information for a specific track: select from the tracks table using the track name column to find the matching composer."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT composer FROM tracks WHERE title = 'Fast As a Shark';",
            "SELECT composer FROM tracks WHERE name = \"Fast As a Shark\";"
        ],
        "rule_sql": [
            "SELECT composer FROM tracks WHERE name = \"Fast As a Shark\";"
        ]
    },
    "670": {
        "db_id": "customers_card_transactions",
        "question": "What are the account ids, customer ids, and account names for all the accounts?",
        "ground_truth": "SELECT account_id ,  customer_id ,  account_name FROM Accounts",
        "amends": [
            "Do remove the `WHERE account_id IS NULL` filter instead of keeping it, as the right query returns all accounts rather than only those with null account IDs. Do reference the table as `Accounts` instead of `accounts` to match the correct table name case. The amended query now correctly returns all account records without filtering and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"all accounts\": remove any filtering conditions that restrict which accounts are returned. 2) When referencing the Accounts table: use the exact table name \"Accounts\" with capital A to match the schema's case sensitivity. 3) When selecting account information: include account_id, customer_id, and account_name columns in the output without any WHERE clause restrictions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT account_id, customer_id, account_name FROM accounts WHERE account_id IS NULL;",
            "SELECT account_id, customer_id, account_name FROM Accounts"
        ],
        "rule_sql": [
            "SELECT account_id, customer_id, account_name FROM Accounts"
        ]
    },
    "989": {
        "db_id": "university_basketball",
        "question": "What is the primary conference of the school that has the lowest acc percent score in the competition?",
        "ground_truth": "SELECT t1.Primary_conference FROM university AS t1 JOIN basketball_match AS t2 ON t1.school_id  =  t2.school_id ORDER BY t2.acc_percent LIMIT 1",
        "amends": [
            "Do select `t1.Primary_conference` instead of `conference`. Do use `FROM university AS t1 JOIN basketball_match AS t2` instead of `FROM schools`. Do add `ON t1.school_id = t2.school_id` join condition instead of no join. Do remove the subquery with `MIN(acc_percent)` instead of keeping it. Do add `ORDER BY t2.acc_percent LIMIT 1` instead of using equality comparison with subquery result. The amended query now correctly retrieves the primary conference from the university with the lowest ACC percentage by joining tables and using ORDER BY with LIMIT instead of a subquery comparison."
        ],
        "rules": [
            "1) When answering about \"primary conference of the school with lowest acc percent score\": make sure the output order: t1.Primary_conference. 2) When combining university and basketball_match tables: link rows where t1.school_id = t2.school_id and keep only matching pairs (inner match). 3) When the question mentions \"lowest acc percent score\": rank rows by t2.acc_percent in ascending order and keep the first 1 row. 4) When the question asks for \"primary conference\": \"primary conference\" actually means \"t1.Primary_conference in schema\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT conference FROM schools WHERE acc_percent = (SELECT MIN(acc_percent) FROM competitions);",
            "SELECT t1.Primary_conference FROM university AS t1 JOIN basketball_match AS t2 ON t1.School_ID = t2.School_ID ORDER BY t2.ACC_Percent LIMIT 1"
        ],
        "rule_sql": [
            "SELECT t1.Primary_conference \nFROM university t1\nINNER JOIN basketball_match t2 ON t1.School_ID = t2.School_ID\nORDER BY t2.ACC_Percent ASC\nLIMIT 1"
        ]
    },
    "330": {
        "db_id": "product_catalog",
        "question": "What are the names of catalog entries with level number 8?",
        "ground_truth": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  \"8\"",
        "amends": [
            "Do select `t1.catalog_entry_name` instead of `name`. Do use `FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2` instead of `FROM catalog_entries`. Do add `ON t1.catalog_entry_id = t2.catalog_entry_id` join condition instead of omitting it. Do use `WHERE t2.catalog_level_number = \"8\"` instead of `WHERE level = 8`. The amended query now correctly joins the necessary tables and filters on the appropriate catalog level attribute."
        ],
        "rules": [
            "1) When selecting catalog entry names: use \"t1.catalog_entry_name\" as the output column instead of \"name\". 2) When accessing catalog entries and their attributes: combine \"Catalog_Contents\" as T1 with \"Catalog_Contents_Additional_Attributes\" as T2 using an inner match where \"t1.catalog_entry_id = t2.catalog_entry_id\". 3) When filtering by level number 8: use the condition \"t2.catalog_level_number = \\\"8\\\"\" with the exact literal value \"8\" in double quotes. 4) When answering about catalog entries with level number 8: make sure the output order includes only \"t1.catalog_entry_name\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM catalog_entries WHERE level = 8;",
            "SELECT t1.catalog_entry_name \nFROM Catalog_Contents AS t1 \nJOIN Catalog_Contents_Additional_Attributes AS t2 \nON t1.catalog_entry_id = t2.catalog_entry_id \nWHERE t2.catalog_level_number = \"8\""
        ],
        "rule_sql": [
            "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 INNER JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id = t2.catalog_entry_id WHERE t2.catalog_level_number = \"8\""
        ]
    },
    "4516": {
        "db_id": "document_management",
        "question": "Return the codes of the document types that do not have a total access count of over 10000.",
        "ground_truth": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING sum(access_count)  >  10000",
        "amends": [
            "Do select `document_type_code` from the `documents` table instead of `code` from `document_types`. Do use `GROUP BY document_type_code` with `HAVING sum(access_count) > 10000` instead of filtering `WHERE total_access_count > 10000` on a different table. Do aggregate individual `access_count` values with `sum()` instead of relying on a pre-aggregated `total_access_count` column. The amended query now correctly calculates the total access count per document type from the source documents table rather than using potentially incorrect pre-computed values.",
            "Do change the HAVING clause condition to `sum(access_count) > 10000` instead of `SUM(access_count) <= 10000`, which reverses the logic from filtering for document types with access counts less than or equal to 10,000 to filtering for those with access counts greater than 10,000. The amended query now correctly identifies document types exceeding the 10,000 access threshold instead of those below it, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"codes of document types that do not have a total access count over 10000\": select \"document_type_code\" from the \"documents\" table instead of \"code\" from \"document_types\". 2) When calculating total access count per document type: use GROUP BY \"document_type_code\" with HAVING sum(\"access_count\") > 10000 instead of filtering WHERE \"total_access_count\" > 10000. 3) When aggregating access counts: compute sum(\"access_count\") from individual document records instead of using pre-aggregated \"total_access_count\" values.",
            "1) When filtering for document types that do not have a total access count over 10000: use the condition sum(access_count) > 10000 to identify document types exceeding the threshold, then return those that do not meet this condition. 2) When grouping by document_type_code: organize results by document_type_code and compute the sum of access_count per group. 3) When handling the literal value 10000: preserve the exact numeric value 10000 without modification."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT code FROM document_types WHERE total_access_count > 10000;",
            "SELECT document_type_code \nFROM Documents \nGROUP BY document_type_code \nHAVING SUM(access_count) <= 10000",
            "SELECT document_type_code \nFROM Documents \nGROUP BY document_type_code \nHAVING SUM(access_count) > 10000"
        ],
        "rule_sql": [
            "SELECT document_type_code \nFROM Documents \nGROUP BY document_type_code \nHAVING SUM(access_count) <= 10000;"
        ]
    },
    "2063": {
        "db_id": "party_people",
        "question": "Show names of parties that does not have any members.",
        "ground_truth": "SELECT party_name FROM party WHERE party_id NOT IN (SELECT party_id FROM Member)",
        "amends": [
            "Do select `party_name` from the `party` table instead of `name` from `parties`. Do use a `WHERE` filter with `party_id NOT IN` subquery instead of `member_count > 0`. Do add a correlated subquery `SELECT party_id FROM Member` to check for membership exclusion instead of counting members directly. Do reference the correct table name `party` instead of `parties`. The amended query now correctly excludes parties that have members by using a NOT IN subquery rather than attempting to count members directly."
        ],
        "rules": [
            "1) When the question asks for \"names of parties\": use the exact column token \"party_name\" from the \"party\" table instead of \"name\" from \"parties\". 2) When the question asks for parties that \"does not have any members\": use a NOT IN subquery with \"party_id NOT IN (SELECT party_id FROM Member)\" instead of checking member_count > 0. 3) When referencing the party table: use the exact table name \"party\" instead of \"parties\". 4) When excluding parties with members: use a correlated subquery that selects \"party_id\" from the \"Member\" table to check for membership exclusion."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM parties WHERE member_count > 0;",
            "SELECT party_name FROM party WHERE Party_ID NOT IN (SELECT Party_ID FROM member)"
        ],
        "rule_sql": [
            "SELECT party_name FROM party WHERE Party_ID NOT IN (SELECT Party_ID FROM member)"
        ]
    },
    "139": {
        "db_id": "bike_1",
        "question": "What is the latitude, longitude, city of the station from which the shortest trip started?",
        "ground_truth": "SELECT T1.lat ,  T1.long ,  T1.city FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id ORDER BY T2.duration LIMIT 1",
        "amends": [
            "Do select `T1.lat`, `T1.long`, and `T1.city` with explicit table aliases instead of `latitude`, `longitude`, and `city` without table qualification. Do join `station AS T1` with `trip AS T2` on `T1.id = T2.start_station_id` instead of querying only the `stations` table without any join. Do order by `T2.duration` instead of the non-existent `trip_duration` column. Do maintain the `LIMIT 1` clause as originally specified. The amended query now correctly joins station and trip data to find the station with the shortest trip duration, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for latitude, longitude, and city: select \"T1.lat\", \"T1.long\", and \"T1.city\" with explicit table aliases instead of unqualified column names. 2) When finding the station from which the shortest trip started: join \"station AS T1\" with \"trip AS T2\" on \"T1.id = T2.start_station_id\" to link trip data to station data. 3) When ordering by shortest trip duration: order by \"T2.duration\" instead of the non-existent \"trip_duration\" column. 4) When limiting to the single shortest trip: maintain the LIMIT 1 clause to return only the top result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT latitude, longitude, city FROM stations ORDER BY trip_duration ASC LIMIT 1;",
            "SELECT T1.lat, T1.long, T1.city\nFROM station AS T1\nJOIN trip AS T2 ON T1.id = T2.start_station_id\nORDER BY T2.duration ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.lat, T1.long, T1.city FROM station AS T1 JOIN trip AS T2 ON T1.id = T2.start_station_id ORDER BY T2.duration ASC LIMIT 1"
        ]
    },
    "641": {
        "db_id": "store_1",
        "question": "How much is the track Fast As a Shark?",
        "ground_truth": "SELECT unit_price FROM tracks WHERE name = \"Fast As a Shark\";",
        "amends": [
            "Do reference the correct column `unit_price` instead of the incorrect column `price` in the SELECT list, ensuring the query retrieves the appropriate pricing data. Do use double quotes `\"Fast As a Shark\"` instead of single quotes `'Fast As a Shark'` for the string literal in the WHERE filter, maintaining consistent string formatting. The amended query now correctly selects the unit price for the specified track name and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the price of a track: use the exact column name \"unit_price\" from the invoice_lines table instead of \"price\". 2) When filtering by track name \"Fast As a Shark\": use double quotes \"Fast As a Shark\" instead of single quotes to maintain consistent string formatting."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT price FROM tracks WHERE name = 'Fast As a Shark';",
            "SELECT unit_price FROM tracks WHERE name = \"Fast As a Shark\";"
        ],
        "rule_sql": [
            "SELECT unit_price FROM tracks WHERE name = \"Fast As a Shark\";"
        ]
    },
    "4956": {
        "db_id": "soccer_2",
        "question": "Find the name and training hours of players whose hours are below 1500.",
        "ground_truth": "SELECT pName ,  HS FROM Player WHERE HS  <  1500",
        "amends": [
            "Do select `pName` and `HS` instead of `name` and `training_hours`. Do use table `Player` instead of `players`. Do apply filter `HS < 1500` instead of `training_hours > 1500`. The amended query now correctly selects the specified columns from the proper table with the appropriate filter condition."
        ],
        "rules": [
            "1) When the question asks for \"name\" and \"training hours\": use columns \"pName\" and \"HS\" from table \"Player\" respectively. 2) When filtering for players whose hours are below 1500: apply condition HS < 1500. 3) When selecting from the players table: use table \"Player\" instead of \"players\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, training_hours FROM players WHERE training_hours > 1500;",
            "SELECT pName, HS FROM Player WHERE HS < 1500;"
        ],
        "rule_sql": [
            "SELECT pName, HS FROM Player WHERE HS < 1500"
        ]
    },
    "5506": {
        "db_id": "voter_2",
        "question": "For each election cycle, report the number of voting records.",
        "ground_truth": "SELECT Election_Cycle ,  count(*) FROM VOTING_RECORD GROUP BY Election_Cycle",
        "amends": [
            "Do use the exact table name `VOTING_RECORD` instead of `voting_records` to match the correct schema. Do use the exact column name `Election_Cycle` with proper capitalization instead of `election_cycle` to ensure accurate column reference. The amended query now correctly references the intended table and column names, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about \"voting records\": use the exact table name \"VOTING_RECORD\" instead of \"voting_records\" to match the schema. 2) When the question mentions \"election cycle\": use the exact column name \"Election_Cycle\" with proper capitalization instead of \"election_cycle\" to ensure accurate column reference. 3) When counting voting records per election cycle: count using the canonical key for voting records (implied by the table structure) and group by \"Election_Cycle\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT election_cycle, COUNT(*) FROM voting_records GROUP BY election_cycle",
            "SELECT Election_Cycle, COUNT(*) AS NumberOfVotingRecords FROM VOTING_RECORD GROUP BY Election_Cycle;"
        ],
        "rule_sql": [
            "SELECT Election_Cycle, COUNT(*) AS NumberOfVotingRecords FROM VOTING_RECORD GROUP BY Election_Cycle;"
        ]
    },
    "4237": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "What are the id of each employee and the number of document destruction authorised by that employee?",
        "ground_truth": "SELECT Destruction_Authorised_by_Employee_ID ,  count(*) FROM Documents_to_be_destroyed GROUP BY Destruction_Authorised_by_Employee_ID",
        "amends": [
            "Do use `Destruction_Authorised_by_Employee_ID` as the column name instead of `employee_id` in both the SELECT list and GROUP BY clause. Do reference the `Documents_to_be_destroyed` table instead of `document_destructions` as the data source. Do omit the alias `destruction_count` instead of including it in the SELECT clause. The amended query now correctly counts document destruction records by the authorized employee ID from the appropriate table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"number of document destruction authorised by that employee\": count the number of records using the canonical key from the Documents_to_be_destroyed table. 2) When the question mentions \"employee id\": use the exact column name \"Destruction_Authorised_by_Employee_ID\" from the Documents_to_be_destroyed table. 3) When the question asks for \"number of document destruction authorised by that employee\" per employee: organize results by \"Destruction_Authorised_by_Employee_ID\" and compute the count per group. 4) When choosing identifier delimiters: do not use backticks or unquoted forms for \"Destruction_Authorised_by_Employee_ID\". 5) When producing output: do not include aliases like \"destruction_count\" in the final result columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT employee_id, COUNT(*) as destruction_count FROM document_destructions GROUP BY employee_id;",
            "SELECT Destruction_Authorised_by_Employee_ID, COUNT(*) FROM Documents_to_be_Destroyed GROUP BY Destruction_Authorised_by_Employee_ID"
        ],
        "rule_sql": [
            "SELECT Destruction_Authorised_by_Employee_ID, COUNT(*) FROM Documents_to_be_Destroyed GROUP BY Destruction_Authorised_by_Employee_ID"
        ]
    },
    "2828": {
        "db_id": "restaurant_1",
        "question": "List all students' first names and last names who majored in 600.",
        "ground_truth": "SELECT Fname , Lname FROM Student WHERE Major  =  600;",
        "amends": [
            "Do use column names `Fname` and `Lname` instead of `first_name` and `last_name`. Do reference table `Student` instead of `students`. Do use numeric value `600` without quotes instead of string literal `'600'` for the Major filter. The amended query now correctly matches the intended behavior by using the proper column names, table name, and numeric comparison syntax."
        ],
        "rules": [
            "1) When the question asks for students' first names: use column \"Fname\" from table \"Student\" instead of \"first_name\". 2) When the question asks for students' last names: use column \"Lname\" from table \"Student\" instead of \"last_name\". 3) When the question refers to the table containing student information: use table \"Student\" instead of \"students\". 4) When filtering by major value 600: use numeric comparison with value 600 without quotes instead of string literal '600'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM students WHERE major = '600';",
            "SELECT Fname, Lname FROM Student WHERE Major = 600"
        ],
        "rule_sql": [
            "SELECT Fname, Lname FROM Student WHERE Major = 600;"
        ]
    },
    "4653": {
        "db_id": "college_3",
        "question": "Find the first names and last names of male (sex is M) faculties who live in building NEB.",
        "ground_truth": "SELECT Fname ,  Lname FROM FACULTY WHERE sex  =  \"M\" AND Building  =  \"NEB\"",
        "amends": [
            "Do use column aliases `Fname` and `Lname` instead of `first_name` and `last_name`. Do reference table `FACULTY` instead of `faculties`. Do filter for `sex = \"M\"` instead of `sex = 'F'`. Do use double quotes around string literals instead of single quotes. The amended query now correctly filters for male faculty members in the NEB building, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for first names and last names: use column aliases \"Fname\" and \"Lname\" from table \"Faculty\" instead of \"first_name\" and \"last_name\". 2) When filtering for male faculty members: use the condition sex = \"M\" instead of sex = 'F'. 3) When filtering for faculty in building NEB: use the exact literal \"NEB\" with double quotes. 4) When referencing the faculty table: use the exact table name \"Faculty\" instead of \"faculties\". 5) When using string literals in conditions: always use double quotes instead of single quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM faculties WHERE sex = 'F' AND building = 'NEB'",
            "SELECT Fname, Lname FROM Faculty WHERE Sex = \"M\" AND Building = \"NEB\";"
        ],
        "rule_sql": [
            "SELECT Fname, Lname FROM Faculty WHERE Sex = \"M\" AND Building = \"NEB\";"
        ]
    },
    "14": {
        "db_id": "department_management",
        "question": "Which department has more than 1 head at a time? List the id, name and the number of heads.",
        "ground_truth": "SELECT T1.department_id ,  T1.name ,  count(*) FROM management AS T2 JOIN department AS T1 ON T1.department_id  =  T2.department_id GROUP BY T1.department_id HAVING count(*)  >  1",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of no aliases. Do reference `department` table as `T1` instead of `departments`. Do add `management` table as `T2` with `JOIN` instead of omitting it. Do use join condition `T1.department_id = T2.department_id` instead of no join. Do select `T1.name` instead of `department_name`. Do use `count(*)` instead of `COUNT(head_id)`. Do group by only `T1.department_id` instead of both `department_id` and `department_name`. Do move the count filter to `HAVING count(*) > 1` instead of `WHERE num_heads > 1`. The amended query now correctly counts management records per department and filters for departments with multiple management entries, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about department heads: use table aliases T1 for department table and T2 for management table instead of no aliases. 2) When combining department and management tables: link rows where T1.department_id = T2.department_id and keep only matching pairs (inner match). 3) When counting heads per department: compute the number of rows using count(*) instead of counting specific columns. 4) When grouping by department: organize results by T1.department_id only instead of multiple grouping columns. 5) When filtering for departments with more than 1 head: apply the condition count(*) > 1 in the HAVING clause instead of the WHERE clause. 6) When selecting department information: include T1.department_id and T1.name instead of department_id and department_name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department_id, department_name, COUNT(head_id) as num_heads\nFROM departments\nWHERE num_heads > 1\nGROUP BY department_id, department_name;",
            "SELECT T1.Department_ID, T1.Name, COUNT(*) AS num_heads\nFROM department T1\nJOIN management T2 ON T1.Department_ID = T2.Department_ID\nGROUP BY T1.Department_ID\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T1.Department_ID, T1.Name, COUNT(*) AS num_heads\nFROM department T1\nINNER JOIN management T2 ON T1.Department_ID = T2.Department_ID\nGROUP BY T1.Department_ID\nHAVING COUNT(*) > 1"
        ]
    },
    "6076": {
        "db_id": "customers_and_addresses",
        "question": "Which product's detail contains the word \"Latte\" or \"Americano\"? Return the full detail.",
        "ground_truth": "SELECT product_details FROM products WHERE product_details LIKE \"%Latte%\" OR product_details LIKE \"%Americano%\"",
        "amends": [
            "Do reference `product_details` column instead of `detail` in both the SELECT list and WHERE clause. Do use `OR` logical operator instead of `AND` to find records containing either 'Latte' or 'Americano' instead of requiring both terms simultaneously. Do remove the wildcard `SELECT *` instead of keeping it and instead specify only the `product_details` column. The amended query now correctly returns products containing either term rather than incorrectly requiring both terms to be present."
        ],
        "rules": [
            "1) When the question asks about product details containing specific words: use the exact column name \"product_details\" from the Products table instead of \"detail\". 2) When searching for records containing either \"Latte\" or \"Americano\": use OR logical operator instead of AND to find records with either term rather than requiring both terms simultaneously. 3) When returning the full detail: select only the \"product_details\" column instead of using SELECT * to return all columns. 4) When handling text literals: preserve the exact case and spelling of \"Latte\" and \"Americano\" as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM products WHERE detail LIKE '%Latte%' AND detail LIKE '%Americano%';",
            "SELECT product_details FROM Products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%'"
        ],
        "rule_sql": [
            "SELECT product_details FROM Products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%'"
        ]
    },
    "4429": {
        "db_id": "network_2",
        "question": "How many people are under 40 for each gender?",
        "ground_truth": "SELECT count(*) ,  gender FROM Person WHERE age  <  40 GROUP BY gender",
        "amends": [
            "Do use table name `Person` instead of `people` in the FROM clause. Do move the `gender` column to the SELECT list instead of placing it first. Do change the WHERE filter to `age < 40` instead of `age > 40` to select younger individuals. Do adjust the column order in the SELECT list to place `count(*)` first instead of `gender`. The amended query now correctly counts people under 40 years old grouped by gender, matching the intended behavior.",
            "Do place `gender` after the aggregate function instead of before it in the SELECT list. Do maintain the same `COUNT(*)` aggregate function and `WHERE age < 40` filter condition. Do preserve the identical `GROUP BY gender` clause without any changes to the grouping logic. The amended query now correctly positions the non-aggregated column after the aggregate function while maintaining the same result set and matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"people under 40 for each gender\": make sure the output order: count first, then gender. 2) When the question mentions \"people\": \"people\" actually means \"Person\" in schema. 3) When the question asks for \"people under 40\": use condition age < 40 instead of age > 40. 4) When the question asks for \"count of people per gender\": compute the number of rows using the canonical key for Person and group by gender.",
            "1) When answering about \"people under 40 for each gender\": make sure the output order: COUNT(*) first, then gender. 2) When the question asks for \"count of people under 40\": compute the number of rows using COUNT(*) with WHERE age < 40 filter condition. 3) When the question says \"per gender\"/\"by gender\": organize results by gender column and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT gender, COUNT(*) FROM people WHERE age > 40 GROUP BY gender;",
            "SELECT gender, COUNT(*) FROM Person WHERE age < 40 GROUP BY gender;",
            "SELECT COUNT(*), gender FROM Person WHERE age < 40 GROUP BY gender"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS count, gender FROM Person WHERE age < 40 GROUP BY gender ORDER BY count, gender;"
        ]
    },
    "1743": {
        "db_id": "gymnast",
        "question": "Return the average horizontal bar points across all gymnasts.",
        "ground_truth": "SELECT avg(Horizontal_Bar_Points) FROM gymnast",
        "amends": [
            "Do reference the `gymnast` table instead of `gymnasts`. Do use the correct column name `Horizontal_Bar_Points` instead of `horizontal_bar`. Do remove the `WHERE horizontal_bar IS NOT NULL` filter instead of keeping it, as the AVG function inherently handles NULL values by excluding them from calculation. The amended query now correctly calculates the average of horizontal bar points from the gymnast table."
        ],
        "rules": [
            "1) When the question asks for \"horizontal bar points\": use the exact column name \"Horizontal_Bar_Points\" from the gymnast table. 2) When calculating average values: do not add explicit NULL filtering as the AVG function inherently excludes NULL values from calculation. 3) When referencing the table containing gymnast data: use the exact table name \"gymnast\" instead of variations like \"gymnasts\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(horizontal_bar) FROM gymnasts WHERE horizontal_bar IS NOT NULL;",
            "SELECT AVG(Horizontal_Bar_Points) FROM gymnast"
        ],
        "rule_sql": [
            "SELECT AVG(Horizontal_Bar_Points) FROM gymnast;"
        ]
    },
    "2058": {
        "db_id": "party_people",
        "question": "How many members are in each party?",
        "ground_truth": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id",
        "amends": [
            "Do join `party AS T2` on `T1.party_id = T2.party_id` instead of querying only the `members` table without any join. Do select `T2.party_name` instead of `party` to get the actual party name from the joined table rather than the ID. Do group by `T1.party_id` instead of `party` to ensure proper aggregation on the joining key. The amended query now correctly retrieves party names from the related party table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"How many members are in each party?\": make sure to join the party table (as T2) to the members table (as T1) using the exact key equality T1.party_id = T2.party_id. 2) When the question asks for party names: select T2.party_name instead of party to get the actual party name from the joined table. 3) When grouping by party: group by T1.party_id instead of party to ensure proper aggregation on the joining key. 4) When counting members per party: count using the canonical key from the members table (T1.party_id) for accurate aggregation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT party, COUNT(*) FROM members GROUP BY party;",
            "SELECT p.Party_name, COUNT(m.Member_ID) AS member_count FROM member m JOIN party p ON m.Party_ID = p.Party_ID GROUP BY p.Party_ID, p.Party_name"
        ],
        "rule_sql": [
            "SELECT T2.party_name, COUNT(T1.party_id) AS member_count FROM member AS T1 JOIN party AS T2 ON T1.party_id = T2.party_id GROUP BY T1.party_id"
        ]
    },
    "887": {
        "db_id": "chinook_1",
        "question": "How many artists do not have any album?",
        "ground_truth": "SELECT count(*) FROM ARTIST WHERE artistid NOT IN(SELECT artistid FROM ALBUM)",
        "amends": [
            "Do reference the `ARTIST` table instead of `artists` and use `artistid` instead of `album_id` for the identifier. Do use a `NOT IN` subquery checking against the `ALBUM` table instead of checking `IS NULL` on a non-existent column. Do remove the incorrect `album_id` column reference and instead filter by artists not present in the album table through the subquery. The amended query now correctly counts artists who have no albums by checking their absence from the ALBUM table rather than relying on a null foreign key that doesn't exist in the schema."
        ],
        "rules": [
            "1) When answering about \"artists without albums\": use the table \"ARTIST\" (not \"artists\") and the identifier \"artistid\" (not \"album_id\"). 2) When checking for artists without albums: use a NOT IN subquery against the \"ALBUM\" table instead of checking IS NULL on non-existent columns. 3) When counting artists who have no albums: filter by artists not present in the ALBUM table through the subquery rather than relying on a null foreign key."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM artists WHERE album_id IS NULL;",
            "SELECT COUNT(*) FROM Artist WHERE ArtistId NOT IN (SELECT DISTINCT ArtistId FROM Album)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Artist WHERE ArtistId NOT IN (SELECT ArtistId FROM Album)"
        ]
    },
    "6146": {
        "db_id": "music_4",
        "question": "What are the ages of all music artists?",
        "ground_truth": "SELECT Age FROM artist",
        "amends": [
            "Do select `Age` from the `artist` table instead of selecting `name` from the `music_artists` table. Do use the correct table name `artist` instead of the incorrect `music_artists` table. The amended query now correctly retrieves age information from the appropriate artist table."
        ],
        "rules": [
            "1) When the question asks for \"ages of all music artists\": select the exact column \"Age\" from the \"artist\" table. 2) When the question mentions \"music artists\": use the exact table name \"artist\" instead of \"music_artists\". 3) When producing output: return only the \"Age\" column values without any other columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM music_artists;",
            "SELECT Age FROM artist;"
        ],
        "rule_sql": [
            "SELECT Age FROM artist;"
        ]
    },
    "1870": {
        "db_id": "wrestler",
        "question": "What are the names of wrestlers days held less than 100?",
        "ground_truth": "SELECT Name FROM wrestler WHERE Days_held  <  100",
        "amends": [
            "Do select `Name` instead of `name` and use table `wrestler` instead of `wrestlers`. Do change the filter to `Days_held < 100` instead of `days_held >= 100`, which reverses the logic to find wrestlers who held titles for less than 100 days rather than 100 or more days. The amended query now correctly matches the intended behavior of selecting wrestlers with fewer than 100 days held."
        ],
        "rules": [
            "1) When the question asks for wrestler names: use the exact column token \"Name\" from the wrestler table. 2) When the question mentions \"days held less than 100\": filter rows where the \"Days_held\" column has values strictly less than 100. 3) When selecting from the wrestler table: use the exact table name \"wrestler\" (not \"wrestlers\"). 4) When answering about wrestlers with less than 100 days held: make sure the output order includes only the \"Name\" column."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM wrestlers WHERE days_held >= 100;",
            "SELECT Name FROM wrestler WHERE Days_held < 100"
        ],
        "rule_sql": [
            "SELECT Name FROM wrestler WHERE CAST(Days_held AS INTEGER) < 100;"
        ]
    },
    "447": {
        "db_id": "allergy_1",
        "question": "Show all allergies with type food.",
        "ground_truth": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  \"food\"",
        "amends": [
            "Do select `allergy` instead of `*` and use `DISTINCT` instead of omitting it. Do query from `Allergy_type` instead of `allergies` as the table source. Do filter on `allergytype = \"food\"` instead of `type = 'food'` for the column name and value syntax. The amended query now correctly returns distinct allergy values from the appropriate table with the correct filter condition."
        ],
        "rules": [
            "1) When answering about \"allergies with type food\": make sure the output order: allergy\n2) When the question mentions \"allergies\": \"allergies\" actually means \"Allergy_type\" in schema\n3) When the question mentions \"type food\": \"type food\" actually means \"allergytype = \\\"food\\\"\" in schema\n4) When selecting allergy values: use DISTINCT to return only unique values of the \"allergy\" column\n5) When filtering for food allergies: use the exact literal value \"food\" with double quotes for the allergytype column comparison"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM allergies WHERE type = 'food';",
            "SELECT DISTINCT Allergy FROM Allergy_Type WHERE AllergyType = 'food'"
        ],
        "rule_sql": [
            "SELECT DISTINCT Allergy FROM Allergy_Type WHERE AllergyType = \"food\" ORDER BY Allergy;"
        ]
    },
    "2552": {
        "db_id": "county_public_safety",
        "question": "Show white percentages of cities and the crime rates of counties they are in.",
        "ground_truth": "SELECT T1.White ,  T2.Crime_rate FROM city AS T1 JOIN county_public_safety AS T2 ON T1.County_ID  =  T2.County_ID",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `c` and `co`. Do select columns `White` and `Crime_rate` instead of `city_name`, `white_percentage`, and `crime_rate`. Do reference table `city` instead of `cities` and `county_public_safety` instead of `counties`. Do remove the `WHERE c.white_percentage > 50` filter instead of keeping it. Do remove the `ORDER BY co.crime_rate DESC` clause instead of including it. The amended query now matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"white percentages of cities and crime rates of counties\": make sure the output order: T1.\"White\", T2.\"Crime_rate\" 2) When combining city and county_public_safety tables: link rows where T1.county_id = T2.county_id and keep only matching pairs (inner match) 3) When the question mentions \"white percentages\": \"white percentages\" actually means T1.\"White\" in schema 4) When the question mentions \"crime rates\": \"crime rates\" actually means T2.\"Crime_rate\" in schema 5) When selecting from the city table: use table alias T1 instead of c 6) When selecting from the county_public_safety table: use table alias T2 instead of co 7) When the question asks for cities and counties data: do not apply any WHERE filter on T1.\"White\" > 50 8) When the question asks for cities and counties data: do not apply any ORDER BY clause on T2.\"Crime_rate\" DESC"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.city_name, c.white_percentage, co.crime_rate \nFROM cities c \nJOIN counties co ON c.county_id = co.county_id \nWHERE c.white_percentage > 50 \nORDER BY co.crime_rate DESC;",
            "SELECT T1.White, T2.Crime_rate FROM city T1 JOIN county_public_safety T2 ON T1.County_ID = T2.County_ID"
        ],
        "rule_sql": [
            "SELECT T1.\"White\", T2.\"Crime_rate\" FROM city T1 INNER JOIN county_public_safety T2 ON T1.\"County_ID\" = T2.\"County_ID\""
        ]
    },
    "400": {
        "db_id": "flight_1",
        "question": "What are the numbers of the shortest flights?",
        "ground_truth": "SELECT flno FROM Flight ORDER BY distance ASC LIMIT 3",
        "amends": [
            "Do select `flno` instead of `flight_number` and order by `distance ASC` instead of `duration DESC`. Do limit to `3` rows instead of `1` row. Do query from `Flight` table instead of `flights` table. The amended query now matches the correct behavior by selecting the appropriate column name, ordering by distance in ascending order, returning three records, and using the correct table name."
        ],
        "rules": [
            "1) When the question asks for \"numbers of the shortest flights\": select \"flno\" from the \"Flight\" table instead of \"flight_number\" from \"flights\". 2) When determining \"shortest flights\": order by \"distance\" in ascending order instead of \"duration\" in descending order. 3) When the question asks for multiple shortest flights: return 3 rows instead of just 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flight_number FROM flights ORDER BY duration DESC LIMIT 1;",
            "SELECT flno FROM flight ORDER BY distance ASC LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT flno FROM flight ORDER BY distance ASC LIMIT 3;"
        ]
    },
    "142": {
        "db_id": "bike_1",
        "question": "What are the ids of the stations in San Francisco that normally have more than 10 bikes available?",
        "ground_truth": "SELECT id FROM station WHERE city  =  \"San Francisco\" INTERSECT SELECT station_id FROM status GROUP BY station_id HAVING avg(bikes_available)  >  10",
        "amends": [
            "Do select `id` from `station` instead of `station_id` from `stations`. Do use `INTERSECT` with a subquery instead of a single table filter. Do add a second query selecting `station_id` from `status` instead of omitting it. Do use `GROUP BY station_id` and `HAVING avg(bikes_available) > 10` instead of a simple `WHERE bikes_available > 10` filter. Do use double quotes around 'San Francisco' instead of single quotes. The amended query now correctly identifies stations in San Francisco that have an average bikes available greater than 10 across status records, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting station identifiers: use \"id\" from table \"station\" instead of \"station_id\" from \"stations\". 2) When combining data from multiple tables: use INTERSECT operation between queries instead of filtering a single table. 3) When accessing status information: include a second query selecting \"station_id\" from \"status\" table. 4) When calculating average bike availability: use GROUP BY station_id and HAVING avg(bikes_available) > 10 instead of simple WHERE filter. 5) When specifying the city name: use double quotes around \"San Francisco\" instead of single quotes. 6) When determining stations with normally high bike availability: compute the average bikes_available across status records per station."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT station_id FROM stations WHERE city = 'San Francisco' AND bikes_available > 10;",
            "SELECT id FROM station WHERE city = \"San Francisco\"\nINTERSECT\nSELECT station_id FROM status GROUP BY station_id HAVING AVG(bikes_available) > 10"
        ],
        "rule_sql": [
            "SELECT id FROM station WHERE city = \"San Francisco\"\nINTERSECT\nSELECT station_id FROM status GROUP BY station_id HAVING AVG(bikes_available) > 10"
        ]
    },
    "1326": {
        "db_id": "college_2",
        "question": "What is the name and building of the departments whose budget is more than the average budget?",
        "ground_truth": "SELECT dept_name ,  building FROM department WHERE budget  >  (SELECT avg(budget) FROM department)",
        "amends": [
            "Do use `dept_name` instead of `name` for the column selection. Do reference the `department` table instead of `departments` in both the main query and subquery. Do use lowercase `avg` instead of uppercase `AVG` for the aggregate function. The amended query now correctly references the department table structure and uses proper case consistency for the aggregate function."
        ],
        "rules": [
            "1) When the question asks for \"name\" of departments: use the exact column token \"dept_name\" instead of \"name\" from the department table. 2) When referencing the department table: use the exact table name \"department\" (singular) instead of \"departments\" (plural) in both main query and subqueries. 3) When using aggregate functions: use lowercase \"avg\" instead of uppercase \"AVG\" for case consistency with the schema dialect."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, building FROM departments WHERE budget > (SELECT AVG(budget) FROM departments);",
            "SELECT dept_name, building FROM department WHERE budget > (SELECT avg(budget) FROM department)"
        ],
        "rule_sql": [
            "SELECT dept_name, building FROM department WHERE budget > (SELECT avg(budget) FROM department)"
        ]
    },
    "5089": {
        "db_id": "device",
        "question": "What are the carriers of devices that are in stock in more than a single shop?",
        "ground_truth": "SELECT T2.Carrier FROM stock AS T1 JOIN device AS T2 ON T1.Device_ID  =  T2.Device_ID GROUP BY T1.Device_ID HAVING COUNT(*)  >  1",
        "amends": [
            "Do use `JOIN` between `stock` and `device` tables instead of querying only the `devices` table. Do reference `T2.Carrier` instead of `carrier` from a single table. Do add the join condition `ON T1.Device_ID = T2.Device_ID` instead of missing table relationships. Do use `GROUP BY T1.Device_ID` instead of omitting grouping. Do move the count filter to `HAVING COUNT(*) > 1` instead of using `WHERE stock_count > 1`. Do remove `DISTINCT` since the grouping and having clause ensures unique results. The amended query now correctly identifies carriers for devices with multiple stock entries by properly joining the tables and using aggregate counting with grouping."
        ],
        "rules": [
            "1) When answering about carriers of devices in stock in multiple shops: combine information from stock and device tables using an inner match where T1.Device_ID equals T2.Device_ID. 2) When counting shops per device: group by T1.Device_ID and count the number of rows per device. 3) When filtering for devices in more than one shop: keep only device groups where the count exceeds 1. 4) When selecting carriers: output T2.Carrier values from the matching device records. 5) When ensuring unique results: rely on the grouping and filtering process rather than using DISTINCT on the final output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT carrier FROM devices WHERE stock_count > 1;",
            "SELECT T2.Carrier\nFROM stock T1\nJOIN device T2 ON T1.Device_ID = T2.Device_ID\nGROUP BY T1.Device_ID\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T2.Carrier\nFROM stock T1\nINNER JOIN device T2 ON T1.Device_ID = T2.Device_ID\nGROUP BY T1.Device_ID\nHAVING COUNT(T1.Shop_ID) > 1"
        ]
    },
    "5011": {
        "db_id": "soccer_2",
        "question": "What is the average and maximum number of hours students who made the team practiced?",
        "ground_truth": "SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'",
        "amends": [
            "Do reference columns `T1.HS` instead of `hours_practiced` and use table aliases `T1` and `T2` instead of bare table names. Do join tables `player AS T1` and `tryout AS T2` on `T1.pID = T2.pID` instead of querying a single table. Do filter on `T2.decision = 'yes'` instead of `made_team = 'yes'` to check the tryout decision rather than a student attribute. The amended query now correctly aggregates practice hours from the player table while filtering based on tryout decisions, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"average and maximum number of hours students who made the team practiced\": make sure the output order: AVG(T1.HS), MAX(T1.HS). 2) When the question mentions \"students who made the team\": \"made the team\" actually means \"T2.decision = 'yes'\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.pID = T2.pID exactly as shown in the amends; keep only matching pairs (inner match). 4) When computing aggregates on practice hours: use T1.HS as the exact column token for hours practiced."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(hours_practiced), MAX(hours_practiced) FROM students WHERE made_team = 'yes';",
            "SELECT AVG(T1.HS) AS average_hours, MAX(T1.HS) AS maximum_hours FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T2.decision = 'yes'"
        ],
        "rule_sql": [
            "SELECT AVG(T1.HS) AS average_hours, MAX(T1.HS) AS maximum_hours\nFROM Player T1\nINNER JOIN Tryout T2 ON T1.pID = T2.pID\nWHERE T2.decision = 'yes';"
        ]
    },
    "1215": {
        "db_id": "apartment_rentals",
        "question": "Which apartments have type code \"Flat\"? Give me their apartment numbers.",
        "ground_truth": "SELECT apt_number FROM Apartments WHERE apt_type_code  =  \"Flat\"",
        "amends": [
            "Do select `apt_number` instead of `apartment_number` and filter on `apt_type_code = \"Flat\"` instead of `type_code = 'House'`, while also referencing the correct table name `Apartments` instead of `apartments`. The amended query now correctly retrieves apartment numbers for flats rather than houses, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for apartment numbers: use the exact column name \"apt_number\" from the Apartments table. 2) When filtering for apartments with type code \"Flat\": use the exact condition \"apt_type_code = \\\"Flat\\\"\" with double quotes around the literal value. 3) When referencing the Apartments table: use the exact table name \"Apartments\" with proper capitalization."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT apartment_number FROM apartments WHERE type_code = 'House'",
            "SELECT apt_number FROM Apartments WHERE apt_type_code = 'Flat';"
        ],
        "rule_sql": [
            "SELECT apt_number FROM Apartments WHERE apt_type_code = \"Flat\";"
        ]
    },
    "1239": {
        "db_id": "apartment_rentals",
        "question": "What are the facility codes of the apartments with more than four bedrooms?",
        "ground_truth": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  4",
        "amends": [
            "Do select `T1.facility_code` from the `Apartment_Facilities` table instead of `facility_code` from the `apartments` table. Do join `Apartment_Facilities AS T1` with `Apartments AS T2` on `T1.apt_id = T2.apt_id` instead of querying only the `apartments` table. Do filter with `T2.bedroom_count > 4` instead of `bedrooms <= 4`, changing both the column reference and the inequality direction. Do use the correct table alias `T2` for the bedroom count column instead of the base table name. The amended query now correctly joins the facility and apartment tables and filters for apartments with more than 4 bedrooms, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"facility codes of apartments with more than four bedrooms\": make sure the output order: T1.facility_code. 2) When the question mentions \"facility codes\": \"facility codes\" actually means \"T1.facility_code in schema\". 3) When the question mentions \"apartments with more than four bedrooms\": this means filter rows where T2.bedroom_count > 4. 4) When combining Apartment_Facilities (T1) and Apartments (T2): link rows where T1.apt_id = T2.apt_id and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT facility_code FROM apartments WHERE bedrooms <= 4;",
            "SELECT T1.facility_code \nFROM Apartment_Facilities AS T1\nJOIN Apartments AS T2 ON T1.apt_id = T2.apt_id\nWHERE T2.bedroom_count > 4"
        ],
        "rule_sql": [
            "SELECT T1.facility_code\nFROM Apartment_Facilities T1\nINNER JOIN Apartments T2 ON T1.apt_id = T2.apt_id\nWHERE T2.bedroom_count > 4\nORDER BY T1.facility_code;"
        ]
    },
    "4194": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "Show the description for role name \"Proof Reader\".",
        "ground_truth": "SELECT role_description FROM ROLES WHERE role_name  =  \"Proof Reader\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT role_description FROM roles WHERE role_name = 'Proof Reader';"
        ],
        "rule_sql": [
            "SELECT Role_Description FROM Roles WHERE Role_Name = 'Proof Reader';"
        ]
    },
    "4128": {
        "db_id": "film_rank",
        "question": "List all countries of markets in descending order of number of cities.",
        "ground_truth": "SELECT Country FROM market ORDER BY Number_cities DESC",
        "amends": [
            "Do select `Country` instead of `country, COUNT(city) as city_count` and remove the aggregation and grouping. Do use `ORDER BY Number_cities DESC` instead of `ORDER BY city_count ASC` to sort by a different column in descending order. Do reference table `market` instead of `markets` with the correct table name. The amended query now correctly selects only the country column and orders by Number_cities in descending order as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks to list countries: select only the \"Country\" column from the \"market\" table. 2) When ordering by number of cities in descending order: use \"Number_cities\" column for ordering with DESC direction. 3) When the question mentions \"markets\": use the exact table name \"market\" (not \"markets\"). 4) When the question asks for a simple list without aggregation: do not use GROUP BY or COUNT functions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country, COUNT(city) as city_count FROM markets GROUP BY country ORDER BY city_count ASC;",
            "SELECT Country FROM market ORDER BY Number_cities DESC;"
        ],
        "rule_sql": [
            "SELECT Country FROM market ORDER BY Number_cities DESC;"
        ]
    },
    "3414": {
        "db_id": "hr_1",
        "question": "What is all the information about the Marketing department?",
        "ground_truth": "SELECT * FROM  departments WHERE department_name  =  'Marketing'",
        "amends": [
            "Do filter with `department_name = 'Marketing'` instead of `department_name = 'Sales'` to query the correct department records. The amended query now matches RIGHT_SQL's behavior by selecting the Marketing department instead of Sales."
        ],
        "rules": [
            "1) When the question asks for information about the Marketing department: filter records where department_name equals 'Marketing' exactly (case-sensitive). 2) When selecting department information: include all available columns from the departments table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM departments WHERE department_name = 'Sales';",
            "SELECT * FROM departments WHERE DEPARTMENT_NAME = 'Marketing';"
        ],
        "rule_sql": [
            "SELECT * FROM departments WHERE DEPARTMENT_NAME = 'Marketing';"
        ]
    },
    "1811": {
        "db_id": "small_bank_1",
        "question": "What is the savings balance of the account belonging to the customer with the highest checking balance?",
        "ground_truth": "SELECT T3.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid ORDER BY T2.balance DESC LIMIT 1",
        "amends": [
            "Do use explicit joins with `accounts AS T1 JOIN checking AS T2 ON T1.custid = T2.custid JOIN savings AS T3 ON T1.custid = T3.custid` instead of a subquery that incorrectly references the same table. Do select `T3.balance` from the `savings` table instead of `savings_balance` from `accounts`. Do add proper table aliases `T1`, `T2`, and `T3` instead of omitting them. Do remove the WHERE clause with the subquery instead of keeping it, as the join approach correctly links the tables. Do order by `T2.balance DESC` from the checking table instead of `checking_balance DESC` from accounts. The amended query now correctly retrieves the savings balance for the customer with the highest checking balance by properly joining the three related tables."
        ],
        "rules": [
            "1) When combining customer account information from multiple tables: link accounts as T1, checking as T2, and savings as T3 using T1.custid = T2.custid and T1.custid = T3.custid to ensure proper table relationships. 2) When finding the customer with the highest checking balance: order results by T2.balance DESC from the checking table to identify the top customer. 3) When retrieving savings balance information: select T3.balance from the savings table instead of any savings-related column from the accounts table. 4) When the question asks for the savings balance of the customer with the highest checking balance: use explicit joins between accounts, checking, and savings tables rather than subqueries that incorrectly reference the same table multiple times."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT savings_balance FROM accounts WHERE customer_id = (SELECT customer_id FROM accounts ORDER BY checking_balance DESC LIMIT 1);",
            "SELECT T3.balance \nFROM accounts AS T1 \nJOIN checking AS T2 ON T1.custid = T2.custid \nJOIN savings AS T3 ON T1.custid = T3.custid \nORDER BY T2.balance DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T3.balance \nFROM ACCOUNTS AS T1\nJOIN CHECKING AS T2 ON T1.custid = T2.custid\nJOIN SAVINGS AS T3 ON T1.custid = T3.custid\nORDER BY T2.balance DESC\nLIMIT 1"
        ]
    },
    "5898": {
        "db_id": "cre_Theme_park",
        "question": "What is the average price range of five star hotels that allow pets?",
        "ground_truth": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  \"5\" AND pets_allowed_yn  =  1",
        "amends": [
            "Do reference `star_rating_code` instead of `stars` in the WHERE filter. Do use numeric comparison `= 5` instead of string comparison `= \"5\"`. Do reference `pets_allowed_yn` instead of `pets_allowed` in the WHERE filter. Do use numeric comparison `= 1` instead of string comparison `= 'yes'` for the pets allowed flag. The amended query now correctly matches the schema and data types of the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question mentions \"stars\": \"stars\" actually means \"star_rating_code\" in the schema. 2) When filtering for five star hotels: use numeric comparison = 5 with the exact token \"star_rating_code\". 3) When filtering for hotels that allow pets: use the exact token \"pets_allowed_yn\" with numeric comparison = 1 instead of string comparison = 'yes'. 4) When computing average price range: use AVG(price_range) as specified in the original query structure."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(price_range) FROM hotels WHERE stars = 5 AND pets_allowed = 'yes';",
            "SELECT AVG(price_range) FROM Hotels WHERE star_rating_code = 5 AND pets_allowed_yn = 1;"
        ],
        "rule_sql": [
            "SELECT AVG(price_range) FROM Hotels WHERE star_rating_code = 5 AND pets_allowed_yn = 1;"
        ]
    },
    "3237": {
        "db_id": "college_1",
        "question": "Find the total credits of all classes offered by each department.",
        "ground_truth": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code",
        "amends": [
            "Do use `sum(T1.crs_credit)` instead of `SUM(credits)` for the aggregate function and column reference. Do specify `T1.dept_code` instead of just `department` for the grouping column. Do add `FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code = T2.crs_code` instead of the simple `FROM classes` to properly join the course and class tables on the course code relationship. The amended query now correctly aggregates course credits from the joined tables and groups by department code, matching the intended behavior.",
            "Do place the aggregate function `sum(T1.crs_credit)` first in the SELECT list instead of second, and do remove the alias `AS total_credits` instead of keeping it. Do use lowercase column names `crs_credit` and `dept_code` instead of uppercase `CRS_CREDIT` and `DEPT_CODE` for consistency. The amended query now matches RIGHT_SQL's behavior with identical logic and output structure.",
            "Do place the aggregate function `sum(T1.crs_credit)` first in the SELECT list instead of second, while keeping the same column order in GROUP BY. Do maintain the same JOIN condition `T1.crs_code = T2.crs_code` and preserve all other elements including the table aliases, join type, and grouping logic. The amended query now matches RIGHT_SQL's behavior with identical output despite the column ordering difference in the SELECT clause.",
            "Do place `sum(T1.crs_credit)` before `T1.dept_code` in the SELECT list instead of the reverse order. Do maintain the same FROM clause with `JOIN CLASS AS T2 ON T1.crs_code = T2.crs_code` and identical GROUP BY `T1.dept_code`. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [
            "1) When answering about \"total credits of all classes offered by each department\": make sure the output order: T1.dept_code, sum(T1.crs_credit). 2) When the question mentions \"department\": \"department\" actually means \"T1.dept_code in schema\". 3) When the question mentions \"credits\": \"credits\" actually means \"T1.crs_credit in schema\". 4) When combining T1 and T2 for shared entities: link rows where T1.crs_code = T2.crs_code exactly as shown in the amends; keep only matching pairs (inner match). 5) When the question says \"per department\"/\"by department\": organize results by T1.dept_code and compute sum(T1.crs_credit) per group.",
            "1) When answering about \"total credits of all classes offered by each department\": make sure the output order: sum(T1.crs_credit) first, then T1.dept_code. 2) When producing output columns: do not use aliases like \"AS total_credits\" for aggregate functions. 3) When referring to column identifiers: use lowercase \"crs_credit\" and \"dept_code\" instead of uppercase \"CRS_CREDIT\" and \"DEPT_CODE\" for consistency with the schema.",
            "1) When answering about \"total credits of all classes offered by each department\": make sure the output order: sum(T1.crs_credit) first, then T1.dept_code. 2) When combining course table (T1) and CLASS table (T2): link rows where T1.crs_code = T2.crs_code and keep only matching pairs (inner match). 3) When the question says \"per department\": organize results by T1.dept_code and compute sum of T1.crs_credit per group.",
            "1) When answering about \"total credits of all classes offered by each department\": make sure the output order: sum(T1.crs_credit) before T1.dept_code\n2) When combining T1 (course) and T2 (CLASS) for shared entities: link rows where T1.crs_code = T2.crs_code exactly as shown; keep only matching pairs (inner match)\n3) When the question says \"per department\": organize results by T1.dept_code and compute sum of T1.crs_credit per group"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department, SUM(credits) FROM classes GROUP BY department;",
            "SELECT T1.DEPT_CODE, SUM(T1.CRS_CREDIT) AS total_credits\nFROM COURSE AS T1\nJOIN CLASS AS T2 ON T1.CRS_CODE = T2.CRS_CODE\nGROUP BY T1.DEPT_CODE",
            "SELECT T1.dept_code, sum(T1.crs_credit) FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code = T2.crs_code GROUP BY T1.dept_code",
            "SELECT T1.dept_code, sum(T1.crs_credit) \nFROM course AS T1 \nJOIN CLASS AS T2 ON T1.crs_code = T2.crs_code \nGROUP BY T1.dept_code",
            "SELECT sum(T1.crs_credit), T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code = T2.crs_code GROUP BY T1.dept_code"
        ],
        "rule_sql": [
            "SELECT SUM(crs_credit), dept_code FROM COURSE T1 INNER JOIN CLASS T2 ON T1.crs_code = T2.crs_code GROUP BY dept_code"
        ]
    },
    "1298": {
        "db_id": "soccer_1",
        "question": "What are the names of players who have the best dribbling?",
        "ground_truth": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.dribbling  =  ( SELECT max(overall_rating) FROM Player_Attributes)",
        "amends": [
            "Do select `T1.player_name` with `DISTINCT` instead of `name` without distinct. Do join `Player AS T1` with `Player_Attributes AS T2` on `T1.player_api_id = T2.player_api_id` instead of selecting from only `players`. Do add a WHERE filter comparing `T2.dribbling` to a subquery selecting `max(overall_rating)` from `Player_Attributes` instead of ordering by `dribbling DESC`. Do remove the `ORDER BY` and `LIMIT 1` clauses instead of keeping them. The amended query now correctly identifies players with the maximum dribbling rating by joining the necessary tables and using a subquery comparison instead of relying on ordering and limiting.",
            "Do use `max(overall_rating)` in the subquery instead of `MAX(dribbling)` to correctly identify players with the maximum overall rating rather than maximum dribbling. The amended query now matches RIGHT_SQL's behavior by fixing the aggregate column reference in the subquery predicate."
        ],
        "rules": [
            "1) When answering about \"names of players who have the best dribbling\": make sure the output order: T1.player_name. 2) When the question mentions \"players\": \"players\" actually means \"Player AS T1\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.player_api_id = T2.player_api_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"best dribbling\": \"best dribbling\" actually means \"T2.dribbling = (SELECT max(overall_rating) FROM Player_Attributes)\" in schema. 5) When selecting player names: use DISTINCT T1.player_name instead of name without distinct.",
            "1) When the question asks for players with the \"best dribbling\": use the \"overall_rating\" column from Player_Attributes table instead of \"dribbling\" to identify the best players. 2) When finding the maximum value to identify best players: compute the maximum of T2.overall_rating rather than T2.dribbling. 3) When comparing player attributes to find the best: use the condition T2.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes) instead of T2.dribbling = (SELECT MAX(dribbling) FROM Player_Attributes)."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM players ORDER BY dribbling DESC LIMIT 1;",
            "SELECT DISTINCT T1.player_name\nFROM Player AS T1\nJOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id\nWHERE T2.dribbling = (SELECT MAX(dribbling) FROM Player_Attributes)",
            "SELECT DISTINCT T1.player_name\nFROM Player AS T1\nJOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id\nWHERE T2.dribbling = (SELECT max(overall_rating) FROM Player_Attributes)"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.player_name\nFROM Player AS T1\nINNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id\nWHERE T2.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)\nORDER BY T1.player_name;"
        ]
    },
    "5787": {
        "db_id": "customer_complaints",
        "question": "Return the description of the product called \"Chocolate\".",
        "ground_truth": "SELECT product_description FROM products WHERE product_name  =  \"Chocolate\"",
        "amends": [
            "Do select `product_description` instead of `name` in the SELECT list. Do filter on `product_name = \"Chocolate\"` instead of `description = 'Chocolate'` in the WHERE clause, correcting both the column reference and the string literal syntax from single to double quotes. The amended query now correctly retrieves product descriptions where the product name matches \"Chocolate\" instead of incorrectly filtering by description content."
        ],
        "rules": [
            "1) When the question asks for \"description of the product\": select the exact column \"product_description\" from the Products table. 2) When filtering for a product called \"Chocolate\": use the condition product_name = \"Chocolate\" with double quotes around the literal value. 3) When the question specifies a product name: filter using the product_name column rather than the description column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM products WHERE description = 'Chocolate';",
            "SELECT product_description FROM Products WHERE product_name = \"Chocolate\""
        ],
        "rule_sql": [
            "SELECT product_description FROM Products WHERE product_name = \"Chocolate\";"
        ]
    },
    "6291": {
        "db_id": "city_record",
        "question": "Which cities have lower temperature in March than in July and have been once host cities?",
        "ground_truth": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of direct table references. Do join `city AS T1` with `temperature AS T2` on `T1.city_id = T2.city_id` instead of querying a single `temperature_data` table. Do reference temperature columns as `T2.Mar` and `T2.Jul` instead of `march_temp` and `july_temp`. Do remove the `host_city = 'yes'` filter instead of keeping it as a simple WHERE condition. Do add an INTERSECT operation with a second query joining `city AS T3` with `hosting_city AS T4` on `T3.city_id = T4.host_city` instead of the single table approach. The amended query now correctly identifies cities that are both warmer in July than March and are hosting cities through proper table relationships."
        ],
        "rules": [
            "1) When answering about cities with temperature comparisons: use table aliases T1 for city and T2 for temperature, joining them on T1.city_id = T2.city_id. 2) When comparing March and July temperatures: reference the exact column tokens T2.Mar and T2.Jul with the condition T2.Mar < T2.Jul. 3) When identifying host cities: use table aliases T3 for city and T4 for hosting_city, joining them on T3.city_id = T4.host_city. 4) When combining temperature and hosting conditions: use INTERSECT operation between the temperature query and hosting query instead of simple WHERE conditions. 5) When selecting output: return only the city column from the final result set."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city \nFROM temperature_data \nWHERE march_temp < july_temp \nAND host_city = 'yes'",
            "SELECT T1.City\nFROM city AS T1\nJOIN temperature AS T2 ON T1.City_ID = T2.City_ID\nWHERE T2.Mar < T2.Jul\nINTERSECT\nSELECT T3.City\nFROM city AS T3\nJOIN hosting_city AS T4 ON T3.City_ID = T4.Host_City"
        ],
        "rule_sql": [
            "SELECT T1.City FROM city T1 JOIN temperature T2 ON T1.City_ID = T2.City_ID WHERE T2.Mar < T2.Jul INTERSECT SELECT T3.City FROM city T3 JOIN hosting_city T4 ON T3.City_ID = T4.Host_City"
        ]
    },
    "2656": {
        "db_id": "local_govt_mdm",
        "question": "How many council taxes are collected for renting arrears ?",
        "ground_truth": "SELECT count(*) FROM rent_arrears",
        "amends": [
            "Do query the `rent_arrears` table instead of the `council_taxes` table, and do remove the `WHERE reason = 'renting_arrears'` filter instead of keeping it, as the entire table structure and purpose has changed to focus specifically on rent arrears data. The amended query now correctly counts all records in the rent_arrears table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about council taxes collected for renting arrears: query the \"rent_arrears\" table instead of the \"council_taxes\" table. 2) When the entire table structure and purpose has changed to focus specifically on rent arrears data: remove any WHERE clause filtering for reason = 'renting_arrears' as it is no longer needed. 3) When counting all records in the rent_arrears table: simply count all rows without any filtering conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM council_taxes WHERE reason = 'renting_arrears';",
            "SELECT COUNT(*) FROM Rent_Arrears;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Rent_Arrears;"
        ]
    },
    "1468": {
        "db_id": "college_2",
        "question": "Find the names of all instructors who have taught some course and the course_id.",
        "ground_truth": "SELECT name ,  course_id FROM instructor AS T1 JOIN teaches AS T2 ON T1.ID  =  T2.ID",
        "amends": [
            "Do add `JOIN teaches AS T2` instead of querying only the `instructors` table. Do use `ON T1.ID = T2.ID` instead of filtering with `WHERE course_id IS NOT NULL`. Do reference `instructor AS T1` instead of `instructors` to properly join with the teaches table. The amended query now correctly joins instructor and teaches tables to retrieve course assignments instead of relying on a simple null check."
        ],
        "rules": [
            "1) When answering about instructors who have taught courses: join table \"instructor\" as T1 with table \"teaches\" as T2 using the condition T1.ID = T2.ID to find matching teaching assignments. 2) When the question asks for instructor names and course IDs: select the exact columns T1.name and T2.course_id from the joined tables. 3) When combining instructor and teaches tables: perform an inner match where only rows with equal ID values in both tables are kept, ensuring we only get instructors who actually teach courses."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, course_id FROM instructors WHERE course_id IS NOT NULL;",
            "SELECT T1.name, T2.course_id\nFROM instructor AS T1\nJOIN teaches AS T2 ON T1.ID = T2.ID"
        ],
        "rule_sql": [
            "SELECT T1.name, T2.course_id FROM instructor T1 JOIN teaches T2 ON T1.ID = T2.ID"
        ]
    },
    "1152": {
        "db_id": "body_builder",
        "question": "List the snatch score and clean jerk score of body builders in ascending order of snatch score.",
        "ground_truth": "SELECT Snatch ,  Clean_Jerk FROM body_builder ORDER BY Snatch ASC",
        "amends": [
            "Do reference columns `Snatch` and `Clean_Jerk` instead of `snatch_score` and `clean_jerk_score`. Do query from table `body_builder` instead of `body_builders`. Do order by `Snatch` in ascending order instead of `clean_jerk_score`. The amended query now correctly selects the specified columns from the proper table with the intended sorting."
        ],
        "rules": [
            "1) When the question asks for \"snatch score\" and \"clean jerk score\": use the exact column names \"Snatch\" and \"Clean_Jerk\" from the body_builder table. 2) When querying about body builders: use the table name \"body_builder\" (singular form) instead of \"body_builders\". 3) When ordering results in ascending order of snatch score: sort by the \"Snatch\" column in ascending order, not by \"Clean_Jerk\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT snatch_score, clean_jerk_score FROM body_builders ORDER BY clean_jerk_score ASC;",
            "SELECT Snatch, Clean_Jerk FROM body_builder ORDER BY Snatch ASC;"
        ],
        "rule_sql": [
            "SELECT Snatch, Clean_Jerk FROM body_builder ORDER BY Snatch ASC;"
        ]
    },
    "5169": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "Find the id of the product ordered the most often on invoices.",
        "ground_truth": "SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do add `GROUP BY Product_ID` and change the ORDER BY to `COUNT(*) DESC` instead of ordering by `quantity DESC` without aggregation. Do include the aggregate function `COUNT(*)` in the ORDER BY clause instead of referencing the non-aggregated column `quantity` directly. This amendment ensures we find the product with the highest number of invoice occurrences rather than simply the invoice with the largest quantity, making the query correctly identify the most frequently sold product. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the product ordered the most often: count the number of invoice occurrences per product using COUNT(*) grouped by Product_ID. 2) When ranking products by frequency: order the results by the count in descending order to find the highest count. 3) When selecting the top product: take only the first row after ordering by count descending to get the product with maximum occurrences."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT product_id FROM invoices ORDER BY quantity DESC LIMIT 1;",
            "SELECT Product_ID\nFROM Invoices\nGROUP BY Product_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Product_ID\nFROM Invoices\nGROUP BY Product_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "3330": {
        "db_id": "college_1",
        "question": "What are the first names of all professors who teach more than one class?",
        "ground_truth": "SELECT T2.emp_fname FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num GROUP BY T1.prof_num HAVING count(*)  >  1",
        "amends": [
            "Do select `T2.emp_fname` from the `employee` table instead of `first_name` from `professors`. Do join `CLASS AS T1` with `employee AS T2` on `T1.prof_num = T2.emp_num` instead of querying only the `professors` table. Do use `GROUP BY T1.prof_num` with `HAVING count(*) > 1` instead of applying the aggregate condition directly in the `WHERE` clause without grouping. Do remove the incorrect `WHERE COUNT(class_id) > 1` filter that would cause a syntax error and instead implement proper grouping and having logic. The amended query now correctly identifies employees teaching more than one class by joining the class and employee tables and using appropriate aggregation."
        ],
        "rules": [
            "1) When the question asks for \"first names of professors\": use \"T2.emp_fname\" from the \"employee\" table instead of \"first_name\" from \"professors\". 2) When combining class and employee information: join \"CLASS AS T1\" with \"employee AS T2\" on \"T1.prof_num = T2.emp_num\" and keep only matching pairs (inner match). 3) When counting classes per professor: group by \"T1.prof_num\" and count all rows in each group. 4) When filtering for professors teaching more than one class: apply the condition \"count(*) > 1\" after grouping (using HAVING clause logic). 5) When answering about \"first names of all professors who teach more than one class\": make sure the output order: \"T2.emp_fname\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM professors WHERE COUNT(class_id) > 1;",
            "SELECT T2.EMP_FNAME \nFROM CLASS AS T1 \nJOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM \nGROUP BY T1.PROF_NUM \nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T2.emp_fname\nFROM CLASS AS T1\nINNER JOIN employee AS T2 ON T1.prof_num = T2.emp_num\nGROUP BY T1.prof_num\nHAVING COUNT(*) > 1\nORDER BY T2.emp_fname;"
        ]
    },
    "2663": {
        "db_id": "party_host",
        "question": "What are the themes of parties ordered by the number of hosts in ascending manner?",
        "ground_truth": "SELECT Party_Theme FROM party ORDER BY Number_of_hosts ASC",
        "amends": [
            "Do select `Party_Theme` instead of `theme, COUNT(host_id) as host_count`. Do remove the `COUNT` aggregation and `host_count` alias instead of including them. Do query from `party` instead of `parties`. Do remove the `GROUP BY theme` clause instead of grouping by theme. Do order by `Number_of_hosts ASC` instead of `host_count DESC`. The amended query now matches the intended behavior of selecting themes ordered by host count in ascending order."
        ],
        "rules": [
            "1) When answering about \"themes of parties ordered by number of hosts\": make sure the output order: Party_Theme 2) When the question mentions \"themes\": \"themes\" actually means \"Party_Theme in schema\" 3) When the question mentions \"ordered by number of hosts in ascending manner\": order rows by Number_of_hosts in ascending direction 4) When querying from the parties table: use table party instead of parties 5) When selecting columns: do not use COUNT aggregation or host_count alias, select only Party_Theme"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT theme, COUNT(host_id) as host_count FROM parties GROUP BY theme ORDER BY host_count DESC;",
            "SELECT Party_Theme FROM party ORDER BY Number_of_hosts ASC;"
        ],
        "rule_sql": [
            "SELECT Party_Theme FROM party ORDER BY Number_of_hosts ASC"
        ]
    },
    "442": {
        "db_id": "allergy_1",
        "question": "How many distinct allergies are there?",
        "ground_truth": "SELECT count(DISTINCT allergytype) FROM Allergy_type",
        "amends": [
            "Do count `DISTINCT allergytype` instead of counting all rows with `COUNT(*)`. Do query from `Allergy_type` table instead of from `allergies` table. The amended query now correctly counts distinct allergy types from the appropriate table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"distinct allergies\": make sure to count distinct values of \"allergytype\" instead of counting all rows. 2) When the question mentions \"allergies\": \"allergies\" actually means \"allergytype\" in the \"Allergy_type\" table. 3) When counting distinct entities: compute the number of unique values of the exact token \"allergytype\" from the \"Allergy_type\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM allergies;",
            "SELECT COUNT(DISTINCT AllergyType) FROM Allergy_Type"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT AllergyType) FROM Allergy_Type;"
        ]
    },
    "2403": {
        "db_id": "candidate_poll",
        "question": "What are the support, consider, and oppose rates of each candidate, ordered ascending by their unsure rate?",
        "ground_truth": "SELECT Support_rate ,  Consider_rate ,  Oppose_rate FROM candidate ORDER BY unsure_rate",
        "amends": [
            "Do select only `Support_rate`, `Consider_rate`, and `Oppose_rate` instead of including `candidate` and `unsure_rate` in the SELECT list. Do query from the `candidate` table instead of the `candidate_ratings` table. Do remove the `DESC` keyword from the ORDER BY clause instead of keeping it, while still ordering by `unsure_rate` in ascending order. The amended query now correctly selects the specified rating columns from the appropriate table and orders results by the unsure rate in default ascending order, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting columns for candidate rating rates: include only Support_rate, Consider_rate, and Oppose_rate from the candidate table. 2) When ordering results by unsure rate: use ascending order (default direction) without specifying DESC. 3) When querying candidate rating information: use the candidate table instead of candidate_ratings table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT candidate, support_rate, consider_rate, oppose_rate, unsure_rate \nFROM candidate_ratings \nORDER BY unsure_rate DESC;",
            "SELECT Support_rate, Consider_rate, Oppose_rate FROM candidate ORDER BY Unsure_rate;"
        ],
        "rule_sql": [
            "SELECT Support_rate, Consider_rate, Oppose_rate FROM candidate ORDER BY Unsure_rate ASC;"
        ]
    },
    "1825": {
        "db_id": "small_bank_1",
        "question": "What are names and savings balances of the three accounts with the highest savings balances?",
        "ground_truth": "SELECT T1.name ,  T2.balance FROM accounts AS T1 JOIN savings AS T2 ON T1.custid  =  T2.custid ORDER BY T2.balance DESC LIMIT 3",
        "amends": [
            "Do select `T1.name` and `T2.balance` instead of `name` and `savings_balance`. Do join `savings AS T2` on `T1.custid = T2.custid` instead of querying only the `accounts` table. Do order by `T2.balance DESC` instead of `savings_balance ASC`. The amended query now correctly joins account information with savings data and returns the top 3 highest balances instead of the lowest 3 values from a single table."
        ],
        "rules": [
            "1) When the question asks for \"names and savings balances\": select T1.name and T2.balance as output columns. 2) When combining account and savings information: join ACCOUNTS as T1 with savings as T2 where T1.custid = T2.custid and keep only matching pairs (inner match). 3) When the question asks for \"three accounts with the highest savings balances\": order results by T2.balance in descending order and keep the first 3 rows. 4) When handling identifier delimiters: do not replace the exact column names name, balance, and custid with any other delimiters or casing."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, savings_balance FROM accounts ORDER BY savings_balance ASC LIMIT 3;",
            "SELECT T1.name, T2.balance \nFROM ACCOUNTS AS T1 \nJOIN SAVINGS AS T2 ON T1.custid = T2.custid \nORDER BY T2.balance DESC \nLIMIT 3"
        ],
        "rule_sql": [
            "SELECT T1.name, T2.balance FROM ACCOUNTS AS T1 INNER JOIN SAVINGS AS T2 ON T1.custid = T2.custid ORDER BY T2.balance DESC LIMIT 3"
        ]
    },
    "536": {
        "db_id": "allergy_1",
        "question": "What are the first name and major of the students who are able to consume soy?",
        "ground_truth": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  \"Soy\")",
        "amends": [
            "Do select `fname` and `major` instead of `first_name` and `major`. Do use table `Student` instead of `students`. Do remove the direct `allergy = 'soy'` filter instead of keeping it. Do add a subquery with `NOT IN` condition instead of omitting it. Do reference `StuID` in both main query and subquery instead of missing the correlation. Do use table `Has_allergy` with filter `Allergy = \"Soy\"` instead of filtering directly on the students table. The amended query now correctly excludes students with soy allergies by using a correlated subquery instead of incorrectly assuming allergy information is stored directly in the student table."
        ],
        "rules": [
            "1) When the question asks for \"first name\" and \"major\" of students: use columns \"fname\" and \"major\" from table \"Student\" (aliased as T1). 2) When the question mentions students who are \"able to consume soy\": this means students who do NOT have a soy allergy, which requires excluding students with \"Soy\" allergy in the \"Has_allergy\" table. 3) When filtering for soy allergies: use table \"Has_allergy\" (aliased as T2) with condition T2.\"Allergy\" = \"Soy\" exactly. 4) When excluding students with soy allergies: use a NOT IN subquery that correlates T1.\"StuID\" with T2.\"StuID\" to ensure proper exclusion. 5) When combining Student and Has_allergy tables for exclusion: link rows where T1.\"StuID\" = T2.\"StuID\" for the correlation condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, major FROM students WHERE allergy = 'soy';",
            "SELECT fname, major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'Soy')"
        ],
        "rule_sql": [
            "SELECT T1.fname, T1.major FROM Student T1 WHERE T1.StuID NOT IN (SELECT T2.StuID FROM Has_Allergy T2 WHERE T2.Allergy = 'Soy' AND T1.StuID = T2.StuID)"
        ]
    },
    "1821": {
        "db_id": "small_bank_1",
        "question": "What are the names of customers with a higher checking balance than savings balance?",
        "ground_truth": "SELECT T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid WHERE T2.balance  >  T3.balance",
        "amends": [
            "Do reference `T1.name` from the `accounts` table instead of `name` from a non-existent `customers` table. Do join `checking AS T2` on `T1.custid = T2.custid` and `savings AS T3` on `T1.custid = T3.custid` instead of querying a single table. Do filter on `T2.balance > T3.balance` instead of `checking_balance > savings_balance` to compare actual account balances from separate tables. The amended query now correctly joins the accounts, checking, and savings tables to compare balances between account types, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for customer names: use \"T1.name\" from the \"accounts\" table instead of \"name\" from a non-existent \"customers\" table. 2) When comparing checking and savings balances: join \"checking AS T2\" on \"T1.custid = T2.custid\" and \"savings AS T3\" on \"T1.custid = T3.custid\" to access separate account balance tables. 3) When filtering for customers with higher checking than savings balance: use the condition \"T2.balance > T3.balance\" to compare actual account balances from the joined tables."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM customers WHERE checking_balance > savings_balance",
            "SELECT T1.name \nFROM ACCOUNTS AS T1\nJOIN CHECKING AS T2 ON T1.custid = T2.custid\nJOIN SAVINGS AS T3 ON T1.custid = T3.custid\nWHERE T2.balance > T3.balance"
        ],
        "rule_sql": [
            "SELECT T1.name \nFROM ACCOUNTS AS T1\nJOIN CHECKING AS T2 ON T1.custid = T2.custid\nJOIN SAVINGS AS T3 ON T1.custid = T3.custid\nWHERE T2.balance > T3.balance"
        ]
    },
    "3849": {
        "db_id": "e_learning",
        "question": "What are the personal names used both by some course authors and some students?",
        "ground_truth": "SELECT personal_name FROM Course_Authors_and_Tutors INTERSECT SELECT personal_name FROM Students",
        "amends": [
            "Do select `personal_name` instead of `author_name` and `student_name` from different tables. Do use `Course_Authors_and_Tutors` instead of `course_authors` as the source table. Do remove the redundant `DISTINCT` keywords since `INTERSECT` already eliminates duplicates. The amended query now correctly finds the intersection of personal names between course authors/tutors and students, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for personal names used by both course authors and students: use \"personal_name\" as the column name instead of \"author_name\" or \"student_name\". 2) When referring to course authors: use table \"Course_Authors_and_Tutors\" instead of \"course_authors\". 3) When finding the intersection of values between two tables: use INTERSECT operation without DISTINCT keywords as INTERSECT already eliminates duplicates."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT author_name FROM course_authors INTERSECT SELECT DISTINCT student_name FROM students;",
            "SELECT personal_name FROM Course_Authors_and_Tutors INTERSECT SELECT personal_name FROM Students"
        ],
        "rule_sql": [
            "SELECT personal_name FROM Course_Authors_and_Tutors INTERSECT SELECT personal_name FROM Students"
        ]
    },
    "5682": {
        "db_id": "dorm_1",
        "question": "Find the total capacity of all dorms.",
        "ground_truth": "SELECT sum(student_capacity) FROM dorm",
        "amends": [
            "Do use the column name `student_capacity` instead of `rooms` in the SELECT list. Do reference the table name `dorm` instead of `dorms` in the FROM clause. The amended query now correctly calculates the total student capacity from the dorm table."
        ],
        "rules": [
            "1) When the question asks for \"total capacity of all dorms\": use the exact column name \"student_capacity\" from the dorm table to calculate the sum. 2) When referencing the table containing dorm information: use the exact table name \"dorm\" (not \"dorms\") in the FROM clause. 3) When computing the total capacity: sum all values from the \"student_capacity\" column without any filtering conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(rooms) FROM dorms;",
            "SELECT SUM(student_capacity) FROM Dorm;"
        ],
        "rule_sql": [
            "SELECT SUM(student_capacity) FROM dorm"
        ]
    },
    "1413": {
        "db_id": "college_2",
        "question": "Which semeseter and year had the fewest students?",
        "ground_truth": "SELECT semester ,  YEAR FROM takes GROUP BY semester ,  YEAR ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do select `semester` and `YEAR` instead of `semester`, `year`, and `COUNT(*) as student_count`. Do use `FROM takes` instead of `FROM students`. Do remove the `COUNT(*)` aggregation and `GROUP BY` clause instead of keeping them. Do change `ORDER BY count(*)` instead of `ORDER BY student_count DESC`. Do maintain `LIMIT 1` as in the original query. The amended query now correctly selects from the takes table and orders by the count of records to find the semester and year with the fewest entries, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"fewest students\": count the number of records in the \"takes\" table using the canonical key for student enrollment records. 2) When the question asks for semester and year: select the exact columns \"semester\" and \"YEAR\" (with exact case) from the \"takes\" table. 3) When finding the semester and year with the fewest students: order the results by the count of records in ascending order and keep only the first result. 4) When counting enrollment records: use the \"takes\" table instead of the \"students\" table as it contains the enrollment information by semester and year."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT semester, year, COUNT(*) as student_count FROM students GROUP BY semester, year ORDER BY student_count DESC LIMIT 1;",
            "SELECT semester, year FROM takes GROUP BY semester, year ORDER BY COUNT(*) LIMIT 1"
        ],
        "rule_sql": [
            "SELECT semester, year FROM takes GROUP BY semester, year ORDER BY COUNT(*) ASC LIMIT 1;"
        ]
    },
    "6840": {
        "db_id": "flight_4",
        "question": "What is the number of different different airports that are destinations for American Airlines?",
        "ground_truth": "SELECT count(DISTINCT dst_apid) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'",
        "amends": [
            "Do use `count(DISTINCT dst_apid)` instead of `COUNT(*)` to count unique destination airports rather than all rows. Do join `airlines AS T1` with `routes AS T2` on `T1.alid = T2.alid` instead of querying only the `airports` table. Do filter on `T1.name = 'American Airlines'` instead of `airline = 'American Airlines'` to properly reference the airline name from the correct table. Do remove the incorrect table reference `airports` and instead use the appropriate tables `airlines` and `routes` to establish the correct relationship between airlines and their routes. The amended query now correctly counts distinct destination airports for American Airlines by joining the appropriate tables and using the correct filter condition."
        ],
        "rules": [
            "1) When answering about \"number of different airports that are destinations for American Airlines\": make sure the output order: count of distinct destination airports. 2) When the question mentions \"American Airlines\": \"American Airlines\" actually means \"T1.name = 'American Airlines'\" in schema. 3) When combining T1 (airlines) and T2 (routes) for shared entities: link rows where T1.alid = T2.alid exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"count of distinct destination airports\": compute the number of unique values of T2.dst_apid. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM airports WHERE airline = 'American Airlines';",
            "SELECT COUNT(DISTINCT T2.dst_apid) \nFROM airlines AS T1 \nJOIN routes AS T2 ON T1.alid = T2.alid \nWHERE T1.name = 'American Airlines'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT r.dst_apid) \nFROM routes r\nJOIN airlines a ON r.alid = a.alid\nWHERE a.name = 'American Airlines'"
        ]
    },
    "2488": {
        "db_id": "movie_1",
        "question": "For directors who had more than one movie, return the titles and produced years of all movies directed by them.",
        "ground_truth": "SELECT T1.title ,  T1.year FROM Movie AS T1 JOIN Movie AS T2 ON T1.director  =  T2.director WHERE T1.title != T2.title",
        "amends": [
            "Do select `title` and `year` from table `Movie` instead of `title` and `produced_year` from `movies`. Do use a self-join on `director` instead of grouping by `director`. Do add a join condition `T1.director = T2.director` instead of omitting it. Do move the count condition to a `WHERE` clause with `T1.title != T2.title` instead of using `HAVING COUNT(*) > 1`. Do remove the `GROUP BY` clause instead of keeping it. The amended query now correctly finds movies by the same director with different titles, matching the intended behavior.",
            "Do use `AS` for table aliases instead of omitting them. Do remove the unnecessary `GROUP BY T1.mID, T1.title, T1.year` and `HAVING COUNT(DISTINCT T2.mID) > 1` clauses instead of keeping them, as the right query simply finds movies by the same director with different titles without requiring multiple distinct movie IDs. The amended query now matches the right SQL's behavior of returning all movies that share a director but have different titles."
        ],
        "rules": [
            "1) When selecting movie information: use \"title\" and \"year\" columns from table \"Movie\" instead of \"title\" and \"produced_year\" from \"movies\". 2) When finding directors with multiple movies: use a self-join on \"director\" column instead of grouping by \"director\". 3) When joining tables for the same director: add join condition T1.director = T2.director to link movies by the same director. 4) When filtering for directors with multiple movies: use WHERE clause with T1.title != T2.title condition instead of HAVING COUNT(*) > 1. 5) When organizing results: remove GROUP BY clause since we're not aggregating but finding related movies.",
            "1) When answering about \"directors who had more than one movie\": find movies that share the same director but have different titles. 2) When combining Movie tables for shared directors: link rows where T1.director = T2.director and keep only matching pairs (inner match). 3) When filtering for different movie titles: ensure T1.title != T2.title to exclude same-title movies. 4) When selecting output columns: return T1.title and T1.year from the first Movie table. 5) When using table aliases: always use AS for table aliases instead of omitting them."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title, produced_year FROM movies GROUP BY director HAVING COUNT(*) > 1",
            "SELECT T1.title, T1.year \nFROM Movie T1\nJOIN Movie T2 ON T1.director = T2.director\nWHERE T1.title != T2.title\nGROUP BY T1.mID, T1.title, T1.year\nHAVING COUNT(DISTINCT T2.mID) > 1",
            "SELECT T1.title, T1.year\nFROM Movie T1\nJOIN Movie T2 ON T1.director = T2.director\nWHERE T1.title != T2.title"
        ],
        "rule_sql": [
            "SELECT T1.title, T1.year \nFROM Movie AS T1\nJOIN Movie AS T2 ON T1.director = T2.director\nWHERE T1.title != T2.title;"
        ]
    },
    "2853": {
        "db_id": "customer_deliveries",
        "question": "Find the name of the first 5 customers.",
        "ground_truth": "SELECT customer_name FROM Customers ORDER BY date_became_customer LIMIT 5",
        "amends": [
            "Do select only `customer_name` instead of all columns with `*`. Do add `ORDER BY date_became_customer` instead of omitting any ordering. Do reference the table as `Customers` instead of `customers` to match the correct case. The amended query now correctly returns the first 5 customer names ordered by their signup date instead of an arbitrary selection of all customer data."
        ],
        "rules": [
            "1) When answering about \"first 5 customers\": make sure the output order includes only \"customer_name\" column. 2) When the question mentions \"first\": order rows by \"date_became_customer\" in ascending order and keep the first 5 rows. 3) When referring to the customers table: use the exact identifier \"Customers\" with the correct case as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM customers LIMIT 5;",
            "SELECT customer_name FROM Customers ORDER BY date_became_customer LIMIT 5"
        ],
        "rule_sql": [
            "SELECT customer_name FROM Customers ORDER BY date_became_customer ASC LIMIT 5"
        ]
    },
    "4493": {
        "db_id": "decoration_competition",
        "question": "Show the names of members and the locations of colleges they go to in ascending alphabetical order of member names.",
        "ground_truth": "SELECT T2.Name ,  T1.College_Location FROM college AS T1 JOIN member AS T2 ON T1.College_ID  =  T2.College_ID ORDER BY T2.Name ASC",
        "amends": [
            "Do select `T2.Name` and `T1.College_Location` instead of `member_name` and `college_location`. Do join `college AS T1` with `member AS T2` on `T1.College_ID = T2.College_ID` instead of selecting directly from a single `members` table. Do order by `T2.Name ASC` instead of `college_location ASC`. The amended query now correctly joins the college and member tables to retrieve member names with their corresponding college locations, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting member names and college locations: use T2.\"Name\" for member names and T1.\"College_Location\" for college locations instead of member_name and college_location. 2) When combining college and member data: join \"college\" AS T1 with \"member\" AS T2 on T1.\"College_ID\" = T2.\"College_ID\" using an inner match. 3) When ordering results alphabetically by member names: order by T2.\"Name\" ASC instead of college_location ASC."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT member_name, college_location FROM members ORDER BY college_location ASC;",
            "SELECT T2.Name, T1.College_Location FROM college AS T1 JOIN member AS T2 ON T1.College_ID = T2.College_ID ORDER BY T2.Name ASC"
        ],
        "rule_sql": [
            "SELECT T2.\"Name\", T1.\"College_Location\" FROM \"college\" AS T1 INNER JOIN \"member\" AS T2 ON T1.\"College_ID\" = T2.\"College_ID\" ORDER BY T2.\"Name\" ASC;"
        ]
    },
    "519": {
        "db_id": "allergy_1",
        "question": "Find the last name and age of the student who has allergy to both milk and cat.",
        "ground_truth": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  \"Milk\" INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  \"Cat\")",
        "amends": [
            "Do select `lname` and `age` instead of `last_name` and `age`. Do use table `Student` instead of `students`. Do remove the incorrect `WHERE allergy = 'milk' AND allergy = 'cat'` condition that could never be true and instead use a subquery with `INTERSECT` to find students who have both milk and cat allergies from the `Has_allergy` table. Do reference the correct column `StuID` for the student identifier instead of the missing allergy column in the original table. The amended query now correctly identifies students with both specified allergies by intersecting results from the allergy table.",
            "Do use lowercase column names `lname` and `age` instead of uppercase `LName` and `Age`. Do remove the table alias `s` from the main query instead of keeping it. Do use double quotes `\"Milk\"` and `\"Cat\"` for string literals instead of single quotes `'milk'` and `'cat'`. Do use the correct table name `Has_allergy` (with lowercase 'a') instead of `Has_Allergy`. Do remove the table aliases `ha1` and `ha2` from the subquery instead of keeping them. The amended query now correctly identifies students with both milk and cat allergies using proper case sensitivity and syntax."
        ],
        "rules": [
            "1) When the question asks for \"last name\": use the exact column token \"LName\" from table \"Student\" instead of \"last_name\". 2) When the question asks for \"age\": use the exact column token \"Age\" from table \"Student\". 3) When the question asks about students with allergies to both \"milk\" and \"cat\": use the \"Has_allergy\" table to find students who have both allergies by intersecting results where allergy equals 'milk' and allergy equals 'cat'. 4) When combining student information with allergy data: link using the student identifier column \"StuID\" to match students from \"Student\" table with their allergies in \"Has_allergy\" table. 5) When selecting output columns: present them in the order \"LName\" then \"Age\" as specified in the question.",
            "1) When the question asks for last name and age: use column names \"lname\" and \"age\" without table aliases in the output. 2) When the question mentions \"allergy to milk\": use the exact string literal \"Milk\" with double quotes. 3) When the question mentions \"allergy to cat\": use the exact string literal \"Cat\" with double quotes. 4) When referring to the allergy table: use the exact table name \"Has_allergy\" with lowercase 'a'. 5) When querying the allergy table in subqueries: do not use table aliases for \"Has_allergy\". 6) When finding students with both milk and cat allergies: identify students who appear in both the set of students with \"Milk\" allergy and the set of students with \"Cat\" allergy."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name, age FROM students WHERE allergy = 'milk' AND allergy = 'cat'",
            "SELECT s.LName, s.Age\nFROM Student s\nWHERE s.StuID IN (\n    SELECT ha1.StuID\n    FROM Has_Allergy ha1\n    WHERE ha1.Allergy = 'milk'\n    INTERSECT\n    SELECT ha2.StuID\n    FROM Has_Allergy ha2\n    WHERE ha2.Allergy = 'cat'\n)",
            "SELECT lname, age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy = \"Milk\" INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy = \"Cat\")"
        ],
        "rule_sql": [
            "SELECT LName, Age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy = \"Milk\") AND StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy = \"Cat\")"
        ]
    },
    "6484": {
        "db_id": "scientist_1",
        "question": "What is the name and hours for the project which has the most scientists assigned to it?",
        "ground_truth": "SELECT T1.name ,  T1.hours FROM projects AS T1 JOIN assignedto AS T2 ON T1.code  =  T2.project GROUP BY T2.project ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `projects AS T1` with `assignedto AS T2` on `T1.code = T2.project` instead of querying only the `projects` table without any join. Do add `GROUP BY T2.project` to aggregate by project instead of missing the grouping clause entirely. Do use `count(*)` in the ORDER BY instead of `COUNT(scientist_id)` which would fail without proper grouping. Do reference columns with table aliases `T1.name` and `T1.hours` instead of unqualified `name` and `hours`. The amended query now correctly joins the projects with their assignments and aggregates to find the project with the most scientists assigned, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"the project which has the most scientists assigned to it\": make sure to join projects AS T1 with assignedto AS T2 on T1.code = T2.project using an inner match. 2) When counting scientists assigned to projects: use count(*) to count the number of assignment records per project. 3) When grouping by project: use GROUP BY T2.project to aggregate assignment counts by project. 4) When ordering by the count of scientists: order by the count in descending direction to find the project with the most scientists. 5) When selecting output columns: use T1.name and T1.hours for the project name and hours. 6) When limiting to the top result: keep only the first row after ordering by count descending."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, hours FROM projects ORDER BY COUNT(scientist_id) DESC LIMIT 1;",
            "SELECT T1.name, T1.hours\nFROM projects AS T1\nJOIN assignedto AS T2 ON T1.code = T2.project\nGROUP BY T2.project\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Name, T1.Hours\nFROM Projects AS T1\nINNER JOIN AssignedTo AS T2 ON T1.Code = T2.Project\nGROUP BY T2.Project\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "5063": {
        "db_id": "device",
        "question": "Count the number of different software platforms.",
        "ground_truth": "SELECT count(DISTINCT Software_Platform) FROM device",
        "amends": [
            "Do count `DISTINCT Software_Platform` instead of counting all rows with `COUNT(*)`. Do query from `device` table instead of `software_platforms` table. The amended query now correctly counts unique software platforms from the device table rather than counting all rows from an incorrect table."
        ],
        "rules": [
            "1) When counting different software platforms: count distinct values of \"Software_Platform\" column. 2) When the question asks about software platforms: use the \"device\" table instead of \"software_platforms\" table. 3) When counting distinct entities: use the exact column token \"Software_Platform\" with double quotes as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM software_platforms;",
            "SELECT COUNT(DISTINCT Software_Platform) FROM device;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT \"Software_Platform\") FROM device;"
        ]
    },
    "6380": {
        "db_id": "flight_company",
        "question": "Which of the airport names contains the word 'international'?",
        "ground_truth": "SELECT name FROM airport WHERE name LIKE '%international%'",
        "amends": [
            "Do reference the table as `airport` instead of `airports` to match the correct table name in the schema. The amended query now correctly filters for airport names containing 'international' from the proper table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about airport names containing 'international': use the exact table name \"airport\" (not \"airports\") as specified in the schema. 2) When filtering for names containing the word 'international': use the exact literal 'international' with the correct case and spacing as shown in the question. 3) When selecting airport names: ensure the output column is \"name\" from the \"airport\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM airports WHERE name LIKE '%international%';",
            "SELECT name FROM airport WHERE name LIKE '%international%';"
        ],
        "rule_sql": [
            "SELECT name FROM airport WHERE name LIKE '%international%';"
        ]
    },
    "3400": {
        "db_id": "manufacturer",
        "question": "Find the id and number of shops for the company that produces the most expensive furniture.",
        "ground_truth": "SELECT t1.manufacturer_id ,  t1.num_of_shops FROM manufacturer AS t1 JOIN furniture_manufacte AS t2 ON t1.manufacturer_id  =  t2.manufacturer_id ORDER BY t2.Price_in_Dollar DESC LIMIT 1",
        "amends": [
            "Do select `t1.manufacturer_id` and `t1.num_of_shops` instead of `company_id` and `COUNT(shop_id)`. Do use `FROM manufacturer AS t1 JOIN furniture_manufacte AS t2` instead of `FROM companies`. Do add `ON t1.manufacturer_id = t2.manufacturer_id` join condition instead of no join. Do remove the subquery and `WHERE furniture_price = MAX(furniture_price)` filter instead of keeping it. Do add `ORDER BY t2.Price_in_Dollar DESC LIMIT 1` instead of `GROUP BY company_id`. The amended query now correctly retrieves the manufacturer with the highest-priced furniture by joining tables and ordering by price instead of using an incorrect subquery approach."
        ],
        "rules": [
            "1) When answering about \"id and number of shops for the company that produces the most expensive furniture\": make sure the output order: manufacturer_id, num_of_shops. 2) When the question mentions \"company\": \"company\" actually means \"manufacturer in schema\" and use exact token \"t1.manufacturer_id\". 3) When the question mentions \"number of shops\": \"number of shops\" actually means \"num_of_shops in schema\" and use exact token \"t1.num_of_shops\". 4) When combining manufacturer and furniture_manufacte tables: link rows where the canonical keys are equal exactly as shown in the amends (t1.manufacturer_id = t2.manufacturer_id); keep only matching pairs (inner match). 5) When the question asks for \"the most expensive furniture\": rank rows by t2.Price_in_Dollar in descending direction and keep the first 1 row. 6) When handling text literals: do not change case, spacing, or punctuation for identifiers like \"manufacturer_id\", \"num_of_shops\", and \"Price_in_Dollar\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT company_id, COUNT(shop_id) AS shop_count\nFROM companies\nWHERE furniture_price = (SELECT MAX(furniture_price) FROM companies)\nGROUP BY company_id;",
            "SELECT t1.Manufacturer_ID, t1.Num_of_Shops \nFROM manufacturer AS t1 \nJOIN furniture_manufacte AS t2 ON t1.Manufacturer_ID = t2.Manufacturer_ID \nORDER BY t2.Price_in_Dollar DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT t1.Manufacturer_ID, t1.Num_of_Shops\nFROM manufacturer t1\nINNER JOIN furniture_manufacte t2 ON t1.Manufacturer_ID = t2.Manufacturer_ID\nORDER BY t2.Price_in_Dollar DESC\nLIMIT 1"
        ]
    },
    "4077": {
        "db_id": "student_1",
        "question": "What are the first and last names of the first-grade students who are NOT taught by teacher OTHA MOYER?",
        "ground_truth": "SELECT DISTINCT T1.firstname ,  T1.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.grade  =  1 EXCEPT SELECT T1.firstname ,  T1.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"OTHA\" AND T2.lastname  =  \"MOYER\"",
        "amends": [
            "Do use `DISTINCT` on `firstname` and `lastname` instead of omitting it. Do select from `list` table instead of `students` table. Do join on `classroom` instead of `teacher_id`. Do use `EXCEPT` operator to exclude records instead of using `!=` conditions in `WHERE`. Do filter for `grade = 1` in the main query instead of combining it with teacher filters. Do add a separate exclusion query for teachers named `\"OTHA\"` and `\"MOYER\"` instead of trying to exclude them with inequality conditions. Do use double quotes for string literals instead of single quotes. The amended query now correctly excludes students taught by the specific teacher while maintaining the grade filter, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting from the student list: use the \"list\" table instead of \"students\" table. 2) When joining teacher information: join on the \"classroom\" column instead of \"teacher_id\". 3) When filtering for first-grade students: apply \"grade = 1\" condition in the main query. 4) When excluding students taught by teacher OTHA MOYER: use EXCEPT operator with a separate query that identifies students taught by \"OTHA\" and \"MOYER\". 5) When handling string literals: use double quotes as in \"OTHA\" and \"MOYER\" instead of single quotes. 6) When selecting student names: use DISTINCT on firstname and lastname to avoid duplicates."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.first_name, s.last_name \nFROM students s\nJOIN teachers t ON s.teacher_id = t.teacher_id\nWHERE s.grade = 1 AND t.first_name != 'OTHA' AND t.last_name != 'MOYER';",
            "SELECT DISTINCT FirstName, LastName\nFROM list\nWHERE Grade = 1\nEXCEPT\nSELECT l.FirstName, l.LastName\nFROM list l\nJOIN teachers t ON l.Classroom = t.Classroom\nWHERE t.FirstName = \"OTHA\" AND t.LastName = \"MOYER\""
        ],
        "rule_sql": [
            "SELECT DISTINCT FirstName, LastName\nFROM list\nWHERE Grade = 1\nEXCEPT\nSELECT l.FirstName, l.LastName\nFROM list l\nJOIN teachers t ON l.Classroom = t.Classroom\nWHERE t.FirstName = \"OTHA\" AND t.LastName = \"MOYER\""
        ]
    },
    "4140": {
        "db_id": "film_rank",
        "question": "List the studios of each film and the number of films produced by that studio.",
        "ground_truth": "SELECT Studio ,  COUNT(*) FROM film GROUP BY Studio",
        "amends": [
            "Do use the correct table name `film` instead of `films` and maintain consistent capitalization with `Studio` instead of `studio` in both the SELECT list and GROUP BY clause, while preserving the aggregate function `COUNT(*)` unchanged."
        ],
        "rules": [
            "1) When the question asks about \"films\": use the exact table name \"film\" instead of \"films\". 2) When the question mentions \"studios\": use the exact column name \"Studio\" with consistent capitalization in both SELECT list and GROUP BY clause. 3) When counting films per studio: use COUNT(*) to count all rows in each studio group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT studio, COUNT(*) FROM films GROUP BY studio;",
            "SELECT Studio, COUNT(*) FROM film GROUP BY Studio;"
        ],
        "rule_sql": [
            "SELECT Studio, COUNT(*) AS Number_of_Films FROM film GROUP BY Studio;"
        ]
    },
    "626": {
        "db_id": "store_1",
        "question": "What is the name of all tracks in the album named Balls to the Wall?",
        "ground_truth": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = \"Balls to the Wall\";",
        "amends": [
            "Do use explicit `JOIN` syntax with `albums AS T1 JOIN tracks AS T2` instead of a subquery in the `WHERE` clause. Do reference `T2.name` instead of just `name` for clarity. Do join on `T1.id = T2.genre_id` instead of filtering by `album_id` from a subquery. Do filter with `T1.title = \"Balls to the Wall\"` instead of using a subquery to find the album_id. The amended query now correctly joins the albums and tracks tables and matches the RIGHT_SQL's behavior.",
            "Do join condition `ON T1.id = T2.genre_id` instead of `ON T1.id = T2.album_id` to correctly relate albums to tracks through genre_id rather than album_id. The amended query now matches RIGHT_SQL's behavior by fixing the join predicate to use the appropriate relationship between albums and tracks tables."
        ],
        "rules": [
            "1) When answering about \"tracks in the album named Balls to the Wall\": make sure the output order: T2.name 2) When combining albums and tracks tables: link rows where T1.id = T2.genre_id and keep only matching pairs (inner match) 3) When filtering for the album title: use exact literal \"Balls to the Wall\" for T1.title 4) When selecting track names: use T2.name as the output column",
            "1) When joining albums table (T1) with tracks table (T2): use the join condition T1.id = T2.genre_id instead of T1.id = T2.album_id to correctly relate albums to tracks through genre_id. 2) When filtering for the album named 'Balls to the Wall': use the exact literal 'Balls to the Wall' with case and spacing preserved. 3) When selecting track names from the tracks table: output the name column from T2."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM tracks WHERE album_id = (SELECT album_id FROM albums WHERE title = 'Balls to the Wall');",
            "SELECT T2.name \nFROM albums AS T1 \nJOIN tracks AS T2 ON T1.id = T2.album_id \nWHERE T1.title = 'Balls to the Wall'",
            "SELECT T2.name \nFROM albums AS T1 \nJOIN tracks AS T2 ON T1.id = T2.genre_id \nWHERE T1.title = 'Balls to the Wall'"
        ],
        "rule_sql": [
            "SELECT T2.name \nFROM albums T1 \nINNER JOIN tracks T2 ON T1.id = T2.genre_id \nWHERE T1.title = 'Balls to the Wall' \nORDER BY T2.name"
        ]
    },
    "4590": {
        "db_id": "solvency_ii",
        "question": "Show the most common type code across products.",
        "ground_truth": "SELECT Product_Type_Code FROM Products GROUP BY Product_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do reference the column as `Product_Type_Code` instead of `type_code` in both the SELECT list and GROUP BY clause. Do order by `COUNT(*) DESC` instead of `ASC` to find the most frequent product type rather than the least frequent. Do remove the alias `count` from the aggregate function instead of keeping it since it's not referenced in the ORDER BY. The amended query now correctly identifies the most common product type by counting occurrences in descending order.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, as the query only needs to return the `Product_Type_Code` with the highest count rather than displaying the count value itself. The amended query now correctly returns just the product type code with the most products, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"type code\": use the exact column name \"Product_Type_Code\" from the Products table. 2) When counting occurrences to find the most common type: count all rows using COUNT(*) and group by \"Product_Type_Code\". 3) When ordering to find the most common type: sort the results by the count in descending order (highest count first). 4) When the question asks for \"most common type code\": return only the top result (limit 1) after ordering by count descending.",
            "1) When answering about \"most common type code across products\": make sure the output order: Product_Type_Code only without count values. 2) When the question asks for \"most common type code\": rank rows by count of Product_Type_Code in descending order and keep the first 1 row. 3) When counting products per Product_Type_Code: compute the number of rows using the canonical key for products (Product_Type_Code)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type_code, COUNT(*) as count FROM products GROUP BY type_code ORDER BY count ASC LIMIT 1;",
            "SELECT Product_Type_Code, COUNT(*) \nFROM Products \nGROUP BY Product_Type_Code \nORDER BY COUNT(*) DESC \nLIMIT 1",
            "SELECT Product_Type_Code FROM Products GROUP BY Product_Type_Code ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Product_Type_Code FROM Products GROUP BY Product_Type_Code ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "6676": {
        "db_id": "driving_school",
        "question": "How many lessons taken by customer with first name as Rylan and last name as Goodwin were completed?",
        "ground_truth": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = \"Rylan\" AND T2.last_name = \"Goodwin\" AND T1.lesson_status_code = \"Completed\";",
        "amends": [
            "Do join `Customers AS T2` instead of querying only the `lessons` table. Do use `T1.customer_id = T2.customer_id` join condition instead of missing the table relationship entirely. Do reference `T2.first_name` and `T2.last_name` instead of the non-existent `customer_first_name` and `customer_last_name` columns. Do filter on `T1.lesson_status_code = \"Completed\"` instead of the incorrect `status = 'completed'` column reference. The amended query now correctly joins tables and references valid column names to match the intended behavior."
        ],
        "rules": [
            "1) When answering about lessons taken by a specific customer: combine the lessons table (T1) and Customers table (T2) using the exact join condition T1.customer_id = T2.customer_id, keeping only matching pairs. 2) When the question mentions \"first name as Rylan\": filter for T2.first_name = 'Rylan' exactly as specified. 3) When the question mentions \"last name as Goodwin\": filter for T2.last_name = 'Goodwin' exactly as specified. 4) When the question asks about \"lessons completed\": filter for T1.lesson_status_code = \"Completed\" using the exact literal value and column name. 5) When counting completed lessons: count the number of rows that satisfy all the specified conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM lessons \nWHERE customer_first_name = 'Rylan' AND customer_last_name = 'Goodwin' AND status = 'completed';",
            "SELECT COUNT(*) \nFROM Lessons AS T1\nJOIN Customers AS T2 ON T1.customer_id = T2.customer_id\nWHERE T2.first_name = 'Rylan' \nAND T2.last_name = 'Goodwin' \nAND T1.lesson_status_code = 'Completed'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Lessons T1\nJOIN Customers T2 ON T1.customer_id = T2.customer_id\nWHERE T2.first_name = 'Rylan' \nAND T2.last_name = 'Goodwin'\nAND T1.lesson_status_code = 'Completed'"
        ]
    },
    "2319": {
        "db_id": "perpetrator",
        "question": "List the names of people that are not perpetrators.",
        "ground_truth": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM perpetrator)",
        "amends": [
            "Do select `Name` instead of `name` to match the correct column casing. Do change the WHERE filter to use `People_ID NOT IN` with a subquery selecting from the `perpetrator` table instead of directly filtering on `perpetrator = 1`, which incorrectly treated the perpetrator table reference as a column. Do add the necessary subquery `(SELECT People_ID FROM perpetrator)` instead of omitting it, as the original query mistakenly assumed a boolean column rather than a separate table relationship. The amended query now correctly identifies people who are not perpetrators by checking against the perpetrator table's IDs rather than using an incorrect boolean comparison."
        ],
        "rules": [
            "1) When the question asks for \"names of people\": use the exact column token \"Name\" from the people table. 2) When identifying people who are not perpetrators: use a subquery to select People_ID from the perpetrator table and filter people where People_ID is not in that subquery. 3) When combining people and perpetrator tables: use People_ID as the linking key between tables to identify non-perpetrators."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM people WHERE perpetrator = 1;",
            "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM perpetrator)"
        ],
        "rule_sql": [
            "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM perpetrator)"
        ]
    },
    "5791": {
        "db_id": "customer_complaints",
        "question": "What are the prices of products that have never gotten a complaint?",
        "ground_truth": "SELECT product_price FROM products WHERE product_id NOT IN (SELECT product_id FROM complaints)",
        "amends": [
            "Do select `product_price` instead of `price` in the SELECT list. Do change the WHERE filter to use `product_id NOT IN` with a subquery selecting `product_id` from the `complaints` table instead of checking `complaint_id IS NULL`. Do remove the direct NULL check on `complaint_id` instead of keeping it, as the correct logic requires identifying products that have never been complained about by checking absence from the complaints table rather than assuming a NULL complaint_id field. The amended query now correctly identifies products without any complaints by using a proper anti-join pattern instead of relying on potentially incorrect NULL semantics."
        ],
        "rules": [
            "1) When selecting product prices: use \"product_price\" from the Products table instead of \"price\". 2) When identifying products without complaints: use a subquery to select \"product_id\" from the Complaints table and check that the product's ID is not in that list, rather than checking for NULL complaint_id values. 3) When combining product and complaint information: use the \"product_id\" column as the linking key between Products and Complaints tables."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT price FROM products WHERE complaint_id IS NULL;",
            "SELECT product_price FROM Products WHERE product_id NOT IN (SELECT product_id FROM Complaints)"
        ],
        "rule_sql": [
            "SELECT product_price FROM Products WHERE product_id NOT IN (SELECT product_id FROM Complaints)"
        ]
    },
    "2133": {
        "db_id": "company_1",
        "question": "how many female dependents are there?",
        "ground_truth": "SELECT count(*) FROM dependent WHERE sex  =  'F'",
        "amends": [
            "Do reference table `dependent` instead of `dependents` and use column `sex` instead of `gender`. Do filter for value `'F'` instead of `'male'` while maintaining the same aggregate `count(*)` structure. The amended query now correctly counts female dependents from the appropriate table with accurate column and value references."
        ],
        "rules": [
            "1) When the question asks about \"female dependents\": use table \"dependent\" instead of \"dependents\" and column \"sex\" instead of \"gender\". 2) When filtering for female dependents: use the exact literal value 'F' instead of 'male'. 3) When counting dependents: maintain the count(*) aggregate structure to count all matching rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM dependents WHERE gender = 'male';",
            "SELECT COUNT(*) FROM dependent WHERE sex = 'F';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM dependent WHERE sex = 'F'"
        ]
    },
    "216": {
        "db_id": "book_2",
        "question": "What are the titles of the books whose writer is not \"Elaine Lee\"?",
        "ground_truth": "SELECT Title FROM book WHERE Writer != \"Elaine Lee\"",
        "amends": [
            "Do use `Title` instead of `title` for the column name in the SELECT list. Do use `book` instead of `books` for the table name in the FROM clause. Do use `!=` instead of `=` in the WHERE filter condition. Do use `Writer` instead of `writer` for the column name in the WHERE clause. Do use double quotes instead of single quotes around the string literal. The amended query now correctly filters for books where the writer is not Elaine Lee instead of matching Elaine Lee, and uses the proper table and column names."
        ],
        "rules": [
            "1) When selecting book titles: use the exact column name \"Title\" from the book table. 2) When referring to the book table: use the exact table name \"book\" (not \"books\"). 3) When filtering for books whose writer is not \"Elaine Lee\": use the inequality operator (!=) instead of equality. 4) When referencing the writer column: use the exact column name \"Writer\" from the book table. 5) When using the string literal \"Elaine Lee\": enclose it in double quotes exactly as shown."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM books WHERE writer = 'Elaine Lee';",
            "SELECT Title FROM book WHERE Writer != \"Elaine Lee\";"
        ],
        "rule_sql": [
            "SELECT Title FROM book WHERE Writer != \"Elaine Lee\";"
        ]
    },
    "6806": {
        "db_id": "flight_4",
        "question": "What is the name, city, country, and elevation for every airport in the city of New York?",
        "ground_truth": "SELECT name ,  city ,  country ,  elevation FROM airports WHERE city  =  'New York'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, city, country, elevation FROM airports WHERE city = 'New York' ORDER BY name;"
        ],
        "rule_sql": [
            "SELECT name, city, country, elevation FROM airports WHERE city = 'New York';"
        ]
    },
    "2401": {
        "db_id": "candidate_poll",
        "question": "What is the id of the candidate with the lowest oppose rate?",
        "ground_truth": "SELECT Candidate_ID FROM candidate ORDER BY oppose_rate LIMIT 1",
        "amends": [
            "Do select `Candidate_ID` instead of `id` and order by `oppose_rate` instead of `support_rate ASC` instead of using different column names and sort criteria. Do reference table `candidate` instead of `candidates` instead of using a different table name. The amended query now correctly selects the candidate with the lowest opposition rate from the candidate table."
        ],
        "rules": [
            "1) When the question asks for \"id of the candidate\": use the exact column name \"Candidate_ID\" from the candidate table instead of \"id\". 2) When the question asks for \"lowest oppose rate\": order by the column \"oppose_rate\" in ascending direction to find the minimum value. 3) When referencing the candidate table: use the exact table name \"candidate\" instead of \"candidates\". 4) When selecting a single candidate with the lowest oppose rate: return only the top result after ordering by oppose_rate in ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM candidates ORDER BY support_rate ASC LIMIT 1;",
            "SELECT Candidate_ID FROM candidate ORDER BY Oppose_rate ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Candidate_ID FROM candidate ORDER BY Oppose_rate ASC LIMIT 1;"
        ]
    },
    "5364": {
        "db_id": "tracking_software_problems",
        "question": "How many problems are there for product voluptatem?",
        "ground_truth": "SELECT count(*) FROM product AS T1 JOIN problems AS T2 ON T1.product_id = T2.product_id WHERE T1.product_name = \"voluptatem\"",
        "amends": [
            "Do add a `JOIN` with `product AS T1` on `T1.product_id = T2.product_id` instead of querying only the `problems` table. Do filter on `T1.product_name = \"voluptatem\"` instead of filtering directly on `problems.product`. Do reference the joined table `T2` for the count instead of the original single table approach. The amended query now correctly joins the product table to filter by product name while counting related problems, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"problems for product voluptatem\": join the product table (as T1) with the problems table (as T2) using T1.product_id = T2.product_id to link related entities. 2) When filtering for product name \"voluptatem\": use T1.product_name = \"voluptatem\" instead of filtering directly on the problems table. 3) When counting problems: count using the joined table T2 (problems table) after establishing the correct product relationship through the join."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM problems WHERE product = 'voluptatem';",
            "SELECT COUNT(*) \nFROM Problems AS T2\nJOIN Product AS T1 ON T1.product_id = T2.product_id\nWHERE T1.product_name = 'voluptatem'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Product AS T1\nJOIN Problems AS T2 ON T1.product_id = T2.product_id\nWHERE T1.product_name = 'voluptatem'"
        ]
    },
    "126": {
        "db_id": "bike_1",
        "question": "How many different bike ids are there?",
        "ground_truth": "SELECT count(DISTINCT bike_id) FROM trip",
        "amends": [
            "Do select `count(DISTINCT bike_id)` instead of `COUNT(*)`. Do query from `trip` table instead of `bikes` table. The amended query now correctly counts distinct bike IDs from the trip data instead of counting all rows from the bikes table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"different bike ids\" or \"how many different bike ids\": count the number of unique values of the exact column \"bike_id\" from the \"trip\" table. 2) When counting distinct entities: use the DISTINCT keyword to ensure only unique values are counted, not all rows. 3) When the schema specifies a table named \"trip\": use this table instead of any other table that might contain similar information, as it contains the actual bike_id data needed for counting distinct bike IDs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM bikes;",
            "SELECT COUNT(DISTINCT bike_id) FROM trip;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT bike_id) FROM trip;"
        ]
    },
    "5396": {
        "db_id": "tracking_software_problems",
        "question": "Find the first and last name of the staff members who reported problems from the product \"rem\" but not \"aut\"?",
        "ground_truth": "SELECT T3.staff_first_name ,  T3.staff_last_name FROM problems AS T1 JOIN product AS T2 JOIN staff AS T3 ON T1.product_id = T2.product_id AND T1.reported_by_staff_id = T3.staff_id WHERE T2.product_name = \"rem\" EXCEPT SELECT T3.staff_first_name ,  T3.staff_last_name FROM problems AS T1 JOIN product AS T2 JOIN staff AS T3 ON T1.product_id = T2.product_id AND T1.reported_by_staff_id = T3.staff_id WHERE T2.product_name = \"aut\"",
        "amends": [
            "Do join `problems AS T1`, `product AS T2`, and `staff AS T3` with explicit join conditions instead of querying `staff` directly without joins. Do use `T2.product_name = \"rem\"` instead of `product = 'rem'` and add an EXCEPT clause to exclude staff who reported \"aut\" products instead of using `AND product != 'aut'`. Do reference specific columns `T3.staff_first_name` and `T3.staff_last_name` instead of generic `first_name` and `last_name`. Do establish proper join relationships through `T1.product_id = T2.product_id` and `T1.reported_by_staff_id = T3.staff_id` instead of missing table connections entirely. The amended query now correctly identifies staff who reported \"rem\" products while excluding those who reported \"aut\" products, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about staff members who reported problems: join tables problems AS T1, product AS T2, and staff AS T3 using T1.product_id = T2.product_id and T1.reported_by_staff_id = T3.staff_id to establish proper relationships. 2) When the question mentions \"product 'rem'\": use T2.product_name = \"rem\" exactly as specified with double quotes. 3) When the question asks to exclude staff who reported \"aut\" products: use an EXCEPT clause to exclude staff who reported products with T2.product_name = \"aut\" instead of using AND product != 'aut'. 4) When selecting staff names: use T3.staff_first_name and T3.staff_last_name instead of generic first_name and last_name columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name \nFROM staff \nWHERE product = 'rem' \nAND product != 'aut';",
            "SELECT T3.staff_first_name, T3.staff_last_name\nFROM Problems AS T1\nJOIN Product AS T2 ON T1.product_id = T2.product_id\nJOIN Staff AS T3 ON T1.reported_by_staff_id = T3.staff_id\nWHERE T2.product_name = 'rem'\nEXCEPT\nSELECT T3.staff_first_name, T3.staff_last_name\nFROM Problems AS T1\nJOIN Product AS T2 ON T1.product_id = T2.product_id\nJOIN Staff AS T3 ON T1.reported_by_staff_id = T3.staff_id\nWHERE T2.product_name = 'aut'"
        ],
        "rule_sql": [
            "SELECT T3.staff_first_name, T3.staff_last_name\nFROM Problems AS T1\nJOIN Product AS T2 ON T1.product_id = T2.product_id\nJOIN Staff AS T3 ON T1.reported_by_staff_id = T3.staff_id\nWHERE T2.product_name = \"rem\"\nEXCEPT\nSELECT T3.staff_first_name, T3.staff_last_name\nFROM Problems AS T1\nJOIN Product AS T2 ON T1.product_id = T2.product_id\nJOIN Staff AS T3 ON T1.reported_by_staff_id = T3.staff_id\nWHERE T2.product_name = \"aut\""
        ]
    },
    "6992": {
        "db_id": "culture_company",
        "question": "What is the average, maximum, and minimum budget for all movies before 2000.",
        "ground_truth": "SELECT avg(budget_million) ,  max(budget_million) ,  min(budget_million) FROM movie WHERE YEAR  <  2000",
        "amends": [
            "Do use column `budget_million` instead of `budget` in all aggregate functions. Do change the filter condition to `YEAR < 2000` instead of `year >= 2000`. Do reference table `movie` instead of `movies` in the FROM clause. The amended query now correctly calculates budget statistics for movies released before the year 2000 using the appropriate column name and table reference."
        ],
        "rules": [
            "1) When the question asks for budget statistics: use the column \"budget_million\" instead of \"budget\" for all aggregate calculations. 2) When filtering movies by release date before 2000: use the condition YEAR < 2000 instead of year >= 2000. 3) When referencing the movie table: use the exact table name \"movie\" instead of \"movies\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(budget), MAX(budget), MIN(budget) FROM movies WHERE year >= 2000",
            "SELECT AVG(Budget_million) AS average_budget, MAX(Budget_million) AS maximum_budget, MIN(Budget_million) AS minimum_budget FROM movie WHERE Year < 2000"
        ],
        "rule_sql": [
            "SELECT AVG(Budget_million) AS average_budget, MAX(Budget_million) AS maximum_budget, MIN(Budget_million) AS minimum_budget FROM movie WHERE Year < 2000"
        ]
    },
    "6105": {
        "db_id": "customers_and_addresses",
        "question": "Find the name and active date of the customer that use email as the contact channel.",
        "ground_truth": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  'Email'",
        "amends": [
            "Do select `t1.customer_name` and `t2.active_from_date` instead of `name` and `active_date`. Do join `customer_contact_channels AS t2` on `t1.customer_id = t2.customer_id` instead of querying only the `customers` table. Do filter on `t2.channel_code = 'Email'` instead of `contact_channel = 'phone'`. The amended query now correctly retrieves customer information from the joined contact channels table with the proper email filter instead of the original phone-based approach."
        ],
        "rules": [
            "1) When the question asks for customer name and active date: select \"t1.customer_name\" and \"t2.active_from_date\" as output columns. 2) When combining customer information with contact channels: join \"customers\" as T1 with \"customer_contact_channels\" as T2 where \"t1.customer_id = t2.customer_id\" and keep only matching pairs (inner match). 3) When filtering for email contact channel: include only rows where \"t2.channel_code\" equals exactly 'Email' (case-sensitive)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, active_date FROM customers WHERE contact_channel = 'phone';",
            "SELECT t1.customer_name, t2.active_from_date\nFROM Customers AS t1\nJOIN Customer_Contact_Channels AS t2 ON t1.customer_id = t2.customer_id\nWHERE t2.channel_code = 'Email'"
        ],
        "rule_sql": [
            "SELECT t1.customer_name, t2.active_from_date\nFROM Customers AS t1\nINNER JOIN Customer_Contact_Channels AS t2 ON t1.customer_id = t2.customer_id\nWHERE t2.channel_code = 'Email';"
        ]
    },
    "6361": {
        "db_id": "school_bus",
        "question": "Show the school name and type for schools without a school bus.",
        "ground_truth": "SELECT school ,  TYPE FROM school WHERE school_id NOT IN (SELECT school_id FROM school_bus)",
        "amends": [
            "Do select `school` and `TYPE` instead of `school_name` and `school_type`. Do use table `school` instead of `schools`. Do remove the `WHERE school_bus = 'yes'` filter instead of keeping it. Do add a subquery with `NOT IN` condition checking `school_id` against `school_bus` table instead of omitting it. The amended query now correctly excludes schools that have bus service by checking their absence in the school_bus table rather than incorrectly filtering for schools with bus service."
        ],
        "rules": [
            "1) When the question asks for school name and type: select \"school\" and \"TYPE\" columns instead of \"school_name\" and \"school_type\". 2) When referring to the schools table: use table \"school\" instead of \"schools\". 3) When filtering for schools without a school bus: remove any condition checking for school_bus = 'yes' and instead check that the school's identifier is not present in the school_bus table. 4) When excluding schools with bus service: use a subquery that checks if \"school_id\" is not in the school_bus table rather than filtering for positive bus service presence."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT school_name, school_type FROM schools WHERE school_bus = 'yes';",
            "SELECT school, Type FROM school WHERE School_ID NOT IN (SELECT School_ID FROM school_bus)"
        ],
        "rule_sql": [
            "SELECT school, Type FROM school WHERE School_ID NOT IN (SELECT School_ID FROM school_bus)"
        ]
    },
    "5125": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "Return the name of the marketing region the store Rob Dinning is located in.",
        "ground_truth": "SELECT T1.Marketing_Region_Name FROM Marketing_Regions AS T1 JOIN Stores AS T2 ON T1.Marketing_Region_Code  =  T2.Marketing_Region_Code WHERE T2.Store_Name  =  \"Rob Dinning\"",
        "amends": [
            "Do select `Marketing_Region_Name` from the `Marketing_Regions` table instead of `store_name` from the `marketing_regions` table. Do add a `JOIN` with the `Stores` table on `Marketing_Region_Code = Marketing_Region_Code` instead of querying only a single table. Do change the filter to `Store_Name = \"Rob Dinning\"` in the joined `Stores` table instead of `manager = 'Rob Dinning'` in the marketing regions table. The amended query now correctly retrieves marketing region names for stores managed by Rob Dinning instead of incorrectly looking for a manager field in the marketing regions table, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the marketing region name: select \"Marketing_Region_Name\" from the \"Marketing_Regions\" table. 2) When the question mentions a store name \"Rob Dinning\": filter using \"Store_Name\" = \"Rob Dinning\" in the \"Stores\" table. 3) When combining \"Marketing_Regions\" and \"Stores\" tables: link rows where \"Marketing_Region_Code\" = \"Marketing_Region_Code\" between the tables and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT store_name FROM marketing_regions WHERE manager = 'Rob Dinning';",
            "SELECT mr.Marketing_Region_Name \nFROM Marketing_Regions mr\nJOIN Stores s ON mr.Marketing_Region_Code = s.Marketing_Region_Code\nWHERE s.Store_Name = 'Rob Dinning'"
        ],
        "rule_sql": [
            "SELECT mr.Marketing_Region_Name\nFROM Marketing_Regions mr\nINNER JOIN Stores s ON mr.Marketing_Region_Code = s.Marketing_Region_Code\nWHERE s.Store_Name = 'Rob Dinning';"
        ]
    },
    "5398": {
        "db_id": "tracking_software_problems",
        "question": "Find the products which have problems reported by both Lacey Bosco and Kenton Champlin?",
        "ground_truth": "SELECT T2.product_name FROM problems AS T1 JOIN product AS T2 JOIN staff AS T3 ON T1.product_id = T2.product_id AND T1.reported_by_staff_id = T3.staff_id WHERE T3.staff_first_name = \"Lacey\" AND T3.staff_last_name = \"Bosco\" INTERSECT SELECT T2.product_name FROM problems AS T1 JOIN product AS T2 JOIN staff AS T3 ON T1.product_id = T2.product_id AND T1.reported_by_staff_id = T3.staff_id WHERE T3.staff_first_name = \"Kenton\" AND T3.staff_last_name = \"Champlin\"",
        "amends": [
            "Do use `INTERSECT` with two separate queries instead of `OR` conditions with `GROUP BY` and `HAVING`. Do join `staff` table instead of `users` table, using `staff_id` instead of `user_id` and `staff_first_name`/`staff_last_name` instead of `first_name`/`last_name`. Do reference `reported_by_staff_id` instead of `reported_by` in the join condition. Do use `product` table instead of `products` with alias `T2` instead of `p`. Do remove `GROUP BY` and `HAVING COUNT(DISTINCT u.user_id) = 2` entirely instead of keeping them. Do use double quotes around string literals instead of single quotes. The amended query now correctly finds products reported by both specified staff members using intersection logic instead of flawed grouping approach.",
            "Do select only `product_name` instead of both `product_id` and `product_name`. Do use table aliases `T1`, `T2`, and `T3` instead of `p`, `pr`, and `s`. Do combine join conditions with `AND` in a single `JOIN` clause instead of separate `JOIN` statements. Do reference `T3.staff_first_name` and `T3.staff_last_name` instead of `s.staff_first_name` and `s.staff_last_name`. The amended query now correctly identifies products reported by both specified staff members through proper INTERSECT operation."
        ],
        "rules": [
            "1) When the question asks for products reported by multiple specific staff members: use INTERSECT logic with separate queries for each staff member instead of OR conditions with GROUP BY and HAVING. 2) When joining staff information: use the \"staff\" table with columns \"staff_id\", \"staff_first_name\", and \"staff_last_name\" instead of a \"users\" table. 3) When linking problems to staff: use \"reported_by_staff_id\" instead of \"reported_by\" as the join condition. 4) When referencing products: use the \"product\" table (alias T2) instead of \"products\" table. 5) When filtering for specific staff members: use exact string literals with double quotes like \"Lacey\" and \"Bosco\" for first and last names. 6) When combining results for multiple conditions: remove GROUP BY and HAVING COUNT(DISTINCT) clauses entirely when using INTERSECT approach.",
            "1) When answering about \"products which have problems reported by both Lacey Bosco and Kenton Champlin\": make sure the output order: T1.product_name. 2) When the question mentions \"Lacey Bosco\": \"Lacey Bosco\" actually means T3.staff_first_name = \"Lacey\" AND T3.staff_last_name = \"Bosco\" in schema. 3) When the question mentions \"Kenton Champlin\": \"Kenton Champlin\" actually means T3.staff_first_name = \"Kenton\" AND T3.staff_last_name = \"Champlin\" in schema. 4) When combining T1, T2, and T3 for shared entities: link rows where T1.product_id = T2.product_id AND T2.reported_by_staff_id = T3.staff_id; keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for string literals \"Lacey\", \"Bosco\", \"Kenton\", and \"Champlin\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.product_name \nFROM products p\nJOIN problems pr ON p.product_id = pr.product_id\nJOIN users u ON pr.reported_by = u.user_id\nWHERE u.first_name = 'Lacey' AND u.last_name = 'Bosco'\nOR u.first_name = 'Kenton' AND u.last_name = 'Champlin'\nGROUP BY p.product_id\nHAVING COUNT(DISTINCT u.user_id) = 2;",
            "SELECT p.product_id, p.product_name\nFROM Product p\nJOIN Problems pr ON p.product_id = pr.product_id\nJOIN Staff s ON pr.reported_by_staff_id = s.staff_id\nWHERE s.staff_first_name = \"Lacey\" AND s.staff_last_name = \"Bosco\"\nINTERSECT\nSELECT p.product_id, p.product_name\nFROM Product p\nJOIN Problems pr ON p.product_id = pr.product_id\nJOIN Staff s ON pr.reported_by_staff_id = s.staff_id\nWHERE s.staff_first_name = \"Kenton\" AND s.staff_last_name = \"Champlin\"",
            "SELECT T2.product_name\nFROM Problems T1\nJOIN Product T2 ON T1.product_id = T2.product_id\nJOIN Staff T3 ON T1.reported_by_staff_id = T3.staff_id\nWHERE T3.staff_first_name = \"Lacey\" AND T3.staff_last_name = \"Bosco\"\nINTERSECT\nSELECT T2.product_name\nFROM Problems T1\nJOIN Product T2 ON T1.product_id = T2.product_id\nJOIN Staff T3 ON T1.reported_by_staff_id = T3.staff_id\nWHERE T3.staff_first_name = \"Kenton\" AND T3.staff_last_name = \"Champlin\""
        ],
        "rule_sql": [
            "SELECT T1.product_name\nFROM Product T1\nJOIN Problems T2 ON T1.product_id = T2.product_id\nJOIN Staff T3 ON T2.reported_by_staff_id = T3.staff_id\nWHERE T3.staff_first_name = \"Lacey\" AND T3.staff_last_name = \"Bosco\"\nINTERSECT\nSELECT T1.product_name\nFROM Product T1\nJOIN Problems T2 ON T1.product_id = T2.product_id\nJOIN Staff T3 ON T2.reported_by_staff_id = T3.staff_id\nWHERE T3.staff_first_name = \"Kenton\" AND T3.staff_last_name = \"Champlin\""
        ]
    },
    "3549": {
        "db_id": "music_1",
        "question": "What is the average rating of songs produced by female artists?",
        "ground_truth": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  \"Female\"",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `a` and `s`. Do reference `T2.rating` in the aggregate function instead of `s.rating`. Do join on `T1.artist_name = T2.artist_name` instead of `s.artist_id = a.id`. Do use double quotes around the string literal \"Female\" instead of single quotes 'female'. Do reference the table as `song` instead of `songs` and `artist` instead of `artists`. The amended query now correctly matches the intended behavior by joining on artist names rather than IDs and using consistent table naming conventions."
        ],
        "rules": [
            "1) When joining tables artist and song: link rows where T1.artist_name = T2.artist_name and keep only matching pairs (inner match). 2) When filtering for female artists: use the exact string literal \"Female\" with double quotes and proper case. 3) When computing average rating: use T2.rating as the column for the aggregate function. 4) When referring to table aliases: use T1 for artist table and T2 for song table consistently. 5) When naming tables: use exact table names \"artist\" and \"song\" instead of plural forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(s.rating) \nFROM songs s \nJOIN artists a ON s.artist_id = a.id \nWHERE a.gender = 'female';",
            "SELECT AVG(T2.rating) FROM artist T1 JOIN song T2 ON T1.artist_name = T2.artist_name WHERE T1.gender = \"Female\""
        ],
        "rule_sql": [
            "SELECT AVG(T2.rating) FROM artist T1 INNER JOIN song T2 ON T1.artist_name = T2.artist_name WHERE T1.gender = \"Female\""
        ]
    },
    "2617": {
        "db_id": "inn_1",
        "question": "What are the bed type and name of all the rooms with traditional decor?",
        "ground_truth": "SELECT roomName ,  bedType FROM Rooms WHERE decor = \"traditional\";",
        "amends": [
            "Do select `roomName` and `bedType` instead of `bed_type` and `name`. Do reference table `Rooms` instead of `rooms`. Do filter for `\"traditional\"` decor instead of `'modern'` decor. The amended query now correctly retrieves traditional decor room names and bed types from the Rooms table."
        ],
        "rules": [
            "1) When the question asks for \"bed type and name\" of rooms: select \"bedType\" and \"roomName\" columns from the \"Rooms\" table. 2) When the question specifies rooms with \"traditional\" decor: filter rows where the decor column equals exactly 'traditional' (case-sensitive). 3) When referring to the table containing room information: use the exact table name \"Rooms\" with proper capitalization."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT bed_type, name FROM rooms WHERE decor = 'modern';",
            "SELECT roomName, bedType FROM Rooms WHERE decor = 'traditional';"
        ],
        "rule_sql": [
            "SELECT bedType, roomName FROM Rooms WHERE decor = 'traditional';"
        ]
    },
    "3000": {
        "db_id": "sakila_1",
        "question": "What is the largest payment amount?",
        "ground_truth": "SELECT amount FROM payment ORDER BY amount DESC LIMIT 1",
        "amends": [
            "Do select the single `amount` column instead of using `MIN(amount)` aggregate function. Do add `ORDER BY amount DESC` to sort results in descending order instead of omitting any ordering. Do add `LIMIT 1` to return only the top row instead of returning all aggregated results. The amended query now correctly retrieves the maximum payment amount by sorting descending and limiting to one row, matching the RIGHT_SQL's behavior of finding the highest value rather than the minimum."
        ],
        "rules": [
            "1) When the question asks for the \"largest\" payment amount: sort rows by the \"amount\" column in descending order and keep only the first row. 2) When selecting the payment amount: use the exact column name \"amount\" without aggregation functions. 3) When ordering results: use the exact column name \"amount\" with descending direction to find the maximum value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(amount) FROM payments;",
            "SELECT amount FROM payment ORDER BY amount DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT amount FROM payment ORDER BY amount DESC LIMIT 1;"
        ]
    },
    "4066": {
        "db_id": "student_1",
        "question": "How many students does LORIA ONDERSMA teaches?",
        "ground_truth": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"LORIA\" AND T2.lastname  =  \"ONDERSMA\"",
        "amends": [
            "Do join `list AS T1` and `teachers AS T2` on `T1.classroom = T2.classroom` instead of querying only the `students` table. Do filter on `T2.firstname = \"LORIA\"` and `T2.lastname = \"ONDERSMA\"` instead of using a single `teacher_name` column. Do use the correct table structure with separate first and last name columns instead of assuming a combined teacher_name field. The amended query now correctly matches the RIGHT_SQL's behavior by properly joining tables and filtering on the appropriate name fields."
        ],
        "rules": [
            "1) When answering about \"how many students does LORIA ONDERSMA teaches\": make sure the output order: count of students\n2) When the question mentions \"LORIA ONDERSMA\": \"LORIA ONDERSMA\" actually means \"T2.firstname = 'LORIA' and T2.lastname = 'ONDERSMA'\" in schema\n3) When combining list AS T1 and teachers AS T2 for shared entities: link rows where T1.classroom = T2.classroom exactly as shown in the amends; keep only matching pairs (inner match)\n4) When the question asks for \"count of students\": compute the number of rows using the canonical key token for students from T1 (e.g., T1.student_id or equivalent primary key)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE teacher_name = 'LORIA ONDERSMA';",
            "SELECT COUNT(*) FROM list AS T1 JOIN teachers AS T2 ON T1.Classroom = T2.Classroom WHERE T2.FirstName = 'LORIA' AND T2.LastName = 'ONDERSMA'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS \"count of students\"\nFROM list AS T1\nINNER JOIN teachers AS T2 ON T1.Classroom = T2.Classroom\nWHERE T2.FirstName = 'LORIA' AND T2.LastName = 'ONDERSMA'"
        ]
    },
    "6163": {
        "db_id": "music_4",
        "question": "How many distinct artists do the volumes associate to?",
        "ground_truth": "SELECT COUNT(DISTINCT Artist_ID) FROM volume",
        "amends": [
            "Do `COUNT(DISTINCT Artist_ID)` instead of `COUNT(*)` to count unique artists rather than all rows. Do reference table `volume` instead of `volumes` to use the correct table name. End with confirmation that the amended query now correctly counts distinct artists from the volume table."
        ],
        "rules": [
            "1) When counting distinct artists from the volume table: use COUNT(DISTINCT Artist_ID) to count unique artists rather than all rows. 2) When referencing the table containing artist information: use the exact table name \"volume\" instead of \"volumes\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM volumes;",
            "SELECT COUNT(DISTINCT Artist_ID) FROM volume;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Artist_ID) FROM volume;"
        ]
    },
    "4450": {
        "db_id": "network_2",
        "question": "Find the person who has exactly one friend.",
        "ground_truth": "SELECT name FROM PersonFriend GROUP BY name HAVING count(*)  =  1",
        "amends": [
            "Do select `name` directly from `PersonFriend` instead of joining through `person` and `friend` tables. Do use `GROUP BY name` instead of `GROUP BY p1.id`. Do use `count(*) = 1` instead of `COUNT(f1.friend_id) = 1` to count all rows in the group rather than specific non-null friend_id values. The amended query now correctly identifies persons with exactly one friend by counting all group rows directly from the PersonFriend table."
        ],
        "rules": [
            "1) When answering about \"person who has exactly one friend\": make sure to select \"name\" directly from the \"PersonFriend\" table. 2) When grouping to count friends per person: use \"GROUP BY name\" to organize results by person name. 3) When counting the number of friends per person: use count(*) = 1 to count all rows in each group rather than counting specific non-null values. 4) When the question asks for persons with exactly one friend: ensure the condition checks that the count of all group rows equals exactly 1."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p1.name \nFROM person p1 \nJOIN friend f1 ON p1.id = f1.person_id \nGROUP BY p1.id \nHAVING COUNT(f1.friend_id) = 1;",
            "SELECT name FROM PersonFriend GROUP BY name HAVING COUNT(*) = 1"
        ],
        "rule_sql": [
            "SELECT name FROM PersonFriend GROUP BY name HAVING COUNT(*) = 1;"
        ]
    },
    "2449": {
        "db_id": "movie_1",
        "question": "How many movie ratings have more than 3 stars?",
        "ground_truth": "SELECT count(*) FROM Rating WHERE stars  >  3",
        "amends": [
            "Do reference the table as `Rating` instead of `ratings` to match the correct table name. Do filter with `stars > 3` instead of `stars <= 3` to count ratings with more than 3 stars instead of 3 or fewer stars. The amended query now correctly counts ratings with over 3 stars as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When referencing the ratings table: use the exact table name \"Rating\" with double quotes and proper capitalization. 2) When filtering for ratings with more than 3 stars: use the condition stars > 3 (strictly greater than 3, not including 3). 3) When counting movie ratings: count all rows from the Rating table that satisfy the stars > 3 condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM ratings WHERE stars <= 3;",
            "SELECT COUNT(*) FROM Rating WHERE stars > 3"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM \"Rating\" WHERE stars > 3"
        ]
    },
    "4513": {
        "db_id": "document_management",
        "question": "Find the list of documents that are both in the most three popular type and have the most three popular structure.",
        "ground_truth": "SELECT document_name FROM documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT 3 INTERSECT SELECT document_name FROM documents GROUP BY document_structure_code ORDER BY count(*) DESC LIMIT 3",
        "amends": [
            "Do select only `document_name` instead of selecting all columns with `d.*`. Do use `GROUP BY document_type_code` and `GROUP BY document_structure_code` instead of grouping by `type` and `structure`. Do use `ORDER BY count(*) DESC` instead of ordering by alias `count`. Do use `INTERSECT` to find common document names instead of joining on two separate subqueries with `JOIN popular_types` and `JOIN popular_structures`. Do remove the outer `ORDER BY d.id` instead of keeping it. The amended query now correctly finds document names that appear in both the top 3 most frequent document types and top 3 most frequent document structures, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting document names from the Documents table: use only \"document_name\" column instead of all columns. 2) When grouping documents by type: use \"document_type_code\" column for grouping instead of \"type\". 3) When grouping documents by structure: use \"document_structure_code\" column for grouping instead of \"structure\". 4) When ordering by count in popularity rankings: order by count(*) DESC instead of using an alias. 5) When finding documents that belong to both top 3 most popular types and top 3 most popular structures: use INTERSECT operation to find common document names instead of JOIN operations. 6) When the question asks for a list of documents: do not include any outer ORDER BY clause on document id."
        ],
        "amend_res": -1,
        "rule_res": -1,
        "amend_sql": [
            "SELECT d.* \nFROM documents d\nJOIN (\n    SELECT type, COUNT(*) as count\n    FROM documents\n    GROUP BY type\n    ORDER BY count DESC\n    LIMIT 3\n) popular_types ON d.type = popular_types.type\nJOIN (\n    SELECT structure, COUNT(*) as count\n    FROM documents\n    GROUP BY structure\n    ORDER BY count DESC\n    LIMIT 3\n) popular_structures ON d.structure = popular_structures.structure\nORDER BY d.id;",
            "SELECT document_name\nFROM Documents\nWHERE document_type_code IN (\n    SELECT document_type_code\n    FROM Documents\n    GROUP BY document_type_code\n    ORDER BY COUNT(*) DESC\n    LIMIT 3\n)\nINTERSECT\nSELECT document_name\nFROM Documents\nWHERE document_structure_code IN (\n    SELECT document_structure_code\n    FROM Documents\n    GROUP BY document_structure_code\n    ORDER BY COUNT(*) DESC\n    LIMIT 3\n);"
        ],
        "rule_sql": [
            "WITH PopularTypes AS (\n    SELECT document_type_code\n    FROM Documents\n    GROUP BY document_type_code\n    ORDER BY COUNT(*) DESC\n    LIMIT 3\n),\nPopularStructures AS (\n    SELECT document_structure_code\n    FROM Documents\n    GROUP BY document_structure_code\n    ORDER BY COUNT(*) DESC\n    LIMIT 3\n)\nSELECT document_name\nFROM Documents\nWHERE document_type_code IN (SELECT document_type_code FROM PopularTypes)\nINTERSECT\nSELECT document_name\nFROM Documents\nWHERE document_structure_code IN (SELECT document_structure_code FROM PopularStructures);"
        ]
    },
    "3946": {
        "db_id": "hospital_1",
        "question": "Find the name of physicians whose position title contains the word 'senior'.",
        "ground_truth": "SELECT name FROM physician WHERE POSITION LIKE '%senior%'",
        "amends": [
            "Do reference table `physician` instead of `physicians` in the FROM clause. Do filter on column `POSITION` instead of `position_title` in the WHERE condition. The amended query now correctly retrieves names from the physician table where the position contains 'senior', matching the intended behavior."
        ],
        "rules": [
            "1) When answering about physician names: use table \"physician\" (not \"physicians\") as the base table T1. 2) When filtering by position title containing 'senior': use column \"POSITION\" (not \"position_title\") and apply pattern matching for '%senior%'. 3) When selecting output: return the \"name\" column from table \"physician\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM physicians WHERE position_title LIKE '%senior%';",
            "SELECT Name FROM Physician WHERE POSITION LIKE '%senior%';"
        ],
        "rule_sql": [
            "SELECT name FROM physician WHERE POSITION LIKE '%senior%'"
        ]
    },
    "1273": {
        "db_id": "apartment_rentals",
        "question": "Which apartments have unit status availability of both 0 and 1? Return their apartment numbers.",
        "ground_truth": "SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  0 INTERSECT SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  1",
        "amends": [
            "Do add `JOIN View_Unit_Status` on `T1.apt_id = T2.apt_id` instead of querying only the `apartments` table. Do change the column reference to `T1.apt_number` instead of `apartment_number`. Do replace the contradictory `WHERE unit_status = 0 AND unit_status = 1` condition with separate queries for `T2.available_yn = 0` and `T2.available_yn = 1` combined with `INTERSECT` instead of using an impossible AND condition. Do add table aliases `T1` and `T2` instead of using unqualified column names. The amended query now correctly finds apartments that have both available_yn = 0 and available_yn = 1 statuses through the INTERSECT operation, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about apartments with both availability statuses 0 and 1: combine results from two separate queries using INTERSECT instead of using contradictory AND conditions. 2) When joining tables for apartment information: link apartments table (T1) and View_Unit_Status table (T2) where T1.apt_id = T2.apt_id. 3) When checking for availability status 0: filter rows where T2.available_yn = 0. 4) When checking for availability status 1: filter rows where T2.available_yn = 1. 5) When selecting apartment numbers: use T1.apt_number instead of apartment_number as the output column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT apartment_number FROM apartments WHERE unit_status = 0 AND unit_status = 1;",
            "SELECT T1.apt_number\nFROM Apartments T1\nJOIN View_Unit_Status T2 ON T1.apt_id = T2.apt_id\nWHERE T2.available_yn = 0\nINTERSECT\nSELECT T1.apt_number\nFROM Apartments T1\nJOIN View_Unit_Status T2 ON T1.apt_id = T2.apt_id\nWHERE T2.available_yn = 1"
        ],
        "rule_sql": [
            "SELECT T1.apt_number\nFROM Apartments T1\nJOIN View_Unit_Status T2 ON T1.apt_id = T2.apt_id\nWHERE T2.available_yn = 0\nINTERSECT\nSELECT T1.apt_number\nFROM Apartments T1\nJOIN View_Unit_Status T2 ON T1.apt_id = T2.apt_id\nWHERE T2.available_yn = 1"
        ]
    },
    "3958": {
        "db_id": "hospital_1",
        "question": "What are the names of the physician who prescribed the highest dose?",
        "ground_truth": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1",
        "amends": [
            "Do add `T1.` prefix to `name` instead of using unqualified `name`. Do specify `FROM physician AS T1 JOIN prescribes AS T2` instead of just `FROM physicians`. Do add `ON T1.employeeid = T2.physician` join condition instead of omitting any join. Do reference `T2.dose` in `ORDER BY` instead of unqualified `dose`. The amended query now correctly joins the physician and prescribes tables to find the physician with the highest prescribed dose, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"names of the physician who prescribed the highest dose\": make sure the output order: T1.name. 2) When combining T1 and T2 for shared entities: link rows where T1.employeeid = T2.physician exactly as shown in the amends; keep only matching pairs (inner match). 3) When the question mentions \"highest dose\": \"dose\" actually means \"T2.dose in schema\" and rank rows by T2.dose in descending direction and keep the first 1 row. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM physicians ORDER BY dose DESC LIMIT 1;",
            "SELECT T1.Name \nFROM Physician AS T1 \nJOIN Prescribes AS T2 ON T1.EmployeeID = T2.Physician \nORDER BY T2.Dose DESC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Name\nFROM Physician T1\nINNER JOIN Prescribes T2 ON T1.EmployeeID = T2.Physician\nORDER BY T2.Dose DESC\nLIMIT 1;"
        ]
    },
    "5979": {
        "db_id": "game_1",
        "question": "What is the type of video game Call of Destiny.",
        "ground_truth": "SELECT gtype FROM Video_games WHERE gname  =  \"Call of Destiny\"",
        "amends": [
            "Do select `gtype` instead of `title` from the column list. Do reference table `Video_games` instead of `video_games` in the FROM clause. Do filter on `gname = \"Call of Destiny\"` instead of `name = 'Call of Destiny'` in the WHERE condition, using double quotes instead of single quotes for the string literal. The amended query now correctly retrieves the game type from the specified table using the appropriate column names and string formatting."
        ],
        "rules": [
            "1) When answering about \"type of video game\": make sure the output column is \"gtype\" instead of \"title\". 2) When referencing the video games table: use the exact table name \"Video_games\" with the correct case. 3) When filtering for the game \"Call of Destiny\": use the exact column name \"gname\" and the exact string literal \"Call of Destiny\" with double quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM video_games WHERE name = 'Call of Destiny';",
            "SELECT GType FROM Video_Games WHERE GName = \"Call of Destiny\";"
        ],
        "rule_sql": [
            "SELECT gtype FROM Video_Games WHERE gname = \"Call of Destiny\";"
        ]
    },
    "6703": {
        "db_id": "driving_school",
        "question": "How many lessons were taught by a staff member whose first name has the letter 'a' in it?",
        "ground_truth": "SELECT count(*) FROM Lessons AS T1 JOIN Staff AS T2 ON T1.staff_id = T2.staff_id WHERE T2.first_name LIKE \"%a%\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM lessons WHERE staff_id IN (SELECT staff_id FROM staff WHERE first_name LIKE '%a%');"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS lesson_count\nFROM Lessons l\nJOIN Staff s ON l.staff_id = s.staff_id\nWHERE s.first_name LIKE '%a%';"
        ]
    },
    "4933": {
        "db_id": "store_product",
        "question": "What are the products with the maximum page size eqal to A4 or a pages per minute color less than 5?",
        "ground_truth": "SELECT product FROM product WHERE max_page_size  =  \"A4\" OR pages_per_minute_color  <  5",
        "amends": [
            "Do reference the `product` column instead of `*` in the SELECT list. Do use the correct table name `product` instead of `products` in the FROM clause. Do maintain the same WHERE filter conditions `max_page_size = 'A4'` and `pages_per_minute_color < 5` with the OR operator. Do remove the ORDER BY `pages_per_minute_color DESC` and LIMIT 1 clauses instead of keeping them, as the right query returns all matching rows rather than just the top one. The amended query now matches RIGHT_SQL's behavior by selecting all products that meet the criteria without sorting or limiting results."
        ],
        "rules": [
            "1) When selecting from the product table: use the exact table name \"product\" (not \"products\"). 2) When the question asks for \"products\": select the exact column \"product\" instead of using *. 3) When filtering for maximum page size equal to A4: use the exact literal 'A4' with the condition max_page_size = 'A4'. 4) When filtering for pages per minute color less than 5: use the condition pages_per_minute_color < 5. 5) When combining multiple filter conditions: use OR operator to include products that satisfy either max_page_size = 'A4' OR pages_per_minute_color < 5. 6) When the question asks for all matching products: do not apply ordering or limiting clauses, return all rows that meet the filter conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM products WHERE max_page_size = 'A4' OR pages_per_minute_color < 5 ORDER BY pages_per_minute_color DESC LIMIT 1;",
            "SELECT product FROM product WHERE max_page_size = 'A4' OR pages_per_minute_color < 5"
        ],
        "rule_sql": [
            "SELECT product FROM product WHERE max_page_size = 'A4' OR pages_per_minute_color < 5"
        ]
    },
    "6304": {
        "db_id": "city_record",
        "question": "what is the GDP of the city with the largest population.",
        "ground_truth": "SELECT gdp FROM city ORDER BY Regional_Population DESC LIMIT 1",
        "amends": [
            "Do reference the `gdp` column instead of `GDP` to match the correct column name. Do use the `city` table instead of `cities` to reference the correct table source. Do order by `Regional_Population` instead of `population` to use the correct population metric for sorting. The amended query now correctly retrieves the GDP from the city table ordered by regional population in descending order with a limit of one result."
        ],
        "rules": [
            "1) When the question asks for \"GDP\": use the exact column name \"gdp\" from the city table. 2) When the question asks about \"city\": use the exact table name \"city\" instead of \"cities\". 3) When the question mentions \"largest population\": use the exact column name \"Regional_Population\" for sorting in descending order to find the maximum value. 4) When retrieving the top result: limit the output to exactly one row after ordering by Regional_Population in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT GDP FROM cities ORDER BY population DESC LIMIT 1;",
            "SELECT gdp FROM city ORDER BY Regional_Population DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT gdp FROM city ORDER BY Regional_Population DESC LIMIT 1;"
        ]
    },
    "5590": {
        "db_id": "products_gen_characteristics",
        "question": "What is the description of the color for most products?",
        "ground_truth": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `ref_colors` as `t2` on `t1.color_code = t2.color_code` instead of querying only the `products` table. Do select `t2.color_description` instead of `color` from the products table. Do group by `t2.color_description` instead of `color` to ensure proper aggregation. Do order by `count(*)` instead of the alias `count` since column aliases cannot be referenced in ORDER BY in the same query level. The amended query now correctly joins to the reference table to get color descriptions and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"most products\": rank colors by count of products in descending order and keep the first 1 row. 2) When the question mentions \"color description\": \"color description\" actually means \"t2.color_description\" in schema. 3) When combining products table (t1) and ref_colors table (t2): link rows where t1.color_code = t2.color_code exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"count of products\": compute the number of rows using the canonical key from the products table. 5) When grouping by color description: organize results by t2.color_description and compute requested aggregates per group. 6) When ordering by count: order by the count(*) value directly instead of using column aliases in the same query level."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT color, COUNT(*) as count FROM products GROUP BY color ORDER BY count DESC LIMIT 1;",
            "SELECT t2.color_description\nFROM Products t1\nJOIN Ref_Colors t2 ON t1.color_code = t2.color_code\nGROUP BY t2.color_description\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t2.color_description\nFROM Products t1\nINNER JOIN Ref_Colors t2 ON t1.color_code = t2.color_code\nGROUP BY t2.color_description\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "4805": {
        "db_id": "aircraft",
        "question": "What are the total number of Domestic Passengers of airports that contain the word \"London\".",
        "ground_truth": "SELECT sum(Domestic_Passengers) FROM airport WHERE Airport_Name LIKE \"%London%\"",
        "amends": [
            "Do reference the `airport` table instead of `airports` to match the correct table name. Do use double quotes `\"%London%\"` instead of single quotes `'%London%'` for the LIKE pattern string literal. Do maintain the same aggregate function `sum(Domestic_Passengers)` and WHERE filter logic while correcting these table reference and string literal syntax issues. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"total number of Domestic Passengers\": use the exact column token \"Domestic_Passengers\" with the SUM aggregate function. 2) When the question mentions \"airports that contain the word London\": filter using the pattern \"%London%\" with double quotes around the literal. 3) When referencing the table containing airport data: use the exact table name \"airport\" (not \"airports\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(Domestic_Passengers) FROM airports WHERE Airport_Name LIKE '%London%';",
            "SELECT SUM(\"Domestic_Passengers\") FROM \"airport\" WHERE \"Airport_Name\" LIKE \"%London%\""
        ],
        "rule_sql": [
            "SELECT SUM(Domestic_Passengers) FROM airport WHERE Airport_Name LIKE \"%London%\""
        ]
    },
    "5017": {
        "db_id": "soccer_2",
        "question": "Which colleges does each player with a name that starts with the letter D  who tried out go to?",
        "ground_truth": "SELECT T1.cName FROM  tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID WHERE T2.pName LIKE 'D%'",
        "amends": [
            "Do select `T1.cName` instead of `p.name, c.college_name`. Do use `tryout AS T1` and `player AS T2` as table sources instead of `players p` and `colleges c`. Do perform a `JOIN` on `T1.pID = T2.pID` instead of `p.college_id = c.id`. Do filter with `T2.pName LIKE 'D%'` instead of `p.name LIKE 'D%' AND p.tried_out = 1`. Do remove the `tried_out` filter condition instead of including it. The amended query now correctly retrieves tryout information for players with names starting with 'D'.",
            "Do remove `T2.pName` from the SELECT list instead of including it, as the RIGHT_SQL only selects `T1.cName`. Do maintain the same `JOIN` between `Tryout AS T1` and `Player AS T2` on `T1.pID = T2.pID` instead of changing the join logic. Do keep the WHERE filter `T2.pName LIKE 'D%'` unchanged instead of modifying it. The amended query now correctly returns only coach names for players whose names start with 'D', matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about colleges for players with names starting with D who tried out: make sure the output order: T1.cName\n2) When combining tryout and player tables: link rows where T1.pID = T2.pID and keep only matching pairs (inner match)\n3) When the question mentions \"player with a name that starts with the letter D\": filter using T2.pName LIKE 'D%'\n4) When the question mentions \"tried out\": this is already captured by using the tryout table (T1) and does not require an additional filter condition\n5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms",
            "1) When the question asks about colleges for players: select only \"T1.cName\" instead of including player names in the output. 2) When filtering for players whose names start with 'D': use the exact condition \"T2.pName LIKE 'D%'\" with the literal 'D' and % wildcard. 3) When combining Tryout and Player tables: link rows where \"T1.pID = T2.pID\" exactly as shown, maintaining an inner join between the tables."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.name, c.college_name \nFROM players p \nJOIN colleges c ON p.college_id = c.id \nWHERE p.name LIKE 'D%' \nAND p.tried_out = 1;",
            "SELECT T1.cName, T2.pName\nFROM Tryout AS T1\nJOIN Player AS T2 ON T1.pID = T2.pID\nWHERE T2.pName LIKE 'D%';",
            "SELECT T1.cName \nFROM Tryout AS T1 \nJOIN Player AS T2 ON T1.pID = T2.pID \nWHERE T2.pName LIKE 'D%'"
        ],
        "rule_sql": [
            "SELECT T1.cName FROM Tryout T1 INNER JOIN Player T2 ON T1.pID = T2.pID WHERE T2.pName LIKE 'D%' ORDER BY T1.cName"
        ]
    },
    "6755": {
        "db_id": "activity_1",
        "question": "Show the faculty id of each faculty member, along with the number of students he or she advises.",
        "ground_truth": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID",
        "amends": [
            "Do add `JOIN Student AS T2 ON T1.FacID = T2.advisor` instead of querying only the `faculty` table. Do use table alias `T1` for `Faculty` instead of no alias. Do reference `T1.FacID` in SELECT and GROUP BY instead of `faculty_id`. The amended query now correctly joins faculty with student data to count students per advisor instead of just counting faculty records, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about faculty members and their advised students: combine Faculty table (as T1) with Student table (as T2) by linking rows where T1.FacID equals T2.advisor. 2) When counting students per faculty advisor: count the number of rows using the Student table records that match each faculty member. 3) When selecting faculty identification: use T1.FacID instead of faculty_id to reference the faculty identifier. 4) When organizing results by faculty member: group the results by T1.FacID to show counts per individual faculty advisor."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT faculty_id, COUNT(*) FROM faculty GROUP BY faculty_id;",
            "SELECT T1.FacID, COUNT(T2.StuID) AS student_count\nFROM Faculty AS T1\nJOIN Student AS T2 ON T1.FacID = T2.Advisor\nGROUP BY T1.FacID"
        ],
        "rule_sql": [
            "SELECT T1.FacID, COUNT(T2.StuID) AS number_of_students_advised FROM Faculty T1 LEFT JOIN Student T2 ON T1.FacID = T2.Advisor GROUP BY T1.FacID"
        ]
    },
    "6560": {
        "db_id": "wine_1",
        "question": "What are the names of wines, sorted in alphabetical order?",
        "ground_truth": "SELECT DISTINCT Name FROM WINE ORDER BY Name",
        "amends": [
            "Do use `DISTINCT` to eliminate duplicate rows instead of omitting it. Do reference column as `Name` instead of `name` to match the correct case. Do use ascending `ORDER BY` with `Name` instead of descending `name DESC`. Do reference table as `WINE` instead of `wines` to match the correct table name. The amended query now correctly returns unique wine names in ascending order from the WINE table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"names of wines\": make sure the output order: \"Name\" in ascending alphabetical order. 2) When the question mentions \"wines\": \"wines\" actually means \"WINE\" in schema. 3) When selecting wine names: use \"Name\" instead of \"name\" to match the correct case. 4) When eliminating duplicate wine names: use DISTINCT to return unique values from the \"Name\" column. 5) When sorting results alphabetically: use ascending order instead of descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM wines ORDER BY name DESC;",
            "SELECT DISTINCT Name FROM wine ORDER BY Name ASC;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Name FROM wine ORDER BY Name ASC;"
        ]
    },
    "5826": {
        "db_id": "workshop_paper",
        "question": "Show different colleges along with the number of authors of submission from each college.",
        "ground_truth": "SELECT College ,  COUNT(*) FROM submission GROUP BY College",
        "amends": [
            "Do reference table `submission` instead of `authors` in the FROM clause. Do use column `College` instead of `college` in both the SELECT list and GROUP BY clause, preserving the same aggregate function `COUNT(*)`. The amended query now correctly counts submissions by college rather than authors by college, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about \"colleges\" and \"authors of submission\": use table \"submission\" instead of \"authors\" to access the correct data. 2) When referring to the college column in the submission table: use the exact identifier \"College\" (with capital C) in both SELECT list and GROUP BY clause, not \"college\". 3) When counting submissions per college: use COUNT(*) to count all rows in each college group, which correctly represents the number of authors of submission from each college."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT college, COUNT(*) FROM authors GROUP BY college;",
            "SELECT College, COUNT(*) AS NumberOfAuthors FROM submission GROUP BY College;"
        ],
        "rule_sql": [
            "SELECT College, COUNT(*) AS NumberOfAuthors FROM submission GROUP BY College;"
        ]
    },
    "2512": {
        "db_id": "movie_1",
        "question": "Find the names of reviewers who had given higher than 3 star ratings.",
        "ground_truth": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  >  3",
        "amends": [
            "Do use explicit table aliases `T2.name` instead of ambiguous `name`. Do join tables `Rating AS T1` and `Reviewer AS T2` instead of querying only the `reviewers` table. Do specify the join condition `ON T1.rID = T2.rID` instead of missing the table relationship. Do filter on `T1.stars > 3` instead of `rating > 3` to reference the correct column from the Rating table. The amended query now correctly joins the Rating and Reviewer tables to find reviewers who gave ratings above 3 stars, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"names of reviewers who had given higher than 3 star ratings\": make sure the output order: T2.name. 2) When the question mentions \"reviewers\": \"reviewers\" actually means \"Reviewer table as T2\" in schema. 3) When the question mentions \"higher than 3 star ratings\": \"higher than 3 star ratings\" actually means \"T1.stars > 3\" in schema. 4) When combining Rating as T1 and Reviewer as T2 for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (T1.rID = T2.rID); keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM reviewers WHERE rating > 3;",
            "SELECT T2.name\nFROM Rating AS T1\nJOIN Reviewer AS T2 ON T1.rID = T2.rID\nWHERE T1.stars > 3"
        ],
        "rule_sql": [
            "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID = T2.rID WHERE T1.stars > 3 ORDER BY T2.name;"
        ]
    },
    "3880": {
        "db_id": "insurance_policies",
        "question": "With which kind of payment method were the least number of payments processed?",
        "ground_truth": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1",
        "amends": [
            "Do select `Payment_Method_Code` instead of `payment_method` and omit the `payment_count` alias instead of including it. Do group by `Payment_Method_Code` instead of `payment_method` and order by `count(*) ASC` instead of `payment_count DESC`. The amended query now matches RIGHT_SQL's behavior by selecting the correct column name, removing the unnecessary alias, and changing the sort order to ascending count.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, as only the `Payment_Method_Code` is needed to identify the least frequent payment method. Do keep the `GROUP BY Payment_Method_Code` and `ORDER BY count(*) ASC LIMIT 1` unchanged, as they correctly identify the payment method with the lowest frequency count. The amended query now matches RIGHT_SQL's behavior by returning only the payment method code rather than both the code and its count."
        ],
        "rules": [
            "1) When the question asks about \"payment method\": use the exact column token \"Payment_Method_Code\" from the Payments table. 2) When counting payments: count all rows using count(*) without an alias. 3) When grouping by payment method: group by the exact column \"Payment_Method_Code\". 4) When finding the \"least number of payments\": order the results by count(*) in ascending order and take the first row.",
            "1) When answering about \"the least number of payments processed by payment method\": make sure the output order: Payment_Method_Code only. 2) When the question asks for \"count of payments per payment method\": compute the number of rows using the canonical key Payment_Method_Code. 3) When the question mentions \"least number\" or \"lowest frequency\": rank payment methods by count in ascending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT payment_method, COUNT(*) as payment_count FROM payments GROUP BY payment_method ORDER BY payment_count DESC LIMIT 1;",
            "SELECT Payment_Method_Code, COUNT(*) FROM Payments GROUP BY Payment_Method_Code ORDER BY COUNT(*) ASC LIMIT 1;",
            "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY COUNT(*) ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY COUNT(*) ASC LIMIT 1"
        ]
    },
    "1456": {
        "db_id": "college_2",
        "question": "Find the name of students who have taken the prerequisite course of the course with title International Finance.",
        "ground_truth": "SELECT T1.name FROM student AS T1 JOIN takes AS T2 ON T1.id  =  T2.id WHERE T2.course_id IN (SELECT T4.prereq_id FROM course AS T3 JOIN prereq AS T4 ON T3.course_id  =  T4.course_id WHERE T3.title  =  'International Finance')",
        "amends": [
            "Do use table alias `T1` for `student` instead of `s` for `students`, and select `T1.name` instead of `s.name`. Do join `takes AS T2` instead of `enrollments e`, using `ON T1.id = T2.id` instead of `ON s.id = e.student_id`. Do remove the join to `courses` table and instead use a subquery with `course AS T3` and `prereq AS T4` joined `ON T3.course_id = T4.course_id`. Do change the WHERE condition to `T2.course_id IN` the subquery instead of directly filtering on `c.title = 'International Finance'`. Do add the subquery that selects `T4.prereq_id` from the joined course and prereq tables with filter `WHERE T3.title = 'International Finance'` instead of the direct course title filter. The amended query now correctly finds students taking prerequisite courses for International Finance instead of students directly enrolled in that course."
        ],
        "rules": [
            "1) When the question asks about students who have taken prerequisite courses: use table alias T1 for the student table and select T1.name as the output. 2) When joining student and enrollment data: use takes table as T2 instead of enrollments and link using T1.id = T2.id. 3) When finding prerequisites for a specific course: use a subquery that joins course table as T3 and prereq table as T4 with T3.course_id = T4.course_id. 4) When filtering for the course \"International Finance\": apply the condition T3.title = 'International Finance' exactly as written in the subquery. 5) When identifying prerequisite courses: select T4.prereq_id from the subquery and use T2.course_id IN this subquery result to find students taking those prerequisite courses."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.name \nFROM students s\nJOIN enrollments e ON s.id = e.student_id\nJOIN courses c ON e.course_id = c.id\nWHERE c.title = 'International Finance';",
            "SELECT T1.name\nFROM student AS T1\nJOIN takes AS T2 ON T1.ID = T2.ID\nWHERE T2.course_id IN (\n    SELECT T4.prereq_id\n    FROM course AS T3\n    JOIN prereq AS T4 ON T3.course_id = T4.course_id\n    WHERE T3.title = 'International Finance'\n)"
        ],
        "rule_sql": [
            "SELECT T1.name\nFROM student AS T1\nJOIN takes AS T2 ON T1.ID = T2.ID\nWHERE T2.course_id IN (\n    SELECT T4.prereq_id\n    FROM course AS T3\n    JOIN prereq AS T4 ON T3.course_id = T4.course_id\n    WHERE T3.title = 'International Finance'\n)"
        ]
    },
    "956": {
        "db_id": "medicine_enzyme_interaction",
        "question": "What is the type of interaction for the enzyme named 'ALA synthase' and the medicine named 'Aripiprazole'?",
        "ground_truth": "SELECT T1.interaction_type FROM medicine_enzyme_interaction AS T1 JOIN medicine AS T2 ON T1.medicine_id  =  T2.id JOIN enzyme AS T3 ON T1.enzyme_id  =  T3.id WHERE T3.name  =  'ALA synthase' AND T2.name  =  'Aripiprazole'",
        "amends": [
            "Do join `medicine_enzyme_interaction AS T1` with `medicine AS T2` on `T1.medicine_id = T2.id` and `enzyme AS T3` on `T1.enzyme_id = T3.id` instead of querying `enzyme_medicine_interactions` directly. Do filter on `T3.name = 'ALA synthase'` and `T2.name = 'Aripiprazole'` instead of `enzyme_name` and `medicine_name` columns. Do select `T1.interaction_type` instead of just `interaction_type` to specify the source table. The amended query now correctly joins normalized tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about enzyme-medicine interactions: join medicine_enzyme_interaction AS T1 with medicine AS T2 on T1.medicine_id = T2.id and enzyme AS T3 on T1.enzyme_id = T3.id using inner matches. 2) When filtering for enzyme named 'ALA synthase': use T3.name = 'ALA synthase' with exact case and spacing. 3) When filtering for medicine named 'Aripiprazole': use T2.name = 'Aripiprazole' with exact case and spacing. 4) When selecting interaction type: output T1.interaction_type to specify the source table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT interaction_type FROM enzyme_medicine_interactions WHERE enzyme_name = 'ALA synthase' AND medicine_name = 'Aripiprazole';",
            "SELECT T1.interaction_type FROM medicine_enzyme_interaction AS T1 JOIN medicine AS T2 ON T1.medicine_id = T2.id JOIN enzyme AS T3 ON T1.enzyme_id = T3.id WHERE T3.name = 'ALA synthase' AND T2.name = 'Aripiprazole'"
        ],
        "rule_sql": [
            "SELECT T1.interaction_type \nFROM medicine_enzyme_interaction AS T1\nINNER JOIN medicine AS T2 ON T1.medicine_id = T2.id\nINNER JOIN enzyme AS T3 ON T1.enzyme_id = T3.id\nWHERE T3.name = 'ALA synthase' AND T2.name = 'Aripiprazole'"
        ]
    },
    "5447": {
        "db_id": "voter_2",
        "question": "How many voting records do we have?",
        "ground_truth": "SELECT count(*) FROM VOTING_RECORD",
        "amends": [
            "Do query the `VOTING_RECORD` table instead of the `users` table. Do count records from the voting system instead of user records. The amended query now correctly counts voting records as specified in the target implementation."
        ],
        "rules": [
            "1) When answering about \"how many voting records\": query the \"VOTING_RECORD\" table instead of any other table. 2) When counting voting records: count all records from the \"VOTING_RECORD\" table to get the total number of voting records in the system."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users;",
            "SELECT COUNT(*) FROM Voting_record;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Voting_record;"
        ]
    },
    "2508": {
        "db_id": "movie_1",
        "question": "What is the name of the movie that is rated by most of times?",
        "ground_truth": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `T1.mID` to the SELECT list instead of omitting it, and do specify `T2.title` instead of just `title`. Do change the FROM clause to use `Rating AS T1 JOIN Movie AS T2 ON T1.mID = T2.mID` instead of a single table without joins. Do add `GROUP BY T1.mID` instead of omitting grouping. Do change the ORDER BY to use `count(*) DESC` instead of `rating_count DESC`, and do move the aggregation logic from a presumed column to an explicit count function. The amended query now correctly joins the Rating and Movie tables, groups by movie ID, counts ratings per movie, and returns the movie with the highest rating count, matching the RIGHT_SQL's behavior.",
            "Do add `T1.mID` to the SELECT list instead of omitting it, as the GROUP BY clause groups by `T1.mID` making it valid for selection. The amended query now matches RIGHT_SQL's behavior by including both the movie title and ID in the results.",
            "Do include `T2.title` in the SELECT list instead of omitting it, and do remove the `rating_count` alias from the COUNT(*) expression instead of keeping it. The amended query now correctly returns both the movie title and ID while maintaining the same grouping, ordering, and limit behavior as the RIGHT_SQL.",
            "Do include `T2.title` in the SELECT list instead of omitting it, and do remove the `COUNT(*)` from the SELECT list instead of keeping it. Do maintain the same FROM clause with `JOIN Movie AS T2 ON T1.mID = T2.mID` instead of changing it. Do keep the `GROUP BY T1.mID` unchanged. Do preserve the `ORDER BY COUNT(*) DESC` and `LIMIT 1` without modification. The amended query now correctly selects both the movie title and movie ID while maintaining the grouping and ordering logic to find the most frequently rated movie.",
            "Do include `T2.title` in the SELECT list instead of omitting it, and do maintain the same join condition `T1.mID = T2.mID` with the correct INNER JOIN. Do keep the GROUP BY on `T1.mID` and ORDER BY `count(*) DESC` with LIMIT 1 unchanged. The amended query now correctly includes the movie title in the results while maintaining the same aggregation logic to find the most frequently rated movie."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM movies ORDER BY rating_count DESC LIMIT 1;",
            "SELECT T2.title\nFROM Rating AS T1\nJOIN Movie AS T2 ON T1.mID = T2.mID\nGROUP BY T1.mID\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.mID, T2.title, COUNT(*) AS rating_count\nFROM Rating AS T1\nJOIN Movie AS T2 ON T1.mID = T2.mID\nGROUP BY T1.mID\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.mID, T2.title, COUNT(*) \nFROM Rating AS T1 \nJOIN Movie AS T2 ON T1.mID = T2.mID \nGROUP BY T1.mID \nORDER BY COUNT(*) DESC \nLIMIT 1",
            "SELECT T1.mID, T2.title\nFROM Rating AS T1\nJOIN Movie AS T2 ON T1.mID = T2.mID\nGROUP BY T1.mID\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.mID, T2.title\nFROM Rating AS T1\nJOIN Movie AS T2 ON T1.mID = T2.mID\nGROUP BY T1.mID\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "6232": {
        "db_id": "ship_1",
        "question": "Which classes have more than two captains?",
        "ground_truth": "SELECT CLASS FROM captain GROUP BY CLASS HAVING count(*)  >  2",
        "amends": [
            "Do use `CLASS` as the column name instead of `class_name` and move the aggregate filter to `HAVING count(*) > 2` instead of incorrectly placing it in the `WHERE` clause where aggregate functions cannot be used. Do reference the `captain` table instead of the `classes` table and remove the unnecessary alias `captain_count` from the select list. Do remove the `GROUP BY` column alias and use the actual column name `CLASS` for grouping instead of `class_name`. The amended query now correctly filters aggregated results using HAVING instead of WHERE and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about classes with captains: use the \"captain\" table instead of the \"classes\" table to access captain information. 2) When counting captains per class: group by the exact column \"CLASS\" and count using the canonical counting method. 3) When filtering aggregated results: use HAVING count(*) > 2 instead of WHERE clause for aggregate conditions. 4) When selecting output columns: include \"CLASS\" as the class name and remove unnecessary aliases like \"captain_count\" from the select list."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT class_name, COUNT(*) as captain_count FROM classes WHERE captain_count > 2 GROUP BY class_name",
            "SELECT CLASS FROM captain GROUP BY CLASS HAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT Class FROM captain GROUP BY Class HAVING COUNT(*) > 2"
        ]
    },
    "5998": {
        "db_id": "game_1",
        "question": "What are the advisors",
        "ground_truth": "SELECT advisor FROM Student GROUP BY advisor HAVING count(*)  >=  2",
        "amends": [
            "Do select `advisor` instead of `*` and add `GROUP BY advisor` with `HAVING count(*) >= 2` instead of using `WHERE advisor_id IS NOT NULL`. Do change the table name from `students` to `Student` and remove the `WHERE` filter entirely. The amended query now correctly groups students by advisor and filters for advisors with at least two students, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"advisors\": select the exact column \"advisor\" instead of all columns (*). 2) When the question asks for advisors with multiple students: group results by \"advisor\" and keep only groups having at least 2 students (count(*) >= 2). 3) When referring to the students table: use the exact table name \"Student\" (case-sensitive) instead of \"students\". 4) When filtering for advisors with students: do not use a WHERE clause on advisor_id being not null; instead use grouping and having conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM students WHERE advisor_id IS NOT NULL;",
            "SELECT advisor FROM Student GROUP BY advisor HAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT advisor FROM Student GROUP BY advisor HAVING COUNT(*) >= 2"
        ]
    },
    "3199": {
        "db_id": "college_1",
        "question": "How many sections does each course has?",
        "ground_truth": "SELECT count(*) ,  crs_code FROM CLASS GROUP BY crs_code",
        "amends": [
            "Do use `crs_code` as the grouping column instead of `course_id`. Do place the aggregate function `count(*)` first in the SELECT list instead of second. Do reference table `CLASS` instead of `sections` as the data source. The amended query now correctly counts records grouped by course code from the CLASS table.",
            "Do use `count(*)` without an alias instead of `COUNT(*) AS section_count`. Do list `crs_code` after the aggregate instead of `CRS_CODE` first in the SELECT list. Do maintain the same GROUP BY clause with `crs_code` instead of `CRS_CODE` but preserve the same logical grouping. The amended query now matches RIGHT_SQL's behavior by removing the column alias and reordering the SELECT list while maintaining identical result semantics."
        ],
        "rules": [
            "1) When answering about \"how many sections each course has\": make sure the output order: count(*) first, then course identifier. 2) When the question mentions \"course\": \"course\" actually means \"CRS_CODE in schema\". 3) When the question asks for \"count of sections\": compute the number of rows using the canonical key from the CLASS table. 4) When the question says \"per course\"/\"each course\": organize results by CRS_CODE and compute count per group. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms.",
            "1) When answering about \"how many sections each course has\": make sure the output order: count(*) first, then crs_code. 2) When counting sections per course: use count(*) without an alias instead of COUNT(*) AS section_count. 3) When grouping by course code: use crs_code (lowercase) instead of CRS_CODE (uppercase) for both SELECT and GROUP BY clauses."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_id, COUNT(*) FROM sections GROUP BY course_id;",
            "SELECT CRS_CODE, COUNT(*) AS section_count FROM CLASS GROUP BY CRS_CODE;",
            "SELECT COUNT(*), CRS_CODE FROM CLASS GROUP BY CRS_CODE"
        ],
        "rule_sql": [
            "SELECT COUNT(*), crs_code FROM CLASS GROUP BY crs_code"
        ]
    },
    "6250": {
        "db_id": "ship_1",
        "question": "Which flag is most widely used among all ships?",
        "ground_truth": "SELECT flag FROM ship GROUP BY flag ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference the correct table name `ship` instead of the incorrect `ships` in the FROM clause. Do move the aggregate function `count(*)` directly into the ORDER BY clause instead of including it as a column alias in the SELECT list. Do remove the explicit column alias `count` from the SELECT list instead of keeping it, since it's not needed when the aggregate is only used for ordering. Do maintain the GROUP BY on `flag` and LIMIT 1 to return the flag with the highest count. The amended query now correctly identifies the table and uses the aggregate function only where needed for ordering purposes."
        ],
        "rules": [
            "1) When the question asks about ships: use the exact table name \"ship\" instead of \"ships\". 2) When counting entities to find the most widely used flag: count using the canonical key (all rows) and group by \"flag\". 3) When ordering by count to find the most widely used: order by the count in descending direction and keep only the first row (LIMIT 1). 4) When producing output for flag identification: include only the \"flag\" column in the result, not the count value used for ordering."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flag, COUNT(*) as count FROM ships GROUP BY flag ORDER BY count DESC LIMIT 1;",
            "SELECT flag FROM ship GROUP BY flag ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT flag FROM ship GROUP BY flag ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "5809": {
        "db_id": "customer_complaints",
        "question": "Of complaints with the type code \"Product Failure\", how many had each different status code?",
        "ground_truth": "SELECT complaint_status_code ,  count(*) FROM complaints WHERE complaint_type_code  =  \"Product Failure\" GROUP BY complaint_status_code",
        "amends": [
            "Do reference `complaint_status_code` instead of `status_code` in the SELECT list and GROUP BY clause. Do reference `complaint_type_code` instead of `type_code` in the WHERE filter. Do use double quotes around the string literal \"Product Failure\" instead of single quotes. The amended query now correctly groups by complaint status code rather than type code and uses the proper column names throughout to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for status codes: use the exact column name \"complaint_status_code\" from the Complaints table. 2) When filtering for complaints with type \"Product Failure\": use the exact column name \"complaint_type_code\" and the exact literal value \"Product Failure\" with double quotes. 3) When counting complaints per status code: group by \"complaint_status_code\" and count using the canonical key for complaints. 4) When the question asks for \"how many had each different status code\": organize results by complaint status code and compute the count of complaints per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT status_code, COUNT(*) FROM complaints WHERE type_code = 'Product Failure' GROUP BY type_code;",
            "SELECT complaint_status_code, COUNT(*) AS complaint_count\nFROM Complaints\nWHERE complaint_type_code = \"Product Failure\"\nGROUP BY complaint_status_code;"
        ],
        "rule_sql": [
            "SELECT complaint_status_code, COUNT(complaint_id) AS complaint_count\nFROM Complaints\nWHERE complaint_type_code = \"Product Failure\"\nGROUP BY complaint_status_code\nORDER BY complaint_status_code;"
        ]
    },
    "1919": {
        "db_id": "protein_institute",
        "question": "Show the institution type with an institution founded after 1990 and an institution with at least 1000 enrollment.",
        "ground_truth": "SELECT TYPE FROM institution WHERE founded  >  1990 AND enrollment  >=  1000",
        "amends": [
            "Do reference column `TYPE` instead of `institution_type` and table `institution` instead of `institutions`. Do use logical operator `AND` instead of `OR` between the conditions `founded > 1990` and `enrollment >= 1000` instead of using `OR`, ensuring both criteria must be met simultaneously. The amended query now correctly filters for institutions founded after 1990 with enrollment of at least 1000, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"institution type\": use the exact column token \"TYPE\" from the schema. 2) When the question mentions \"institutions\": use the exact table token \"institution\" from the schema. 3) When filtering for institutions founded after 1990 with enrollment of at least 1000: use the logical operator AND between conditions \"founded > 1990\" and \"enrollment >= 1000\" to ensure both criteria are met simultaneously."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT institution_type FROM institutions WHERE founded_year > 1990 OR enrollment >= 1000;",
            "SELECT Type FROM Institution WHERE Founded > 1990 AND Enrollment >= 1000;"
        ],
        "rule_sql": [
            "SELECT Type FROM Institution WHERE Founded > 1990 AND Enrollment >= 1000;"
        ]
    },
    "81": {
        "db_id": "student_assessment",
        "question": "How many registed students do each course have? List course name and the number of their registered students?",
        "ground_truth": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id",
        "amends": [
            "Do add joins to `student_course_registrations` and `courses` tables instead of querying only the `students` table. Do join `students` with `student_course_registrations` on `student_id` instead of missing this relationship. Do join `student_course_registrations` with `courses` on `course_id` instead of not linking to course details. Do select `T3.course_name` from the courses table instead of the potentially incorrect `course_name` from students. Do group by `T2.course_id` instead of `course_name` to ensure accurate counting of registrations per course. The amended query now correctly counts student course registrations by joining through the proper relationship tables."
        ],
        "rules": [
            "1) When answering about \"registered students per course\": make sure the output order: course name first, then count of registered students. 2) When the question mentions \"course name\": \"course name\" actually means \"T3.course_name\" in schema. 3) When the question asks for \"count of registered students per course\": compute the number of student registrations using the canonical key T1.student_id from student_course_registrations table. 4) When combining students and student_course_registrations tables: link rows where T1.student_id = T2.student_id and keep only matching pairs (inner match). 5) When combining student_course_registrations and courses tables: link rows where T2.course_id = T3.course_id and keep only matching pairs (inner match). 6) When grouping by course: organize results by T2.course_id to ensure accurate counting of registrations per course."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_name, COUNT(*) FROM students GROUP BY course_name;",
            "SELECT c.course_name, COUNT(scr.student_id) AS number_of_registered_students\nFROM Courses c\nJOIN Student_Course_Registrations scr ON c.course_id = scr.course_id\nGROUP BY c.course_id, c.course_name\nORDER BY c.course_name;"
        ],
        "rule_sql": [
            "SELECT c.course_name, COUNT(scr.student_id) AS number_of_registered_students\nFROM Student_Course_Registrations scr\nINNER JOIN Courses c ON scr.course_id = c.course_id\nGROUP BY c.course_id, c.course_name\nORDER BY c.course_name, number_of_registered_students;"
        ]
    },
    "1841": {
        "db_id": "browser_web",
        "question": "Which accelerator name contains substring \"Opera\"?",
        "ground_truth": "SELECT name FROM web_client_accelerator WHERE name LIKE \"%Opera%\"",
        "amends": [
            "Do select only `name` instead of all columns with `*`. Do query from `web_client_accelerator` instead of `accelerators`. Do use `LIKE \"%Opera%\"` for partial matching instead of exact equality `= 'Opera'`. The amended query now correctly searches for web client accelerator names containing \"Opera\" rather than exact matches in the wrong table."
        ],
        "rules": [
            "1) When answering about \"accelerator name containing substring 'Opera'\": make sure the output order: name. 2) When the question mentions \"accelerator\": \"accelerator\" actually means \"web_client_accelerator\" in schema. 3) When the question mentions \"contains substring 'Opera'\": use partial matching with LIKE \"%Opera%\" instead of exact equality = 'Opera'. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 5) When handling text literals: do not change case, spacing, or punctuation of \"Opera\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM accelerators WHERE name = 'Opera';",
            "SELECT name FROM Web_client_accelerator WHERE name LIKE '%Opera%'"
        ],
        "rule_sql": [
            "SELECT \"name\" FROM \"Web_client_accelerator\" WHERE \"name\" LIKE '%Opera%' ORDER BY \"name\";"
        ]
    },
    "1131": {
        "db_id": "climbing",
        "question": "What are the names of climbers and the corresponding heights of the mountains that they climb?",
        "ground_truth": "SELECT T1.Name ,  T2.Height FROM climber AS T1 JOIN mountain AS T2 ON T1.Mountain_ID  =  T2.Mountain_ID",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do select columns `Name` and `Height` instead of `climber_name` and `mountain_name`. Do reference table `climber` instead of `climbers` and `mountain` instead of `mountains`. Do join on `T1.Mountain_ID = T2.Mountain_ID` instead of `climbers.mountain_id = mountains.id`. The amended query now correctly joins the climber and mountain tables using the proper Mountain_ID column and returns the climber names with corresponding mountain heights."
        ],
        "rules": [
            "1) When answering about \"names of climbers and corresponding heights of mountains\": make sure the output order: T1.\"Name\", T2.\"Height\" 2) When combining climber and mountain tables: link rows where T1.\"Mountain_ID\" = T2.\"Mountain_ID\" and keep only matching pairs (inner match) 3) When selecting climber names: use column T1.\"Name\" instead of \"climber_name\" 4) When selecting mountain heights: use column T2.\"Height\" instead of \"mountain_name\" 5) When referring to table roles: use T1 for \"climber\" table and T2 for \"mountain\" table"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT climber_name, mountain_name FROM climbers JOIN mountains ON climbers.mountain_id = mountains.id;",
            "SELECT T1.Name, T2.Height FROM climber T1 JOIN mountain T2 ON T1.Mountain_ID = T2.Mountain_ID"
        ],
        "rule_sql": [
            "SELECT T1.\"Name\", T2.\"Height\" FROM climber T1 INNER JOIN mountain T2 ON T1.\"Mountain_ID\" = T2.\"Mountain_ID\""
        ]
    },
    "503": {
        "db_id": "allergy_1",
        "question": "How many students have cat allergies?",
        "ground_truth": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  \"Cat\"",
        "amends": [
            "Do reference the `Has_allergy` table instead of the `students` table. Do use the correct column name `Allergy` instead of `allergy`. Do use double quotes for the string literal `\"Cat\"` instead of single quotes for `'cat'` to match the case-sensitive value. The amended query now correctly counts records from the appropriate table with the proper case-sensitive allergy filter."
        ],
        "rules": [
            "1) When answering about \"students with cat allergies\": use the \"Has_allergy\" table instead of the \"students\" table. 2) When filtering for cat allergies: use the exact column name \"Allergy\" (not \"allergy\") and the exact case-sensitive literal value \"Cat\" (not \"cat\"). 3) When counting students with allergies: count records from the \"Has_allergy\" table using the appropriate counting mechanism for that table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE allergy = 'cat';",
            "SELECT COUNT(*) FROM Has_Allergy WHERE Allergy = \"Cat\";"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Has_Allergy WHERE Allergy = 'Cat';"
        ]
    },
    "120": {
        "db_id": "bike_1",
        "question": "What is the id of the shortest trip?",
        "ground_truth": "SELECT id FROM trip ORDER BY duration LIMIT 1",
        "amends": [
            "Do reference table `trip` instead of `trips` in the FROM clause. Do order by `duration` instead of `distance` in the ORDER BY clause. The amended query now correctly retrieves the record with the shortest duration from the trip table."
        ],
        "rules": [
            "1) When the question asks about \"shortest trip\": use column \"duration\" from table \"trip\" to determine trip length instead of \"distance\". 2) When ordering by trip duration to find the shortest trip: sort rows by \"duration\" in ascending order and keep only the first row. 3) When selecting from the trip table: use the exact table name \"trip\" (not \"trips\") in the FROM clause. 4) When answering about \"id of the shortest trip\": make sure the output order: \"id\" as the selected column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM trips ORDER BY distance ASC LIMIT 1;",
            "SELECT id FROM trip ORDER BY duration ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT id FROM trip ORDER BY duration ASC LIMIT 1;"
        ]
    },
    "2548": {
        "db_id": "county_public_safety",
        "question": "List the names of the city with the top 5 white percentages.",
        "ground_truth": "SELECT Name FROM city ORDER BY White DESC LIMIT 5",
        "amends": [
            "Do select `Name` instead of `city_name` and `white_percentage`. Do order by `White` in descending order instead of `white_percentage` in ascending order. Do use table `city` instead of `cities`. The amended query now correctly retrieves the top 5 cities by White population in descending order."
        ],
        "rules": [
            "1) When the question asks for \"city names\": use the exact column \"Name\" from table \"city\" instead of \"city_name\". 2) When the question asks for \"white percentages\": use the exact column \"White\" from table \"city\" instead of \"white_percentage\". 3) When the question mentions \"top 5\" by white percentage: rank rows by \"White\" in descending order and keep the first 5 rows. 4) When selecting from the cities table: use table \"city\" instead of \"cities\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city_name, white_percentage FROM cities ORDER BY white_percentage ASC LIMIT 5;",
            "SELECT Name FROM city ORDER BY White DESC LIMIT 5"
        ],
        "rule_sql": [
            "SELECT Name FROM city ORDER BY White DESC LIMIT 5"
        ]
    },
    "1955": {
        "db_id": "cinema",
        "question": "Show director with the largest number of show times in total.",
        "ground_truth": "SELECT T2.directed_by FROM schedule AS T1 JOIN film AS T2 ON T1.film_id  =  T2.film_id GROUP BY T2.directed_by ORDER BY sum(T1.show_times_per_day) DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of direct table names. Do select `T2.directed_by` instead of `director`. Do join `schedule AS T1` with `film AS T2` on `T1.film_id = T2.film_id` instead of querying only the `movies` table. Do aggregate with `sum(T1.show_times_per_day)` instead of `COUNT(*)`. Do order by the sum `DESC` instead of `ASC`. Do remove the alias `show_times` instead of keeping it. The amended query now correctly calculates total show times per director across schedule records and returns the director with the highest total."
        ],
        "rules": [
            "1) When answering about \"director with the largest number of show times\": make sure the output order: T2.directed_by. 2) When combining schedule and film tables: link rows where T1.film_id = T2.film_id and keep only matching pairs (inner match). 3) When calculating total show times per director: compute sum(T1.show_times_per_day) for each T2.directed_by. 4) When the question mentions \"largest number\": rank rows by sum(T1.show_times_per_day) in descending order and keep the first 1 row. 5) When producing output: do not include column aliases like show_times."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT director, COUNT(*) as show_times \nFROM movies \nGROUP BY director \nORDER BY show_times ASC \nLIMIT 1;",
            "SELECT T2.directed_by\nFROM schedule AS T1\nJOIN film AS T2 ON T1.film_id = T2.film_id\nGROUP BY T2.directed_by\nORDER BY SUM(T1.show_times_per_day) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.directed_by\nFROM schedule T1\nINNER JOIN film T2 ON T1.Film_ID = T2.Film_ID\nGROUP BY T2.directed_by\nORDER BY SUM(T1.Show_times_per_day) DESC\nLIMIT 1"
        ]
    },
    "693": {
        "db_id": "customers_card_transactions",
        "question": "Show ids, first names, last names, and phones for all customers.",
        "ground_truth": "SELECT customer_id ,  customer_first_name ,  customer_last_name ,  customer_phone FROM Customers",
        "amends": [
            "Do use column names `customer_id`, `customer_first_name`, `customer_last_name`, and `customer_phone` instead of `id`, `first_name`, `last_name`, and `phone`. Do reference table `Customers` instead of `customers`. The amended query now correctly matches the schema with proper column naming conventions and table reference."
        ],
        "rules": [
            "1) When the question asks for customer information: use table \"Customers\" instead of \"customers\" with exact case and quotes. 2) When the question mentions \"ids\": use column \"customer_id\" instead of \"id\". 3) When the question mentions \"first names\": use column \"customer_first_name\" instead of \"first_name\". 4) When the question mentions \"last names\": use column \"customer_last_name\" instead of \"last_name\". 5) When the question mentions \"phones\": use column \"customer_phone\" instead of \"phone\". 6) When showing all customers: do not filter by phone being NULL; include all records without any WHERE clause restrictions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, first_name, last_name, phone FROM customers WHERE phone IS NULL;",
            "SELECT customer_id, customer_first_name, customer_last_name, customer_phone FROM Customers;"
        ],
        "rule_sql": [
            "SELECT customer_id, customer_first_name, customer_last_name, customer_phone FROM \"Customers\""
        ]
    },
    "2582": {
        "db_id": "inn_1",
        "question": "Which room has the highest rate? List the room's full name, rate, check in and check out date.",
        "ground_truth": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;",
        "amends": [
            "Do specify table aliases `T2.roomName`, `T1.Rate`, `T1.CheckIn`, and `T1.CheckOut` instead of unqualified column names `room_name`, `rate`, `check_in_date`, and `check_out_date`. Do add `FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room = T2.RoomId` instead of the single table `rooms`. Do add `GROUP BY T1.Room` instead of omitting aggregation grouping. Do use qualified column `T1.Rate` in `ORDER BY` instead of unqualified `rate`. The amended query now correctly joins reservation and room data, groups by room to handle potential multiple reservations, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"which room has the highest rate\": make sure the output order: T2.roomName, T1.Rate, T1.CheckIn, T1.CheckOut. 2) When combining Reservations and Rooms tables: link rows where T1.Room = T2.RoomId and keep only matching pairs (inner match). 3) When the question asks for \"highest rate\": rank rows by T1.Rate in descending direction and keep the first 1 row. 4) When the question asks for room information per room: organize results by T1.Room and compute requested aggregates per group. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for identifiers like T2.roomName, T1.Rate, T1.CheckIn, T1.CheckOut, T1.Room, and T2.RoomId."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT room_name, rate, check_in_date, check_out_date FROM rooms ORDER BY rate DESC LIMIT 1;",
            "SELECT T2.roomName, T1.Rate, T1.CheckIn, T1.CheckOut\nFROM Reservations AS T1\nJOIN Rooms AS T2 ON T1.Room = T2.RoomId\nGROUP BY T1.Room\nORDER BY T1.Rate DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.roomName, T1.Rate, T1.CheckIn, T1.CheckOut\nFROM Reservations T1\nINNER JOIN Rooms T2 ON T1.Room = T2.RoomId\nORDER BY T1.Rate DESC\nLIMIT 1;"
        ]
    },
    "4285": {
        "db_id": "club_1",
        "question": "Where us the club named \"Tennis Club\" located?",
        "ground_truth": "SELECT clublocation FROM club WHERE clubname  =  \"Tennis Club\"",
        "amends": [
            "Do select `clublocation` instead of `name` and use table `club` instead of `clubs`. Do filter on `clubname = \"Tennis Club\"` instead of `location = 'Tennis Club'` while maintaining the same single-table structure. The amended query now correctly retrieves the location from the club table based on the club name rather than attempting to filter by location value."
        ],
        "rules": [
            "1) When the question asks about location of a club named \"Tennis Club\": select \"clublocation\" from the \"club\" table. 2) When filtering for a specific club name: use the condition \"clubname\" = \"Tennis Club\" exactly as specified. 3) When referring to the club table: use the exact table name \"club\" (not \"clubs\"). 4) When the question mentions \"club named 'Tennis Club'\": this corresponds to filtering where \"clubname\" equals \"Tennis Club\" exactly."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM clubs WHERE location = 'Tennis Club';",
            "SELECT ClubLocation FROM Club WHERE ClubName = 'Tennis Club';"
        ],
        "rule_sql": [
            "SELECT ClubLocation FROM Club WHERE ClubName = 'Tennis Club'"
        ]
    },
    "6702": {
        "db_id": "driving_school",
        "question": "How many lessons taught by staff whose first name has letter 'a' in it?",
        "ground_truth": "SELECT count(*) FROM Lessons AS T1 JOIN Staff AS T2 ON T1.staff_id = T2.staff_id WHERE T2.first_name LIKE \"%a%\"",
        "amends": [
            "Do use an explicit `JOIN` with `T1.staff_id = T2.staff_id` instead of a subquery with `staff_id IN (SELECT id FROM staff)`. Do reference the joined table alias `T2.first_name` in the WHERE filter instead of the original subquery condition. Do add table aliases `AS T1` and `AS T2` for clarity instead of using unaliased table names. The amended query now correctly joins on the staff_id relationship and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When joining tables for staff and lessons: link rows where T1.staff_id = T2.staff_id using an explicit join instead of a subquery. 2) When filtering for staff whose first name contains 'a': use T2.first_name LIKE '%a%' to match the exact literal pattern. 3) When counting lessons taught by qualified staff: count the number of rows using the canonical key relationship between lessons and staff tables."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM lessons WHERE staff_id IN (SELECT id FROM staff WHERE first_name LIKE '%a%');",
            "SELECT COUNT(*) \nFROM Lessons AS T1\nJOIN Staff AS T2 ON T1.staff_id = T2.staff_id\nWHERE T2.first_name LIKE '%a%'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS lesson_count\nFROM Lessons\nJOIN Staff ON Lessons.staff_id = Staff.staff_id\nWHERE Staff.first_name LIKE '%a%'"
        ]
    },
    "694": {
        "db_id": "customers_card_transactions",
        "question": "What are the ids, full names, and phones of each customer?",
        "ground_truth": "SELECT customer_id ,  customer_first_name ,  customer_last_name ,  customer_phone FROM Customers",
        "amends": [
            "Do include `customer_first_name`, `customer_last_name`, and `customer_phone` in the SELECT list instead of only `first_name` and `phone`. Do use the correct column names `customer_first_name` and `customer_phone` instead of the abbreviated `first_name` and `phone`. Do add `customer_last_name` to the output instead of omitting it. Do reference the table as `Customers` with proper casing instead of `customers`. The amended query now correctly selects all required customer details with proper column naming conventions."
        ],
        "rules": [
            "1) When answering about customer details: include customer_id, customer_first_name, customer_last_name, and customer_phone in the output. 2) When referring to the customer table: use the exact table name \"Customers\" with proper casing. 3) When selecting customer names: use the exact column names \"customer_first_name\" and \"customer_last_name\" instead of abbreviated forms. 4) When selecting phone information: use the exact column name \"customer_phone\" instead of the abbreviated \"phone\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT customer_id, first_name, phone FROM customers;",
            "SELECT customer_id, customer_first_name, customer_last_name, customer_phone FROM Customers;"
        ],
        "rule_sql": [
            "SELECT customer_id, customer_first_name, customer_last_name, customer_phone FROM Customers;"
        ]
    },
    "2995": {
        "db_id": "sakila_1",
        "question": "Return the full name of the customer who made the first rental.",
        "ground_truth": "SELECT T1.first_name ,  T1.last_name FROM customer AS T1 JOIN rental AS T2 ON T1.customer_id  =  T2.customer_id ORDER BY T2.rental_date ASC LIMIT 1",
        "amends": [
            "Do add table `rental` with a `JOIN` on `customer_id` instead of querying only the `customer` table. Do select individual columns `first_name` and `last_name` instead of concatenating them as `full_name`. Do reference `rental_date` from the joined `rental` table instead of attempting to use it directly from `customer`. Do specify `ASC` ordering instead of omitting the direction. The amended query now correctly joins the necessary tables to access rental data and returns the appropriate columns for sorting by rental date."
        ],
        "rules": [
            "1) When answering about \"the first rental\": sort rows by \"rental_date\" in ascending order and keep only the first row. 2) When the question asks for \"full name of the customer\": select both \"first_name\" and \"last_name\" columns separately instead of concatenating them. 3) When combining customer and rental data: link rows where \"customer.customer_id\" equals \"rental.customer_id\" and keep only matching pairs (inner join). 4) When ordering by rental date: use \"rental.rental_date\" from the rental table, not from the customer table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name || ' ' || last_name AS full_name FROM customer ORDER BY rental_date LIMIT 1;",
            "SELECT c.first_name, c.last_name\nFROM customer c\nJOIN rental r ON c.customer_id = r.customer_id\nORDER BY r.rental_date ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT c.first_name, c.last_name\nFROM customer c\nINNER JOIN rental r ON c.customer_id = r.customer_id\nORDER BY r.rental_date ASC\nLIMIT 1;"
        ]
    },
    "4227": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "What is the code of each location and the number of documents in that location?",
        "ground_truth": "SELECT location_code ,  count(*) FROM Document_locations GROUP BY location_code",
        "amends": [
            "Do reference the `Document_locations` table instead of the `documents` table in the FROM clause. Do maintain the same column selection `location_code` and aggregate function `count(*)` with identical GROUP BY grouping. The amended query now correctly queries from the appropriate table while preserving the same analytical logic and output structure."
        ],
        "rules": [
            "1) When answering about \"code of each location and number of documents\": make sure the output order: location_code, count(*)\n2) When counting documents per location: compute the number of rows using the canonical key from Document_locations table\n3) When grouping by location: organize results by location_code and compute count per group"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location_code, COUNT(*) FROM documents GROUP BY location_code;",
            "SELECT location_code, COUNT(*) AS number_of_documents FROM Document_Locations GROUP BY location_code;"
        ],
        "rule_sql": [
            "SELECT Location_Code, COUNT(*) \nFROM Document_Locations \nGROUP BY Location_Code \nORDER BY Location_Code;"
        ]
    },
    "2606": {
        "db_id": "inn_1",
        "question": "How many rooms are there?",
        "ground_truth": "SELECT count(*) FROM Rooms;",
        "amends": [
            "Do remove the `WHERE room_id IS NULL` filter instead of keeping it, as the correct query should count all rooms rather than only those with null room_id values. Do reference the table as `Rooms` instead of `rooms` to match the correct case sensitivity. The amended query now correctly counts all records in the Rooms table without any filtering conditions."
        ],
        "rules": [
            "1) When counting all rooms: count all records in the \"Rooms\" table without any filtering conditions. 2) When referencing the Rooms table: use the exact identifier \"Rooms\" with proper case sensitivity as shown in the schema. 3) When the question asks \"How many rooms are there\": compute the count of all rows in the \"Rooms\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM rooms WHERE room_id IS NULL;",
            "SELECT COUNT(*) FROM Rooms;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Rooms;"
        ]
    },
    "3869": {
        "db_id": "insurance_policies",
        "question": "Find the claim id and the number of settlements made for the claim with the most recent settlement date.",
        "ground_truth": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1",
        "amends": [
            "Do join `Claims` and `Settlements` tables instead of querying only `settlements` table. Do use `JOIN` with `T1.claim_id = T2.claim_id` instead of the subquery approach. Do add `ORDER BY T1.Date_Claim_Settled DESC` and `LIMIT 1` instead of filtering by maximum settlement date. Do remove the `WHERE` clause with subquery instead of keeping it. Do change the column selection to include both `count(*)` and `T1.claim_id` instead of only `claim_id` and `settlement_count`. The amended query now correctly counts settlements per claim and returns the most recently settled claim.",
            "Do use `count(*)` without an alias instead of `COUNT(*) AS settlement_count` in the SELECT list. Do place `T1.claim_id` after the aggregate instead of `T1.Claim_ID` first in the SELECT list. Do reference `T1.Date_Claim_Settled` in ORDER BY instead of omitting the table alias prefix. The amended query now correctly returns the count of settlements per claim ID ordered by the most recently settled claim.",
            "Do place `count(*)` before `T1.claim_id` in the SELECT list instead of after it. Do add `GROUP BY T1.claim_id` instead of omitting it, which is necessary for the aggregate function to work correctly with the non-aggregated column. Do use `AS T1` for explicit table aliasing instead of implicit aliasing. The amended query now correctly groups by claim_id before counting and ordering, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"claim id and number of settlements for the claim with most recent settlement date\": make sure the output order: claim_id first, then settlement count. 2) When combining Claims and Settlements tables: link rows where T1.claim_id = T2.claim_id and keep only matching pairs (inner match). 3) When counting settlements per claim: compute the number of rows using the canonical key for settlements. 4) When the question asks for \"the claim with the most recent settlement date\": rank rows by T1.Date_Claim_Settled in descending order and keep only the first 1 row. 5) When producing output: include both T1.claim_id and the count of settlements instead of only claim_id and settlement_count.",
            "1) When counting settlements per claim: use count(*) without an alias instead of COUNT(*) AS settlement_count. 2) When ordering output columns: place T1.claim_id after the aggregate count instead of first in the SELECT list. 3) When ordering by settlement date: reference T1.Date_Claim_Settled with the table alias prefix in ORDER BY instead of omitting it. 4) When answering about the claim with the most recent settlement date: order rows by T1.Date_Claim_Settled in descending order and keep only the first row.",
            "1) When answering about \"claim id and number of settlements\": make sure the output order: count of settlements first, then claim_id. 2) When the question asks for \"number of settlements per claim\": organize results by T1.claim_id and compute count of settlements per group. 3) When counting settlements: compute the number of rows using the canonical key T1.claim_id. 4) When ordering by most recent settlement date: rank rows by T1.Date_Claim_Settled in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT claim_id, COUNT(*) as settlement_count \nFROM settlements \nWHERE settlement_date = (SELECT MAX(settlement_date) FROM settlements) \nGROUP BY claim_id;",
            "SELECT T1.Claim_ID, COUNT(*) AS settlement_count\nFROM Claims T1\nJOIN Settlements T2 ON T1.Claim_ID = T2.Claim_ID\nGROUP BY T1.Claim_ID\nORDER BY T1.Date_Claim_Settled DESC\nLIMIT 1;",
            "SELECT T1.claim_id, count(*)\nFROM Claims T1\nJOIN Settlements T2 ON T1.claim_id = T2.claim_id\nORDER BY T1.Date_Claim_Settled DESC\nLIMIT 1",
            "SELECT count(*), T1.claim_id \nFROM Claims AS T1 \nJOIN Settlements AS T2 ON T1.claim_id = T2.claim_id \nGROUP BY T1.claim_id \nORDER BY T1.Date_Claim_Settled DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS settlement_count, T1.Claim_ID\nFROM Claims T1\nINNER JOIN Settlements T2 ON T1.Claim_ID = T2.Claim_ID\nGROUP BY T1.Claim_ID\nORDER BY T1.Date_Claim_Settled DESC\nLIMIT 1;"
        ]
    },
    "163": {
        "db_id": "bike_1",
        "question": "Which trip started from the station with the largest dock count? Give me the trip id.",
        "ground_truth": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT 1",
        "amends": [
            "Do use `JOIN` with `trip AS T1` and `station AS T2` on `T1.start_station_id = T2.id` instead of a subquery with `WHERE start_station_id = (SELECT...)`. Do select `T1.id` instead of `trip_id`. Do add `ORDER BY T2.dock_count DESC` instead of ordering only in the subquery. Do remove the subquery entirely instead of using it for filtering. The amended query now correctly joins the tables and orders by dock_count to find the trip starting from the station with the most docks, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"trip started from station with largest dock count\": make sure the output order: T2.dock_count DESC, then T1.id. 2) When combining trip table (T1) and station table (T2): link rows where T1.start_station_id = T2.id and keep only matching pairs (inner match). 3) When the question asks for \"trip id\": \"trip id\" actually means \"T1.id\" in schema. 4) When the question mentions \"largest dock count\": rank rows by T2.dock_count in descending direction and keep the first row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT trip_id FROM trips WHERE start_station_id = (SELECT station_id FROM stations ORDER BY dock_count DESC LIMIT 1) LIMIT 1;",
            "SELECT T1.id \nFROM trip AS T1 \nJOIN station AS T2 ON T1.start_station_id = T2.id \nORDER BY T2.dock_count DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.id\nFROM trip T1\nINNER JOIN station T2 ON T1.start_station_id = T2.id\nORDER BY T2.dock_count DESC, T1.id\nLIMIT 1;"
        ]
    },
    "1989": {
        "db_id": "phone_market",
        "question": "Show the names of phones that are on market with number of shops greater than 50.",
        "ground_truth": "SELECT T3.Name FROM phone_market AS T1 JOIN market AS T2 ON T1.Market_ID  =  T2.Market_ID JOIN phone AS T3 ON T1.Phone_ID  =  T3.Phone_ID WHERE T2.Num_of_shops  >  50",
        "amends": [
            "Do select `T3.Name` from the `phone` table instead of `name` from the `phones` table. Do join three tables (`phone_market AS T1`, `market AS T2`, and `phone AS T3`) with explicit `JOIN` conditions instead of querying a single `phones` table. Do use the join condition `T1.Market_ID = T2.Market_ID` and `T1.Phone_ID = T3.Phone_ID` to properly relate the tables instead of assuming a single table structure. Do filter on `T2.Num_of_shops > 50` from the `market` table instead of `shop_count > 50` from what appears to be an incorrect table. Do remove the `market_status = 'on_market'` filter entirely as it is not present in the correct logic. The amended query now correctly retrieves phone names from the proper normalized schema structure with appropriate table relationships."
        ],
        "rules": [
            "1) When answering about \"names of phones\": select \"T3.Name\" from the \"phone\" table. 2) When combining tables for phone market information: link \"phone_market AS T1\" with \"market AS T2\" where \"T1.Market_ID = T2.Market_ID\" and with \"phone AS T3\" where \"T1.Phone_ID = T3.Phone_ID\", keeping only matching pairs (inner match). 3) When filtering for shops greater than 50: use the condition \"T2.Num_of_shops > 50\" from the \"market\" table. 4) When the question mentions \"on market\": do not apply any market_status filter as this condition is not required in the correct logic."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM phones WHERE market_status = 'on_market' AND shop_count > 50;",
            "SELECT T3.Name \nFROM phone_market AS T1\nJOIN market AS T2 ON T1.Market_ID = T2.Market_ID\nJOIN phone AS T3 ON T1.Phone_ID = T3.Phone_ID\nWHERE T2.Num_of_shops > 50"
        ],
        "rule_sql": [
            "SELECT T3.Name \nFROM phone_market AS T1 \nINNER JOIN market AS T2 ON T1.Market_ID = T2.Market_ID \nINNER JOIN phone AS T3 ON T1.Phone_ID = T3.Phone_ID \nWHERE T2.Num_of_shops > 50"
        ]
    },
    "1773": {
        "db_id": "gymnast",
        "question": "Count the number of different hometowns of these people.",
        "ground_truth": "SELECT count(DISTINCT Hometown) FROM people",
        "amends": [
            "Do use `count(DISTINCT Hometown)` instead of `COUNT(*)` to count distinct hometown values rather than all rows. Do add the `Hometown` column reference instead of omitting it from the aggregate function. The amended query now correctly counts unique hometowns instead of total records, matching the intended behavior."
        ],
        "rules": [
            "1) When counting the number of different hometowns: use count(DISTINCT \"Hometown\") instead of COUNT(*) to count distinct values rather than all rows. 2) When the question asks for \"different hometowns\": this means counting unique values in the \"Hometown\" column. 3) When referring to the hometown column: use the exact identifier \"Hometown\" as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM people;",
            "SELECT COUNT(DISTINCT Hometown) FROM people;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT \"Hometown\") FROM people;"
        ]
    },
    "1262": {
        "db_id": "apartment_rentals",
        "question": "Show the most common apartment type code among apartments with more than 1 bathroom.",
        "ground_truth": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use column name `apt_type_code` instead of `apartment_type_code` in both SELECT and GROUP BY clauses. Do use column name `bathroom_count` instead of `bathrooms` in the WHERE filter. Do remove the explicit column alias `count` from the SELECT list instead of keeping it. Do change the ORDER BY direction to `DESC` instead of `ASC` for the count aggregation. Do reference the table as `Apartments` instead of `apartments` with proper casing. The amended query now correctly identifies apartment types with the highest count of units having more than one bathroom, matching the intended behavior.",
            "Do remove the `COUNT(*)` column from the SELECT list instead of including it, as only the `apt_type_code` is needed in the final result. Do keep all other elements unchanged including the `WHERE bathroom_count > 1` filter, `GROUP BY apt_type_code` grouping, `ORDER BY count(*) DESC` ordering, and `LIMIT 1` limitation. The amended query now correctly returns only the apt_type_code with the highest count of apartments having more than one bathroom, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question mentions \"apartment type code\": use the exact column name \"apt_type_code\" from the Apartments table in both SELECT and GROUP BY clauses. 2) When filtering for apartments with more than 1 bathroom: use the exact column name \"bathroom_count\" with the condition > 1 in the WHERE clause. 3) When counting occurrences: do not use explicit column aliases in the SELECT list. 4) When finding the most common type: order the results by count in descending (DESC) direction instead of ascending. 5) When referencing the table: use the exact table name \"Apartments\" with proper casing as shown in the schema.",
            "1) When the question asks for the most common apartment type code among apartments with more than 1 bathroom: rank apartment type codes by count of apartments with bathroom_count > 1 in descending order and keep only the top 1 result. 2) When counting apartments per apartment type code: use the exact column token \"apt_type_code\" for grouping. 3) When filtering apartments with more than 1 bathroom: use the exact condition bathroom_count > 1. 4) When showing only the apartment type code in the final result: include only the \"apt_type_code\" column and exclude any count columns from the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT apartment_type_code, COUNT(*) as count\nFROM apartments\nWHERE bathrooms > 1\nGROUP BY apartment_type_code\nORDER BY count ASC\nLIMIT 1;",
            "SELECT apt_type_code, COUNT(*) \nFROM Apartments \nWHERE bathroom_count > 1 \nGROUP BY apt_type_code \nORDER BY COUNT(*) DESC \nLIMIT 1",
            "SELECT apt_type_code\nFROM Apartments\nWHERE bathroom_count > 1\nGROUP BY apt_type_code\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT apt_type_code FROM Apartments WHERE bathroom_count > 1 GROUP BY apt_type_code ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "2756": {
        "db_id": "election",
        "question": "Show all the information about election.",
        "ground_truth": "SELECT * FROM election",
        "amends": [
            "Do reference table `election` instead of `elections` to ensure the query targets the correct database table with the proper singular naming convention."
        ],
        "rules": [
            "1) When the question asks about election information: use the exact table name \"election\" (singular form) instead of \"elections\" to reference the correct database table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM elections;",
            "SELECT * FROM election;"
        ],
        "rule_sql": [
            "SELECT * FROM election;"
        ]
    },
    "5853": {
        "db_id": "tracking_share_transactions",
        "question": "Show the description of transaction type with code \"PUR\".",
        "ground_truth": "SELECT transaction_type_description FROM Ref_Transaction_Types WHERE transaction_type_code\t  =  \"PUR\"",
        "amends": [
            "Do select only `transaction_type_description` instead of all columns with `*`. Do reference table `Ref_Transaction_Types` instead of `transaction_types`. Do filter on column `transaction_type_code` instead of `code`. Do use equality operator with quoted value `\"PUR\"` instead of `'PUR'`. The amended query now correctly retrieves the specific transaction description from the proper reference table using the appropriate column names and filtering criteria."
        ],
        "rules": [
            "1) When answering about \"description of transaction type with code 'PUR'\": make sure the output order: transaction_type_description. 2) When the question mentions \"transaction type\": use table \"Ref_Transaction_Types\" instead of \"transaction_types\". 3) When the question mentions \"code\": \"code\" actually means \"transaction_type_code\" in schema. 4) When filtering for transaction type code: use equality operator with quoted value \"PUR\" instead of 'PUR'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM transaction_types WHERE code = 'PUR';",
            "SELECT transaction_type_description FROM Ref_Transaction_Types WHERE transaction_type_code = \"PUR\";"
        ],
        "rule_sql": [
            "SELECT transaction_type_description FROM Ref_Transaction_Types WHERE transaction_type_code = \"PUR\";"
        ]
    },
    "2731": {
        "db_id": "storm_record",
        "question": "What are the names of regions that were affected by the storm in which the most people died?",
        "ground_truth": "SELECT T2.region_name FROM affected_region AS T1 JOIN region AS T2 ON T1.region_id  =  T2.region_id JOIN storm AS T3 ON T1.storm_id  =  T3.storm_id ORDER BY T3.Number_Deaths DESC LIMIT 1",
        "amends": [
            "Do select `T2.region_name` from the `region` table instead of `region_name` directly from `storms`. Do join `affected_region AS T1` instead of omitting it, and do join `region AS T2` on `T1.region_id = T2.region_id` instead of accessing region data directly. Do join `storm AS T3` on `T1.storm_id = T3.storm_id` instead of querying the `storms` table directly. Do order by `T3.Number_Deaths` instead of `deaths` to use the correct column name from the proper table. The amended query now correctly joins through the relationship tables to find the region with the highest number of deaths, matching the intended behavior.",
            "Do remove the `WHERE` filter with subquery instead of using it to find maximum deaths. Do add `ORDER BY T3.Number_Deaths DESC` instead of omitting ordering. Do add `LIMIT 1` instead of using equality comparison to maximum value. Do change join condition from `T1.Region_id = T2.Region_id` to `T1.region_id = T2.region_id` using lowercase column names instead of mixed case. Do change join condition from `T1.Storm_ID = T3.Storm_ID` to `T1.storm_id = T3.storm_id` using lowercase column names instead of mixed case. The amended query now correctly retrieves the region with the highest number of deaths by sorting and limiting instead of potentially returning multiple regions with the maximum death count."
        ],
        "rules": [
            "1) When answering about \"names of regions affected by the storm with most deaths\": make sure the output order: T2.region_name. 2) When the question mentions \"regions that were affected by the storm\": this requires joining affected_region AS T1 and region AS T2 on T1.region_id = T2.region_id to link affected regions to their names. 3) When the question mentions \"storm in which the most people died\": this requires joining storm AS T3 on T1.storm_id = T3.storm_id and ordering by T3.Number_Deaths DESC to find the storm with highest deaths. 4) When combining tables for shared entities: link T1 and T2 where T1.region_id = T2.region_id, and link T1 and T3 where T1.storm_id = T3.storm_id, keeping only matching pairs (inner match). 5) When the question asks for \"the most people died\": rank rows by T3.Number_Deaths in descending direction and keep the first 1 row.",
            "1) When the question asks for regions affected by the storm with the most deaths: rank storms by \"Number_Deaths\" in descending order and keep only the top 1 storm. 2) When combining \"affected_region\" as T1 and \"storm\" as T3: link rows where T1.storm_id = T3.storm_id exactly as shown in the amends. 3) When combining \"affected_region\" as T1 and \"region\" as T2: link rows where T1.region_id = T2.region_id exactly as shown in the amends. 4) When the question asks for region names: output T2.region_name as the final result. 5) When handling identifier delimiters: do not change the lowercase column names storm_id and region_id to mixed case versions."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region_name FROM storms ORDER BY deaths DESC LIMIT 1;",
            "SELECT T2.region_name\nFROM affected_region AS T1\nJOIN region AS T2 ON T1.Region_id = T2.Region_id\nJOIN storm AS T3 ON T1.Storm_ID = T3.Storm_ID\nWHERE T3.Number_Deaths = (SELECT MAX(Number_Deaths) FROM storm)",
            "SELECT T2.region_name \nFROM affected_region AS T1\nJOIN region AS T2 ON T1.region_id = T2.region_id\nJOIN storm AS T3 ON T1.storm_id = T3.storm_id\nORDER BY T3.Number_Deaths DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.region_name \nFROM affected_region AS T1\nJOIN region AS T2 ON T1.region_id = T2.region_id\nJOIN storm AS T3 ON T1.storm_id = T3.storm_id\nWHERE T3.storm_id = (\n    SELECT storm_id \n    FROM storm \n    ORDER BY Number_Deaths DESC \n    LIMIT 1\n)\nORDER BY T2.region_name;"
        ]
    },
    "1416": {
        "db_id": "college_2",
        "question": "Find the name and salary of the instructors who are advisors of any student from History department?",
        "ground_truth": "SELECT T2.name ,  T2.salary FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id WHERE T3.dept_name  =  'History'",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `i` and `s`. Do reference columns `T2.name` and `T2.salary` instead of `i.name` and `i.salary`. Do join through the `advisor` table `T1` instead of directly joining `instructors` to `students`. Do use join conditions `T1.i_id = T2.id` and `T1.s_id = T3.id` instead of `i.id = s.advisor_id`. Do filter on `T3.dept_name = 'History'` instead of `s.department = 'History'`. The amended query now correctly uses the advisor relationship table to connect instructors and students and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about instructors who are advisors of students from History department: make sure the output order: T2.name, T2.salary\n2) When combining tables for advisor relationships: link rows through the advisor table T1 using T1.i_id = T2.id and T1.s_id = T3.id, keeping only matching pairs (inner match)\n3) When filtering for History department students: use exact literal 'History' for T3.dept_name condition\n4) When selecting instructor information: use T2.name and T2.salary columns for output"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT i.name, i.salary FROM instructors i JOIN students s ON i.id = s.advisor_id WHERE s.department = 'History';",
            "SELECT T2.name, T2.salary FROM advisor T1 JOIN instructor T2 ON T1.i_ID = T2.ID JOIN student T3 ON T1.s_ID = T3.ID WHERE T3.dept_name = 'History'"
        ],
        "rule_sql": [
            "SELECT T2.name, T2.salary\nFROM advisor T1\nINNER JOIN instructor T2 ON T1.i_ID = T2.ID\nINNER JOIN student T3 ON T1.s_ID = T3.ID\nWHERE T3.dept_name = 'History'\nORDER BY T2.name, T2.salary;"
        ]
    },
    "1252": {
        "db_id": "apartment_rentals",
        "question": "Return the apartment number with the largest number of bedrooms.",
        "ground_truth": "SELECT apt_number FROM Apartments ORDER BY bedroom_count DESC LIMIT 1",
        "amends": [
            "Do reference column `apt_number` instead of `apartment_number` and table `Apartments` instead of `apartments`. Do use `bedroom_count` instead of `bedrooms` in the ORDER BY clause and sort in `DESC` order instead of `ASC`. The amended query now correctly references the proper column and table names with the intended descending sort order."
        ],
        "rules": [
            "1) When the question mentions \"apartment number\": use column \"apt_number\" from table \"Apartments\" exactly as shown in the schema. 2) When the question asks for the \"largest number of bedrooms\": use column \"bedroom_count\" from table \"Apartments\" and sort in descending order. 3) When the question asks for the apartment with the largest number of bedrooms: return only the top result after sorting by \"bedroom_count\" in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT apartment_number FROM apartments ORDER BY bedrooms ASC LIMIT 1;",
            "SELECT apt_number FROM Apartments ORDER BY bedroom_count DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT apt_number FROM Apartments ORDER BY bedroom_count DESC LIMIT 1;"
        ]
    },
    "6497": {
        "db_id": "scientist_1",
        "question": "Find the number of scientists involved for the projects that require more than 300 hours.",
        "ground_truth": "SELECT count(*) ,  T1.name FROM projects AS T1 JOIN assignedto AS T2 ON T1.code  =  T2.project WHERE T1.hours  >  300 GROUP BY T1.name",
        "amends": [
            "Do add `T1.name` to the SELECT list and include `GROUP BY T1.name` instead of omitting them. Do change the FROM clause to use `projects AS T1 JOIN assignedto AS T2 ON T1.code = T2.project` instead of querying only the `scientists` table. Do move the filter `T1.hours > 300` to the WHERE clause instead of using `hours > 300` on a different table. The amended query now correctly counts projects by name with hours exceeding 300, joining the projects and assignedto tables to match the RIGHT_SQL's behavior.",
            "Do place `count(*)` before `T1.name` in the SELECT list instead of having `T1.name` first, and do use `count(*)` instead of `COUNT(T2.scientist)` to count all rows rather than non-null scientist values. The amended query now correctly counts all assigned projects regardless of scientist values and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"number of scientists involved for projects that require more than 300 hours\": make sure the output order: T1.name, COUNT(*) 2) When the question mentions \"projects that require more than 300 hours\": \"hours > 300\" actually means \"T1.hours > 300\" in schema 3) When combining T1 (projects) and T2 (assignedto) for shared entities: link rows where T1.code = T2.project exactly as shown in the amends; keep only matching pairs (inner match) 4) When the question asks for \"number of scientists involved\": compute the count of rows using the join relationship between projects and assignedto tables 5) When the question says \"by projects\": organize results by T1.name and compute the count per project group",
            "1) When counting entities in a group: use count(*) to count all rows in the group rather than counting non-null values of a specific column. 2) When ordering output columns: place the count result before other selected columns when the question primarily asks for a count. 3) When the question asks for \"number of scientists involved\": this means counting all assignment rows for each project, not counting distinct scientist values."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM scientists WHERE hours > 300",
            "SELECT T1.name, COUNT(T2.scientist) \nFROM projects AS T1 \nJOIN assignedto AS T2 ON T1.code = T2.project \nWHERE T1.hours > 300 \nGROUP BY T1.name",
            "SELECT count(*), T1.name FROM projects AS T1 JOIN assignedto AS T2 ON T1.code = T2.project WHERE T1.hours > 300 GROUP BY T1.name"
        ],
        "rule_sql": [
            "SELECT T1.Name, COUNT(*) \nFROM Projects T1\nINNER JOIN AssignedTo T2 ON T1.Code = T2.Project\nWHERE T1.Hours > 300\nGROUP BY T1.Name"
        ]
    },
    "5304": {
        "db_id": "manufactory_1",
        "question": "Find the total revenue of companies whose revenue is larger than the revenue of some companies based in Austin.",
        "ground_truth": "SELECT sum(revenue) FROM manufacturers WHERE revenue  >  (SELECT min(revenue) FROM manufacturers WHERE headquarter  =  'Austin')",
        "amends": [
            "Do reference the `manufacturers` table instead of `companies` in both the main query and subquery. Do filter the subquery with `headquarter = 'Austin'` instead of `city = 'Austin'`. Do use the `min(revenue)` aggregate function in the subquery instead of a direct `revenue` reference that could return multiple rows. The amended query now correctly compares against the minimum revenue from Austin-headquartered manufacturers instead of potentially failing with a multi-row subquery error."
        ],
        "rules": [
            "1) When the question mentions \"companies\": use the \"manufacturers\" table instead. 2) When filtering for companies based in Austin: use the condition \"headquarter = 'Austin'\" instead of \"city = 'Austin'\". 3) When comparing revenue against companies from Austin: use the minimum revenue value from Austin-headquartered manufacturers instead of a direct revenue reference that could return multiple rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(revenue) FROM companies WHERE revenue > (SELECT revenue FROM companies WHERE city = 'Austin')",
            "SELECT SUM(Revenue) \nFROM Manufacturers \nWHERE Revenue > (SELECT MIN(Revenue) FROM Manufacturers WHERE Headquarter = 'Austin')"
        ],
        "rule_sql": [
            "SELECT SUM(Revenue) \nFROM Manufacturers \nWHERE Revenue > (SELECT MIN(Revenue) FROM Manufacturers WHERE Headquarter = 'Austin')"
        ]
    },
    "72": {
        "db_id": "student_assessment",
        "question": "How many courses does the student with id 171 actually attend?",
        "ground_truth": "SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T2.student_id = 171",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE student_id = 171;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT course_id) \nFROM Student_Course_Attendance \nWHERE student_id = 171;"
        ]
    },
    "6212": {
        "db_id": "roller_coaster",
        "question": "List the status shared by more than two roller coaster.",
        "ground_truth": "SELECT Status FROM roller_coaster GROUP BY Status HAVING COUNT(*)  >  2",
        "amends": [
            "Do reference the table as `roller_coaster` instead of `roller_coasters` and use column name `Status` instead of `status` in both SELECT and GROUP BY clauses. Do change the HAVING condition to `COUNT(*) > 2` instead of `COUNT(*) > 1` to filter for groups with more than two records. Do remove the `COUNT(*)` column from the SELECT list instead of including it, focusing only on returning the Status values that meet the grouping criteria. The amended query now correctly identifies status groups with more than two records in the roller_coaster table."
        ],
        "rules": [
            "1) When the question mentions \"roller coaster\": use the exact table name \"roller_coaster\" instead of \"roller_coasters\". 2) When the question asks for \"status\": use the exact column name \"Status\" with proper case in both SELECT and GROUP BY clauses. 3) When the question asks for \"more than two\": use the condition COUNT(*) > 2 in the HAVING clause instead of COUNT(*) > 1. 4) When the question asks to \"list the status\": only include the \"Status\" column in the output and remove any aggregate columns like COUNT(*) from the SELECT list."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT status, COUNT(*) FROM roller_coasters GROUP BY status HAVING COUNT(*) > 1",
            "SELECT Status FROM roller_coaster GROUP BY Status HAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT Status FROM roller_coaster GROUP BY Status HAVING COUNT(*) > 2;"
        ]
    },
    "3884": {
        "db_id": "insurance_policies",
        "question": "What are all the distinct details of the customers?",
        "ground_truth": "SELECT DISTINCT customer_details FROM Customers",
        "amends": [
            "Do select `customer_details` instead of `*` for all columns. Do use `DISTINCT` instead of omitting it to remove duplicate rows. Do reference table `Customers` instead of `customers` with proper case sensitivity. Do remove the `WHERE customer_id = 1` filter instead of keeping it to return all customer details rather than just one specific customer. The amended query now correctly returns unique customer details from the entire Customers table without filtering to a specific ID."
        ],
        "rules": [
            "1) When selecting customer details from the Customers table: use \"customer_details\" instead of \"*\" to get all columns. 2) When the question asks for distinct customer details: apply DISTINCT to remove duplicate rows. 3) When referencing the Customers table: use exact case-sensitive identifier \"Customers\" instead of \"customers\". 4) When the question asks for all customer details: remove any WHERE filters that restrict to specific customer IDs like customer_id = 1."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM customers WHERE customer_id = 1;",
            "SELECT DISTINCT Customer_Details FROM Customers"
        ],
        "rule_sql": [
            "SELECT DISTINCT customer_details FROM Customers;"
        ]
    },
    "2475": {
        "db_id": "movie_1",
        "question": "What are the names of all reviewers that have rated 3 or more movies?",
        "ground_truth": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID GROUP BY T1.rID HAVING COUNT(*)  >=  3",
        "amends": [
            "Do select `T2.name` from the `Reviewer` table instead of `reviewer_name` from the `reviewers` table. Do join `Rating AS T1` with `Reviewer AS T2` on `T1.rID = T2.rID` instead of querying only the `reviewers` table. Do group by `T1.rID` instead of `reviewer_name` to properly count ratings per reviewer. Do keep the `HAVING COUNT(*) >= 3` condition to filter for reviewers with at least three ratings, but remove the unnecessary `WHERE rating >= 3` filter that incorrectly restricted the rating values. The amended query now correctly identifies reviewers with three or more ratings regardless of rating value, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"names of reviewers that have rated 3 or more movies\": make sure the output order: T2.name. 2) When the question mentions \"reviewers\": \"reviewers\" actually means \"Reviewer table as T2\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.rID = T2.rID exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"count of ratings per reviewer\": compute the number of rows using T1.rID as the counting key. 5) When the question asks for reviewers with 3 or more ratings: keep only groups where the count of ratings is >= 3. 6) When handling text literals: do not change case, spacing, or punctuation for any identifiers or values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT reviewer_name FROM reviewers WHERE rating >= 3 GROUP BY reviewer_name HAVING COUNT(*) >= 3;",
            "SELECT T2.name\nFROM Rating AS T1\nJOIN Reviewer AS T2 ON T1.rID = T2.rID\nGROUP BY T1.rID\nHAVING COUNT(*) >= 3"
        ],
        "rule_sql": [
            "SELECT T2.name\nFROM Rating AS T1\nJOIN Reviewer AS T2 ON T1.rID = T2.rID\nGROUP BY T1.rID\nHAVING COUNT(*) >= 3\nORDER BY T2.name"
        ]
    },
    "4931": {
        "db_id": "store_product",
        "question": "What are the products with the maximum page size A4 that also have a pages per minute color smaller than 5?",
        "ground_truth": "SELECT product FROM product WHERE max_page_size  =  \"A4\" AND pages_per_minute_color  <  5",
        "amends": [
            "Do reference the `product` column instead of `*` in the SELECT list. Do use the correct table name `product` instead of `products` in the FROM clause. Do filter on `max_page_size = \"A4\"` instead of `page_size = 'A4'` in the WHERE clause. Do remove the ORDER BY and LIMIT clauses instead of keeping them. The amended query now correctly filters products by maximum page size and color printing speed without unnecessary sorting and limiting."
        ],
        "rules": [
            "1) When selecting from the product table: use the exact table name \"product\" instead of \"products\". 2) When filtering by page size: use the column \"max_page_size\" instead of \"page_size\" and the exact literal value \"A4\" with double quotes. 3) When filtering by color printing speed: use the column \"pages_per_minute_color\" with the comparison operator \"<\" and value 5. 4) When selecting output columns: reference the specific column \"product\" instead of using \"*\". 5) When the question asks for products meeting criteria without ranking: do not include ORDER BY or LIMIT clauses."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM products WHERE page_size = 'A4' AND pages_per_minute_color < 5 ORDER BY pages_per_minute_color DESC LIMIT 1;",
            "SELECT product FROM product WHERE max_page_size = \"A4\" AND pages_per_minute_color < 5"
        ],
        "rule_sql": [
            "SELECT product FROM product WHERE max_page_size = \"A4\" AND pages_per_minute_color < 5"
        ]
    },
    "4938": {
        "db_id": "store_product",
        "question": "Find the name of the products that are not using the most frequently-used max page size.",
        "ground_truth": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)",
        "amends": [
            "Do reference `product` table instead of `products` table. Do select `product` column instead of `name` column. Do use `product !=` comparison instead of `max_page_size !=` comparison in the WHERE clause. Do reference `product` table in the subquery instead of `products` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` in the ORDER BY clause. The amended query now correctly identifies products that are not equal to the most common max_page_size value, matching the intended behavior.",
            "Do reference `product` column instead of `max_page_size` in the WHERE clause comparison, as the original incorrectly compared the same column value against itself in the subquery. Do maintain the subquery structure that finds the most frequent `max_page_size` value using `GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1` instead of changing this logic. The amended query now correctly identifies products where the product value differs from the most common max_page_size value, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"products\": use the table \"product\" instead of \"products\". 2) When selecting the product name: use the column \"product\" instead of \"name\". 3) When comparing products in the WHERE clause: use \"product !=\" comparison instead of comparing \"max_page_size\". 4) When referencing tables in subqueries: use the \"product\" table consistently. 5) When counting records: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\". 6) When finding the most frequently used max page size: group by \"max_page_size\", order by count in descending order, and take the first result.",
            "1) When the question asks for products not using the most frequently-used max page size: use the exact column token \"product\" in the main SELECT clause instead of \"max_page_size\". 2) When finding the most frequent max_page_size value: group by the exact column token \"max_page_size\" and order by count(*) descending with limit 1. 3) When comparing products against the most frequent max_page_size: use the exact column token \"product\" in the WHERE clause comparison, not \"max_page_size\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM products WHERE max_page_size != (SELECT max_page_size FROM products GROUP BY max_page_size ORDER BY COUNT(*) DESC LIMIT 1);",
            "SELECT product FROM product WHERE max_page_size != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)",
            "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)"
        ],
        "rule_sql": [
            "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)"
        ]
    },
    "2821": {
        "db_id": "restaurant_1",
        "question": "What is the address of the restaurant Subway?",
        "ground_truth": "SELECT Address FROM Restaurant WHERE ResName = \"Subway\";",
        "amends": [
            "Do select `Address` instead of `name` in the SELECT list. Do use `ResName` filter instead of `address` filter in the WHERE clause. Do reference table `Restaurant` instead of `restaurants` in the FROM clause. The amended query now correctly retrieves the address from the Restaurant table where the restaurant name matches 'Subway' instead of incorrectly looking for restaurants with an address of 'Subway'."
        ],
        "rules": [
            "1) When the question asks for \"address of the restaurant Subway\": select the exact column \"Address\" from table \"Restaurant\". 2) When filtering for restaurant name \"Subway\": use the exact column \"ResName\" with the exact literal value 'Subway' (case-sensitive). 3) When referencing the restaurant table: use the exact table name \"Restaurant\" (not \"restaurants\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM restaurants WHERE address = 'Subway';",
            "SELECT Address FROM Restaurant WHERE ResName = 'Subway';"
        ],
        "rule_sql": [
            "SELECT Address FROM Restaurant WHERE ResName = 'Subway';"
        ]
    },
    "2199": {
        "db_id": "formula_1",
        "question": "List the forenames of all distinct drivers in alphabetical order?",
        "ground_truth": "SELECT DISTINCT forename FROM drivers ORDER BY forename ASC",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT forename FROM drivers ORDER BY forename DESC;"
        ],
        "rule_sql": [
            "SELECT DISTINCT forename FROM drivers ORDER BY forename ASC;"
        ]
    },
    "4998": {
        "db_id": "soccer_2",
        "question": "Find the name and college of students whose decisions are yes in the tryout.",
        "ground_truth": "SELECT T1.pName ,  T2.cName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'",
        "amends": [
            "Do select `T1.pName` and `T2.cName` instead of `name` and `college`. Do use `FROM player AS T1 JOIN tryout AS T2` instead of `FROM students`. Do add the join condition `ON T1.pID = T2.pID` instead of omitting it. Do filter on `T2.decision = 'yes'` instead of `decision = 'yes'`. The amended query now correctly joins the player and tryout tables to retrieve player names and college names for accepted tryouts, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"name and college of students whose decisions are yes in the tryout\": make sure the output order: T1.pName, T2.cName\n2) When the question mentions \"name\": \"name\" actually means \"T1.pName in schema\"\n3) When the question mentions \"college\": \"college\" actually means \"T2.cName in schema\"\n4) When combining T1 (player) and T2 (tryout) for shared entities: link rows where T1.pID = T2.pID exactly as shown in the amends; keep only matching pairs (inner match)\n5) When filtering for students with \"yes\" decisions: use T2.decision = 'yes' exactly as shown in the amends, preserving the literal value 'yes' with exact case and punctuation"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, college FROM students WHERE decision = 'yes';",
            "SELECT T1.pName, T2.cName FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T2.decision = 'yes'"
        ],
        "rule_sql": [
            "SELECT T1.pName, T2.cName\nFROM Player T1\nINNER JOIN Tryout T2 ON T1.pID = T2.pID\nWHERE T2.decision = 'yes'"
        ]
    },
    "3508": {
        "db_id": "hr_1",
        "question": "What are the employee ids and job ids for employees who make less than the lowest earning employee with title MK_MAN?",
        "ground_truth": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT employee_id, job_id FROM employees WHERE salary < (SELECT MIN(salary) FROM employees WHERE job_id = 'MK_MAN')"
        ],
        "rule_sql": [
            "SELECT e.EMPLOYEE_ID, e.JOB_ID\nFROM employees e\nWHERE e.SALARY < (\n    SELECT MIN(salary)\n    FROM employees\n    WHERE JOB_ID = 'MK_MAN'\n)"
        ]
    },
    "5289": {
        "db_id": "manufactory_1",
        "question": "Who is the founders of companies whose first letter is S?",
        "ground_truth": "SELECT founder FROM manufacturers WHERE name LIKE 'S%'",
        "amends": [
            "Do select `founder` instead of `*` from the result set. Do query the `manufacturers` table instead of the `companies` table while keeping the same `LIKE 'S%'` filter condition. The amended query now correctly retrieves founder information from the manufacturers table rather than all columns from a non-existent companies table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"founders of companies\": select the \"founder\" column instead of all columns. 2) When the question mentions \"companies\": use the \"manufacturers\" table instead of a \"companies\" table. 3) When filtering for companies whose first letter is S: apply the condition WHERE name LIKE 'S%' to match names starting with S."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM companies WHERE name LIKE 'S%';",
            "SELECT Founder FROM Manufacturers WHERE Name LIKE 'S%'"
        ],
        "rule_sql": [
            "SELECT Founder FROM Manufacturers WHERE Name LIKE 'S%'"
        ]
    },
    "3356": {
        "db_id": "sports_competition",
        "question": "What are the names and players of all the clubs?",
        "ground_truth": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID",
        "amends": [
            "Do specify `T1.name` and `T2.Player_id` instead of `name` and `player`. Do use explicit table aliases `T1` and `T2` instead of no aliases. Do add table `player AS T2` with a `JOIN` instead of omitting it. Do include join condition `ON T1.Club_ID = T2.Club_ID` instead of no join condition. The amended query now correctly joins the club and player tables to retrieve player IDs associated with each club."
        ],
        "rules": [
            "1) When answering about \"names and players of all clubs\": make sure the output order: T1.name, T2.Player_id 2) When the question mentions \"clubs\": use table \"clubs\" as T1 with column \"name\" 3) When the question mentions \"players\": use table \"player\" as T2 with column \"Player_id\" 4) When combining T1 and T2 for shared entities: link rows where T1.Club_ID = T2.Club_ID and keep only matching pairs (inner match) 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, player FROM clubs;",
            "SELECT T1.name, T2.Player_ID FROM club AS T1 JOIN player AS T2 ON T1.Club_ID = T2.Club_ID"
        ],
        "rule_sql": [
            "SELECT T1.\"name\", T2.\"Player_ID\" FROM \"club\" AS T1 INNER JOIN \"player\" AS T2 ON T1.\"Club_ID\" = T2.\"Club_ID\" ORDER BY T1.\"name\", T2.\"Player_ID\""
        ]
    },
    "2499": {
        "db_id": "movie_1",
        "question": "What are the titles and average ratings for all movies that have the lowest average rating?",
        "ground_truth": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT 1",
        "amends": [
            "Do join `Rating AS T1` with `Movie AS T2` on `T1.mID = T2.mID` instead of querying only the `movies` table without proper joins. Do group by `T1.mID` instead of grouping by `title` to ensure correct aggregation. Do order by `avg(T1.stars)` instead of ordering by the alias `average_rating` to reference the actual aggregate expression. Do use the actual column name `stars` from the Rating table instead of the generic `rating` column name. The amended query now correctly joins the rating and movie tables, groups by movie ID for proper aggregation, and matches the RIGHT_SQL's behavior.",
            "Do remove the `HAVING` clause with its subquery that finds minimum average stars instead of keeping it, as the requirement is simply to get the movie with the lowest average rating. Do add `LIMIT 1` instead of omitting it to return only the single movie with the minimum average rating. Do remove the alias `average_rating` from the `AVG` expression instead of keeping it since it's not needed in the final output. Do keep the `ORDER BY avg(T1.stars)` but now it serves to position the lowest rating first for the `LIMIT 1` instead of ordering all results. The amended query now correctly returns the movie title with the single lowest average rating by ordering averages ascending and limiting to one result."
        ],
        "rules": [
            "1) When answering about \"titles and average ratings for all movies that have the lowest average rating\": make sure the output order: title, average_rating. 2) When combining Rating table (as T1) and Movie table (as T2) for shared entities: link rows where T1.mID = T2.mID exactly as shown in the amends; keep only matching pairs (inner match). 3) When the question asks for \"average ratings\": compute the average of T1.stars instead of using the generic rating column name. 4) When the question asks for results \"per movie\" or \"by movie\": organize results by T1.mID (the canonical movie identifier) and compute requested aggregates per group. 5) When the question asks for \"all movies that have the lowest average rating\": rank rows by avg(T1.stars) in ascending order and keep the rows with the minimum average rating value (not just limit 1, as there may be ties). 6) When handling text literals and identifiers: do not change case, spacing, or punctuation of exact tokens like \"stars\", \"mID\", \"title\".",
            "1) When finding the movie with the lowest average rating: order movies by average rating in ascending order and keep only the first result. 2) When computing average ratings: calculate the average of T1.stars values for each movie. 3) When combining Rating and Movie tables: link rows where T1.mID equals T2.mID to match ratings with their corresponding movies. 4) When outputting results: include the movie title from T2.title and the average rating calculation without an alias."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, AVG(rating) as average_rating FROM movies GROUP BY title ORDER BY average_rating ASC LIMIT 1;",
            "SELECT T2.title, AVG(T1.stars) AS average_rating\nFROM Rating AS T1\nJOIN Movie AS T2 ON T1.mID = T2.mID\nGROUP BY T1.mID\nHAVING AVG(T1.stars) = (\n    SELECT MIN(avg_stars)\n    FROM (\n        SELECT AVG(stars) AS avg_stars\n        FROM Rating\n        GROUP BY mID\n    )\n)\nORDER BY AVG(T1.stars);",
            "SELECT T2.title, AVG(T1.stars) \nFROM Rating AS T1 \nJOIN Movie AS T2 ON T1.mID = T2.mID \nGROUP BY T1.mID \nORDER BY AVG(T1.stars) \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.title, AVG(T1.stars) \nFROM Rating AS T1 \nINNER JOIN Movie AS T2 ON T1.mID = T2.mID \nGROUP BY T1.mID \nHAVING AVG(T1.stars) = (\n    SELECT MIN(avg_stars) \n    FROM (\n        SELECT AVG(stars) AS avg_stars \n        FROM Rating \n        GROUP BY mID\n    )\n)\nORDER BY T2.title"
        ]
    },
    "418": {
        "db_id": "flight_1",
        "question": "What are the names for all aircrafts with at least 2 flights?",
        "ground_truth": "SELECT T2.name FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid HAVING count(*)  >= 2",
        "amends": [
            "Do use `T2.name` from the `Aircraft` table instead of `name` from the `aircrafts` table. Do join `Flight AS T1` with `Aircraft AS T2` on `T1.aid = T2.aid` instead of querying a single table. Do add `GROUP BY T1.aid` to group by aircraft ID instead of no grouping. Do move the count filter to `HAVING count(*) >= 2` instead of using `WHERE flight_count >= 2`. The amended query now correctly counts flights per aircraft and filters for those with at least two flights, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about aircraft names with at least 2 flights: make sure the output order: T2.name 2) When the question mentions \"aircrafts\": \"aircrafts\" actually means \"Aircraft table as T2\" in schema 3) When combining Flight as T1 and Aircraft as T2 for shared entities: link rows where T1.aid = T2.aid exactly as shown in the amends; keep only matching pairs (inner match) 4) When the question asks for \"count of flights per aircraft\": compute the number of rows using T1.aid as the grouping key and count(*) as the aggregate 5) When filtering for aircrafts with at least 2 flights: apply the condition count(*) >= 2 in the HAVING clause instead of WHERE 6) When grouping by aircraft: organize results by T1.aid and compute requested aggregates per group"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM aircrafts WHERE flight_count >= 2;",
            "SELECT T2.name \nFROM flight AS T1 \nJOIN aircraft AS T2 ON T1.aid = T2.aid \nGROUP BY T1.aid \nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T2.name \nFROM flight AS T1 \nINNER JOIN aircraft AS T2 ON T1.aid = T2.aid \nGROUP BY T1.aid \nHAVING COUNT(*) >= 2 \nORDER BY T2.name"
        ]
    },
    "247": {
        "db_id": "musical",
        "question": "Return the names of musicals who have the nominee Bob Fosse.",
        "ground_truth": "SELECT Name FROM musical WHERE Nominee  =  \"Bob Fosse\"",
        "amends": [
            "Do reference the `Name` column instead of `musical_name` and use the `musical` table instead of `musicals`. Do use double quotes for the string literal `\"Bob Fosse\"` instead of single quotes and reference the `Nominee` column instead of `nominee`. The amended query now correctly retrieves musical names by Bob Fosse from the appropriate table structure."
        ],
        "rules": [
            "1) When the question asks for musical names: use the \"Name\" column from the \"musical\" table instead of \"musical_name\" from \"musicals\". 2) When the question mentions Bob Fosse as a nominee: use the exact string literal \"Bob Fosse\" with double quotes and reference the \"Nominee\" column. 3) When filtering for musicals by Bob Fosse: select from the \"musical\" table where \"Nominee\" equals \"Bob Fosse\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT musical_name FROM musicals WHERE nominee = 'Bob Fosse';",
            "SELECT \"Name\" FROM \"musical\" WHERE \"Nominee\" = \"Bob Fosse\""
        ],
        "rule_sql": [
            "SELECT Name FROM musical WHERE Nominee = \"Bob Fosse\";"
        ]
    },
    "5521": {
        "db_id": "products_gen_characteristics",
        "question": "Count the number of characteristics.",
        "ground_truth": "SELECT count(*) FROM CHARACTERISTICS",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM characteristics;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Characteristics;"
        ]
    },
    "2355": {
        "db_id": "csu_1",
        "question": "What is the average fee for a CSU campus in the year of 2005?",
        "ground_truth": "SELECT avg(campusfee) FROM csu_fees WHERE YEAR  =  2005",
        "amends": [
            "Do reference the correct column `campusfee` instead of the incorrect `fee` column in the SELECT list. Do use consistent case for the aggregate function `avg` instead of `AVG`. Do maintain the same WHERE filter condition `YEAR = 2005` but remove the unnecessary `AND campus LIKE '%CSU%'` condition instead of keeping it, as all records in the csu_fees table already pertain to CSU campuses. The amended query now correctly calculates the average campus fee for the year 2005 and matches the intended behavior."
        ],
        "rules": [
            "1) When the question asks for average fee: use the exact column name \"campusfee\" instead of \"fee\" for the calculation. 2) When performing aggregate calculations: use lowercase \"avg\" function consistently. 3) When filtering by year 2005: use the exact condition \"YEAR = 2005\" with the literal value 2005. 4) When working with the csu_fees table: do not add additional campus filtering conditions since all records already pertain to CSU campuses."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(fee) FROM csu_fees WHERE year = 2005 AND campus LIKE '%CSU%';",
            "SELECT AVG(CampusFee) FROM csu_fees WHERE Year = 2005"
        ],
        "rule_sql": [
            "SELECT avg(campusfee) FROM csu_fees WHERE Year = 2005"
        ]
    },
    "4484": {
        "db_id": "decoration_competition",
        "question": "How many members are there?",
        "ground_truth": "SELECT count(*) FROM member",
        "amends": [
            "Do reference table `member` instead of `members` to correctly align with the actual table name in the schema. The amended query now matches RIGHT_SQL's behavior by using the proper singular table name."
        ],
        "rules": [
            "1) When the question asks about \"members\": use the exact table name \"member\" instead of \"members\" as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM members WHERE id = 1;",
            "SELECT COUNT(*) FROM member;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM member;"
        ]
    },
    "1471": {
        "db_id": "college_2",
        "question": "What are the names of Art instructors who have taught a course, and the corresponding course id?",
        "ground_truth": "SELECT name ,  course_id FROM instructor AS T1 JOIN teaches AS T2 ON T1.ID  =  T2.ID WHERE T1.dept_name  =  'Art'",
        "amends": [
            "Do select `name` and `course_id` instead of `instructor_name` and `course_id`. Do use `FROM instructor AS T1 JOIN teaches AS T2` instead of `FROM instructors` alone. Do add join condition `ON T1.ID = T2.ID` instead of omitting it. Do filter on `T1.dept_name = 'Art'` instead of `department = 'Art' AND taught_course = 'Yes'`. Do remove the redundant `taught_course` filter since the join with teaches table already ensures teaching relationships. The amended query now correctly retrieves art department instructors and their courses by properly joining the instructor and teaches tables."
        ],
        "rules": [
            "1) When answering about \"names of Art instructors who have taught a course\": select \"name\" from table T1 instead of \"instructor_name\". 2) When combining instructor and teaches tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 3) When filtering for Art department instructors: use T1.dept_name = 'Art' instead of department = 'Art' AND taught_course = 'Yes'. 4) When the question asks for course id: select \"course_id\" from table T2. 5) When the question implies teaching relationships: the join with teaches table already ensures teaching relationships, so do not include redundant taught_course filters."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT instructor_name, course_id FROM instructors WHERE department = 'Art' AND taught_course = 'Yes';",
            "SELECT T1.name, T2.course_id\nFROM instructor AS T1\nJOIN teaches AS T2 ON T1.ID = T2.ID\nWHERE T1.dept_name = 'Art'"
        ],
        "rule_sql": [
            "SELECT i.name, t.course_id\nFROM instructor i\nJOIN teaches t ON i.ID = t.ID\nWHERE i.dept_name = 'Art';"
        ]
    },
    "655": {
        "db_id": "journal_committee",
        "question": "What are the different ages of editors? Show each age along with the number of editors of that age.",
        "ground_truth": "SELECT Age ,  COUNT(*) FROM editor GROUP BY Age",
        "amends": [
            "Do reference table `editor` instead of `editors` in the FROM clause. Do use column name `Age` instead of `age` in both the SELECT list and GROUP BY clause. Do remove the ORDER BY clause instead of keeping it. The amended query now correctly counts editors by age from the proper table without unnecessary sorting."
        ],
        "rules": [
            "1) When answering about \"different ages of editors\": make sure the output order: Age, then count of editors. 2) When the question mentions \"editors\": \"editors\" actually means table \"editor\" in schema. 3) When the question mentions \"age\": \"age\" actually means column \"Age\" in table editor. 4) When the question asks for \"number of editors of that age\": compute the count using the canonical key for editors (the editor table rows). 5) When the question says \"by age\": organize results by the exact column \"Age\" and compute the count per age group. 6) When choosing identifier delimiters: do not add quotes to \"Age\" since the schema shows it unquoted. 7) When producing output: do not include any ordering clause since the question doesn't require sorted results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT age, COUNT(*) FROM editors GROUP BY age ORDER BY age;",
            "SELECT Age, COUNT(*) AS Number_of_Editors FROM editor GROUP BY Age;"
        ],
        "rule_sql": [
            "SELECT Age, COUNT(Editor_ID) AS count_of_editors FROM editor GROUP BY Age"
        ]
    },
    "1901": {
        "db_id": "school_finance",
        "question": "Count the number of budgets in year 2001 or before whose budgeted amount is greater than 3000",
        "ground_truth": "SELECT count(*) FROM budget WHERE budgeted  >  3000 AND YEAR  <=  2001",
        "amends": [
            "Do reference table `budget` instead of `budgets` and column `budgeted` instead of `budgeted_amount` while maintaining the same filter conditions `budgeted > 3000` and `YEAR <= 2001` in the WHERE clause, with the logical operators in the same order. The amended query now correctly references the proper table and column names while preserving the intended filtering logic."
        ],
        "rules": [
            "1) When the question mentions \"budgets\": use the exact table name \"budget\" instead of \"budgets\". 2) When the question mentions \"budgeted amount\": use the exact column name \"budgeted\" instead of \"budgeted_amount\". 3) When filtering for year 2001 or before: apply the condition YEAR <= 2001. 4) When filtering for budgeted amount greater than 3000: apply the condition budgeted > 3000."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM budgets WHERE year <= 2001 AND budgeted_amount > 3000;",
            "SELECT COUNT(*) FROM budget WHERE Year <= 2001 AND Budgeted > 3000"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM budget WHERE Year <= 2001 AND budgeted > 3000"
        ]
    },
    "4418": {
        "db_id": "network_2",
        "question": "How many people whose age is greater 30 and job is engineer?",
        "ground_truth": "SELECT count(*) FROM Person WHERE age  >  30 AND job  =  'engineer'",
        "amends": [
            "Do reference the table as `Person` instead of `people` to match the correct schema naming. Do maintain the identical filter conditions `age > 30 AND job = 'engineer'` and aggregate function `count(*)` without any changes to the logic or semantics. The amended query now matches RIGHT_SQL's behavior with only the table name correction."
        ],
        "rules": [
            "1) When the question refers to \"people\": use the exact table name \"Person\" as specified in the schema. 2) When filtering for age greater than 30: apply the condition \"age > 30\" exactly as stated. 3) When filtering for job equal to engineer: apply the condition \"job = 'engineer'\" with the exact literal value 'engineer' (lowercase). 4) When counting people: use count(*) to count all rows that satisfy the specified conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM people WHERE age > 30 AND job = 'engineer';",
            "SELECT COUNT(*) FROM Person WHERE age > 30 AND job = 'engineer'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Person WHERE age > 30 AND job = 'engineer'"
        ]
    },
    "1368": {
        "db_id": "college_2",
        "question": "Find the name of students who took any class in the years of 2009 and 2010.",
        "ground_truth": "SELECT DISTINCT T1.name FROM student AS T1 JOIN takes AS T2 ON T1.id  =  T2.id WHERE YEAR  =  2009 OR YEAR  =  2010",
        "amends": [
            "Do add `DISTINCT` modifier instead of omitting it. Do change the FROM source to `student AS T1 JOIN takes AS T2` instead of just `students`. Do add join condition `ON T1.id = T2.id` instead of having no join. Do reference table alias `T1.name` instead of just `name`. Do keep the WHERE filter `YEAR = 2009 OR YEAR = 2010` unchanged. The amended query now correctly joins the student and takes tables to retrieve distinct names while maintaining the same year filtering logic."
        ],
        "rules": [
            "1) When answering about \"students who took any class\": combine tables student AS T1 and takes AS T2 using inner match where T1.id = T2.id instead of using just one table. 2) When the question asks for \"name of students\": output T1.name instead of just name. 3) When filtering for years 2009 and 2010: apply WHERE condition YEAR = 2009 OR YEAR = 2010 exactly as specified. 4) When retrieving student names who took classes: use DISTINCT modifier to eliminate duplicate names instead of returning all matching rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM students WHERE year = 2009 OR year = 2010;",
            "SELECT DISTINCT T1.name FROM student AS T1 JOIN takes AS T2 ON T1.ID = T2.ID WHERE T2.year = 2009 OR T2.year = 2010"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.name FROM student AS T1 INNER JOIN takes AS T2 ON T1.ID = T2.ID WHERE T2.year = 2009 OR T2.year = 2010"
        ]
    },
    "6946": {
        "db_id": "architecture",
        "question": "List the name, nationality and id of all male architects ordered by their names lexicographically.",
        "ground_truth": "SELECT name ,  nationality ,  id FROM architect WHERE gender  =  'male' ORDER BY name",
        "amends": [
            "Do reference table `architect` instead of `architects` in the FROM clause. Do filter for `gender = 'male'` instead of `gender = 'female'` in the WHERE condition. The amended query now correctly queries the architect table for male records instead of incorrectly querying a non-existent architects table for female records, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about architects: use the exact table name \"architect\" instead of \"architects\". 2) When the question specifies \"male architects\": filter for records where gender equals the exact literal 'male' (not 'female'). 3) When the question asks for results ordered lexicographically by name: sort the output by the name column in ascending order. 4) When producing output columns: return name, nationality, and id in that exact order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, nationality, id FROM architects WHERE gender = 'female' ORDER BY name ASC;",
            "SELECT name, nationality, id FROM architect WHERE gender = 'male' ORDER BY name"
        ],
        "rule_sql": [
            "SELECT name, nationality, id FROM architect WHERE gender = 'male' ORDER BY name ASC;"
        ]
    },
    "179": {
        "db_id": "bike_1",
        "question": "Find the ids and names of stations from which at least 200 trips started.",
        "ground_truth": "SELECT start_station_id ,  start_station_name FROM trip GROUP BY start_station_name HAVING COUNT(*)  >=  200",
        "amends": [
            "Do select `start_station_id` and `start_station_name` instead of `station_id` and `name`. Do use `FROM trip` instead of `FROM stations`. Do add `GROUP BY start_station_name` instead of omitting grouping. Do move the count filter to `HAVING COUNT(*) >= 200` instead of `WHERE trips_started > 200`. Do remove the direct column reference `trips_started` and instead calculate the count dynamically. The amended query now correctly aggregates trip data by station and filters based on actual trip counts rather than relying on a potentially incorrect pre-calculated column."
        ],
        "rules": [
            "1) When answering about \"stations from which trips started\": use \"start_station_id\" and \"start_station_name\" from the \"trip\" table instead of \"station_id\" and \"name\" from the \"stations\" table. 2) When counting trips per station: group by \"start_station_name\" and count the number of trips using the canonical key from the \"trip\" table. 3) When filtering for stations with at least 200 trips: apply the condition \"COUNT(*) >= 200\" in a HAVING clause after grouping, not in a WHERE clause before grouping. 4) When the question asks for \"at least 200 trips\": use the exact threshold value 200 with inclusive comparison (>=) rather than exclusive comparison (>)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT station_id, name FROM stations WHERE trips_started > 200;",
            "SELECT start_station_id, start_station_name FROM trip GROUP BY start_station_name HAVING COUNT(*) >= 200"
        ],
        "rule_sql": [
            "SELECT start_station_id, start_station_name FROM trip GROUP BY start_station_name HAVING COUNT(*) >= 200;"
        ]
    },
    "6065": {
        "db_id": "customers_and_addresses",
        "question": "Which payment method is used by most customers?",
        "ground_truth": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do order by `count(*) DESC` instead of `COUNT(*) ASC` to find the most frequent payment method rather than the least frequent. Do remove `COUNT(*)` from the SELECT list instead of including it since only the payment_method value is needed in the final result. The amended query now correctly identifies the most common payment method by counting occurrences in descending order and returns only the payment_method value."
        ],
        "rules": [
            "1) When the question asks for \"most customers\" using a payment method: count occurrences of each payment method and find the one with the highest count. 2) When ordering by count to find the most frequent: sort by count in descending order (highest first). 3) When only the payment method value is needed in the final result: exclude the count column from the output. 4) When limiting to the top result: return only the first row after ordering by count descending."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT payment_method, COUNT(*) FROM customers GROUP BY payment_method ORDER BY COUNT(*) ASC LIMIT 1;",
            "SELECT payment_method FROM Customers GROUP BY payment_method ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT payment_method FROM Customers GROUP BY payment_method ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "513": {
        "db_id": "allergy_1",
        "question": "Which allergy has most number of students affected?",
        "ground_truth": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference table `Has_allergy` instead of `students` for the allergy data source. Do select column `Allergy` instead of `allergy` to match the correct column name. Do use `ORDER BY count(*) DESC` instead of `ORDER BY count ASC` to find the most common allergy rather than the least common. Do remove the explicit `COUNT(*) as count` column from the SELECT list instead of including it, as only the Allergy column needs to be returned. The amended query now correctly identifies the most frequent allergy from the appropriate table with proper column naming and sorting logic."
        ],
        "rules": [
            "1) When answering about \"which allergy has most number of students affected\": make sure the output order: \"Allergy\" column only. 2) When the question mentions \"allergy\": \"allergy\" actually means \"Allergy\" in schema from table \"Has_allergy\". 3) When the question asks for \"most number of students affected\": rank rows by count of students in descending order and keep the first 1 row. 4) When counting students affected by allergy: compute the number of rows using the canonical key from \"Has_allergy\" table. 5) When grouping by allergy: organize results by \"Allergy\" column and compute count per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT allergy, COUNT(*) as count FROM students GROUP BY allergy ORDER BY count ASC LIMIT 1;",
            "SELECT Allergy FROM Has_Allergy GROUP BY Allergy ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Allergy FROM Has_Allergy GROUP BY Allergy ORDER BY COUNT(StuID) DESC LIMIT 1;"
        ]
    },
    "2377": {
        "db_id": "csu_1",
        "question": "How many faculty lines are there at San Francisco State University in 2004?",
        "ground_truth": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  \"San Francisco State University\"",
        "amends": [
            "Do join `campuses AS T2` instead of omitting it, and do use `T1.campus = T2.id` as the join condition instead of no join. Do filter on `T2.campus = \"San Francisco State University\"` instead of directly filtering `university = 'San Francisco State University'` in the faculty table. Do select the `faculty` column instead of using `COUNT(*)`. Do maintain the `T1.year = 2004` filter instead of keeping it unchanged. The amended query now correctly joins through the campuses table to validate the university name and returns faculty count data instead of just a count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about faculty lines at a specific university: join the faculty table (T1) with the campuses table (T2) using T1.campus = T2.id to validate university names. 2) When filtering for \"San Francisco State University\": use T2.campus = \"San Francisco State University\" instead of filtering directly in the faculty table. 3) When selecting faculty count data: select the faculty column instead of using COUNT(*). 4) When filtering by year 2004: maintain the T1.year = 2004 filter condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM faculty WHERE university = 'San Francisco State University' AND year = 2004;",
            "SELECT T1.Faculty FROM faculty AS T1 JOIN Campuses AS T2 ON T1.Campus = T2.Id WHERE T2.Campus = 'San Francisco State University' AND T1.Year = 2004"
        ],
        "rule_sql": [
            "SELECT f.Faculty \nFROM faculty f\nJOIN Campuses c ON f.Campus = c.Id\nWHERE c.Campus = 'San Francisco State University' \nAND f.Year = 2004"
        ]
    },
    "2534": {
        "db_id": "county_public_safety",
        "question": "List the names of counties in descending order of population.",
        "ground_truth": "SELECT Name FROM county_public_safety ORDER BY Population DESC",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the correct table `county_public_safety` instead of `counties`. Do order by `Population` in descending order instead of ascending order, and use the correct column name `Population` instead of `population`. The amended query now correctly selects from the appropriate table with proper column names and sorting direction to match the intended behavior."
        ],
        "rules": [
            "1) When answering about county names and population: use table \"county_public_safety\" instead of \"counties\". 2) When selecting the county name: use column \"Name\" instead of \"name\". 3) When ordering by population: use column \"Population\" instead of \"population\". 4) When the question asks for descending order of population: order by \"Population\" in descending order instead of ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM counties ORDER BY population ASC;",
            "SELECT Name FROM county_public_safety ORDER BY Population DESC;"
        ],
        "rule_sql": [
            "SELECT \"Name\" FROM \"county_public_safety\" ORDER BY \"Population\" DESC;"
        ]
    },
    "2616": {
        "db_id": "inn_1",
        "question": "List the type of bed and name of all traditional rooms.",
        "ground_truth": "SELECT roomName ,  bedType FROM Rooms WHERE decor = \"traditional\";",
        "amends": [
            "Do select `roomName` and `bedType` instead of `bed_type` and `room_name`. Do use table name `Rooms` instead of `rooms`. Do filter on `decor = \"traditional\"` instead of `room_type = 'traditional'`.",
            "Do maintain the same column selection of `bedType` and `roomName` instead of changing the column order, as the column order does not affect the query logic. Do keep the same `WHERE decor = 'traditional'` filter instead of changing the quote style from single to double quotes, as both quote styles are functionally equivalent in SQL. The amended query now correctly matches the RIGHT_SQL's behavior while preserving the identical logical output.",
            "Do maintain the same column selection `roomName` and `bedType` instead of changing their order, as the column sequence does not affect query results. Do keep the identical `FROM Rooms` source and `WHERE decor = 'traditional'` filter instead of altering any table references or predicate conditions. Do preserve the exact same single quote usage for string literals instead of switching to double quotes, as both are syntactically equivalent in SQL. The amended query now correctly matches the RIGHT_SQL's behavior while maintaining functional equivalence.",
            "Do maintain the same column selection of `bedType` and `roomName` instead of changing the column order. Do keep the `WHERE decor = 'traditional'` filter unchanged instead of modifying the quote style. The query logic remains identical with only the column presentation order adjusted in the SELECT clause.",
            "Do maintain the same column selection of `bedType` and `roomName` instead of changing the column order. Do keep the same `WHERE decor = 'traditional'` filter instead of using double quotes. Do preserve the same table source `Rooms` instead of modifying the FROM clause. The amended query now correctly matches the RIGHT_SQL's behavior with identical column selection and filtering logic."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT bed_type, room_name FROM rooms WHERE room_type = 'traditional'",
            "SELECT bedType, roomName FROM Rooms WHERE decor = 'traditional';",
            "SELECT bedType, roomName FROM Rooms WHERE decor = 'traditional'",
            "SELECT bedType, roomName FROM Rooms WHERE decor = 'traditional';",
            "SELECT bedType, roomName FROM Rooms WHERE decor = 'traditional'",
            "SELECT bedType, roomName FROM Rooms WHERE decor = 'traditional'"
        ],
        "rule_sql": []
    },
    "2393": {
        "db_id": "csu_1",
        "question": "What is the total number of campuses?",
        "ground_truth": "SELECT count(*) FROM campuses",
        "amends": [
            "Do query the `campuses` table instead of the `students` table, as the source data requirement has changed from counting students to counting campuses. The amended query now correctly counts records from the campuses table, matching the intended behavior of the right SQL."
        ],
        "rules": [
            "1) When answering about \"total number of campuses\": query the \"campuses\" table instead of the \"students\" table. 2) When counting campuses: count records from the \"campuses\" table using the canonical key for campuses."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;",
            "SELECT COUNT(*) AS TotalCampuses FROM Campuses;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS total_campuses FROM Campuses;"
        ]
    },
    "1685": {
        "db_id": "theme_gallery",
        "question": "How many exhibitions have a attendance more than 100 or have a ticket price below 10?",
        "ground_truth": "SELECT count(*) FROM exhibition_record AS T1 JOIN exhibition AS T2 ON T1.exhibition_id  =  T2.exhibition_id WHERE T1.attendance  >  100 OR T2.ticket_price  <  10",
        "amends": [
            "Do join `exhibition_record AS T1` and `exhibition AS T2` on `T1.exhibition_id = T2.exhibition_id` instead of querying only the `exhibitions` table. Do use `OR` between conditions `T1.attendance > 100` and `T2.ticket_price < 10` instead of `AND`. Do reference `attendance` from `T1` and `ticket_price` from `T2` instead of assuming both columns exist in a single table. The amended query now correctly joins related tables and uses OR logic to count records where either attendance exceeds 100 or ticket price is below 10, matching the intended behavior.",
            "Do use `count(*)` instead of `COUNT(DISTINCT T1.Exhibition_ID)` to count all rows rather than distinct exhibition IDs. Do reference lowercase column names `exhibition_id`, `attendance`, and `ticket_price` instead of uppercase versions to match the actual schema. The amended query now correctly counts all matching records rather than distinct exhibition IDs, ensuring accurate row counting for the specified attendance and ticket price conditions."
        ],
        "rules": [
            "1) When answering about exhibitions with attendance more than 100 or ticket price below 10: join exhibition_record as T1 and exhibition as T2 on T1.exhibition_id = T2.exhibition_id using inner match. 2) When the question mentions \"attendance more than 100\": use condition T1.attendance > 100. 3) When the question mentions \"ticket price below 10\": use condition T2.ticket_price < 10. 4) When combining conditions with \"or\" logic: use OR between T1.attendance > 100 and T2.ticket_price < 10 instead of AND. 5) When counting exhibitions: count the number of rows that satisfy either attendance condition or ticket price condition after joining the tables.",
            "1) When counting rows that match conditions: use count(*) to count all matching rows rather than counting distinct values of a specific column. 2) When referencing column names: use lowercase identifiers \"exhibition_id\", \"attendance\", and \"ticket_price\" exactly as they appear in the schema, not uppercase versions. 3) When the question asks for exhibitions with attendance more than 100 or ticket price below 10: apply the conditions attendance > 100 OR ticket_price < 10 to filter the rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM exhibitions WHERE attendance > 100 AND ticket_price < 10;",
            "SELECT COUNT(DISTINCT T1.Exhibition_ID) \nFROM exhibition_record AS T1 \nJOIN exhibition AS T2 ON T1.Exhibition_ID = T2.Exhibition_ID \nWHERE T1.Attendance > 100 OR T2.Ticket_Price < 10",
            "SELECT COUNT(*) \nFROM exhibition_record AS T1 \nJOIN exhibition AS T2 ON T1.exhibition_id = T2.exhibition_id \nWHERE T1.attendance > 100 OR T2.ticket_price < 10"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM exhibition_record AS T1 \nINNER JOIN exhibition AS T2 ON T1.exhibition_id = T2.exhibition_id \nWHERE T1.attendance > 100 OR T2.ticket_price < 10"
        ]
    },
    "6301": {
        "db_id": "city_record",
        "question": "For each competition, count the number of matches.",
        "ground_truth": "SELECT count(*) ,  Competition FROM MATCH GROUP BY Competition",
        "amends": [
            "Do use `count(*)` without a space instead of `COUNT(*)` with parentheses. Do capitalize `Competition` instead of lowercase `competition` in both the SELECT list and GROUP BY clause. Do reference table `MATCH` instead of `matches` in the FROM clause. Do remove the space after the comma in the SELECT list instead of keeping it. The amended query now correctly counts matches grouped by competition with proper table reference and consistent capitalization.",
            "Do place the `Competition` column after the aggregate function `count(*)` in the SELECT list instead of before it, maintaining the same GROUP BY logic. Do keep the same table source `MATCH` and grouping on `Competition` without any changes to join conditions, filters, or ordering. The amended query now correctly positions non-aggregated columns after aggregate functions while preserving the identical result set and matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"count the number of matches per competition\": make sure the output order: Competition, count(*) 2) When the question mentions \"competition\": \"competition\" actually means \"Competition in schema\" with exact capitalization 3) When the question asks for \"count of matches\": compute the number of rows using count(*) without parentheses 4) When the question says \"per competition\"/\"by competition\": organize results by Competition and compute count per group 5) When referencing the table containing match data: use table MATCH instead of matches",
            "1) When answering about counting matches per competition: make sure the output order places the aggregate count(*) before the non-aggregated Competition column. 2) When the question asks for \"count of matches\" per competition: compute the number of rows using all rows from the match table grouped by Competition. 3) When grouping by Competition: organize results by the exact token \"Competition\" from the match table and compute the count per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT competition, COUNT(*) FROM matches GROUP BY competition;",
            "SELECT Competition,count(*) FROM match GROUP BY Competition",
            "SELECT count(*),Competition FROM MATCH GROUP BY Competition"
        ],
        "rule_sql": [
            "SELECT count(*), Competition FROM match GROUP BY Competition"
        ]
    },
    "3292": {
        "db_id": "college_1",
        "question": "What is the first name of the professor who is teaching CIS-220 and QM-261?",
        "ground_truth": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'CIS-220' INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'QM-261'",
        "amends": [
            "Do use `INTERSECT` to find professors teaching both courses instead of `AND` with the same column. Do join `employee` and `CLASS` tables on `emp_num = prof_num` instead of querying only the `professors` table. Do filter for `crs_code = 'CIS-220'` in one branch and `crs_code = 'QM-261'` in another instead of trying to filter both values from the same row. Do select `emp_fname` from the joined tables instead of `first_name` from a single table. The amended query now correctly identifies professors who teach both specified courses by using set intersection logic."
        ],
        "rules": [
            "1) When the question asks for professors teaching multiple specific courses: use set intersection logic to find professors who appear in both course lists instead of filtering for multiple values in the same row. 2) When combining employee and CLASS tables: link rows where \"emp_num\" equals \"prof_num\" exactly as shown in the schema and keep only matching pairs (inner match). 3) When filtering for specific course codes: use exact literal values 'CIS-220' and 'QM-261' with correct case and punctuation. 4) When selecting the first name: use the exact column token \"emp_fname\" from the employee table instead of \"first_name\". 5) When answering about professors teaching both CIS-220 and QM-261: make sure the output order shows only the first name of professors who teach both courses."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM professors WHERE course_code = 'CIS-220' AND course_code = 'QM-261';",
            "SELECT e.EMP_FNAME\nFROM EMPLOYEE e\nJOIN CLASS c1 ON e.EMP_NUM = c1.PROF_NUM\nWHERE c1.CRS_CODE = 'CIS-220'\nINTERSECT\nSELECT e.EMP_FNAME\nFROM EMPLOYEE e\nJOIN CLASS c2 ON e.EMP_NUM = c2.PROF_NUM\nWHERE c2.CRS_CODE = 'QM-261'"
        ],
        "rule_sql": [
            "SELECT e.EMP_FNAME\nFROM EMPLOYEE e\nINNER JOIN CLASS c1 ON e.EMP_NUM = c1.PROF_NUM\nINNER JOIN CLASS c2 ON e.EMP_NUM = c2.PROF_NUM\nWHERE c1.CRS_CODE = 'CIS-220' AND c2.CRS_CODE = 'QM-261';"
        ]
    },
    "1666": {
        "db_id": "theme_gallery",
        "question": "What are the theme and year for all exhibitions that have a ticket price under 15?",
        "ground_truth": "SELECT theme ,  YEAR FROM exhibition WHERE ticket_price  <  15",
        "amends": [
            "Do reference table `exhibition` instead of `exhibitions` in the FROM clause. Do use comparison operator `<` instead of `>` in the WHERE filter condition for `ticket_price`. Do maintain the same SELECT list with columns `theme` and `YEAR` without changes. The amended query now correctly selects exhibitions with ticket prices below 15 instead of above 15, matching the intended behavior."
        ],
        "rules": [
            "1) When referencing the exhibition table: use the exact table name \"exhibition\" instead of \"exhibitions\". 2) When filtering for ticket prices under 15: use the comparison operator < (less than) instead of > (greater than) with the value 15. 3) When selecting output columns: maintain the exact column order and names \"theme\" and \"YEAR\" as specified in the SELECT list."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT theme, year FROM exhibitions WHERE ticket_price > 15;",
            "SELECT theme, Year FROM exhibition WHERE Ticket_Price < 15"
        ],
        "rule_sql": [
            "SELECT theme, Year FROM exhibition WHERE Ticket_Price < 15"
        ]
    },
    "1203": {
        "db_id": "apartment_rentals",
        "question": "What are the address and phone number of the buildings managed by \"Brenden\"?",
        "ground_truth": "SELECT building_address ,  building_phone FROM Apartment_Buildings WHERE building_manager\t =  \"Brenden\"",
        "amends": [
            "Do select `building_address` and `building_phone` instead of `address` and `phone_number`. Do use table `Apartment_Buildings` instead of `buildings`. Do filter on `building_manager = \"Brenden\"` instead of `manager_name = 'Brenden'`. The amended query now correctly references the schema's actual column and table names to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"address\" and \"phone number\": use the exact column names \"building_address\" and \"building_phone\" from the Apartment_Buildings table. 2) When filtering for buildings managed by \"Brenden\": use the exact literal \"Brenden\" (without quotes in the condition) and the column name \"building_manager\". 3) When selecting from the buildings table: use the exact table name \"Apartment_Buildings\" instead of \"buildings\"."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address, phone_number FROM buildings WHERE manager_name = 'Brenden';",
            "SELECT building_address, building_phone FROM Apartment_Buildings WHERE building_manager = 'Brenden';"
        ],
        "rule_sql": [
            "SELECT building_address, building_phone FROM Apartment_Buildings WHERE building_manager = Brenden;"
        ]
    },
    "3966": {
        "db_id": "hospital_1",
        "question": "What are the highest cost, lowest cost and average cost of procedures?",
        "ground_truth": "SELECT MAX(cost) ,  MIN(cost) ,  AVG(cost) FROM procedures",
        "amends": [
            "Do use the `procedures` table instead of the `patients` table as the data source. Do remove the column aliases `highest_cost`, `lowest_cost`, and `average_cost` instead of keeping them. The amended query now correctly calculates aggregate statistics from the procedures table without unnecessary aliasing, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about procedure costs: use the \"procedures\" table instead of the \"patients\" table as the data source. 2) When calculating aggregate statistics: compute MAX(cost) for highest cost, MIN(cost) for lowest cost, and AVG(cost) for average cost. 3) When presenting results: do not use column aliases like \"highest_cost\", \"lowest_cost\", or \"average_cost\" in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(cost) AS highest_cost, MIN(cost) AS lowest_cost, AVG(cost) AS average_cost FROM patients;",
            "SELECT MAX(Cost), MIN(Cost), AVG(Cost) FROM Procedures;"
        ],
        "rule_sql": [
            "SELECT MAX(Cost), MIN(Cost), AVG(Cost) FROM Procedures;"
        ]
    },
    "2321": {
        "db_id": "perpetrator",
        "question": "How many distinct locations of perpetrators are there?",
        "ground_truth": "SELECT count(DISTINCT LOCATION) FROM perpetrator",
        "amends": [
            "Do `count(DISTINCT LOCATION)` instead of `COUNT(*)` to count unique locations rather than all rows. Do reference table `perpetrator` instead of `perpetrators` to use the correct table name. The amended query now correctly counts distinct locations from the perpetrator table instead of counting all rows from the incorrect table."
        ],
        "rules": [
            "1) When the question asks for \"distinct locations of perpetrators\": count the number of unique values in the \"LOCATION\" column from the \"perpetrator\" table. 2) When referring to the table containing perpetrator information: use the exact table name \"perpetrator\" (not \"perpetrators\"). 3) When counting distinct values: use the DISTINCT operation on the specified column (\"LOCATION\") rather than counting all rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM perpetrators;",
            "SELECT COUNT(DISTINCT Location) FROM perpetrator;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Location) FROM perpetrator;"
        ]
    },
    "4320": {
        "db_id": "tracking_grants_for_research",
        "question": "What are the distinct grant amount for the grants where the documents were sent before '1986-08-26 20:49:27' and grant were ended after '1989-03-16 18:27:16'?",
        "ground_truth": "SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  '1986-08-26 20:49:27' INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  '1989-03-16 18:27:16'",
        "amends": [
            "Do join `Grants AS T1` with `Documents AS T2` on `T1.grant_id = T2.grant_id` instead of querying only the grants table. Do filter on `T2.sent_date < '1986-08-26 20:49:27'` instead of `document_sent_date`. Do use `INTERSECT` to combine results with the second query filtering `grant_end_date > '1989-03-16 18:27:16'` instead of using `AND` in a single WHERE clause. Do remove `DISTINCT` since `INTERSECT` inherently returns distinct values. Do reference `T1.grant_amount` with table alias instead of just `grant_amount`. The amended query now correctly finds grants that have both a document sent before the specified date and an end date after the other specified date using proper table relationships."
        ],
        "rules": [
            "1) When the question involves both grants and documents: join table \"Grants AS T1\" with table \"Documents AS T2\" using the condition T1.grant_id = T2.grant_id to link related records. 2) When filtering documents by sent date: use T2.sent_date < '1986-08-26 20:49:27' instead of document_sent_date. 3) When filtering grants by end date: use T1.grant_end_date > '1989-03-16 18:27:16'. 4) When combining conditions from different tables: use INTERSECT to find grants that satisfy both conditions rather than AND in a single WHERE clause. 5) When selecting grant amounts: reference the column as T1.grant_amount with the table alias. 6) When INTERSECT is used: do not use DISTINCT as INTERSECT inherently returns distinct values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT grant_amount FROM grants WHERE document_sent_date < '1986-08-26 20:49:27' AND grant_end_date > '1989-03-16 18:27:16'",
            "SELECT T1.grant_amount\nFROM Grants AS T1\nJOIN Documents AS T2 ON T1.grant_id = T2.grant_id\nWHERE T2.sent_date < '1986-08-26 20:49:27'\nINTERSECT\nSELECT T1.grant_amount\nFROM Grants AS T1\nWHERE T1.grant_end_date > '1989-03-16 18:27:16'"
        ],
        "rule_sql": [
            "SELECT T1.grant_amount\nFROM Grants AS T1\nJOIN Documents AS T2 ON T1.grant_id = T2.grant_id\nWHERE T2.sent_date < '1986-08-26 20:49:27'\nINTERSECT\nSELECT T1.grant_amount\nFROM Grants AS T1\nJOIN Documents AS T2 ON T1.grant_id = T2.grant_id\nWHERE T1.grant_end_date > '1989-03-16 18:27:16'"
        ]
    },
    "1458": {
        "db_id": "college_2",
        "question": "Find the name and salary of instructors whose salary is below the average salary of the instructors in the Physics department.",
        "ground_truth": "SELECT name ,  salary FROM instructor WHERE salary  <  (SELECT avg(salary) FROM instructor WHERE dept_name  =  'Physics')",
        "amends": [
            "Do reference table `instructor` instead of `instructors` in both the main query and subquery. Do use column `dept_name` instead of `department` in the subquery's WHERE filter. Do use lowercase `avg` function instead of uppercase `AVG` in the subquery. The amended query now correctly references the proper table and column names to match the intended logic."
        ],
        "rules": [
            "1) When the question mentions \"instructors\": use table \"instructor\" instead of \"instructors\" in both main query and subquery. 2) When the question mentions \"department\" in the context of filtering: use column \"dept_name\" instead of \"department\" in the WHERE filter. 3) When computing average salary: use lowercase \"avg\" function instead of uppercase \"AVG\" in the subquery. 4) When filtering for Physics department: use exact literal value 'Physics' (case-sensitive) for the dept_name comparison."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, salary FROM instructors WHERE salary < (SELECT AVG(salary) FROM instructors WHERE department = 'Physics')",
            "SELECT name, salary FROM instructor WHERE salary < (SELECT avg(salary) FROM instructor WHERE dept_name = 'Physics')"
        ],
        "rule_sql": [
            "SELECT name, salary FROM instructor WHERE salary < (SELECT avg(salary) FROM instructor WHERE dept_name = 'Physics')"
        ]
    },
    "4001": {
        "db_id": "ship_mission",
        "question": "what are the names of the ships ordered by ascending tonnage?",
        "ground_truth": "SELECT Name FROM ship ORDER BY Tonnage ASC",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the `ship` table instead of `ships`. Do order by `Tonnage` in ascending order instead of descending order. The amended query now correctly references the proper table and column names with the intended sort direction."
        ],
        "rules": [
            "1) When the question asks for ship names: use the exact column token \"Name\" from the ship table. 2) When the question mentions ordering by ascending tonnage: order by the exact column token \"Tonnage\" in ascending order. 3) When the question refers to ships: use the exact table token \"ship\" instead of \"ships\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM ships ORDER BY tonnage DESC;",
            "SELECT Name FROM ship ORDER BY Tonnage ASC;"
        ],
        "rule_sql": [
            "SELECT Name FROM ship ORDER BY Tonnage ASC;"
        ]
    },
    "2424": {
        "db_id": "candidate_poll",
        "question": "how many people are there whose weight is higher than 85 for each gender?",
        "ground_truth": "SELECT count(*) ,  sex FROM people WHERE weight  >  85 GROUP BY sex",
        "amends": [
            "Do use column alias `sex` instead of `gender` in both the SELECT list and GROUP BY clause. Do place the aggregate function `count(*)` first in the SELECT list instead of second. Do remove the space after `weight` in the WHERE filter condition instead of keeping it. The amended query now correctly groups by the `sex` column and maintains the same filtering logic for weights greater than 85, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question mentions \"gender\": use the exact column token \"sex\" instead of \"gender\" in both output and grouping. 2) When counting people: place the count(*) aggregate function first in the output order before the grouping column. 3) When filtering by weight greater than 85: use the exact condition \"weight > 85\" without any space after \"weight\". 4) When grouping by gender (sex): organize results by the \"sex\" column and compute the count of people per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT gender, COUNT(*) FROM people WHERE weight > 85 GROUP BY gender;",
            "SELECT count(*) AS count, sex FROM people WHERE weight > 85 GROUP BY sex"
        ],
        "rule_sql": [
            "SELECT COUNT(*), sex FROM people WHERE weight > 85 GROUP BY sex"
        ]
    },
    "4272": {
        "db_id": "club_1",
        "question": "Find all the male members of club \"Hopkins Student Enterprises\". Show the first name and last name.",
        "ground_truth": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Hopkins Student Enterprises\" AND t3.sex  =  \"M\"",
        "amends": [
            "Do use explicit table aliases `t3.fname` and `t3.lname` instead of direct column names `first_name` and `last_name`. Do join three tables `club AS t1`, `member_of_club AS t2`, and `student AS t3` instead of querying a single `members` table. Do use `INNER JOIN` with proper join conditions `t1.clubid = t2.clubid` and `t2.stuid = t3.stuid` instead of no joins. Do filter on `t1.clubname = \"Hopkins Student Enterprises\"` instead of `club_name = 'Hopkins Student Enterprises'`. Do filter on `t3.sex = \"M\"` for male students instead of `gender = 'female'` for female students. The amended query now correctly retrieves male students from the specified club using proper table relationships."
        ],
        "rules": [
            "1) When the question asks about members of a specific club: join three tables using club AS t1, member_of_club AS t2, and student AS t3 with inner matches on t1.clubid = t2.clubid and t2.stuid = t3.stuid. 2) When filtering for club name \"Hopkins Student Enterprises\": use exact literal \"Hopkins Student Enterprises\" with t1.clubname column. 3) When filtering for male members: use t3.sex = \"M\" instead of gender = 'female'. 4) When selecting first and last names: use explicit table aliases t3.fname and t3.lname instead of direct column names first_name and last_name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM members WHERE gender = 'female' AND club_name = 'Hopkins Student Enterprises'",
            "SELECT t3.Fname, t3.LName \nFROM Club AS t1 \nINNER JOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID \nINNER JOIN Student AS t3 ON t2.StuID = t3.StuID \nWHERE t1.ClubName = 'Hopkins Student Enterprises' \nAND t3.Sex = 'M'"
        ],
        "rule_sql": [
            "SELECT t3.Fname, t3.LName FROM Club AS t1 INNER JOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID INNER JOIN Student AS t3 ON t2.StuID = t3.StuID WHERE t1.ClubName = 'Hopkins Student Enterprises' AND t3.Sex = 'M'"
        ]
    },
    "6203": {
        "db_id": "roller_coaster",
        "question": "How many roller coasters are there?",
        "ground_truth": "SELECT count(*) FROM roller_coaster",
        "amends": [
            "Do reference the `roller_coaster` table instead of the `coasters` table. Do filter on the implicit table name instead of using a `type = 'roller'` condition. Do remove the explicit filter condition instead of including it, as the table name itself indicates the type. The amended query now correctly counts all records from the roller_coaster table without needing a redundant type filter."
        ],
        "rules": [
            "1) When answering about \"How many roller coasters are there?\": make sure to count all records from the \"roller_coaster\" table. 2) When the question mentions \"roller coasters\": \"roller coasters\" actually means all records in the \"roller_coaster\" table. 3) When counting roller coasters: compute the number of rows using all records from the \"roller_coaster\" table without any filter conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM coasters WHERE type = 'roller';",
            "SELECT COUNT(*) FROM roller_coaster;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM roller_coaster;"
        ]
    },
    "790": {
        "db_id": "coffee_shop",
        "question": "Find the number of members living in each address.",
        "ground_truth": "SELECT count(*) ,  address FROM member GROUP BY address",
        "amends": [
            "Do use `count(*)` as the first column in the SELECT list instead of placing `address` first. Do reference the table as `member` instead of `members` in the FROM clause. The amended query now correctly counts records grouped by address from the member table."
        ],
        "rules": [
            "1) When answering about \"number of members living in each address\": make sure the output order: count of members first, then address. 2) When referring to the members table: use the exact table name \"member\" instead of \"members\". 3) When counting members per address: use count(*) to count all records in each address group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT address, COUNT(*) FROM members GROUP BY address;",
            "SELECT COUNT(*), Address FROM member GROUP BY Address"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS member_count, Address FROM member GROUP BY Address ORDER BY member_count DESC, Address;"
        ]
    },
    "6858": {
        "db_id": "flight_4",
        "question": "What are the cities that have more than 2 airports sorted by number of airports?",
        "ground_truth": "SELECT city FROM airports GROUP BY city HAVING count(*)  >  2 ORDER BY count(*)",
        "amends": [
            "Do remove the explicit `COUNT(*) as airport_count` column from the SELECT list instead of including it, and do reference `count(*)` directly in both the HAVING clause and ORDER BY clause instead of using the alias `airport_count`. Do use the unaliased aggregate function `count(*)` in the HAVING condition instead of the column alias, and do maintain the same ordering by count but without the alias reference. The amended query now correctly filters cities with more than two airports while returning only the city names and matches the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about cities with more than 2 airports: make sure the output order includes only city names without the count column. 2) When counting airports per city: use count(*) directly in both the HAVING condition and ORDER BY clause instead of using an alias. 3) When filtering for cities with more than 2 airports: use the condition count(*) > 2 in the HAVING clause. 4) When ordering results by number of airports: order by count(*) in ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, COUNT(*) as airport_count FROM airports GROUP BY city HAVING airport_count > 2 ORDER BY airport_count ASC;",
            "SELECT city FROM airports GROUP BY city HAVING COUNT(*) > 2 ORDER BY COUNT(*) DESC;"
        ],
        "rule_sql": [
            "SELECT city FROM airports GROUP BY city HAVING COUNT(*) > 2 ORDER BY COUNT(*) ASC;"
        ]
    },
    "1135": {
        "db_id": "climbing",
        "question": "What are the different names of mountains ascended by climbers from the country of West Germany?",
        "ground_truth": "SELECT DISTINCT T2.Name FROM climber AS T1 JOIN mountain AS T2 ON T1.Mountain_ID  =  T2.Mountain_ID WHERE T1.Country  =  \"West Germany\"",
        "amends": [
            "Do use table alias `T2` for `mountain` instead of `m` for `mountains`. Do reference `T2.Name` instead of `m.mountain_name` in the SELECT list. Do join `climber AS T1` to `mountain AS T2` on `T1.Mountain_ID = T2.Mountain_ID` instead of joining `mountains` to `ascents` to `climbers` through multiple joins. Do filter on `T1.Country = \"West Germany\"` instead of `c.country = 'West Germany'` and use double quotes instead of single quotes. Do remove the unnecessary `ascents` table join and reference climber attributes directly from the `climber` table instead of through the `ascents` intermediary. The amended query now correctly retrieves mountain names by directly joining climbers to mountains and filtering by country, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"different names of mountains ascended by climbers from West Germany\": make sure the output order: T2.Name\n2) When the question mentions \"mountains\": \"mountains\" actually means \"T2.Name in schema\"\n3) When the question mentions \"climbers from the country of West Germany\": filter rows where T1.Country = \"West Germany\" exactly as specified\n4) When combining T1 (climber) and T2 (mountain) for shared entities: link rows where T1.Mountain_ID = T2.Mountain_ID and keep only matching pairs (inner match)\n5) When the question asks for \"different names\": compute the distinct values of T2.Name\n6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for literal \"West Germany\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT m.mountain_name \nFROM mountains m\nJOIN ascents a ON m.mountain_id = a.mountain_id\nJOIN climbers c ON a.climber_id = c.climber_id\nWHERE c.country = 'West Germany';",
            "SELECT DISTINCT T2.Name \nFROM climber AS T1 \nJOIN mountain AS T2 ON T1.Mountain_ID = T2.Mountain_ID \nWHERE T1.Country = \"West Germany\""
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.Name\nFROM climber T1\nINNER JOIN mountain T2 ON T1.Mountain_ID = T2.Mountain_ID\nWHERE T1.Country = \"West Germany\"\nORDER BY T2.Name"
        ]
    },
    "3088": {
        "db_id": "behavior_monitoring",
        "question": "How many addresses have zip code 197?",
        "ground_truth": "SELECT count(*) FROM ADDRESSES WHERE zip_postcode  =  \"197\"",
        "amends": [
            "Do use column name `zip_postcode` instead of `zip_code` in the WHERE filter. Do use double quotes `\"197\"` instead of single quotes `'197'` for the string literal value. The amended query now correctly filters on the appropriate column with proper string quoting, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about zip codes: use the exact column name \"zip_postcode\" instead of \"zip_code\" from the Addresses table. 2) When filtering for zip code values: use double quotes \"197\" instead of single quotes '197' for the string literal value. 3) When counting addresses: count the number of rows in the Addresses table that match the specified zip code condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM addresses WHERE zip_code = '197';",
            "SELECT COUNT(*) FROM Addresses WHERE zip_postcode = \"197\";"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Addresses WHERE zip_postcode = \"197\";"
        ]
    },
    "6627": {
        "db_id": "driving_school",
        "question": "What are the details of the car with id 1?",
        "ground_truth": "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = 1;",
        "amends": [
            "Do select `vehicle_details` instead of `*` to return only the specific column needed. Do query from `Vehicles` table instead of `cars` to use the correct data source. Do filter on `vehicle_id = 1` instead of `car_id = 2` to target the appropriate record identifier and value. The amended query now correctly retrieves the specified vehicle details from the proper table using the correct identifier."
        ],
        "rules": [
            "1) When the question asks for \"details of the car\": select only the \"vehicle_details\" column instead of all columns. 2) When querying vehicle information: use the \"Vehicles\" table instead of \"cars\" as the correct data source. 3) When filtering by vehicle identifier: use \"vehicle_id = 1\" instead of \"car_id = 2\" to target the appropriate record with the correct value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM cars WHERE car_id = 2;",
            "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = 1;"
        ],
        "rule_sql": [
            "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = 1;"
        ]
    },
    "3495": {
        "db_id": "hr_1",
        "question": "display all the information of the employees whose salary if within the range of smallest salary and 2500.",
        "ground_truth": "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND 2500",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND 2500;"
        ],
        "rule_sql": [
            "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND 2500"
        ]
    },
    "3619": {
        "db_id": "music_1",
        "question": "Find the top 3 artists who have the largest number of songs works whose language is Bangla.",
        "ground_truth": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  \"bangla\" GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3",
        "amends": [
            "Do reference the table as `artist` instead of `artists` and `song` instead of `songs`. Do join on `artist_name = artist_name` instead of `artist_id = artist_id`. Do use the column `languages` instead of `language` for filtering. Do filter for `\"bangla\"` instead of `'Bangla'` with proper case sensitivity. Do group by `T2.artist_name` instead of `artist_name`. Do order by `count(*)` instead of the alias `song_count`. Do remove the column alias `song_count` from the SELECT list instead of including it. Do use double quotes around the string literal instead of single quotes. The amended query now correctly joins on artist names, uses the proper column names with correct case sensitivity, and properly aggregates and orders the results to match the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"artists\": use table \"artist\" instead of \"artists\" and table \"song\" instead of \"songs\". 2) When joining artist and song tables: link rows where T1.artist_name = T2.artist_name exactly. 3) When filtering by language: use column \"languages\" instead of \"language\" and filter for exact value \"bangla\" with proper case sensitivity. 4) When grouping results: group by T2.artist_name instead of artist_name. 5) When ordering results: order by count(*) in descending order instead of using an alias. 6) When selecting output columns: include only artist_name and the count without column aliases. 7) When limiting results: take the top 3 rows after ordering by count in descending order."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT artist_name, COUNT(*) as song_count \nFROM artists \nJOIN songs ON artists.artist_id = songs.artist_id \nWHERE songs.language = 'Bangla' \nGROUP BY artist_name \nORDER BY song_count DESC \nLIMIT 3;",
            "SELECT artist.artist_name\nFROM artist\nJOIN song ON artist.artist_name = song.artist_name\nWHERE song.languages = \"bangla\"\nGROUP BY artist.artist_name\nORDER BY COUNT(*) DESC\nLIMIT 3"
        ],
        "rule_sql": [
            "SELECT artist.artist_name, COUNT(*) \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE song.languages = 'bangla' \nGROUP BY song.artist_name \nORDER BY COUNT(*) DESC \nLIMIT 3"
        ]
    },
    "3082": {
        "db_id": "loan_1",
        "question": "Find the average credit score of the customers who have some loan.",
        "ground_truth": "SELECT avg(credit_score) FROM customer WHERE cust_id IN (SELECT cust_id FROM loan)",
        "amends": [
            "Do reference the `customer` table instead of `customers` and use `avg` instead of `AVG` for the aggregate function. Do change the filter to use a subquery `cust_id IN (SELECT cust_id FROM loan)` instead of checking `loan_id IS NOT NULL` directly in the WHERE clause, as this correctly identifies customers who have loans by correlating through the proper relationship between customer and loan tables. The amended query now matches RIGHT_SQL's behavior by accurately calculating the average credit score for customers who have taken loans."
        ],
        "rules": [
            "1) When answering about \"average credit score of customers who have some loan\": make sure the output order: avg(credit_score). 2) When the question mentions \"customers\": \"customers\" actually means \"customer table\". 3) When the question asks for \"average credit score\": use the avg aggregate function on the credit_score column. 4) When identifying customers who have loans: use a subquery condition where cust_id IN (SELECT cust_id FROM loan) to find customers with associated loan records. 5) When combining customer and loan information: use the cust_id as the linking key between customer and loan tables through the subquery relationship."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(credit_score) FROM customers WHERE loan_id IS NOT NULL;",
            "SELECT avg(credit_score) FROM customer WHERE cust_id IN (SELECT cust_id FROM loan)"
        ],
        "rule_sql": [
            "SELECT AVG(credit_score) FROM customer WHERE cust_ID IN (SELECT cust_ID FROM loan)"
        ]
    },
    "480": {
        "db_id": "allergy_1",
        "question": "Who advises student 1004?",
        "ground_truth": "SELECT Advisor FROM Student WHERE StuID  =  1004",
        "amends": [
            "Do reference the `Advisor` column instead of `advisor_name` to match the correct column name in the schema. Do reference the `Student` table instead of `students` to use the proper table name. Do use the `StuID` column instead of `student_id` for the filter condition to align with the correct column identifier. The amended query now correctly retrieves advisor information from the Student table using the proper column and table names."
        ],
        "rules": [
            "1) When the question asks about advising a specific student: use the exact student identifier \"StuID\" from the \"Student\" table for filtering. 2) When the question mentions \"student 1004\": use the exact literal value 1004 without quotes for the student ID filter. 3) When retrieving advisor information: select the exact column \"Advisor\" from the \"Student\" table, not \"advisor_name\". 4) When referencing the student table: use the exact table name \"Student\" with proper capitalization, not \"students\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT advisor_name FROM students WHERE student_id = 1004;",
            "SELECT Advisor FROM Student WHERE StuID = 1004;"
        ],
        "rule_sql": [
            "SELECT Advisor FROM Student WHERE StuID = 1004;"
        ]
    },
    "3306": {
        "db_id": "college_1",
        "question": "What is the name, address, and number of students in the departments that have the 3 most students?",
        "ground_truth": "SELECT T2.dept_name ,  T2.dept_address ,  count(*) FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT 3",
        "amends": [
            "Do use `JOIN` instead of `LEFT JOIN` to exclude departments with no students. Do reference columns as `T2.dept_name` and `T2.dept_address` instead of `d.name` and `d.address`. Do join on `T1.dept_code = T2.dept_code` instead of `d.department_id = s.department_id` with corrected table aliases and column names. Do group by `T1.dept_code` instead of `d.department_id` to match the join condition. Do use `count(*)` instead of `COUNT(s.student_id)` to count all rows in each group. Do order by `count(*)` instead of the alias `student_count` since the alias is no longer defined. The amended query now correctly joins student and department tables on the proper code column and counts enrolled students per department while excluding empty departments."
        ],
        "rules": [
            "1) When combining student and department tables: link rows where T1.dept_code = T2.dept_code and keep only matching pairs (inner match). 2) When counting students per department: compute the number of rows using count(*) for each group. 3) When the question asks for \"3 most students\": rank departments by student count in descending order and keep the first 3 rows. 4) When producing output: include T2.dept_name, T2.dept_address, and the student count in that order. 5) When grouping results: organize by T1.dept_code to match the join condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.name, d.address, COUNT(s.student_id) as student_count\nFROM departments d\nLEFT JOIN students s ON d.department_id = s.department_id\nGROUP BY d.department_id\nORDER BY student_count DESC\nLIMIT 3;",
            "SELECT T2.DEPT_NAME, T2.DEPT_ADDRESS, COUNT(*) AS student_count\nFROM STUDENT T1\nJOIN DEPARTMENT T2 ON T1.DEPT_CODE = T2.DEPT_CODE\nGROUP BY T1.DEPT_CODE\nORDER BY COUNT(*) DESC\nLIMIT 3"
        ],
        "rule_sql": [
            "SELECT d.DEPT_NAME, d.DEPT_ADDRESS, COUNT(*) AS student_count\nFROM STUDENT s\nINNER JOIN DEPARTMENT d ON s.DEPT_CODE = d.DEPT_CODE\nGROUP BY s.DEPT_CODE\nORDER BY student_count DESC\nLIMIT 3"
        ]
    },
    "1403": {
        "db_id": "college_2",
        "question": "How many courses are provided in each semester and year?",
        "ground_truth": "SELECT count(*) ,  semester ,  YEAR FROM SECTION GROUP BY semester ,  YEAR",
        "amends": [
            "Do use `count(*)` as the first column in the SELECT list instead of placing it third. Do reference table `SECTION` in the FROM clause instead of `courses`. Do capitalize `YEAR` in both SELECT and GROUP BY clauses instead of lowercase `year`. Do maintain the same GROUP BY columns `semester, YEAR` but with proper capitalization. The amended query now correctly counts records from the SECTION table grouped by semester and year, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"courses provided in each semester and year\": make sure the output order: count(*) first, then semester, then YEAR. 2) When the question mentions \"courses\": \"courses\" actually means \"SECTION table in schema\". 3) When the question asks for \"count of courses\": compute the number of rows using count(*) from SECTION table. 4) When the question says \"per semester and year\": organize results by semester and YEAR and compute count per group. 5) When handling column names: use exact capitalization YEAR (uppercase) instead of year (lowercase) for the year column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT semester, year, COUNT(*) FROM courses GROUP BY semester, year;",
            "SELECT COUNT(*) AS course_count, semester, YEAR FROM SECTION GROUP BY semester, YEAR"
        ],
        "rule_sql": [
            "SELECT COUNT(*), semester, YEAR FROM section GROUP BY semester, YEAR ORDER BY COUNT(*) DESC, semester, YEAR;"
        ]
    },
    "6202": {
        "db_id": "music_4",
        "question": "Return the issue dates of volumes by artists who are at most 23 years old?",
        "ground_truth": "SELECT Issue_Date FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T1.age  <=  23",
        "amends": [
            "Do use table alias `T1` for `artist` instead of `artists` and `T2` for `volume` instead of `volumes`. Do select `Issue_Date` instead of `issue_date` with proper case sensitivity. Do use `JOIN` with explicit table aliases instead of implicit table names in the join condition. Do change the join condition to `T1.Artist_ID = T2.Artist_ID` instead of `volumes.artist_id = artists.id` with proper column naming. Do reverse the filter condition to `T1.age <= 23` instead of `artists.age > 23` to select artists 23 years old or younger rather than older than 23. The amended query now correctly selects issue dates for artists aged 23 or younger from the properly joined tables."
        ],
        "rules": [
            "1) When answering about \"issue dates of volumes by artists who are at most 23 years old\": make sure the output order: T2.Issue_Date. 2) When combining artist and volume tables for shared entities: link rows where T1.Artist_ID = T2.Artist_ID; keep only matching pairs (inner match). 3) When the question mentions \"at most 23 years old\": filter rows where T1.age <= 23. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 5) When handling text literals: do not change case, spacing, or punctuation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT issue_date FROM volumes JOIN artists ON volumes.artist_id = artists.id WHERE artists.age > 23;",
            "SELECT T2.Issue_Date FROM artist T1 JOIN volume T2 ON T1.Artist_ID = T2.Artist_ID WHERE T1.Age <= 23"
        ],
        "rule_sql": [
            "SELECT T2.\"Issue_Date\" FROM \"artist\" T1 INNER JOIN \"volume\" T2 ON T1.\"Artist_ID\" = T2.\"Artist_ID\" WHERE T1.\"Age\" <= 23 ORDER BY T2.\"Issue_Date\""
        ]
    },
    "4043": {
        "db_id": "student_1",
        "question": "Find the classrooms in which grade 4 is studying.",
        "ground_truth": "SELECT DISTINCT classroom FROM list WHERE grade  =  4",
        "amends": [
            "Do select `classroom` instead of `*` and use `DISTINCT` instead of omitting it. Do query from `list` instead of `classrooms` as the source table. Do filter for `grade = 4` instead of `grade = 5` to target the correct grade level. The amended query now correctly returns distinct classroom values from the list table for fourth grade students, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"classrooms in which grade 4 is studying\": make sure the output order: classroom. 2) When the question asks for distinct classrooms: compute the number of unique values of the exact token \"classroom\". 3) When the question mentions \"grade 4\": use the exact literal value 4 for filtering. 4) When querying from the source table: use the exact table name \"list\" instead of \"classrooms\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM classrooms WHERE grade = 5;",
            "SELECT DISTINCT Classroom FROM list WHERE Grade = 4"
        ],
        "rule_sql": [
            "SELECT DISTINCT Classroom FROM list WHERE Grade = 4 ORDER BY Classroom;"
        ]
    },
    "2975": {
        "db_id": "sakila_1",
        "question": "Return the address of store 1.",
        "ground_truth": "SELECT T2.address FROM store AS T1 JOIN address AS T2 ON T1.address_id  =  T2.address_id WHERE store_id  =  1",
        "amends": [
            "Do select `T2.address` from the `address` table instead of `address` from the `stores` table. Do join `store AS T1` with `address AS T2` using `ON T1.address_id = T2.address_id` instead of querying only the `stores` table. Do filter by `store_id = 1` instead of `store_id = 2` to target the correct store record. The amended query now properly retrieves address information by joining the store and address tables through their relationship key and filtering for the intended store identifier."
        ],
        "rules": [
            "1) When answering about \"address of store 1\": make sure the output order: T2.address 2) When the question mentions \"store 1\": \"store 1\" actually means \"store_id = 1 in schema\" 3) When combining T1 and T2 for shared entities: link rows where T1.address_id = T2.address_id exactly as shown in the amends; keep only matching pairs (inner match) 4) When filtering for a specific store: use store_id = 1 instead of store_id = 2 to target the correct store record"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT address FROM stores WHERE store_id = 2;",
            "SELECT T2.address FROM store AS T1 JOIN address AS T2 ON T1.address_id = T2.address_id WHERE T1.store_id = 1"
        ],
        "rule_sql": [
            "SELECT address.address \nFROM store \nJOIN address ON store.address_id = address.address_id \nWHERE store.store_id = 1"
        ]
    },
    "6274": {
        "db_id": "city_record",
        "question": "Which city has hosted the most events?",
        "ground_truth": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.city` instead of `city` and remove the `event_count` alias instead of keeping it. Do use `FROM city AS T1 JOIN hosting_city AS T2` instead of `FROM events` and change the join condition to `ON T1.city_id = T2.host_city` instead of no join. Do remove the `WHERE` clause instead of having one and change the `GROUP BY` to `T2.host_city` instead of `city`. Do change the `ORDER BY` to `count(*) DESC` instead of `event_count ASC` while keeping `LIMIT 1`. The amended query now correctly joins the city and hosting_city tables to find the city hosting the most events."
        ],
        "rules": [
            "1) When answering about \"which city has hosted the most events\": make sure the output order: T1.city, count(*) 2) When combining T1 and T2 for shared entities: link rows where T1.city_id = T2.host_city exactly as shown in the amends; keep only matching pairs (inner match). 3) When the question mentions \"most events\": rank rows by count(*) in descending direction and keep the first 1 row. 4) When the question asks for \"count of events\": compute the number of rows using the grouping key T2.host_city. 5) When producing output: do not include event_count alias in the final result."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, COUNT(*) as event_count FROM events GROUP BY city ORDER BY event_count ASC LIMIT 1;",
            "SELECT T1.City\nFROM city AS T1\nJOIN hosting_city AS T2 ON T1.City_ID = T2.Host_City\nGROUP BY T2.Host_City\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT c.City, COUNT(*) \nFROM city c\nJOIN hosting_city hc ON c.City_ID = hc.Host_City\nGROUP BY c.City\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "1325": {
        "db_id": "college_2",
        "question": "How many classrooms are not in Lamberton?",
        "ground_truth": "SELECT count(*) FROM classroom WHERE building != 'Lamberton'",
        "amends": [
            "Do reference the table as `classroom` instead of `classrooms` to match the correct table name. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about \"classrooms\": use the exact table name \"classroom\" instead of \"classrooms\" as shown in the schema. 2) When counting entities from the classroom table: count using the canonical key for classrooms (not specified in this simple schema, but use COUNT(*) as shown in the amends). 3) When filtering for classrooms not in Lamberton: use the exact literal 'Lamberton' with the correct case and spelling as shown in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM classrooms WHERE building != 'Lamberton';",
            "SELECT COUNT(*) FROM classroom WHERE building != 'Lamberton';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM classroom WHERE building != 'Lamberton';"
        ]
    },
    "2955": {
        "db_id": "sakila_1",
        "question": "What are the full names of actors who had roles in more than 30 films?",
        "ground_truth": "SELECT T2.first_name ,  T2.last_name FROM film_actor AS T1 JOIN actor AS T2 ON T1.actor_id  =  T2.actor_id GROUP BY T2.actor_id HAVING count(*)  >  30",
        "amends": [
            "Do use `T2.first_name` and `T2.last_name` with explicit table aliases instead of unqualified column names. Do join `film_actor AS T1` to `actor AS T2` on `T1.actor_id = T2.actor_id` instead of querying only the `actors` table. Do add `GROUP BY T2.actor_id` to aggregate by actor instead of omitting grouping. Do move the count filter to `HAVING count(*) > 30` instead of using `WHERE film_count > 30` with a non-existent column. The amended query now correctly counts film appearances per actor and filters based on the actual count rather than a presumed column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"actors who had roles in more than 30 films\": make sure the output order: T2.first_name, T2.last_name. 2) When combining film_actor and actor tables: link rows where T1.actor_id = T2.actor_id and keep only matching pairs (inner match). 3) When counting film appearances per actor: group by T2.actor_id and compute count(*) per group. 4) When filtering for actors with more than 30 films: apply the condition count(*) > 30 after grouping (HAVING clause equivalent). 5) When the question asks for \"full names of actors\": select both T2.first_name and T2.last_name from the actor table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM actors WHERE film_count > 30;",
            "SELECT T2.first_name, T2.last_name\nFROM film_actor AS T1\nJOIN actor AS T2 ON T1.actor_id = T2.actor_id\nGROUP BY T2.actor_id\nHAVING COUNT(*) > 30"
        ],
        "rule_sql": [
            "SELECT T2.first_name, T2.last_name\nFROM film_actor T1\nINNER JOIN actor T2 ON T1.actor_id = T2.actor_id\nGROUP BY T2.actor_id\nHAVING COUNT(*) > 30\nORDER BY T2.first_name, T2.last_name;"
        ]
    },
    "6075": {
        "db_id": "customers_and_addresses",
        "question": "Find the detail of products whose detail contains the word \"Latte\" or the word \"Americano\"",
        "ground_truth": "SELECT product_details FROM products WHERE product_details LIKE \"%Latte%\" OR product_details LIKE \"%Americano%\"",
        "amends": [
            "Do reference `product_details` column instead of `detail` in both the SELECT list and WHERE clause. Do use `OR` logical operator instead of `AND` to find records containing either 'Latte' or 'Americano' instead of requiring both terms simultaneously. Do specify only the `product_details` column in the SELECT list instead of using `*` to return all columns. The amended query now correctly matches the RIGHT_SQL's behavior by finding products containing either coffee type rather than requiring both."
        ],
        "rules": [
            "1) When the question asks for products containing specific words in their details: use the exact column name \"product_details\" from the Products table instead of \"detail\". 2) When searching for products containing either \"Latte\" or \"Americano\": use OR logical operator to find records containing either term, not AND which requires both terms simultaneously. 3) When selecting output columns: specify only the \"product_details\" column instead of using * to return all columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM products WHERE detail LIKE '%Latte%' AND detail LIKE '%Americano%';",
            "SELECT product_details FROM Products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%'"
        ],
        "rule_sql": [
            "SELECT product_details FROM Products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%'"
        ]
    },
    "1029": {
        "db_id": "phone_1",
        "question": "List the hardware model name and company name for all the phones that were launched in year 2002 or have RAM size greater than 32.",
        "ground_truth": "SELECT T2.Hardware_Model_name ,  T2.Company_name FROM chip_model AS T1 JOIN phone AS T2 ON T1.Model_name  =  T2.chip_model WHERE T1.Launch_year = 2002 OR T1.RAM_MiB  >  32;",
        "amends": [
            "Do select `Hardware_Model_name` and `Company_name` from table `phone` instead of `hardware_model_name` and `company_name` from table `phones`. Do join table `chip_model` as `T1` with `phone` as `T2` on `T1.Model_name = T2.chip_model` instead of querying only the `phones` table. Do filter on `T1.Launch_year = 2002` and `T1.RAM_MiB > 32` instead of `launched_year = 2002` and `ram_size > 32` from the original table. The amended query now correctly joins the chip model information with phone data and applies filters to the appropriate source table, matching the intended behavior."
        ],
        "rules": [
            "1) When selecting hardware model and company information: use \"Hardware_Model_name\" and \"Company_name\" from table \"phone\" instead of \"hardware_model_name\" and \"company_name\" from table \"phones\". 2) When combining phone and chip model information: join table \"chip_model\" as T1 with \"phone\" as T2 where T1.Model_name = T2.chip_model using inner match. 3) When filtering for phones launched in year 2002: use T1.Launch_year = 2002 instead of launched_year = 2002. 4) When filtering for phones with RAM size greater than 32: use T1.RAM_MiB > 32 instead of ram_size > 32."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT hardware_model_name, company_name FROM phones WHERE launched_year = 2002 OR ram_size > 32;",
            "SELECT T2.Hardware_Model_name, T2.Company_name \nFROM chip_model T1 \nJOIN phone T2 ON T1.Model_name = T2.chip_model \nWHERE T1.Launch_year = 2002 OR T1.RAM_MiB > 32"
        ],
        "rule_sql": [
            "SELECT T2.Hardware_Model_name, T2.Company_name FROM chip_model AS T1 INNER JOIN phone AS T2 ON T1.Model_name = T2.chip_model WHERE T1.Launch_year = 2002 OR T1.RAM_MiB > 32"
        ]
    },
    "589": {
        "db_id": "store_1",
        "question": "find the full name of employees who report to Nancy Edwards?",
        "ground_truth": "SELECT T2.first_name , T2.last_name FROM employees AS T1 JOIN employees AS T2 ON T1.id = T2.reports_to WHERE T1.first_name = \"Nancy\" AND T1.last_name = \"Edwards\";",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of no aliases. Do change from a subquery in the `WHERE` clause to an explicit `JOIN` between the same table instead of a correlated subquery. Do join on `T1.id = T2.reports_to` instead of filtering by `manager_id = (subquery)`. Do move the name filter conditions `first_name = \"Nancy\"` and `last_name = \"Edwards\"` to the `WHERE` clause applied to `T1` instead of having them in the subquery. Do select from `T2.first_name` and `T2.last_name` instead of selecting from the base table without specifying the alias context. The amended query now correctly identifies direct reports by joining on the reports_to relationship rather than using manager_id filtering with a subquery."
        ],
        "rules": [
            "1) When answering about \"employees who report to Nancy Edwards\": make sure the output order: T2.first_name, T2.last_name. 2) When combining T1 and T2 for shared employees: link rows where T1.id = T2.reports_to and keep only matching pairs (inner match). 3) When the question mentions \"Nancy Edwards\": \"Nancy\" actually means T1.first_name = 'Nancy' and \"Edwards\" actually means T1.last_name = 'Edwards'. 4) When selecting employee names: select T2.first_name and T2.last_name from the reporting employee table (T2) rather than the manager table (T1)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM employees WHERE manager_id = (SELECT employee_id FROM employees WHERE first_name = 'Nancy' AND last_name = 'Edwards')",
            "SELECT T2.first_name, T2.last_name\nFROM employees T1\nJOIN employees T2 ON T1.id = T2.reports_to\nWHERE T1.first_name = 'Nancy' AND T1.last_name = 'Edwards';"
        ],
        "rule_sql": [
            "SELECT T2.first_name, T2.last_name\nFROM employees T1\nINNER JOIN employees T2 ON T1.id = T2.reports_to\nWHERE T1.first_name = 'Nancy' AND T1.last_name = 'Edwards'\nORDER BY T2.first_name, T2.last_name"
        ]
    },
    "2844": {
        "db_id": "customer_deliveries",
        "question": "Find the number of customers in total.",
        "ground_truth": "SELECT count(*) FROM customers",
        "amends": [
            "Do select from `customers` instead of `orders` to count the correct table's records. The amended query now matches the right SQL's behavior of counting customer records rather than order records."
        ],
        "rules": [
            "1) When counting customers: count from the \"customers\" table instead of the \"orders\" table to get the correct entity count. 2) When the question asks for \"number of customers in total\": compute the count using the canonical key from the \"customers\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders;",
            "SELECT COUNT(*) AS total_customers FROM Customers;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS total_customers FROM Customers;"
        ]
    },
    "6465": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "What are the dates for the documents with both 'GV' type and 'SF' type expenses?",
        "ground_truth": "SELECT T1.document_date FROM Documents AS T1 JOIN Documents_with_Expenses AS T2 ON T1.document_id  =  T2.document_id WHERE T2.budget_type_code  =  'GV' INTERSECT SELECT T1.document_date FROM Documents AS T1 JOIN Documents_with_Expenses AS T2 ON T1.document_id  =  T2.document_id WHERE T2.budget_type_code  =  'SF'",
        "amends": [
            "Do join `Documents AS T1` with `Documents_with_Expenses AS T2` on `T1.document_id = T2.document_id` instead of querying only the `documents` table. Do filter on `T2.budget_type_code = 'GV'` and `T2.budget_type_code = 'SF'` in separate queries instead of using contradictory `expense_type = 'GV' AND expense_type = 'SF'` conditions. Do use `INTERSECT` to find dates that appear in both result sets instead of attempting to find rows where a single column equals two different values simultaneously. Do select `T1.document_date` instead of just `date`. The amended query now correctly identifies document dates that have both GV and SF budget types through proper table joins and set intersection logic."
        ],
        "rules": [
            "1) When answering about documents with both 'GV' type and 'SF' type expenses: join Documents AS T1 with Documents_with_Expenses AS T2 on T1.document_id = T2.document_id to access expense information. 2) When filtering for 'GV' type expenses: use T2.budget_type_code = 'GV' with exact literal 'GV'. 3) When filtering for 'SF' type expenses: use T2.budget_type_code = 'SF' with exact literal 'SF'. 4) When finding documents that have both expense types: use INTERSECT to combine results from separate queries for each budget type. 5) When selecting document dates: use T1.document_date instead of just date."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT date FROM documents WHERE expense_type = 'GV' AND expense_type = 'SF';",
            "SELECT T1.document_date\nFROM Documents AS T1\nJOIN Documents_with_Expenses AS T2 ON T1.document_id = T2.document_id\nWHERE T2.budget_type_code = 'GV'\nINTERSECT\nSELECT T1.document_date\nFROM Documents AS T1\nJOIN Documents_with_Expenses AS T2 ON T1.document_id = T2.document_id\nWHERE T2.budget_type_code = 'SF'"
        ],
        "rule_sql": [
            "SELECT T1.document_date\nFROM Documents AS T1\nJOIN Documents_with_Expenses AS T2 ON T1.document_id = T2.document_id\nWHERE T2.budget_type_code = 'GV'\nINTERSECT\nSELECT T1.document_date\nFROM Documents AS T1\nJOIN Documents_with_Expenses AS T2 ON T1.document_id = T2.document_id\nWHERE T2.budget_type_code = 'SF'"
        ]
    },
    "4447": {
        "db_id": "network_2",
        "question": "What are the names of the people who are older 40 but no friends under age 30?",
        "ground_truth": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)",
        "amends": [
            "Do use `Person` and `PersonFriend` tables instead of `people` and `friends`, and change from a single query with `NOT EXISTS` to an `EXCEPT` operation between two subqueries. Do join `Person AS T1` with `PersonFriend AS T2` on `T1.name = T2.name` instead of using a correlated subquery with `friends.person_id = people.id`. Do filter with `T2.friend IN (SELECT name FROM Person WHERE age > 40)` in the first part and `T2.friend IN (SELECT name FROM Person WHERE age < 30)` in the second part instead of `WHERE age > 40 AND NOT EXISTS` with a subquery checking for friends under 30. Do use explicit table aliases `T1` and `T2` instead of no aliases, and structure the query as `EXCEPT` between two similar join operations instead of a single filtered selection. The amended query now correctly identifies people whose friends are all over 40 by excluding those with any friends under 30, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"people who are older 40 but no friends under age 30\": use Person table as T1 and PersonFriend table as T2. 2) When combining T1 and T2: link rows where T1.name = T2.name exactly as shown in the amends. 3) When the question mentions \"older 40\": filter using T2.friend IN (SELECT name FROM Person WHERE age > 40). 4) When the question mentions \"no friends under age 30\": exclude results where T2.friend IN (SELECT name FROM Person WHERE age < 30) using EXCEPT operation. 5) When producing output: return only the name column from T1."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM people WHERE age > 40 AND NOT EXISTS (SELECT 1 FROM friends WHERE friends.person_id = people.id AND friends.age < 30)",
            "SELECT T1.name\nFROM Person AS T1\nJOIN PersonFriend AS T2 ON T1.name = T2.name\nWHERE T2.friend IN (SELECT name FROM Person WHERE age > 40)\nEXCEPT\nSELECT T1.name\nFROM Person AS T1\nJOIN PersonFriend AS T2 ON T1.name = T2.name\nWHERE T2.friend IN (SELECT name FROM Person WHERE age < 30)"
        ],
        "rule_sql": [
            "SELECT T1.name\nFROM Person AS T1\nJOIN PersonFriend AS T2 ON T1.name = T2.name\nWHERE T2.friend IN (SELECT name FROM Person WHERE age > 40)\nEXCEPT\nSELECT T1.name\nFROM Person AS T1\nJOIN PersonFriend AS T2 ON T1.name = T2.name\nWHERE T2.friend IN (SELECT name FROM Person WHERE age < 30)"
        ]
    },
    "5222": {
        "db_id": "music_2",
        "question": "Which vocal type has the band mate with last name \"Heilo\" played the most?",
        "ground_truth": "SELECT TYPE FROM vocals AS T1 JOIN band AS T2 ON T1.bandmate  =  T2.id WHERE lastname  =  \"Heilo\" GROUP BY TYPE ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `vocals` and `band` tables on `T1.bandmate = T2.id` instead of querying only `band_mates`. Do filter on `lastname = \"Heilo\"` instead of `last_name = 'Heilo'`. Do group by `TYPE` instead of `vocal_type`. Do order by `count(*)` descending instead of ordering by the alias `count`. Do select only `TYPE` instead of both `vocal_type` and `count(*)`. The amended query now correctly joins related tables and returns the vocal type with the highest count for the specified band member."
        ],
        "rules": [
            "1) When combining vocals and band tables: link rows where T1.bandmate = T2.id exactly as shown and keep only matching pairs (inner match). 2) When filtering for last name \"Heilo\": use exact literal \"Heilo\" with column name \"lastname\" (not last_name). 3) When grouping by vocal type: use the exact column token \"TYPE\" for grouping instead of \"vocal_type\". 4) When counting occurrences: count all rows per group to determine frequency. 5) When ordering results: sort by the count in descending order to find the highest count. 6) When selecting output: return only the \"TYPE\" column instead of both vocal type and count. 7) When answering about \"most played vocal type\": return the single result with the highest count after ranking."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT vocal_type, COUNT(*) as count FROM band_mates WHERE last_name = 'Heilo' GROUP BY vocal_type ORDER BY count DESC LIMIT 1;",
            "SELECT v.Type\nFROM Vocals v\nJOIN Band b ON v.Bandmate = b.Id\nWHERE b.Lastname = 'Heilo'\nGROUP BY v.Type\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT TYPE FROM Vocals JOIN Band ON Vocals.Bandmate = Band.Id WHERE Band.Lastname = 'Heilo' GROUP BY TYPE ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "2964": {
        "db_id": "sakila_1",
        "question": "How many films are there in each category? List the genre name, genre id and the count.",
        "ground_truth": "SELECT T2.name ,  T1.category_id ,  count(*) FROM film_category AS T1 JOIN category AS T2 ON T1.category_id  =  T2.category_id GROUP BY T1.category_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category.name, category.category_id, COUNT(film.film_id) \nFROM category \nLEFT JOIN film_category ON category.category_id = film_category.category_id \nLEFT JOIN film ON film_category.film_id = film.film_id \nGROUP BY category.category_id"
        ],
        "rule_sql": [
            "SELECT c.category_id, c.name AS genre_name, COUNT(fc.film_id) AS film_count\nFROM category c\nLEFT JOIN film_category fc ON c.category_id = fc.category_id\nGROUP BY c.category_id, c.name\nORDER BY c.category_id;",
            "SELECT c.category_id, c.name AS genre_name, COUNT(fc.film_id) AS film_count\nFROM category c\nLEFT JOIN film_category fc ON c.category_id = fc.category_id\nGROUP BY c.category_id, c.name\nORDER BY c.category_id;"
        ]
    },
    "6756": {
        "db_id": "activity_1",
        "question": "What are the faculty id and the number of students each faculty has?",
        "ground_truth": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID",
        "amends": [
            "Do join `Faculty AS T1` to `Student AS T2` on `T1.FacID = T2.advisor` instead of querying only the `students` table. Do select `T1.FacID` instead of `faculty_id` to reference the joined table's column. Do use the explicit join condition `T1.FacID = T2.advisor` instead of grouping by `faculty_id` without proper table context. The amended query now correctly counts students per faculty by joining through the advisor relationship instead of assuming faculty_id exists directly in the students table, matching the RIGHT_SQL's behavior.",
            "Do use `INNER JOIN` instead of `LEFT JOIN` to exclude faculty without students. Do use `count(*)` instead of `COUNT(T2.StuID)` to count all student records rather than just non-null student IDs. Do remove the alias `number_of_students` instead of keeping it for simpler output. The amended query now correctly counts students per faculty advisor using an inner join that matches the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"faculty id and number of students each faculty has\": make sure the output order: T1.FacID, count of students per faculty. 2) When combining Faculty as T1 and Student as T2: link rows where T1.FacID = T2.advisor exactly as shown in the amends; keep only matching pairs (inner match). 3) When counting students per faculty: compute the number of rows using the relationship T2.advisor = T1.FacID for each faculty. 4) When selecting faculty identifier: use T1.FacID instead of faculty_id to reference the joined table's column.",
            "1) When combining Faculty as T1 and Student as T2: link rows where T1.FacID equals T2.Advisor and keep only matching pairs (inner match). 2) When counting students per faculty: compute the number of rows using all student records rather than just non-null student IDs. 3) When answering about faculty id and number of students: make sure the output order is T1.FacID followed by the count of students."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT faculty_id, COUNT(*) FROM students GROUP BY faculty_id;",
            "SELECT T1.FacID, COUNT(T2.StuID) AS number_of_students\nFROM Faculty AS T1\nLEFT JOIN Student AS T2 ON T1.FacID = T2.Advisor\nGROUP BY T1.FacID",
            "SELECT T1.FacID, COUNT(*) FROM Faculty AS T1 INNER JOIN Student AS T2 ON T1.FacID = T2.Advisor GROUP BY T1.FacID"
        ],
        "rule_sql": [
            "SELECT T1.FacID, COUNT(*) AS student_count FROM Faculty AS T1 INNER JOIN Student AS T2 ON T1.FacID = T2.Advisor GROUP BY T1.FacID ORDER BY T1.FacID;"
        ]
    },
    "2998": {
        "db_id": "sakila_1",
        "question": "Which store has most the customers?",
        "ground_truth": "SELECT store_id FROM customer GROUP BY store_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference table `customer` instead of `customers` in the FROM clause. Do remove the explicit column alias `customer_count` and instead use the aggregate expression `count(*)` directly in the ORDER BY clause. Do change the sort direction to `DESC` instead of `ASC` to find the store with the highest customer count. Do remove the explicit column selection `COUNT(customer_id) AS customer_count` from the SELECT list and instead only return `store_id` as required. The amended query now correctly identifies the store with the most customers by counting all records per store group and ordering descending."
        ],
        "rules": [
            "1) When answering about \"which store has the most customers\": make sure the output order: store_id only. 2) When counting customers: use count(*) to count all records per store group. 3) When finding the store with the highest customer count: order the results by the count in descending direction and keep only the first row. 4) When grouping by store: use store_id as the grouping key from the customer table. 5) When referring to the customer table: use the exact identifier \"customer\" (not \"customers\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT store_id, COUNT(customer_id) AS customer_count FROM customers GROUP BY store_id ORDER BY customer_count ASC LIMIT 1;",
            "SELECT store_id FROM customer GROUP BY store_id ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT store_id FROM customer GROUP BY store_id ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "4473": {
        "db_id": "network_2",
        "question": "What are the names of all people who are friends with Alice for the shortest amount of time?",
        "ground_truth": "SELECT name FROM PersonFriend WHERE friend =  'Alice' AND YEAR  =  (SELECT min(YEAR) FROM PersonFriend WHERE friend =  'Alice')",
        "amends": [
            "Do select `name` from `PersonFriend` instead of `p.name` from `people`. Do use `WHERE friend = 'Alice'` instead of joining with `friends` table and subquery filtering. Do add `AND YEAR = (SELECT min(YEAR) FROM PersonFriend WHERE friend = 'Alice')` instead of ordering by `friendship_duration ASC` with limit. Do remove the explicit join and subquery structure instead of keeping the complex join pattern. The amended query now correctly finds the person who has been friends with Alice for the shortest duration by using the minimum year value directly."
        ],
        "rules": [
            "1) When answering about \"names of people who are friends with Alice\": select the exact column \"name\" from table \"PersonFriend\". 2) When the question mentions \"friends with Alice\": filter rows where column \"friend\" equals exactly 'Alice'. 3) When the question asks for \"shortest amount of time\" (minimum duration): add condition that column \"YEAR\" must equal the minimum \"YEAR\" value from rows where \"friend\" equals 'Alice'. 4) When handling text literals: preserve the exact case and spelling of 'Alice' as shown in the schema and amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.name \nFROM people p\nJOIN friends f ON p.id = f.person_id\nWHERE f.friend_id = (SELECT id FROM people WHERE name = 'Alice')\nORDER BY f.friendship_duration ASC\nLIMIT 1;",
            "SELECT name FROM PersonFriend WHERE friend = 'Alice' AND year = (SELECT MIN(year) FROM PersonFriend WHERE friend = 'Alice')"
        ],
        "rule_sql": [
            "SELECT name FROM PersonFriend WHERE friend = 'Alice' AND year = (SELECT MIN(year) FROM PersonFriend WHERE friend = 'Alice')"
        ]
    },
    "1162": {
        "db_id": "body_builder",
        "question": "What are the names of body builders in descending order of total scores?",
        "ground_truth": "SELECT T2.Name FROM body_builder AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T1.Total DESC",
        "amends": [
            "Do select `T2.Name` from the `people` table instead of `name` from the `body_builders` table. Do join `people AS T2` to `body_builder AS T1` on `T1.People_ID = T2.People_ID` instead of querying only the `body_builders` table. Do order by `T1.Total DESC` instead of `total_score ASC`, changing both the column reference and sort direction. The amended query now correctly retrieves names from the people table joined with body builder data and sorts by total score in descending order, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"names of body builders\": select \"T2.Name\" from the \"people\" table instead of \"name\" from the \"body_builders\" table. 2) When combining \"body_builders\" and \"people\" tables: link rows where \"T1.People_ID = T2.People_ID\" and keep only matching pairs (inner match). 3) When ordering by total scores in descending order: sort by \"T1.Total\" in descending direction instead of ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM body_builders ORDER BY total_score ASC;",
            "SELECT T2.Name \nFROM body_builder AS T1 \nJOIN people AS T2 ON T1.People_ID = T2.People_ID \nORDER BY T1.Total DESC"
        ],
        "rule_sql": [
            "SELECT T2.Name \nFROM body_builder T1 \nINNER JOIN people T2 ON T1.People_ID = T2.People_ID \nORDER BY T1.Total DESC"
        ]
    },
    "1060": {
        "db_id": "match_season",
        "question": "Show the players from college UCLA.",
        "ground_truth": "SELECT Player FROM match_season WHERE College  =  \"UCLA\"",
        "amends": [
            "Do select `Player` instead of `*` to return only the specific column needed. Do query from `match_season` table instead of `players` table to access the correct data source. Do use double quotes `\"UCLA\"` instead of single quotes `'UCLA'` for string literal formatting. The amended query now correctly retrieves UCLA players from the appropriate table with proper column selection and string formatting."
        ],
        "rules": [
            "1) When answering about \"players from college UCLA\": make sure the output order: Player. 2) When the question mentions \"college UCLA\": \"college UCLA\" actually means \"UCLA\" in schema. 3) When selecting from tables: use the match_season table instead of players table to access the correct data source. 4) When using string literals: use double quotes \"UCLA\" instead of single quotes 'UCLA' for proper string formatting."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM players WHERE college = 'UCLA';",
            "SELECT \"Player\" FROM \"match_season\" WHERE \"College\" = \"UCLA\""
        ],
        "rule_sql": [
            "SELECT Player FROM match_season WHERE College = \"UCLA\" ORDER BY Player;"
        ]
    },
    "4951": {
        "db_id": "soccer_2",
        "question": "How many different players trained for more than 1000 hours?",
        "ground_truth": "SELECT count(*) FROM Player WHERE HS  >  1000",
        "amends": [
            "Do reference table `Player` instead of `players` in the FROM clause. Do use filter condition `HS > 1000` instead of `training_hours > 1000` in the WHERE clause. The amended query now correctly counts records from the Player table where the HS column exceeds 1000, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"different players trained for more than 1000 hours\": make sure to count distinct players using the canonical key from the Player table. 2) When the question mentions \"players\": \"players\" actually means table \"Player\" in the schema. 3) When the question mentions \"trained for more than 1000 hours\": this condition actually means column \"HS\" > 1000 in the Player table. 4) When counting distinct players: compute the number of unique values using the canonical key from the Player table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE training_hours > 1000",
            "SELECT COUNT(*) FROM Player WHERE HS > 1000"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT pID) FROM Player WHERE HS > 1000;"
        ]
    },
    "3355": {
        "db_id": "sports_competition",
        "question": "Please show the names and the players of clubs.",
        "ground_truth": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID",
        "amends": [
            "Do select `T1.name` and `T2.Player_id` instead of `name` and `players`. Do join `club AS T1` with `player AS T2` on `T1.Club_ID = T2.Club_ID` instead of querying only `clubs` table. Do remove the `WHERE players IS NULL` filter instead of keeping it. The amended query now correctly joins related tables and retrieves player associations rather than filtering for null values."
        ],
        "rules": [
            "1) When answering about \"names and players of clubs\": make sure the output order: T1.name, T2.Player_id 2) When the question mentions \"clubs\": use table \"club\" as T1 instead of \"clubs\" 3) When the question mentions \"players\": use column \"Player_id\" from table \"player\" as T2 instead of \"players\" 4) When combining club and player tables: link rows where T1.Club_ID = T2.Club_ID and keep only matching pairs (inner match) 5) When the original query had a WHERE players IS NULL filter: remove this filter entirely instead of keeping it"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, players FROM clubs WHERE players IS NULL;",
            "SELECT T1.name, T2.Player_ID FROM club AS T1 JOIN player AS T2 ON T1.Club_ID = T2.Club_ID"
        ],
        "rule_sql": [
            "SELECT T1.name, T2.Player_ID FROM club AS T1 INNER JOIN player AS T2 ON T1.Club_ID = T2.Club_ID ORDER BY T1.name, T2.Player_ID"
        ]
    },
    "5086": {
        "db_id": "device",
        "question": "List the carriers of devices that have no devices in stock.",
        "ground_truth": "SELECT Carrier FROM device WHERE Device_ID NOT IN (SELECT Device_ID FROM stock)",
        "amends": [
            "Do select `Carrier` instead of `carrier` and use table `device` instead of `devices`. Do remove the `WHERE stock = 0` filter instead of keeping it and instead use a subquery with `NOT IN` to filter devices where `Device_ID` is not present in the `stock` table. Do reference `Device_ID` in both the main query and subquery instead of using a direct column comparison. The amended query now correctly identifies devices without stock by checking their absence from the stock table rather than relying on a potentially incorrect stock value column."
        ],
        "rules": [
            "1) When the question asks about \"carriers\": use the exact column name \"Carrier\" from the device table. 2) When checking for devices with no stock: use a subquery to find Device_ID values that are not present in the stock table's Device_ID column instead of checking a stock value column. 3) When combining device and stock information: use Device_ID as the linking key between tables to identify which devices have no stock records. 4) When selecting from the device table: use the correct table name \"device\" instead of \"devices\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT carrier FROM devices WHERE stock = 0;",
            "SELECT Carrier FROM device WHERE Device_ID NOT IN (SELECT Device_ID FROM stock)"
        ],
        "rule_sql": [
            "SELECT DISTINCT Carrier FROM device WHERE Device_ID NOT IN (SELECT Device_ID FROM stock)"
        ]
    },
    "6752": {
        "db_id": "activity_1",
        "question": "Which students have professors as their advisors? Find their student ids.",
        "ground_truth": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  \"Professor\"",
        "amends": [
            "Do use `T2.StuID` instead of `student_id` for the SELECT column. Do join `Faculty AS T1` with `Student AS T2` instead of querying only the `students` table. Do use the join condition `T1.FacID = T2.advisor` instead of filtering by `advisor_type = 'professor'`. Do filter with `T1.rank = \"Professor\"` in the WHERE clause instead of checking `advisor_type = 'professor'`. The amended query now correctly retrieves student IDs by joining with faculty data and filtering on professor rank instead of relying on a potentially incorrect advisor_type field."
        ],
        "rules": [
            "1) When selecting student IDs: use \"T2\".\"StuID\" as the output column. 2) When combining faculty and student data: link rows where \"T1\".\"FacID\" equals \"T2\".\"advisor\" and keep only matching pairs (inner join). 3) When filtering for professors: check that \"T1\".\"rank\" equals \"Professor\" exactly. 4) When answering about students with professors as advisors: make sure the output order shows only \"T2\".\"StuID\" values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id FROM students WHERE advisor_type = 'professor';",
            "SELECT T2.StuID\nFROM Faculty AS T1\nJOIN Student AS T2 ON T1.FacID = T2.Advisor\nWHERE T1.Rank = 'Professor';"
        ],
        "rule_sql": [
            "SELECT T2.StuID FROM Faculty T1 INNER JOIN Student T2 ON T1.FacID = T2.Advisor WHERE T1.Rank = 'Professor';"
        ]
    },
    "1087": {
        "db_id": "match_season",
        "question": "Count the number of different colleges that players who play for Columbus Crew are from.",
        "ground_truth": "SELECT count(DISTINCT T1.College) FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id WHERE T2.Name  =  \"Columbus Crew\"",
        "amends": [
            "Do use `count(DISTINCT T1.College)` instead of `COUNT(*)` to count distinct colleges instead of all rows. Do add `FROM match_season AS T1 JOIN team AS T2 ON T1.Team = T2.Team_id` instead of `FROM players` to join two tables with proper relationship. Do use `WHERE T2.Name = \"Columbus Crew\"` instead of `WHERE team = 'Columbus Crew'` to filter by team name rather than team identifier. Do remove the direct table reference to `players` and instead use the joined tables `match_season` and `team` to properly relate players to their colleges through team membership. The amended query now correctly counts distinct colleges for players on the Columbus Crew team by properly joining the relevant tables and filtering on the team name."
        ],
        "rules": [
            "1) When counting different colleges that players are from: use count(DISTINCT T1.College) to count distinct college values instead of counting all rows. 2) When relating players to their teams: join match_season AS T1 with team AS T2 using T1.Team = T2.Team_id to establish the proper relationship between players and teams. 3) When filtering for Columbus Crew: use WHERE T2.Name = \"Columbus Crew\" to filter by the exact team name rather than using a team identifier. 4) When answering about colleges of players on a specific team: use the joined tables match_season and team instead of directly referencing a players table to properly relate players to their colleges through team membership."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE team = 'Columbus Crew';",
            "SELECT COUNT(DISTINCT T1.College) \nFROM match_season AS T1 \nJOIN team AS T2 ON T1.Team = T2.Team_id \nWHERE T2.Name = \"Columbus Crew\""
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.College) \nFROM match_season AS T1 \nJOIN team AS T2 ON T1.Team = T2.Team_id \nWHERE T2.Name = \"Columbus Crew\""
        ]
    },
    "6166": {
        "db_id": "music_4",
        "question": "What are the dates of ceremony at music festivals corresponding to volumes that lasted more than 2 weeks on top?",
        "ground_truth": "SELECT T1.Date_of_ceremony FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T2.Weeks_on_Top  >  2",
        "amends": [
            "Do reference `T1.Date_of_ceremony` instead of `ceremony_date` and use table alias `T1` instead of direct table reference. Do join `volume AS T2` on `T1.Volume = T2.Volume_ID` instead of querying `music_festivals` alone without any join. Do filter on `T2.Weeks_on_Top > 2` instead of `volume_duration > 14` to use the correct column from the joined volume table. Do remove `ORDER BY ceremony_date` instead of keeping it since the right query doesn't require sorting. The amended query now correctly joins festival data with volume information and applies the proper filtering condition to match the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"dates of ceremony at music festivals\": make sure the output order: T1.Date_of_ceremony 2) When the question mentions \"volumes that lasted more than 2 weeks on top\": use T2.Weeks_on_Top > 2 as the filtering condition 3) When combining music_festivals as T1 and volume as T2: link rows where T1.Volume = T2.Volume_ID and keep only matching pairs (inner match) 4) When the question does not require ordering: do not include any sorting in the results"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT ceremony_date FROM music_festivals WHERE volume_duration > 14 ORDER BY ceremony_date;",
            "SELECT T1.Date_of_ceremony FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume = T2.Volume_ID WHERE T2.Weeks_on_Top > 2"
        ],
        "rule_sql": [
            "SELECT T1.Date_of_ceremony \nFROM music_festival T1\nINNER JOIN volume T2 ON T1.Volume = T2.Volume_ID\nWHERE T2.Weeks_on_Top > 2"
        ]
    },
    "6536": {
        "db_id": "wine_1",
        "question": "What are the distinct names of wines that have appellations in the North Coast area?",
        "ground_truth": "SELECT DISTINCT T2.Name FROM APPELLATIONs AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.Area  =  \"North Coast\"",
        "amends": [
            "Do select `T2.Name` from the `WINE` table instead of `name` from the `wines` table. Do join `APPELLATIONs AS T1` with `WINE AS T2` instead of querying a single table. Do use the join condition `T1.Appelation = T2.Appelation` to connect the tables instead of filtering directly. Do filter on `T1.Area = \"North Coast\"` instead of `appellation = 'North Coast'` to correctly reference the area field in the APPELLATIONs table. The amended query now properly joins the two related tables and filters based on the area field rather than the appellation field, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about distinct wine names from North Coast area: make sure the output order: T2.Name. 2) When the question mentions \"wines\": \"wines\" actually means \"WINE table as T2\" in schema. 3) When the question mentions \"appellations in North Coast area\": \"appellations\" actually means \"APPELLATIONs table as T1\" and \"North Coast area\" means T1.Area = \"North Coast\". 4) When combining T1 and T2 for shared appellations: link rows where T1.Appelation = T2.Appelation exactly as shown; keep only matching pairs (inner match). 5) When the question asks for \"distinct names\": compute the number of unique values of T2.Name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT name FROM wines WHERE appellation = 'North Coast';",
            "SELECT DISTINCT T2.Name \nFROM appellations AS T1 \nJOIN wine AS T2 ON T1.Appelation = T2.Appelation \nWHERE T1.Area = 'North Coast'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.Name\nFROM appellations AS T1\nINNER JOIN wine AS T2 ON T1.Appelation = T2.Appelation\nWHERE T1.Area = 'North Coast'\nORDER BY T2.Name;"
        ]
    },
    "6355": {
        "db_id": "school_bus",
        "question": "Show home city where at least two drivers older than 40 are from.",
        "ground_truth": "SELECT home_city FROM driver WHERE age  >  40 GROUP BY home_city HAVING count(*)  >=  2",
        "amends": [
            "Do use table name `driver` instead of `drivers` in the FROM clause. Do change the HAVING condition to `count(*) >= 2` instead of `COUNT(*) >= 1` to filter for cities with at least two drivers meeting the age criteria. The amended query now correctly identifies cities with multiple drivers over 40 years old, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"drivers\": use the exact table name \"driver\" instead of \"drivers\" in the FROM clause. 2) When counting drivers per home city with age > 40: use count(*) >= 2 in the HAVING condition to filter for cities with at least two drivers meeting the age criteria."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT home_city FROM drivers WHERE age > 40 GROUP BY home_city HAVING COUNT(*) >= 1;",
            "SELECT Home_city FROM driver WHERE Age > 40 GROUP BY Home_city HAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT Home_city FROM driver WHERE Age > 40 GROUP BY Home_city HAVING COUNT(*) >= 2"
        ]
    },
    "5982": {
        "db_id": "game_1",
        "question": "Count the number of video games with Massively multiplayer online game type .",
        "ground_truth": "SELECT count(*) FROM Video_games WHERE gtype  =  \"Massively multiplayer online game\"",
        "amends": [
            "Do use the correct table name `Video_games` instead of `video_games` to match the actual schema. Do use the correct column name `gtype` instead of `game_type` for the game type attribute. Do use the exact string value `\"Massively multiplayer online game\"` instead of `'Massively Multiplayer Online'` to match the precise category designation in the data. The amended query now correctly counts games in the specified category using the proper schema elements and exact string matching."
        ],
        "rules": [
            "1) When referring to the video games table: use the exact table name \"Video_games\" with the specified capitalization and underscore. 2) When filtering by game type: use the exact column name \"gtype\" instead of \"game_type\". 3) When matching the \"Massively multiplayer online game\" type: use the exact string literal \"Massively multiplayer online game\" with the precise case, spacing, and punctuation as shown in the data."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM video_games WHERE game_type = 'Massively Multiplayer Online';",
            "SELECT COUNT(*) FROM Video_Games WHERE GType = 'Massively multiplayer online game';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Video_Games WHERE gtype = 'Massively multiplayer online game';"
        ]
    },
    "828": {
        "db_id": "chinook_1",
        "question": "What are the names of tracks that contain the the word you in them?",
        "ground_truth": "SELECT Name FROM TRACK WHERE Name LIKE '%you%'",
        "amends": [
            "Do reference the table as `TRACK` instead of `tracks` and use column name `Name` instead of `name` while maintaining the same `LIKE '%you%'` filter condition instead of the original table and column references. The amended query now correctly matches the RIGHT_SQL's behavior with the proper table and column capitalization."
        ],
        "rules": [
            "1) When the question asks about tracks containing the word \"you\": use the table name \"TRACK\" exactly as specified in the schema instead of \"tracks\". 2) When referencing the track name column: use the column name \"Name\" exactly as specified in the schema instead of \"name\". 3) When filtering for tracks containing the word \"you\": apply the condition \"Name LIKE '%you%'\" to find tracks with the exact word \"you\" anywhere in the track name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM tracks WHERE name LIKE '%you%';",
            "SELECT Name FROM Track WHERE Name LIKE '%you%'"
        ],
        "rule_sql": [
            "SELECT Name FROM Track WHERE Name LIKE '%you%'"
        ]
    },
    "115": {
        "db_id": "bike_1",
        "question": "Give me the start station and end station for the trips with the three oldest id.",
        "ground_truth": "SELECT start_station_name ,  end_station_name FROM trip ORDER BY id LIMIT 3",
        "amends": [
            "Do select `start_station_name` and `end_station_name` instead of `start_station` and `end_station`. Do reference table `trip` instead of `trips`. Do remove explicit `ASC` direction from `ORDER BY id` instead of keeping it. The amended query now correctly retrieves station names from the trip table with proper column references and ordering."
        ],
        "rules": [
            "1) When answering about \"start station and end station\": make sure the output order: \"start_station_name\", \"end_station_name\". 2) When the question mentions \"trips\": \"trips\" actually means \"trip\" in schema. 3) When the question asks for \"the three oldest id\": rank rows by \"id\" in ascending order and keep the first 3 rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT start_station, end_station FROM trips ORDER BY id ASC LIMIT 3;",
            "SELECT start_station_name, end_station_name FROM trip ORDER BY id LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT start_station_name, end_station_name FROM trip ORDER BY id ASC LIMIT 3;"
        ]
    },
    "954": {
        "db_id": "medicine_enzyme_interaction",
        "question": "What is the id and name of the enzyme that can interact with the most medicines as an activator?",
        "ground_truth": "SELECT T1.id ,  T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id WHERE T2.interaction_type  =  'activitor' GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do select `T1.id` and `T1.name` instead of `enzyme_id` and `enzyme_name`. Do join `enzyme AS T1` with `medicine_enzyme_interaction AS T2` instead of using a subquery. Do use `JOIN` with `ON T1.id = T2.enzyme_id` instead of an `IN` subquery. Do filter with `WHERE T2.interaction_type = 'activitor'` instead of `interaction_type = 'activator'`. Do group by `T1.id` instead of grouping within the subquery. Do order by `count(*) DESC` instead of ordering within the subquery. Do remove the redundant subquery structure and instead perform aggregation directly in the main query. The amended query now correctly identifies enzymes with the most medicine interactions of type 'activitor' and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about enzymes and their medicine interactions: use table aliases T1 for enzyme table and T2 for medicine_enzyme_interaction table. 2) When selecting enzyme information: select T1.id and T1.name instead of enzyme_id and enzyme_name. 3) When combining enzyme and interaction data: join T1 and T2 where T1.id = T2.enzyme_id using an inner match. 4) When filtering for activator interactions: use WHERE T2.interaction_type = 'activitor' with exact spelling 'activitor'. 5) When grouping enzyme interactions: group by T1.id to count interactions per enzyme. 6) When counting medicine interactions: use count(*) to count all interaction records per enzyme. 7) When finding the enzyme with most interactions: order by count(*) DESC and take the top result. 8) When handling output order: present results with T1.id first, then T1.name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT enzyme_id, enzyme_name \nFROM enzymes \nWHERE enzyme_id IN (\n    SELECT enzyme_id \n    FROM medicine_enzyme_interactions \n    WHERE interaction_type = 'activator' \n    GROUP BY enzyme_id \n    ORDER BY COUNT(medicine_id) DESC \n    LIMIT 1\n)",
            "SELECT T1.id, T1.name\nFROM enzyme AS T1\nJOIN medicine_enzyme_interaction AS T2 ON T1.id = T2.enzyme_id\nWHERE T2.interaction_type = 'activitor'\nGROUP BY T1.id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.id, T1.name\nFROM enzyme T1\nINNER JOIN medicine_enzyme_interaction T2 ON T1.id = T2.enzyme_id\nWHERE T2.interaction_type = 'activitor'\nGROUP BY T1.id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "5280": {
        "db_id": "manufactory_1",
        "question": "How many companies were created by Andy?",
        "ground_truth": "SELECT count(*) FROM manufacturers WHERE founder  =  'Andy'",
        "amends": [
            "Do reference the `manufacturers` table instead of the `companies` table. Do filter on the `founder` column instead of the `created_by` column. The amended query now correctly counts records from the manufacturers table where the founder is Andy, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"companies\": use the \"manufacturers\" table instead. 2) When the question mentions \"created by\": \"created by\" actually means \"founder\" in schema. 3) When filtering for \"Andy\": use the exact literal value 'Andy' with the correct case and spacing."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM companies WHERE created_by = 'Andy';",
            "SELECT COUNT(*) FROM Manufacturers WHERE Founder = 'Andy';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Manufacturers WHERE Founder = 'Andy';"
        ]
    },
    "3271": {
        "db_id": "college_1",
        "question": "What is the name of department where has the largest number of professors with a Ph.D. degree?",
        "ground_truth": "SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  'Ph.D.' GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.dept_name` and `T1.dept_code` instead of only `department_name`. Do join `professor AS T1` with `department AS T2` on `T1.dept_code = T2.dept_code` instead of querying only the `departments` table. Do filter on `T1.prof_high_degree = 'Ph.D.'` instead of `degree = 'Ph.D.'`. Do add `GROUP BY T1.dept_code` and `ORDER BY count(*) DESC LIMIT 1` instead of using a subquery with `MAX(professor_count)`. Do remove the subquery and instead use aggregation to find the department with the most Ph.D. professors. The amended query now correctly identifies the department with the highest number of Ph.D. professors by joining professor and department tables and counting occurrences."
        ],
        "rules": [
            "1) When answering about \"department with largest number of professors with Ph.D. degree\": make sure the output order: T2.dept_name, T1.dept_code. 2) When the question mentions \"department\": use T2.dept_name for department name and T1.dept_code for department code. 3) When combining professor (T1) and department (T2) tables: link rows where T1.dept_code = T2.dept_code and keep only matching pairs (inner match). 4) When filtering for professors with Ph.D. degree: use T1.prof_high_degree = 'Ph.D.' exactly as specified. 5) When counting professors per department: group by T1.dept_code and count the number of rows per group. 6) When the question asks for \"largest number\": rank departments by count(*) in descending order and keep only the top 1 department."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department_name FROM departments WHERE professor_count = (SELECT MAX(professor_count) FROM departments) AND degree = 'Ph.D.'",
            "SELECT T2.DEPT_NAME, T1.DEPT_CODE\nFROM PROFESSOR AS T1\nJOIN DEPARTMENT AS T2 ON T1.DEPT_CODE = T2.DEPT_CODE\nWHERE T1.PROF_HIGH_DEGREE = 'Ph.D.'\nGROUP BY T1.DEPT_CODE\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.dept_name, T1.dept_code\nFROM PROFESSOR T1\nINNER JOIN DEPARTMENT T2 ON T1.dept_code = T2.dept_code\nWHERE T1.prof_high_degree = 'Ph.D.'\nGROUP BY T1.dept_code\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "4686": {
        "db_id": "college_3",
        "question": "What is the full name of the instructor who has a course named COMPUTER LITERACY?",
        "ground_truth": "SELECT T2.Fname ,  T2.Lname FROM COURSE AS T1 JOIN FACULTY AS T2 ON T1.Instructor  =  T2.FacID WHERE T1.CName  =  \"COMPUTER LITERACY\"",
        "amends": [
            "Do select `T2.Fname` and `T2.Lname` instead of `first_name` and `last_name`. Do join `COURSE AS T1` with `FACULTY AS T2` on `T1.Instructor = T2.FacID` instead of querying only the `instructors` table. Do filter on `T1.CName = \"COMPUTER LITERACY\"` instead of `course_name = 'COMPUTER LITERACY'`. The amended query now correctly joins the course and faculty tables to retrieve instructor names based on course assignment, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for instructor names based on a course: join COURSE as T1 with FACULTY as T2 on T1.Instructor = T2.FacID to link courses to their assigned instructors. 2) When filtering for a specific course name: use T1.CName = \"COMPUTER LITERACY\" with exact case and spacing as specified. 3) When selecting instructor names: output T2.Fname and T2.Lname instead of first_name and last_name to match the schema's column naming. 4) When combining tables for course-instructor relationships: perform an inner match where T1.Instructor equals T2.FacID to ensure only valid instructor-course assignments are included."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM instructors WHERE course_name = 'COMPUTER LITERACY';",
            "SELECT T2.Fname, T2.Lname FROM Course AS T1 JOIN Faculty AS T2 ON T1.Instructor = T2.FacID WHERE T1.CName = 'COMPUTER LITERACY'"
        ],
        "rule_sql": [
            "SELECT T2.Fname, T2.Lname FROM Course AS T1 JOIN Faculty AS T2 ON T1.Instructor = T2.FacID WHERE T1.CName = 'COMPUTER LITERACY';"
        ]
    },
    "40": {
        "db_id": "farm",
        "question": "Please show the themes of competitions with host cities having populations larger than 1000.",
        "ground_truth": "SELECT T2.Theme FROM city AS T1 JOIN farm_competition AS T2 ON T1.City_ID  =  T2.Host_city_ID WHERE T1.Population  >  1000",
        "amends": [
            "Do select `T2.Theme` from the `farm_competition` table instead of `theme` from `competitions`. Do join `city AS T1` with `farm_competition AS T2` using `ON T1.City_ID = T2.Host_city_ID` instead of querying a single table. Do filter on `T1.Population > 1000` instead of `city_population > 1000` to correctly reference the population column from the city table. The amended query now properly joins the city and farm_competition tables to retrieve competition themes based on city population criteria, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"themes of competitions with host cities having populations larger than 1000\": make sure the output order: T2.Theme\n2) When the question mentions \"host cities\": \"host cities\" actually means \"T1.City_ID = T2.Host_city_ID in schema\"\n3) When the question mentions \"populations larger than 1000\": filter rows where T1.Population > 1000\n4) When combining city as T1 and farm_competition as T2 for shared entities: link rows where T1.City_ID = T2.Host_city_ID exactly as shown in the amends; keep only matching pairs (inner match)\n5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for T2.Theme, T1.City_ID, T2.Host_city_ID, and T1.Population"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT theme FROM competitions WHERE city_population > 1000",
            "SELECT T2.Theme FROM farm_competition AS T2 JOIN city AS T1 ON T1.City_ID = T2.Host_city_ID WHERE T1.Population > 1000"
        ],
        "rule_sql": [
            "SELECT T2.Theme\nFROM city AS T1\nINNER JOIN farm_competition AS T2 ON T1.City_ID = T2.Host_city_ID\nWHERE T1.Population > 1000\nORDER BY T2.Theme"
        ]
    },
    "5444": {
        "db_id": "voter_2",
        "question": "Find the number of students in total.",
        "ground_truth": "SELECT count(*) FROM STUDENT",
        "amends": [
            "Do reference the table as `STUDENT` instead of `students` to match the correct table name. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency with the right SQL. Do remove the `WHERE grade = 'A'` filter instead of keeping it, as the right query counts all records without filtering. The amended query now correctly counts all records in the STUDENT table without any grade filtering, matching the behavior of the right SQL."
        ],
        "rules": [
            "1) When the question asks for \"number of students in total\": count all records in the \"STUDENT\" table without any filtering. 2) When referring to the student table: use the exact table name \"STUDENT\" with uppercase letters as shown in the schema. 3) When counting records: use lowercase \"count(*)\" for consistency with the correct SQL dialect. 4) When the question does not specify any grade filtering: do not apply any WHERE conditions related to grade values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE grade = 'A';",
            "SELECT count(*) FROM Student;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM STUDENT;"
        ]
    },
    "4865": {
        "db_id": "school_player",
        "question": "What is the list of school locations sorted in descending order of school foundation year?",
        "ground_truth": "SELECT LOCATION FROM school ORDER BY Founded DESC",
        "amends": [
            "Do use the table name `school` instead of `schools` and select the column `LOCATION` instead of `location`. Do order by `Founded` in `DESC` order instead of `foundation_year` in `ASC` order. The amended query now correctly retrieves location data from the school table sorted by founding date in descending order."
        ],
        "rules": [
            "1) When the question asks for school locations: select \"LOCATION\" from the \"school\" table. 2) When the question mentions \"school foundation year\": this refers to the \"Founded\" column in the \"school\" table. 3) When the question asks for sorting in descending order: order the results by \"Founded\" in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location FROM schools ORDER BY foundation_year ASC;",
            "SELECT Location FROM school ORDER BY Founded DESC;"
        ],
        "rule_sql": [
            "SELECT Location FROM school ORDER BY Founded DESC;"
        ]
    },
    "4392": {
        "db_id": "tracking_grants_for_research",
        "question": "What are the staff roles of the staff who",
        "ground_truth": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'",
        "amends": [
            "Do select `role_code` from `Project_Staff` instead of `role` from `staff`. Do add date range filters `date_from > '2003-04-19 15:06:20'` and `date_to < '2016-03-15 00:33:18'` instead of using a subquery condition. Do remove the `IN` subquery with `staff_roles` table instead of keeping it. The amended query now correctly filters by date range on the Project_Staff table instead of using an incorrect subquery approach."
        ],
        "rules": [
            "1) When answering about staff roles: select \"role_code\" from \"Project_Staff\" instead of \"role\" from \"staff\". 2) When filtering by date range: apply conditions where \"date_from\" > '2003-04-19 15:06:20' and \"date_to\" < '2016-03-15 00:33:18'. 3) When combining data from multiple tables: do not use subqueries with the \"staff_roles\" table when the required information is available in \"Project_Staff\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT role FROM staff WHERE id IN (SELECT staff_id FROM staff_roles)",
            "SELECT DISTINCT role_code FROM Project_Staff WHERE date_from > '2003-04-19 15:06:20' AND date_to < '2016-03-15 00:33:18'"
        ],
        "rule_sql": [
            "SELECT DISTINCT role_code FROM Project_Staff WHERE date_from > '2003-04-19 15:06:20' AND date_to < '2016-03-15 00:33:18'"
        ]
    },
    "3956": {
        "db_id": "hospital_1",
        "question": "List the names of all distinct medications, ordered in an alphabetical order.",
        "ground_truth": "SELECT DISTINCT name FROM medication ORDER BY name",
        "amends": [
            "Do select `name` instead of `medication_name` and add `DISTINCT` instead of omitting it. Do reference table `medication` instead of `medications`. Do order by `name` in ascending order instead of descending order with `DESC`. The amended query now correctly retrieves unique medication names from the proper table in alphabetical order."
        ],
        "rules": [
            "1) When the question asks for \"medications\": use the exact table name \"medication\" instead of \"medications\". 2) When the question asks for \"names of medications\": use the exact column name \"name\" instead of \"medication_name\". 3) When the question asks for \"distinct medications\": include DISTINCT to return only unique medication names. 4) When the question specifies \"ordered in an alphabetical order\": sort by \"name\" in ascending order instead of descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT medication_name FROM medications ORDER BY medication_name DESC;",
            "SELECT DISTINCT Name FROM Medication ORDER BY Name ASC;"
        ],
        "rule_sql": [
            "SELECT DISTINCT name FROM medication ORDER BY name ASC;"
        ]
    },
    "2254": {
        "db_id": "machine_repair",
        "question": "What are the names of the technicians by ascending order of quality rank for the machine they are assigned?",
        "ground_truth": "SELECT T3.Name FROM repair_assignment AS T1 JOIN machine AS T2 ON T1.machine_id  =  T2.machine_id JOIN technician AS T3 ON T1.technician_ID  =  T3.technician_ID ORDER BY T2.quality_rank",
        "amends": [
            "Do select `T3.Name` instead of `t.name, m.quality_rank`. Do use `repair_assignment AS T1` joined with `machine AS T2` on `T1.machine_id = T2.machine_id` instead of directly joining `technicians t` with `machines m` on `t.machine_id = m.id`. Do add a second join with `technician AS T3` on `T1.technician_ID = T3.technician_ID` instead of omitting the repair_assignment table. Do order by `T2.quality_rank` instead of `m.quality_rank ASC`. The amended query now correctly follows the relationship chain through repair_assignment to connect technicians with machines via their proper foreign keys."
        ],
        "rules": [
            "1) When answering about \"names of technicians by ascending order of quality rank\": make sure the output order: T3.Name, T2.quality_rank 2) When combining repair_assignment and machine tables: link rows where T1.machine_id = T2.machine_id and keep only matching pairs (inner match) 3) When combining repair_assignment and technician tables: link rows where T1.technician_ID = T3.technician_ID and keep only matching pairs (inner match) 4) When ordering results by quality rank: sort rows by T2.quality_rank in ascending order 5) When selecting technician names: use T3.Name as the exact identifier for technician names"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT t.name, m.quality_rank FROM technicians t JOIN machines m ON t.machine_id = m.id ORDER BY m.quality_rank ASC;",
            "SELECT T3.Name \nFROM repair_assignment AS T1 \nJOIN machine AS T2 ON T1.Machine_ID = T2.Machine_ID \nJOIN technician AS T3 ON T1.technician_id = T3.technician_id \nORDER BY T2.quality_rank ASC"
        ],
        "rule_sql": [
            "SELECT T3.Name, T2.quality_rank\nFROM repair_assignment T1\nINNER JOIN machine T2 ON T1.Machine_ID = T2.Machine_ID\nINNER JOIN technician T3 ON T1.technician_id = T3.technician_id\nORDER BY T2.quality_rank ASC;"
        ]
    },
    "1668": {
        "db_id": "theme_gallery",
        "question": "How many exhibitions has each artist had?",
        "ground_truth": "SELECT T2.name ,  count(*) FROM exhibition AS T1 JOIN artist AS T2 ON T1.artist_id  =  T2.artist_id GROUP BY T1.artist_id",
        "amends": [
            "Do add table `artist AS T2` in the FROM clause instead of omitting it. Do use `JOIN` with predicate `ON T1.artist_id = T2.artist_id` instead of querying only the exhibitions table. Do select `T2.name` instead of only `artist_id`. Do reference `T1.artist_id` in GROUP BY instead of just `artist_id` to match the joined table alias. The amended query now correctly joins exhibitions with artists to display artist names alongside exhibition counts, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"how many exhibitions each artist has had\": make sure the output order: artist name followed by exhibition count. 2) When the question mentions \"artist\": \"artist\" actually means \"T2.name in schema\". 3) When the question asks for \"count of exhibitions\": compute the number of rows using the canonical key token for exhibitions (T1.artist_id). 4) When combining T1 (exhibitions) and T2 (artist) for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (T1.artist_id = T2.artist_id); keep only matching pairs (inner match). 5) When the question says \"each artist\": organize results by the token for artist (T2.name) and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT artist_id, COUNT(*) FROM exhibitions GROUP BY artist_id;",
            "SELECT T2.Name, COUNT(T1.Exhibition_ID) AS Exhibition_Count\nFROM exhibition AS T1\nJOIN artist AS T2 ON T1.Artist_ID = T2.Artist_ID\nGROUP BY T1.Artist_ID, T2.Name"
        ],
        "rule_sql": [
            "SELECT T2.Name, COUNT(T1.Artist_ID) AS Exhibition_Count\nFROM exhibition T1\nINNER JOIN artist T2 ON T1.Artist_ID = T2.Artist_ID\nGROUP BY T2.Name\nORDER BY T2.Name;"
        ]
    },
    "3180": {
        "db_id": "college_1",
        "question": "What are the first names and birthdates of the professors in charge of ACCT-211?",
        "ground_truth": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  \"ACCT-211\"",
        "amends": [
            "Do select `EMP_FNAME` and `EMP_DOB` instead of `first_name` and `birthdate`. Do use `DISTINCT` instead of omitting it. Do join `employee AS T1` with `CLASS AS T2` on `T1.EMP_NUM = T2.PROF_NUM` instead of querying only the `professors` table. Do filter on `CRS_CODE = \"ACCT-211\"` instead of `course_code = 'ACCT-211'`. The amended query now correctly retrieves distinct employee names and birthdates by joining the employee and class tables with the proper relationship and filtering."
        ],
        "rules": [
            "1) When the question asks for \"first names and birthdates\": select \"EMP_FNAME\" and \"EMP_DOB\" from table T1. 2) When the question mentions \"professors in charge of ACCT-211\": join \"employee AS T1\" with \"CLASS AS T2\" where \"T1.EMP_NUM = T2.PROF_NUM\" and filter for \"CRS_CODE = \\\"ACCT-211\\\"\". 3) When retrieving employee information: use DISTINCT to return unique combinations of \"EMP_FNAME\" and \"EMP_DOB\". 4) When combining tables for shared entities: perform an inner match where \"T1.EMP_NUM = T2.PROF_NUM\" to link employee records with their assigned classes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, birthdate FROM professors WHERE course_code = 'ACCT-211';",
            "SELECT DISTINCT T1.EMP_FNAME, T1.EMP_DOB\nFROM EMPLOYEE AS T1\nJOIN CLASS AS T2 ON T1.EMP_NUM = T2.PROF_NUM\nWHERE T2.CRS_CODE = 'ACCT-211'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.EMP_FNAME, T1.EMP_DOB FROM EMPLOYEE AS T1 INNER JOIN CLASS AS T2 ON T1.EMP_NUM = T2.PROF_NUM WHERE T2.CRS_CODE = \"ACCT-211\""
        ]
    },
    "3155": {
        "db_id": "assets_maintenance",
        "question": "How many engineers did each staff contact? List both the contact staff name and number of engineers contacted.",
        "ground_truth": "SELECT T1.staff_name ,  count(*) FROM Staff AS T1 JOIN Engineer_Visits AS T2 ON T1.staff_id  =  T2.contact_staff_id GROUP BY T1.staff_name",
        "amends": [
            "Do use `T1.staff_name` with table alias instead of unqualified `staff_name`. Do count all rows with `count(*)` instead of counting `engineer_id` which may contain NULL values. Do join `Staff AS T1` and `Engineer_Visits AS T2` tables instead of querying only the `contacts` table. Do use the correct join condition `T1.staff_id = T2.contact_staff_id` instead of missing the relationship between tables. The amended query now correctly counts engineer visits per staff member by properly joining the relevant tables with the appropriate relationship."
        ],
        "rules": [
            "1) When joining Staff and Engineer_Visits tables: use table aliases T1 for Staff and T2 for Engineer_Visits, and link rows where T1.staff_id = T2.contact_staff_id to establish the relationship between staff members and their engineer contacts. 2) When counting engineers contacted by each staff member: use count(*) to count all rows instead of counting engineer_id which may contain NULL values. 3) When selecting output columns: include T1.staff_name for the contact staff name and the count result for number of engineers contacted. 4) When grouping results: organize by T1.staff_name to show the count of engineers per staff member."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT staff_name, COUNT(engineer_id) AS number_of_engineers\nFROM contacts\nGROUP BY staff_name;",
            "SELECT T1.staff_name, COUNT(*) AS number_of_engineers_contacted\nFROM Staff AS T1\nJOIN Engineer_Visits AS T2 ON T1.staff_id = T2.contact_staff_id\nGROUP BY T1.staff_id, T1.staff_name"
        ],
        "rule_sql": [
            "SELECT T1.staff_name, COUNT(*) AS number_of_engineers_contacted\nFROM Staff T1\nJOIN Engineer_Visits T2 ON T1.staff_id = T2.contact_staff_id\nGROUP BY T1.staff_name;"
        ]
    },
    "803": {
        "db_id": "coffee_shop",
        "question": "What are the id and address of the shops which have a happy hour in May?",
        "ground_truth": "SELECT t1.address ,  t1.shop_id FROM shop AS t1 JOIN happy_hour AS t2 ON t1.shop_id  =  t2.shop_id WHERE MONTH  =  'May'",
        "amends": [
            "Do select `t1.address` and `t1.shop_id` instead of `id` and `address`. Do use `FROM shop AS t1 JOIN happy_hour AS t2` instead of `FROM shops` alone. Do add the join condition `ON t1.shop_id = t2.shop_id` instead of omitting it. Do change the filter to `WHERE MONTH = 'May'` instead of `WHERE happy_hour LIKE '%May%'`. The amended query now correctly joins tables and uses exact month matching instead of pattern matching, producing the intended results.",
            "Do use lowercase column names `address` and `shop_id` instead of mixed case `Shop_ID` and `Address`. Do maintain the same `JOIN` on `t1.shop_id = t2.shop_id` instead of changing the join condition. Do keep the same `WHERE` filter on `MONTH = 'May'` instead of modifying the filter logic. The amended query now correctly preserves the original logic while using consistent lowercase column naming conventions.",
            "Do reverse the column order in the SELECT list to `address, shop_id` instead of `shop_id, address`. Do use `MONTH` instead of `Month` in the WHERE filter to match the correct column name. The amended query now correctly selects columns in the specified order and uses the proper column name for the month filter, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about shops with happy hours in May: make sure the output order: shop_id, address 2) When the question mentions \"id\": \"id\" actually means \"shop_id in schema\" 3) When combining shop and happy_hour tables: link rows where t1.shop_id = t2.shop_id exactly as shown; keep only matching pairs (inner match) 4) When filtering for happy hours in May: use exact literal matching with MONTH = 'May' instead of pattern matching",
            "1) When the question asks for \"id\" and \"address\" of shops: use the exact column tokens \"shop_id\" and \"address\" from table T1 (shop) in lowercase. 2) When combining shop and happy_hour tables: link rows where T1.shop_id = T2.shop_id and keep only matching pairs (inner match). 3) When filtering for shops with happy hour in May: use the exact literal 'May' (case-sensitive) for the Month column in table T2 (happy_hour). 4) When producing output: maintain the column order as shop_id followed by address.",
            "1) When answering about \"id and address of shops\": make sure the output order: address, shop_id. 2) When the question mentions \"happy hour in May\": \"May\" actually means \"MONTH = 'May'\" in schema, using exact literal 'May' with proper case. 3) When combining shop and happy_hour tables: link rows where shop_id values are equal (t1.shop_id = t2.shop_id) and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, address FROM shops WHERE happy_hour LIKE '%May%';",
            "SELECT t1.Shop_ID, t1.Address FROM shop AS t1 JOIN happy_hour AS t2 ON t1.Shop_ID = t2.Shop_ID WHERE t2.Month = 'May'",
            "SELECT t1.shop_id, t1.address FROM shop AS t1 JOIN happy_hour AS t2 ON t1.shop_id = t2.shop_id WHERE t2.Month = 'May'",
            "SELECT t1.address, t1.shop_id FROM shop AS t1 JOIN happy_hour AS t2 ON t1.shop_id = t2.shop_id WHERE t2.MONTH = 'May'"
        ],
        "rule_sql": [
            "SELECT s.shop_id, s.address FROM shop s INNER JOIN happy_hour hh ON s.shop_id = hh.shop_id WHERE hh.Month = 'May'"
        ]
    },
    "6400": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "Count the number of documents.",
        "ground_truth": "SELECT count(*) FROM Documents",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM documents;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Documents;"
        ]
    },
    "5639": {
        "db_id": "railway",
        "question": "What is the name of the oldest manager?",
        "ground_truth": "SELECT Name FROM manager ORDER BY Age DESC LIMIT 1",
        "amends": [
            "Do reference table `manager` instead of `managers` and select column `Name` instead of `name`. Do order by `Age DESC` instead of `age ASC` while maintaining the `LIMIT 1` clause. The amended query now correctly retrieves the single record from the manager table ordered by age in descending sequence, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"manager\": use table \"manager\" instead of \"managers\". 2) When selecting the name of a manager: use column \"Name\" instead of \"name\". 3) When finding the oldest manager: order by \"Age DESC\" instead of ascending order to get the highest age first. 4) When retrieving a single oldest record: maintain the LIMIT 1 clause to return only one result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM managers ORDER BY age ASC LIMIT 1;",
            "SELECT Name FROM manager ORDER BY Age DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name FROM manager ORDER BY Age DESC LIMIT 1;"
        ]
    },
    "6118": {
        "db_id": "customers_and_addresses",
        "question": "Return the number of customers who have at least one order with \"Cancelled\" status.",
        "ground_truth": "SELECT count(DISTINCT customer_id) FROM customer_orders WHERE order_status  =  \"Cancelled\"",
        "amends": [
            "Do count `DISTINCT customer_id` instead of `COUNT(*)` to count unique customers rather than all rows. Do query from `customer_orders` table instead of `customers` table to access the appropriate order data. Do filter on `order_status = 'Cancelled'` instead of `status = 'Cancelled'` to use the correct column name and table context. The amended query now correctly counts distinct customers with cancelled orders, matching the intended behavior."
        ],
        "rules": [
            "1) When counting customers with cancelled orders: count distinct \"customer_id\" values instead of counting all rows. 2) When accessing order status information: use the \"customer_orders\" table instead of the \"customers\" table. 3) When filtering for cancelled orders: use \"order_status = 'Cancelled'\" instead of \"status = 'Cancelled'\" to match the correct column name and table context."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE status = 'Cancelled';",
            "SELECT COUNT(DISTINCT customer_id) FROM Customer_Orders WHERE order_status = 'Cancelled'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT customer_id) \nFROM Customer_Orders \nWHERE order_status = 'Cancelled'"
        ]
    },
    "6412": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "How many documents correspond with each project id?",
        "ground_truth": "SELECT project_id ,  count(*) FROM Documents GROUP BY project_id",
        "amends": [
            "Do group by `project_id` instead of `document_id` to correctly aggregate counts per project. Do capitalize `Documents` instead of lowercase `documents` for table name consistency. The amended query now correctly counts documents grouped by project_id rather than incorrectly grouping by document_id itself."
        ],
        "rules": [
            "1) When the question asks for \"count of documents per project id\": group results by the exact token \"project_id\" and count using the canonical key for documents. 2) When referring to the documents table: use the exact table name \"Documents\" with capital D as shown in the schema. 3) When grouping by project_id: ensure the output shows project_id first followed by the count of documents for each project."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT project_id, COUNT(*) FROM documents GROUP BY document_id;",
            "SELECT Project_ID, COUNT(Document_ID) AS Document_Count FROM Documents GROUP BY Project_ID;"
        ],
        "rule_sql": [
            "SELECT project_id, COUNT(*) AS document_count FROM Documents GROUP BY project_id ORDER BY project_id;"
        ]
    },
    "238": {
        "db_id": "musical",
        "question": "What are the characters and duration of actors?",
        "ground_truth": "SELECT Character ,  Duration FROM actor",
        "amends": [
            "Do reference table `actor` instead of `actors` to correctly target the intended data source. Do use column names `Character` and `Duration` with proper capitalization instead of lowercase `character` and `duration` to match the actual schema. The amended query now correctly retrieves character and duration information from the actor table as intended."
        ],
        "rules": [
            "1) When the question asks about \"characters and duration of actors\": use table \"actor\" instead of \"actors\" to correctly target the intended data source. 2) When selecting character information: use column name \"Character\" with proper capitalization instead of lowercase \"character\" to match the actual schema. 3) When selecting duration information: use column name \"Duration\" with proper capitalization instead of lowercase \"duration\" to match the actual schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT character, duration FROM actors;",
            "SELECT Character, Duration FROM actor;"
        ],
        "rule_sql": [
            "SELECT Character, Duration FROM actor;"
        ]
    },
    "2118": {
        "db_id": "cre_Doc_Control_Systems",
        "question": "What is the receipt date of the document with id 3?",
        "ground_truth": "SELECT receipt_date FROM Documents WHERE document_id = 3;",
        "amends": [
            "Do reference the table as `Documents` instead of `documents` to match the correct case sensitivity. Do filter on `document_id = 3` instead of `id = 3` to use the proper column name for document identification. The amended query now correctly retrieves the receipt date from the Documents table using the appropriate document identifier column."
        ],
        "rules": [
            "1) When referencing the Documents table: use the exact identifier \"Documents\" with proper case sensitivity. 2) When filtering by document identifier: use the column \"document_id\" instead of \"id\" to match the correct column name. 3) When retrieving receipt date for a specific document: filter using \"document_id = 3\" to get the correct document with identifier value 3."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT receipt_date FROM documents WHERE id = 3;",
            "SELECT receipt_date FROM Documents WHERE document_id = 3;"
        ],
        "rule_sql": [
            "SELECT receipt_date FROM Documents WHERE document_id = 3;"
        ]
    },
    "6819": {
        "db_id": "flight_4",
        "question": "Which country is the airport that has the highest altitude located in?",
        "ground_truth": "SELECT country FROM airports ORDER BY elevation DESC LIMIT 1",
        "amends": [
            "Do order by `elevation` instead of `altitude` and use `DESC` instead of `ASC` in the ORDER BY clause. Do keep the same column selection `country` and maintain the `LIMIT 1` constraint. The amended query now correctly retrieves the country with the highest elevation instead of the lowest altitude, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"altitude\": \"altitude\" actually means \"elevation\" in the airports table. 2) When the question asks for \"highest altitude\": rank rows by elevation in descending order and keep the first 1 row. 3) When answering about \"which country is the airport that has the highest altitude located in\": make sure the output order: country."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM airports ORDER BY altitude ASC LIMIT 1;",
            "SELECT country FROM airports ORDER BY elevation DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT country FROM airports ORDER BY elevation DESC LIMIT 1;"
        ]
    },
    "6264": {
        "db_id": "ship_1",
        "question": "Find the name and flag of ships that are not steered by any captain with Midshipman rank.",
        "ground_truth": "SELECT name ,  flag FROM ship WHERE ship_id NOT IN (SELECT ship_id FROM captain WHERE rank  =  'Midshipman')",
        "amends": [
            "Do select only `name` and `flag` columns instead of including the table alias prefix. Do query from the `ship` table instead of `ships` with alias. Do remove the explicit JOIN with `captains` table instead of keeping it. Do use a NOT IN subquery filter instead of a WHERE condition on joined tables. Do reference `ship_id` in the subquery instead of `captain_id` for proper correlation. Do filter for ships not associated with Midshipman-ranked captains instead of excluding Midshipman captains directly. The amended query now correctly identifies ships without Midshipman captains using a subquery approach instead of join filtering."
        ],
        "rules": [
            "1) When selecting columns from the ship table: use the exact column names \"name\" and \"flag\" without table alias prefixes. 2) When querying from the ship table: use the exact table name \"ship\" without alias. 3) When filtering ships not steered by captains with Midshipman rank: use a NOT IN subquery instead of a JOIN approach. 4) When correlating the subquery with the main query: use \"ship_id\" as the linking column instead of \"captain_id\". 5) When checking for Midshipman rank in the subquery: use the exact literal value 'Midshipman' with proper case and spelling. 6) When the question asks for ships not steered by any captain with Midshipman rank: ensure the query returns ships that have no association with captains whose rank equals 'Midshipman'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.name, s.flag \nFROM ships s\nJOIN captains c ON s.captain_id = c.id\nWHERE c.rank != 'Midshipman';",
            "SELECT name, flag FROM Ship WHERE Ship_ID NOT IN (SELECT Ship_ID FROM captain WHERE Rank = 'Midshipman')"
        ],
        "rule_sql": [
            "SELECT name, flag FROM ship WHERE ship_id NOT IN (SELECT ship_id FROM captain WHERE rank = 'Midshipman')"
        ]
    },
    "2309": {
        "db_id": "perpetrator",
        "question": "What are the names of perpetrators?",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN perpetrator AS T2 ON T1.People_ID  =  T2.People_ID",
        "amends": [
            "Do add `JOIN perpetrator AS T2 ON T1.People_ID = T2.People_ID` instead of querying only the `victims` table. Do change the source from `FROM victims` to `FROM people AS T1` instead of using the incorrect table. Do specify the table alias with `T1.Name` instead of just `name` without qualification. Do add the required join condition `T1.People_ID = T2.People_ID` instead of omitting the relationship between tables. The amended query now correctly joins the people and perpetrator tables to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"names of perpetrators\": make sure the output order: T2.Name 2) When the question asks for perpetrator names: use the \"perpetrator\" table (aliased as T2) instead of the \"victims\" table 3) When combining people and perpetrator tables: link rows where T1.People_ID = T2.People_ID and keep only matching pairs (inner match) 4) When selecting columns from joined tables: qualify column names with the correct table alias (use T2.Name instead of unqualified name)"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM victims;",
            "SELECT T1.Name FROM people AS T1 JOIN perpetrator AS T2 ON T1.People_ID = T2.People_ID"
        ],
        "rule_sql": [
            "SELECT T2.Name FROM perpetrator T2 INNER JOIN people T1 ON T1.People_ID = T2.People_ID ORDER BY T2.Name"
        ]
    },
    "645": {
        "db_id": "store_1",
        "question": "Find the name of tracks which are in both Movies and music playlists.",
        "ground_truth": "SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  'Movies' INTERSECT SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  'Music'",
        "amends": [
            "Do use `INTERSECT` with two separate queries instead of multiple joins to find tracks in both playlists. Do reference tables as `playlist_tracks` and `playlists` instead of `playlist_track` and `playlists`. Do use column names `id`, `track_id`, and `playlist_id` instead of `TrackId` and `PlaylistId`. Do move the playlist name filters to `WHERE` clauses instead of `JOIN` conditions. Do select from a single table alias `T1` for tracks instead of multiple joins on the same table. Do remove the redundant table aliases `pt1`, `p1`, `pt2`, and `p2` instead of keeping them. The amended query now correctly finds tracks that exist in both the 'Movies' and 'Music' playlists using set intersection logic."
        ],
        "rules": [
            "1) When the question asks for tracks in both 'Movies' and 'Music' playlists: use set intersection logic instead of multiple joins to find the common tracks. 2) When referencing the playlist-track relationship table: use the exact table name \"playlist_tracks\" instead of \"playlist_track\". 3) When using column identifiers: use \"id\" for playlist identifiers, \"track_id\" for track identifiers, and \"playlist_id\" for playlist references in the playlist_tracks table. 4) When filtering by playlist names: place the playlist name conditions in WHERE clauses with exact literals 'Movies' and 'Music' instead of JOIN conditions. 5) When selecting from the tracks table: use a single table alias \"T1\" instead of multiple joins on the same table. 6) When combining results from two separate queries: use INTERSECT to find tracks that exist in both the 'Movies' and 'Music' playlists."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.Name \nFROM tracks t\nJOIN playlist_track pt1 ON t.TrackId = pt1.TrackId\nJOIN playlists p1 ON pt1.PlaylistId = p1.PlaylistId AND p1.Name = 'Movies'\nJOIN playlist_track pt2 ON t.TrackId = pt2.TrackId\nJOIN playlists p2 ON pt2.PlaylistId = p2.PlaylistId AND p2.Name = 'Music';",
            "SELECT t.name\nFROM tracks t\nWHERE t.id IN (\n    SELECT pt.track_id\n    FROM playlist_tracks pt\n    JOIN playlists p ON pt.playlist_id = p.id\n    WHERE p.name = 'Movies'\n    INTERSECT\n    SELECT pt.track_id\n    FROM playlist_tracks pt\n    JOIN playlists p ON pt.playlist_id = p.id\n    WHERE p.name = 'Music'\n)"
        ],
        "rule_sql": [
            "SELECT T1.name \nFROM tracks T1\nJOIN playlist_tracks PT1 ON T1.id = PT1.track_id\nJOIN playlists P1 ON PT1.playlist_id = P1.id\nWHERE P1.name = 'Movies'\nINTERSECT\nSELECT T1.name \nFROM tracks T1\nJOIN playlist_tracks PT2 ON T1.id = PT2.track_id\nJOIN playlists P2 ON PT2.playlist_id = P2.id\nWHERE P2.name = 'Music'"
        ]
    },
    "4413": {
        "db_id": "network_2",
        "question": "What is the name of the youngest male?",
        "ground_truth": "SELECT name FROM Person WHERE gender  =  'male' AND age  =  (SELECT min(age) FROM person WHERE gender  =  'male' )",
        "amends": [
            "Do reference table `Person` instead of `people` in the FROM clause. Do add a subquery `(SELECT min(age) FROM person WHERE gender = 'male')` to find the minimum age instead of using `ORDER BY age ASC LIMIT 1`. Do change the age filter to `age = (subquery)` instead of ordering and limiting. Do add an explicit `AND` condition for age equality instead of relying on ordering and limiting. Do remove the `ORDER BY` and `LIMIT` clauses instead of keeping them. The amended query now correctly identifies the person with the minimum age among males instead of potentially returning multiple rows with the same minimum age."
        ],
        "rules": [
            "1) When answering about \"the youngest male\": make sure the output order: name. 2) When the question mentions \"youngest\": \"youngest\" actually means \"minimum age in schema\". 3) When the question mentions \"male\": \"male\" actually means \"gender = 'male' in schema\". 4) When finding the minimum age: compute the minimum value of age from all rows where gender = 'male'. 5) When identifying the person with minimum age: select rows where age equals the computed minimum age and gender = 'male'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM people WHERE gender = 'male' ORDER BY age ASC LIMIT 1;",
            "SELECT name FROM Person WHERE gender = 'male' AND age = (SELECT MIN(age) FROM Person WHERE gender = 'male')"
        ],
        "rule_sql": [
            "SELECT name FROM Person WHERE gender = 'male' AND age = (SELECT MIN(age) FROM Person WHERE gender = 'male')"
        ]
    },
    "2197": {
        "db_id": "formula_1",
        "question": "Find the distinct driver id of all drivers that have a longer stop duration than some drivers in the race whose id is 841?",
        "ground_truth": "SELECT DISTINCT driverid ,  STOP FROM pitstops WHERE duration  >  (SELECT min(duration) FROM pitstops WHERE raceid  =  841)",
        "amends": [
            "Do select `driverid, STOP` instead of `driver_id` only. Do query from `pitstops` table instead of `stops` table. Do use filter `duration >` instead of `stop_duration >`. Do use subquery `SELECT min(duration)` instead of `SELECT stop_duration` to ensure proper comparison against the minimum value. Do filter subquery with `raceid = 841` instead of `race_id = 841`. Do remove `ORDER BY driver_id` instead of keeping it as the ordering is unnecessary for the result set. The amended query now correctly identifies drivers with pitstop durations exceeding the minimum duration for race 841, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"distinct driver id\": select the exact column \"driverid\" from the \"pitstops\" table. 2) When comparing stop durations: use the column \"duration\" instead of \"stop_duration\" for duration comparisons. 3) When filtering for race id 841: use the exact literal value 841 with the column \"raceid\" (not \"race_id\"). 4) When comparing against drivers in race 841: compare against the minimum duration value using \"min(duration)\" rather than individual durations. 5) When the question asks for drivers with longer durations than some drivers in race 841: use the condition \"duration > (SELECT min(duration) FROM pitstops WHERE raceid = 841)\" to ensure proper comparison against the minimum value. 6) When producing the final result: do not include unnecessary ordering since the question only requires distinct driver IDs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT driver_id FROM stops WHERE stop_duration > (SELECT stop_duration FROM stops WHERE race_id = 841) ORDER BY driver_id;",
            "SELECT DISTINCT driverId, stop FROM pitStops WHERE duration > (SELECT MIN(duration) FROM pitStops WHERE raceId = 841)"
        ],
        "rule_sql": [
            "SELECT DISTINCT driverId FROM pitStops WHERE duration > (SELECT MIN(duration) FROM pitStops WHERE raceId = 841)"
        ]
    },
    "6394": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "What are the statement ids, statement details, and account details, for all accounts?",
        "ground_truth": "SELECT T1.statement_id ,  T2.statement_details ,  T1.account_details FROM Accounts AS T1 JOIN Statements AS T2 ON T1.statement_id  =  T2.statement_id",
        "amends": [
            "Do specify table aliases `T1` and `T2` instead of omitting them. Do add the `Accounts` table with alias `T1` instead of omitting it. Do change the `FROM` clause to `Accounts AS T1 JOIN Statements AS T2` instead of just `FROM statements`. Do add the join condition `ON T1.statement_id = T2.statement_id` instead of omitting it. Do qualify columns with table aliases as `T1.statement_id`, `T2.statement_details`, and `T1.account_details` instead of unqualified column names. The amended query now correctly joins the Accounts and Statements tables to retrieve the appropriate data."
        ],
        "rules": [
            "1) When answering about \"statement ids, statement details, and account details for all accounts\": make sure the output order: T1.statement_id, T2.statement_details, T1.account_details. 2) When combining Accounts and Statements tables: link rows where T1.statement_id = T2.statement_id and keep only matching pairs (inner match). 3) When selecting columns from multiple tables: qualify each column with its table alias (T1 for Accounts, T2 for Statements)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT statement_id, statement_details, account_details FROM statements",
            "SELECT T1.statement_id, T2.statement_details, T1.account_details FROM Accounts AS T1 JOIN Statements AS T2 ON T1.statement_id = T2.statement_id"
        ],
        "rule_sql": [
            "SELECT T1.Statement_ID, T2.Statement_Details, T1.Account_Details \nFROM Accounts T1 \nINNER JOIN Statements T2 ON T1.Statement_ID = T2.Statement_ID"
        ]
    },
    "992": {
        "db_id": "university_basketball",
        "question": "Return the name of the team and the acc during the regular season for the school that was founded the earliest.",
        "ground_truth": "SELECT t2.team_name ,  t2.ACC_Regular_Season FROM university AS t1 JOIN basketball_match AS t2 ON t1.school_id  =  t2.school_id ORDER BY t1.founded LIMIT 1",
        "amends": [
            "Do select `t2.team_name` and `t2.ACC_Regular_Season` instead of `team_name`, `acc`, and `MIN(founded_year)`. Do join `university AS t1` with `basketball_match AS t2` on `t1.school_id = t2.school_id` instead of querying only `teams` table. Do remove the `WHERE season_type = 'regular'` filter and `GROUP BY team_name, acc` clause instead of keeping them. Do order by `t1.founded` instead of `founded_year`. Do remove the aggregate function `MIN()` instead of using it. The amended query now correctly retrieves the earliest founded university's basketball team information by joining the relevant tables directly."
        ],
        "rules": [
            "1) When answering about \"team name and acc during regular season for school founded earliest\": make sure the output order: t2.team_name, t2.ACC_Regular_Season. 2) When combining university and basketball_match tables: link rows where t1.school_id = t2.school_id and keep only matching pairs (inner match). 3) When the question asks for the school founded earliest: order by t1.founded in ascending direction and keep the first 1 row. 4) When handling text literals: do not add or remove filters like 'season_type = regular' when not specified in the question. 5) When computing aggregates: do not use MIN() or GROUP BY when the question asks for specific row values rather than grouped aggregates."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT team_name, acc, MIN(founded_year) FROM teams WHERE season_type = 'regular' GROUP BY team_name, acc ORDER BY founded_year LIMIT 1;",
            "SELECT t2.Team_Name, t2.ACC_Regular_Season \nFROM university AS t1 \nJOIN basketball_match AS t2 ON t1.School_ID = t2.School_ID \nORDER BY t1.Founded ASC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT t2.Team_Name, t2.ACC_Regular_Season \nFROM university t1 \nINNER JOIN basketball_match t2 ON t1.School_ID = t2.School_ID \nORDER BY t1.Founded ASC \nLIMIT 1"
        ]
    },
    "198": {
        "db_id": "bike_1",
        "question": "What are the ids of all trips that had a duration as long as the average trip duration in the zip code 94103?",
        "ground_truth": "SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  94103)",
        "amends": [
            "Do reference table `trip` instead of `trips` in both main query and subquery. Do use `>=` comparison instead of `=` equality operator for duration comparison. Do remove single quotes around `94103` numeric zip_code value instead of treating it as a string. Do use lowercase `avg` function instead of uppercase `AVG` aggregate function. The amended query now correctly identifies trips with duration greater than or equal to the average duration for zip code 94103, matching the RIGHT_SQL's behavior.",
            "Do remove the redundant `zip_code = 94103` filter from the outer WHERE clause instead of keeping it, since the subquery already filters for `zip_code = 94103` and the outer filter unnecessarily restricts the result set. Do maintain the subquery `avg(duration)` calculation with the `zip_code = 94103` filter instead of altering it, as this correctly computes the average duration for the specified zip code. The amended query now matches RIGHT_SQL's behavior by only filtering on duration comparison while preserving the correct subquery logic."
        ],
        "rules": [
            "1) When the question mentions \"trips\": use the exact table name \"trip\" instead of \"trips\" in both main query and subquery. 2) When comparing trip duration to average duration: use the >= operator instead of = to include trips with duration greater than or equal to the average. 3) When filtering by zip code 94103: use the numeric value 94103 without single quotes since zip_code is a numeric column. 4) When computing average duration: use the lowercase avg function instead of uppercase AVG aggregate function.",
            "1) When the question asks for trips with duration equal to the average duration in zip code 94103: use the exact literal value '94103' for zip code filtering. 2) When computing average duration for a specific zip code: calculate the average duration only for rows where zip_code equals '94103'. 3) When comparing trip durations to the average: use duration >= (average duration) to find trips with duration as long as or longer than the average. 4) When filtering results: do not apply redundant zip_code filters in the outer query when the subquery already filters for the same zip code value."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM trips WHERE duration = (SELECT AVG(duration) FROM trips WHERE zip_code = '94103')",
            "SELECT id FROM trip WHERE zip_code = 94103 AND duration >= (SELECT avg(duration) FROM trip WHERE zip_code = 94103)",
            "SELECT id FROM trip WHERE duration >= (SELECT avg(duration) FROM trip WHERE zip_code = 94103)"
        ],
        "rule_sql": [
            "SELECT id FROM trip WHERE duration >= (SELECT avg(duration) FROM trip WHERE zip_code = 94103) AND zip_code = 94103;"
        ]
    },
    "2850": {
        "db_id": "customer_deliveries",
        "question": "Find the names and phone numbers of customers living in California state.",
        "ground_truth": "SELECT t1.customer_name ,  t1.customer_phone FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  'California'",
        "amends": [
            "Do select `customer_name` and `customer_phone` instead of `name` and `phone`. Do add joins to `customer_addresses` and `addresses` instead of querying only the `customers` table. Do use `JOIN` with `t1.customer_id = t2.customer_id` and `t2.address_id = t3.address_id` instead of no joins. Do filter on `t3.state_province_county = 'California'` instead of `state = 'California'`. The amended query now correctly joins related tables to filter customers by their address state information."
        ],
        "rules": [
            "1) When the question asks for customer names and phone numbers: select \"customer_name\" and \"customer_phone\" from the Customers table. 2) When filtering customers by state: join Customers (T1) to customer_addresses (T2) using T1.customer_id = T2.customer_id, then join to addresses (T3) using T2.address_id = T3.address_id. 3) When looking for customers in California: filter on T3.state_province_county = 'California' exactly. 4) When combining tables for customer address information: perform inner joins using the exact key equalities shown to ensure only matching customer-address pairs are included."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, phone FROM customers WHERE state = 'California';",
            "SELECT c.customer_name, c.customer_phone\nFROM Customers c\nJOIN Customer_Addresses ca ON c.customer_id = ca.customer_id\nJOIN Addresses a ON ca.address_id = a.address_id\nWHERE a.state_province_county = 'California'"
        ],
        "rule_sql": [
            "SELECT c.customer_name, c.customer_phone\nFROM Customers c\nINNER JOIN Customer_Addresses ca ON c.customer_id = ca.customer_id\nINNER JOIN Addresses a ON ca.address_id = a.address_id\nWHERE a.state_province_county = 'California'"
        ]
    },
    "5318": {
        "db_id": "manufactory_1",
        "question": "Find the name of companies that do not make DVD drive.",
        "ground_truth": "SELECT name FROM manufacturers EXCEPT SELECT T2.name FROM products AS T1 JOIN manufacturers AS T2 ON T1.Manufacturer  =  T2.code WHERE T1.name  =  'DVD drive'",
        "amends": [
            "Do select `name` from the `manufacturers` table instead of `company_name` from `companies`. Do use an `EXCEPT` set operation instead of a simple `WHERE` filter. Do add a subquery that joins `products` with `manufacturers` on `Manufacturer = code` instead of omitting this relationship. Do filter for products where `name = 'DVD drive'` in the subquery instead of filtering manufacturers directly by `product_type`. Do remove the incorrect `product_type` filter condition instead of keeping it. The amended query now correctly identifies manufacturers who do not produce DVD drives by using set difference logic instead of the incorrect assumption about product_type column existence."
        ],
        "rules": [
            "1) When selecting company names: use \"name\" from the \"manufacturers\" table instead of \"company_name\" from \"companies\". 2) When finding companies that do not make a specific product: use an EXCEPT set operation to subtract manufacturers that make the product from all manufacturers. 3) When identifying manufacturers that make DVD drives: join \"products\" with \"manufacturers\" on \"Manufacturer = code\" and filter for products where \"name = 'DVD drive'\". 4) When handling the DVD drive product: use the exact literal 'DVD drive' with the specified case and spacing. 5) When combining tables for product-manufacturer relationships: link rows where \"products\".\"Manufacturer\" equals \"manufacturers\".\"code\" and keep only matching pairs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT company_name FROM companies WHERE product_type = 'DVD drive';",
            "SELECT Name FROM Manufacturers\nEXCEPT\nSELECT m.Name \nFROM Manufacturers m\nJOIN Products p ON m.Code = p.Manufacturer\nWHERE p.Name = 'DVD drive'"
        ],
        "rule_sql": [
            "SELECT name FROM Manufacturers\nEXCEPT\nSELECT m.name FROM Manufacturers m\nJOIN Products p ON m.Code = p.Manufacturer\nWHERE p.name = 'DVD drive'"
        ]
    },
    "5435": {
        "db_id": "shop_membership",
        "question": "What are the cities that do not have any branches with more than 100 members?",
        "ground_truth": "SELECT city FROM branch EXCEPT SELECT city FROM branch WHERE membership_amount  >  100",
        "amends": [
            "Do use `EXCEPT` set operation instead of a simple `WHERE` filter. Do reference table `branch` instead of `branches`. Do remove the `members > 100` condition from the main query instead of including it. Do add a second query `SELECT city FROM branch WHERE membership_amount > 100` for the EXCEPT operation instead of omitting it. Do use column `membership_amount` instead of `members` for the comparison. The amended query now correctly returns cities from all branches except those with membership amounts exceeding 100, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for cities that do not have any branches with a specific condition: use an EXCEPT set operation to exclude cities that have branches meeting the condition instead of filtering in the main query. 2) When referring to the branch table: use the exact table name \"branch\" instead of \"branches\". 3) When checking for membership size: use the exact column name \"membership_amount\" instead of \"members\" for the comparison. 4) When filtering for branches with more than 100 members: use the exact literal value 100 in the condition \"membership_amount > 100\" in the second query for the EXCEPT operation. 5) When constructing the EXCEPT operation: the first query should select all cities from the branch table, and the second query should select cities from branch table where membership_amount > 100."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city FROM branches WHERE members > 100;",
            "SELECT City FROM branch\nEXCEPT\nSELECT City FROM branch WHERE membership_amount > 100"
        ],
        "rule_sql": [
            "SELECT City FROM branch\nEXCEPT\nSELECT City FROM branch WHERE membership_amount > 100"
        ]
    },
    "6251": {
        "db_id": "ship_1",
        "question": "Return the flag that is most common among all ships.",
        "ground_truth": "SELECT flag FROM ship GROUP BY flag ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference table `ship` instead of `ships` in the FROM clause, as the correct table name is singular. The amended query now correctly references the intended table and matches the RIGHT_SQL's behavior.",
            "Do select only `flag` instead of both `Flag` and `COUNT(*) as count` in the SELECT list. Do remove the explicit column alias `count` instead of keeping it. Do move the aggregate function `count(*)` to the ORDER BY clause instead of including it in the SELECT list. Do use lowercase `flag` instead of uppercase `Flag` for column references. The amended query now correctly returns only the flag with the highest count while matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"most common flag among all ships\": make sure the output order: flag\n2) When the question mentions \"ships\": \"ships\" actually means \"ship in schema\"\n3) When the question asks for \"most common\" flag: count occurrences of each flag value using the exact token \"Flag\" from table \"ship\" and return the one with the highest count\n4) When counting occurrences: compute the number of rows for each distinct value of \"Flag\" column\n5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms\n6) When handling text literals: do not change case, spacing, or punctuation of flag values like 'Panama'",
            "1) When answering about \"most common flag among all ships\": make sure the output order: flag only without count column. 2) When counting ships by flag: use count(*) but do not include it in the output columns. 3) When ordering by frequency: use count(*) in descending order to find the most common. 4) When limiting to the most common: take only the first row after ordering by count descending. 5) When referencing the flag column: use lowercase \"flag\" exactly as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flag FROM ships GROUP BY flag ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT Flag, COUNT(*) as count FROM Ship GROUP BY Flag ORDER BY count DESC LIMIT 1;",
            "SELECT flag FROM ship GROUP BY flag ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT \"Flag\" FROM \"Ship\" GROUP BY \"Flag\" ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "4378": {
        "db_id": "tracking_grants_for_research",
        "question": "What is the last date of the staff leaving the projects?",
        "ground_truth": "SELECT date_to FROM Project_Staff ORDER BY date_to DESC LIMIT 1",
        "amends": [
            "Do select `date_to` instead of `MAX(end_date)` and use `ORDER BY date_to DESC LIMIT 1` instead of an aggregate function with a filter. Do query from `Project_Staff` table instead of `staff_projects` table. Do remove the `WHERE status = 'left'` filter instead of keeping it. The amended query now correctly retrieves the latest date_to value from the Project_Staff table without unnecessary filtering."
        ],
        "rules": [
            "1) When answering about \"last date of staff leaving projects\": use the exact column \"date_to\" from table \"Project_Staff\" instead of any other date column. 2) When finding the most recent date: order rows by \"date_to\" in descending order and take the first row. 3) When the question mentions \"staff leaving\": do not apply any status filter as the schema does not contain a status column for filtering. 4) When selecting from the database: use table \"Project_Staff\" as the source table, not \"staff_projects\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(end_date) FROM staff_projects WHERE status = 'left';",
            "SELECT date_to FROM Project_Staff ORDER BY date_to DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT date_to FROM Project_Staff ORDER BY date_to DESC LIMIT 1;"
        ]
    },
    "394": {
        "db_id": "flight_1",
        "question": "What is the average price for flights from LA to Honolulu?",
        "ground_truth": "SELECT avg(price) FROM Flight WHERE origin  =  \"Los Angeles\" AND destination  =  \"Honolulu\"",
        "amends": [
            "Do use table name `Flight` instead of `flights` to reference the correct database object. Do use string literals `\"Los Angeles\"` instead of `'LA'` for the origin filter to match the full city name instead of an abbreviated code. Do use lowercase `avg` instead of uppercase `AVG` for the aggregate function, though this is a cosmetic difference that doesn't affect functionality. The amended query now correctly calculates the average price for flights from Los Angeles to Honolulu by using the proper table reference and complete city names in the filter conditions."
        ],
        "rules": [
            "1) When referencing the flights table: use the exact table name \"Flight\" instead of \"flights\". 2) When filtering for origin city: use the exact string literal \"Los Angeles\" instead of abbreviated forms like 'LA'. 3) When filtering for destination city: use the exact string literal \"Honolulu\" as shown in the question. 4) When calculating average price: use the lowercase function name \"avg\" instead of uppercase \"AVG\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(price) FROM flights WHERE origin = 'LA' AND destination = 'Honolulu';",
            "SELECT avg(price) FROM flight WHERE origin = 'Los Angeles' AND destination = 'Honolulu';"
        ],
        "rule_sql": [
            "SELECT avg(price) FROM Flight WHERE origin = 'Los Angeles' AND destination = 'Honolulu';"
        ]
    },
    "3997": {
        "db_id": "hospital_1",
        "question": "What are the distinct names of nurses on call?",
        "ground_truth": "SELECT DISTINCT T1.name FROM nurse AS T1 JOIN on_call AS T2 ON T1.EmployeeID  =  T2.nurse",
        "amends": [
            "Do use `DISTINCT T1.name` instead of just `name` to eliminate duplicate nurse names. Do join `nurse AS T1` with `on_call AS T2` instead of querying only the `nurses` table. Do specify the join condition `ON T1.EmployeeID = T2.nurse` instead of using a simple `WHERE on_call = 'yes'` filter. Do reference the properly aliased table `nurse AS T1` instead of the incorrectly named `nurses` table. The amended query now correctly identifies distinct nurses who are on call by joining the nurse table with the on_call relationship table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"distinct names of nurses\": use DISTINCT T1.name to eliminate duplicate nurse names. 2) When combining information about nurses and on-call status: join nurse AS T1 with on_call AS T2 using the condition T1.EmployeeID = T2.nurse to match nurses with their on-call status. 3) When identifying nurses who are on call: reference the on_call table T2 instead of filtering a single table, as the on-call status is stored in a separate relationship table. 4) When referring to the nurse table: use the exact table name nurse AS T1 instead of the incorrect nurses table name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM nurses WHERE on_call = 'yes';",
            "SELECT DISTINCT T1.Name FROM Nurse AS T1 JOIN On_Call AS T2 ON T1.EmployeeID = T2.Nurse;"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Name FROM nurse AS T1 JOIN on_call AS T2 ON T1.EmployeeID = T2.Nurse;"
        ]
    },
    "5027": {
        "db_id": "soccer_2",
        "question": "What are the names of all schools that have students trying out for the position of goal and 'mid'-field.",
        "ground_truth": "SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid'",
        "amends": [
            "Do select `cName` from a single `tryout` table instead of selecting `school_name` from multiple joined tables. Do use `INTERSECT` to find common names instead of using `OR` conditions in a `WHERE` clause. Do filter for `pPos = 'goalie'` and `pPos = 'mid'` in separate queries instead of filtering for `position = 'goal'` or `position = 'mid-field'` in a single query. Do remove all table joins with `schools` and `students` instead of including them. The amended query now correctly finds names that appear in both position categories using set intersection logic."
        ],
        "rules": [
            "1) When answering about school names from tryout data: select \"cName\" from the \"Tryout\" table instead of joining multiple tables. 2) When the question mentions students trying out for positions 'goal' and 'mid'-field: use INTERSECT to find common names that appear in both position categories instead of using OR conditions. 3) When filtering for position 'goal': use the exact literal 'goalie' for the \"pPos\" column. 4) When filtering for position 'mid'-field: use the exact literal 'mid' for the \"pPos\" column. 5) When combining position requirements: remove all table joins with \"schools\" and \"students\" tables and work directly with the \"Tryout\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT school_name FROM schools s JOIN students st ON s.school_id = st.school_id JOIN tryouts t ON st.student_id = t.student_id WHERE t.position = 'goal' OR t.position = 'mid-field';",
            "SELECT cName FROM Tryout WHERE pPos = 'goalie' INTERSECT SELECT cName FROM Tryout WHERE pPos = 'mid';"
        ],
        "rule_sql": [
            "SELECT cName FROM Tryout WHERE pPos = 'goalie' INTERSECT SELECT cName FROM Tryout WHERE pPos = 'mid';"
        ]
    },
    "3902": {
        "db_id": "hospital_1",
        "question": "what is the name and position of the head whose department has least number of employees?",
        "ground_truth": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of implicit table references. Do join `department AS T1` with `physician AS T2` on `T1.head = T2.EmployeeID` instead of querying a single `heads` table. Do select from the joined tables instead of the standalone `heads` table. Do group by `departmentID` instead of ordering by a correlated subquery. Do order by `count(departmentID)` instead of ordering by `(SELECT COUNT(*) FROM employees WHERE department_id = heads.department_id)`. Do remove the correlated subquery entirely instead of using it for ordering. The amended query now correctly joins department and physician tables to find department heads and orders by department count, matching the RIGHT_SQL's behavior.",
            "Do remove the `JOIN Affiliated_With AS T3` table and its associated join condition `T1.DepartmentID = T3.Department` instead of including it. Do remove the `WHERE T3.PrimaryAffiliation = 1` filter instead of keeping it. Do change the `GROUP BY` clause to use `departmentID` instead of `T1.DepartmentID`. Do change the `ORDER BY` clause to use `count(departmentID)` instead of `COUNT(T3.Physician)`. The amended query now correctly retrieves department heads without unnecessary joins and filters, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"name and position of the head whose department has least number of employees\": make sure the output order: name, position. 2) When combining department and physician tables: link rows where T1.head = T2.EmployeeID exactly as shown and keep only matching pairs (inner match). 3) When the question asks for \"least number of employees\" per department: organize results by departmentID and compute count of departmentID per group, then order by count(departmentID) in ascending direction and keep the first 1 row. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 5) When handling text literals: do not change case, spacing, or punctuation.",
            "1) When answering about \"department heads with least number of employees\": make sure the output order: T2.Name, T2.Position\n2) When combining Department as T1 and Physician as T2: link rows where T1.Head = T2.EmployeeID and keep only matching pairs (inner match)\n3) When the question asks for \"least number of employees\" per department: organize results by departmentID and compute count of departmentID per group\n4) When the question asks for the department with minimum employee count: rank rows by count(departmentID) in ascending order and keep the first 1 row\n5) When handling department identifiers: use departmentID as the grouping and counting key instead of joining with additional tables"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, position FROM heads ORDER BY (SELECT COUNT(*) FROM employees WHERE department_id = heads.department_id) LIMIT 1;",
            "SELECT T2.Name, T2.Position\nFROM Department AS T1\nJOIN Physician AS T2 ON T1.Head = T2.EmployeeID\nJOIN Affiliated_With AS T3 ON T1.DepartmentID = T3.Department\nWHERE T3.PrimaryAffiliation = 1\nGROUP BY T1.DepartmentID\nORDER BY COUNT(T3.Physician) ASC\nLIMIT 1;",
            "SELECT T2.Name, T2.Position\nFROM Department AS T1\nJOIN Physician AS T2 ON T1.Head = T2.EmployeeID\nGROUP BY T1.DepartmentID\nORDER BY COUNT(T1.DepartmentID) ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Name, T2.Position\nFROM Department AS T1\nINNER JOIN Physician AS T2 ON T1.Head = T2.EmployeeID\nGROUP BY T1.DepartmentID\nORDER BY COUNT(T1.DepartmentID) ASC\nLIMIT 1"
        ]
    },
    "4134": {
        "db_id": "film_rank",
        "question": "What is the average number of cities of markets with low film market estimate bigger than 10000?",
        "ground_truth": "SELECT avg(T2.Number_cities) FROM film_market_estimation AS T1 JOIN market AS T2 ON T1.Market_ID  =  T2.Market_ID WHERE T1.Low_Estimate  >  10000",
        "amends": [
            "Do use `avg(T2.Number_cities)` instead of `AVG(city_count)` for the aggregate function and column reference. Do join `film_market_estimation AS T1` with `market AS T2` on `T1.Market_ID = T2.Market_ID` instead of querying only the `markets` table. Do filter on `T1.Low_Estimate > 10000` instead of `market_estimate = 'low' AND film_market_estimate > 10000` for the WHERE condition. Do remove the incorrect market_estimate filter condition instead of including it. The amended query now correctly calculates the average number of cities for markets where the low estimate exceeds 10000, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about average number of cities for markets with low film market estimate bigger than 10000: use avg(T2.Number_cities) as the aggregate function and column reference. 2) When combining film_market_estimation and market tables: join T1 (film_market_estimation) with T2 (market) on T1.Market_ID = T2.Market_ID using inner match. 3) When filtering for low estimate bigger than 10000: apply condition T1.Low_Estimate > 10000. 4) When the question mentions \"low film market estimate\": this refers specifically to T1.Low_Estimate column, not market_estimate = 'low'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(city_count) FROM markets WHERE market_estimate = 'low' AND film_market_estimate > 10000;",
            "SELECT AVG(T2.Number_cities) \nFROM film_market_estimation AS T1\nJOIN market AS T2 ON T1.Market_ID = T2.Market_ID\nWHERE T1.Low_Estimate > 10000"
        ],
        "rule_sql": [
            "SELECT AVG(T2.Number_cities) \nFROM film_market_estimation T1\nINNER JOIN market T2 ON T1.Market_ID = T2.Market_ID\nWHERE T1.Low_Estimate > 10000"
        ]
    },
    "2059": {
        "db_id": "party_people",
        "question": "What is the name of party with most number of members?",
        "ground_truth": "SELECT T2.party_name FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `Member` and `party` tables with `JOIN` on `T1.party_id = T2.party_id` instead of querying `parties` table directly without proper joins. Do add proper table aliases `T1` and `T2` instead of omitting them. Do group by `T1.party_id` instead of attempting to aggregate without grouping. Do use `count(*)` in the ORDER BY clause instead of `COUNT(member_id)` which references an unjoined table. Do select `T2.party_name` from the joined party table instead of selecting `party_name` directly from what appears to be an unjoined parties table. The amended query now correctly joins the member and party tables, groups by party_id to count members per party, and returns the party name with the highest member count, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"party with most number of members\": make sure to join Member table as T1 and party table as T2 using T1.party_id = T2.party_id. 2) When counting members per party: group by T1.party_id and use count(*) to count members. 3) When selecting the party name: select T2.party_name from the joined party table. 4) When finding the party with the highest member count: order by the member count in descending order and keep only the top result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT party_name FROM parties ORDER BY COUNT(member_id) DESC LIMIT 1;",
            "SELECT T2.party_name\nFROM member T1\nJOIN party T2 ON T1.Party_ID = T2.Party_ID\nGROUP BY T1.Party_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.Party_name\nFROM member AS T1\nJOIN party AS T2 ON T1.Party_ID = T2.Party_ID\nGROUP BY T1.Party_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "1531": {
        "db_id": "insurance_and_eClaims",
        "question": "Find the names of the customers who have an deputy policy.",
        "ground_truth": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  \"Deputy\"",
        "amends": [
            "Do use `DISTINCT t2.customer_details` instead of `name` in the SELECT list. Do add `policies AS t1` and `customers AS t2` as joined tables instead of querying only the customers table. Do use `JOIN` with `ON t1.customer_id = t2.customer_id` instead of no join condition. Do filter on `t1.policy_type_code = \"Deputy\"` instead of `policy_type = 'deputy'` to reference the correct table and column with proper case sensitivity and quotes. The amended query now correctly joins tables and filters on the policy type code to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"customers who have a deputy policy\": make sure the output order: t2.customer_details. 2) When the question mentions \"customers\": use table \"customers AS t2\" with exact alias t2. 3) When the question mentions \"deputy policy\": filter on t1.policy_type_code = \"Deputy\" with exact literal \"Deputy\" and double quotes. 4) When combining policies and customers tables: link rows where t1.customer_id = t2.customer_id and keep only matching pairs (inner match). 5) When selecting customer names: use t2.customer_details instead of name and include DISTINCT to remove duplicates."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM customers WHERE policy_type = 'deputy';",
            "SELECT DISTINCT t2.Customer_Details\nFROM Policies AS t1\nJOIN Customers AS t2 ON t1.Customer_ID = t2.Customer_ID\nWHERE t1.Policy_Type_Code = 'Deputy'"
        ],
        "rule_sql": [
            "SELECT DISTINCT t2.customer_details FROM Policies AS t1 INNER JOIN Customers AS t2 ON t1.customer_id = t2.customer_id WHERE t1.policy_type_code = \"Deputy\" ORDER BY t2.customer_details"
        ]
    },
    "4961": {
        "db_id": "soccer_2",
        "question": "What are the different types of player positions?",
        "ground_truth": "SELECT count(DISTINCT pPos) FROM tryout",
        "amends": [
            "Do use `count(DISTINCT pPos)` instead of `SELECT DISTINCT position` to count distinct values rather than listing them. Do query from `tryout` table instead of `players` table to use the correct data source. Do remove the `WHERE position IS NOT NULL` filter instead of keeping it since the count function inherently handles null values. Do remove the `ORDER BY position` clause instead of including it as ordering is unnecessary for an aggregate count. The amended query now correctly counts distinct non-null pPos values from the tryout table, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When counting distinct values of player positions: use count(DISTINCT \"pPos\") instead of listing distinct values. 2) When the question asks about player positions: use the \"tryout\" table instead of the \"players\" table as the correct data source. 3) When counting distinct values: do not include explicit null filtering since the count function inherently handles null values. 4) When performing aggregate counting: do not include ordering clauses as they are unnecessary for aggregate results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT position FROM players WHERE position IS NOT NULL ORDER BY position;",
            "SELECT COUNT(DISTINCT pPos) FROM Tryout"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT pPos) FROM Tryout;"
        ]
    },
    "387": {
        "db_id": "flight_1",
        "question": "Show origins of all flights with destination Honolulu.",
        "ground_truth": "SELECT origin FROM Flight WHERE destination  =  \"Honolulu\"",
        "amends": [
            "Do select `origin` instead of `destination` in the SELECT list. Do reference table `Flight` instead of `flights` in the FROM clause. Do filter on `destination = 'Honolulu'` instead of `origin = 'Honolulu'` in the WHERE clause. The amended query now correctly retrieves the origin airports for flights destined to Honolulu rather than incorrectly showing destinations for flights originating from Honolulu."
        ],
        "rules": [
            "1) When the question asks to show origins of flights: select the \"origin\" column from the \"Flight\" table. 2) When the question specifies flights with destination Honolulu: filter rows where the \"destination\" column equals exactly 'Honolulu'. 3) When choosing identifier delimiters: use double quotes for column names like \"origin\" and \"destination\" as shown in the schema. 4) When handling text literals: preserve the exact case and spelling 'Honolulu' as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT destination FROM flights WHERE origin = 'Honolulu';",
            "SELECT origin FROM flight WHERE destination = 'Honolulu';"
        ],
        "rule_sql": [
            "SELECT \"origin\" FROM \"flight\" WHERE \"destination\" = 'Honolulu';"
        ]
    },
    "89": {
        "db_id": "student_assessment",
        "question": "What is the id of the student who most recently registered course 301?",
        "ground_truth": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1",
        "amends": [
            "Do query the `student_course_attendance` table instead of the `registrations` table. Do use the `date_of_attendance` column for ordering instead of `registration_date`. The amended query now correctly retrieves attendance data from the appropriate table with the correct date column for sorting."
        ],
        "rules": [
            "1) When answering about \"the student who most recently registered course 301\": make sure the output order: student_id. 2) When the question mentions \"registered course\": \"registered course\" actually means \"attendance data in Student_Course_Attendance table\". 3) When the question asks for \"most recently\": rank rows by date_of_attendance in descending order and keep the first 1 row. 4) When filtering for course 301: use the exact literal value 301 for course_id filtering. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id FROM registrations WHERE course_id = 301 ORDER BY registration_date DESC LIMIT 1;",
            "SELECT student_id FROM Student_Course_Attendance WHERE course_id = '301' ORDER BY date_of_attendance DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT student_id FROM Student_Course_Attendance WHERE course_id = '301' ORDER BY date_of_attendance DESC LIMIT 1"
        ]
    },
    "837": {
        "db_id": "chinook_1",
        "question": "What is the least common media type in all tracks?",
        "ground_truth": "SELECT T1.Name FROM MEDIATYPE AS T1 JOIN TRACK AS T2 ON T1.MediaTypeId  =  T2.MediaTypeId GROUP BY T2.MediaTypeId ORDER BY COUNT(*) ASC LIMIT 1",
        "amends": [
            "Do select `T1.Name` instead of `MediaTypeId, COUNT(*) as count`. Do use `FROM MEDIATYPE AS T1 JOIN TRACK AS T2` instead of `FROM tracks`. Do add join condition `ON T1.MediaTypeId = T2.MediaTypeId` instead of omitting it. Do group by `T2.MediaTypeId` instead of `MediaTypeId`. Do order by `COUNT(*) ASC` instead of `count DESC`. The amended query now correctly retrieves the media type name with the lowest track count instead of just the media type ID with the highest count."
        ],
        "rules": [
            "1) When answering about \"least common media type in all tracks\": make sure the output order: T1.Name. 2) When combining T1 (MediaType) and T2 (Track) for shared entities: link rows where T1.MediaTypeId = T2.MediaTypeId; keep only matching pairs (inner match). 3) When the question asks for \"least common\" media type: organize results by T2.MediaTypeId and compute count of tracks per group, then rank rows by count in ascending order and keep the first 1 row. 4) When counting tracks: compute the number of rows using the canonical key T2.MediaTypeId. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MediaTypeId, COUNT(*) as count FROM tracks GROUP BY MediaTypeId ORDER BY count DESC LIMIT 1;",
            "SELECT T1.Name \nFROM MediaType AS T1 \nJOIN Track AS T2 ON T1.MediaTypeId = T2.MediaTypeId \nGROUP BY T2.MediaTypeId \nORDER BY COUNT(*) ASC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Name\nFROM MediaType T1\nINNER JOIN Track T2 ON T1.MediaTypeId = T2.MediaTypeId\nGROUP BY T2.MediaTypeId\nORDER BY COUNT(T2.MediaTypeId) ASC\nLIMIT 1"
        ]
    },
    "3580": {
        "db_id": "music_1",
        "question": "What are the names of all songs that are ordered by their resolution numbers?",
        "ground_truth": "SELECT song_name FROM song ORDER BY resolution",
        "amends": [
            "Do reference column `song_name` instead of `name` and table `song` instead of `songs`. Do order by column `resolution` instead of `resolution_number`. The amended query now correctly references the intended schema elements and matches the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for song names: use the exact column token \"song_name\" from table \"song\" instead of \"name\" from \"songs\". 2) When ordering songs by their resolution numbers: use the exact column token \"resolution\" from table \"song\" instead of \"resolution_number\". 3) When answering about song names ordered by resolution: make sure the output order is \"song_name\" followed by ordering on \"resolution\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM songs ORDER BY resolution_number;",
            "SELECT song_name FROM song ORDER BY resolution;"
        ],
        "rule_sql": [
            "SELECT song_name FROM song ORDER BY resolution, song_name;"
        ]
    },
    "5292": {
        "db_id": "manufactory_1",
        "question": "What is the total revenue of all companies whose main office is at Tokyo or Taiwan?",
        "ground_truth": "SELECT sum(revenue) FROM manufacturers WHERE Headquarter  =  'Tokyo' OR Headquarter  =  'Taiwan'",
        "amends": [
            "Do query the `manufacturers` table instead of the `companies` table. Do use the `Headquarter` column instead of the `main_office` column for filtering. Do maintain the same aggregation with `sum(revenue)` and the same filter condition checking for 'Tokyo' or 'Taiwan' values. The amended query now correctly accesses the manufacturers data using the appropriate headquarters column name."
        ],
        "rules": [
            "1) When answering about \"total revenue of all companies whose main office is at Tokyo or Taiwan\": query the \"manufacturers\" table instead of the \"companies\" table. 2) When filtering by main office location: use the \"Headquarter\" column instead of the \"main_office\" column. 3) When checking for Tokyo or Taiwan headquarters: filter for exact values 'Tokyo' or 'Taiwan' in the \"Headquarter\" column. 4) When computing total revenue: use sum(revenue) aggregation to calculate the sum of revenue values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(revenue) FROM companies WHERE main_office = 'Tokyo' OR main_office = 'Taiwan';",
            "SELECT SUM(Revenue) FROM Manufacturers WHERE Headquarter = 'Tokyo' OR Headquarter = 'Taiwan';"
        ],
        "rule_sql": [
            "SELECT SUM(Revenue) FROM Manufacturers WHERE Headquarter = 'Tokyo' OR Headquarter = 'Taiwan';"
        ]
    },
    "4181": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "How many locations are listed in the database?",
        "ground_truth": "SELECT count(*) FROM Ref_locations",
        "amends": [
            "Do reference the `Ref_locations` table instead of the `locations` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)`. Do remove the `WHERE id IS NOT NULL` filter instead of keeping it, as counting all rows in the reference table is the intended behavior. The amended query now correctly counts all records in the Ref_locations table without unnecessary filtering."
        ],
        "rules": [
            "1) When counting locations in the database: use the \"Ref_locations\" table instead of \"locations\" table. 2) When counting all records: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\". 3) When counting all rows in a reference table: do not apply any WHERE filter conditions like \"id IS NOT NULL\" as counting all rows is the intended behavior."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM locations WHERE id IS NOT NULL;",
            "SELECT count(*) FROM Ref_Locations"
        ],
        "rule_sql": [
            "select count(*) from Ref_Locations"
        ]
    },
    "3284": {
        "db_id": "college_1",
        "question": "What are the course codes for every class that the student with the last name Smithson took?",
        "ground_truth": "SELECT T1.crs_code FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T3.stu_num  =  T2.stu_num WHERE T3.stu_lname  =  'Smithson'",
        "amends": [
            "Do select `T1.crs_code` instead of `course_code` and use table aliases throughout. Do join `CLASS AS T1` and `enroll AS T2` on `T1.class_code = T2.class_code` instead of joining `students` and `enrollments` directly. Do add a second join to `student AS T3` on `T3.stu_num = T2.stu_num` instead of omitting this table. Do filter on `T3.stu_lname = 'Smithson'` instead of `last_name = 'Smithson'` to reference the correct column from the proper table. The amended query now correctly joins through the enrollment bridge table to find courses taken by students with the specified last name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about course codes for classes taken by a student with last name Smithson: make sure the output order is T1.crs_code. 2) When the question mentions \"course codes\": \"course codes\" actually means T1.crs_code in schema. 3) When the question mentions \"last name Smithson\": use exact literal 'Smithson' and match it to T3.stu_lname. 4) When combining CLASS as T1 and enroll as T2: link rows where T1.class_code = T2.class_code exactly and keep only matching pairs (inner match). 5) When combining enroll as T2 and student as T3: link rows where T3.stu_num = T2.stu_num exactly and keep only matching pairs (inner match). 6) When filtering for student last name: use T3.stu_lname = 'Smithson' with exact case and spacing."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_code FROM students JOIN enrollments ON students.student_id = enrollments.student_id WHERE last_name = 'Smithson'",
            "SELECT T1.CRS_CODE\nFROM CLASS AS T1\nJOIN ENROLL AS T2 ON T1.CLASS_CODE = T2.CLASS_CODE\nJOIN STUDENT AS T3 ON T3.STU_NUM = T2.STU_NUM\nWHERE T3.STU_LNAME = 'Smithson'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.CRS_CODE\nFROM CLASS AS T1\nINNER JOIN ENROLL AS T2 ON T1.CLASS_CODE = T2.CLASS_CODE\nINNER JOIN STUDENT AS T3 ON T3.STU_NUM = T2.STU_NUM\nWHERE T3.STU_LNAME = 'Smithson'\nORDER BY T1.CRS_CODE;"
        ]
    },
    "2227": {
        "db_id": "formula_1",
        "question": "Find the id, forename and number of races of all drivers who have at least participated in two races?",
        "ground_truth": "SELECT T1.driverid ,  T1.forename ,  count(*) FROM drivers AS T1 JOIN results AS T2 ON T1.driverid = T2.driverid JOIN races AS T3 ON T2.raceid = T3.raceid GROUP BY T1.driverid HAVING count(*)  >=  2",
        "amends": [
            "Do join `drivers AS T1` with `results AS T2` on `T1.driverid = T2.driverid` and then with `races AS T3` on `T2.raceid = T3.raceid` instead of querying only the `drivers` table without any joins. Do select `T1.driverid` and `T1.forename` instead of `id` and `forename` without table qualification. Do use `count(*)` instead of `COUNT(race_id)` to count all result rows. Do group by only `T1.driverid` instead of grouping by both `id` and `forename`. Do keep the `HAVING count(*) >= 2` condition instead of `HAVING num_races >= 2` with the alias. The amended query now correctly counts race participations through the results table and properly groups by driver identifier only."
        ],
        "rules": [
            "1) When answering about driver race participations: combine drivers table as T1 with results table as T2 using T1.driverid = T2.driverid, then combine with races table as T3 using T2.raceid = T3.raceid instead of querying only the drivers table. 2) When selecting driver information: use T1.driverid and T1.forename instead of unqualified id and forename. 3) When counting race participations: use count(*) to count all result rows instead of COUNT(race_id). 4) When grouping by driver: group by only T1.driverid instead of grouping by both id and forename. 5) When filtering for drivers with at least two races: keep the condition HAVING count(*) >= 2 instead of using an alias."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, forename, COUNT(race_id) as num_races FROM drivers GROUP BY id, forename HAVING num_races >= 2",
            "SELECT T1.driverId, T1.forename, COUNT(*) AS num_races\nFROM drivers AS T1\nJOIN results AS T2 ON T1.driverId = T2.driverId\nJOIN races AS T3 ON T2.raceId = T3.raceId\nGROUP BY T1.driverId\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T1.driverId, T1.forename, COUNT(*) AS number_of_races\nFROM drivers AS T1\nJOIN results AS T2 ON T1.driverId = T2.driverId\nJOIN races AS T3 ON T2.raceId = T3.raceId\nGROUP BY T1.driverId\nHAVING COUNT(*) >= 2"
        ]
    },
    "5518": {
        "db_id": "products_gen_characteristics",
        "question": "How many colors are there?",
        "ground_truth": "SELECT count(*) FROM ref_colors",
        "amends": [
            "Do reference table `ref_colors` instead of `colors` to ensure the query accesses the correct data source. The amended query now correctly counts records from the appropriate reference table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about colors: use the table \"ref_colors\" instead of \"colors\" to access the correct data source. 2) When counting colors: count all records from the \"ref_colors\" table to get the total number of colors."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM colors;",
            "SELECT COUNT(*) FROM Ref_Colors;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Ref_Colors;"
        ]
    },
    "1472": {
        "db_id": "college_2",
        "question": "Find the names of all instructors whose name includes the substring \u201cdar\u201d.",
        "ground_truth": "SELECT name FROM instructor WHERE name LIKE '%dar%'",
        "amends": [
            "Do reference table `instructor` instead of `instructors` while keeping the same `SELECT name` clause and `WHERE name LIKE '%dar%'` filter unchanged. The amended query now correctly queries the intended table while maintaining the same search logic and result behavior."
        ],
        "rules": [
            "1) When the question asks for instructors: use the exact table name \"instructor\" instead of \"instructors\". 2) When searching for names containing \"dar\": apply the exact filter pattern '%dar%' to the \"name\" column. 3) When selecting instructor names: output the \"name\" column from the \"instructor\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM instructors WHERE name LIKE '%dar%';",
            "SELECT name FROM instructor WHERE name LIKE '%dar%'"
        ],
        "rule_sql": [
            "SELECT name FROM instructor WHERE name LIKE '%dar%'"
        ]
    },
    "2090": {
        "db_id": "pilot_record",
        "question": "Show the most common nationality of pilots.",
        "ground_truth": "SELECT Nationality FROM pilot GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do reference table `pilot` instead of `pilots` and column `Nationality` instead of `nationality` to match the correct schema. Do use `ORDER BY COUNT(*) DESC` instead of `ORDER BY count ASC` to find the most common nationality rather than the least common. Do select only `Nationality` instead of both `nationality` and `COUNT(*) as count` since the count is only needed for ordering. The amended query now correctly identifies the most frequent nationality by counting occurrences in descending order."
        ],
        "rules": [
            "1) When the question asks about \"pilots\": use table \"pilot\" instead of \"pilots\" to match the schema. 2) When the question mentions \"nationality\": use column \"Nationality\" from table \"pilot\" with exact case and spelling. 3) When the question asks for \"most common nationality\": order by count in descending order (DESC) rather than ascending (ASC). 4) When the question asks to \"show the most common nationality\": select only the \"Nationality\" column since the count is only needed for ordering purposes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT nationality, COUNT(*) as count FROM pilots GROUP BY nationality ORDER BY count ASC LIMIT 1;",
            "SELECT Nationality FROM pilot GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Nationality FROM pilot GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "584": {
        "db_id": "store_1",
        "question": "What is the title of the album that was released by the artist whose name has the phrase 'Led'?",
        "ground_truth": "SELECT T2.title FROM artists AS T1 JOIN albums AS T2 ON T1.id  =  T2.artist_id WHERE T1.name LIKE '%Led%'",
        "amends": [
            "Do use explicit join syntax with `artists AS T1 JOIN albums AS T2` instead of querying only the `albums` table. Do specify the join condition `ON T1.id = T2.artist_id` instead of missing the relationship between tables. Do reference the artist name from the correct table as `T1.name` instead of using `artist_name` which may not exist. Do select the title from the joined table as `T2.title` instead of just `title` without table qualification. The amended query now properly joins the artists and albums tables to find album titles by artist name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about album titles by artist name: make sure to join tables artists as T1 and albums as T2 using the condition T1.id = T2.artist_id. 2) When the question mentions \"artist whose name has the phrase 'Led'\": use T1.name LIKE '%Led%' to filter artists. 3) When selecting the album title: use T2.title as the output column. 4) When combining artists and albums tables: perform an inner join where T1.id equals T2.artist_id to keep only matching artist-album pairs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM albums WHERE artist_name LIKE '%Led%';",
            "SELECT T2.title FROM artists AS T1 JOIN albums AS T2 ON T1.id = T2.artist_id WHERE T1.name LIKE '%Led%'"
        ],
        "rule_sql": [
            "SELECT T2.title \nFROM artists AS T1 \nINNER JOIN albums AS T2 ON T1.id = T2.artist_id \nWHERE T1.name LIKE '%Led%'"
        ]
    },
    "3047": {
        "db_id": "loan_1",
        "question": "What is the name of the bank branch with the greatest number of customers?",
        "ground_truth": "SELECT bname FROM bank ORDER BY no_of_customers DESC LIMIT 1",
        "amends": [
            "Do use table alias `bank` instead of `bank_branches` and select column `bname` instead of `branch_name`. Do order by `no_of_customers` instead of `customer_count` while maintaining the same DESC ordering and LIMIT 1 clause. The amended query now correctly references the intended table structure and column names to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"bank branch with the greatest number of customers\": make sure the output order: bank.bname 2) When the question mentions \"bank branch name\": \"bank branch name\" actually means \"bname in schema\" 3) When the question mentions \"greatest number of customers\" or \"greatest\": rank rows by no_of_customers in descending order and keep the first 1 row. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms - use exact column names as shown in schema (bname, no_of_customers). 5) When referring to table roles: do not rename or swap the alias \"bank\" once set for this schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT branch_name FROM bank_branches ORDER BY customer_count DESC LIMIT 1;",
            "SELECT bname FROM bank ORDER BY no_of_customers DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT bname FROM bank ORDER BY no_of_customers DESC LIMIT 1"
        ]
    },
    "813": {
        "db_id": "chinook_1",
        "question": "What are the first names and last names of the employees who live in Calgary city.",
        "ground_truth": "SELECT FirstName ,  LastName FROM EMPLOYEE WHERE City  =  \"Calgary\"",
        "amends": [
            "Do use `FirstName` and `LastName` column names instead of `first_name` and `last_name`. Do reference the `EMPLOYEE` table instead of `employees`. Do use double quotes `\"Calgary\"` for the string literal instead of single quotes `'Calgary'`. The amended query now correctly matches the RIGHT_SQL's behavior with proper column and table naming conventions."
        ],
        "rules": [
            "1) When the question asks for first names and last names: use the exact column names \"FirstName\" and \"LastName\" from the \"Employee\" table. 2) When the question mentions employees: reference the \"Employee\" table instead of \"employees\". 3) When filtering for city equal to Calgary: use the exact string literal \"Calgary\" with double quotes instead of single quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM employees WHERE city = 'Calgary';",
            "SELECT FirstName, LastName FROM Employee WHERE City = \"Calgary\";"
        ],
        "rule_sql": [
            "SELECT FirstName, LastName FROM Employee WHERE City = \"Calgary\""
        ]
    },
    "6941": {
        "db_id": "tracking_orders",
        "question": "List the names of the customers who have once bought product \"food\".",
        "ground_truth": "SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 JOIN order_items AS T3 JOIN products AS T4 ON T1.customer_id = T2.customer_id AND T2.order_id = T3.order_id AND T3.product_id = T4.product_id WHERE T4.product_name = \"food\" GROUP BY T1.customer_id HAVING count(*)  >=  1",
        "amends": [
            "Do select `T1.customer_name` instead of `name` and add table aliases. Do add joins on `customers AS T1`, `orders AS T2`, `order_items AS T3`, and `products AS T4` with conditions `T1.customer_id = T2.customer_id`, `T2.order_id = T3.order_id`, and `T3.product_id = T4.product_id` instead of querying only the customers table. Do filter on `T4.product_name = \"food\"` instead of `product = 'food'` to reference the correct table and column. Do add `GROUP BY T1.customer_id` and `HAVING count(*) >= 1` instead of omitting aggregation to ensure only customers with matching orders are returned. The amended query now correctly joins related tables and filters on product names from the products table instead of incorrectly assuming the customers table contains product information."
        ],
        "rules": [
            "1) When answering about \"customers who have once bought product 'food'\": make sure the output order: T1.customer_name. 2) When the question mentions \"customers\": use table \"customers AS T1\" with exact alias T1. 3) When the question mentions \"bought product 'food'\": join tables orders AS T2, order_items AS T3, and products AS T4 with exact join conditions T1.customer_id = T2.customer_id, T2.order_id = T3.order_id, and T3.product_id = T4.product_id. 4) When filtering for product \"food\": use exact literal \"food\" with column T4.product_name. 5) When ensuring customers have \"once bought\" the product: group by T1.customer_id and require at least one matching order with count(*) >= 1. 6) When combining tables for shared entities: perform inner matches using the exact key equalities shown in the join conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM customers WHERE product = 'food';",
            "SELECT T1.customer_name\nFROM Customers AS T1\nJOIN Orders AS T2 ON T1.customer_id = T2.customer_id\nJOIN Order_Items AS T3 ON T2.order_id = T3.order_id\nJOIN Products AS T4 ON T3.product_id = T4.product_id\nWHERE T4.product_name = 'food'\nGROUP BY T1.customer_id\nHAVING COUNT(*) >= 1"
        ],
        "rule_sql": [
            "SELECT T1.customer_name\nFROM customers AS T1\nINNER JOIN orders AS T2 ON T1.customer_id = T2.customer_id\nINNER JOIN order_items AS T3 ON T2.order_id = T3.order_id\nINNER JOIN products AS T4 ON T3.product_id = T4.product_id\nWHERE T4.product_name = 'food'\nGROUP BY T1.customer_id\nHAVING COUNT(*) >= 1\nORDER BY T1.customer_name"
        ]
    },
    "3365": {
        "db_id": "sports_competition",
        "question": "List the types of competition and the number of competitions of each type.",
        "ground_truth": "SELECT Competition_type ,  COUNT(*) FROM competition GROUP BY Competition_type",
        "amends": [
            "Do reference the correct table name `competition` instead of the incorrect `competitions`. Do group by `Competition_type` instead of `competition_id` to ensure the count aggregates properly by competition type rather than by individual competition identifiers. Do maintain the case consistency for `Competition_type` in both SELECT and GROUP BY clauses instead of using inconsistent casing. The amended query now correctly counts competitions by their type rather than by ID, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"types of competition and the number of competitions of each type\": make sure the output order: Competition_type first, then count of competitions. 2) When the question mentions \"types of competition\": \"types of competition\" actually means \"Competition_type in schema\". 3) When the question asks for \"number of competitions of each type\": compute the count of competitions using the canonical key for competitions, grouped by Competition_type. 4) When the question says \"per type\"/\"by type\": organize results by Competition_type and compute the count per group. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for Competition_type. 6) When handling text literals: do not change case, spacing, or punctuation for values like 'Friendly'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT competition_type, COUNT(*) FROM competitions GROUP BY competition_id;",
            "SELECT Competition_type, COUNT(*) AS Number_of_Competitions FROM competition GROUP BY Competition_type;"
        ],
        "rule_sql": [
            "SELECT \"Competition_type\", COUNT(*) AS \"Number_of_Competitions\" FROM \"competition\" GROUP BY \"Competition_type\""
        ]
    },
    "601": {
        "db_id": "store_1",
        "question": "List top 10 employee work longest in the company. List employee's first and last name.",
        "ground_truth": "SELECT first_name , last_name FROM employees ORDER BY hire_date ASC LIMIT 10;",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM employees ORDER BY hire_date ASC LIMIT 10;"
        ],
        "rule_sql": [
            "SELECT first_name, last_name \nFROM employees \nORDER BY (julianday('now') - julianday(hire_date)) DESC \nLIMIT 10"
        ]
    },
    "3314": {
        "db_id": "college_1",
        "question": "What are the first names, office locations of all lecturers who have taught some course?",
        "ground_truth": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num",
        "amends": [
            "Do select `T2.emp_fname`, `T4.prof_office`, and `T3.crs_description` instead of `first_name` and `office_location`. Do join four tables (`CLASS AS T1`, `employee AS T2`, `course AS T3`, and `professor AS T4`) with explicit `JOIN` conditions instead of querying a single `lecturers` table. Do use join predicates `T1.prof_num = T2.emp_num`, `T1.crs_code = T3.crs_code`, and `T2.emp_num = T4.emp_num` instead of a simple `WHERE course_taught IS NOT NULL` filter. Do remove the `WHERE` clause entirely instead of keeping the `course_taught IS NOT NULL` condition, as the join logic now properly handles the relationship between professors, courses, and classes. The amended query now correctly retrieves professor names, office locations, and course descriptions by properly joining the relevant tables through their relationships."
        ],
        "rules": [
            "1) When answering about \"first names, office locations of all lecturers who have taught some course\": make sure the output order: T2.emp_fname, T4.prof_office, T3.crs_description. 2) When the question mentions \"lecturers\": \"lecturers\" actually means \"professors in schema\" requiring joining employee and professor tables. 3) When combining CLASS AS T1 and employee AS T2: link rows where T1.prof_num = T2.emp_num and keep only matching pairs (inner match). 4) When combining CLASS AS T1 and course AS T3: link rows where T1.crs_code = T3.crs_code and keep only matching pairs (inner match). 5) When combining employee AS T2 and professor AS T4: link rows where T2.emp_num = T4.emp_num and keep only matching pairs (inner match). 6) When identifying lecturers who have taught some course: use the join relationships through CLASS table instead of a WHERE course_taught IS NOT NULL condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, office_location FROM lecturers WHERE course_taught IS NOT NULL;",
            "SELECT T2.EMP_FNAME, T4.PROF_OFFICE, T3.CRS_DESCRIPTION\nFROM CLASS AS T1\nJOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM\nJOIN COURSE AS T3 ON T1.CRS_CODE = T3.CRS_CODE\nJOIN PROFESSOR AS T4 ON T2.EMP_NUM = T4.EMP_NUM"
        ],
        "rule_sql": [
            "SELECT T2.EMP_FNAME, T4.PROF_OFFICE, T3.CRS_DESCRIPTION\nFROM CLASS AS T1\nINNER JOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM\nINNER JOIN COURSE AS T3 ON T1.CRS_CODE = T3.CRS_CODE\nINNER JOIN PROFESSOR AS T4 ON T2.EMP_NUM = T4.EMP_NUM\nORDER BY T2.EMP_FNAME, T4.PROF_OFFICE, T3.CRS_DESCRIPTION;"
        ]
    },
    "2276": {
        "db_id": "entrepreneur",
        "question": "Return the names of entrepreneurs do no not have the investor Rachel Elnaugh.",
        "ground_truth": "SELECT T2.Name FROM entrepreneur AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Investor != \"Rachel Elnaugh\"",
        "amends": [
            "Do join `entrepreneur AS T1` with `people AS T2` on `T1.People_ID = T2.People_ID` instead of querying only the `entrepreneurs` table. Do select `T2.Name` from the joined `people` table instead of selecting `name` directly from the original table. Do use table aliases `T1` and `T2` for clarity instead of no aliases. Do reference the investor condition as `T1.Investor` instead of just `investor` to specify the table source. Do use double quotes around the string value instead of single quotes for consistency. The amended query now correctly retrieves entrepreneur names from the people table through proper table joining and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about entrepreneurs who do not have a specific investor: join table \"entrepreneur\" as T1 with table \"people\" as T2 on T1.People_ID = T2.People_ID to access the correct name information. 2) When selecting entrepreneur names: use T2.Name from the \"people\" table instead of the original table's name column. 3) When filtering by investor condition: reference the investor column as T1.Investor to specify the correct table source. 4) When comparing against the literal value \"Rachel Elnaugh\": use double quotes around the exact string value as shown in the schema. 5) When combining tables for shared entities: link rows where T1.People_ID = T2.People_ID and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM entrepreneurs WHERE investor != 'Rachel Elnaugh';",
            "SELECT T2.Name FROM entrepreneur AS T1 JOIN people AS T2 ON T1.People_ID = T2.People_ID WHERE T1.Investor != \"Rachel Elnaugh\""
        ],
        "rule_sql": [
            "SELECT T2.Name FROM entrepreneur AS T1 JOIN people AS T2 ON T1.People_ID = T2.People_ID WHERE T1.Investor != \"Rachel Elnaugh\""
        ]
    },
    "5584": {
        "db_id": "products_gen_characteristics",
        "question": "What is the unit of measurement of product named \"cumin\"?",
        "ground_truth": "SELECT t2.unit_of_measure FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  \"cumin\"",
        "amends": [
            "Do select `t2.unit_of_measure` instead of `unit` from the products table. Do add a `JOIN` with `ref_product_categories AS t2` instead of querying only the products table. Do use the join condition `ON t1.product_category_code = t2.product_category_code` instead of no join condition. Do filter on `t1.product_name = \"cumin\"` instead of `name = 'cumin'`. Do use table aliases `t1` and `t2` instead of no aliases. The amended query now correctly retrieves the unit of measure from the reference table based on product category association rather than assuming the unit exists directly in the products table."
        ],
        "rules": [
            "1) When the question asks about \"unit of measurement\" for a product: use the exact column token \"t2.unit_of_measure\" instead of \"unit\". 2) When querying for product information: join \"products\" as t1 with \"ref_product_categories\" as t2 using the condition \"t1.product_category_code = t2.product_category_code\" to link product categories. 3) When filtering for a product named \"cumin\": use the exact filter \"t1.product_name = \\\"cumin\\\"\" with double quotes around the literal value. 4) When selecting from multiple tables: use table aliases t1 for the products table and t2 for the ref_product_categories table as established in the join."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT unit FROM products WHERE name = 'cumin';",
            "SELECT t2.unit_of_measure \nFROM Products AS t1\nJOIN Ref_Product_Categories AS t2 ON t1.product_category_code = t2.product_category_code\nWHERE t1.product_name = 'cumin'"
        ],
        "rule_sql": [
            "SELECT t2.unit_of_measure FROM Products t1 JOIN Ref_Product_Categories t2 ON t1.product_category_code = t2.product_category_code WHERE t1.product_name = \"cumin\""
        ]
    },
    "4756": {
        "db_id": "department_store",
        "question": "Return the id of the staff whose Staff Department Assignment was earlier than that of any Clerical Staff.",
        "ground_truth": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  'Clerical Staff')",
        "amends": [
            "Do select `staff_id` instead of `s1.id` and use the correct table name `Staff_Department_Assignments` instead of `staff_department_assignment`. Do remove the unnecessary join to `staff` table instead of keeping it in both main and subquery. Do use `date_assigned_to` column instead of `assignment_date` for date comparisons. Do change the subquery to find the maximum date with `max(date_assigned_to)` instead of minimum date with `MIN(sda2.assignment_date)`. Do filter by `job_title_code = 'Clerical Staff'` in the subquery instead of `department = 'Clerical'` on the staff table. The amended query now correctly identifies staff assigned before the most recent clerical staff assignment date."
        ],
        "rules": [
            "1) When selecting staff identifiers: use the exact column name \"staff_id\" from the Staff_Department_Assignments table instead of \"s1.id\". 2) When referring to the staff department assignment table: use the exact table name \"Staff_Department_Assignments\" with proper case and underscores. 3) When comparing assignment dates: use the column \"date_assigned_to\" for date comparisons instead of \"assignment_date\". 4) When finding the most recent clerical staff assignment: use MAX(date_assigned_to) to find the maximum date instead of MIN(). 5) When filtering for clerical staff: use the condition \"job_title_code = 'Clerical Staff'\" exactly as specified, including the literal value 'Clerical Staff' with proper case and spacing. 6) When joining tables: avoid unnecessary joins to the staff table in both main query and subquery when the required information is available in Staff_Department_Assignments. 7) When the question asks for staff whose assignment was earlier than any clerical staff: compare date_assigned_to to be less than the maximum date_assigned_to of clerical staff assignments."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s1.id \nFROM staff s1\nJOIN staff_department_assignment sda1 ON s1.id = sda1.staff_id\nWHERE sda1.assignment_date < (\n    SELECT MIN(sda2.assignment_date)\n    FROM staff_department_assignment sda2\n    JOIN staff s2 ON sda2.staff_id = s2.id\n    WHERE s2.department = 'Clerical'\n)",
            "SELECT sda1.staff_id\nFROM Staff_Department_Assignments sda1\nWHERE sda1.date_assigned_to < (\n    SELECT MAX(sda2.date_assigned_to)\n    FROM Staff_Department_Assignments sda2\n    WHERE sda2.job_title_code = 'Clerical Staff'\n)"
        ],
        "rule_sql": [
            "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to < (SELECT MAX(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code = 'Clerical Staff')"
        ]
    },
    "1031": {
        "db_id": "phone_1",
        "question": "Find the Char cells, Pixels and Hardware colours for the screen of the phone whose hardware model name is \"LG-P760\".",
        "ground_truth": "SELECT T1.Char_cells ,  T1.Pixels ,  T1.Hardware_colours FROM screen_mode AS T1 JOIN phone AS T2 ON T1.Graphics_mode = T2.screen_mode WHERE T2.Hardware_Model_name = \"LG-P760\";",
        "amends": [
            "Do select `T1.Char_cells`, `T1.Pixels`, and `T1.Hardware_colours` from the `screen_mode` table instead of selecting `char_cells`, `pixels`, and `hardware_colors` from the `phone_screens` table. Do join `screen_mode AS T1` with `phone AS T2` on `T1.Graphics_mode = T2.screen_mode` instead of querying a single table. Do filter on `T2.Hardware_Model_name = \"LG-P760\"` instead of filtering on `hardware_model = 'LG-P760'`. The amended query now correctly joins related tables and matches the intended behavior."
        ],
        "rules": [
            "1) When answering about \"Char cells, Pixels and Hardware colours for the screen\": make sure the output order: T1.Char_cells, T1.Pixels, T1.Hardware_colours\n2) When the question mentions \"phone whose hardware model name is 'LG-P760'\": filter rows where T2.Hardware_Model_name = \"LG-P760\" exactly\n3) When combining screen_mode (T1) and phone (T2) tables: link rows where T1.Graphics_mode = T2.screen_mode and keep only matching pairs (inner match)\n4) When selecting from multiple tables: use T1 for screen_mode table columns (Char_cells, Pixels, Hardware_colours) and T2 for phone table columns (Hardware_Model_name)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT char_cells, pixels, hardware_colors FROM phone_screens WHERE hardware_model = 'LG-P760';",
            "SELECT T1.Char_cells, T1.Pixels, T1.Hardware_colours \nFROM screen_mode AS T1 \nJOIN phone AS T2 ON T1.Graphics_mode = T2.screen_mode \nWHERE T2.Hardware_Model_name = 'LG-P760'"
        ],
        "rule_sql": [
            "SELECT T1.Char_cells, T1.Pixels, T1.Hardware_colours\nFROM screen_mode T1\nINNER JOIN phone T2 ON T1.Graphics_mode = T2.screen_mode\nWHERE T2.Hardware_Model_name = 'LG-P760'"
        ]
    },
    "4389": {
        "db_id": "tracking_grants_for_research",
        "question": "How many tasks are there?",
        "ground_truth": "SELECT count(*) FROM Tasks",
        "amends": [
            "Do query the `Tasks` table instead of the `employees` table. The amended query now correctly counts records from the Tasks table as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When answering about \"how many tasks\": make sure to count records from the \"Tasks\" table instead of the \"employees\" table. 2) When counting entities: use the canonical counting method for the specified table (\"Tasks\") to get the total number of tasks."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees;",
            "SELECT COUNT(*) FROM Tasks;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS total_tasks FROM Tasks;"
        ]
    },
    "1561": {
        "db_id": "customers_and_invoices",
        "question": "Show the unique first names, last names, and phone numbers for all customers with any account.",
        "ground_truth": "SELECT DISTINCT T1.customer_first_name ,  T1.customer_last_name ,  T1.phone_number FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id",
        "amends": [
            "Do reference columns with table aliases `T1.customer_first_name`, `T1.customer_last_name`, and `T1.phone_number` instead of unqualified `first_name`, `last_name`, and `phone_number`. Do add `JOIN Accounts AS T2` instead of omitting the table. Do use join condition `ON T1.customer_id = T2.customer_id` instead of filtering with `WHERE account_id IS NOT NULL`. Do remove the `WHERE` clause entirely instead of keeping the incorrect filter that doesn't properly relate the tables. The amended query now correctly joins the Customers and Accounts tables to find customers who actually have accounts, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about customers with accounts: combine Customers as T1 and Accounts as T2 using the join condition T1.customer_id = T2.customer_id to find matching pairs. 2) When selecting customer information: use the exact column tokens T1.customer_first_name, T1.customer_last_name, and T1.phone_number. 3) When the question asks for unique customer details: ensure each customer appears only once in the results by removing duplicate entries. 4) When combining tables for shared entities: perform an inner match to keep only customers who have at least one account in the Accounts table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT first_name, last_name, phone_number FROM customers WHERE account_id IS NOT NULL;",
            "SELECT DISTINCT T1.customer_first_name, T1.customer_last_name, T1.phone_number\nFROM Customers AS T1\nJOIN Accounts AS T2 ON T1.customer_id = T2.customer_id"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.customer_first_name, T1.customer_last_name, T1.phone_number\nFROM Customers AS T1\nINNER JOIN Accounts AS T2 ON T1.customer_id = T2.customer_id;"
        ]
    },
    "2856": {
        "db_id": "customer_deliveries",
        "question": "Find the name of route that has the highest number of deliveries.",
        "ground_truth": "SELECT t1.route_name FROM Delivery_Routes AS t1 JOIN Delivery_Route_Locations AS t2 ON t1.route_id  =  t2.route_id GROUP BY t1.route_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `t1.route_name` from `Delivery_Routes AS t1` instead of just `route_name` from `deliveries`. Do add a `JOIN` with `Delivery_Route_Locations AS t2` on `t1.route_id = t2.route_id` instead of querying a single table. Do add `GROUP BY t1.route_id` to aggregate by route instead of no grouping. Do order by `count(*) DESC` instead of `delivery_count ASC` to find the route with the most locations rather than fewest deliveries. Do keep `LIMIT 1` to return only the top result. The amended query now correctly identifies the route with the most associated locations rather than incorrectly assuming a delivery_count column exists."
        ],
        "rules": [
            "1) When answering about \"route that has the highest number of deliveries\": use table \"Delivery_Routes AS t1\" for route information instead of \"deliveries\". 2) When counting deliveries per route: join with \"Delivery_Route_Locations AS t2\" on \"t1.route_id = t2.route_id\" to get delivery locations data. 3) When grouping by route: use \"GROUP BY t1.route_id\" to aggregate results by each route. 4) When finding the route with highest number of deliveries: order by \"count(*) DESC\" to rank routes by their delivery count in descending order. 5) When the question asks for the highest number: use \"LIMIT 1\" to return only the top result. 6) When selecting route name: use \"t1.route_name\" as the output column."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT route_name FROM deliveries ORDER BY delivery_count ASC LIMIT 1;",
            "SELECT t1.route_name \nFROM Delivery_Routes AS t1\nJOIN Delivery_Route_Locations AS t2 ON t1.route_id = t2.route_id\nGROUP BY t1.route_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t1.route_name\nFROM Delivery_Routes AS t1\nJOIN Delivery_Route_Locations AS t2 ON t1.route_id = t2.route_id\nJOIN Order_Deliveries AS t3 ON t2.location_code = t3.location_code\nGROUP BY t1.route_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "5703": {
        "db_id": "dorm_1",
        "question": "What is the name of the dorm with both a TV Lounge and Study Room listed as amenities?",
        "ground_truth": "SELECT T1.dorm_name FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid JOIN dorm_amenity AS T3 ON T2.amenid  =  T3.amenid WHERE T3.amenity_name  =  'TV Lounge' INTERSECT SELECT T1.dorm_name FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid JOIN dorm_amenity AS T3 ON T2.amenid  =  T3.amenid WHERE T3.amenity_name  =  'Study Room'",
        "amends": [
            "Do use proper table joins with `dorm`, `has_amenity`, and `dorm_amenity` tables instead of querying a single `dorms` table. Do select `dorm_name` instead of `name` and use proper column references with table aliases. Do replace the `LIKE` pattern matching with explicit equality conditions `amenity_name = 'TV Lounge'` and `amenity_name = 'Study Room'` instead of string pattern matching. Do use an `INTERSECT` operation to find dorms that have both amenities instead of using `OR` logic which would find dorms with either amenity. Do add proper join conditions `T1.dormid = T2.dormid` and `T2.amenid = T3.amenid` instead of relying on a single table structure. The amended query now correctly identifies dorms that contain both specified amenities rather than those containing either one."
        ],
        "rules": [
            "1) When the question asks about dorms with specific amenities: use proper table joins with \"dorm\", \"has_amenity\", and \"dorm_amenity\" tables instead of querying a single table. 2) When selecting the dorm name: select \"dorm_name\" instead of \"name\" and use proper column references with table aliases. 3) When matching specific amenities: use explicit equality conditions \"amenity_name = 'TV Lounge'\" and \"amenity_name = 'Study Room'\" instead of string pattern matching. 4) When finding dorms that have both amenities: use an INTERSECT operation to find dorms that have both amenities instead of using OR logic which would find dorms with either amenity. 5) When combining tables: add proper join conditions \"T1.dormid = T2.dormid\" and \"T2.amenid = T3.amenid\" instead of relying on a single table structure."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM dorms WHERE amenities LIKE '%TV Lounge%' OR amenities LIKE '%Study Room%';",
            "SELECT d.dorm_name\nFROM Dorm d\nJOIN Has_amenity ha1 ON d.dormid = ha1.dormid\nJOIN Dorm_amenity da1 ON ha1.amenid = da1.amenid AND da1.amenity_name = 'TV Lounge'\nINTERSECT\nSELECT d.dorm_name\nFROM Dorm d\nJOIN Has_amenity ha2 ON d.dormid = ha2.dormid\nJOIN Dorm_amenity da2 ON ha2.amenid = da2.amenid AND da2.amenity_name = 'Study Room'"
        ],
        "rule_sql": [
            "SELECT d.dorm_name\nFROM Dorm d\nJOIN Has_amenity ha1 ON d.dormid = ha1.dormid\nJOIN Dorm_amenity da1 ON ha1.amenid = da1.amenid AND da1.amenity_name = 'TV Lounge'\nINTERSECT\nSELECT d.dorm_name\nFROM Dorm d\nJOIN Has_amenity ha2 ON d.dormid = ha2.dormid\nJOIN Dorm_amenity da2 ON ha2.amenid = da2.amenid AND da2.amenity_name = 'Study Room'"
        ]
    },
    "4420": {
        "db_id": "network_2",
        "question": "What is the average age for each gender?",
        "ground_truth": "SELECT avg(age) ,  gender FROM Person GROUP BY gender",
        "amends": [
            "Do use table name `Person` instead of `users` in the FROM clause. Do place the `gender` column after the aggregate function instead of before it in the SELECT list. Do maintain the same aggregate function `avg(age)` and GROUP BY clause `GROUP BY gender` structure. The amended query now correctly references the appropriate table and maintains proper column ordering while preserving the same analytical behavior.",
            "Do place the `gender` column after the aggregate function `avg(age)` in the SELECT list instead of listing it first. Do maintain the same GROUP BY clause with `gender` to ensure proper aggregation grouping. The amended query now correctly positions the aggregate function first while preserving the same logical grouping and output behavior as the RIGHT_SQL."
        ],
        "rules": [
            "1) When answering about \"average age for each gender\": make sure the output order: average age first, then gender. 2) When the question mentions \"users\": \"users\" actually means \"Person\" in schema. 3) When the question asks for \"average age\": compute the average of the \"age\" column. 4) When the question says \"per gender\"/\"by gender\": organize results by the \"gender\" column and compute requested aggregates per group.",
            "1) When answering about \"average age for each gender\": make sure the output order: avg(age) first, then gender. 2) When the question asks for \"average age\": compute the average of the age column. 3) When the question says \"for each gender\": organize results by the gender column and compute the average age per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT gender, AVG(age) FROM users GROUP BY gender;",
            "SELECT gender, avg(age) FROM Person GROUP BY gender",
            "SELECT avg(age), gender FROM Person GROUP BY gender"
        ],
        "rule_sql": [
            "SELECT AVG(age) AS average_age, gender FROM Person GROUP BY gender ORDER BY average_age, gender;"
        ]
    },
    "962": {
        "db_id": "medicine_enzyme_interaction",
        "question": "What is the count of enzymes without any interactions?",
        "ground_truth": "SELECT count(*) FROM enzyme WHERE id NOT IN ( SELECT enzyme_id FROM medicine_enzyme_interaction );",
        "amends": [
            "Do reference table `enzyme` instead of `enzymes` and use column `id` instead of `enzyme_id` in the main query. Do use subquery from table `medicine_enzyme_interaction` instead of `interactions` while keeping the same `enzyme_id` column reference. The amended query now correctly counts enzymes without interactions by using the proper table and column names that match the schema."
        ],
        "rules": [
            "1) When answering about \"count of enzymes without any interactions\": use table \"enzyme\" as T1 and column \"id\" as the canonical key for counting enzymes. 2) When checking for enzymes without interactions: reference table \"medicine_enzyme_interaction\" as T2 and use column \"enzyme_id\" to identify enzymes that have interactions. 3) When counting distinct enzymes: compute the number of unique \"id\" values from T1 where the \"id\" is not found in the \"enzyme_id\" values of T2. 4) When combining enzyme and interaction data: use the exact column mapping where T1.\"id\" = T2.\"enzyme_id\" for identifying matching records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM enzymes WHERE enzyme_id NOT IN (SELECT enzyme_id FROM interactions)",
            "SELECT COUNT(*) \nFROM enzyme e \nWHERE e.id NOT IN (SELECT enzyme_id FROM medicine_enzyme_interaction)"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.id) \nFROM enzyme T1 \nWHERE T1.id NOT IN (SELECT T2.enzyme_id FROM medicine_enzyme_interaction T2)"
        ]
    },
    "3059": {
        "db_id": "loan_1",
        "question": "What is the total account balance for customers with a credit score of above 100 for the different states?",
        "ground_truth": "SELECT sum(acc_bal) ,  state FROM customer WHERE credit_score  >  100 GROUP BY state",
        "amends": [
            "Do use the table name `customer` instead of `customers` and the column name `acc_bal` instead of `account_balance`. Do place the `state` column after the aggregate function instead of before it in the SELECT list. Do remove the alias `total_balance` instead of keeping it. The amended query now correctly references the actual table and column names while maintaining the same aggregation logic by state for customers with credit scores above 100.",
            "Do place `state` after `SUM(acc_bal)` in the SELECT list instead of before it, maintaining the same aggregation logic and filtering condition with `credit_score > 100` grouped by `state`. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question mentions \"customers\": use the exact table name \"customer\" instead of \"customers\". 2) When the question mentions \"account balance\": use the exact column name \"acc_bal\" instead of \"account_balance\". 3) When producing output for state-level aggregation: place the aggregate function SUM(acc_bal) before the state column in the output order. 4) When the question asks for total account balance without specifying an alias: do not add an alias like \"total_balance\" to the aggregate result. 5) When filtering customers by credit score above 100: use the condition credit_score > 100 exactly as specified.",
            "1) When the question asks for total account balance by state for customers with credit score above 100: place SUM(acc_bal) before state in the output columns. 2) When filtering customers by credit score: use the condition credit_score > 100. 3) When grouping results by state: organize the output by the state column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT state, SUM(account_balance) as total_balance \nFROM customers \nWHERE credit_score > 100 \nGROUP BY state;",
            "SELECT state, SUM(acc_bal) FROM customer WHERE credit_score > 100 GROUP BY state;",
            "SELECT SUM(acc_bal), state FROM customer WHERE credit_score > 100 GROUP BY state;"
        ],
        "rule_sql": [
            "SELECT SUM(acc_bal), state FROM customer WHERE credit_score > 100 GROUP BY state;"
        ]
    },
    "6720": {
        "db_id": "activity_1",
        "question": "What buildings have faculty offices?",
        "ground_truth": "SELECT DISTINCT building FROM Faculty",
        "amends": [
            "Do select only `building` instead of all columns with `*`. Do use `DISTINCT` to eliminate duplicates instead of omitting it. Do query from the `Faculty` table instead of the `buildings` table. Do remove the `type = 'office'` filter instead of keeping it. Do remove the `owner = 'faculty'` filter instead of keeping it. The amended query now correctly retrieves unique building names from the Faculty table as intended."
        ],
        "rules": [
            "1) When answering about \"What buildings have faculty offices?\": make sure the output order: building 2) When the question asks for buildings: \"building\" actually means \"building in schema\" 3) When the question asks for distinct values: use DISTINCT to eliminate duplicates 4) When querying about faculty offices: query from the Faculty table instead of the buildings table 5) When filtering for faculty offices: do not apply type = 'office' or owner = 'faculty' filters"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM buildings WHERE type = 'office' AND owner = 'faculty';",
            "SELECT DISTINCT Building FROM Faculty;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Building FROM Faculty ORDER BY Building;"
        ]
    },
    "675": {
        "db_id": "customers_card_transactions",
        "question": "How many accounts does the customer with first name Art and last name Turcotte have?",
        "ground_truth": "SELECT count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  \"Art\" AND T2.customer_last_name  =  \"Turcotte\"",
        "amends": [
            "Do add `JOIN Accounts AS T1` on `T1.customer_id = T2.customer_id` instead of querying only the `customers` table. Do reference `customer_first_name` and `customer_last_name` instead of `first_name` and `last_name` from the `Customers AS T2` table instead of the original `customers` table. Do use double quotes around string literals `\"Art\"` and `\"Turcotte\"` instead of single quotes. The amended query now correctly joins the Accounts and Customers tables to count records based on customer names, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"how many accounts a customer has\": join the Accounts table (as T1) with the Customers table (as T2) using the condition T1.customer_id = T2.customer_id to link customer accounts. 2) When the question mentions \"first name Art and last name Turcotte\": use the exact column tokens \"customer_first_name\" and \"customer_last_name\" from the Customers table (T2) with the exact string literals \"Art\" and \"Turcotte\". 3) When counting accounts for a specific customer: count the number of rows in the Accounts table (T1) that match the customer with the specified first and last name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE first_name = 'Art' AND last_name = 'Turcotte';",
            "SELECT COUNT(*) \nFROM Accounts AS T1\nJOIN Customers AS T2 ON T1.customer_id = T2.customer_id\nWHERE T2.customer_first_name = \"Art\" AND T2.customer_last_name = \"Turcotte\""
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Accounts AS T1\nJOIN Customers AS T2 ON T1.customer_id = T2.customer_id\nWHERE T2.customer_first_name = 'Art' AND T2.customer_last_name = 'Turcotte'"
        ]
    },
    "2829": {
        "db_id": "restaurant_1",
        "question": "Which city does student Linda Smith live in?",
        "ground_truth": "SELECT city_code FROM Student WHERE Fname = \"Linda\" AND Lname = \"Smith\";",
        "amends": [
            "Do select `city_code` instead of `city` to use the correct column name. Do reference table `Student` instead of `students` to use the proper table name. Do use column `Fname` instead of `first_name` and `Lname` instead of `last_name` to match the actual schema column names. Do use double quotes `\"Linda\"` and `\"Smith\"` instead of single quotes for string literals. The amended query now correctly retrieves the city code from the Student table for the specified student."
        ],
        "rules": [
            "1) When the question asks for a student's city: use column \"city_code\" from table \"Student\" instead of \"city\" from \"students\". 2) When the question mentions student first name \"Linda\": use column \"Fname\" with literal value \"Linda\" (double quotes). 3) When the question mentions student last name \"Smith\": use column \"Lname\" with literal value \"Smith\" (double quotes). 4) When selecting string literals: use double quotes instead of single quotes for exact value matching."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city FROM students WHERE first_name = 'Linda' AND last_name = 'Smith';",
            "SELECT city_code FROM Student WHERE Fname = \"Linda\" AND Lname = \"Smith\";"
        ],
        "rule_sql": [
            "SELECT city_code FROM Student WHERE Fname = \"Linda\" AND Lname = \"Smith\";"
        ]
    },
    "5713": {
        "db_id": "dorm_1",
        "question": "What is the code of the city with the most students?",
        "ground_truth": "SELECT city_code FROM student GROUP BY city_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do aggregate with `count(*)` instead of referencing `student_count` column, do add `GROUP BY city_code` instead of omitting it, and do change table reference to `student` instead of `students` to match the correct schema. The amended query now correctly identifies the city with the most students by counting records per city rather than relying on a potentially non-existent student_count column."
        ],
        "rules": [
            "1) When counting students per city: use count(*) to count all records in the student table for each city group. 2) When grouping by city: use GROUP BY city_code to organize results by city code. 3) When referencing the student table: use the exact table name student instead of students. 4) When finding the city with the most students: order the results by the student count in descending order and take the first result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city_code FROM students ORDER BY student_count DESC LIMIT 1;",
            "SELECT city_code FROM Student GROUP BY city_code ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT city_code FROM Student GROUP BY city_code ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "2300": {
        "db_id": "entrepreneur",
        "question": "Count the number of different companies.",
        "ground_truth": "SELECT count(DISTINCT Company) FROM entrepreneur",
        "amends": [
            "Do select `count(DISTINCT Company)` instead of `COUNT(*)`. Do query from `entrepreneur` table instead of `companies` table. The amended query now correctly counts distinct companies from the entrepreneur table rather than counting all rows from the companies table."
        ],
        "rules": [
            "1) When counting the number of different companies: use the exact token \"Company\" from the entrepreneur table to count distinct values. 2) When the question asks about companies: the data comes from the \"entrepreneur\" table, not a \"companies\" table. 3) When counting distinct entities: compute the number of unique values using the exact column token \"Company\" rather than counting all rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM companies;",
            "SELECT COUNT(DISTINCT Company) FROM entrepreneur;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Company) FROM entrepreneur;"
        ]
    },
    "6609": {
        "db_id": "train_station",
        "question": "Show the name, time, and service for all trains.",
        "ground_truth": "SELECT name ,  TIME ,  service FROM train",
        "amends": [
            "Do add `service` to the SELECT list instead of omitting it. Do change the table reference from `trains` to `train` instead of using the incorrect table name. The amended query now correctly includes all required columns and references the proper table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"name, time, and service\": include all three columns \"name\", \"time\", and \"service\" in the output. 2) When referencing the train table: use the exact table name \"train\" instead of \"trains\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, time FROM trains;",
            "SELECT Name, Time, Service FROM train;"
        ],
        "rule_sql": [
            "SELECT name, time, service FROM train;"
        ]
    },
    "4743": {
        "db_id": "department_store",
        "question": "What is the id of the department with the least number of staff?",
        "ground_truth": "SELECT department_id FROM staff_department_assignments GROUP BY department_id ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do reference the `staff_department_assignments` table instead of the `staff` table as the data source. Do use the same `ORDER BY count(*)` aggregation without the `ASC` specifier instead of including it, as ascending order is the default. The amended query now correctly uses the appropriate table for department assignments and maintains the same ordering behavior to identify the department with the fewest staff members.",
            "Do remove the `COUNT(*) AS staff_count` column from the SELECT list instead of including it, and do remove the explicit column alias instead of keeping it. Do maintain the same `FROM Staff_Department_Assignments` source table and `GROUP BY department_id` grouping. Do keep the `ORDER BY count(*)` sorting and `LIMIT 1` restriction unchanged. The amended query now correctly returns only the department_id with the smallest staff count instead of including unnecessary count data."
        ],
        "rules": [
            "1) When answering about \"department with the least number of staff\": use the \"staff_department_assignments\" table as the data source instead of the \"staff\" table. 2) When counting staff members per department: group by \"department_id\" and count the number of rows using the canonical key from staff_department_assignments. 3) When ordering by staff count to find the department with the least staff: order by the count in ascending order (default behavior, no explicit ASC needed). 4) When selecting the department with the minimum count: limit the result to the first row after ordering by count in ascending order.",
            "1) When answering about \"the department with the least number of staff\": make sure the output order: department_id only. 2) When counting staff per department: compute the number of rows using the canonical key token for department grouping (department_id). 3) When the question asks for \"least number\" or \"smallest staff count\": rank rows by staff count in ascending order and keep the first 1 row. 4) When producing output for this question: do not include the count column or any explicit column aliases in the final result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department_id FROM staff GROUP BY department_id ORDER BY COUNT(*) ASC LIMIT 1;",
            "SELECT department_id, COUNT(*) AS staff_count\nFROM Staff_Department_Assignments\nGROUP BY department_id\nORDER BY COUNT(*)\nLIMIT 1;",
            "SELECT department_id FROM Staff_Department_Assignments GROUP BY department_id ORDER BY count(*) LIMIT 1"
        ],
        "rule_sql": [
            "SELECT department_id FROM Staff_Department_Assignments GROUP BY department_id ORDER BY COUNT(*) LIMIT 1;"
        ]
    },
    "3398": {
        "db_id": "manufacturer",
        "question": "Give me the name and year of opening of the manufacturers that have either less than 10 factories or more than 10 shops.",
        "ground_truth": "SELECT name ,  open_year FROM manufacturer WHERE num_of_shops  >  10 OR Num_of_Factories  <  10",
        "amends": [
            "Do reference column `open_year` instead of `year_opened` and table `manufacturer` instead of `manufacturers` in the FROM clause. Do use filter conditions `num_of_shops > 10 OR Num_of_Factories < 10` instead of `factories < 10 OR shops > 10` to correctly reference the actual column names. The amended query now matches the intended logic by selecting from the correct table with properly named columns and filter conditions."
        ],
        "rules": [
            "1) When the question asks for manufacturer information: use table \"manufacturer\" instead of \"manufacturers\" and select columns \"name\" and \"open_year\" instead of \"year_opened\". 2) When filtering manufacturers by factory or shop counts: use filter conditions \"Num_of_Factories < 10 OR num_of_shops > 10\" with exact column names and comparison operators as specified. 3) When the question mentions \"factories\" or \"shops\": these refer to columns \"Num_of_Factories\" and \"num_of_shops\" respectively in the manufacturer table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, year_opened FROM manufacturers WHERE factories < 10 OR shops > 10;",
            "SELECT Name, Open_Year FROM manufacturer WHERE Num_of_Shops > 10 OR Num_of_Factories < 10"
        ],
        "rule_sql": [
            "SELECT Name, Open_Year FROM manufacturer WHERE Num_of_Factories < 10 OR Num_of_Shops > 10;"
        ]
    },
    "2390": {
        "db_id": "csu_1",
        "question": "Find the campus fee of \"San Jose State University\" in year 2000.",
        "ground_truth": "SELECT t1.campusfee FROM csu_fees AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t2.campus  =  \"San Jose State University\" AND t1.year  =  2000",
        "amends": [
            "Do select `t1.campusfee` from the `csu_fees` table instead of `campus_fee` from the `universities` table. Do join `campuses AS t2` on `t1.campus = t2.id` instead of querying a single table. Do filter on `t2.campus = \"San Jose State University\"` instead of `name = 'San Jose State University'` to use the joined table's campus name. Do filter on `t1.year = 2000` instead of `year = 2000` to specify the table alias. The amended query now correctly joins the fee and campus tables to retrieve campus fee data with proper table relationships."
        ],
        "rules": [
            "1) When answering about campus fee for a specific university: select t1.campusfee from the csu_fees table instead of campus_fee from universities table. 2) When joining campus fee data with university information: join campuses AS t2 on t1.campus = t2.id to establish proper table relationships. 3) When filtering by university name: use t2.campus = \"San Jose State University\" instead of name = 'San Jose State University' to reference the joined table's campus name column. 4) When filtering by year: use t1.year = 2000 instead of year = 2000 to specify the table alias for the year column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT campus_fee FROM universities WHERE name = 'San Jose State University' AND year = 2000;",
            "SELECT t1.CampusFee \nFROM csu_fees AS t1 \nJOIN Campuses AS t2 ON t1.Campus = t2.Id \nWHERE t2.Campus = 'San Jose State University' AND t1.Year = 2000"
        ],
        "rule_sql": [
            "SELECT t1.CampusFee FROM csu_fees AS t1 JOIN Campuses AS t2 ON t1.Campus = t2.Id WHERE t2.Campus = 'San Jose State University' AND t1.Year = 2000"
        ]
    },
    "5071": {
        "db_id": "device",
        "question": "What are the names of shops that have more than a single kind of device in stock?",
        "ground_truth": "SELECT T2.Shop_Name FROM stock AS T1 JOIN shop AS T2 ON T1.Shop_ID  =  T2.Shop_ID GROUP BY T1.Shop_ID HAVING COUNT(*)  >  1",
        "amends": [
            "Do select `T2.Shop_Name` instead of `name` from the SELECT list. Do use `FROM stock AS T1 JOIN shop AS T2` instead of `FROM shops` as the data source, adding proper table joins. Do specify the join condition `ON T1.Shop_ID = T2.Shop_ID` instead of omitting any join predicates. Do add `GROUP BY T1.Shop_ID` instead of grouping implicitly. Do move the count filter to `HAVING COUNT(*) > 1` instead of using `WHERE COUNT(DISTINCT device_type) > 1` which is invalid syntax. Do remove the `DISTINCT` modifier from the count operation instead of keeping it. The amended query now correctly identifies shops with multiple stock entries by properly joining tables and using valid HAVING clause syntax."
        ],
        "rules": [
            "1) When answering about shop names: make sure the output order: T2.Shop_Name. 2) When the question mentions \"shops\": use table \"shop\" as T2 with exact identifier \"Shop_Name\" for names. 3) When combining stock and shop tables: link rows where T1.Shop_ID = T2.Shop_ID and keep only matching pairs (inner match). 4) When the question asks for shops with more than one kind of device: group results by T1.Shop_ID and count the number of rows per group. 5) When filtering for shops with multiple stock entries: apply the condition COUNT(*) > 1 in the grouping phase. 6) When counting stock entries: use COUNT(*) instead of COUNT(DISTINCT device_type) as the question asks about multiple kinds of devices in stock rather than distinct device types."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM shops WHERE COUNT(DISTINCT device_type) > 1;",
            "SELECT T2.Shop_Name\nFROM stock AS T1\nJOIN shop AS T2 ON T1.Shop_ID = T2.Shop_ID\nGROUP BY T1.Shop_ID\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T2.Shop_Name\nFROM stock T1\nINNER JOIN shop T2 ON T1.Shop_ID = T2.Shop_ID\nGROUP BY T1.Shop_ID\nHAVING COUNT(*) > 1\nORDER BY T2.Shop_Name;"
        ]
    },
    "2585": {
        "db_id": "inn_1",
        "question": "Find the number of adults for the room reserved and checked in by CONRAD SELBIG on Oct 23, 2010.",
        "ground_truth": "SELECT Adults FROM Reservations WHERE CheckIn  =  \"2010-10-23\" AND FirstName  =  \"CONRAD\" AND LastName  =  \"SELBIG\";",
        "amends": [
            "Do select `Adults` instead of `COUNT(*)`. Do query from `Reservations` instead of `guests`. Do filter on `CheckIn = \"2010-10-23\"` instead of `check_in_date = '2010-10-23'`. Do filter on `FirstName = \"CONRAD\"` instead of `name = 'CONRAD SELBIG'`. Do add `LastName = \"SELBIG\"` instead of omitting it. Do remove `status = 'checked_in'` instead of keeping it. The amended query now correctly retrieves the number of adults from the reservations table for the specified guest and check-in date."
        ],
        "rules": [
            "1) When answering about \"number of adults for a reservation\": select the exact column \"Adults\" instead of counting rows. 2) When querying for reservation information: use the \"Reservations\" table instead of a \"guests\" table. 3) When filtering by check-in date: use the exact column \"CheckIn\" with the literal value \"2010-10-23\" in the specified format. 4) When filtering by guest name: split the full name into separate conditions using \"FirstName = \\\"CONRAD\\\"\" and \"LastName = \\\"SELBIG\\\"\" instead of a single name field. 5) When the question does not mention reservation status: do not include any status filter conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM guests WHERE name = 'CONRAD SELBIG' AND check_in_date = '2010-10-23' AND status = 'checked_in'",
            "SELECT Adults FROM Reservations WHERE FirstName = \"CONRAD\" AND LastName = \"SELBIG\" AND CheckIn = \"2010-10-23\""
        ],
        "rule_sql": [
            "SELECT Adults FROM Reservations WHERE FirstName = \"CONRAD\" AND LastName = \"SELBIG\" AND CheckIn = \"2010-10-23\""
        ]
    },
    "1438": {
        "db_id": "college_2",
        "question": "Find the name of instructor who is the advisor of the student who has the highest number of total credits.",
        "ground_truth": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT 1",
        "amends": [
            "Do use the `advisor` table as an intermediate join table instead of directly joining `instructor` to `student`. Do join `instructor` through `advisor.i_id = instructor.id` instead of `instructor.ID = student.advisor_id`. Do add a second join from `advisor.s_id` to `student.id` instead of omitting the proper relationship. Do reference columns as `T2.name` from the instructor table instead of `i.name`. Do use table aliases `T1`, `T2`, and `T3` for clarity instead of single-letter aliases. The amended query now correctly models the advisor-student-instructor relationship through the proper bridge table and matches the RIGHT_SQL's behavior.",
            "Do remove the `WHERE` filter with subquery instead of keeping it, and do add `ORDER BY T3.tot_cred DESC LIMIT 1` instead of omitting it. Do use lowercase column references `T1.i_id` and `T1.s_id` instead of uppercase `T1.i_ID` and `T1.s_ID`, and do use lowercase `T2.id` instead of uppercase `T2.ID`. The amended query now correctly finds the single instructor with the highest-credited student by sorting and limiting rather than using a subquery filter that could return multiple matches."
        ],
        "rules": [
            "1) When answering about \"instructor who is the advisor of the student\": use the advisor table as an intermediate join table between instructor and student tables. 2) When joining instructor and advisor tables: link rows where T2.id = T1.i_id exactly. 3) When joining advisor and student tables: link rows where T1.s_id = T3.id exactly. 4) When the question asks for \"the student who has the highest number of total credits\": rank students by T3.tot_cred in descending order and keep only the top 1 row. 5) When selecting the instructor name: reference it as T2.name from the instructor table. 6) When combining tables for this relationship: perform inner matches only using the exact key equalities specified in the joins.",
            "1) When the question asks for the instructor who advises the student with the highest total credits: sort students by tot_cred in descending order and take only the top student. 2) When combining advisor and instructor tables: link rows where T1.i_id = T2.id using exact lowercase column names. 3) When combining advisor and student tables: link rows where T1.s_id = T3.id using exact lowercase column names. 4) When finding the highest value: use ORDER BY T3.tot_cred DESC LIMIT 1 instead of a subquery filter to ensure only one result is returned. 5) When outputting results: return only the instructor's name (T2.name) as the final result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT i.name FROM instructor i JOIN student s ON i.ID = s.advisor_id ORDER BY s.tot_cred DESC LIMIT 1;",
            "SELECT T2.name\nFROM advisor T1\nJOIN instructor T2 ON T1.i_ID = T2.ID\nJOIN student T3 ON T1.s_ID = T3.ID\nWHERE T3.tot_cred = (SELECT MAX(tot_cred) FROM student);",
            "SELECT T2.name\nFROM advisor T1\nJOIN instructor T2 ON T1.i_id = T2.id\nJOIN student T3 ON T1.s_id = T3.id\nORDER BY T3.tot_cred DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT i.name \nFROM advisor a\nJOIN instructor i ON a.i_ID = i.ID\nJOIN student s ON a.s_ID = s.ID\nORDER BY s.tot_cred DESC\nLIMIT 1"
        ]
    },
    "500": {
        "db_id": "allergy_1",
        "question": "How many students does each advisor have?",
        "ground_truth": "SELECT advisor ,  count(*) FROM Student GROUP BY advisor",
        "amends": [
            "Do reference the `advisor` column instead of `advisor_id` and use the `Student` table name instead of `students` to match the correct schema. Do maintain the `COUNT(*)` aggregate and `GROUP BY advisor` structure while ensuring the column reference aligns with the actual table definition. The amended query now correctly counts students per advisor using the proper column and table names as specified in RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for \"students per advisor\": organize results by the exact column token \"advisor\" and compute the count of students per group. 2) When counting students: use the canonical counting approach by counting all rows in the \"Student\" table. 3) When referring to the student table: use the exact table name \"Student\" (case-sensitive) instead of \"students\". 4) When referring to the advisor column: use the exact column token \"advisor\" instead of \"advisor_id\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT advisor_id, COUNT(*) FROM students GROUP BY advisor_id;",
            "SELECT advisor, COUNT(*) FROM Student GROUP BY advisor"
        ],
        "rule_sql": [
            "SELECT advisor, COUNT(*) FROM Student GROUP BY advisor;"
        ]
    },
    "3712": {
        "db_id": "mountain_photos",
        "question": "Find the brand and name for each camera lens, and sort in descending order of maximum aperture.",
        "ground_truth": "SELECT brand ,  name FROM camera_lens ORDER BY max_aperture DESC",
        "amends": [
            "Do order by `max_aperture DESC` instead of `maximum_aperture ASC` to use the correct column name and sort direction. The amended query now matches the intended behavior with proper column reference and descending sort order."
        ],
        "rules": [
            "1) When the question asks for camera lens information: include both \"brand\" and \"name\" columns in the output. 2) When sorting camera lenses by maximum aperture: use the column \"max_aperture\" instead of \"maximum_aperture\". 3) When the question specifies descending order of maximum aperture: sort by \"max_aperture\" in descending order (largest values first)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT brand, name FROM camera_lens ORDER BY maximum_aperture ASC;",
            "SELECT brand, name FROM camera_lens ORDER BY max_aperture DESC;"
        ],
        "rule_sql": [
            "SELECT brand, name FROM camera_lens ORDER BY max_aperture DESC;"
        ]
    },
    "6576": {
        "db_id": "wine_1",
        "question": "What are the maximum price and score of wines for each year?",
        "ground_truth": "SELECT max(Price) ,  max(Score) ,  YEAR FROM WINE GROUP BY YEAR",
        "amends": [
            "Do use `max(Score)` instead of `score` to properly aggregate the score column with GROUP BY. Do place `YEAR` at the end of the SELECT list instead of at the beginning. Do reference the table as `WINE` instead of `wines` for correct table naming. The amended query now correctly aggregates both price and score with MAX functions and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for maximum price and score of wines for each year: use MAX(\"price\") and MAX(\"Score\") as aggregate functions instead of selecting individual score values. 2) When organizing results by year: group by \"YEAR\" column to get results per year. 3) When referencing the wine table: use the exact table name \"WINE\" instead of \"wines\" for correct table naming. 4) When ordering output columns: place \"YEAR\" at the end of the output list instead of at the beginning."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, MAX(price), score FROM wines GROUP BY year;",
            "SELECT MAX(Price), MAX(Score), Year FROM wine GROUP BY Year"
        ],
        "rule_sql": [
            "SELECT MAX(\"Price\"), MAX(\"Score\"), \"Year\" FROM \"wine\" GROUP BY \"Year\" ORDER BY \"Year\""
        ]
    },
    "6427": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "What is the document type description for document type named Film?",
        "ground_truth": "SELECT document_type_description FROM Ref_document_types WHERE document_type_name  =  \"Film\"",
        "amends": [
            "Do select `document_type_description` instead of `description` and do reference table `Ref_document_types` instead of `document_types`. Do filter on `document_type_name = \"Film\"` instead of `name = 'Film'` with proper double quotes instead of single quotes. The amended query now correctly retrieves the document type description from the reference table using the appropriate column names and string literal syntax."
        ],
        "rules": [
            "1) When the question asks for \"document type description\": select \"document_type_description\" from the appropriate table. 2) When the question refers to \"document type named Film\": filter rows where \"document_type_name\" equals exactly \"Film\" (with double quotes). 3) When retrieving document type information: use the table \"Ref_document_types\" instead of \"document_types\" as the source table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description FROM document_types WHERE name = 'Film';",
            "SELECT document_type_description FROM Ref_Document_Types WHERE document_type_name = \"Film\";"
        ],
        "rule_sql": [
            "SELECT document_type_description FROM Ref_Document_Types WHERE document_type_name = \"Film\";"
        ]
    },
    "6796": {
        "db_id": "activity_1",
        "question": "Which faculty members are playing either Canoeing or Kayaking? Tell me their first names.",
        "ground_truth": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'",
        "amends": [
            "Do use `DISTINCT T1.lname` instead of `first_name` without distinct. Do join `Faculty AS T1` with `Faculty_participates_in AS T2` on `T1.facID = T2.facID` instead of querying `faculty` alone. Do add a second join to `activity AS T3` on `T2.actid = T3.actid` instead of the incorrect `T2.actid = T2.actid`. Do filter on `T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'` instead of directly on `sport` column. The amended query now correctly retrieves distinct last names from the proper join relationships and matches the intended behavior.",
            "Do select `T1.lname` instead of `T1.Fname` in the SELECT list. Do use the correct join condition `T2.actid = T2.actid` instead of `T2.actid = T3.actid` in the second JOIN clause, though this appears to be a typo that should likely be `T2.actid = T3.actid` for proper table correlation. The amended query now correctly retrieves last names instead of first names for faculty participating in specified activities.",
            "Do use lowercase `lname` instead of uppercase `Lname` in the SELECT list. Do fix the JOIN condition to `T2.actid = T3.actid` instead of the incorrect `T2.actid = T2.actid` which creates a self-join condition. The amended query now correctly joins the activity table and matches the RIGHT_SQL's behavior.",
            "Do use the correct join condition `T2.actid = T2.actid` instead of the incorrect `T2.actid = T3.actid` in the second JOIN clause. Do maintain the same SELECT list with `T1.lname`, FROM sources with `Faculty AS T1`, `Faculty_Participates_in AS T2`, and `Activity AS T3`, WHERE filters with `T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'`, and DISTINCT modifier. The amended query now correctly matches the intended logic by fixing the join predicate while preserving all other query elements.",
            "Do use `T2.actid = T2.actid` instead of `T2.actid = T3.actid` in the JOIN condition between Faculty_Participates_in and Activity tables. This change ensures the join is correctly established between the same table's actid column rather than incorrectly joining to the Activity table's actid, which would create an invalid self-join condition. The amended query now correctly matches the intended logic by maintaining proper table relationships while preserving the same filtering criteria for 'Canoeing' and 'Kayaking' activities."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM faculty WHERE sport = 'Canoeing' OR sport = 'Kayaking';",
            "SELECT DISTINCT T1.Fname FROM Faculty AS T1 JOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID JOIN Activity AS T3 ON T2.actid = T3.actid WHERE T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'",
            "SELECT DISTINCT T1.Lname\nFROM Faculty AS T1\nJOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID\nJOIN Activity AS T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'",
            "SELECT DISTINCT T1.lname\nFROM Faculty AS T1\nJOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID\nJOIN Activity AS T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'",
            "SELECT DISTINCT T1.lname\nFROM Faculty AS T1\nJOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID\nJOIN Activity AS T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'",
            "SELECT DISTINCT T1.lname\nFROM Faculty AS T1\nJOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID\nJOIN Activity AS T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'"
        ],
        "rule_sql": []
    },
    "3040": {
        "db_id": "loan_1",
        "question": "Find the name of customers who do not have a loan with a type of Mortgages.",
        "ground_truth": "SELECT cust_name FROM customer EXCEPT SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id WHERE T2.loan_type  =  'Mortgages'",
        "amends": [
            "Do select `cust_name` instead of `name` and use the `customer` table instead of `customers`. Do use an `EXCEPT` operation to exclude customers with mortgages instead of a simple `WHERE` filter with `!=`. Do add a join between `customer` and `loan` tables on `cust_id` instead of omitting the loan table entirely. Do filter for `loan_type = 'Mortgages'` in the exclusion subquery instead of using inequality comparison. Do properly correlate the subquery through the join condition instead of attempting to filter directly in the main query. The amended query now correctly identifies customers without mortgage loans by excluding those who have them, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for customer names: use the exact column token \"cust_name\" from the customer table instead of \"name\". 2) When the question refers to the customer table: use the exact table name \"customer\" instead of \"customers\". 3) When identifying customers without mortgage loans: use an EXCEPT operation to exclude customers who have loans with type 'Mortgages' instead of a simple inequality filter. 4) When combining customer and loan tables: link rows where customer.cust_id equals loan.cust_id to establish the relationship. 5) When filtering for mortgage loans in the exclusion subquery: use the exact literal 'Mortgages' with equality comparison instead of inequality. 6) When correlating the subquery: ensure the join condition properly connects the main query and subquery through the customer ID relationship."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM customers WHERE loan_type != 'Mortgages';",
            "SELECT cust_name FROM customer EXCEPT SELECT c.cust_name FROM customer c JOIN loan l ON c.cust_ID = l.cust_ID WHERE l.loan_type = 'Mortgages'"
        ],
        "rule_sql": [
            "SELECT cust_name FROM customer\nEXCEPT\nSELECT c.cust_name FROM customer c\nJOIN loan l ON c.cust_ID = l.cust_ID\nWHERE l.loan_type = 'Mortgages'"
        ]
    },
    "5652": {
        "db_id": "railway",
        "question": "Show the countries that have managers of age above 50 or below 46.",
        "ground_truth": "SELECT Country FROM manager WHERE Age  >  50 OR Age  <  46",
        "amends": [
            "Do use table name `manager` instead of `managers` and capitalize column names `Country` and `Age` instead of lowercase `country` and `age`, while maintaining the same filter condition `Age > 50 OR Age < 46` instead of `age > 50 OR age < 46`. The amended query now matches RIGHT_SQL's behavior with corrected table and column naming conventions."
        ],
        "rules": [
            "1) When the question mentions \"countries\": \"countries\" actually means \"Country\" in the manager table. 2) When the question mentions \"managers\": \"managers\" actually means the \"manager\" table. 3) When the question mentions \"age\": \"age\" actually means \"Age\" in the manager table. 4) When filtering for age conditions above 50 or below 46: apply the exact condition Age > 50 OR Age < 46 using the exact column name \"Age\" with proper capitalization."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM managers WHERE age > 50 OR age < 46;",
            "SELECT DISTINCT Country FROM manager WHERE Age > 50 OR Age < 46"
        ],
        "rule_sql": [
            "SELECT DISTINCT Country FROM manager WHERE Age > 50 OR Age < 46"
        ]
    },
    "3918": {
        "db_id": "hospital_1",
        "question": "How many patients stay in room 112?",
        "ground_truth": "SELECT count(patient) FROM stay WHERE room  =  112",
        "amends": [
            "Do count `patient` instead of `*` to count actual patient records rather than all rows. Do query from `stay` table instead of `patients` table to access the correct data source. Do filter on `room` column instead of `room_number` to use the proper column name. Do use numeric value `112` instead of string `'112'` since room numbers are stored as integers rather than strings. Do remove the unnecessary table alias and whitespace formatting differences that don't affect query logic."
        ],
        "rules": [
            "1) When counting patients: count using the canonical key for patient records rather than counting all rows. 2) When accessing patient stay information: query from the \"stay\" table instead of the \"patients\" table to get the correct data source. 3) When filtering by room number: use the \"room\" column instead of \"room_number\" to match the proper column name. 4) When comparing room values: use numeric value 112 instead of string '112' since room numbers are stored as integers rather than strings."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE room_number = '112';",
            "SELECT COUNT(patient) FROM Stay WHERE room = 112"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Patient) FROM Stay WHERE Room = 112;"
        ]
    },
    "1287": {
        "db_id": "game_injury",
        "question": "How many distinct kinds of injuries happened after season 2010?",
        "ground_truth": "SELECT count(DISTINCT T1.injury) FROM injury_accident AS T1 JOIN game AS T2 ON T1.game_id  =  T2.id WHERE T2.season  >  2010",
        "amends": [
            "Do select `count(DISTINCT T1.injury)` instead of `COUNT(*)` to count distinct injury types rather than all rows. Do use `FROM injury_accident AS T1 JOIN game AS T2` instead of `FROM injuries` to join the injury_accident table with the game table. Do add `ON T1.game_id = T2.id` instead of omitting the join condition to properly relate injury records to games. Do move the season filter to `WHERE T2.season > 2010` instead of applying it directly to a non-existent season column in the injuries table, ensuring the filter is correctly applied to the game table's season column. The amended query now correctly counts distinct injury types from games occurring after the 2010 season, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting distinct injury types: use count(DISTINCT T1.injury) instead of COUNT(*) to count unique injury values. 2) When combining injury_accident and game tables: join using T1.game_id = T2.id to properly relate injury records to games. 3) When filtering by season after 2010: apply the condition T2.season > 2010 to the game table's season column instead of a non-existent season column in injury_accident. 4) When answering about distinct kinds of injuries after season 2010: make sure the output order includes only the count of distinct injury types."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM injuries WHERE season > 2010;",
            "SELECT COUNT(DISTINCT T1.Injury) FROM injury_accident AS T1 JOIN game AS T2 ON T1.game_id = T2.id WHERE T2.Season > 2010"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.Injury) FROM injury_accident T1 JOIN game T2 ON T1.game_id = T2.id WHERE T2.Season > 2010"
        ]
    },
    "6944": {
        "db_id": "tracking_orders",
        "question": "Which customers have ever canceled the purchase of the product \"food\" (the item status is \"Cancel\")?",
        "ground_truth": "SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 JOIN order_items AS T3 JOIN products AS T4 ON T1.customer_id = T2.customer_id AND T2.order_id = T3.order_id AND T3.product_id = T4.product_id WHERE T3.order_item_status = \"Cancel\" AND T4.product_name = \"food\" GROUP BY T1.customer_id HAVING count(*)  >=  1",
        "amends": [
            "Do add tables `orders AS T2`, `order_items AS T3`, and `products AS T4` with explicit joins instead of querying only the `customers` table. Do use `JOIN` with proper join conditions `T1.customer_id = T2.customer_id`, `T2.order_id = T3.order_id`, and `T3.product_id = T4.product_id` instead of no joins. Do change the filter to `T3.order_item_status = \"Cancel\"` instead of `status = 'Cancel'` and `T4.product_name = \"food\"` instead of `product = 'food'`. Do add `GROUP BY T1.customer_id` and `HAVING count(*) >= 1` instead of no aggregation. Do qualify the column as `T1.customer_name` instead of just `customer_name`. The amended query now correctly joins multiple tables to find customers with canceled food orders and ensures only customers with at least one matching order are returned."
        ],
        "rules": [
            "1) When answering about customers who canceled food purchases: use tables \"customers AS T1\", \"orders AS T2\", \"order_items AS T3\", and \"products AS T4\" with explicit joins instead of querying only the customers table. 2) When combining tables for shared entities: link rows where T1.customer_id = T2.customer_id, T2.order_id = T3.order_id, and T3.product_id = T4.product_id using inner matches. 3) When the question mentions \"canceled purchase\": use T3.order_item_status = \"Cancel\" instead of status = 'Cancel'. 4) When the question mentions product \"food\": use T4.product_name = \"food\" instead of product = 'food'. 5) When finding customers with at least one matching order: group by T1.customer_id and ensure count(*) >= 1. 6) When selecting customer names: qualify the column as T1.customer_name instead of just customer_name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT customer_name FROM customers WHERE product = 'food' AND status = 'Cancel';",
            "SELECT T1.customer_name\nFROM Customers AS T1\nJOIN Orders AS T2 ON T1.customer_id = T2.customer_id\nJOIN Order_Items AS T3 ON T2.order_id = T3.order_id\nJOIN Products AS T4 ON T3.product_id = T4.product_id\nWHERE T3.order_item_status = 'Cancel' AND T4.product_name = 'food'\nGROUP BY T1.customer_id\nHAVING COUNT(*) >= 1"
        ],
        "rule_sql": [
            "SELECT T1.customer_name\nFROM customers AS T1\nINNER JOIN orders AS T2 ON T1.customer_id = T2.customer_id\nINNER JOIN order_items AS T3 ON T2.order_id = T3.order_id\nINNER JOIN products AS T4 ON T3.product_id = T4.product_id\nWHERE T3.order_item_status = \"Cancel\"\nAND T4.product_name = \"food\"\nGROUP BY T1.customer_id\nHAVING COUNT(*) >= 1;"
        ]
    },
    "3596": {
        "db_id": "music_1",
        "question": "What are the names of all singers that are from the UK and released a song in English?",
        "ground_truth": "SELECT artist_name FROM artist WHERE country  =  \"UK\" INTERSECT SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  \"english\"",
        "amends": [
            "Do select `artist_name` instead of `singer_name` and use `INTERSECT` to combine results instead of a single query. Do change the table reference to `artist` instead of `singers` and use double quotes for string literals instead of single quotes. Do add a join with `song` table on `artist_name` instead of filtering directly in the WHERE clause. Do filter for `languages = \"english\"` in the joined song table instead of `language = 'English'` in the main table. Do use table alias `T1` for artist and `T2` for song instead of no aliases. The amended query now correctly finds artists from the UK who have songs in English, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for singer names: use the exact column token \"artist_name\" instead of \"singer_name\". 2) When combining information about artists and songs: use table alias T1 for \"artist\" table and T2 for \"song\" table. 3) When filtering for country: use T1.\"country\" = \"UK\" with double quotes around the literal. 4) When filtering for language: use T2.\"languages\" = \"english\" with double quotes around the literal and exact column name \"languages\". 5) When joining tables: link rows where T1.\"artist_name\" = T2.\"artist_name\" to match artists with their songs. 6) When combining results from multiple conditions: use INTERSECT operation to find artists that satisfy both conditions (from UK AND have English songs)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT singer_name FROM singers WHERE country = 'UK' AND language = 'English';",
            "SELECT T1.artist_name\nFROM artist T1\nJOIN song T2 ON T1.artist_name = T2.artist_name\nWHERE T1.country = \"UK\"\nINTERSECT\nSELECT T1.artist_name\nFROM artist T1\nJOIN song T2 ON T1.artist_name = T2.artist_name\nWHERE T2.languages = \"english\""
        ],
        "rule_sql": [
            "SELECT T1.artist_name FROM artist T1 WHERE T1.country = \"UK\"\nINTERSECT\nSELECT T2.artist_name FROM song T2 WHERE T2.languages = \"english\""
        ]
    },
    "390": {
        "db_id": "flight_1",
        "question": "What are the departure and arrival dates of all flights from LA to Honolulu?",
        "ground_truth": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  \"Los Angeles\" AND destination  =  \"Honolulu\"",
        "amends": [
            "Do reference table `Flight` instead of `flights` in the FROM clause. Do use double quotes for string literals `\"Los Angeles\"` instead of single quotes `'LA'` in the WHERE condition for the origin column, ensuring accurate matching of the full city name instead of an abbreviated code. The amended query now correctly retrieves departure and arrival dates from the specified table with precise location filtering."
        ],
        "rules": [
            "1) When answering about \"flights from LA to Honolulu\": use table \"Flight\" instead of \"flights\" in the FROM clause. 2) When the question mentions \"LA\": \"LA\" actually means \"Los Angeles\" in schema, so use the exact string literal \"Los Angeles\" for the origin column condition. 3) When the question mentions \"Honolulu\": use the exact string literal \"Honolulu\" for the destination column condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT departure_date, arrival_date FROM flights WHERE origin = 'LA' AND destination = 'Honolulu';",
            "SELECT departure_date, arrival_date FROM flight WHERE origin = \"Los Angeles\" AND destination = \"Honolulu\";"
        ],
        "rule_sql": [
            "SELECT departure_date, arrival_date FROM flight WHERE origin = 'Los Angeles' AND destination = 'Honolulu';"
        ]
    },
    "1223": {
        "db_id": "apartment_rentals",
        "question": "Return the booking start date and end date for the apartments that have type code \"Duplex\".",
        "ground_truth": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  \"Duplex\"",
        "amends": [
            "Do specify `T1.booking_start_date` twice instead of `start_date, end_date` in the SELECT list. Do add `Apartment_Bookings AS T1` and `Apartments AS T2` as FROM sources instead of just `bookings`. Do add `JOIN Apartments AS T2 ON T1.apt_id = T2.apt_id` instead of omitting the join. Do change the filter to `T2.apt_type_code = \"Duplex\"` instead of `apartment_type = 'Duplex'` and move it to reference the joined table. The amended query now correctly joins the booking and apartment tables to filter by apartment type code rather than relying on a potentially incorrect column in the bookings table.",
            "Do select `T1.booking_start_date` twice instead of selecting both `T1.booking_start_date` and `T1.booking_end_date`. The amended query now matches RIGHT_SQL's behavior by returning only the booking start date in both columns."
        ],
        "rules": [
            "1) When answering about \"booking start date and end date\": make sure the output order: T1.booking_start_date, T1.booking_start_date (as end_date). 2) When the question mentions \"apartments that have type code 'Duplex'\": \"type code\" actually means \"T2.apt_type_code in schema\" and the literal must be exactly \"Duplex\". 3) When combining T1 (Apartment_Bookings) and T2 (Apartments) for shared entities: link rows where T1.apt_id = T2.apt_id exactly as shown; keep only matching pairs (inner match). 4) When filtering by apartment type: apply the condition T2.apt_type_code = \"Duplex\" to reference the joined Apartments table rather than the bookings table.",
            "1) When the question asks for both booking start date and booking end date: select both T1.booking_start_date and T1.booking_end_date as separate columns, not the same column twice. 2) When filtering apartments by type code \"Duplex\": use the exact literal \"Duplex\" with double quotes as shown in the schema. 3) When joining Apartment_Bookings and Apartments tables: link rows where T1.apt_id equals T2.apt_id to find matching apartment bookings."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT start_date, end_date FROM bookings WHERE apartment_type = 'Duplex'",
            "SELECT T1.booking_start_date, T1.booking_end_date\nFROM Apartment_Bookings AS T1\nJOIN Apartments AS T2 ON T1.apt_id = T2.apt_id\nWHERE T2.apt_type_code = \"Duplex\"",
            "SELECT T1.booking_start_date, T1.booking_start_date\nFROM Apartment_Bookings AS T1\nJOIN Apartments AS T2 ON T1.apt_id = T2.apt_id\nWHERE T2.apt_type_code = \"Duplex\""
        ],
        "rule_sql": [
            "SELECT T1.booking_start_date, T1.booking_end_date\nFROM Apartment_Bookings T1\nINNER JOIN Apartments T2 ON T1.apt_id = T2.apt_id\nWHERE T2.apt_type_code = 'Duplex'"
        ]
    },
    "3161": {
        "db_id": "station_weather",
        "question": "Find the number and time of the train that goes from Chennai to Guruvayur.",
        "ground_truth": "SELECT train_number ,  TIME FROM train WHERE origin  =  'Chennai' AND destination  =  'Guruvayur'",
        "amends": [
            "Do select `TIME` instead of `departure_time` for the column name. Do reference table `train` instead of `trainS` for the source. Do filter with `origin = 'Chennai'` instead of `origin = 'Guruvayur'` and `destination = 'Guruvayur'` instead of `destination = 'Chennai'`, effectively reversing the origin and destination criteria. The amended query now correctly matches the RIGHT_SQL's behavior by selecting trains from Chennai to Guruvayur rather than from Guruvayur to Chennai."
        ],
        "rules": [
            "1) When the question asks for trains going from Chennai to Guruvayur: use origin = 'Chennai' and destination = 'Guruvayur' as filter conditions. 2) When selecting time information: use the column name \"TIME\" instead of \"departure_time\". 3) When referencing the train table: use the exact table name \"train\" (singular) instead of \"trains\" (plural)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT train_number, departure_time FROM trains WHERE origin = 'Guruvayur' AND destination = 'Chennai';",
            "SELECT train_number, time FROM train WHERE origin = 'Chennai' AND destination = 'Guruvayur'"
        ],
        "rule_sql": [
            "SELECT train_number, time FROM train WHERE origin = 'Chennai' AND destination = 'Guruvayur';"
        ]
    },
    "414": {
        "db_id": "flight_1",
        "question": "What are the flight numbers for the aircraft Airbus A340-300?",
        "ground_truth": "SELECT T1.flno FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid WHERE T2.name  =  \"Airbus A340-300\"",
        "amends": [
            "Do reference `T1.flno` instead of `flight_number` in the SELECT list. Do join `Flight AS T1` with `Aircraft AS T2` instead of querying only the `flights` table. Do use the join condition `T1.aid = T2.aid` instead of directly filtering by aircraft name. Do filter on `T2.name = \"Airbus A340-300\"` in the WHERE clause instead of using `aircraft = 'Airbus A340-300'`. The amended query now correctly joins the Flight and Aircraft tables to filter by aircraft name through the proper relationship."
        ],
        "rules": [
            "1) When answering about \"flight numbers for aircraft Airbus A340-300\": make sure the output order: T1.flno\n2) When the question mentions \"flight numbers\": \"flight numbers\" actually means \"T1.flno in schema\"\n3) When the question mentions \"Airbus A340-300\": use the exact literal \"Airbus A340-300\" for filtering\n4) When combining T1 (Flight) and T2 (Aircraft) for shared entities: link rows where T1.aid = T2.aid exactly as shown in the amends; keep only matching pairs (inner match)\n5) When filtering by aircraft name: use T2.name = \"Airbus A340-300\" instead of directly filtering the flights table by aircraft name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE aircraft = 'Airbus A340-300';",
            "SELECT T1.flno \nFROM flight AS T1 \nJOIN aircraft AS T2 ON T1.aid = T2.aid \nWHERE T2.name = 'Airbus A340-300'"
        ],
        "rule_sql": [
            "SELECT T1.flno\nFROM flight T1\nINNER JOIN aircraft T2 ON T1.aid = T2.aid\nWHERE T2.name = 'Airbus A340-300'\nORDER BY T1.flno"
        ]
    },
    "5528": {
        "db_id": "products_gen_characteristics",
        "question": "What are the names of products with category \"Spices\"?",
        "ground_truth": "SELECT product_name FROM products WHERE product_category_code  =  \"Spices\"",
        "amends": [
            "Do select `product_name` instead of `name` and filter on `product_category_code` instead of `category`. Do use double quotes `\"Spices\"` instead of single quotes `'Spices'` for the string literal. The amended query now correctly references the actual column names and matches the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"names of products\": select \"product_name\" from table \"Products\" (T1). 2) When the question mentions \"category 'Spices'\": filter rows where \"product_category_code\" equals exactly \"Spices\". 3) When handling text literals: use double quotes around string values exactly as shown in the schema (\"Spices\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM products WHERE category = 'Spices';",
            "SELECT product_name FROM Products WHERE product_category_code = \"Spices\";"
        ],
        "rule_sql": [
            "SELECT product_name FROM Products WHERE product_category_code = \"Spices\""
        ]
    },
    "5674": {
        "db_id": "dorm_1",
        "question": "Find the first name of students who is older than 20.",
        "ground_truth": "SELECT fname FROM student WHERE age  >  20",
        "amends": [
            "Do select `fname` instead of `first_name` and use table `student` instead of `students`. Do filter with `age > 20` instead of `age < 20` to include only students older than 20 rather than younger than 20. The amended query now correctly retrieves first names from the student table for those over 20 years old."
        ],
        "rules": [
            "1) When the question asks for \"first name\" of students: use the exact column token \"fname\" instead of \"first_name\". 2) When referring to the student table: use the exact table name \"student\" instead of \"students\". 3) When filtering for students older than 20: use the condition age > 20 instead of age < 20 to include only those over 20 years old."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE age < 20;",
            "SELECT fname FROM Student WHERE age > 20;"
        ],
        "rule_sql": [
            "SELECT fname FROM student WHERE age > 20"
        ]
    },
    "4183": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "What are all the location codes and location names?",
        "ground_truth": "SELECT location_code ,  location_name FROM Ref_locations",
        "amends": [
            "Do reference the `Ref_locations` table instead of the `locations` table in the FROM clause. Do remove the `WHERE location_id > 100` filter instead of keeping it, as the right query retrieves all records without filtering. The amended query now correctly selects all location codes and names from the reference locations table without unnecessary filtering, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"all location codes and location names\": make sure the output order: location_code, location_name. 2) When the question asks for all records without filtering: do not apply any WHERE clause conditions. 3) When selecting from the reference locations table: use the exact table name \"Ref_locations\" as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location_code, location_name FROM locations WHERE location_id > 100;",
            "SELECT Location_Code, Location_Name FROM Ref_Locations;"
        ],
        "rule_sql": [
            "SELECT Location_Code, Location_Name FROM Ref_Locations;"
        ]
    },
    "6629": {
        "db_id": "driving_school",
        "question": "What are the first, middle, and last names of all staff?",
        "ground_truth": "SELECT first_name ,  middle_name ,  last_name FROM Staff;",
        "amends": [
            "Do add `middle_name` to the SELECT list instead of omitting it, and use the correct table name `Staff` instead of `staff` with proper casing. The amended query now correctly includes all required name fields and references the proper table to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"first, middle, and last names of all staff\": include all three name fields in the output columns in the order: first_name, middle_name, last_name. 2) When referring to the staff table: use the exact table name \"Staff\" with proper casing instead of lowercase \"staff\". 3) When selecting from the Staff table: ensure all three name columns (first_name, middle_name, last_name) are included in the output to match the question's request for complete name information."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM staff;",
            "SELECT first_name, middle_name, last_name FROM Staff;"
        ],
        "rule_sql": [
            "SELECT first_name, middle_name, last_name FROM Staff;"
        ]
    },
    "6481": {
        "db_id": "scientist_1",
        "question": "List the name of all projects that are operated longer than the average working hours of all projects.",
        "ground_truth": "SELECT name FROM projects WHERE hours  >  (SELECT avg(hours) FROM projects)",
        "amends": [
            "Do reference column `hours` instead of `working_hours` in both the main query filter and the subquery aggregate. Do use lowercase `avg` function instead of uppercase `AVG` while maintaining the same aggregation logic. The amended query now correctly filters projects where hours exceed the average hours across all projects, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"working hours\": \"working hours\" actually means \"hours\" in the schema. 2) When computing the average of working hours: use the lowercase \"avg\" function on the \"hours\" column. 3) When filtering projects by hours greater than average: compare each project's \"hours\" value against the average of all \"hours\" values from the projects table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM projects WHERE working_hours > (SELECT AVG(working_hours) FROM projects);",
            "SELECT Name FROM Projects WHERE hours > (SELECT avg(hours) FROM Projects)"
        ],
        "rule_sql": [
            "SELECT Name FROM Projects WHERE hours > (SELECT AVG(hours) FROM Projects)"
        ]
    },
    "2943": {
        "db_id": "sakila_1",
        "question": "What are the countries that contain 3 or more cities?",
        "ground_truth": "SELECT T2.country FROM city AS T1 JOIN country AS T2 ON T1.country_id  =  T2.country_id GROUP BY T2.country_id HAVING count(*)  >=  3",
        "amends": [
            "Do join `country AS T2` instead of querying `cities` alone. Do reference `T2.country` in SELECT instead of just `country`. Do add join condition `ON T1.country_id = T2.country_id` instead of missing table relationships. Do group by `T2.country_id` instead of `country` to ensure proper aggregation. The amended query now correctly joins tables and uses proper table aliases to match the intended behavior."
        ],
        "rules": [
            "1) When answering about countries with 3 or more cities: join table \"country\" as T2 with the cities table using T1.country_id = T2.country_id to establish the relationship between cities and countries. 2) When grouping by country for aggregation: use T2.country_id as the grouping key instead of the country name to ensure proper aggregation. 3) When selecting the country name in the output: reference T2.country instead of just country to specify the exact table source. 4) When counting cities per country: count the number of cities using the canonical key from the cities table and filter for countries with count >= 3."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM cities GROUP BY country HAVING COUNT(*) >= 3;",
            "SELECT T2.country\nFROM city AS T1\nJOIN country AS T2 ON T1.country_id = T2.country_id\nGROUP BY T2.country_id\nHAVING COUNT(*) >= 3"
        ],
        "rule_sql": [
            "SELECT T2.country\nFROM city T1\nJOIN country T2 ON T1.country_id = T2.country_id\nGROUP BY T2.country_id\nHAVING COUNT(*) >= 3;"
        ]
    },
    "3283": {
        "db_id": "college_1",
        "question": "What is the code of the course which the student whose last name is Smithson took?",
        "ground_truth": "SELECT T1.crs_code FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T3.stu_num  =  T2.stu_num WHERE T3.stu_lname  =  'Smithson'",
        "amends": [
            "Do select `T1.crs_code` instead of `course_code` from the wrong table. Do join `CLASS AS T1` instead of querying only the `students` table. Do add `enroll AS T2` with join condition `T1.class_code = T2.class_code` instead of missing this relationship. Do add `student AS T3` with join condition `T3.stu_num = T2.stu_num` instead of directly filtering students. Do filter on `T3.stu_lname = 'Smithson'` instead of `last_name = 'Smithson'` to use the correct column name and table reference. The amended query now correctly retrieves course codes by properly joining through the enrollment relationship to find students with the specified last name."
        ],
        "rules": [
            "1) When answering about course codes for a student with last name Smithson: make sure the output order: T1.crs_code. 2) When the question mentions \"course code\": \"course code\" actually means \"T1.crs_code\" in schema. 3) When the question mentions \"student whose last name is Smithson\": filter using T3.stu_lname = 'Smithson' exactly as written. 4) When combining CLASS (T1) and enroll (T2): link rows where T1.class_code = T2.class_code exactly and keep only matching pairs (inner match). 5) When combining enroll (T2) and student (T3): link rows where T3.stu_num = T2.stu_num exactly and keep only matching pairs (inner match). 6) When choosing identifier delimiters: do not replace the unquoted forms shown in the amends with quoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_code FROM students WHERE last_name = 'Smithson';",
            "SELECT T1.CRS_CODE \nFROM CLASS AS T1\nJOIN ENROLL AS T2 ON T1.CLASS_CODE = T2.CLASS_CODE\nJOIN STUDENT AS T3 ON T3.STU_NUM = T2.STU_NUM\nWHERE T3.STU_LNAME = 'Smithson'"
        ],
        "rule_sql": [
            "SELECT T1.CRS_CODE\nFROM CLASS T1\nINNER JOIN ENROLL T2 ON T1.CLASS_CODE = T2.CLASS_CODE\nINNER JOIN STUDENT T3 ON T3.STU_NUM = T2.STU_NUM\nWHERE T3.STU_LNAME = 'Smithson'"
        ]
    },
    "6831": {
        "db_id": "flight_4",
        "question": "Find the name, city, and country of the airport that has the highest latitude.",
        "ground_truth": "SELECT name ,  city ,  country FROM airports ORDER BY elevation DESC LIMIT 1",
        "amends": [
            "Do order by `elevation DESC` instead of `latitude ASC` to sort by elevation in descending order rather than latitude in ascending order. The amended query now matches the RIGHT_SQL's behavior by correctly selecting the airport with the highest elevation rather than the southernmost airport.",
            "Do order by `elevation` instead of `x` in the ORDER BY clause, as the column `x` does not exist in the schema while `elevation` is the correct column to sort airports by their height above sea level. The amended query now correctly sorts airports by elevation in descending order and returns the top result, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for the airport with the highest latitude: use the \"elevation\" column instead of the \"latitude\" column to determine the highest value. 2) When ordering by elevation to find the highest value: sort in descending order (highest to lowest) rather than ascending order. 3) When selecting airport information: include the name, city, and country columns from the airports table.",
            "1) When the question asks for the airport with the highest latitude: use the \"elevation\" column instead of \"x\" column to determine height above sea level. 2) When ordering airports by elevation to find the highest: sort in descending order and return only the top result. 3) When selecting output columns for airport information: include name, city, and country exactly as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, city, country FROM airports ORDER BY latitude ASC LIMIT 1;",
            "SELECT name, city, country FROM airports ORDER BY x DESC LIMIT 1;",
            "SELECT name, city, country FROM airports ORDER BY elevation DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT name, city, country FROM airports ORDER BY elevation DESC LIMIT 1;"
        ]
    },
    "344": {
        "db_id": "flight_1",
        "question": "How many aircrafts exist in the database?",
        "ground_truth": "SELECT count(*) FROM Aircraft",
        "amends": [
            "Do reference the `Aircraft` table instead of the `airplanes` table. The amended query now correctly counts all records from the Aircraft table."
        ],
        "rules": [
            "1) When answering about \"how many aircrafts exist in the database\": make sure to count all records from the \"Aircraft\" table. 2) When the question mentions \"aircrafts\": \"aircrafts\" actually means \"Aircraft\" table in the schema. 3) When counting aircraft entities: use the canonical counting method for all records in the \"Aircraft\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM airplanes;",
            "SELECT COUNT(*) FROM aircraft;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM aircraft;"
        ]
    },
    "314": {
        "db_id": "product_catalog",
        "question": "What are the name and publication date of the catalogs with catalog level number above 5?",
        "ground_truth": "SELECT t1.catalog_name ,  t1.date_of_publication FROM catalogs AS t1 JOIN catalog_structure AS t2 ON t1.catalog_id  =  t2.catalog_id WHERE catalog_level_number  >  5",
        "amends": [
            "Do select `t1.catalog_name` and `t1.date_of_publication` instead of `name` and `publication_date`. Do add `JOIN catalog_structure AS t2` instead of querying only the `catalogs` table. Do use join condition `ON t1.catalog_id = t2.catalog_id` instead of no join condition. Do filter on `catalog_level_number > 5` instead of `catalog_level > 5`. The amended query now correctly joins the catalog structure table and filters on the appropriate level column, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"name\" and \"publication date\" of catalogs: use \"t1.catalog_name\" and \"t1.date_of_publication\" as the exact output columns instead of generic \"name\" and \"publication_date\". 2) When combining catalog information with catalog structure: join \"catalogs\" as T1 with \"catalog_structure\" as T2 using the condition \"t1.catalog_id = t2.catalog_id\" to link related records. 3) When filtering for catalogs with level number above 5: use the exact condition \"catalog_level_number > 5\" instead of \"catalog_level > 5\" to match the schema's column naming. 4) When answering about catalogs with catalog level number above 5: make sure the output order is \"t1.catalog_name\" followed by \"t1.date_of_publication\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, publication_date FROM catalogs WHERE catalog_level > 5;",
            "SELECT t1.catalog_name, t1.date_of_publication \nFROM Catalogs AS t1\nJOIN Catalog_Structure AS t2 ON t1.catalog_id = t2.catalog_id\nWHERE t2.catalog_level_number > 5"
        ],
        "rule_sql": [
            "SELECT t1.catalog_name, t1.date_of_publication\nFROM Catalogs t1\nJOIN Catalog_Structure t2 ON t1.catalog_id = t2.catalog_id\nWHERE t2.catalog_level_number > 5\nORDER BY t1.catalog_name, t1.date_of_publication;"
        ]
    },
    "3824": {
        "db_id": "e_learning",
        "question": "What are the descriptions and names of the courses that have student enrollment bigger than 2?",
        "ground_truth": "SELECT T1.course_description ,  T1.course_name FROM Courses AS T1 JOIN Student_Course_Enrolment AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name HAVING COUNT(*)  >  2",
        "amends": [
            "Do select `T1.course_description` and `T1.course_name` instead of `course_name` and `description`. Do use `FROM Courses AS T1 JOIN Student_Course_Enrolment AS T2` instead of `FROM courses` alone. Do add join condition `ON T1.course_id = T2.course_id` instead of omitting any join. Do add `GROUP BY T1.course_name` instead of grouping by nothing. Do move the count filter to `HAVING COUNT(*) > 2` instead of using `WHERE student_enrollment > 2`. The amended query now correctly counts actual student enrollments through the join rather than relying on a potentially incorrect column value, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for course descriptions and names: select T1.course_description and T1.course_name in that order instead of course_name and description. 2) When counting student enrollments for courses: use FROM Courses AS T1 JOIN Student_Course_Enrolment AS T2 with join condition ON T1.course_id = T2.course_id to link enrollment records to courses. 3) When filtering by enrollment count greater than 2: use GROUP BY T1.course_name and HAVING COUNT(*) > 2 instead of WHERE student_enrollment > 2 to count actual student enrollments through the join. 4) When combining Courses and Student_Course_Enrolment tables: perform an inner match where T1.course_id = T2.course_id to keep only courses with enrollment records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_name, description FROM courses WHERE student_enrollment > 2;",
            "SELECT T1.course_description, T1.course_name\nFROM Courses AS T1\nJOIN Student_Course_Enrolment AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_name\nHAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT T1.course_description, T1.course_name\nFROM Courses AS T1\nJOIN Student_Course_Enrolment AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_name\nHAVING COUNT(*) > 2"
        ]
    },
    "1712": {
        "db_id": "epinions_1",
        "question": "Find the name of the source user with the highest average trust score.",
        "ground_truth": "SELECT T1.name FROM useracct AS T1 JOIN trust AS T2 ON T1.u_id  =  T2.source_u_id GROUP BY T2.source_u_id ORDER BY avg(trust) DESC LIMIT 1",
        "amends": [
            "Do select `T1.name` with table alias instead of just `name` without qualification. Do add `FROM useracct AS T1 JOIN trust AS T2` with explicit table aliases and join instead of just `FROM users`. Do add `ON T1.u_id = T2.source_u_id` join condition instead of omitting any join predicate. Do add `GROUP BY T2.source_u_id` aggregation instead of operating on individual rows. Do change ordering to `ORDER BY avg(trust) DESC` based on average trust score instead of `ORDER BY trust_score DESC` based on individual scores. The amended query now correctly calculates average trust scores per user and returns the user with the highest average, matching RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"source user with the highest average trust score\": make sure the output order: T1.name 2) When combining useracct and trust tables: link rows where T1.u_id = T2.source_u_id exactly as shown; keep only matching pairs (inner match). 3) When the question asks for \"highest average trust score\": rank rows by average trust score in descending order and keep the first 1 row. 4) When the question asks for \"average trust score per user\": organize results by T2.source_u_id and compute average trust per group. 5) When selecting user names: use T1.name with table alias qualification instead of just name without qualification."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM users ORDER BY trust_score DESC LIMIT 1;",
            "SELECT T1.name\nFROM useracct AS T1\nJOIN trust AS T2 ON T1.u_id = T2.source_u_id\nGROUP BY T2.source_u_id\nORDER BY AVG(T2.trust) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.name\nFROM useracct T1\nINNER JOIN trust T2 ON T1.u_id = T2.source_u_id\nGROUP BY T2.source_u_id\nORDER BY AVG(T2.trust) DESC\nLIMIT 1;"
        ]
    },
    "2030": {
        "db_id": "gas_company",
        "question": "What are the locations that have gas stations owned by a company with a market value greater than 100?",
        "ground_truth": "SELECT T3.location FROM station_company AS T1 JOIN company AS T2 ON T1.company_id  =  T2.company_id JOIN gas_station AS T3 ON T1.station_id  =  T3.station_id WHERE T2.market_value  >  100",
        "amends": [
            "Do use explicit table joins with `station_company AS T1 JOIN company AS T2 ON T1.company_id = T2.company_id JOIN gas_station AS T3 ON T1.station_id = T3.station_id` instead of querying a single `gas_stations` table. Do reference the location column as `T3.location` instead of just `location` without table qualification. Do filter on `T2.market_value > 100` instead of `company_market_value > 100` to properly access the market value from the company table. Do add the necessary join conditions `T1.company_id = T2.company_id` and `T1.station_id = T3.station_id` instead of omitting the table relationships entirely. The amended query now correctly joins the three related tables to filter stations based on their associated company's market value, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about gas station locations with company market value conditions: make sure the output order: T3.location 2) When the question mentions \"gas stations owned by a company\": this requires joining three tables - station_company as T1, company as T2, and gas_station as T3 3) When combining T1 and T2 for shared entities: link rows where T1.company_id = T2.company_id and keep only matching pairs (inner match) 4) When combining T1 and T3 for shared entities: link rows where T1.station_id = T3.station_id and keep only matching pairs (inner match) 5) When the question mentions \"market value greater than 100\": filter using T2.market_value > 100 instead of company_market_value 6) When referencing location information: use T3.location instead of unqualified location"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location FROM gas_stations WHERE company_market_value > 100",
            "SELECT DISTINCT T3.location \nFROM station_company AS T1 \nJOIN company AS T2 ON T1.Company_ID = T2.Company_ID \nJOIN gas_station AS T3 ON T1.Station_ID = T3.Station_ID \nWHERE T2.Market_Value > 100"
        ],
        "rule_sql": [
            "SELECT T3.location FROM station_company AS T1 JOIN company AS T2 ON T1.company_id = T2.company_id JOIN gas_station AS T3 ON T1.station_id = T3.station_id WHERE T2.market_value > 100 ORDER BY T3.location"
        ]
    },
    "6546": {
        "db_id": "wine_1",
        "question": "What is the maximum price of wines from the appelation in the Central Coast area, which was produced before 2005?",
        "ground_truth": "SELECT max(T2.Price) FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.Area  =  \"Central Coast\" AND T2.year  <  2005",
        "amends": [
            "Do join `APPELLATIONS` and `WINE` tables instead of querying only `wines`; do use `T1.Appelation = T2.Appelation` as the join condition instead of filtering directly on `appelation`; do filter on `T1.Area = \"Central Coast\"` instead of `appelation = 'Central Coast'`; do keep `T2.year < 2005` filter but reference it through the joined table instead of directly; do select `max(T2.Price)` with proper table qualification instead of `MAX(price)` without qualification. The amended query now correctly joins the appellations table to filter by area and matches the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about maximum price of wines from an appellation in a specific area produced before a certain year: make sure the output order: maximum price\n2) When the question mentions \"Central Coast area\": \"Central Coast\" actually means \"Area = 'Central Coast'\" in schema\n3) When the question mentions \"appelation\": join APPELLATIONS table (T1) and WINE table (T2) using T1.Appelation = T2.Appelation\n4) When filtering by area: use T1.Area = \"Central Coast\" instead of filtering directly on appelation\n5) When filtering by production year before 2005: use T2.year < 2005 through the joined WINE table\n6) When computing maximum price: use max(T2.Price) with proper table qualification\n7) When combining APPELLATIONS and WINE tables: link rows where T1.Appelation = T2.Appelation and keep only matching pairs (inner match)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(price) FROM wines WHERE appelation = 'Central Coast' AND year < 2005;",
            "SELECT MAX(w.Price) \nFROM wine w\nJOIN appellations a ON w.Appelation = a.Appelation\nWHERE a.Area = 'Central Coast' \nAND w.Year < 2005"
        ],
        "rule_sql": [
            "SELECT MAX(w.Price) AS \"maximum price\"\nFROM wine w\nJOIN appellations a ON w.Appelation = a.Appelation\nWHERE a.Area = 'Central Coast'\nAND w.Year < 2005"
        ]
    },
    "4585": {
        "db_id": "solvency_ii",
        "question": "What are the names and type codes of products?",
        "ground_truth": "SELECT Product_Name ,  Product_Type_Code FROM Products",
        "amends": [
            "Do select `Product_Name` and `Product_Type_Code` instead of `name` and `price`. Do use the exact column names `Product_Name` and `Product_Type_Code` instead of the incorrect `name` and `price` that don't match the schema. The amended query now correctly retrieves product name and type information instead of attempting to access non-existent price data, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"names and type codes of products\": select the exact columns \"Product_Name\" and \"Product_Type_Code\" from the Products table. 2) When the schema shows column names with exact case and formatting: use \"Product_Name\" and \"Product_Type_Code\" exactly as specified, not simplified versions like \"name\" or \"price\". 3) When producing output for product information: maintain the order of columns as \"Product_Name\" followed by \"Product_Type_Code\" to match the question's request sequence."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, price FROM products;",
            "SELECT Product_Name, Product_Type_Code FROM Products;"
        ],
        "rule_sql": [
            "SELECT Product_Name, Product_Type_Code FROM Products;"
        ]
    },
    "3940": {
        "db_id": "hospital_1",
        "question": "What is the names of the physicians who prescribe medication Thesisin?",
        "ground_truth": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  \"Thesisin\"",
        "amends": [
            "Do add `DISTINCT` to eliminate duplicates instead of omitting it. Do change the source from `physicians` table to joining `physician AS T1`, `prescribes AS T2`, and `medication AS T3` instead of querying a single table. Do use `JOIN` with `T1.employeeid = T2.physician` and `T3.code = T2.medication` instead of no joins. Do move the filter from `medication = 'Thesisin'` to `T3.name = \"Thesisin\"` instead of filtering on the wrong column. Do reference `T1.name` instead of just `name`. The amended query now correctly identifies physicians who prescribe Thesisin medication through proper table relationships."
        ],
        "rules": [
            "1) When answering about \"names of physicians who prescribe medication Thesisin\": make sure the output order: T1.name. 2) When the question mentions \"physicians\": \"physicians\" actually means \"physician AS T1\" in schema. 3) When the question mentions \"prescribe medication Thesisin\": this requires joining prescribes AS T2 and medication AS T3 tables with T1.employeeid = T2.physician and T3.code = T2.medication. 4) When filtering for medication \"Thesisin\": use T3.name = \"Thesisin\" exactly as specified. 5) When eliminating duplicate physician names: use DISTINCT on T1.name. 6) When combining tables for shared entities: link rows where T1.employeeid = T2.physician and T3.code = T2.medication; keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM physicians WHERE medication = 'Thesisin';",
            "SELECT DISTINCT T1.Name \nFROM Physician AS T1\nJOIN Prescribes AS T2 ON T1.EmployeeID = T2.Physician\nJOIN Medication AS T3 ON T3.Code = T2.Medication\nWHERE T3.Name = 'Thesisin'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Name\nFROM Physician AS T1\nJOIN Prescribes AS T2 ON T1.EmployeeID = T2.Physician\nJOIN Medication AS T3 ON T3.Code = T2.Medication\nWHERE T3.Name = 'Thesisin'\nORDER BY T1.Name;"
        ]
    },
    "6905": {
        "db_id": "tracking_orders",
        "question": "Give me the names of customers who have placed orders between 2009-01-01 and 2010-01-01.",
        "ground_truth": "SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T2.date_order_placed >= \"2009-01-01\" AND T2.date_order_placed <= \"2010-01-01\"",
        "amends": [
            "Do select `T1.customer_name` instead of `name` and add table alias `T1`. Do add `JOIN orders AS T2` instead of querying only the `customers` table. Do use join condition `ON T1.customer_id = T2.customer_id` instead of no join. Do filter on `T2.date_order_placed` with explicit range conditions `>= \"2009-01-01\" AND <= \"2010-01-01\"` instead of filtering on `order_date` using `BETWEEN`. The amended query now correctly joins customer and order tables and filters on the order placement date to match the intended behavior."
        ],
        "rules": [
            "1) When answering about customer names who placed orders in a date range: make sure the output order: T1.customer_name. 2) When the question mentions \"customers who have placed orders\": join tables \"customers\" as T1 and \"orders\" as T2 using the exact condition T1.customer_id = T2.customer_id. 3) When the question specifies orders between 2009-01-01 and 2010-01-01: filter on T2.date_order_placed with the exact range conditions >= \"2009-01-01\" AND <= \"2010-01-01\". 4) When selecting customer names: use the exact column token T1.customer_name instead of generic \"name\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM customers WHERE order_date BETWEEN '2009-01-01' AND '2010-01-01';",
            "SELECT T1.customer_name\nFROM Customers AS T1\nJOIN Orders AS T2 ON T1.customer_id = T2.customer_id\nWHERE T2.date_order_placed >= '2009-01-01' AND T2.date_order_placed <= '2010-01-01'"
        ],
        "rule_sql": [
            "SELECT T1.customer_name\nFROM Customers AS T1\nJOIN Orders AS T2 ON T1.customer_id = T2.customer_id\nWHERE T2.date_order_placed >= '2009-01-01' AND T2.date_order_placed <= '2010-01-01'\nORDER BY T1.customer_name;"
        ]
    },
    "2356": {
        "db_id": "csu_1",
        "question": "report the total number of degrees granted between 1998 and 2002.",
        "ground_truth": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  1998 AND T2.year  <=  2002 GROUP BY T1.campus",
        "amends": [
            "Do add `T1.campus` and `sum(T2.degrees)` instead of `COUNT(*)` for proper aggregation. Do add `FROM campuses AS T1 JOIN degrees AS T2` instead of only `FROM degrees` to include the campuses table. Do add `ON T1.id = T2.campus` instead of omitting the join condition to properly relate campuses and degrees. Do change the filter to `T2.year >= 1998 AND T2.year <= 2002` instead of `year BETWEEN 1998 AND 2002` for explicit range specification. Do add `GROUP BY T1.campus` instead of omitting grouping to aggregate degrees by campus. The amended query now correctly calculates the sum of degrees per campus within the specified year range instead of counting all degree records."
        ],
        "rules": [
            "1) When answering about \"total number of degrees granted\": use sum(T2.degrees) instead of COUNT(*) to properly aggregate degree counts. 2) When combining campuses and degrees tables: link rows where T1.id = T2.campus to properly relate campuses and degrees. 3) When filtering by year range 1998 to 2002: use T2.year >= 1998 AND T2.year <= 2002 for explicit inclusive range specification. 4) When aggregating degrees by campus: include GROUP BY T1.campus to organize results by campus. 5) When the question asks for total degrees across all campuses: ensure the output includes sum(T2.degrees) as the aggregated result."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM degrees WHERE year BETWEEN 1998 AND 2002;",
            "SELECT T1.Campus, SUM(T2.Degrees) \nFROM Campuses AS T1 \nJOIN degrees AS T2 ON T1.Id = T2.Campus \nWHERE T2.Year >= 1998 AND T2.Year <= 2002 \nGROUP BY T1.Campus"
        ],
        "rule_sql": [
            "SELECT SUM(d.Degrees) \nFROM degrees d \nWHERE d.Year >= 1998 AND d.Year <= 2002"
        ]
    },
    "4271": {
        "db_id": "club_1",
        "question": "Give me the first name and last name for all the female members of the club \"Bootup Baltimore\".",
        "ground_truth": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.sex  =  \"F\"",
        "amends": [
            "Do select `t3.fname` and `t3.lname` instead of `first_name` and `last_name`. Do join from `club AS t1` instead of querying `members` directly. Do add `JOIN member_of_club AS t2 ON t1.clubid = t2.clubid` and `JOIN student AS t3 ON t2.stuid = t3.stuid` instead of single table access. Do filter on `t1.clubname = \"Bootup Baltimore\"` instead of `club_name = 'male'` and use `t3.sex = \"F\"` instead of `gender = 'male'`. The amended query now correctly joins through the relationship tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"first name and last name for female members\": select \"t3.fname\" and \"t3.lname\" as output columns. 2) When the question mentions \"female members\": filter using \"t3.sex = \\\"F\\\"\" exactly. 3) When the question mentions \"club 'Bootup Baltimore'\": filter using \"t1.clubname = \\\"Bootup Baltimore\\\"\" exactly. 4) When combining tables for club membership relationships: link \"club AS t1\" with \"member_of_club AS t2\" where \"t1.clubid = t2.clubid\" and link \"member_of_club AS t2\" with \"student AS t3\" where \"t2.stuid = t3.stuid\", keeping only matching pairs (inner match). 5) When handling identifier delimiters: use double quotes for identifiers like \"t3.fname\", \"t3.lname\", \"t3.sex\", and \"t1.clubname\" as shown in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM members WHERE gender = 'male' AND club_name = 'Bootup Baltimore';",
            "SELECT t3.Fname, t3.LName \nFROM Club AS t1 \nJOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID \nJOIN Student AS t3 ON t2.StuID = t3.StuID \nWHERE t1.ClubName = 'Bootup Baltimore' AND t3.Sex = 'F'"
        ],
        "rule_sql": [
            "SELECT t3.fname, t3.lname FROM Club AS t1 INNER JOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID INNER JOIN Student AS t3 ON t2.StuID = t3.StuID WHERE t1.ClubName = \"Bootup Baltimore\" AND t3.Sex = \"F\""
        ]
    },
    "5332": {
        "db_id": "manufactory_1",
        "question": "Compute the average price of all products with manufacturer code equal to 2.",
        "ground_truth": "SELECT avg(price) FROM products WHERE Manufacturer  =  2",
        "amends": [
            "Do reference the column `Manufacturer` instead of `manufacturer_id` in the WHERE filter, maintaining the same filter condition of `= 2` but using the correct column name. Do use the lowercase function name `avg` instead of uppercase `AVG` for the aggregate function, though this is a cosmetic difference that does not affect functionality. The amended query now correctly filters by the Manufacturer column and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question mentions \"manufacturer code equal to 2\": use the exact column token \"Manufacturer\" with literal value 2 for filtering. 2) When computing the average price: use the lowercase function name \"avg\" for the aggregate calculation. 3) When filtering products by manufacturer: maintain the exact equality condition \"= 2\" using the Manufacturer column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(price) FROM products WHERE manufacturer_id = 2;",
            "SELECT avg(Price) FROM Products WHERE Manufacturer = 2"
        ],
        "rule_sql": [
            "SELECT avg(Price) FROM Products WHERE Manufacturer = 2"
        ]
    },
    "322": {
        "db_id": "product_catalog",
        "question": "Give me the average and minimum price (in Euro) of the products.",
        "ground_truth": "SELECT avg(price_in_euros) ,  min(price_in_euros) FROM catalog_contents",
        "amends": [
            "Do reference table `catalog_contents` instead of `products` and use columns `price_in_euros` instead of `price` for both aggregate functions. Do remove the explicit aliases `average_price` and `minimum_price` instead of keeping them, allowing the database to generate default column names. The amended query now correctly calculates aggregates from the appropriate table and column while matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"average and minimum price (in Euro) of the products\": use table \"catalog_contents\" instead of \"products\" and column \"price_in_euros\" instead of \"price\" for both aggregate functions. 2) When computing aggregates for price in Euros: calculate the average and minimum values from the \"price_in_euros\" column without assigning explicit aliases to the output columns. 3) When the question specifies \"in Euro\": ensure the exact column \"price_in_euros\" is used rather than any other price-related column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(price) as average_price, MIN(price) as minimum_price FROM products;",
            "SELECT AVG(price_in_euros) AS average_price, MIN(price_in_euros) AS minimum_price FROM Catalog_Contents;"
        ],
        "rule_sql": [
            "SELECT AVG(price_in_euros), MIN(price_in_euros) FROM Catalog_Contents;"
        ]
    },
    "1421": {
        "db_id": "college_2",
        "question": "What are the names of courses without prerequisites?",
        "ground_truth": "SELECT title FROM course WHERE course_id NOT IN (SELECT course_id FROM prereq)",
        "amends": [
            "Do select `title` instead of `course_name` and use a `NOT IN` subquery instead of `IS NOT NULL` filtering. Do reference table `course` instead of `courses` and remove the `prerequisite_id` column reference. Do add a subquery `SELECT course_id FROM prereq` instead of omitting it, which correctly identifies courses that have prerequisites by checking against the prereq table rather than relying on a nullable column. The amended query now matches RIGHT_SQL's behavior by properly identifying courses with existing prerequisites through a relational check rather than null validation."
        ],
        "rules": [
            "1) When the question asks for course names: use the exact column token \"title\" from the course table instead of \"course_name\". 2) When identifying courses without prerequisites: use a NOT IN subquery against the prereq table's course_id column rather than checking for NULL values in a prerequisite_id column. 3) When referencing the course table: use the exact table name \"course\" (singular) instead of \"courses\" (plural). 4) When constructing the subquery to identify courses with prerequisites: select \"course_id\" from the \"prereq\" table to properly identify courses that have existing prerequisites through relational checks."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_name FROM courses WHERE prerequisite_id IS NOT NULL;",
            "SELECT title FROM course WHERE course_id NOT IN (SELECT course_id FROM prereq)"
        ],
        "rule_sql": [
            "SELECT title FROM course WHERE course_id NOT IN (SELECT course_id FROM prereq)"
        ]
    },
    "5076": {
        "db_id": "device",
        "question": "Please show different software platforms and the corresponding number of devices using each.",
        "ground_truth": "SELECT Software_Platform ,  COUNT(*) FROM device GROUP BY Software_Platform",
        "amends": [
            "Do reference the correct table name `device` instead of `devices` and use the correct column name `Software_Platform` instead of `platform` in both the SELECT list and GROUP BY clause, while maintaining the COUNT(*) aggregation."
        ],
        "rules": [
            "1) When answering about \"different software platforms and the corresponding number of devices using each\": make sure the output order: \"Software_Platform\" first, then the count. 2) When the question mentions \"software platforms\": \"software platforms\" actually means \"Software_Platform in schema\". 3) When the question asks for \"number of devices using each\": compute the count of all rows using the canonical key for devices. 4) When the question says \"per software platform\"/\"by platform\": organize results by \"Software_Platform\" and compute the count per group. 5) When choosing identifier delimiters: do not replace the exact column name \"Software_Platform\" with any other form."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT platform, COUNT(*) FROM devices GROUP BY platform;",
            "SELECT Software_Platform, COUNT(*) AS Number_of_Devices FROM device GROUP BY Software_Platform;"
        ],
        "rule_sql": [
            "SELECT Software_Platform, COUNT(Device_ID) AS NumberOfDevices FROM device GROUP BY Software_Platform ORDER BY Software_Platform;"
        ]
    },
    "2160": {
        "db_id": "formula_1",
        "question": "What are the unique names of all race held between 2014 and 2017?",
        "ground_truth": "SELECT DISTINCT name FROM races WHERE YEAR BETWEEN 2014 AND 2017",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT name FROM races WHERE year BETWEEN 2014 AND 2017;"
        ],
        "rule_sql": [
            "SELECT DISTINCT name FROM races WHERE year BETWEEN 2014 AND 2017 ORDER BY name;"
        ]
    },
    "2423": {
        "db_id": "candidate_poll",
        "question": "What are the names of candidates who have a lower support rate than oppose rate?",
        "ground_truth": "SELECT t1.name FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id WHERE t2.support_rate  <  t2.oppose_rate",
        "amends": [
            "Do select `t1.name` from the `people` table instead of `name` from the `candidates` table. Do join `candidate AS t2` on `t1.people_id = t2.people_id` instead of querying only the `candidates` table. Do use the condition `t2.support_rate < t2.oppose_rate` instead of `support_rate > oppose_rate` to correctly identify candidates with lower support than opposition. The amended query now properly joins the people and candidate tables and uses the correct comparison logic to match the intended behavior."
        ],
        "rules": [
            "1) When answering about candidate names: select \"t1.name\" from the \"people\" table instead of \"name\" from the \"candidates\" table. 2) When combining people and candidate tables: link rows where \"t1.people_id = t2.people_id\" and keep only matching pairs (inner match). 3) When identifying candidates with lower support than opposition: use the condition \"t2.support_rate < t2.oppose_rate\" instead of \"support_rate > oppose_rate\" to correctly match the intended behavior."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM candidates WHERE support_rate > oppose_rate;",
            "SELECT t1.Name FROM people AS t1 JOIN candidate AS t2 ON t1.People_ID = t2.People_ID WHERE t2.Support_rate < t2.Oppose_rate"
        ],
        "rule_sql": [
            "SELECT t1.Name FROM people t1 INNER JOIN candidate t2 ON t1.People_ID = t2.People_ID WHERE t2.Support_rate < t2.Oppose_rate"
        ]
    },
    "2788": {
        "db_id": "election",
        "question": "Show the name of the party that has at least two records.",
        "ground_truth": "SELECT Party FROM party GROUP BY Party HAVING COUNT(*)  >=  2",
        "amends": [
            "Do use `Party` as the column name instead of `party_name`. Do use `party` as the table name instead of `parties`. Do add `GROUP BY Party` instead of omitting it. Do move the `COUNT(*) >= 2` filter to `HAVING` instead of placing it in `WHERE`. The amended query now correctly groups by party and applies the count filter after aggregation, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"name of the party\": use the exact column name \"Party\" from the election table. 2) When counting records per party: group by the \"Party\" column and count using the canonical key. 3) When filtering for parties with at least two records: apply the count condition (COUNT(*) >= 2) after grouping using a HAVING clause instead of WHERE. 4) When referring to the table containing party information: use the exact table name \"election\" as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT party_name FROM parties WHERE COUNT(*) >= 2",
            "SELECT Party FROM party GROUP BY Party HAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT Party FROM election GROUP BY Party HAVING COUNT(*) >= 2"
        ]
    },
    "630": {
        "db_id": "store_1",
        "question": "What are the names of all Rock tracks that are stored on MPEG audio files?",
        "ground_truth": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = \"Rock\" AND T3.name = \"MPEG audio file\";",
        "amends": [
            "Do join `genres` and `tracks` on `genres.id = tracks.genre_id` instead of omitting the genres table entirely. Do join `media_types` on `media_types.id = tracks.media_type_id` instead of joining directly to tracks via `tracks.MediaTypeId = media_types.MediaTypeId`. Do filter on `genres.name = 'Rock'` instead of filtering media_types.name for 'Rock'. Do filter on `media_types.name = 'MPEG audio file'` instead of filtering track names with `LIKE '%.mp3'`. Do select `tracks.name` from the tracks table instead of selecting from an incomplete join structure. The amended query now correctly identifies rock genre tracks with MPEG audio format instead of incorrectly filtering by file extension."
        ],
        "rules": [
            "1) When joining tables for track information: link genres and tracks using genres.id = tracks.genre_id, and link media_types and tracks using media_types.id = tracks.media_type_id. 2) When filtering for rock music: use genres.name = 'Rock' instead of media_types.name. 3) When filtering for MPEG audio format: use media_types.name = 'MPEG audio file' instead of filtering track names by file extension. 4) When selecting track names: retrieve tracks.name from the tracks table after proper joins. 5) When combining multiple tables: perform inner joins to ensure only matching records from genres, tracks, and media_types are included."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.Name FROM tracks t JOIN media_types m ON t.MediaTypeId = m.MediaTypeId WHERE m.Name = 'Rock' AND t.Name LIKE '%.mp3'",
            "SELECT tracks.name \nFROM tracks \nJOIN genres ON genres.id = tracks.genre_id \nJOIN media_types ON media_types.id = tracks.media_type_id \nWHERE genres.name = 'Rock' \nAND media_types.name = 'MPEG audio file';"
        ],
        "rule_sql": [
            "SELECT tracks.name \nFROM tracks\nINNER JOIN genres ON genres.id = tracks.genre_id\nINNER JOIN media_types ON media_types.id = tracks.media_type_id\nWHERE genres.name = 'Rock' \nAND media_types.name = 'MPEG audio file'"
        ]
    },
    "1698": {
        "db_id": "epinions_1",
        "question": "Find the names of users who did not leave any review.",
        "ground_truth": "SELECT name FROM useracct WHERE u_id NOT IN (SELECT u_id FROM review)",
        "amends": [
            "Do reference table `useracct` instead of `users` and column `u_id` instead of `user_id` in both the main query and subquery. Do reference table `review` instead of `reviews` in the subquery. The amended query now correctly matches the intended behavior by using the appropriate table and column names from the schema."
        ],
        "rules": [
            "1) When answering about \"users who did not leave any review\": use table \"useracct\" as T1 and column \"u_id\" as the canonical key for users. 2) When checking for users without reviews: reference table \"review\" as T2 and use column \"u_id\" to link to T1. 3) When identifying users without reviews: find users from T1 where their \"u_id\" does not appear in the \"u_id\" values of T2. 4) When selecting output: return the \"name\" column from T1 for matching users."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM users WHERE user_id NOT IN (SELECT user_id FROM reviews)",
            "SELECT name FROM useracct WHERE u_id NOT IN (SELECT u_id FROM review)"
        ],
        "rule_sql": [
            "SELECT name FROM useracct AS T1 WHERE T1.u_id NOT IN (SELECT u_id FROM review AS T2)"
        ]
    },
    "1742": {
        "db_id": "gymnast",
        "question": "What is the average horizontal bar points for all gymnasts?",
        "ground_truth": "SELECT avg(Horizontal_Bar_Points) FROM gymnast",
        "amends": [
            "Do select `avg(Horizontal_Bar_Points)` instead of `AVG(floor_exercise)` to use the correct column name and aggregate function. Do reference table `gymnast` instead of `gymnast_scores` to query from the appropriate data source. The amended query now correctly calculates the average horizontal bar points from the gymnast table."
        ],
        "rules": [
            "1) When answering about \"average horizontal bar points for all gymnasts\": make sure to compute the average of the exact column \"Horizontal_Bar_Points\" from the table \"gymnast\". 2) When the question mentions \"horizontal bar points\": \"horizontal bar points\" actually means \"Horizontal_Bar_Points\" in the schema. 3) When the question asks for \"average\" of a column: compute the arithmetic mean of all values in that column using the exact column name \"Horizontal_Bar_Points\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(floor_exercise) FROM gymnast_scores;",
            "SELECT AVG(Horizontal_Bar_Points) FROM gymnast;"
        ],
        "rule_sql": [
            "SELECT AVG(Horizontal_Bar_Points) FROM gymnast;"
        ]
    },
    "1590": {
        "db_id": "customers_and_invoices",
        "question": "Return the names and ids of each account, as well as the number of transactions.",
        "ground_truth": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id",
        "amends": [
            "Do select `T2.account_name`, `T1.account_id`, and `count(*)` instead of just `name` and `id`. Do use `FROM Financial_transactions AS T1 JOIN Accounts AS T2` instead of only `FROM accounts`. Do add the join condition `ON T1.account_id = T2.account_id` instead of omitting it. Do add `GROUP BY T1.account_id` instead of not grouping. The amended query now correctly joins the two tables, aggregates transaction counts per account, and returns the complete required dataset."
        ],
        "rules": [
            "1) When answering about \"names and ids of each account, as well as the number of transactions\": make sure the output order: T2.account_name, T1.account_id, count(*). 2) When the question mentions \"account names and ids\": use T2.account_name and T1.account_id as the exact identifier tokens. 3) When combining Financial_transactions as T1 and Accounts as T2: link rows where T1.account_id = T2.account_id exactly as shown and keep only matching pairs (inner match). 4) When the question asks for \"number of transactions per account\": organize results by T1.account_id and compute count(*) per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, id FROM accounts;",
            "SELECT T2.account_name, T1.account_id, COUNT(*) \nFROM Financial_Transactions AS T1 \nJOIN Accounts AS T2 ON T1.account_id = T2.account_id \nGROUP BY T1.account_id"
        ],
        "rule_sql": [
            "SELECT T2.account_name, T1.account_id, COUNT(*) \nFROM Financial_Transactions T1 \nINNER JOIN Accounts T2 ON T1.account_id = T2.account_id \nGROUP BY T1.account_id \nORDER BY T2.account_name, T1.account_id, COUNT(*)"
        ]
    },
    "3929": {
        "db_id": "hospital_1",
        "question": "Return the name of each physician and the number of patients he or she treats.",
        "ground_truth": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid",
        "amends": [
            "Do reference `physician` as `T1` instead of `p` and `patient` as `T2` instead of `pt`. Do join on `T1.employeeid = T2.PCP` instead of `p.id = pt.physician_id`. Do group by `T1.employeeid` instead of `p.name`. Do remove the alias `patient_count` from the count instead of keeping it. The amended query now correctly matches the intended behavior by using the proper join condition between physician employee IDs and patient primary care physician references with appropriate grouping."
        ],
        "rules": [
            "1) When answering about \"physicians and their patient counts\": make sure the output order: T1.name, COUNT(*) 2) When combining T1 (physician) and T2 (patient) for shared entities: link rows where T1.employeeid = T2.PCP exactly as shown; keep only matching pairs (inner match). 3) When the question asks for \"number of patients per physician\": organize results by T1.employeeid and compute the count of patients per group. 4) When counting patients: compute the number of rows using the join relationship without adding an alias to the count. 5) When referring to physician names: use T1.name exactly as the identifier for physician names."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.name, COUNT(*) as patient_count FROM physicians p JOIN patients pt ON p.id = pt.physician_id GROUP BY p.name",
            "SELECT T1.Name, COUNT(T2.SSN) FROM Physician T1 JOIN Patient T2 ON T1.EmployeeID = T2.PCP GROUP BY T1.EmployeeID"
        ],
        "rule_sql": [
            "SELECT T1.name, COUNT(*) \nFROM Physician T1 \nINNER JOIN Patient T2 ON T1.employeeid = T2.PCP \nGROUP BY T1.employeeid"
        ]
    },
    "4044": {
        "db_id": "student_1",
        "question": "Which classrooms are used by grade 5?",
        "ground_truth": "SELECT DISTINCT classroom FROM list WHERE grade  =  5",
        "amends": [
            "Do reference table `list` instead of `students` in the FROM clause. Do add `DISTINCT` to eliminate duplicate classroom values instead of omitting it. Do maintain the filter `grade = 5` in the WHERE clause. The amended query now correctly returns unique classroom values from the appropriate table while preserving the grade filter, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"classrooms used by grade 5\": make sure the output order: classroom\n2) When the question mentions \"classrooms\": \"classrooms\" actually means \"classroom in schema\"\n3) When the question asks for \"which classrooms\": use DISTINCT to eliminate duplicate classroom values\n4) When the question specifies \"grade 5\": filter rows where grade = 5 exactly\n5) When selecting from tables: use table \"list\" instead of \"students\" as the source table"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT classroom FROM students WHERE grade = 5;",
            "SELECT DISTINCT Classroom FROM list WHERE Grade = 5"
        ],
        "rule_sql": [
            "SELECT DISTINCT Classroom FROM list WHERE Grade = 5 ORDER BY Classroom;"
        ]
    },
    "545": {
        "db_id": "store_1",
        "question": "Find out the top 10 customers by total number of orders. List customers' first and last name and the number of total orders.",
        "ground_truth": "SELECT T1.first_name ,  T1.last_name ,  COUNT(*) FROM customers AS T1 JOIN invoices AS T2 ON T2.customer_id  =  T1.id GROUP BY T1.id ORDER BY COUNT(*) DESC LIMIT 10;",
        "amends": [
            "Do join `invoices AS T2` on `T2.customer_id = T1.id` instead of querying only the `customers` table. Do reference columns with table aliases `T1.first_name` and `T1.last_name` instead of unqualified column names. Do use `COUNT(*)` instead of `COUNT(order_id)` to count all invoice records. Do group by `T1.id` instead of `customer_id` to ensure proper aggregation with the joined table structure. Do order by `COUNT(*)` instead of the alias `total_orders` since the alias is not used in the SELECT clause. The amended query now correctly joins customer and invoice data to count orders per customer."
        ],
        "rules": [
            "1) When answering about \"top 10 customers by total number of orders\": make sure the output order: T1.first_name, T1.last_name, COUNT(*) as total_orders\n2) When the question mentions \"customers\": use table \"customers\" as T1 and join with \"invoices\" as T2\n3) When combining T1 and T2 for shared entities: link rows where T2.customer_id = T1.id exactly as shown in the amends; keep only matching pairs (inner match)\n4) When counting orders per customer: compute the number of rows using COUNT(*) to count all invoice records instead of COUNT(order_id)\n5) When grouping by customer: group by T1.id instead of customer_id to ensure proper aggregation with the joined table structure\n6) When ordering by total orders: order by COUNT(*) in descending direction instead of the alias total_orders since the alias is not used in the SELECT clause\n7) When the question asks for \"top 10\": rank rows by COUNT(*) in descending direction and keep the first 10 rows"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name, COUNT(order_id) as total_orders \nFROM customers \nGROUP BY customer_id \nORDER BY total_orders DESC \nLIMIT 10;",
            "SELECT T1.first_name, T1.last_name, COUNT(*) AS total_orders\nFROM customers AS T1\nJOIN invoices AS T2 ON T2.customer_id = T1.id\nGROUP BY T1.id\nORDER BY COUNT(*) DESC\nLIMIT 10"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.last_name, COUNT(*) as total_orders\nFROM customers T1\nINNER JOIN invoices T2 ON T2.customer_id = T1.id\nGROUP BY T1.id\nORDER BY COUNT(*) DESC\nLIMIT 10"
        ]
    },
    "1687": {
        "db_id": "theme_gallery",
        "question": "Show all artist names with an average exhibition attendance over 200.",
        "ground_truth": "SELECT T3.name FROM exhibition_record AS T1 JOIN exhibition AS T2 ON T1.exhibition_id  =  T2.exhibition_id JOIN artist AS T3 ON T3.artist_id  =  T2.artist_id GROUP BY T3.artist_id HAVING avg(T1.attendance)  >  200",
        "amends": [
            "Do use `T3.name` from the `artist` table instead of `artist_name` from an unspecified source. Do join three tables (`exhibition_record AS T1`, `exhibition AS T2`, and `artist AS T3`) with proper relationships instead of querying a single `artists` table. Do use `JOIN exhibition AS T2 ON T1.exhibition_id = T2.exhibition_id` and `JOIN artist AS T3 ON T3.artist_id = T2.artist_id` instead of no joins. Do calculate `avg(T1.attendance)` and filter with `HAVING avg(T1.attendance) > 200` instead of directly filtering `attendance > 200` in WHERE. Do add `GROUP BY T3.artist_id` to support the aggregate function instead of omitting grouping. The amended query now correctly calculates average attendance per artist across exhibitions rather than filtering individual attendance records."
        ],
        "rules": [
            "1) When answering about \"artist names with average exhibition attendance over 200\": make sure the output order: T3.name. 2) When the question mentions \"artist names\": \"artist names\" actually means \"T3.name in schema\". 3) When combining T1, T2, and T3 for shared entities: link rows where T1.exhibition_id = T2.exhibition_id and T3.artist_id = T2.artist_id; keep only matching pairs (inner match). 4) When the question asks for \"average exhibition attendance\": compute avg(T1.attendance) per artist group. 5) When the question asks for \"average over 200\": filter groups where avg(T1.attendance) > 200. 6) When grouping by artist: organize results by T3.artist_id to support aggregate calculations."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT artist_name FROM artists WHERE attendance > 200;",
            "SELECT T3.Name\nFROM exhibition_record AS T1\nJOIN exhibition AS T2 ON T1.Exhibition_ID = T2.Exhibition_ID\nJOIN artist AS T3 ON T3.Artist_ID = T2.Artist_ID\nGROUP BY T3.Artist_ID\nHAVING AVG(T1.Attendance) > 200"
        ],
        "rule_sql": [
            "SELECT T3.Name\nFROM exhibition_record T1\nINNER JOIN exhibition T2 ON T1.Exhibition_ID = T2.Exhibition_ID\nINNER JOIN artist T3 ON T2.Artist_ID = T3.Artist_ID\nGROUP BY T3.Artist_ID\nHAVING AVG(T1.Attendance) > 200\nORDER BY T3.Name;"
        ]
    },
    "6219": {
        "db_id": "roller_coaster",
        "question": "What are the country names, area and population which has both roller coasters with speed higher",
        "ground_truth": "SELECT T1.name ,  T1.area ,  T1.population FROM country AS T1 JOIN roller_coaster AS T2 ON T1.Country_ID  =  T2.Country_ID WHERE T2.speed  >  60 INTERSECT SELECT T1.name ,  T1.area ,  T1.population FROM country AS T1 JOIN roller_coaster AS T2 ON T1.Country_ID  =  T2.Country_ID WHERE T2.speed  <  55",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of direct table names. Do join `country` with `roller_coaster` on `T1.Country_ID = T2.Country_ID` instead of querying `countries` table directly. Do filter on `T2.speed > 60` instead of `roller_coaster_speed > 100`. Do add an INTERSECT operation with a second query filtering on `T2.speed < 55` instead of having a single filter condition. Do select from `country` table instead of `countries` table. Do reference columns as `T1.name`, `T1.area`, and `T1.population` instead of `country_name`, `area`, and `population`. The amended query now correctly finds countries that have both roller coasters faster than 60 and slower than 55, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about countries with roller coasters: use table alias T1 for country table and T2 for roller_coaster table instead of direct table names. 2) When combining country and roller_coaster tables: link rows where T1.Country_ID = T2.Country_ID and keep only matching pairs (inner match). 3) When the question mentions \"speed higher\": filter on T2.speed > 60 instead of roller_coaster_speed > 100. 4) When the question implies \"both\" roller coasters with different speed conditions: use INTERSECT operation with a second query filtering on T2.speed < 55 instead of having a single filter condition. 5) When selecting country information: reference columns as T1.name, T1.area, and T1.population instead of country_name, area, and population. 6) When querying the country table: use country table instead of countries table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country_name, area, population FROM countries WHERE roller_coaster_speed > 100",
            "SELECT T1.Name, T1.Area, T1.Population\nFROM country T1\nJOIN roller_coaster T2 ON T1.Country_ID = T2.Country_ID\nWHERE T2.Speed > 60\nINTERSECT\nSELECT T1.Name, T1.Area, T1.Population\nFROM country T1\nJOIN roller_coaster T2 ON T1.Country_ID = T2.Country_ID\nWHERE T2.Speed < 55"
        ],
        "rule_sql": [
            "SELECT T1.Name, T1.Area, T1.Population\nFROM country T1\nJOIN roller_coaster T2 ON T1.Country_ID = T2.Country_ID\nWHERE T2.Speed > 60\nINTERSECT\nSELECT T1.Name, T1.Area, T1.Population\nFROM country T1\nJOIN roller_coaster T2 ON T1.Country_ID = T2.Country_ID\nWHERE T2.Speed < 55"
        ]
    },
    "918": {
        "db_id": "insurance_fnol",
        "question": "Count the total number of available services.",
        "ground_truth": "SELECT count(*) FROM services",
        "amends": [
            "Do use lowercase `count(*)` instead of uppercase `COUNT(*)` to maintain consistent function casing. Do add a line break after `FROM services` instead of keeping the entire query on one line for improved readability. The amended query now matches RIGHT_SQL's behavior with identical functionality but improved formatting consistency."
        ],
        "rules": [
            "1) When counting total number of available services: use lowercase count(*) function instead of uppercase COUNT(*) for consistent function casing. 2) When formatting the query for readability: add a line break after FROM services instead of keeping the entire query on one line. 3) When filtering services by status: use the exact literal 'unavailable' with the exact case and spelling as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM services WHERE status = 'unavailable';",
            "select count(*)\nfrom services"
        ],
        "rule_sql": [
            "select count(*)\nfrom services"
        ]
    },
    "1278": {
        "db_id": "game_injury",
        "question": "What is the average attendance of stadiums with capacity percentage higher than 100%?",
        "ground_truth": "SELECT average_attendance FROM stadium WHERE capacity_percentage  >  100",
        "amends": [
            "Do reference the correct column name `average_attendance` instead of calculating `AVG(attendance)` with an aggregate function. Do use the correct table name `stadium` instead of the pluralized `stadiums`. The amended query now correctly retrieves the pre-calculated average attendance value from the stadium table rather than attempting to calculate an average from a non-existent attendance column."
        ],
        "rules": [
            "1) When the question asks for average attendance: use the exact column name \"average_attendance\" instead of calculating AVG(attendance) 2) When referencing the stadium table: use the exact table name \"stadium\" instead of the pluralized \"stadiums\" 3) When the question asks for stadiums with capacity percentage higher than 100%: use the condition \"capacity_percentage > 100\" to filter rows"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(attendance) FROM stadiums WHERE capacity_percentage > 100;",
            "SELECT average_attendance FROM stadium WHERE capacity_percentage > 100;"
        ],
        "rule_sql": [
            "SELECT average_attendance FROM stadium WHERE capacity_percentage > 100"
        ]
    },
    "2175": {
        "db_id": "formula_1",
        "question": "Give me a list of names and years of races that had any driver whose forename is Lewis?",
        "ground_truth": "SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = \"Lewis\"",
        "amends": [
            "Do select `T2.name` and `T2.year` from the `races` table instead of `name` and `year` directly. Do join `results AS T1` to `races AS T2` on `T1.raceid = T2.raceid` instead of querying races alone. Do add a second join to `drivers AS T3` on `T1.driverid = T3.driverid` instead of omitting the drivers table. Do filter on `T3.forename = \"Lewis\"` instead of `driver_forename = 'Lewis'` to properly reference the driver's first name through the joined tables. The amended query now correctly retrieves race information for Lewis Hamilton by properly joining through the results table to connect drivers to races."
        ],
        "rules": [
            "1) When answering about race names and years: make sure the output order: T2.name, T2.year\n2) When the question mentions \"races\": use table \"races\" with alias T2\n3) When the question mentions \"driver whose forename is Lewis\": join to \"results\" as T1 and \"drivers\" as T3, then filter on T3.forename = \"Lewis\"\n4) When combining tables for shared entities: link T1 to T2 where T1.raceid = T2.raceid and link T1 to T3 where T1.driverid = T3.driverid, keeping only matching pairs (inner match)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, year FROM races WHERE driver_forename = 'Lewis';",
            "SELECT T2.name, T2.year FROM races AS T2 JOIN results AS T1 ON T1.raceId = T2.raceId JOIN drivers AS T3 ON T1.driverId = T3.driverId WHERE T3.forename = 'Lewis'"
        ],
        "rule_sql": [
            "SELECT T2.name, T2.year\nFROM races T2\nINNER JOIN results T1 ON T1.raceId = T2.raceId\nINNER JOIN drivers T3 ON T1.driverId = T3.driverId\nWHERE T3.forename = 'Lewis'\nGROUP BY T2.name, T2.year\nORDER BY T2.name, T2.year"
        ]
    },
    "877": {
        "db_id": "chinook_1",
        "question": "Find the names of artists that do not have any albums.",
        "ground_truth": "SELECT Name FROM ARTIST EXCEPT SELECT T2.Name FROM ALBUM AS T1 JOIN ARTIST AS T2 ON T1.ArtistId  =  T2.ArtistId",
        "amends": [
            "Do use `EXCEPT` set operation instead of filtering with `IS NULL`. Do select from `ARTIST` table instead of `artists`. Do reference `Name` column instead of `name`. Do remove the `WHERE album_id IS NULL` filter instead of keeping it. Do add a join between `ALBUM` and `ARTIST` tables on `ArtistId` instead of omitting table relationships. The amended query now correctly identifies artists without albums by using set difference rather than attempting to filter on a non-existent column."
        ],
        "rules": [
            "1) When answering about \"names of artists that do not have any albums\": make sure the output order: \"Name\" from the ARTIST table. 2) When the question mentions \"artists\": \"artists\" actually means \"ARTIST\" in schema. 3) When the question mentions \"names\": \"names\" actually means \"Name\" column in schema. 4) When finding artists without albums: use set difference (EXCEPT) between all artists and artists with albums instead of filtering with IS NULL. 5) When combining ARTIST and ALBUM tables: link rows where ARTIST.ArtistId = ALBUM.ArtistId to identify artists with albums. 6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table names like \"ARTIST\" and column names like \"Name\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM artists WHERE album_id IS NULL;",
            "SELECT Name FROM Artist\nEXCEPT\nSELECT a.Name FROM Artist a\nJOIN Album al ON a.ArtistId = al.ArtistId"
        ],
        "rule_sql": [
            "SELECT \"Name\" FROM \"Artist\"\nEXCEPT\nSELECT a.\"Name\" FROM \"Artist\" a\nJOIN \"Album\" al ON a.\"ArtistId\" = al.\"ArtistId\"\nORDER BY \"Name\""
        ]
    },
    "15": {
        "db_id": "department_management",
        "question": "Which head's name has the substring 'Ha'? List the id and name.",
        "ground_truth": "SELECT head_id ,  name FROM head WHERE name LIKE '%Ha%'",
        "amends": [
            "Do use `head_id` instead of `id` in the SELECT list to reference the correct column name. Do reference the table `head` instead of `heads` in the FROM clause to use the correct table name. The amended query now correctly selects the head_id column from the head table with the same filtering logic."
        ],
        "rules": [
            "1) When the question asks for \"id\" of a head: use the exact column name \"head_id\" from the head table instead of \"id\". 2) When referencing the table containing head information: use the exact table name \"head\" instead of \"heads\". 3) When filtering for names containing the substring 'Ha': use the exact literal 'Ha' with case sensitivity as shown in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, name FROM heads WHERE name LIKE '%Ha%';",
            "SELECT head_id, name FROM head WHERE name LIKE '%Ha%';"
        ],
        "rule_sql": [
            "SELECT head_id, name FROM head WHERE name LIKE '%Ha%';"
        ]
    },
    "2729": {
        "db_id": "storm_record",
        "question": "What are the names of regions with two or more storms?",
        "ground_truth": "SELECT T1.region_name FROM region AS T1 JOIN affected_region AS T2 ON T1.region_id = T2.region_id GROUP BY T1.region_id HAVING count(*)  >=  2",
        "amends": [
            "Do select `T1.region_name` with table alias instead of just `region_name` without qualification. Do add `FROM region AS T1 JOIN affected_region AS T2` with explicit table aliases and join instead of just `FROM storms` without joins. Do use `ON T1.region_id = T2.region_id` as the join condition instead of no join condition. Do group by `T1.region_id` instead of `region_name` to ensure proper aggregation. Do use `>= 2` as the HAVING threshold instead of `> 1` to include cases with exactly 2 occurrences. The amended query now correctly joins the region and affected_region tables and counts storm occurrences per region."
        ],
        "rules": [
            "1) When answering about \"names of regions with two or more storms\": make sure the output order: T1.region_name. 2) When combining T1 and T2 for shared entities: link rows where T1.region_id = T2.region_id exactly as shown; keep only matching pairs (inner match). 3) When the question asks for \"count of storms per region\": compute the number of rows using T1.region_id as the counting key. 4) When the question mentions \"two or more\": use >= 2 as the threshold instead of > 1 to include cases with exactly 2 occurrences. 5) When grouping by region: organize results by T1.region_id to ensure proper aggregation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT region_name FROM storms GROUP BY region_name HAVING COUNT(*) > 1",
            "SELECT T1.region_name \nFROM region AS T1 \nJOIN affected_region AS T2 ON T1.region_id = T2.region_id \nGROUP BY T1.region_id \nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT r.region_name \nFROM region r\nJOIN affected_region ar ON r.Region_id = ar.Region_id\nGROUP BY r.Region_id, r.region_name\nHAVING COUNT(ar.Storm_ID) >= 2\nORDER BY r.region_name;"
        ]
    },
    "2730": {
        "db_id": "storm_record",
        "question": "Find the names of the regions which were affected by the storm that killed the greatest number of people.",
        "ground_truth": "SELECT T2.region_name FROM affected_region AS T1 JOIN region AS T2 ON T1.region_id  =  T2.region_id JOIN storm AS T3 ON T1.storm_id  =  T3.storm_id ORDER BY T3.Number_Deaths DESC LIMIT 1",
        "amends": [
            "Do use `JOIN` operations with `affected_region`, `region`, and `storm` tables instead of querying `regions` directly with a subquery. Do reference `T2.region_name` instead of `region_name` from the correct joined table. Do join on `T1.region_id = T2.region_id` and `T1.storm_id = T3.storm_id` instead of filtering by a subquery result. Do order by `T3.Number_Deaths DESC` instead of `deaths DESC` to get the most deadly storm. Do remove the `WHERE` clause entirely instead of using it with a subquery filter. The amended query now correctly identifies the region affected by the storm with the highest number of deaths through proper table relationships."
        ],
        "rules": [
            "1) When answering about regions affected by the most deadly storm: use JOIN operations with affected_region, region, and storm tables instead of querying regions directly. 2) When combining tables for shared entities: link rows where T1.region_id = T2.region_id and T1.storm_id = T3.storm_id, keeping only matching pairs (inner match). 3) When the question mentions \"greatest number of people\" killed: order by T3.Number_Deaths DESC to get the most deadly storm. 4) When selecting region names: reference T2.region_name instead of region_name from the correct joined table. 5) When filtering for the most deadly storm: remove the WHERE clause entirely instead of using it with a subquery filter."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT region_name FROM regions WHERE storm_id = (SELECT storm_id FROM storms ORDER BY deaths DESC LIMIT 1);",
            "SELECT T2.Region_name \nFROM affected_region T1\nJOIN region T2 ON T1.Region_id = T2.Region_id\nJOIN storm T3 ON T1.Storm_ID = T3.Storm_ID\nORDER BY T3.Number_Deaths DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT r.Region_name \nFROM affected_region ar\nJOIN region r ON ar.Region_id = r.Region_id\nJOIN storm s ON ar.Storm_ID = s.Storm_ID\nORDER BY s.Number_Deaths DESC\nLIMIT 1;"
        ]
    },
    "3686": {
        "db_id": "baseball_1",
        "question": "Find the year in which the least people enter hall of fame.",
        "ground_truth": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;",
        "amends": [
            "Do select `yearid` instead of `year` and remove the alias `count` instead of keeping it. Do group by `yearid` instead of `year`. Do order by `count(*) ASC` instead of `count DESC` to sort by ascending count rather than descending. The amended query now correctly uses the proper column name and ordering to match the intended behavior.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, as the query only needs to return the yearid with the minimum count. The GROUP BY clause on `yearid` and ORDER BY with `count(*) ASC` remain unchanged to correctly identify the year with the fewest hall of fame entries. The amended query now matches the right SQL's behavior by returning only the yearid column while maintaining the same aggregation and ordering logic."
        ],
        "rules": [
            "1) When the question asks about \"year\": use the exact column name \"yearid\" from the hall_of_fame table instead of \"year\". 2) When counting entities: use count(*) without an alias instead of assigning an alias like \"count\". 3) When grouping by year: group by \"yearid\" instead of \"year\". 4) When finding the \"least\" or minimum count: order by count(*) in ascending order (ASC) instead of descending order (DESC).",
            "1) When answering about \"the year in which the least people enter hall of fame\": make sure the output order includes only \"yearid\" without the count value. 2) When counting hall of fame entries per year: compute the number of rows using the canonical key \"yearid\" from table hall_of_fame. 3) When finding the year with the minimum count: rank years by their count of hall of fame entries in ascending order and keep only the first row. 4) When grouping by year: organize results by \"yearid\" and compute the count of entries per year."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, COUNT(*) as count FROM hall_of_fame GROUP BY year ORDER BY count DESC LIMIT 1;",
            "SELECT yearid, COUNT(*) FROM hall_of_fame GROUP BY yearid ORDER BY COUNT(*) ASC LIMIT 1;",
            "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY COUNT(*) ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;"
        ]
    },
    "2715": {
        "db_id": "storm_record",
        "question": "How many regions were affected by each storm?",
        "ground_truth": "SELECT T1.name ,  count(*) FROM storm AS T1 JOIN affected_region AS T2 ON T1.storm_id  =  T2.storm_id GROUP BY T1.storm_id",
        "amends": [
            "Do reference `T1.name` instead of `storm_name` and remove the alias `affected_regions` instead of keeping it. Do join `storm AS T1` and `affected_region AS T2` instead of querying only `storms`, and use `ON T1.storm_id = T2.storm_id` instead of no join condition. Do group by `T1.storm_id` instead of `storm_name` to ensure correct aggregation. The amended query now correctly counts affected regions per storm by properly joining the related tables."
        ],
        "rules": [
            "1) When answering about \"How many regions were affected by each storm?\": make sure the output order: T1.name, COUNT(*) 2) When combining T1 and T2 for shared entities: link rows where T1.storm_id = T2.storm_id; keep only matching pairs (inner match). 3) When the question asks for \"count of regions affected by each storm\": compute the number of rows using the canonical key T1.storm_id for grouping. 4) When the question mentions \"storm\": \"storm\" actually means \"T1.name in schema\". 5) When producing output: do not include the alias \"affected_regions\" for the count result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT storm_name, COUNT(*) as affected_regions FROM storms GROUP BY storm_name;",
            "SELECT T1.Name, COUNT(T2.Region_id) AS Number_of_Affected_Regions\nFROM storm AS T1\nJOIN affected_region AS T2 ON T1.Storm_ID = T2.Storm_ID\nGROUP BY T1.Storm_ID"
        ],
        "rule_sql": [
            "SELECT s.Name, COUNT(*) \nFROM storm s\nINNER JOIN affected_region ar ON s.Storm_ID = ar.Storm_ID\nGROUP BY s.Storm_ID\nORDER BY s.Name, COUNT(*)"
        ]
    },
    "1077": {
        "db_id": "match_season",
        "question": "Give the different positions of players who play for the country with the capital Dublin.",
        "ground_truth": "SELECT DISTINCT T2.Position FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T1.Capital  =  \"Dublin\"",
        "amends": [
            "Do join `country AS T1` and `match_season AS T2` instead of querying only the `players` table. Do use `T1.Country_id = T2.Country` as the join condition instead of no join condition. Do filter on `T1.Capital = \"Dublin\"` instead of `country = 'Dublin'`. Do select `T2.Position` instead of `position`. The amended query now correctly retrieves positions from match_season data joined with country information based on capital city instead of incorrectly filtering players by country name."
        ],
        "rules": [
            "1) When answering about player positions for a country with capital Dublin: join country table (as T1) with match_season table (as T2) using T1.Country_id = T2.Country. 2) When filtering for the country with capital Dublin: use T1.Capital = \"Dublin\" instead of country name filtering. 3) When selecting player positions: use T2.Position from the match_season table instead of position from players table. 4) When combining country and match_season tables: perform an inner match where T1.Country_id equals T2.Country to link country information with player data."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT position FROM players WHERE country = 'Dublin';",
            "SELECT DISTINCT T2.Position \nFROM country AS T1 \nJOIN match_season AS T2 ON T1.Country_id = T2.Country \nWHERE T1.Capital = 'Dublin'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.Position \nFROM country AS T1 \nINNER JOIN match_season AS T2 ON T1.Country_id = T2.Country \nWHERE T1.Capital = 'Dublin';"
        ]
    },
    "6881": {
        "db_id": "flight_4",
        "question": "Find the busiest source airport that runs most number of routes in China.",
        "ground_truth": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `airports AS T1` with `routes AS T2` on `T1.apid = T2.src_apid` instead of querying only the `routes` table. Do select `T1.name` instead of `source_airport`. Do filter on `T1.country = 'China'` instead of `country = 'China'` to ensure the country condition applies to the airport rather than potentially ambiguous route data. Do group by `T1.name` instead of `source_airport` to aggregate by the actual airport name. Do order by `count(*) DESC` instead of `route_count DESC` while maintaining the same descending count ordering. The amended query now correctly joins airport metadata with route data and applies country filtering to the appropriate table, matching the RIGHT_SQL's behavior.",
            "Do remove the `COUNT(*) AS route_count` column from the SELECT list instead of including it. Do change the ORDER BY clause to reference `count(*)` with lowercase instead of `COUNT(*)` with uppercase. The amended query now correctly returns only the airport name with the highest route count from China, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"busiest source airport in China\": make sure to join airports table (as T1) with routes table (as T2) where T1.apid equals T2.src_apid. 2) When the question mentions \"source airport\": use T1.name instead of source_airport from the routes table. 3) When filtering for airports in China: apply the condition T1.country = 'China' exactly as specified. 4) When counting routes per airport: group by T1.name and count all matching route records. 5) When finding the busiest airport: order by the count in descending order and take only the top result.",
            "1) When answering about \"the busiest source airport that runs most number of routes in China\": make sure the output order includes only the airport name column without the route count. 2) When ordering by count of routes: use lowercase \"count(*)\" in the order by clause instead of uppercase \"COUNT(*)\". 3) When the question asks for the busiest airport with most routes: rank airports by route count in descending order and keep only the top 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT source_airport, COUNT(*) as route_count \nFROM routes \nWHERE country = 'China' \nGROUP BY source_airport \nORDER BY route_count DESC \nLIMIT 1;",
            "SELECT T1.name, COUNT(*) AS route_count\nFROM airports AS T1\nJOIN routes AS T2 ON T1.apid = T2.src_apid\nWHERE T1.country = 'China'\nGROUP BY T1.name\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT T1.name\nFROM airports AS T1\nJOIN routes AS T2 ON T1.apid = T2.src_apid\nWHERE T1.country = 'China'\nGROUP BY T1.name\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.name \nFROM airports T1\nJOIN routes T2 ON T1.apid = T2.src_apid\nWHERE T1.country = 'China'\nGROUP BY T1.name\nORDER BY count(*) DESC\nLIMIT 1"
        ]
    },
    "5459": {
        "db_id": "voter_2",
        "question": "Find the average age of female students.",
        "ground_truth": "SELECT avg(Age) FROM STUDENT WHERE Sex  =  \"F\"",
        "amends": [
            "Do use table name `STUDENT` instead of `students` and column name `Sex` instead of `gender` in the FROM clause and WHERE filter. Do filter for value `\"F\"` instead of `'male'` to target female students instead of male students. Do use lowercase `avg` function instead of uppercase `AVG` while maintaining the same aggregate calculation on the `Age` column instead of `age`. The amended query now correctly calculates the average age of female students from the STUDENT table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"average age of female students\": make sure the output order: avg(Age) 2) When the question mentions \"female students\": \"female\" actually means \"Sex = 'F'\" in schema 3) When the question mentions \"average age\": use the avg function on the \"Age\" column 4) When choosing identifier delimiters: use exact table name \"STUDENT\" and column names \"Sex\" and \"Age\" as shown in the schema 5) When handling text literals: use exact value \"F\" for female students (not 'male' or other variations)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age) FROM students WHERE gender = 'male';",
            "SELECT avg(Age) FROM Student WHERE Sex = 'F'"
        ],
        "rule_sql": [
            "SELECT avg(Age) FROM Student WHERE Sex = 'F'"
        ]
    },
    "934": {
        "db_id": "medicine_enzyme_interaction",
        "question": "What is the total count of enzymes?",
        "ground_truth": "SELECT count(*) FROM enzyme",
        "amends": [
            "Do reference table `enzyme` instead of `proteins` in the FROM clause. The amended query now correctly counts records from the enzyme table instead of the proteins table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"total count of enzymes\": make sure to count records from the \"enzyme\" table instead of the \"proteins\" table. 2) When counting entities: use the canonical key for counting (typically all rows from the specified table) to get the total count."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM proteins;",
            "SELECT COUNT(*) FROM enzyme;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM enzyme;"
        ]
    },
    "754": {
        "db_id": "race_track",
        "question": "Return the name, location, and seating of the track that was opened in the most recent year.",
        "ground_truth": "SELECT name ,  LOCATION ,  seating FROM track ORDER BY year_opened DESC LIMIT 1",
        "amends": [
            "Do reference table `track` instead of `tracks` in the FROM clause. Do use column `year_opened` instead of `opened_year` in the ORDER BY clause. The amended query now correctly references the proper table name and column for sorting by opening year."
        ],
        "rules": [
            "1) When the question asks about tracks: use table \"track\" instead of \"tracks\" for the FROM clause. 2) When ordering by opening year: use column \"year_opened\" instead of \"opened_year\" for the ORDER BY clause. 3) When finding the most recent track: sort by \"year_opened\" in descending order and keep only the first row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, location, seating FROM tracks ORDER BY opened_year DESC LIMIT 1;",
            "SELECT Name, Location, Seating FROM track ORDER BY year_opened DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name, Location, Seating FROM track ORDER BY year_opened DESC LIMIT 1;"
        ]
    },
    "5239": {
        "db_id": "music_2",
        "question": "What is the first and last name of artist who performed \"Le Pop\"?",
        "ground_truth": "SELECT T2.firstname ,  T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId WHERE T3.Title  =  \"Le Pop\"",
        "amends": [
            "Do select `T2.firstname` and `T2.lastname` instead of `first_name` and `last_name`. Do use `FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate = T2.id JOIN Songs AS T3 ON T3.SongId = T1.SongId` instead of `FROM artists` with no joins. Do filter on `T3.Title = \"Le Pop\"` instead of `album_title = 'Le Pop'`. The amended query now correctly joins multiple tables to find band members who performed the song \"Le Pop\" rather than incorrectly querying a single artists table for album titles."
        ],
        "rules": [
            "1) When the question asks for first and last name of an artist: select \"T2.firstname\" and \"T2.lastname\" exactly as specified in the schema. 2) When finding artists who performed a specific song: join \"Performance AS T1\", \"Band AS T2\", and \"Songs AS T3\" tables using the exact join conditions \"T1.bandmate = T2.id\" and \"T3.SongId = T1.SongId\". 3) When filtering for the song \"Le Pop\": use the exact literal \"Le Pop\" with the condition \"T3.Title = \"Le Pop\"\" to match the song title exactly."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM artists WHERE album_title = 'Le Pop';",
            "SELECT T2.Firstname, T2.Lastname \nFROM Performance AS T1 \nJOIN Band AS T2 ON T1.Bandmate = T2.Id \nJOIN Songs AS T3 ON T3.SongId = T1.SongId \nWHERE T3.Title = \"Le Pop\""
        ],
        "rule_sql": [
            "SELECT T2.Firstname, T2.Lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.Bandmate = T2.Id JOIN Songs AS T3 ON T3.SongId = T1.SongId WHERE T3.Title = \"Le Pop\""
        ]
    },
    "6854": {
        "db_id": "flight_4",
        "question": "What is the count of cities with more than 3 airports?",
        "ground_truth": "SELECT count(*) FROM (SELECT city FROM airports GROUP BY city HAVING count(*)  >  3)",
        "amends": [
            "Do use a subquery with `GROUP BY city` and `HAVING count(*) > 3` instead of directly filtering `airport_count > 3` in the WHERE clause. Do count the results from the subquery instead of counting directly from the cities table. Do reference the `airports` table instead of the `cities` table to properly calculate airport counts per city. The amended query now correctly identifies cities with more than 3 airports by grouping and counting airport records rather than relying on a potentially incorrect or non-existent airport_count column."
        ],
        "rules": [
            "1) When counting cities with more than 3 airports: use the airports table to count airports per city by grouping on city. 2) When filtering for cities with more than 3 airports: apply the condition count(*) > 3 in a HAVING clause after grouping by city. 3) When producing the final count: count the distinct cities that satisfy the condition of having more than 3 airports from the grouped subquery results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities WHERE airport_count > 3;",
            "SELECT COUNT(*) FROM (SELECT city FROM airports GROUP BY city HAVING COUNT(*) > 3)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS city_count\nFROM (\n    SELECT city\n    FROM airports\n    GROUP BY city\n    HAVING COUNT(*) > 3\n) AS cities_with_more_than_3_airports"
        ]
    },
    "6384": {
        "db_id": "flight_company",
        "question": "which pilot is in charge of the most number of flights?",
        "ground_truth": "SELECT pilot FROM flight GROUP BY pilot ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference the `pilot` column instead of `pilot_name` in both the SELECT list and GROUP BY clause. Do use `count(*)` directly in the ORDER BY clause instead of referencing the `flight_count` alias. Do order by `DESC` instead of `ASC` to find the pilot with the highest count rather than the lowest. Do reference the correct table name `flight` instead of `flights`. The amended query now correctly identifies the pilot with the most flights by counting records per pilot and ordering descending by that count, matching the intended behavior.",
            "Do select only `pilot` instead of selecting both `Pilot` and `COUNT(*) as flight_count`. Do use lowercase `pilot` in the SELECT list instead of capitalized `Pilot`. Do remove the alias `flight_count` instead of keeping it. Do use lowercase `pilot` in the GROUP BY clause instead of capitalized `Pilot`. The amended query now correctly returns only the pilot with the highest flight count without unnecessary columns or aliases, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"which pilot is in charge of the most number of flights\": make sure the output order: pilot name first, then flight count. 2) When the question mentions \"pilot\": \"pilot\" actually means \"Pilot\" column in the flight table. 3) When counting flights per pilot: count all rows using count(*) and group by the exact token \"Pilot\". 4) When the question asks for \"most number of flights\": rank pilots by flight count in descending order and keep only the top 1 row. 5) When ordering by flight count: use count(*) directly in the order by clause instead of referencing any alias. 6) When referring to the flight table: use the exact table name \"flight\" instead of \"flights\".",
            "1) When answering about \"which pilot is in charge of the most number of flights\": make sure the output order: pilot\n2) When the question asks for \"count of flights\": compute the number of rows using the canonical key for flights (pilot)\n3) When the question mentions \"most number of flights\": rank rows by flight count in descending order and keep the first 1 row\n4) When handling column names: use lowercase \"pilot\" instead of capitalized \"Pilot\" for both selection and grouping\n5) When producing output: do not include unnecessary columns or aliases beyond the requested pilot name"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT pilot_name, COUNT(*) as flight_count FROM flights GROUP BY pilot_name ORDER BY flight_count ASC LIMIT 1;",
            "SELECT Pilot, COUNT(*) as flight_count FROM flight GROUP BY Pilot ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT pilot FROM flight GROUP BY pilot ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Pilot, COUNT(*) FROM flight GROUP BY Pilot ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "6056": {
        "db_id": "customers_and_addresses",
        "question": "What are the names of all the customers?",
        "ground_truth": "SELECT customer_name FROM customers",
        "amends": [
            "Do select only `customer_name` instead of selecting all columns with `*`. Do remove the wildcard selector and explicitly specify the desired column instead of retrieving all available fields. The amended query now matches RIGHT_SQL's behavior by returning only customer names rather than all customer data."
        ],
        "rules": [
            "1) When answering about \"names of all the customers\": make sure the output order: customer_name. 2) When the question asks for customer names: select only the customer_name column instead of all columns. 3) When handling column selection: do not use wildcard selectors like *; explicitly specify the desired column names."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM customers;",
            "SELECT customer_name FROM Customers"
        ],
        "rule_sql": [
            "SELECT customer_name FROM Customers ORDER BY customer_name;"
        ]
    },
    "991": {
        "db_id": "university_basketball",
        "question": "What is the team name and acc regular season score of the school that was founded for the longest time?",
        "ground_truth": "SELECT t2.team_name ,  t2.ACC_Regular_Season FROM university AS t1 JOIN basketball_match AS t2 ON t1.school_id  =  t2.school_id ORDER BY t1.founded LIMIT 1",
        "amends": [
            "Do select `team_name` and `ACC_Regular_Season` instead of `team_name` and `acc_regular_season_score`. Do join `university` and `basketball_match` on `school_id` instead of querying only `schools`. Do order by `founded` instead of `founded_year`. The amended query now correctly joins the university and basketball data to find the oldest university's basketball team information."
        ],
        "rules": [
            "1) When the question asks for \"acc regular season score\": use the exact column name \"ACC_Regular_Season\" from the basketball_match table. 2) When combining university and basketball_match tables: link rows where university.school_id equals basketball_match.school_id using an inner match. 3) When ordering by the founding year: use the exact column name \"founded\" from the university table instead of \"founded_year\". 4) When finding the school founded for the longest time: order by \"founded\" in ascending order and take the first row. 5) When selecting output columns: include both \"team_name\" and \"ACC_Regular_Season\" in the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT team_name, acc_regular_season_score FROM schools ORDER BY founded_year ASC LIMIT 1;",
            "SELECT bm.Team_Name, bm.ACC_Regular_Season \nFROM basketball_match bm\nJOIN university u ON bm.School_ID = u.School_ID\nORDER BY u.Founded ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT bm.Team_Name, bm.ACC_Regular_Season \nFROM basketball_match bm\nINNER JOIN university u ON bm.School_ID = u.School_ID\nORDER BY u.Founded ASC\nLIMIT 1;"
        ]
    },
    "1314": {
        "db_id": "performance_attendance",
        "question": "Show the most common location of performances.",
        "ground_truth": "SELECT LOCATION FROM performance GROUP BY LOCATION ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select only `LOCATION` instead of including `COUNT(*) as performance_count` in the SELECT list. Do use `ORDER BY COUNT(*) DESC` instead of `ORDER BY performance_count ASC` to find the location with the highest count rather than the lowest. Do reference table `performance` instead of `performances` to match the correct table name. The amended query now correctly identifies the location with the most performances by counting occurrences per location and ordering descending with limit 1, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"most common location of performances\": select only the \"LOCATION\" column from the \"performance\" table. 2) When counting performances per location: count all rows using COUNT(*) and group by \"LOCATION\". 3) When finding the most common location: order the results by COUNT(*) in descending order and keep only the first row (limit 1). 4) When referencing table names: use the exact table name \"performance\" (not \"performances\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location, COUNT(*) as performance_count FROM performances GROUP BY location ORDER BY performance_count ASC LIMIT 1;",
            "SELECT Location FROM performance GROUP BY Location ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Location FROM performance GROUP BY Location ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "2482": {
        "db_id": "movie_1",
        "question": "Return all reviewer names and movie names together in a single list.",
        "ground_truth": "SELECT name FROM Reviewer UNION SELECT title FROM Movie",
        "amends": [
            "Do select `name` from `Reviewer` instead of `reviewer_name` from `reviewers`, and do select `title` from `Movie` instead of `movie_name` from `movies`, while maintaining the same UNION operation structure. The amended query now correctly references the proper table and column names to match the intended schema."
        ],
        "rules": [
            "1) When the question asks for \"reviewer names\": select the exact column \"name\" from table \"Reviewer\" (not \"reviewer_name\" from \"reviewers\"). 2) When the question asks for \"movie names\": select the exact column \"title\" from table \"Movie\" (not \"movie_name\" from \"movies\"). 3) When combining reviewer names and movie names in a single list: use UNION operation to combine both results into one column output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT reviewer_name FROM reviewers UNION SELECT movie_name FROM movies;",
            "SELECT name FROM Reviewer\nUNION\nSELECT title FROM Movie;"
        ],
        "rule_sql": [
            "SELECT name FROM Reviewer\nUNION\nSELECT title FROM Movie;"
        ]
    },
    "5218": {
        "db_id": "music_2",
        "question": "Which song has the most vocals?",
        "ground_truth": "SELECT title FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid GROUP BY T1.songid ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `vocals` table as `T1` and `songs` table as `T2` with a `JOIN` on `T1.songid = T2.songid` instead of selecting only from `songs`. Do add `GROUP BY T1.songid` to aggregate by song instead of ordering individual records. Do change the ORDER BY to `count(*) DESC` to sort by the number of vocals per song instead of ordering by the `vocals` column directly. Do remove the direct reference to `vocals DESC` in the ORDER BY clause since we're now counting vocal occurrences. The amended query now correctly identifies the song with the most vocals by joining the vocals table, grouping by song, and counting occurrences, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"which song has the most vocals\": make sure the output order: title. 2) When the question mentions \"vocals\": \"vocals\" actually means \"rows in the vocals table (T1) grouped by songid\". 3) When combining T1 (vocals) and T2 (songs) for shared entities: link rows where T1.songid = T2.songid exactly as shown; keep only matching pairs (inner match). 4) When the question asks for \"most vocals\" or \"highest number of vocals\": rank rows by count(*) in descending direction and keep the first 1 row. 5) When the question asks for \"count of vocals per song\": compute the number of rows using T1.songid as the grouping key and count(*) as the aggregate."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM songs ORDER BY vocals DESC LIMIT 1;",
            "SELECT T2.Title, COUNT(*) AS vocal_count\nFROM Vocals T1\nJOIN Songs T2 ON T1.SongId = T2.SongId\nGROUP BY T1.SongId\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT s.Title\nFROM Songs s\nJOIN Vocals v ON s.SongId = v.SongId\nGROUP BY s.SongId, s.Title\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "1497": {
        "db_id": "debate",
        "question": "What is the party of the youngest people?",
        "ground_truth": "SELECT Party FROM people ORDER BY Age ASC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT party FROM people ORDER BY age ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Party FROM people ORDER BY Age ASC LIMIT 1;"
        ]
    },
    "6093": {
        "db_id": "customers_and_addresses",
        "question": "List the countries having more than 4 addresses listed.",
        "ground_truth": "SELECT country FROM addresses GROUP BY country HAVING count(address_id)  >  4",
        "amends": [
            "Do use `count(address_id)` instead of `COUNT(*)` in the HAVING clause to count specific non-null values rather than all rows. Do change the comparison operator to `>` instead of `<` to filter for countries with more than 4 addresses instead of fewer than 4. Do remove `COUNT(*)` from the SELECT list instead of including it since only the country column is needed in the final output. The amended query now correctly returns countries with more than 4 addresses by counting address_id values and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting addresses per country: use count(address_id) instead of COUNT(*) to count specific non-null values rather than all rows. 2) When filtering for countries with more than 4 addresses: use the > operator instead of < to filter for values greater than 4. 3) When selecting output columns: include only the country column in the final output, not the count value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country, COUNT(*) FROM addresses GROUP BY country HAVING COUNT(*) < 4;",
            "SELECT country FROM Addresses GROUP BY country HAVING COUNT(address_id) > 4"
        ],
        "rule_sql": [
            "SELECT country FROM Addresses GROUP BY country HAVING COUNT(address_id) > 4"
        ]
    },
    "4954": {
        "db_id": "soccer_2",
        "question": "What is the average training hours of all players?",
        "ground_truth": "SELECT avg(HS) FROM Player",
        "amends": [
            "Do use `avg(HS)` instead of `AVG(age)` to calculate the average of the correct column. Do reference the table as `Player` instead of `players` to use the proper table name. The amended query now correctly calculates the average of the HS column from the Player table, matching the intended behavior."
        ],
        "rules": [
            "1) When calculating average training hours: use the exact column \"HS\" from the \"Player\" table. 2) When referring to the players table: use the exact table name \"Player\" (not \"players\"). 3) When computing the average: calculate the average of the \"HS\" column values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age) FROM players;",
            "SELECT AVG(HS) FROM Player;"
        ],
        "rule_sql": [
            "SELECT AVG(HS) FROM Player;"
        ]
    },
    "6356": {
        "db_id": "school_bus",
        "question": "Show all home cities except for those having a driver older than 40.",
        "ground_truth": "SELECT home_city FROM driver EXCEPT SELECT home_city FROM driver WHERE age  >  40",
        "amends": [
            "Do remove `DISTINCT` instead of keeping it, and do use `EXCEPT` with a subquery filtering `age > 40` instead of a simple `WHERE age <= 40` filter. Do reference the table as `driver` instead of `drivers` in both main query and subquery. This approach correctly identifies cities that have drivers exclusively aged 40 or younger, rather than just cities with at least one driver aged 40 or younger. The amended query now matches RIGHT_SQL's behavior by using set operations to properly exclude cities that have any drivers over 40."
        ],
        "rules": [
            "1) When the question asks to show all home cities except for those having a driver older than 40: use EXCEPT with a subquery to properly exclude cities that have any drivers over 40 instead of a simple WHERE filter. 2) When referencing the driver table: use the exact table name \"driver\" instead of \"drivers\" in both main query and subquery. 3) When filtering for drivers older than 40: use the condition age > 40 in the subquery to identify cities to exclude. 4) When selecting home cities: do not use DISTINCT in the main query as the EXCEPT operation inherently handles uniqueness."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT home_city FROM drivers WHERE age <= 40;",
            "SELECT Home_city FROM driver EXCEPT SELECT Home_city FROM driver WHERE Age > 40"
        ],
        "rule_sql": [
            "SELECT Home_city FROM driver EXCEPT SELECT Home_city FROM driver WHERE Age > 40"
        ]
    },
    "1904": {
        "db_id": "school_finance",
        "question": "How many budget record has a budget amount smaller than the invested amount?",
        "ground_truth": "SELECT count(*) FROM budget WHERE budgeted  <  invested",
        "amends": [
            "Do reference the `budget` table instead of `budget_records`. Do use the comparison `budgeted < invested` instead of `budget_amount > invested_amount`. The amended query now correctly counts records where the budgeted amount is less than the invested amount, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about budget records: use the table \"budget\" instead of \"budget_records\". 2) When comparing budgeted and invested amounts: use the comparison \"budgeted < invested\" instead of \"budget_amount > invested_amount\" to find records where budgeted amount is smaller than invested amount."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM budget_records WHERE budget_amount > invested_amount;",
            "SELECT COUNT(*) FROM budget WHERE Budgeted < Invested"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM budget WHERE Budgeted < Invested"
        ]
    },
    "669": {
        "db_id": "customers_card_transactions",
        "question": "Show ids, customer ids, names for all accounts.",
        "ground_truth": "SELECT account_id ,  customer_id ,  account_name FROM Accounts",
        "amends": [
            "Do use column names `account_id`, `customer_id`, and `account_name` instead of `id`, `customer_id`, and `name`. Do reference table `Accounts` instead of `accounts`. Do remove the `WHERE id IS NULL` filter instead of keeping it, as the right query returns all records without filtering for null values."
        ],
        "rules": [
            "1) When answering about \"Show ids, customer ids, names for all accounts\": make sure the output order: account_id, customer_id, account_name. 2) When the question mentions \"ids\": \"ids\" actually means \"account_id in schema\". 3) When the question mentions \"names\": \"names\" actually means \"account_name in schema\". 4) When the question asks for \"all accounts\": return all records from table \"Accounts\" without any filtering conditions. 5) When selecting columns from table \"Accounts\": use the exact column names \"account_id\", \"customer_id\", and \"account_name\" as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, customer_id, name FROM accounts WHERE id IS NULL;",
            "SELECT account_id, customer_id, account_name FROM Accounts"
        ],
        "rule_sql": [
            "SELECT account_id, customer_id, account_name FROM Accounts;"
        ]
    },
    "3003": {
        "db_id": "sakila_1",
        "question": "Give the address of the staff member who has the first name Elsa.",
        "ground_truth": "SELECT T2.address FROM staff AS T1 JOIN address AS T2 ON T1.address_id  =  T2.address_id WHERE T1.first_name  =  'Elsa'",
        "amends": [
            "Do select `T2.address` from the address table instead of `address` from the staff table. Do add an explicit `JOIN` between `staff AS T1` and `address AS T2` with the join condition `T1.address_id = T2.address_id` instead of querying the staff table alone. Do maintain the `WHERE` filter `T1.first_name = 'Elsa'` as originally specified. The amended query now correctly retrieves address information from the address table by joining through the address_id relationship instead of incorrectly assuming the address column exists directly in the staff table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for address information about staff members: retrieve the address from the address table (T2.address) instead of from the staff table. 2) When combining staff and address tables: link rows where T1.address_id = T2.address_id and keep only matching pairs (inner join). 3) When filtering for staff with first name Elsa: apply the condition T1.first_name = 'Elsa' exactly as specified, preserving the exact case and quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT address FROM staff WHERE first_name = 'Elsa'",
            "SELECT T2.address \nFROM staff AS T1 \nJOIN address AS T2 ON T1.address_id = T2.address_id \nWHERE T1.first_name = 'Elsa'"
        ],
        "rule_sql": [
            "SELECT a.address \nFROM staff s\nINNER JOIN address a ON s.address_id = a.address_id\nWHERE s.first_name = 'Elsa'"
        ]
    },
    "5303": {
        "db_id": "manufactory_1",
        "question": "What are the names of companies with revenue less than the lowest revenue of any manufacturer in Austin?",
        "ground_truth": "SELECT name FROM manufacturers WHERE revenue  <  (SELECT min(revenue) FROM manufacturers WHERE headquarter  =  'Austin')",
        "amends": [
            "Do reference the `manufacturers` table instead of `companies` in the FROM clause. Do use the filter `headquarter = 'Austin'` instead of `city = 'Austin'` in the subquery predicate. Do maintain the same comparison operator `<` and aggregate function `MIN(revenue)` in the subquery. The amended query now correctly filters manufacturers based on revenue comparison against the minimum revenue of Austin-headquartered manufacturers instead of incorrectly comparing companies against manufacturers."
        ],
        "rules": [
            "1) When answering about companies with revenue less than the lowest revenue of manufacturers in Austin: make sure the output order: name. 2) When the question mentions \"manufacturers in Austin\": \"Austin\" actually means \"headquarter = 'Austin'\" in schema. 3) When comparing company revenue to manufacturer revenue: use the comparison operator `<` to find companies with revenue less than the minimum revenue. 4) When computing the minimum revenue of Austin manufacturers: use the aggregate function MIN(revenue) with the filter headquarter = 'Austin'. 5) When combining data from companies and manufacturers: use a subquery to first compute the minimum revenue from manufacturers with headquarter = 'Austin', then compare company revenue against this value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM companies WHERE revenue < (SELECT MIN(revenue) FROM manufacturers WHERE city = 'Austin')",
            "SELECT Name FROM Manufacturers WHERE Revenue < (SELECT MIN(Revenue) FROM Manufacturers WHERE Headquarter = 'Austin')"
        ],
        "rule_sql": [
            "SELECT Name FROM Manufacturers WHERE Revenue < (SELECT MIN(Revenue) FROM Manufacturers WHERE Headquarter = 'Austin') ORDER BY Name;"
        ]
    },
    "2896": {
        "db_id": "icfp_1",
        "question": "Find the titles of papers whose first author is affiliated with an institution in the country \"Japan\" and has last name \"Ohori\"?",
        "ground_truth": "SELECT t3.title FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid JOIN inst AS t4 ON t2.instid  =  t4.instid WHERE t4.country  =  \"Japan\" AND t2.authorder  =  1 AND t1.lname  =  \"Ohori\"",
        "amends": [
            "Do reference `authorship` and `inst` tables instead of directly joining `authors` to `papers` and `institutions`. Do use `authorship.authid` and `authorship.paperid` for joins instead of `authors.paper_id` and `authors.affiliation`. Do join `inst` on `authorship.instid` instead of joining `institutions` on `authors.affiliation`. Do use `authorder` for author order instead of `author_order`. Do use `lname` for last name instead of `last_name`. Do reference `title` from the `papers` table (aliased as `t3`) instead of directly from `papers`. The amended query now correctly models the relationship between authors, papers, and institutions through the authorship bridge table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for paper titles: use the \"title\" column from the \"Papers\" table (aliased as T3). 2) When the question mentions \"first author\": use \"authorder\" = 1 from the \"authorship\" table. 3) When the question mentions last name \"Ohori\": use \"lname\" = 'Ohori' from the \"Authors\" table. 4) When the question mentions country \"Japan\": use \"country\" = 'Japan' from the \"inst\" table. 5) When combining authors, papers, and institutions: join \"authorship\" (T1) to \"Authors\" (T2) on T1.\"authid\" = T2.\"authid\", join \"authorship\" to \"Papers\" (T3) on T1.\"paperid\" = T3.\"paperid\", and join \"authorship\" to \"inst\" (T4) on T1.\"instid\" = T4.\"instid\", keeping only matching pairs (inner matches)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.title \nFROM papers p \nJOIN authors a ON p.paper_id = a.paper_id \nJOIN institutions i ON a.affiliation = i.institution_id \nWHERE a.author_order = 1 \nAND a.last_name = 'Ohori' \nAND i.country = 'Japan';",
            "SELECT p.title \nFROM Papers p\nJOIN Authorship a ON p.paperID = a.paperID\nJOIN Authors auth ON a.authID = auth.authID\nJOIN Inst i ON a.instID = i.instID\nWHERE i.country = 'Japan' \nAND auth.lname = 'Ohori' \nAND a.authOrder = 1;"
        ],
        "rule_sql": [
            "SELECT T3.title \nFROM Authorship T1\nJOIN Authors T2 ON T1.authID = T2.authID\nJOIN Papers T3 ON T1.paperID = T3.paperID\nJOIN Inst T4 ON T1.instID = T4.instID\nWHERE T1.authOrder = 1\nAND T2.lname = 'Ohori'\nAND T4.country = 'Japan'"
        ]
    },
    "3309": {
        "db_id": "college_1",
        "question": "Find the first names of all instructors who have taught some course and the course code.",
        "ground_truth": "SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num",
        "amends": [
            "Do reference `T2.emp_fname` and `T1.crs_code` instead of `instructor.first_name` and `course.course_code`. Do use explicit `JOIN` syntax with `employee AS T2` and `CLASS AS T1` instead of implicit comma join with `instructor` and `course`. Do join on `T1.prof_num = T2.emp_num` instead of `instructor.id = course.instructor_id`. The amended query now correctly matches the intended table relationships and column references."
        ],
        "rules": [
            "1) When answering about \"first names of instructors who have taught some course and the course code\": make sure the output order: T2.emp_fname, T1.crs_code. 2) When the question mentions \"first names\": \"first names\" actually means \"T2.emp_fname\" in schema. 3) When the question mentions \"course code\": \"course code\" actually means \"T1.crs_code\" in schema. 4) When combining employee table (as T2) and CLASS table (as T1) for instructors who taught courses: link rows where T1.prof_num = T2.emp_num exactly; keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT instructor.first_name, course.course_code FROM instructor, course WHERE instructor.id = course.instructor_id",
            "SELECT T2.EMP_FNAME, T1.CRS_CODE\nFROM CLASS AS T1\nJOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM"
        ],
        "rule_sql": [
            "SELECT T2.EMP_FNAME, T1.CRS_CODE\nFROM CLASS T1\nINNER JOIN EMPLOYEE T2 ON T1.PROF_NUM = T2.EMP_NUM\nORDER BY T2.EMP_FNAME, T1.CRS_CODE;"
        ]
    },
    "5566": {
        "db_id": "products_gen_characteristics",
        "question": "Find the number of characteristics that the product \"flax\" has.",
        "ground_truth": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  \"flax\"",
        "amends": [
            "Do add joins to `product_characteristics` and `CHARACTERISTICS` tables instead of querying only the `products` table. Do use `JOIN` with `t1.product_id = t2.product_id` and `t2.characteristic_id = t3.characteristic_id` instead of omitting these relationships. Do reference `t1.product_name` instead of `name` for the filter condition. Do maintain the `COUNT(*)` aggregation instead of changing it. The amended query now correctly joins related tables to count products with specific characteristics matching the name 'flax'."
        ],
        "rules": [
            "1) When answering about \"number of characteristics that the product 'flax' has\": make sure the output order: COUNT(*) 2) When the question mentions \"flax\": \"flax\" actually means \"t1.product_name = 'flax'\" in schema 3) When combining T1 (products), T2 (product_characteristics), and T3 (CHARACTERISTICS) for shared entities: link rows where t1.product_id = t2.product_id and t2.characteristic_id = t3.characteristic_id; keep only matching pairs (inner match) 4) When counting characteristics for a product: compute the number of rows using the joined relationship between products and their characteristics through product_characteristics"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM products WHERE name = 'flax';",
            "SELECT COUNT(*) \nFROM Products t1\nJOIN Product_Characteristics t2 ON t1.product_id = t2.product_id\nJOIN Characteristics t3 ON t2.characteristic_id = t3.characteristic_id\nWHERE t1.product_name = 'flax'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Products t1\nINNER JOIN Product_Characteristics t2 ON t1.product_id = t2.product_id\nINNER JOIN Characteristics t3 ON t2.characteristic_id = t3.characteristic_id\nWHERE t1.product_name = 'flax'"
        ]
    },
    "6745": {
        "db_id": "activity_1",
        "question": "Which rank has the smallest number of faculty members?",
        "ground_truth": "SELECT rank FROM Faculty GROUP BY rank ORDER BY count(*) ASC LIMIT 1",
        "amends": [
            "Do select only `rank` instead of both `rank` and `COUNT(*) as faculty_count`. Do order by `count(*) ASC` instead of `faculty_count DESC`. Do remove the explicit column alias `faculty_count` instead of keeping it. The amended query now correctly returns the rank with the smallest count of faculty members instead of the largest count."
        ],
        "rules": [
            "1) When answering about \"rank with smallest number of faculty members\": make sure the output order contains only the rank column. 2) When counting faculty members: count all rows using the canonical counting method. 3) When ordering by count to find the smallest: order the results by count in ascending order instead of descending order. 4) When selecting the smallest count result: take only the first row after ordering by count in ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT rank, COUNT(*) as faculty_count FROM faculty GROUP BY rank ORDER BY faculty_count DESC LIMIT 1;",
            "SELECT rank FROM Faculty GROUP BY rank ORDER BY COUNT(*) ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Rank FROM Faculty GROUP BY Rank ORDER BY COUNT(*) ASC LIMIT 1;"
        ]
    },
    "2372": {
        "db_id": "csu_1",
        "question": "How many faculty is there in total in the year of 2002?",
        "ground_truth": "SELECT sum(faculty) FROM faculty WHERE YEAR  =  2002",
        "amends": [
            "Do use `sum(faculty)` instead of `COUNT(*)` to calculate the total faculty count rather than counting rows. Do keep the `WHERE YEAR = 2002` filter unchanged as it correctly restricts to the year 2002. The amended query now correctly sums the faculty values instead of counting rows, matching the intended behavior of calculating total faculty count for the specified year."
        ],
        "rules": [
            "1) When calculating total faculty count: use sum(\"faculty\") instead of counting rows to get the actual total number of faculty members. 2) When filtering by year 2002: keep the condition WHERE \"YEAR\" = 2002 to restrict results to that specific year."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM faculty WHERE year = 2002;",
            "SELECT SUM(Faculty) FROM faculty WHERE Year = 2002"
        ],
        "rule_sql": [
            "SELECT SUM(\"Faculty\") AS TotalFaculty FROM faculty WHERE \"Year\" = 2002"
        ]
    },
    "5003": {
        "db_id": "soccer_2",
        "question": "What are the names and hours spent practicing of every student who received a yes at tryouts?",
        "ground_truth": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'",
        "amends": [
            "Do select `T1.pName` and `T1.HS` instead of `name` and `hours_practiced`. Do join `player AS T1` with `tryout AS T2` on `T1.pID = T2.pID` instead of querying only the `students` table. Do filter on `T2.decision = 'yes'` instead of `tryout_result = 'no'`. The amended query now correctly retrieves players who were accepted to tryouts rather than those who were rejected, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for student names and hours spent practicing: select \"T1\".\"pName\" and \"T1\".\"HS\" as output columns. 2) When combining player and tryout information: link rows where \"T1\".\"pID\" equals \"T2\".\"pID\" and keep only matching pairs (inner join). 3) When filtering for students who received a yes at tryouts: include only rows where \"T2\".\"decision\" equals exactly 'yes' (case-sensitive). 4) When the question mentions \"student\": this refers to the \"player\" table in the schema, not a \"students\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, hours_practiced FROM students WHERE tryout_result = 'no';",
            "SELECT T1.pName, T1.HS FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T2.decision = 'yes'"
        ],
        "rule_sql": [
            "SELECT T1.pName, T1.HS FROM Player T1 INNER JOIN Tryout T2 ON T1.pID = T2.pID WHERE T2.decision = 'yes'"
        ]
    },
    "4544": {
        "db_id": "company_office",
        "question": "Count the number of companies.",
        "ground_truth": "SELECT count(*) FROM Companies",
        "amends": [
            "Do query the `Companies` table instead of the `employees` table, as the data source has changed to reflect the correct business context. The amended query now matches RIGHT_SQL's behavior by counting records from the appropriate table."
        ],
        "rules": [
            "1) When counting the number of companies: use the \"Companies\" table instead of the \"employees\" table to match the correct business context. 2) When the question asks for \"count of companies\": compute the number of rows from the \"Companies\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees;",
            "SELECT COUNT(*) FROM Companies;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Companies;"
        ]
    },
    "6889": {
        "db_id": "tracking_orders",
        "question": "Find the id of the order whose shipment tracking number is \"3452\".",
        "ground_truth": "SELECT order_id FROM shipments WHERE shipment_tracking_number = \"3452\"",
        "amends": [
            "Do select `order_id` from the `shipments` table instead of `id` from the `orders` table. Do filter on `shipment_tracking_number` with string value \"3452\" instead of `tracking_number` with numeric value 3452. The amended query now correctly retrieves shipment information using the appropriate table and tracking number format."
        ],
        "rules": [
            "1) When the question asks for the id of an order based on shipment tracking number: select \"order_id\" from the \"Shipments\" table instead of \"id\" from the \"orders\" table. 2) When filtering by shipment tracking number with value \"3452\": use the exact string literal \"3452\" with double quotes and filter on \"shipment_tracking_number\" column instead of treating it as a numeric value. 3) When the question mentions \"shipment tracking number\": this corresponds to the \"shipment_tracking_number\" column in the \"Shipments\" table, not \"tracking_number\" in the \"orders\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM orders WHERE tracking_number = 3452;",
            "SELECT order_id FROM Shipments WHERE shipment_tracking_number = '3452';"
        ],
        "rule_sql": [
            "SELECT order_id FROM Shipments WHERE shipment_tracking_number = \"3452\";"
        ]
    },
    "436": {
        "db_id": "flight_1",
        "question": "What is the salaray and name of the employee that is certified to fly the most planes?",
        "ground_truth": "SELECT T1.name ,  T1.salary FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do specify `T1.name` and `T1.salary` with table aliases instead of unqualified `name` and `salary`. Do use `FROM Employee AS T1 JOIN Certificate AS T2` instead of `FROM employees` with no join. Do add `ON T1.eid = T2.eid` join condition instead of missing join predicate. Do add `GROUP BY T1.eid` instead of omitting grouping. Do use `count(*)` in ORDER BY instead of `COUNT(certifications.plane_id)` with incorrect table reference. Do reference correct table names `Employee` and `Certificate` instead of `employees` and `certifications`. The amended query now correctly counts certificates per employee and returns the employee with the most certificates, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about employee salary and name: make sure the output order: T1.name, T1.salary 2) When combining Employee and Certificate tables: link rows where T1.eid = T2.eid and keep only matching pairs (inner match) 3) When counting certificates per employee: compute the number of rows using count(*) grouped by T1.eid 4) When finding the employee with the most certificates: rank employees by certificate count in descending order and keep the first 1 row 5) When referring to table names: use exact identifiers \"Employee\" AS T1 and \"Certificate\" AS T2 instead of alternative names"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, salary FROM employees ORDER BY COUNT(certifications.plane_id) DESC LIMIT 1;",
            "SELECT T1.name, T1.salary\nFROM Employee AS T1\nJOIN Certificate AS T2 ON T1.eid = T2.eid\nGROUP BY T1.eid\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.name, T1.salary\nFROM Employee AS T1\nINNER JOIN Certificate AS T2 ON T1.eid = T2.eid\nGROUP BY T1.eid\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "6559": {
        "db_id": "wine_1",
        "question": "List the names of all distinct wines in alphabetical order.",
        "ground_truth": "SELECT DISTINCT Name FROM WINE ORDER BY Name",
        "amends": [
            "Do add `DISTINCT` instead of omitting it to eliminate duplicate wine names. Do use `Name` column instead of `name` to match the correct column casing. Do remove explicit `ASC` ordering since it's the default behavior. The amended query now correctly returns unique wine names in alphabetical order, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"distinct wines\": use DISTINCT to eliminate duplicate values from the \"Name\" column. 2) When the question mentions \"wines in alphabetical order\": order the results by the \"Name\" column in ascending order (which is the default behavior). 3) When referring to wine names: use the exact column token \"Name\" (with proper casing) instead of \"name\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM wines ORDER BY name ASC;",
            "SELECT DISTINCT Name FROM wine ORDER BY Name;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Name FROM wine ORDER BY Name;"
        ]
    },
    "1102": {
        "db_id": "match_season",
        "question": "Show the name of colleges that have at least two players in descending alphabetical order.",
        "ground_truth": "SELECT College FROM match_season GROUP BY College HAVING count(*)  >=  2 ORDER BY College DESC",
        "amends": [
            "Do select `College` instead of `name` and do aggregate with `GROUP BY` and `HAVING count(*) >= 2` instead of selecting from a single table without grouping. Do source from `match_season` instead of `colleges` and do maintain `ORDER BY College DESC` instead of `ORDER BY name DESC` but now applied to the grouped results. The amended query now correctly identifies colleges with multiple matches by using grouping and filtering on the count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about colleges with at least two players: use the \"College\" column from the match_season table instead of \"name\" from colleges table. 2) When counting players per college: group by \"College\" and count the number of rows per group, keeping only groups where the count is at least 2. 3) When ordering colleges in descending alphabetical order: sort the results by \"College\" in descending order after grouping and filtering."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM colleges ORDER BY name DESC;",
            "SELECT College FROM match_season GROUP BY College HAVING COUNT(*) >= 2 ORDER BY College DESC;"
        ],
        "rule_sql": [
            "SELECT College FROM match_season GROUP BY College HAVING COUNT(*) >= 2 ORDER BY College DESC;"
        ]
    },
    "5306": {
        "db_id": "manufactory_1",
        "question": "Find the total revenue of companies of each founder.",
        "ground_truth": "SELECT sum(revenue) ,  founder FROM manufacturers GROUP BY founder",
        "amends": [
            "Do select `sum(revenue)` and `founder` instead of `founder` and `SUM(revenue)`. Do use table `manufacturers` instead of `companies`. Do group by `founder` instead of `company_id`. The amended query now correctly aggregates revenue by founder from the manufacturers table.",
            "Do place the `SUM(revenue)` aggregate function first in the SELECT list instead of placing `founder` first. Do maintain the same `GROUP BY founder` clause instead of changing the grouping logic. Do use lowercase `manufacturers` as the table name instead of uppercase `Manufacturers` for consistency. The amended query now correctly calculates total revenue per founder while maintaining the same logical behavior as the RIGHT_SQL."
        ],
        "rules": [
            "1) When answering about \"total revenue of companies of each founder\": make sure the output order: founder, sum(revenue). 2) When the question mentions \"companies\": \"companies\" actually means \"manufacturers\" in schema. 3) When the question asks for \"total revenue per founder\": organize results by founder and compute sum of revenue per group. 4) When grouping by founder: use the exact grouping key founder instead of company_id.",
            "1) When answering about \"total revenue of companies of each founder\": make sure the output order: SUM(revenue) first, then founder. 2) When the question mentions \"founder\": use the exact column token \"founder\" for grouping. 3) When the question mentions \"revenue\": use the exact column token \"revenue\" for summation. 4) When referring to the table containing company data: use the exact table name \"manufacturers\" in lowercase. 5) When computing total revenue per founder: group by the \"founder\" column and calculate the sum of \"revenue\" for each group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT founder, SUM(revenue) FROM companies GROUP BY company_id;",
            "SELECT founder, SUM(revenue) FROM Manufacturers GROUP BY founder;",
            "SELECT SUM(revenue), founder FROM manufacturers GROUP BY founder"
        ],
        "rule_sql": [
            "SELECT SUM(revenue) AS total_revenue, founder FROM manufacturers GROUP BY founder"
        ]
    },
    "6070": {
        "db_id": "customers_and_addresses",
        "question": "Return all the distinct payment methods used by customers.",
        "ground_truth": "SELECT DISTINCT payment_method FROM customers",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT payment_method FROM customers"
        ],
        "rule_sql": [
            "SELECT DISTINCT payment_method FROM Customers;"
        ]
    },
    "2408": {
        "db_id": "candidate_poll",
        "question": "Find the average height and weight for all males (sex is M).",
        "ground_truth": "SELECT avg(height) ,  avg(weight) FROM people WHERE sex  =  'M'",
        "amends": [
            "Do filter with `sex = 'M'` instead of `sex = 'F'` in the WHERE clause, changing the gender condition from female to male. The amended query now correctly calculates average height and weight for male individuals instead of female individuals, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for average height and weight for males (sex is M): use the condition sex = 'M' instead of sex = 'F' in the filtering clause. 2) When computing averages for height and weight: calculate the average of the height column and the average of the weight column from the people table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(height), AVG(weight) FROM people WHERE sex = 'F';",
            "SELECT AVG(Height) AS Average_Height, AVG(Weight) AS Average_Weight FROM people WHERE Sex = 'M'"
        ],
        "rule_sql": [
            "SELECT AVG(Height) AS average_height, AVG(Weight) AS average_weight FROM people WHERE Sex = 'M'"
        ]
    },
    "2566": {
        "db_id": "county_public_safety",
        "question": "Show the police force shared by counties with location on the east and west.",
        "ground_truth": "SELECT Police_force FROM county_public_safety WHERE LOCATION  =  \"East\" INTERSECT SELECT Police_force FROM county_public_safety WHERE LOCATION  =  \"West\"",
        "amends": [
            "Do use table name `county_public_safety` instead of `counties`. Do change column name `police_force` to `Police_force` with proper capitalization instead of lowercase. Do use `INTERSECT` to find common police forces between locations instead of attempting to use `AND` with contradictory `location = 'east' AND location = 'west'`. Do use double quotes for string literals `\"East\"` and `\"West\"` instead of single quotes. Do capitalize location values `\"East\"` and `\"West\"` instead of lowercase. Do split the query into two separate SELECT statements with INTERSECT instead of a single query with impossible WHERE conditions. The amended query now correctly finds police forces that serve both East and West locations using proper INTERSECT semantics."
        ],
        "rules": [
            "1) When the question mentions \"counties\": use table name \"county_public_safety\" instead of \"counties\". 2) When the question mentions \"police force\": use column name \"Police_force\" with exact capitalization instead of lowercase \"police_force\". 3) When finding entities shared between locations \"east\" and \"west\": use INTERSECT operation between two separate queries instead of AND conditions with contradictory location values. 4) When specifying location values: use double-quoted literals \"East\" and \"West\" with exact capitalization instead of lowercase single-quoted values. 5) When the question asks for police forces shared by counties on east and west: find the intersection of police forces from locations \"East\" and \"West\" using proper INTERSECT semantics."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT police_force FROM counties WHERE location = 'east' AND location = 'west';",
            "SELECT Police_force FROM county_public_safety WHERE Location = \"East\" INTERSECT SELECT Police_force FROM county_public_safety WHERE Location = \"West\""
        ],
        "rule_sql": [
            "SELECT Police_force FROM county_public_safety WHERE Location = \"East\" INTERSECT SELECT Police_force FROM county_public_safety WHERE Location = \"West\""
        ]
    },
    "4993": {
        "db_id": "soccer_2",
        "question": "What is the name of the school with smallest enrollment size per state?",
        "ground_truth": "SELECT cName ,  state ,  min(enr) FROM college GROUP BY state",
        "amends": [
            "Do reference table `college` instead of `schools` and use column `cName` instead of `name` in the SELECT list. Do use column `enr` instead of `enrollment` for the aggregate function. Do maintain the `MIN` aggregate function and `GROUP BY state` clause without changes. The amended query now correctly references the intended table and column names while preserving the original aggregation logic."
        ],
        "rules": [
            "1) When answering about \"school with smallest enrollment size per state\": make sure the output order: state, name, enrollment size. 2) When the question mentions \"school\": \"school\" actually means \"College\" in schema. 3) When the question mentions \"name\": \"name\" actually means \"cName\" in schema. 4) When the question mentions \"enrollment size\": \"enrollment size\" actually means \"enr\" in schema. 5) When the question says \"per state\"/\"by state\": organize results by state and compute requested aggregates per group. 6) When the question asks for \"smallest enrollment size\": compute the minimum value of \"enr\" per group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT state, name, MIN(enrollment) FROM schools GROUP BY state;",
            "SELECT cName, state, MIN(enr) AS min_enrollment\nFROM College\nGROUP BY state;"
        ],
        "rule_sql": [
            "WITH MinEnrollmentPerState AS (\n    SELECT \n        state,\n        MIN(enr) as min_enr\n    FROM College\n    GROUP BY state\n)\nSELECT \n    c.state, \n    c.cName as name, \n    c.enr as enrollment_size\nFROM College c\nJOIN MinEnrollmentPerState m ON c.state = m.state AND c.enr = m.min_enr\nORDER BY c.state, c.cName;"
        ]
    },
    "567": {
        "db_id": "store_1",
        "question": "List the number of invoices and the invoice total from California.",
        "ground_truth": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  \"CA\";",
        "amends": [
            "Do add `billing_state` to the SELECT list instead of omitting it. Do use `COUNT(*)` without an alias instead of aliasing it as `invoice_count`. Do use `SUM(total)` without an alias instead of aliasing it as `invoice_total`. Do filter on `billing_state = \"CA\"` instead of `state = 'California'` to use the correct column name and state abbreviation format. The amended query now correctly returns the billing state along with count and sum metrics using proper column references and state code formatting."
        ],
        "rules": [
            "1) When the question asks for invoices from California: use \"CA\" as the state abbreviation instead of 'California' in the filter condition. 2) When filtering by state: use the column \"billing_state\" instead of \"state\" to match the schema. 3) When counting invoices: use COUNT(*) without an alias instead of aliasing it as invoice_count. 4) When summing invoice totals: use SUM(total) without an alias instead of aliasing it as invoice_total. 5) When selecting output columns: include \"billing_state\" in the output list to show the state being filtered on."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) as invoice_count, SUM(total) as invoice_total \nFROM invoices \nWHERE state = 'California';",
            "SELECT billing_state, COUNT(*), SUM(total) FROM invoices WHERE billing_state = 'CA'"
        ],
        "rule_sql": [
            "SELECT billing_state, COUNT(*), SUM(total) FROM invoices WHERE billing_state = 'CA';"
        ]
    },
    "5774": {
        "db_id": "customer_complaints",
        "question": "List the name of all products along with the number of complaints that they have received.",
        "ground_truth": "SELECT t1.product_name ,  count(*) FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_name",
        "amends": [
            "Do use `t1.product_name` in the SELECT list instead of `p.name`, and do use `count(*)` instead of `COUNT(c.id) AS complaint_count`. Do use `JOIN` instead of `LEFT JOIN`, and do join on `t1.product_id = t2.product_id` instead of `p.id = c.product_id`. Do remove the ORDER BY clause instead of keeping it. The amended query now matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"products and their complaint counts\": make sure the output order: product_name first, then complaint_count. 2) When the question mentions \"name of all products\": \"name\" actually means \"product_name in schema\" and use exact token \"t1.product_name\". 3) When the question asks for \"number of complaints\": compute count using \"count(*)\" instead of counting specific IDs. 4) When combining products and complaints tables: link rows where \"t1.product_id = t2.product_id\" exactly as shown; keep only matching pairs (inner match) using JOIN instead of LEFT JOIN. 5) When organizing results by product: group by \"t1.product_name\" to compute aggregates per product. 6) When producing final output: do not include any ordering clause as the question does not specify any sorting requirement."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.name, COUNT(c.id) AS complaint_count\nFROM products p\nLEFT JOIN complaints c ON p.id = c.product_id\nGROUP BY p.name\nORDER BY complaint_count DESC;",
            "SELECT t1.product_name, COUNT(*) AS complaint_count\nFROM Products t1\nJOIN Complaints t2 ON t1.product_id = t2.product_id\nGROUP BY t1.product_name"
        ],
        "rule_sql": [
            "SELECT t1.product_name, COUNT(*) AS complaint_count FROM Products t1 JOIN Complaints t2 ON t1.product_id = t2.product_id GROUP BY t1.product_name"
        ]
    },
    "3182": {
        "db_id": "college_1",
        "question": "How many classes does the professor whose last name is Graztevski teach?",
        "ground_truth": "SELECT count(*) FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE T1.EMP_LNAME  =  'Graztevski'",
        "amends": [
            "Do use `employee AS T1` joined to `CLASS AS T2` on `T1.EMP_NUM = T2.PROF_NUM` instead of querying only `professors` table. Do filter on `T1.EMP_LNAME = 'Graztevski'` instead of `last_name = 'Graztevski'` to match the correct table structure. The amended query now correctly counts classes taught by Professor Graztevski by joining employee and class tables instead of using a non-existent professors table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about classes taught by a professor: use table \"employee\" as T1 joined to table \"CLASS\" as T2 on T1.EMP_NUM = T2.PROF_NUM instead of querying only a professors table. 2) When filtering for a professor's last name: use T1.EMP_LNAME = 'Graztevski' instead of last_name = 'Graztevski' to match the correct table structure. 3) When counting classes taught by a professor: count the number of rows from T2 where T1.EMP_NUM = T2.PROF_NUM and T1.EMP_LNAME matches the specified value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM professors WHERE last_name = 'Graztevski';",
            "SELECT COUNT(*) \nFROM EMPLOYEE AS T1 \nJOIN CLASS AS T2 ON T1.EMP_NUM = T2.PROF_NUM \nWHERE T1.EMP_LNAME = 'Graztevski'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM EMPLOYEE AS T1 \nJOIN CLASS AS T2 ON T1.EMP_NUM = T2.PROF_NUM \nWHERE T1.EMP_LNAME = 'Graztevski'"
        ]
    },
    "5434": {
        "db_id": "shop_membership",
        "question": "Show all cities without a branch having more than 100 memberships.",
        "ground_truth": "SELECT city FROM branch EXCEPT SELECT city FROM branch WHERE membership_amount  >  100",
        "amends": [
            "Do use `EXCEPT` set operation to find cities from the `branch` table that are not present in cities with membership amounts exceeding 100, instead of filtering `branches` table directly with `membership_count <= 100`. Do reference the correct table name `branch` instead of `branches` in both parts of the query. Do filter by `membership_amount > 100` instead of `membership_count <= 100` to properly exclude cities with high membership amounts. Do remove the `WHERE` clause from the first part of the query and instead use set-based exclusion logic. The amended query now correctly identifies cities that do not have any branches with membership amounts exceeding 100, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for cities without branches having more than 100 memberships: use a set operation to exclude cities that have branches with membership amounts exceeding 100. 2) When referring to the branch table: use the exact table name \"branch\" instead of \"branches\". 3) When filtering for high membership amounts: use the exact condition \"membership_amount > 100\" to identify branches with more than 100 memberships. 4) When performing set operations: use EXCEPT to remove cities that have branches meeting the high membership condition from the complete list of cities with branches."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city FROM branches WHERE membership_count <= 100;",
            "SELECT City FROM branch\nEXCEPT\nSELECT City FROM branch WHERE membership_amount > 100"
        ],
        "rule_sql": [
            "SELECT DISTINCT City FROM branch\nEXCEPT\nSELECT DISTINCT City FROM branch WHERE membership_amount > 100"
        ]
    },
    "2650": {
        "db_id": "local_govt_mdm",
        "question": "Wat is the tax source system code and master customer id of the taxes related to each parking fine id?",
        "ground_truth": "SELECT T1.source_system_code ,  T1.master_customer_id ,  T2.council_tax_id FROM CMI_Cross_References AS T1 JOIN Parking_Fines AS T2 ON T1.cmi_cross_ref_id  =  T2.cmi_cross_ref_id",
        "amends": [
            "Do select `T1.source_system_code`, `T1.master_customer_id`, and `T2.council_tax_id` instead of `parking_fine_id`, `tax_source_system_code`, and `customer_id`. Do use `FROM CMI_Cross_References AS T1 JOIN Parking_Fines AS T2` instead of `FROM taxes`. Do add `ON T1.cmi_cross_ref_id = T2.cmi_cross_ref_id` join condition instead of omitting it. The amended query now correctly joins the cross-reference and parking fines tables to retrieve the appropriate system codes and customer identifiers."
        ],
        "rules": [
            "1) When answering about \"tax source system code and master customer id of the taxes related to each parking fine id\": make sure the output order: T1.source_system_code, T1.master_customer_id, T2.council_tax_id. 2) When the question mentions \"parking fine id\": \"parking fine id\" actually means \"T2.council_tax_id in schema\". 3) When the question mentions \"tax source system code\": \"tax source system code\" actually means \"T1.source_system_code in schema\". 4) When the question mentions \"master customer id\": \"master customer id\" actually means \"T1.master_customer_id in schema\". 5) When combining T1 and T2 for shared entities: link rows where T1.cmi_cross_ref_id = T2.cmi_cross_ref_id; keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT parking_fine_id, tax_source_system_code, customer_id FROM taxes",
            "SELECT T1.source_system_code, T1.master_customer_id, T2.council_tax_id\nFROM CMI_Cross_References AS T1\nJOIN Parking_Fines AS T2 ON T1.cmi_cross_ref_id = T2.cmi_cross_ref_id;"
        ],
        "rule_sql": [
            "SELECT T1.source_system_code, T1.master_customer_id, T2.council_tax_id\nFROM CMI_Cross_References T1\nINNER JOIN Parking_Fines T2 ON T1.cmi_cross_ref_id = T2.cmi_cross_ref_id\nORDER BY T1.source_system_code, T1.master_customer_id, T2.council_tax_id"
        ]
    },
    "4192": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "What are the name and description for role code \"MG\"?",
        "ground_truth": "SELECT role_name ,  role_description FROM ROLES WHERE role_code  =  \"MG\"",
        "amends": [
            "Do use column aliases `role_name` and `role_description` instead of the original column names `name` and `description`. Do use double quotes `\"MG\"` instead of single quotes `'MG'` for the string literal in the WHERE clause. The amended query now correctly references the intended columns with proper quoting and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"name and description\" from the roles table: use the exact column aliases \"role_name\" and \"role_description\" in the output. 2) When filtering for role code \"MG\": use double quotes around the literal value exactly as \"MG\" in the condition. 3) When answering about role code information: make sure the output order is \"role_name\" followed by \"role_description\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, description FROM roles WHERE role_code = 'MG';",
            "SELECT Role_Name AS role_name, Role_Description AS role_description FROM Roles WHERE Role_Code = \"MG\";"
        ],
        "rule_sql": [
            "SELECT Role_Name AS role_name, Role_Description AS role_description FROM Roles WHERE Role_Code = \"MG\";"
        ]
    },
    "1700": {
        "db_id": "epinions_1",
        "question": "Find the titles of items whose rating is higher than the average review rating of all items.",
        "ground_truth": "SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id WHERE T2.rating  >  (SELECT avg(rating) FROM review)",
        "amends": [
            "Do specify the table alias `T1` for the `title` column instead of referencing it without qualification. Do add a `JOIN` between `item AS T1` and `review AS T2` on `T1.i_id = T2.i_id` instead of querying only the `items` table. Do change the filter to reference `T2.rating` instead of the ambiguous `rating` column. Do update the subquery to reference the `review` table instead of `reviews` for consistency with the main query's table structure. The amended query now correctly correlates item titles with their corresponding review ratings and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"titles of items whose rating is higher than the average review rating\": make sure the output order: T1.title 2) When the question mentions \"items\": use table \"item\" with alias T1 3) When the question mentions \"review rating\": use table \"review\" with alias T2 and column T2.rating 4) When combining T1 and T2 for shared entities: link rows where T1.i_id = T2.i_id and keep only matching pairs (inner match) 5) When computing average review rating: calculate the average of T2.rating from all rows in T2 6) When filtering items: keep only rows where T2.rating is greater than the computed average rating"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM items WHERE rating > (SELECT AVG(rating) FROM reviews);",
            "SELECT T1.title \nFROM item AS T1 \nJOIN review AS T2 ON T1.i_id = T2.i_id \nWHERE T2.rating > (SELECT AVG(rating) FROM review)"
        ],
        "rule_sql": [
            "SELECT T1.title FROM item T1 INNER JOIN review T2 ON T1.i_id = T2.i_id WHERE T2.rating > (SELECT AVG(T2.rating) FROM review T2) ORDER BY T1.title;"
        ]
    },
    "5415": {
        "db_id": "shop_membership",
        "question": "What are the different membership levels?",
        "ground_truth": "SELECT count(DISTINCT LEVEL) FROM member",
        "amends": [
            "Do `SELECT count(DISTINCT LEVEL)` instead of `SELECT *`. Do `FROM member` instead of `FROM members`. Do remove `WHERE level IS NOT NULL` instead of keeping it, as counting distinct values inherently handles NULLs appropriately. The amended query now correctly counts distinct level values from the member table instead of returning all rows with non-null levels."
        ],
        "rules": [
            "1) When answering about \"different membership levels\": count the number of unique values in the \"LEVEL\" column. 2) When counting distinct values: use the exact column token \"LEVEL\" from the member table. 3) When handling NULL values in distinct counts: do not filter out NULL values explicitly as distinct counting inherently handles them appropriately. 4) When referring to the table: use the exact table name \"member\" (not \"members\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM members WHERE level IS NOT NULL",
            "SELECT COUNT(DISTINCT Level) FROM member"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Level) FROM member;"
        ]
    },
    "385": {
        "db_id": "flight_1",
        "question": "Show all flight number from Los Angeles.",
        "ground_truth": "SELECT flno FROM Flight WHERE origin  =  \"Los Angeles\"",
        "amends": [
            "Do reference column `flno` instead of `flight_number` in the SELECT list. Do reference table `Flight` instead of `flights` in the FROM clause. Do use filter condition `origin = \"Los Angeles\"` instead of `departure_city = 'Los Angeles'` in the WHERE clause. The amended query now correctly matches the intended behavior by using the proper column and table names from the schema."
        ],
        "rules": [
            "1) When the question asks for \"flight number\": use the exact column token \"flno\" from table \"Flight\". 2) When the question mentions \"from Los Angeles\": use the exact filter condition origin = \"Los Angeles\" with double quotes around the city name. 3) When referencing the flights table: use the exact table name \"Flight\" instead of \"flights\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_city = 'Los Angeles';",
            "SELECT flno FROM flight WHERE origin = 'Los Angeles';"
        ],
        "rule_sql": [
            "SELECT flno FROM flight WHERE origin = \"Los Angeles\""
        ]
    },
    "1067": {
        "db_id": "match_season",
        "question": "Count the number of different teams involved in match season.",
        "ground_truth": "SELECT count(DISTINCT Team) FROM match_season",
        "amends": [
            "Do count `DISTINCT Team` instead of `COUNT(*)` to count unique teams rather than all rows. Do reference table `match_season` instead of `matches` to use the correct table name. Do remove the `WHERE season = 'match season'` filter instead of keeping it, as the right query operates on the entire table without filtering. The amended query now correctly counts distinct teams from the match_season table, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When counting different teams: count distinct values of \"Team\" column instead of counting all rows. 2) When referencing the match season data: use table \"match_season\" instead of \"matches\". 3) When the question asks about teams involved in match season: do not apply any filter condition on season column as the count should include all teams from the entire table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE season = 'match season';",
            "SELECT COUNT(DISTINCT Team) FROM match_season;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Team) FROM match_season"
        ]
    },
    "3855": {
        "db_id": "insurance_policies",
        "question": "What are the method, date and amount of each payment? Sort the list in ascending order of date.",
        "ground_truth": "SELECT Payment_Method_Code ,  Date_Payment_Made ,  Amount_Payment FROM Payments ORDER BY Date_Payment_Made ASC",
        "amends": [
            "Do use exact column names `Payment_Method_Code`, `Date_Payment_Made`, and `Amount_Payment` instead of incorrect aliases `method`, `date`, and `amount`. Do change the sort direction to `ASC` instead of `DESC` to order by ascending date instead of descending. The amended query now correctly references the actual column names from the Payments table and sorts in chronological order."
        ],
        "rules": [
            "1) When the question asks for \"method, date and amount\" of payments: use the exact column names \"Payment_Method_Code\", \"Date_Payment_Made\", and \"Amount_Payment\" from the Payments table. 2) When the question specifies sorting in \"ascending order of date\": order the results by \"Date_Payment_Made\" in ascending (chronological) order instead of descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT method, date, amount FROM payments ORDER BY date DESC;",
            "SELECT Payment_Method_Code, Date_Payment_Made, Amount_Payment FROM Payments ORDER BY Date_Payment_Made ASC;"
        ],
        "rule_sql": [
            "SELECT Payment_Method_Code, Date_Payment_Made, Amount_Payment FROM Payments ORDER BY Date_Payment_Made ASC;"
        ]
    },
    "5726": {
        "db_id": "dorm_1",
        "question": "Find the number and average age of students living in each city.",
        "ground_truth": "SELECT count(*) ,  avg(age) ,  city_code FROM student GROUP BY city_code",
        "amends": [
            "Do select `count(*)` and `avg(age)` without aliases instead of using `COUNT(*) as number_of_students` and `AVG(age) as average_age`. Do reference `city_code` instead of `city` as the grouping column. Do use table name `student` instead of `students` in the FROM clause. Do remove the `city` column from the SELECT list instead of including it, as it's redundant when grouping by `city_code`. The amended query now correctly aggregates student data by city code rather than city name, matching the intended behavior.",
            "Do list the aggregate functions `count(*)` and `avg(age)` before the grouping column `city_code` instead of placing the grouping column first in the SELECT list. Do maintain the same GROUP BY clause with `city_code` as the grouping key. The amended query now correctly follows standard SQL convention by placing aggregate functions before grouping columns while preserving the same logical behavior and output as the right SQL."
        ],
        "rules": [
            "1) When the question asks for \"number and average age of students living in each city\": use the exact column token \"city_code\" for grouping instead of \"city\". 2) When counting students: count all rows using count(*) without an alias. 3) When calculating average age: use avg(age) without an alias. 4) When selecting from the student table: use the exact table name \"student\" instead of \"students\". 5) When grouping by city_code: do not include the city_code column in the output selection as it's redundant with grouping.",
            "1) When answering about \"number and average age of students living in each city\": make sure the output order: COUNT(*), AVG(Age), city_code 2) When the question mentions \"each city\": \"city\" actually means \"city_code in Student table\" 3) When the question asks for \"number of students\": compute the count of all rows using the canonical key for students 4) When the question asks for \"average age\": compute the average of the Age column 5) When the question says \"per city\"/\"by city\": organize results by city_code and compute requested aggregates per group"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, COUNT(*) as number_of_students, AVG(age) as average_age FROM students GROUP BY city;",
            "SELECT city_code, COUNT(*), AVG(Age) FROM Student GROUP BY city_code;",
            "SELECT count(*), avg(age), city_code FROM Student GROUP BY city_code"
        ],
        "rule_sql": [
            "SELECT COUNT(*), AVG(Age) FROM Student GROUP BY city_code"
        ]
    },
    "6433": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "List ids and details for all projects.",
        "ground_truth": "SELECT project_id ,  project_details FROM Projects",
        "amends": [
            "Do select specific columns `project_id` and `project_details` instead of using `*` to select all columns. Do query from the `Projects` table instead of the `employees` table. Do remove the `WHERE department = 'IT'` filter instead of keeping it, as the right query does not require any filtering conditions. The amended query now correctly retrieves only the project_id and project_details columns from the Projects table without any unnecessary filtering, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"List ids and details for all projects\": make sure the output order: project_id, project_details. 2) When the question mentions \"projects\": \"projects\" actually means \"Projects table in schema\". 3) When selecting columns from the Projects table: use the exact column names project_id and project_details. 4) When retrieving all projects: do not apply any filtering conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM employees WHERE department = 'IT';",
            "SELECT project_id, project_details FROM Projects"
        ],
        "rule_sql": [
            "SELECT project_id, project_details FROM Projects;"
        ]
    },
    "2313": {
        "db_id": "perpetrator",
        "question": "What are the names of perpetrators in country \"China\" or \"Japan\"?",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN perpetrator AS T2 ON T1.People_ID  =  T2.People_ID WHERE T2.Country  =  \"China\" OR T2.Country  =  \"Japan\"",
        "amends": [
            "Do select `T1.Name` from the `people` table instead of `name` from the `perpetrators` table. Do join `perpetrator AS T2` on `T1.People_ID = T2.People_ID` instead of querying a single table. Do use `OR` condition for `T2.Country = \"China\" OR T2.Country = \"Japan\"` instead of the impossible `AND` condition `country = 'China' AND country = 'Japan'`. The amended query now correctly retrieves names from the people table joined with perpetrator data using an OR condition for multiple country values, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"names of perpetrators in country 'China' or 'Japan'\": make sure the output order: T1.Name 2) When the question mentions \"perpetrators\": \"perpetrators\" actually means \"T2 (perpetrator table) in schema\" 3) When the question mentions \"country 'China' or 'Japan'\": use the exact literals \"China\" and \"Japan\" with OR condition T2.Country = \"China\" OR T2.Country = \"Japan\" 4) When combining T1 (people) and T2 (perpetrator) for shared entities: link rows where T1.People_ID = T2.People_ID exactly as shown; keep only matching pairs (inner match) 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for \"China\" and \"Japan\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM perpetrators WHERE country = 'China' AND country = 'Japan';",
            "SELECT T1.Name FROM people AS T1 JOIN perpetrator AS T2 ON T1.People_ID = T2.People_ID WHERE T2.Country = 'China' OR T2.Country = 'Japan'"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM people T1 JOIN perpetrator T2 ON T1.People_ID = T2.People_ID WHERE T2.Country = \"China\" OR T2.Country = \"Japan\" ORDER BY T1.Name"
        ]
    },
    "713": {
        "db_id": "customers_card_transactions",
        "question": "What is the customer id with most number of cards, and how many does he have?",
        "ground_truth": "SELECT customer_id ,  count(*) FROM Customers_cards GROUP BY customer_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference table `Customers_cards` instead of `cards` in the FROM clause. Do order by `count(*) DESC` instead of `ASC` to find the customer with the most cards rather than the fewest. Do remove the alias `card_count` from the COUNT(*) expression instead of keeping it, as the ORDER BY clause directly references the aggregate function. The amended query now correctly identifies the customer with the highest number of cards by counting from the appropriate table and sorting in descending order."
        ],
        "rules": [
            "1) When answering about \"customer id with most number of cards\": make sure the output order: customer_id, COUNT(*) 2) When counting cards: use table \"Customers_cards\" instead of \"cards\" 3) When finding the customer with the most cards: order by COUNT(*) in descending direction instead of ascending 4) When ordering by aggregate results: reference the aggregate function COUNT(*) directly instead of using an alias 5) When limiting to the top result: keep only the first row after ordering by COUNT(*) in descending order"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT customer_id, COUNT(*) as card_count FROM cards GROUP BY customer_id ORDER BY card_count ASC LIMIT 1;",
            "SELECT customer_id, COUNT(*) \nFROM Customers_Cards \nGROUP BY customer_id \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT customer_id, COUNT(*) FROM Customers_Cards GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "2706": {
        "db_id": "storm_record",
        "question": "List name and damage for all storms in a descending order of max speed.",
        "ground_truth": "SELECT name ,  damage_millions_USD FROM storm ORDER BY max_speed DESC",
        "amends": [
            "Do select `damage_millions_USD` instead of `max_speed` in the SELECT list. Do query from `storm` table instead of `storms` table. Do order by `max_speed DESC` instead of `damage DESC`. The amended query now correctly retrieves storm names with their damage amounts ordered by maximum wind speed."
        ],
        "rules": [
            "1) When selecting columns for storm information: include \"name\" and \"damage_millions_USD\" in the output columns. 2) When querying storm data: use the \"storm\" table (not \"storms\"). 3) When ordering results by maximum wind speed: sort by \"max_speed\" in descending order (DESC). 4) When the question asks for \"damage\": use the exact column \"damage_millions_USD\" from the storm table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, max_speed FROM storms ORDER BY damage DESC;",
            "SELECT Name, Damage_millions_USD FROM storm ORDER BY Max_speed DESC;"
        ],
        "rule_sql": [
            "SELECT name, damage_millions_USD FROM storm ORDER BY max_speed DESC;"
        ]
    },
    "871": {
        "db_id": "chinook_1",
        "question": "Please show the employee last names that serves no more than 20 customers.",
        "ground_truth": "SELECT T1.LastName FROM CUSTOMER AS T1 JOIN EMPLOYEE AS T2 ON T1.SupportRepId  =  T2.EmployeeId GROUP BY T1.SupportRepId HAVING COUNT(*)  <=  20",
        "amends": [
            "Do select `T1.LastName` instead of `last_name` from the wrong table. Do join `CUSTOMER AS T1` with `EMPLOYEE AS T2` on `T1.SupportRepId = T2.EmployeeId` instead of querying only the `employees` table. Do add `GROUP BY T1.SupportRepId` and `HAVING COUNT(*) <= 20` instead of using `WHERE customer_count > 20` with an incorrect filter direction and missing aggregation. Do completely restructure the query to properly count customers per support representative instead of incorrectly filtering employees directly. The amended query now correctly identifies support representatives with 20 or fewer customers, matching the intended behavior.",
            "Do select `T1.LastName` instead of `T2.LastName` to reference the customer's last name rather than the employee's last name. The amended query now correctly matches the RIGHT_SQL's behavior by selecting the appropriate column from the Customer table.",
            "Do select `T1.LastName` instead of `T2.LastName` to reference the customer's last name rather than the employee's last name. The amended query now correctly identifies customers with support representatives who have 20 or fewer assigned customers, matching the intended behavior.",
            "Do select `T1.LastName` instead of `T2.LastName` from the Customer table instead of the Employee table. The amended query now correctly retrieves the last names of customers rather than employees, while maintaining the same join condition on `T1.SupportRepId = T2.EmployeeId` and the same grouping and filtering logic with `GROUP BY T1.SupportRepId` and `HAVING COUNT(*) <= 20`, ensuring the query now matches the intended behavior of counting customers per support representative."
        ],
        "rules": [
            "1) When answering about \"employee last names that serve no more than 20 customers\": make sure the output order: T2.LastName 2) When the question mentions \"employee last names\": \"employee last names\" actually means \"T2.LastName in schema\" 3) When combining CUSTOMER AS T1 and EMPLOYEE AS T2 for shared entities: link rows where T1.SupportRepId = T2.EmployeeId exactly as shown in the amends; keep only matching pairs (inner match) 4) When the question asks for \"count of customers per employee\": compute the number of rows using T1.SupportRepId as the grouping key and COUNT(*) as the aggregate 5) When filtering for \"no more than 20 customers\": apply the condition COUNT(*) <= 20 using HAVING clause after grouping 6) When organizing results by employee: group by T1.SupportRepId to compute customer counts per support representative",
            "1) When selecting employee last names from the Customer table: use T1.LastName instead of T2.LastName to reference the customer's last name column. 2) When counting customers served by employees: group by T1.SupportRepId to count customers per employee. 3) When filtering for employees serving no more than 20 customers: apply the condition COUNT(*) <= 20 to limit results to employees with 20 or fewer customers.",
            "1) When answering about \"employee last names that serves no more than 20 customers\": make sure the output order: T1.LastName 2) When the question asks for \"count of customers per employee\": compute the number of rows using the canonical key token for customers (e.g., T1.CustomerId) grouped by T1.SupportRepId 3) When filtering for employees serving no more than 20 customers: include only groups where the count of customers is less than or equal to 20 4) When combining Customer (T1) and Employee (T2) tables: link rows where T1.SupportRepId = T2.EmployeeId to match customers with their support representatives 5) When selecting employee last names: use T2.LastName from the Employee table, not T1.LastName from the Customer table",
            "1) When answering about \"employee last names that serve no more than 20 customers\": make sure the output order: T1.LastName 2) When the question mentions \"employee last names\": \"employee last names\" actually means \"T1.LastName in schema\" 3) When the question asks for \"count of customers per employee\": compute the number of rows using the canonical key token for customers (e.g., T1.SupportRepId) grouped by T1.SupportRepId 4) When filtering for \"no more than 20 customers\": keep only groups where the count of customers is less than or equal to 20 5) When combining Customer table (T1) and Employee table (T2): link rows where T1.SupportRepId = T2.EmployeeId; keep only matching pairs (inner match)"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT last_name FROM employees WHERE customer_count > 20;",
            "SELECT T2.LastName\nFROM Customer AS T1\nJOIN Employee AS T2 ON T1.SupportRepId = T2.EmployeeId\nGROUP BY T1.SupportRepId\nHAVING COUNT(*) <= 20",
            "SELECT T2.LastName \nFROM Customer AS T1 \nJOIN Employee AS T2 ON T1.SupportRepId = T2.EmployeeId \nGROUP BY T1.SupportRepId \nHAVING COUNT(*) <= 20",
            "SELECT T2.LastName \nFROM Customer AS T1 \nJOIN Employee AS T2 ON T1.SupportRepId = T2.EmployeeId \nGROUP BY T1.SupportRepId \nHAVING COUNT(*) <= 20",
            "SELECT T1.LastName \nFROM Customer AS T1\nJOIN Employee AS T2 ON T1.SupportRepId = T2.EmployeeId\nGROUP BY T1.SupportRepId\nHAVING COUNT(*) <= 20"
        ],
        "rule_sql": [
            "SELECT T2.LastName\nFROM Customer AS T1\nINNER JOIN Employee AS T2 ON T1.SupportRepId = T2.EmployeeId\nGROUP BY T1.SupportRepId\nHAVING COUNT(*) <= 20\nORDER BY T2.LastName;"
        ]
    },
    "1481": {
        "db_id": "college_2",
        "question": "What are the ids of courses offered in Fall of 2009 but not in Spring of 2010?",
        "ground_truth": "SELECT course_id FROM SECTION WHERE semester  =  'Fall' AND YEAR  =  2009 EXCEPT SELECT course_id FROM SECTION WHERE semester  =  'Spring' AND YEAR  =  2010",
        "amends": [
            "Do query from `SECTION` table instead of `course_offering` table. Do use `EXCEPT` set operation instead of `NOT IN` subquery. Do maintain the same filter conditions `semester = 'Fall' AND year = 2009` in the first part. Do maintain the same filter conditions `semester = 'Spring' AND year = 2010` in the second part. The amended query now correctly identifies courses offered in Fall 2009 but not in Spring 2010 using the appropriate table and set operation."
        ],
        "rules": [
            "1) When answering about courses offered in specific semesters: use the \"SECTION\" table instead of \"course_offering\" table. 2) When finding entities present in one set but not another: use EXCEPT set operation instead of NOT IN subquery. 3) When filtering for Fall 2009 courses: apply conditions semester = 'Fall' AND year = 2009. 4) When filtering for Spring 2010 courses: apply conditions semester = 'Spring' AND year = 2010. 5) When selecting course identifiers: output the course_id column from the SECTION table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_id FROM course_offering WHERE semester = 'Fall' AND year = 2009 AND course_id NOT IN (SELECT course_id FROM course_offering WHERE semester = 'Spring' AND year = 2010);",
            "SELECT course_id FROM section WHERE semester = 'Fall' AND year = 2009\nEXCEPT\nSELECT course_id FROM section WHERE semester = 'Spring' AND year = 2010"
        ],
        "rule_sql": [
            "SELECT course_id FROM section WHERE semester = 'Fall' AND year = 2009\nEXCEPT\nSELECT course_id FROM section WHERE semester = 'Spring' AND year = 2010"
        ]
    },
    "6512": {
        "db_id": "scientist_1",
        "question": "What are the names of scientists who are not working on the project with the most hours?",
        "ground_truth": "SELECT name FROM scientists EXCEPT SELECT T3.name FROM assignedto AS T1 JOIN projects AS T2 ON T1.project  =  T2.code JOIN scientists AS T3 ON T1.scientist  =  T3.SSN WHERE T2.hours  =  (SELECT max(hours) FROM projects)",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` subquery. Do add explicit joins between `assignedto`, `projects`, and `scientists` tables instead of omitting the relationship tables. Do filter for scientists assigned to projects with maximum hours using `WHERE T2.hours = (SELECT max(hours) FROM projects)` instead of filtering by a single project with `ORDER BY hours DESC LIMIT 1`. Do reference proper join conditions with `T1.project = T2.code` and `T1.scientist = T3.SSN` instead of assuming direct relationships. Do remove the `ORDER BY` and `LIMIT` from the subquery since they are unnecessary for the maximum calculation. The amended query now correctly identifies scientists not assigned to the project with maximum hours by using proper table relationships and set operations."
        ],
        "rules": [
            "1) When combining tables for scientist-project relationships: link rows where \"assignedto\".project = \"projects\".code and \"assignedto\".scientist = \"scientists\".SSN using inner matches. 2) When finding the project with maximum hours: compute the maximum value of \"projects\".hours across all projects. 3) When identifying scientists not working on the project with maximum hours: use set difference (EXCEPT) between all scientists and those assigned to projects where \"projects\".hours equals the maximum hours value. 4) When answering about scientist names: output the \"scientists\".name column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.name \nFROM scientists s\nWHERE s.project_id NOT IN (\n    SELECT project_id \n    FROM projects \n    ORDER BY hours DESC \n    LIMIT 1\n)",
            "SELECT Name FROM Scientists\nEXCEPT\nSELECT T3.Name\nFROM AssignedTo T1\nJOIN Projects T2 ON T1.Project = T2.Code\nJOIN Scientists T3 ON T1.Scientist = T3.SSN\nWHERE T2.Hours = (SELECT MAX(Hours) FROM Projects)"
        ],
        "rule_sql": [
            "SELECT s.Name \nFROM Scientists s\nWHERE s.SSN NOT IN (\n    SELECT a.Scientist \n    FROM AssignedTo a\n    JOIN Projects p ON a.Project = p.Code\n    WHERE p.Hours = (SELECT MAX(Hours) FROM Projects)\n)"
        ]
    },
    "5854": {
        "db_id": "tracking_share_transactions",
        "question": "Show the minimum amount of transactions whose type code is \"PUR\" and whose share count is bigger than 50.",
        "ground_truth": "SELECT min(amount_of_transaction) FROM TRANSACTIONS WHERE transaction_type_code  =  \"PUR\" AND share_count  >  50",
        "amends": [
            "Do reference the column as `amount_of_transaction` instead of `amount` in the SELECT clause. Do use the column name `transaction_type_code` instead of `type_code` in the WHERE filter. Do use double quotes `\"PUR\"` instead of single quotes `'PUR'` for the string literal comparison. The amended query now correctly references the actual column names and uses proper string literal formatting to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the minimum amount of transactions: use the exact column name \"amount_of_transaction\" instead of \"amount\" in the output. 2) When filtering by transaction type code: use the exact column name \"transaction_type_code\" instead of \"type_code\" and compare with the exact string literal \"PUR\" using double quotes. 3) When filtering by share count: use the condition \"share_count > 50\" as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(amount) FROM transactions WHERE type_code = 'PUR' AND share_count > 50",
            "SELECT MIN(amount_of_transaction) FROM Transactions WHERE transaction_type_code = \"PUR\" AND CAST(share_count AS INTEGER) > 50"
        ],
        "rule_sql": [
            "SELECT MIN(amount_of_transaction) FROM Transactions WHERE transaction_type_code = \"PUR\" AND share_count > 50"
        ]
    },
    "6240": {
        "db_id": "ship_1",
        "question": "Find the captain rank that has no captain in Third-rate ship of the line class.",
        "ground_truth": "SELECT rank FROM captain EXCEPT SELECT rank FROM captain WHERE CLASS  =  'Third-rate ship of the line'",
        "amends": [
            "Do use `EXCEPT` set operation instead of a simple `WHERE` filter to exclude specific ranks. Do reference table `captain` instead of `Captains` for correct table name. Do specify condition `CLASS = 'Third-rate ship of the line'` instead of `ship_class != 'Third-rate ship of the line'` to properly exclude the targeted ranks through set difference rather than inequality filtering. The amended query now correctly returns all ranks except those associated with third-rate ships of the line, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks to find ranks that have no association with a specific ship class: use a set difference operation (EXCEPT) instead of a simple filter condition. 2) When referring to the captains table: use the exact table name \"captain\" (lowercase) instead of \"Captains\". 3) When excluding ranks associated with Third-rate ship of the line class: use the exact condition \"CLASS = 'Third-rate ship of the line'\" with the exact literal value 'Third-rate ship of the line' including hyphen and spacing. 4) When performing the set difference: select the \"rank\" column from the captain table and exclude those ranks that appear in the set of captains associated with Third-rate ship of the line class."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT rank FROM Captains WHERE ship_class != 'Third-rate ship of the line'",
            "SELECT Rank FROM captain EXCEPT SELECT Rank FROM captain WHERE Class = 'Third-rate ship of the line'"
        ],
        "rule_sql": [
            "SELECT rank FROM captain EXCEPT SELECT captain.rank FROM captain JOIN Ship ON captain.Ship_ID = Ship.Ship_ID WHERE Ship.Class = 'Third-rate ship of the line'"
        ]
    },
    "2018": {
        "db_id": "gas_company",
        "question": "For each location, how many gas stations are there in order?",
        "ground_truth": "SELECT LOCATION ,  count(*) FROM gas_station GROUP BY LOCATION ORDER BY count(*)",
        "amends": [
            "Do use the correct table name `gas_station` instead of the incorrect pluralized `gas_stations`. Do order by the aggregate expression `count(*)` instead of the grouping column `location`. The amended query now correctly references the table and orders results by the count value rather than the location name, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"gas stations\": use the exact table name \"gas_station\" (singular) instead of pluralized forms. 2) When the question asks for \"how many gas stations are there in order\": order the results by the count value (count(*)) in ascending order rather than by the location name. 3) When counting entities: count all rows in the gas_station table grouped by location to determine the number of gas stations per location."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location, COUNT(*) FROM gas_stations GROUP BY location ORDER BY location;",
            "SELECT Location, COUNT(*) AS station_count FROM gas_station GROUP BY Location ORDER BY COUNT(*) DESC;"
        ],
        "rule_sql": [
            "SELECT Location, COUNT(*) AS station_count FROM gas_station GROUP BY Location ORDER BY station_count ASC"
        ]
    },
    "6598": {
        "db_id": "wine_1",
        "question": "What is the county that produces the most wines scoring higher than 90?",
        "ground_truth": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  90 GROUP BY T1.County ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `APPELLATIONS` and `WINE` tables on `Appelation` instead of querying only the `wines` table. Do reference `T1.County` from the joined table instead of `county` directly. Do filter on `T2.Score > 90` instead of `score > 90` to reference the correct table. Do use `count(*)` in the ORDER BY clause instead of the alias `wine_count`. Do maintain the GROUP BY on `T1.County` and LIMIT 1 to preserve the top county selection logic. The amended query now correctly joins the necessary tables to associate counties with wine scores and returns the county with the highest count of wines scoring above 90, matching the intended behavior.",
            "Do remove `COUNT(*) AS wine_count` from the SELECT list instead of including it, as the RIGHT_SQL only returns the County column. Do keep the same FROM clause with `APPELLATIONS AS T1 JOIN WINE AS T2` instead of using different table aliasing. Do maintain the same join condition `ON T1.Appelation = T2.Appelation` instead of changing it. Do preserve the WHERE filter `T2.Score > 90` instead of modifying it. Do retain the GROUP BY clause `GROUP BY T1.County` instead of altering it. Do keep the ORDER BY clause `ORDER BY count(*) DESC` instead of changing the aggregate function syntax. Do maintain the LIMIT clause `LIMIT 1` instead of modifying it. The amended query now matches RIGHT_SQL's behavior by returning only the County column while maintaining all other structural elements."
        ],
        "rules": [
            "1) When answering about \"county that produces the most wines scoring higher than 90\": make sure the output order: T1.County first. 2) When combining APPELLATIONS and WINE tables: link rows where T1.Appelation = T2.Appelation exactly as shown; keep only matching pairs (inner match). 3) When filtering for wines scoring higher than 90: use T2.Score > 90 with exact comparison bound. 4) When grouping by county: organize results by T1.County and compute count per group. 5) When counting wines: compute the number of rows using count(*) as the counting method. 6) When the question asks for \"most\" (top 1): rank rows by count(*) in descending order and keep the first 1 row.",
            "1) When answering about \"the county that produces the most wines scoring higher than 90\": make sure the output order includes only \"T1.County\" column. 2) When the question asks for \"count of wines\": compute the number of rows using the canonical key for counting in the ORDER BY clause. 3) When combining APPELLATIONS AS T1 and WINE AS T2: link rows where \"T1.Appelation = T2.Appelation\" exactly as shown; keep only matching pairs (inner match). 4) When filtering for wines scoring higher than 90: apply the condition \"T2.Score > 90\" exactly as specified. 5) When grouping by county: organize results by \"T1.County\" and compute aggregates per county. 6) When ranking counties by wine count: order by the count in descending direction and keep only the first row (top county)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT county, COUNT(*) as wine_count \nFROM wines \nWHERE score > 90 \nGROUP BY county \nORDER BY wine_count DESC \nLIMIT 1;",
            "SELECT T1.County, COUNT(*) AS wine_count\nFROM appellations T1\nJOIN wine T2 ON T1.Appelation = T2.Appelation\nWHERE T2.Score > 90\nGROUP BY T1.County\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.County\nFROM appellations AS T1\nJOIN wine AS T2 ON T1.Appelation = T2.Appelation\nWHERE T2.Score > 90\nGROUP BY T1.County\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.County\nFROM appellations AS T1\nINNER JOIN wine AS T2 ON T1.Appelation = T2.Appelation\nWHERE T2.Score > 90\nGROUP BY T1.County\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "1238": {
        "db_id": "apartment_rentals",
        "question": "Show the facility codes of apartments with more than 4 bedrooms.",
        "ground_truth": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  4",
        "amends": [
            "Do specify the full table reference `T1.facility_code` instead of just `facility_code`. Do join `Apartment_Facilities AS T1` with `Apartments AS T2` on `T1.apt_id = T2.apt_id` instead of querying only the `apartments` table. Do use the correct column name `bedroom_count` in the WHERE filter instead of `bedrooms`. Do reference the joined table `T2.bedroom_count > 4` instead of filtering the original table directly. The amended query now correctly joins the facility and apartment tables to find facilities in apartments with more than 4 bedrooms, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about facility codes of apartments: make sure the output order: T1.facility_code 2) When the question mentions \"facility codes\": \"facility codes\" actually means \"T1.facility_code in schema\" 3) When the question mentions \"apartments with more than 4 bedrooms\": join Apartment_Facilities AS T1 with Apartments AS T2 on T1.apt_id = T2.apt_id and filter where T2.bedroom_count > 4 4) When combining T1 and T2 for shared entities: link rows where T1.apt_id = T2.apt_id exactly as shown in the amends; keep only matching pairs (inner match) 5) When the question asks for apartments with more than 4 bedrooms: use the exact column name T2.bedroom_count > 4 instead of bedrooms"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT facility_code FROM apartments WHERE bedrooms > 4",
            "SELECT T1.facility_code \nFROM Apartment_Facilities AS T1\nJOIN Apartments AS T2 ON T1.apt_id = T2.apt_id\nWHERE T2.bedroom_count > 4"
        ],
        "rule_sql": [
            "SELECT T1.facility_code \nFROM Apartment_Facilities AS T1\nINNER JOIN Apartments AS T2 ON T1.apt_id = T2.apt_id\nWHERE T2.bedroom_count > 4\nORDER BY T1.facility_code"
        ]
    },
    "6058": {
        "db_id": "customers_and_addresses",
        "question": "Return the total number of distinct customers.",
        "ground_truth": "SELECT count(*) FROM customers",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT customer_id) FROM Customers;"
        ]
    },
    "6980": {
        "db_id": "culture_company",
        "question": "Show all publishers which do not have a book in 1989.",
        "ground_truth": "SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR  =  1989",
        "amends": [
            "Do select `publisher` from `book_club` instead of selecting all columns from `publishers`. Do use `EXCEPT` to exclude publishers from 1989 instead of `NOT IN` with a subquery. Do reference the `book_club` table instead of separate `publishers` and `books` tables. Do filter with `YEAR = 1989` directly in the second query instead of using a subquery with `year = 1989`. The amended query now correctly identifies publishers not associated with 1989 publications using the EXCEPT operator on the same table structure."
        ],
        "rules": [
            "1) When answering about \"publishers which do not have a book in 1989\": select only the \"publisher\" column from the \"book_club\" table instead of all columns. 2) When excluding publishers with books from 1989: use the EXCEPT operator to remove publishers that have \"YEAR = 1989\" instead of a NOT IN subquery. 3) When working with the book_club table structure: reference the single \"book_club\" table instead of separate \"publishers\" and \"books\" tables. 4) When filtering for books from 1989: use the exact literal \"1989\" with the column \"YEAR\" in the second query of the EXCEPT operation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM publishers WHERE publisher_id NOT IN (SELECT publisher_id FROM books WHERE year = 1989);",
            "SELECT Publisher FROM book_club EXCEPT SELECT Publisher FROM book_club WHERE Year = 1989"
        ],
        "rule_sql": [
            "SELECT Publisher FROM book_club EXCEPT SELECT Publisher FROM book_club WHERE Year = 1989"
        ]
    },
    "2803": {
        "db_id": "news_report",
        "question": "List the names of journalists in ascending order of years working.",
        "ground_truth": "SELECT Name FROM journalist ORDER BY Years_working ASC",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the `journalist` table instead of `journalists`. Do change the sort order to `ASC` instead of `DESC` for the `Years_working` column instead of `years_working`. The amended query now correctly references the proper table and column names with the intended ascending sort order."
        ],
        "rules": [
            "1) When answering about \"names of journalists\": make sure the output column is \"Name\" from table \"journalist\". 2) When the question mentions \"ascending order of years working\": sort the results by \"Years_working\" in ascending order (lowest to highest). 3) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms - use exact column names as shown in the schema (\"Name\" and \"Years_working\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM journalists ORDER BY years_working DESC;",
            "SELECT Name FROM journalist ORDER BY Years_working ASC;"
        ],
        "rule_sql": [
            "SELECT \"Name\" FROM journalist ORDER BY \"Years_working\" ASC;"
        ]
    },
    "1905": {
        "db_id": "school_finance",
        "question": "What is the total budget amount for school \"Glenn\" in all years?",
        "ground_truth": "SELECT sum(T1.budgeted) FROM budget AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id WHERE T2.school_name  =  'Glenn'",
        "amends": [
            "Do reference the `budget` table as `T1` and `school` table as `T2` instead of only using `school_budgets`. Do join `T1` to `T2` on `T1.school_id = T2.school_id` instead of querying a single table. Do filter on `T2.school_name = 'Glenn'` instead of filtering directly on a school_name column in the budget table. Do aggregate `sum(T1.budgeted)` instead of `SUM(budget_amount)` to use the correct column name from the proper table. The amended query now correctly joins budget and school tables to filter by school name and sum the appropriate budgeted amounts, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about total budget amount for a specific school: reference the budget table as T1 and school table as T2. 2) When combining T1 and T2 for shared entities: link rows where T1.school_id = T2.school_id and keep only matching pairs (inner match). 3) When filtering for school \"Glenn\": use T2.school_name = 'Glenn' exactly as specified. 4) When aggregating budget amounts: sum T1.budgeted instead of any other column name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(budget_amount) FROM school_budgets WHERE school_name = 'Glenn';",
            "SELECT SUM(T1.Budgeted) AS total_budget_amount\nFROM budget T1\nJOIN School T2 ON T1.School_id = T2.School_id\nWHERE T2.School_name = 'Glenn'"
        ],
        "rule_sql": [
            "SELECT SUM(T1.Budgeted) AS total_budget_amount\nFROM budget T1\nINNER JOIN School T2 ON T1.School_id = T2.School_id\nWHERE T2.School_name = 'Glenn'"
        ]
    },
    "5010": {
        "db_id": "soccer_2",
        "question": "Find the average and maximum hours for the students whose tryout decision is yes.",
        "ground_truth": "SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of no aliases, and reference columns with table prefixes instead of bare column names. Do join `player AS T1` with `tryout AS T2` on `T1.pID = T2.pID` instead of querying only the `students` table. Do select `avg(T1.HS)` and `max(T1.HS)` instead of `AVG(hours)` and `MIN(hours)` with incorrect aliases. Do filter on `T2.decision = 'yes'` instead of `tryout_decision = 'yes'` to reference the joined table's column. The amended query now correctly aggregates hours played data from joined player and tryout tables where the decision is affirmative."
        ],
        "rules": [
            "1) When answering about \"average and maximum hours for students whose tryout decision is yes\": make sure the output order: average_hours, max_hours. 2) When combining player and tryout tables: link rows where T1.pID = T2.pID and keep only matching pairs (inner match). 3) When the question mentions \"hours\": \"hours\" actually means \"T1.HS in schema\". 4) When the question mentions \"tryout decision is yes\": \"tryout decision is yes\" actually means \"T2.decision = 'yes' in schema\". 5) When computing average hours: compute avg(T1.HS) for rows satisfying T2.decision = 'yes'. 6) When computing maximum hours: compute max(T1.HS) for rows satisfying T2.decision = 'yes'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(hours) as average_hours, MIN(hours) as max_hours FROM students WHERE tryout_decision = 'yes'",
            "SELECT AVG(T1.HS) AS average_hours, MAX(T1.HS) AS maximum_hours FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T2.decision = 'yes'"
        ],
        "rule_sql": [
            "SELECT AVG(T1.HS) AS average_hours, MAX(T1.HS) AS max_hours FROM Player T1 INNER JOIN Tryout T2 ON T1.pID = T2.pID WHERE T2.decision = 'yes'"
        ]
    },
    "6284": {
        "db_id": "city_record",
        "question": "Which city has the lowest GDP? Please list the city name and its GDP.",
        "ground_truth": "SELECT city ,  GDP FROM city ORDER BY GDP LIMIT 1",
        "amends": [
            "Do select `city` and `GDP` columns instead of `city_name` and `MAX(gdp)` aggregate function. Do query from `city` table instead of `cities` table. Do remove the `ASC` keyword from the `ORDER BY` clause instead of keeping it explicit. The amended query now correctly selects individual city records with their GDP values and returns the city with the lowest GDP, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"lowest GDP\": select the exact column \"GDP\" from table \"city\" without using aggregate functions. 2) When the question mentions \"city name\": use the exact column \"city\" from table \"city\" to represent city names. 3) When the question asks for \"lowest\" value of a column: order rows by the column in ascending order (lowest first) and keep only the first row. 4) When producing output: list the city name first followed by its GDP value, matching the question's requested order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city_name, MAX(gdp) FROM cities ORDER BY gdp ASC LIMIT 1;",
            "SELECT City, GDP FROM city ORDER BY GDP LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT City, GDP FROM city ORDER BY GDP ASC LIMIT 1;"
        ]
    },
    "4109": {
        "db_id": "company_employee",
        "question": "Show the names of companies and the number of employees they have",
        "ground_truth": "SELECT T3.Name ,  COUNT(*) FROM employment AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID JOIN company AS T3 ON T1.Company_ID  =  T3.Company_ID GROUP BY T3.Name",
        "amends": [
            "Do join `employment` and `people` on `People_ID` instead of querying `employees` directly. Do add join to `company` on `Company_ID` instead of omitting company table. Do select `T3.Name` instead of `company_name` as the grouping column. Do use proper table aliases `T1`, `T2`, `T3` instead of direct table references. The amended query now correctly joins the three tables to count employees per company name."
        ],
        "rules": [
            "1) When answering about \"names of companies and the number of employees they have\": make sure the output order: T3.Name, COUNT(T1.People_ID) 2) When the question mentions \"companies\": \"companies\" actually means \"T3.Name in schema\" 3) When the question asks for \"number of employees\": compute the count using the canonical key token T1.People_ID 4) When combining T1 (employment), T2 (people), and T3 (company) for shared entities: link rows where T1.People_ID = T2.People_ID and T1.Company_ID = T3.Company_ID; keep only matching pairs (inner match) 5) When the question says \"per company\": organize results by T3.Name and compute employee count per group"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT company_name, COUNT(*) FROM employees GROUP BY company_name",
            "SELECT T3.Name, COUNT(T1.People_ID) AS NumberOfEmployees\nFROM employment T1\nJOIN people T2 ON T1.People_ID = T2.People_ID\nJOIN company T3 ON T1.Company_ID = T3.Company_ID\nGROUP BY T3.Name;"
        ],
        "rule_sql": [
            "SELECT T3.Name, COUNT(T1.People_ID) \nFROM employment T1\nINNER JOIN company T3 ON T1.Company_ID = T3.Company_ID\nGROUP BY T3.Name"
        ]
    },
    "6303": {
        "db_id": "city_record",
        "question": "What are the venues of all the matches? Sort them in the descending order of match date.",
        "ground_truth": "SELECT venue FROM MATCH ORDER BY date DESC",
        "amends": [
            "Do reference table `MATCH` instead of `matches` in the FROM clause. Do order by `date` instead of `match_date` in the ORDER BY clause. Do use `DESC` ordering instead of `ASC` ordering. The amended query now correctly retrieves venues from the MATCH table ordered by date in descending sequence."
        ],
        "rules": [
            "1) When answering about match venues: use the exact table name \"MATCH\" from the schema. 2) When ordering by match date: use the exact column name \"date\" from the MATCH table. 3) When the question specifies \"descending order of match date\": sort the results by date in descending sequence."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT venue FROM matches ORDER BY match_date ASC;",
            "SELECT Venue FROM \"match\" ORDER BY Date DESC;"
        ],
        "rule_sql": [
            "SELECT Venue FROM \"match\" ORDER BY Date DESC;"
        ]
    },
    "3583": {
        "db_id": "music_1",
        "question": "List the names of all songs that have 4 minute duration or are in English.",
        "ground_truth": "SELECT T2.song_name FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE \"4:%\" UNION SELECT song_name FROM song WHERE languages  =  \"english\"",
        "amends": [
            "Do select `T2.song_name` instead of `name` and use `UNION` to combine results instead of `OR` conditions. Do join `files AS T1` with `song AS T2` on `T1.f_id = T2.f_id` instead of querying only the `songs` table. Do filter with `T1.duration LIKE \"4:%\"` for partial string matching instead of exact equality `duration = 4`. Do add a separate `SELECT song_name FROM song WHERE languages = \"english\"` instead of combining conditions with `OR`. Do use proper table aliases and explicit column references instead of simple column names. The amended query now correctly handles duration pattern matching and combines results from joined tables with union operations."
        ],
        "rules": [
            "1) When answering about \"songs with 4 minute duration or in English\": make sure the output order: T2.song_name\n2) When the question mentions \"songs\": use table \"song\" as T2 and join with \"files\" as T1 on T1.f_id = T2.f_id\n3) When the question mentions \"4 minute duration\": use T1.duration LIKE \"4:%\" for partial string matching instead of exact equality\n4) When the question mentions \"English\": use T2.languages = \"english\" with exact literal value\n5) When combining multiple conditions with \"or\": use UNION to combine separate SELECT statements instead of OR conditions\n6) When selecting song names: use T2.song_name instead of just \"name\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM songs WHERE duration = 4 OR language = 'English';",
            "SELECT T2.song_name FROM files AS T1 JOIN song AS T2 ON T1.f_id = T2.f_id WHERE T1.duration LIKE '4:%' UNION SELECT song_name FROM song WHERE languages = 'english'"
        ],
        "rule_sql": [
            "SELECT T2.song_name FROM song T2 JOIN files T1 ON T1.f_id = T2.f_id WHERE T1.duration LIKE '4:%' UNION SELECT T2.song_name FROM song T2 WHERE T2.languages = 'english'"
        ]
    },
    "5489": {
        "db_id": "voter_2",
        "question": "Which students live in the city with code \"NYC\" and have class senator votes in the spring election cycle? Count the numbers.",
        "ground_truth": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.city_code  =  \"NYC\" AND T2.Election_Cycle  =  \"Spring\"",
        "amends": [
            "Do use table alias `T1` for `STUDENT` instead of `s` for `students`, and `T2` for `VOTING_RECORD` instead of `v` for `votes`. Do join on `T1.StuID = Class_Senator_Vote` instead of `s.student_id = v.student_id`, removing the explicit vote_type filter. Do use double quotes around string literals \"NYC\" and \"Spring\" instead of single quotes 'NYC' and 'spring'. Do remove the `AND v.vote_type = 'class_senator'` condition entirely instead of keeping it, as the join condition now implicitly filters for class senator votes. The amended query now correctly matches RIGHT_SQL's behavior by using the proper table names, join condition, and string formatting."
        ],
        "rules": [
            "1) When answering about students in city with code \"NYC\": filter T1.\"city_code\" to exactly equal \"NYC\". 2) When answering about class senator votes in spring election cycle: filter T2.\"election_cycle\" to exactly equal \"Spring\". 3) When combining STUDENT (T1) and VOTING_RECORD (T2) for class senator votes: link rows where T1.\"StuID\" equals T2.\"Class_Senator_Vote\" and keep only matching pairs (inner match). 4) When counting students with class senator votes: compute the number of rows using the join result between T1 and T2 with the specified filters."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM students s\nJOIN votes v ON s.student_id = v.student_id\nWHERE s.city_code = 'NYC' \nAND v.election_cycle = 'spring'\nAND v.vote_type = 'class_senator';",
            "SELECT COUNT(*) \nFROM Student T1\nJOIN Voting_record T2 ON T1.StuID = T2.Class_Senator_Vote\nWHERE T1.city_code = \"NYC\" \nAND T2.Election_Cycle = \"Spring\""
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Student T1\nINNER JOIN Voting_record T2 ON T1.StuID = T2.Class_Senator_Vote\nWHERE T1.city_code = 'NYC' AND T2.Election_Cycle = 'Spring'"
        ]
    },
    "6934": {
        "db_id": "tracking_orders",
        "question": "What are the invoice numbers created before 1989-09-03 or after 2007-12-25?",
        "ground_truth": "SELECT invoice_number FROM invoices WHERE invoice_date < \"1989-09-03\" OR invoice_date > \"2007-12-25\"",
        "amends": [
            "Do use `invoice_number` instead of `InvoiceNumber` for the column name in the SELECT list. Do use `OR` instead of `AND` for the logical operator in the WHERE clause to correctly select invoices that are either before 1989-09-03 or after 2007-12-25, instead of incorrectly requiring both conditions to be true simultaneously. Do use double quotes instead of single quotes for the date literals in the WHERE clause."
        ],
        "rules": [
            "1) When selecting invoice numbers from the Shipments table: use the exact column name \"invoice_number\" in the output. 2) When filtering by date conditions with OR logic: use OR instead of AND to select rows that satisfy either condition, not both simultaneously. 3) When specifying date literals in conditions: use double quotes around date values like \"1989-09-03\" and \"2007-12-25\" instead of single quotes. 4) When answering about invoice numbers created before 1989-09-03 or after 2007-12-25: ensure the WHERE clause includes both date range conditions connected with OR."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT InvoiceNumber FROM invoices WHERE InvoiceDate < '1989-09-03' AND InvoiceDate > '2007-12-25';",
            "SELECT invoice_number FROM Invoices WHERE invoice_date < \"1989-09-03\" OR invoice_date > \"2007-12-25\""
        ],
        "rule_sql": [
            "SELECT invoice_number FROM Invoices WHERE invoice_date < \"1989-09-03\" OR invoice_date > \"2007-12-25\""
        ]
    },
    "6642": {
        "db_id": "driving_school",
        "question": "Which city does staff with first name as Janessa and last name as Sawayn live?",
        "ground_truth": "SELECT T1.city FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id WHERE T2.first_name = \"Janessa\" AND T2.last_name = \"Sawayn\";",
        "amends": [
            "Do select `T1.city` from the `Addresses` table instead of `city` from the `staff` table. Do join `Addresses AS T1` to `Staff AS T2` with `ON T1.address_id = T2.staff_address_id` instead of querying only the `staff` table. Do filter on `T2.first_name` and `T2.last_name` instead of directly filtering the `staff` table's columns. Do reference the joined table aliases `T1` and `T2` instead of accessing columns without table qualification. The amended query now correctly retrieves city information from the Addresses table by joining with Staff using the proper address relationship, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about staff city information: retrieve city from the \"Addresses\" table (T1.city) instead of the \"staff\" table. 2) When joining \"Addresses\" and \"Staff\" tables: link rows where T1.address_id equals T2.staff_address_id. 3) When filtering for staff with first name \"Janessa\" and last name \"Sawayn\": apply the filter conditions T2.first_name = 'Janessa' AND T2.last_name = 'Sawayn' on the \"Staff\" table (T2). 4) When combining tables for this query: perform an inner match between \"Addresses\" AS T1 and \"Staff\" AS T2 using the exact key relationship T1.address_id = T2.staff_address_id."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city FROM staff WHERE first_name = 'Janessa' AND last_name = 'Sawayn';",
            "SELECT T1.city FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id WHERE T2.first_name = 'Janessa' AND T2.last_name = 'Sawayn'"
        ],
        "rule_sql": [
            "SELECT T1.city FROM Addresses AS T1 INNER JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id WHERE T2.first_name = 'Janessa' AND T2.last_name = 'Sawayn'"
        ]
    },
    "333": {
        "db_id": "product_catalog",
        "question": "Find the name and attribute ID of the attribute definitions with attribute value 0.",
        "ground_truth": "SELECT t1.attribute_name ,  t1.attribute_id FROM Attribute_Definitions AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.attribute_id  =  t2.attribute_id WHERE t2.attribute_value  =  0",
        "amends": [
            "Do add `Catalog_Contents_Additional_Attributes AS t2` table with a `JOIN` on `t1.attribute_id = t2.attribute_id` instead of querying only `attribute_definitions` table. Do change the SELECT list to `t1.attribute_name, t1.attribute_id` instead of `name, attribute_id` and add table alias `t1` for `Attribute_Definitions`. Do move the filter condition to `t2.attribute_value = 0` instead of `attribute_value = 0` to reference the joined table instead of the base table. The amended query now correctly joins the two tables and filters on the appropriate table's attribute_value column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"attribute definitions with attribute value 0\": make sure to join Attribute_Definitions as t1 with Catalog_Contents_Additional_Attributes as t2 using t1.attribute_id = t2.attribute_id. 2) When the question mentions \"name\": \"name\" actually means \"t1.attribute_name\" in schema. 3) When filtering for attribute value 0: use t2.attribute_value = 0 instead of filtering on the base table. 4) When selecting output columns: use t1.attribute_name, t1.attribute_id in that order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, attribute_id FROM attribute_definitions WHERE attribute_value = 0;",
            "SELECT t1.attribute_name, t1.attribute_id\nFROM Attribute_Definitions AS t1\nJOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.attribute_id = t2.attribute_id\nWHERE t2.attribute_value = '0'"
        ],
        "rule_sql": [
            "SELECT t1.attribute_name, t1.attribute_id FROM Attribute_Definitions AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.attribute_id = t2.attribute_id WHERE t2.attribute_value = '0'"
        ]
    },
    "5632": {
        "db_id": "railway",
        "question": "How many railways are there?",
        "ground_truth": "SELECT count(*) FROM railway",
        "amends": [
            "Do query the `railway` table instead of the `airports` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the railway table instead of airports."
        ],
        "rules": [
            "1) When the question asks about railways: query the railway table instead of airports table. 2) When counting records: use lowercase count(*) for consistency with the schema's formatting."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM airports;",
            "SELECT count(*) FROM railway;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM railway;"
        ]
    },
    "6772": {
        "db_id": "activity_1",
        "question": "Which faculty do not participate in any activity? Find their faculty ids.",
        "ground_truth": "SELECT FacID FROM Faculty EXCEPT SELECT FacID FROM Faculty_participates_in",
        "amends": [
            "Do use `EXCEPT` to find faculty not participating in activities instead of checking for `NULL` activity_id. Do select `FacID` instead of `faculty_id` to match the correct column name. Do reference the `Faculty` table instead of `faculty` for proper case sensitivity. Do add a subquery with `Faculty_participates_in` table instead of omitting it, as the original approach incorrectly assumed activity_id would be NULL for non-participating faculty when the relationship should be determined through the participation table. The amended query now correctly identifies faculty who have no entries in the participation table rather than relying on potentially incorrect NULL checks in the main faculty table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT faculty_id FROM faculty WHERE activity_id IS NULL;",
            "SELECT FacID FROM Faculty\nEXCEPT\nSELECT FacID FROM Faculty_Participates_in;"
        ],
        "rule_sql": []
    },
    "1887": {
        "db_id": "school_finance",
        "question": "List the name, location, mascot for all schools.",
        "ground_truth": "SELECT school_name ,  LOCATION ,  mascot FROM school",
        "amends": [
            "Do add `mascot` to the SELECT list instead of omitting it. Do change the column reference from `name` to `school_name` instead of using the original column name. Do change the table reference from `schools` to `school` instead of using the plural table name. The amended query now correctly selects all required columns from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, location FROM schools;",
            "SELECT School_name, Location, Mascot FROM School;"
        ],
        "rule_sql": []
    },
    "4820": {
        "db_id": "aircraft",
        "question": "What is the average total number of passengers for all airports that the aircraft \"Robinson R-22\" visits?",
        "ground_truth": "SELECT avg(T3.Total_Passengers) FROM aircraft AS T1 JOIN airport_aircraft AS T2 ON T1.Aircraft_ID  =  T2.Aircraft_ID JOIN airport AS T3 ON T2.Airport_ID  =  T3.Airport_ID WHERE T1.Aircraft  =  \"Robinson R-22\"",
        "amends": [
            "Do join `aircraft AS T1` and `airport_aircraft AS T2` on `T1.Aircraft_ID = T2.Aircraft_ID` instead of querying only the `airports` table. Do then join `airport AS T3` on `T2.Airport_ID = T3.Airport_ID` instead of missing these necessary table relationships. Do filter on `T1.Aircraft = \"Robinson R-22\"` instead of filtering `aircraft_type` directly in the airports table. Do aggregate `avg(T3.Total_Passengers)` instead of `AVG(total_passengers)` to reference the correct column through the proper table joins. The amended query now correctly calculates average passengers for Robinson R-22 aircraft by properly navigating the relational schema through the necessary joins."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(total_passengers) FROM airports WHERE aircraft_type = 'Robinson R-22';",
            "SELECT AVG(T3.Total_Passengers) \nFROM aircraft AS T1\nJOIN airport_aircraft AS T2 ON T1.Aircraft_ID = T2.Aircraft_ID\nJOIN airport AS T3 ON T2.Airport_ID = T3.Airport_ID\nWHERE T1.Aircraft = 'Robinson R-22'"
        ],
        "rule_sql": []
    },
    "931": {
        "db_id": "insurance_fnol",
        "question": "Retrieve the open and close dates of all the policies associated with the customer whose name contains \"Diana\"",
        "ground_truth": "SELECT t2.date_opened ,  t2.date_closed FROM customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name LIKE \"%Diana%\"",
        "amends": [
            "Do select `t2.date_opened` and `t2.date_closed` instead of `policy_open_date` and `policy_close_date`. Do join `customers AS t1` with `customers_policies AS t2` on `t1.customer_id = t2.customer_id` instead of querying only the `policies` table. Do filter on `t1.customer_name LIKE \"%Diana%\"` instead of filtering directly on a non-existent `customer_name` column in the policies table. The amended query now correctly joins the customer and policy tables to find policies associated with customers named Diana, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT policy_open_date, policy_close_date FROM policies WHERE customer_name LIKE '%Diana%';",
            "SELECT t2.Date_Opened, t2.Date_Closed \nFROM Customers AS t1 \nJOIN Customers_Policies AS t2 ON t1.Customer_ID = t2.Customer_ID \nWHERE t1.Customer_name LIKE '%Diana%'"
        ],
        "rule_sql": []
    },
    "944": {
        "db_id": "medicine_enzyme_interaction",
        "question": "What are the names of enzymes whose product is not 'Heme'?",
        "ground_truth": "SELECT name FROM enzyme WHERE product != 'Heme'",
        "amends": [
            "Do reference table `enzyme` instead of `enzymes` and use inequality filter `product != 'Heme'` instead of equality filter `product = 'Heme'`."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM enzymes WHERE product = 'Heme';",
            "SELECT name FROM enzyme WHERE Product != 'Heme';"
        ],
        "rule_sql": []
    },
    "6211": {
        "db_id": "roller_coaster",
        "question": "Please show the most common status of roller coasters.",
        "ground_truth": "SELECT Status FROM roller_coaster GROUP BY Status ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do `GROUP BY Status` instead of omitting it to aggregate counts by status category. Do remove the explicit `COUNT(*) as count` column from the SELECT list instead of including it, since only the status value is needed. Do move the count aggregation to the ORDER BY clause instead of the SELECT clause to sort by frequency while returning only status values. Do use the correct table name `roller_coaster` instead of `roller_coasters` to match the actual schema. The amended query now correctly returns the most frequent status value by counting occurrences per status group and matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT status, COUNT(*) as count FROM roller_coasters ORDER BY count DESC LIMIT 1;",
            "SELECT Status FROM roller_coaster GROUP BY Status ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "1522": {
        "db_id": "insurance_and_eClaims",
        "question": "Which customer made the smallest amount of claim in one claim? Return the customer details.",
        "ground_truth": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)",
        "amends": [
            "Do select `customer_details` from the `customers` table instead of selecting all columns from `customers` with an aggregate. Do use `FROM claim_headers` joined to `policies` and then to `customers` instead of directly joining `customers` to `claims`. Do use `JOIN policies ON claim_headers.policy_id = policies.policy_id` and `JOIN customers ON policies.customer_id = customers.customer_id` instead of `JOIN claims ON customers.customer_id = claims.customer_id`. Do add a `WHERE` filter comparing `amount_piad` to a subquery finding the minimum `amount_piad` instead of using `GROUP BY` with `MIN(amount)` and `ORDER BY` with `LIMIT 1`. Do remove the `GROUP BY` clause and aggregate function entirely instead of grouping by customer_id. Do use the column alias `amount_piad` instead of `amount`. The amended query now correctly identifies customers with claims having the minimum payment amount by properly traversing the relationship through policies."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.*, MIN(c.amount) as smallest_claim_amount \nFROM customers c \nJOIN claims cl ON c.customer_id = cl.customer_id \nGROUP BY c.customer_id \nORDER BY smallest_claim_amount ASC \nLIMIT 1;",
            "SELECT c.Customer_Details \nFROM Customers c\nJOIN Policies p ON c.Customer_ID = p.Customer_ID\nJOIN Claim_Headers ch ON p.Policy_ID = ch.Policy_ID\nWHERE ch.Amount_Piad = (SELECT MIN(Amount_Piad) FROM Claim_Headers)"
        ],
        "rule_sql": []
    },
    "4416": {
        "db_id": "network_2",
        "question": "Who is the person whose age is below 30?",
        "ground_truth": "SELECT name FROM Person WHERE age  <  30",
        "amends": [
            "Do select only `name` instead of all columns with `*`. Do use table name `Person` instead of `people`. Do change the filter to `age < 30` instead of `age > 30`. The amended query now correctly selects names from the Person table for individuals under 30 years old."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM people WHERE age > 30;",
            "SELECT name FROM Person WHERE age < 30"
        ],
        "rule_sql": []
    },
    "5794": {
        "db_id": "customer_complaints",
        "question": "Find the last name of the staff member who processed the complaint of the cheapest product.",
        "ground_truth": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1",
        "amends": [
            "Do use `t1.last_name` instead of `s.last_name` for the column selection. Do use table aliases `t1`, `t2`, and `t3` instead of `s`, `c`, and `p` respectively. Do remove the `WHERE` clause filtering by `p.price = (SELECT MIN(price) FROM products)` instead of keeping it. Do change the `ORDER BY` to use `t3.product_price` instead of `c.complaint_date DESC`. The amended query now correctly matches the RIGHT_SQL's behavior by ordering based on product price rather than filtering for minimum priced products and ordering by complaint date."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.last_name \nFROM staff s \nJOIN complaints c ON s.staff_id = c.staff_id \nJOIN products p ON c.product_id = p.product_id \nWHERE p.price = (SELECT MIN(price) FROM products) \nORDER BY c.complaint_date DESC \nLIMIT 1;",
            "SELECT t1.last_name\nFROM Staff t1\nJOIN Complaints t2 ON t1.staff_id = t2.staff_id\nJOIN Products t3 ON t2.product_id = t3.product_id\nORDER BY t3.product_price ASC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5714": {
        "db_id": "dorm_1",
        "question": "Find the first and last name of students whose age is younger than the average age.",
        "ground_truth": "SELECT fname ,  lname FROM student WHERE age  <  (SELECT avg(age) FROM student)",
        "amends": [
            "Do use column names `fname` and `lname` instead of `first_name` and `last_name`. Do reference table `student` instead of `students`. Do use comparison operator `<` instead of `>` in the WHERE filter. Do use aggregate function `avg(age)` instead of `AVG(age)` in the subquery. The amended query now correctly selects students younger than the average age instead of older than the average age, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM students WHERE age > (SELECT AVG(age) FROM students)",
            "SELECT fname, lname FROM Student WHERE Age < (SELECT avg(age) FROM Student)"
        ],
        "rule_sql": []
    },
    "1406": {
        "db_id": "college_2",
        "question": "Find the year and semester when offers the largest number of courses.",
        "ground_truth": "SELECT semester ,  YEAR FROM SECTION GROUP BY semester ,  YEAR ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `semester` and `YEAR` instead of `year` and `semester`. Do use table `SECTION` instead of `courses`. Do group by `semester, YEAR` instead of `year, semester`. Do order by `count(*) DESC` instead of `course_count ASC`. Do remove the alias `course_count` instead of keeping it. The amended query now correctly identifies the semester and year with the highest section count from the SECTION table.",
            "Do include only `semester` and `YEAR` in the SELECT list instead of selecting `semester`, `year`, and `COUNT(*)`. Do maintain the `GROUP BY semester, YEAR` clause instead of grouping by `semester, year`. Do preserve the `ORDER BY count(*) DESC LIMIT 1` clause without changes. The amended query now correctly returns only the semester and year with the highest section count instead of including the count value in the result set."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, semester, COUNT(*) as course_count FROM courses GROUP BY year, semester ORDER BY course_count ASC LIMIT 1;",
            "SELECT semester, year, COUNT(*) FROM section GROUP BY semester, year ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT semester, year FROM section GROUP BY semester, year ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6184": {
        "db_id": "music_4",
        "question": "Return the result that is most frequent at music festivals.",
        "ground_truth": "SELECT RESULT FROM music_festival GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select `RESULT` instead of `artist_name` as the column name. Do reference table `music_festival` instead of `music_festivals` as the source table. The amended query now correctly selects from the proper table structure and returns the intended result matching the RIGHT_SQL behavior.",
            "Do select only `RESULT` instead of both `Result` and `COUNT(*) as frequency`. Do move the aggregate function `COUNT(*)` to the `ORDER BY` clause instead of including it in the `SELECT` list. Do use uppercase `RESULT` instead of mixed case `Result` for consistency. The amended query now correctly returns the most frequent result value by counting occurrences in the grouping rather than displaying both the result and count values."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT artist_name FROM music_festivals GROUP BY artist_name ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT Result, COUNT(*) as frequency FROM music_festival GROUP BY Result ORDER BY frequency DESC LIMIT 1;",
            "SELECT RESULT FROM music_festival GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "6725": {
        "db_id": "activity_1",
        "question": "Show ids for all the male faculty.",
        "ground_truth": "SELECT FacID FROM Faculty WHERE Sex  =  'M'",
        "amends": [
            "Do select `FacID` instead of `id` and use table name `Faculty` instead of `faculty`. Do filter on `Sex = 'M'` instead of `gender = 'female'` to query for male faculty members rather than female faculty. The amended query now correctly retrieves faculty IDs from the Faculty table where the sex is specified as male, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM faculty WHERE gender = 'female';",
            "SELECT FacID FROM Faculty WHERE Sex = 'M';"
        ],
        "rule_sql": []
    },
    "4883": {
        "db_id": "school_player",
        "question": "What is the denomination of the school the most players belong to?",
        "ground_truth": "SELECT T2.Denomination FROM player AS T1 JOIN school AS T2 ON T1.School_ID  =  T2.School_ID GROUP BY T1.School_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.Denomination` instead of `denomination` to reference the correct table. Do join `player AS T1` and `school AS T2` with `ON T1.School_ID = T2.School_ID` instead of querying only the `schools` table. Do group by `T1.School_ID` instead of `denomination` to properly aggregate by school identifier. Do order by `COUNT(*) DESC` instead of `player_count ASC` to find the school with the most players rather than the fewest. The amended query now correctly identifies the denomination of the school with the highest player count by joining player and school tables and counting players per school."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT denomination, COUNT(*) as player_count FROM schools GROUP BY denomination ORDER BY player_count ASC LIMIT 1;",
            "SELECT T2.Denomination\nFROM player AS T1\nJOIN school AS T2 ON T1.School_ID = T2.School_ID\nGROUP BY T1.School_ID\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "3146": {
        "db_id": "assets_maintenance",
        "question": "Which staff have contacted which engineers? List the staff name and the engineer first name and last name.",
        "ground_truth": "SELECT T1.staff_name ,  T3.first_name ,  T3.last_name FROM Staff AS T1 JOIN Engineer_Visits AS T2 ON T1.staff_id  =  T2.contact_staff_id JOIN Maintenance_Engineers AS T3 ON T2.engineer_id  =  T3.engineer_id",
        "amends": [
            "Do specify explicit column names `T1.staff_name`, `T3.first_name`, and `T3.last_name` instead of ambiguous `s.name`, `e.first_name`, and `e.last_name`. Do use explicit `JOIN` syntax with `Staff AS T1 JOIN Engineer_Visits AS T2 ON T1.staff_id = T2.contact_staff_id` instead of implicit cross join between `staff` and `engineers`. Do add an intermediate table `Engineer_Visits AS T2` to properly link staff and engineers instead of directly joining staff and engineers. Do use correct join condition `T1.staff_id = T2.contact_staff_id` and `T2.engineer_id = T3.engineer_id` instead of incorrect `s.id = e.id`. Do reference the proper table `Maintenance_Engineers AS T3` instead of the non-existent `engineers` table. The amended query now correctly establishes the relationship between staff and engineers through the bridge table and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.name, e.first_name, e.last_name \nFROM staff s, engineers e \nWHERE s.id = e.id;",
            "SELECT T1.staff_name, T3.first_name, T3.last_name\nFROM Staff AS T1\nJOIN Engineer_Visits AS T2 ON T1.staff_id = T2.contact_staff_id\nJOIN Maintenance_Engineers AS T3 ON T2.engineer_id = T3.engineer_id;"
        ],
        "rule_sql": []
    },
    "2813": {
        "db_id": "news_report",
        "question": "Show the names of journalists and the names of the events they reported in ascending order",
        "ground_truth": "SELECT T3.Name ,  T2.Name FROM news_report AS T1 JOIN event AS T2 ON T1.Event_ID  =  T2.Event_ID JOIN journalist AS T3 ON T1.journalist_ID  =  T3.journalist_ID ORDER BY T2.Event_Attendance ASC",
        "amends": [
            "Do select `T3.Name` and `T2.Name` instead of `journalist_name` and `event_name`. Do join `news_report AS T1` with `event AS T2` on `T1.Event_ID = T2.Event_ID` instead of querying only the `journalists` table. Do add a second join to `journalist AS T3` on `T1.journalist_ID = T3.journalist_ID` instead of omitting these table relationships. Do order by `T2.Event_Attendance ASC` instead of `journalist_name DESC`. The amended query now correctly joins the necessary tables to retrieve journalist and event names through proper relationships and uses the appropriate sorting column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT journalist_name, event_name FROM journalists ORDER BY journalist_name DESC;",
            "SELECT T3.Name, T2.Name\nFROM news_report AS T1\nJOIN event AS T2 ON T1.Event_ID = T2.Event_ID\nJOIN journalist AS T3 ON T1.journalist_ID = T3.journalist_ID\nORDER BY T2.Event_Attendance ASC"
        ],
        "rule_sql": []
    },
    "141": {
        "db_id": "bike_1",
        "question": "What are the ids of stations that are located in San Francisco and have average bike availability above 10.",
        "ground_truth": "SELECT id FROM station WHERE city  =  \"San Francisco\" INTERSECT SELECT station_id FROM status GROUP BY station_id HAVING avg(bikes_available)  >  10",
        "amends": [
            "Do select `id` from `station` instead of `station_id` from `stations`. Do use `INTERSECT` to combine results instead of a single query with `WHERE` conditions. Do add a second query selecting `station_id` from `status` instead of omitting this table entirely. Do group by `station_id` and use `HAVING avg(bikes_available) > 10` instead of filtering `avg_bikes_available > 10` directly in `WHERE`. Do use double quotes around 'San Francisco' instead of single quotes. The amended query now correctly finds stations in San Francisco that have an average bikes available greater than 10 by intersecting results from the station table with aggregated status data, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT station_id FROM stations WHERE city = 'San Francisco' AND avg_bikes_available > 10;",
            "SELECT id FROM station WHERE city = \"San Francisco\"\nINTERSECT\nSELECT station_id FROM status GROUP BY station_id HAVING AVG(bikes_available) > 10"
        ],
        "rule_sql": []
    },
    "1165": {
        "db_id": "body_builder",
        "question": "What are the birth places that are shared by at least two people?",
        "ground_truth": "SELECT Birth_Place FROM people GROUP BY Birth_Place HAVING COUNT(*)  >=  2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT birth_place FROM people GROUP BY birth_place HAVING COUNT(*) > 1"
        ],
        "rule_sql": []
    },
    "352": {
        "db_id": "flight_1",
        "question": "What is the name and distance for the aircraft that has an id of 12?",
        "ground_truth": "SELECT name ,  distance FROM Aircraft WHERE aid  =  12",
        "amends": [
            "Do reference the table as `Aircraft` instead of `aircraft` to match the correct case sensitivity. Do use the column `aid` instead of `id` for the filter condition to properly reference the aircraft identifier column. The amended query now correctly selects aircraft details by matching the appropriate identifier column in the properly cased table name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, distance FROM aircraft WHERE id = 12;",
            "SELECT name, distance FROM Aircraft WHERE aid = 12;"
        ],
        "rule_sql": []
    },
    "515": {
        "db_id": "allergy_1",
        "question": "Show all allergies with number of students affected.",
        "ground_truth": "SELECT Allergy ,  count(*) FROM Has_allergy GROUP BY Allergy",
        "amends": [
            "Do reference the `Has_allergy` table instead of the `students` table. Do use the correct column name `Allergy` instead of `allergy` while maintaining the same case-insensitive grouping logic. The amended query now correctly counts allergies from the appropriate table with proper column references, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT allergy, COUNT(*) FROM students GROUP BY allergy;",
            "SELECT Allergy, COUNT(StuID) AS NumberOfStudentsAffected FROM Has_Allergy GROUP BY Allergy;"
        ],
        "rule_sql": []
    },
    "3325": {
        "db_id": "college_1",
        "question": "What is the last name of the student who got a grade A in the class with code 10018.",
        "ground_truth": "SELECT T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  'A' AND T2.class_code  =  10018",
        "amends": [
            "Do select `T1.stu_lname` instead of `last_name` and use explicit table aliases. Do join `student AS T1` with `enroll AS T2` on `T1.stu_num = T2.stu_num` instead of querying only the `students` table. Do filter on `T2.enroll_grade = 'A'` and `T2.class_code = 10018` instead of filtering on `grade` and `class_code` from a single table. Do remove `ORDER BY student_id DESC LIMIT 1` instead of keeping the ordering and limiting, as the correct logic retrieves all matching records rather than just the most recent one. The amended query now correctly joins the student and enrollment tables to find students with grade A in the specified class, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT last_name FROM students WHERE grade = 'A' AND class_code = 10018 ORDER BY student_id DESC LIMIT 1;",
            "SELECT T1.STU_LNAME FROM STUDENT AS T1 JOIN ENROLL AS T2 ON T1.STU_NUM = T2.STU_NUM WHERE T2.ENROLL_GRADE = 'A' AND T2.CLASS_CODE = '10018'"
        ],
        "rule_sql": []
    },
    "5948": {
        "db_id": "cre_Theme_park",
        "question": "Which attraction type does the most tourist attractions belong to? Tell me its  attraction type description and code.",
        "ground_truth": "SELECT T1.Attraction_Type_Description ,  T2.Attraction_Type_Code FROM Ref_Attraction_Types AS T1 JOIN Tourist_Attractions AS T2 ON T1.Attraction_Type_Code  =  T2.Attraction_Type_Code GROUP BY T2.Attraction_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.Attraction_Type_Description` and `T2.Attraction_Type_Code` instead of `attraction_type`, `description`, and `code`. Do join `Ref_Attraction_Types AS T1` with `Tourist_Attractions AS T2` on `T1.Attraction_Type_Code = T2.Attraction_Type_Code` instead of querying only the `attractions` table. Do group by `T2.Attraction_Type_Code` instead of `attraction_type`. The amended query now correctly joins reference data with main attraction records and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT attraction_type, description, code \nFROM attractions \nGROUP BY attraction_type \nORDER BY COUNT(*) DESC \nLIMIT 1;",
            "SELECT T1.Attraction_Type_Description, T2.Attraction_Type_Code\nFROM Ref_Attraction_Types AS T1\nJOIN Tourist_Attractions AS T2 ON T1.Attraction_Type_Code = T2.Attraction_Type_Code\nGROUP BY T2.Attraction_Type_Code\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "6366": {
        "db_id": "flight_company",
        "question": "How many flights have a velocity larger than 200?",
        "ground_truth": "SELECT count(*) FROM flight WHERE velocity  >  200",
        "amends": [
            "Do reference table `flight` instead of `flights` while maintaining the same `COUNT(*)` aggregation and `velocity > 200` filter condition, with no changes needed to the SELECT list, WHERE clause, or other query components. The amended query now matches RIGHT_SQL's behavior by correcting the table name reference."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE velocity > 200;",
            "SELECT COUNT(*) FROM flight WHERE velocity > 200"
        ],
        "rule_sql": []
    },
    "605": {
        "db_id": "store_1",
        "question": "Which employee manage most number of peoples? List employee's first and last name, and number of people report to that employee.",
        "ground_truth": "SELECT T2.first_name , T2.last_name ,  count(T1.reports_to) FROM employees AS T1 JOIN employees AS T2 ON T1.reports_to = T2.id GROUP BY T1.reports_to ORDER BY count(T1.reports_to) DESC LIMIT 1;",
        "amends": [
            "Do use `JOIN` instead of `LEFT JOIN` to exclude employees with no reports. Do reference `reports_to` instead of `manager_id` as the correct foreign key relationship. Do join on `T1.reports_to = T2.id` instead of `e.employee_id = r.manager_id` to properly connect reports to their managers. Do count `T1.reports_to` instead of `r.employee_id` to accurately count direct reports. Do group by `T1.reports_to` instead of `e.employee_id` to ensure correct aggregation by manager. Do order by `count(T1.reports_to)` instead of the alias `report_count` for explicit column reference. The amended query now correctly identifies managers with the most direct reports by fixing the join direction and aggregation logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT e.first_name, e.last_name, COUNT(r.employee_id) AS report_count\nFROM employees e\nLEFT JOIN employees r ON e.employee_id = r.manager_id\nGROUP BY e.employee_id\nORDER BY report_count DESC\nLIMIT 1;",
            "SELECT e2.first_name, e2.last_name, COUNT(e1.reports_to) AS report_count\nFROM employees e1\nJOIN employees e2 ON e1.reports_to = e2.id\nGROUP BY e1.reports_to\nORDER BY COUNT(e1.reports_to) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1985": {
        "db_id": "phone_market",
        "question": "Show the most frequently used carrier of the phones.",
        "ground_truth": "SELECT Carrier FROM phone GROUP BY Carrier ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do reference table `phone` instead of `phones` and use column `Carrier` instead of `carrier`. Do order by `COUNT(*) DESC` instead of `usage_count ASC` to find the carrier with highest usage instead of lowest. Do remove the alias `usage_count` from the SELECT list instead of including it, as it's not needed in the final output. The amended query now correctly identifies the carrier with the most phones by counting occurrences in descending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT carrier, COUNT(*) as usage_count FROM phones GROUP BY carrier ORDER BY usage_count ASC LIMIT 1;",
            "SELECT Carrier FROM phone GROUP BY Carrier ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2341": {
        "db_id": "csu_1",
        "question": "How many universities have a campus fee higher than average?",
        "ground_truth": "SELECT count(*) FROM csu_fees WHERE campusfee  >  (SELECT avg(campusfee) FROM csu_fees)",
        "amends": [
            "Do reference table `csu_fees` instead of `universities` in both the main query and subquery. Do use column `campusfee` instead of `campus_fee` for both the comparison and aggregate calculation. Do maintain the same aggregate function `avg()` and comparison logic but with the corrected table and column names. The amended query now correctly counts records where campus fee exceeds the average, matching the intended behavior with the proper schema elements."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM universities WHERE campus_fee > (SELECT AVG(campus_fee) FROM universities);",
            "SELECT COUNT(*) \nFROM csu_fees \nWHERE CampusFee > (SELECT AVG(CampusFee) FROM csu_fees)"
        ],
        "rule_sql": []
    },
    "1248": {
        "db_id": "apartment_rentals",
        "question": "Show the booking status code and the corresponding number of bookings.",
        "ground_truth": "SELECT \tbooking_status_code ,  COUNT(*) FROM Apartment_Bookings GROUP BY booking_status_code",
        "amends": [
            "Do select `booking_status_code` instead of `booking_status` and do group by `booking_status_code` instead of `booking_id`. Do use table `Apartment_Bookings` instead of `bookings`. The amended query now correctly counts bookings by status code rather than by booking ID, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT booking_status, COUNT(*) FROM bookings GROUP BY booking_id;",
            "SELECT booking_status_code, COUNT(*) AS number_of_bookings FROM Apartment_Bookings GROUP BY booking_status_code;"
        ],
        "rule_sql": []
    },
    "4268": {
        "db_id": "club_1",
        "question": "Find the number of clubs where \"Tracy Kim\" is a member.",
        "ground_truth": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  \"Tracy\" AND t3.lname  =  \"Kim\"",
        "amends": [
            "Do join `club AS t1` with `member_of_club AS t2` on `t1.clubid = t2.clubid` and then with `student AS t3` on `t2.stuid = t3.stuid` instead of querying only the `clubs` table. Do filter on `t3.fname = \"Tracy\" AND t3.lname = \"Kim\"` instead of filtering directly on a non-existent `member_name` column. Do count all matching records instead of counting from a single table with incorrect filtering. The amended query now correctly counts club memberships for the specified student by properly joining the three related tables and using the correct filter conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM clubs WHERE member_name = 'Tracy Kim';",
            "SELECT COUNT(*) \nFROM Club AS t1\nJOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID\nJOIN Student AS t3 ON t2.StuID = t3.StuID\nWHERE t3.Fname = 'Tracy' AND t3.Lname = 'Kim'"
        ],
        "rule_sql": []
    },
    "6797": {
        "db_id": "activity_1",
        "question": "Find the first names of professors who are not playing Canoeing or Kayaking.",
        "ground_truth": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'",
        "amends": [
            "Do select `lname` from `faculty` instead of `first_name` from `professors`. Do add filter `rank = 'Professor'` instead of omitting it. Do use `EXCEPT` with a subquery instead of `NOT IN` with literal values. Do join `Faculty` with `Faculty_participates_in` on `facID` instead of not joining any tables. Do join `activity` on `actid` instead of incorrect self-join condition `T2.actid = T2.actid`. Do filter for `activity_name` values in subquery instead of direct `NOT IN` filter. Do add `DISTINCT` in subquery instead of omitting it. The amended query now correctly identifies professors who don't participate in specified activities by using proper table relationships and set operations.",
            "Do use `T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'` instead of `a.activity_name IN ('Canoeing', 'Kayaking')` for the WHERE filter. Do correct the JOIN condition to `T2.actid = T3.actid` instead of the incorrect `fpi.actid = a.actid` and ensure proper table aliasing consistency throughout. Do maintain the EXCEPT operation structure while fixing the join predicate and conditional logic. The amended query now correctly identifies professors who have not participated in either Canoeing or Kayaking activities.",
            "Do use `DISTINCT` in the second SELECT instead of omitting it to prevent duplicate names from appearing in the EXCEPT operation. Do correct the JOIN condition from `T2.actid = T2.actid` to `T2.actid = T3.actid` instead of the incorrect self-join predicate. Do reference the activity table as `T3.activity_name` instead of `a.activity_name` to maintain proper table alias consistency. Do use consistent column naming with `lname` instead of `Lname` throughout the query. The amended query now correctly returns professors who don't participate in canoeing or kayaking activities, matching the RIGHT_SQL's behavior.",
            "Do use `T1.lname` in the second SELECT instead of just `lname` to properly qualify the column reference. Do correct the JOIN condition from `T2.actid = T2.actid` to `T2.actid = T3.actid` instead of the self-referencing join predicate. The amended query now correctly identifies professors who have not participated in canoeing or kayaking activities by properly joining the activity table and qualifying column references.",
            "Do use `T2.actid = T3.actid` instead of `T2.actid = T2.actid` in the JOIN condition between Faculty_Participates_in and Activity tables, as the original condition incorrectly joined the table to itself rather than properly linking to the Activity table through the actid foreign key relationship."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM professors WHERE sport NOT IN ('Canoeing', 'Kayaking');",
            "SELECT Lname FROM Faculty WHERE Rank = 'Professor' EXCEPT SELECT DISTINCT f.Lname FROM Faculty f JOIN Faculty_Participates_in fpi ON f.FacID = fpi.FacID JOIN Activity a ON fpi.actid = a.actid WHERE a.activity_name IN ('Canoeing', 'Kayaking')",
            "SELECT f.Lname \nFROM Faculty f\nWHERE f.Rank = 'Professor'\nEXCEPT\nSELECT f.Lname \nFROM Faculty f\nJOIN Faculty_Participates_in fpi ON f.FacID = fpi.FacID\nJOIN Activity a ON fpi.actid = a.actid\nWHERE a.activity_name = 'Canoeing' OR a.activity_name = 'Kayaking'",
            "SELECT lname FROM Faculty WHERE rank = 'Professor'\nEXCEPT\nSELECT DISTINCT lname FROM Faculty T1\nJOIN Faculty_Participates_in T2 ON T1.FacID = T2.FacID\nJOIN Activity T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'",
            "SELECT lname FROM Faculty WHERE rank = 'Professor'\nEXCEPT\nSELECT DISTINCT T1.lname \nFROM Faculty T1\nJOIN Faculty_Participates_in T2 ON T1.FacID = T2.FacID\nJOIN Activity T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'",
            "SELECT lname FROM Faculty WHERE rank = 'Professor'\nEXCEPT\nSELECT DISTINCT T1.lname\nFROM Faculty T1\nJOIN Faculty_Participates_in T2 ON T1.FacID = T2.FacID\nJOIN Activity T3 ON T2.actid = T3.actid\nWHERE T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'"
        ],
        "rule_sql": []
    },
    "562": {
        "db_id": "store_1",
        "question": "How many invoices were billed from Chicago, IL?",
        "ground_truth": "SELECT COUNT(*) FROM invoices WHERE billing_city  =  \"Chicago\" AND billing_state  =  \"IL\";",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM invoices WHERE billing_city = 'Chicago' AND billing_state = 'IL';"
        ],
        "rule_sql": []
    },
    "3149": {
        "db_id": "assets_maintenance",
        "question": "What are all the distinct asset models?",
        "ground_truth": "SELECT DISTINCT asset_model FROM Assets",
        "amends": [
            "Do select only `asset_model` instead of all columns with `*`. Do add `DISTINCT` instead of omitting it to return unique values. Do capitalize the table name as `Assets` instead of lowercase `assets` to match proper case sensitivity. The amended query now correctly returns only distinct asset model values from the Assets table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM assets;",
            "SELECT DISTINCT asset_model FROM Assets;"
        ],
        "rule_sql": []
    },
    "1604": {
        "db_id": "customers_and_invoices",
        "question": "Count the number of invoices.",
        "ground_truth": "SELECT count(*) FROM Invoices",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers;"
        ],
        "rule_sql": []
    },
    "1554": {
        "db_id": "customers_and_invoices",
        "question": "What are the ids, names, dates of opening, and other details for accounts corresponding to the customer with the first name \"Meaghan\"?",
        "ground_truth": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'",
        "amends": [
            "Do join `Accounts AS T1` with `Customers AS T2` on `T1.customer_id = T2.customer_id` instead of querying only the `accounts` table without any join. Do filter on `T2.customer_first_name = 'Meaghan'` instead of filtering directly on the accounts table's non-existent `customer_first_name` column. Do select specific columns `account_id, date_account_opened, account_name, other_account_details` instead of using `SELECT *`. The amended query now correctly retrieves account information by joining with the Customers table to access customer names and matches RIGHT_SQL's behavior.",
            "Do reorder the SELECT list to `account_id`, `date_account_opened`, `account_name`, `other_account_details` instead of `account_id`, `account_name`, `date_account_opened`, `other_account_details`. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM accounts WHERE customer_first_name = 'Meaghan';",
            "SELECT T1.account_id, T1.account_name, T1.date_account_opened, T1.other_account_details\nFROM Accounts AS T1\nJOIN Customers AS T2 ON T1.customer_id = T2.customer_id\nWHERE T2.customer_first_name = 'Meaghan'",
            "SELECT T1.account_id, T1.date_account_opened, T1.account_name, T1.other_account_details\nFROM Accounts AS T1\nJOIN Customers AS T2 ON T1.customer_id = T2.customer_id\nWHERE T2.customer_first_name = 'Meaghan'"
        ],
        "rule_sql": []
    },
    "5320": {
        "db_id": "manufactory_1",
        "question": "Find the number of products for each manufacturer, showing the name of each company.",
        "ground_truth": "SELECT count(*) ,  T2.name FROM products AS T1 JOIN manufacturers AS T2 ON T1.Manufacturer  =  T2.code GROUP BY T2.name",
        "amends": [
            "Do add table `manufacturers AS T2` with a `JOIN` on `T1.Manufacturer = T2.code` instead of querying only the `products` table. Do change the SELECT list to `count(*)` and `T2.name` instead of `manufacturer` and `COUNT(*)`. Do modify the GROUP BY clause to use `T2.name` instead of `manufacturer`. The amended query now correctly joins the products table with manufacturers to count products per manufacturer name instead of using the raw manufacturer code, matching the RIGHT_SQL's behavior.",
            "Do place the `count(*)` column first in the SELECT list instead of second, and do use lowercase `name` instead of uppercase `Name` for the column reference while maintaining the same grouping logic. Do remove the explicit alias `T2.Name` in the SELECT list and instead reference the column directly as `T2.name` to match the grouping column exactly. The FROM clause with JOIN condition `ON T1.Manufacturer = T2.code` remains unchanged, preserving the same table relationships and join predicates. The GROUP BY clause correctly uses `T2.name` instead of `T2.Name` to maintain case consistency throughout the query. The amended query now matches the RIGHT_SQL's behavior with identical logical results despite the syntactic adjustments."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT manufacturer, COUNT(*) FROM products GROUP BY manufacturer;",
            "SELECT T2.Name, COUNT(*) \nFROM Products AS T1 \nJOIN Manufacturers AS T2 ON T1.Manufacturer = T2.Code \nGROUP BY T2.Name",
            "SELECT COUNT(*) AS product_count, T2.name AS company_name\nFROM Products AS T1\nJOIN Manufacturers AS T2 ON T1.Manufacturer = T2.code\nGROUP BY T2.name"
        ],
        "rule_sql": []
    },
    "6109": {
        "db_id": "customers_and_addresses",
        "question": "What is the name of the customer that has purchased the most items?",
        "ground_truth": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id GROUP BY t1.customer_name ORDER BY sum(t3.order_quantity) DESC LIMIT 1",
        "amends": [
            "Do add `JOIN customer_orders AS t2 ON t1.customer_id = t2.customer_id` and `JOIN order_items AS t3 ON t2.order_id = t3.order_id` instead of querying only the `customers` table. Do change the `SELECT` list to `t1.customer_name` instead of `customer_name` and add table alias `t1` for the customers table. Do add `GROUP BY t1.customer_name` instead of omitting grouping. Do change the `ORDER BY` clause to `sum(t3.order_quantity) DESC` instead of `customer_id DESC` to order by total order quantity rather than customer ID. The amended query now correctly identifies the customer with the highest total order quantity by joining through the order hierarchy and aggregating quantities, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name FROM customers ORDER BY customer_id DESC LIMIT 1;",
            "SELECT t1.customer_name\nFROM Customers AS t1\nJOIN Customer_Orders AS t2 ON t1.customer_id = t2.customer_id\nJOIN Order_Items AS t3 ON t2.order_id = t3.order_id\nGROUP BY t1.customer_name\nORDER BY SUM(t3.order_quantity) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "2477": {
        "db_id": "movie_1",
        "question": "What are the names of all the different reviewers who rates Gone with the Wind?",
        "ground_truth": "SELECT DISTINCT T3.name FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.title  =  'Gone with the Wind'",
        "amends": [
            "Do join `Rating AS T1`, `Movie AS T2`, and `Reviewer AS T3` tables instead of querying only the `ratings` table. Do use `JOIN Movie AS T2 ON T1.mID = T2.mID` to connect ratings to movies instead of filtering directly on movie_title. Do use `JOIN Reviewer AS T3 ON T1.rID = T3.rID` to get reviewer names instead of selecting reviewer_name directly. Do filter on `T2.title = 'Gone with the Wind'` instead of `movie_title = 'Gone with the Wind'`. Do select `T3.name` instead of `reviewer_name`. The amended query now correctly joins the necessary tables to find reviewers who rated the specific movie."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT reviewer_name FROM ratings WHERE movie_title = 'Gone with the Wind';",
            "SELECT DISTINCT T3.name\nFROM Rating AS T1\nJOIN Movie AS T2 ON T1.mID = T2.mID\nJOIN Reviewer AS T3 ON T1.rID = T3.rID\nWHERE T2.title = 'Gone with the Wind'"
        ],
        "rule_sql": []
    },
    "679": {
        "db_id": "customers_card_transactions",
        "question": "Show the customer id and number of accounts with most accounts.",
        "ground_truth": "SELECT customer_id ,  count(*) FROM Accounts GROUP BY customer_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use `count(*)` instead of `COUNT(account_id)` to count all rows including those with NULL account_id values. Do order by `count(*) DESC` instead of `num_accounts ASC` to find the customer with the most accounts rather than the fewest. Do remove the alias `num_accounts` instead of keeping it since the ORDER BY clause now directly references the aggregate function. The amended query now correctly identifies the customer with the maximum number of accounts by counting all records per customer and sorting in descending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_id, COUNT(account_id) as num_accounts \nFROM accounts \nGROUP BY customer_id \nORDER BY num_accounts ASC \nLIMIT 1;",
            "SELECT customer_id, COUNT(*) \nFROM Accounts \nGROUP BY customer_id \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5727": {
        "db_id": "dorm_1",
        "question": "How many students live in each city and what are their average ages?",
        "ground_truth": "SELECT count(*) ,  avg(age) ,  city_code FROM student GROUP BY city_code",
        "amends": [
            "Do select `count(*)`, `avg(age)`, and `city_code` instead of `city`, `COUNT(*) as student_count`, and `AVG(age) as average_age`. Do use table `student` instead of `students`. Do group by `city_code` instead of `city`. Do remove the aliases `student_count` and `average_age` instead of keeping them. The amended query now correctly aggregates by city_code field and matches the intended behavior.",
            "Do place `city_code` at the end of the SELECT list instead of at the beginning, and do remove the comma after `COUNT(*)` instead of keeping it. The amended query now correctly groups by city_code while maintaining the same aggregation logic and output behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, COUNT(*) as student_count, AVG(age) as average_age FROM students GROUP BY city;",
            "SELECT city_code, COUNT(*), AVG(age) FROM Student GROUP BY city_code;",
            "SELECT COUNT(*), AVG(age), city_code FROM Student GROUP BY city_code"
        ],
        "rule_sql": []
    },
    "3300": {
        "db_id": "college_1",
        "question": "What is the name of the department with the student that has the lowest GPA?",
        "ground_truth": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT 1",
        "amends": [
            "Do select `T2.dept_name` instead of `d.name` for the department name. Do use table aliases `T1` and `T2` instead of `s` and `d` for clarity. Do join on `T1.dept_code = T2.dept_code` instead of `d.id = s.department_id` to use the correct join condition. Do order by `stu_gpa` instead of `s.gpa` to reference the correct GPA column name. Do maintain the `LIMIT 1` clause to return only the top result. The amended query now correctly retrieves the department name for the student with the highest GPA using proper table relationships and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT d.name FROM departments d JOIN students s ON d.id = s.department_id ORDER BY s.gpa DESC LIMIT 1;",
            "SELECT T2.DEPT_NAME \nFROM STUDENT T1\nJOIN DEPARTMENT T2 ON T1.DEPT_CODE = T2.DEPT_CODE\nORDER BY T1.STU_GPA ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5355": {
        "db_id": "tracking_software_problems",
        "question": "Find the oldest log id and its corresponding problem id.",
        "ground_truth": "SELECT problem_log_id ,  problem_id FROM problem_log ORDER BY log_entry_date LIMIT 1",
        "amends": [
            "Do select `problem_log_id` and `problem_id` instead of `MIN(log_id)` and `problem_id`. Do query from `problem_log` table instead of `logs` table. Do order by `log_entry_date` instead of `log_id ASC`. Do remove the `MIN()` aggregation function instead of keeping it. The amended query now correctly retrieves the first log entry by date rather than finding the minimum log ID with aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(log_id), problem_id FROM logs ORDER BY log_id ASC LIMIT 1;",
            "SELECT problem_log_id, problem_id FROM Problem_Log ORDER BY log_entry_date ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6668": {
        "db_id": "driving_school",
        "question": "When did customer with first name as Carole and last name as Bernhard became a customer?",
        "ground_truth": "SELECT date_became_customer FROM Customers WHERE first_name = \"Carole\" AND last_name = \"Bernhard\";",
        "amends": [
            "Do select `date_became_customer` instead of `created_at` for the column name. Do use `\"Bernhard\"` instead of `'Bernhardt'` for the last name filter value. Do reference the table as `Customers` (capitalized) instead of `customers` (lowercase). The amended query now correctly retrieves the customer registration date with the proper name spelling and table reference."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT created_at FROM customers WHERE first_name = 'Carole' AND last_name = 'Bernhardt';",
            "SELECT date_became_customer FROM Customers WHERE first_name = 'Carole' AND last_name = 'Bernhard';"
        ],
        "rule_sql": []
    },
    "2104": {
        "db_id": "cre_Doc_Control_Systems",
        "question": "What are all role codes?",
        "ground_truth": "SELECT role_code FROM ROLES;",
        "amends": [
            "Do select only `role_code` instead of all columns with `*`. Do remove the `WHERE code IS NULL` filter instead of keeping it, as the right query retrieves all role codes without filtering. Do reference the table as `ROLES` instead of `roles` to match the correct case sensitivity. The amended query now correctly returns all role codes from the ROLES table without unnecessary filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM roles WHERE code IS NULL;",
            "SELECT role_code FROM Roles"
        ],
        "rule_sql": []
    },
    "4118": {
        "db_id": "film_rank",
        "question": "What are the low and high estimates of film markets?",
        "ground_truth": "SELECT Low_Estimate ,  High_Estimate FROM film_market_estimation",
        "amends": [
            "Do reference the correct table `film_market_estimation` instead of the incorrect table `film_markets`. Do use the correct column names `Low_Estimate` and `High_Estimate` with proper capitalization instead of the lowercase versions `low_estimate` and `high_estimate`. The amended query now correctly retrieves estimation data from the appropriate table with the proper column names, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT low_estimate, high_estimate FROM film_markets WHERE market_name = 'Hollywood';",
            "SELECT Low_Estimate, High_Estimate FROM film_market_estimation;"
        ],
        "rule_sql": []
    },
    "6611": {
        "db_id": "train_station",
        "question": "Show the name and service for all trains in order by time.",
        "ground_truth": "SELECT name ,  service FROM train ORDER BY TIME",
        "amends": [
            "Do reference table `train` instead of `trains` in the FROM clause. Do order by `TIME` instead of `name` in the ORDER BY clause. The amended query now correctly references the intended table and sorts results by time rather than name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, service FROM trains ORDER BY name;",
            "SELECT Name, Service FROM train ORDER BY Time;"
        ],
        "rule_sql": []
    },
    "5882": {
        "db_id": "tracking_share_transactions",
        "question": "What are the dates of transactions with at least 100 share count or amount bigger than 100?",
        "ground_truth": "SELECT date_of_transaction FROM TRANSACTIONS WHERE share_count  >=  100 OR amount_of_transaction  >=  100",
        "amends": [
            "Do reference `date_of_transaction` instead of `date` in the SELECT list. Do use `amount_of_transaction >= 100` instead of `amount > 100` in the WHERE filter, changing both the column name and the comparison operator from greater than to greater than or equal. The amended query now correctly references the appropriate column names and uses inclusive comparison logic to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT date FROM transactions WHERE share_count >= 100 OR amount > 100;",
            "SELECT date_of_transaction FROM Transactions WHERE share_count >= 100 OR amount_of_transaction >= 100;"
        ],
        "rule_sql": []
    },
    "4804": {
        "db_id": "aircraft",
        "question": "How many international and domestic passengers are there in the airport London Heathrow?",
        "ground_truth": "SELECT International_Passengers ,  Domestic_Passengers FROM airport WHERE Airport_Name  =  \"London Heathrow\"",
        "amends": [
            "Do select specific columns `International_Passengers` and `Domestic_Passengers` instead of using `COUNT(*)` aggregate function. Do query from table `airport` instead of table `passengers`. Do filter on column `Airport_Name` with value \"London Heathrow\" instead of filtering on column `airport` with value 'London Heathrow'. Do use double quotes for string literals instead of single quotes. The amended query now correctly retrieves passenger counts by type from the airport table rather than counting records from an incorrect table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM passengers WHERE airport = 'London Heathrow';",
            "SELECT International_Passengers, Domestic_Passengers FROM airport WHERE Airport_Name = \"London Heathrow\";"
        ],
        "rule_sql": []
    },
    "1586": {
        "db_id": "customers_and_invoices",
        "question": "What are the ids for transactions that have an amount greater than the average amount of a transaction?",
        "ground_truth": "SELECT transaction_id FROM Financial_transactions WHERE transaction_amount  >  (SELECT avg(transaction_amount) FROM Financial_transactions)",
        "amends": [
            "Do reference `transaction_id` instead of `id` and `transaction_amount` instead of `amount` in the SELECT list and WHERE filter. Do use the correct table name `Financial_transactions` instead of `transactions` in both the main query and subquery. Do maintain the same aggregate function `avg(transaction_amount)` instead of `AVG(amount)` in the subquery, preserving the logic of comparing against the average value. The amended query now correctly references the appropriate columns and table names while maintaining the original behavioral intent of selecting records above the average transaction amount."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM transactions WHERE amount > (SELECT AVG(amount) FROM transactions)",
            "SELECT transaction_id FROM Financial_Transactions WHERE transaction_amount > (SELECT AVG(transaction_amount) FROM Financial_Transactions)"
        ],
        "rule_sql": []
    },
    "6716": {
        "db_id": "activity_1",
        "question": "What is the total number of faculty members?",
        "ground_truth": "SELECT count(*) FROM Faculty",
        "amends": [
            "Do reference the `Faculty` table instead of the `students` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)`. The amended query now correctly counts records from the Faculty table instead of the students table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;",
            "SELECT count(*) FROM Faculty;"
        ],
        "rule_sql": []
    },
    "1033": {
        "db_id": "phone_1",
        "question": "Find the name of the company that has the least number of phone models. List the company name and the number of phone model produced by that company.",
        "ground_truth": "SELECT Company_name ,  count(*) FROM phone GROUP BY Company_name ORDER BY count(*) ASC LIMIT 1;",
        "amends": [
            "Do use `Company_name` instead of `company` for the column name and `phone` instead of `phone_models` for the table name. Do use `Company_name` instead of `company` in the GROUP BY clause. Do remove the alias `model_count` instead of keeping it, and reference `count(*)` directly in the ORDER BY clause instead of using the alias. Do maintain the same aggregation, grouping, ordering direction, and limit logic throughout the query."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT company, COUNT(*) as model_count FROM phone_models GROUP BY company ORDER BY model_count ASC LIMIT 1;",
            "SELECT Company_name, COUNT(*) FROM phone GROUP BY Company_name ORDER BY COUNT(*) ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4785": {
        "db_id": "department_store",
        "question": "Find the names of products that were bought by at least two distinct customers.",
        "ground_truth": "SELECT DISTINCT T3.product_name FROM customer_orders AS T1 JOIN order_items AS T2 ON T1.order_id  =  T2.order_id JOIN products AS T3 ON T2.product_id  =  T3.product_id GROUP BY T3.product_id HAVING COUNT (DISTINCT T1.customer_id)  >=  2",
        "amends": [
            "Do select `T3.product_name` instead of `p.name` and add `DISTINCT` instead of omitting it. Do use three joined tables `customer_orders AS T1`, `order_items AS T2`, and `products AS T3` instead of only `products` and `orders`. Do join on `T1.order_id = T2.order_id` and `T2.product_id = T3.product_id` instead of `p.id = o.product_id`. Do change the HAVING condition to `COUNT(DISTINCT T1.customer_id) >= 2` instead of `COUNT(DISTINCT o.customer_id) >= 1`. The amended query now correctly identifies products purchased by at least two distinct customers through the proper table relationships and grouping."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.name \nFROM products p\nJOIN orders o ON p.id = o.product_id\nGROUP BY p.id\nHAVING COUNT(DISTINCT o.customer_id) >= 1",
            "SELECT DISTINCT T3.product_name\nFROM customer_orders AS T1\nJOIN order_items AS T2 ON T1.order_id = T2.order_id\nJOIN products AS T3 ON T2.product_id = T3.product_id\nGROUP BY T3.product_id\nHAVING COUNT(DISTINCT T1.customer_id) >= 2"
        ],
        "rule_sql": []
    },
    "4015": {
        "db_id": "ship_mission",
        "question": "What are the nations that have more than two ships?",
        "ground_truth": "SELECT Nationality FROM ship GROUP BY Nationality HAVING COUNT(*)  >  2",
        "amends": [
            "Do reference the `Nationality` column instead of `nation` and use the `ship` table instead of `ships` while maintaining the same `GROUP BY` clause and `HAVING COUNT(*) > 2` condition, as the amended query now correctly identifies the table and column names to match the intended schema. The amended query now produces the same results as the RIGHT_SQL by properly counting ships grouped by their nationality."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT nation FROM ships GROUP BY nation HAVING COUNT(*) > 2",
            "SELECT Nationality FROM ship GROUP BY Nationality HAVING COUNT(*) > 2"
        ],
        "rule_sql": []
    },
    "5180": {
        "db_id": "music_2",
        "question": "How many songs are there?",
        "ground_truth": "SELECT count(*) FROM Songs",
        "amends": [
            "Do query the `Songs` table instead of the `artists` table. The amended query now correctly counts records from the Songs table as specified in the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM artists;",
            "SELECT COUNT(*) FROM Songs;"
        ],
        "rule_sql": []
    },
    "264": {
        "db_id": "musical",
        "question": "List the most common result of the musicals.",
        "ground_truth": "SELECT RESULT FROM musical GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do reference the table as `musical` instead of `musicals` in the FROM clause. Do select only `RESULT` instead of both `result` and `COUNT(*) as count` in the SELECT list. Do use `ORDER BY COUNT(*) DESC` instead of `ORDER BY count DESC` to reference the aggregate function directly rather than an alias. Do remove the explicit column alias `as count` since it's not needed in the final selection. The amended query now correctly identifies the most frequent result from the musical table by counting occurrences directly in the ORDER BY clause."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT result, COUNT(*) as count FROM musicals GROUP BY result ORDER BY count DESC LIMIT 1;",
            "SELECT Result FROM musical GROUP BY Result ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "838": {
        "db_id": "chinook_1",
        "question": "What is the name of the media type that is least common across all tracks?",
        "ground_truth": "SELECT T1.Name FROM MEDIATYPE AS T1 JOIN TRACK AS T2 ON T1.MediaTypeId  =  T2.MediaTypeId GROUP BY T2.MediaTypeId ORDER BY COUNT(*) ASC LIMIT 1",
        "amends": [
            "Do select `T1.Name` instead of `MediaType.Name` and omit the `track_count` alias. Do use table aliases `T1` and `T2` instead of full table names. Do group by `T2.MediaTypeId` instead of `MediaType.Name`. Do order by `COUNT(*)` instead of the alias `track_count`. The amended query now correctly identifies the media type with the fewest tracks by grouping on the MediaTypeId rather than the name, ensuring accurate counting and ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MediaType.Name, COUNT(Track.TrackId) as track_count\nFROM MediaType\nJOIN Track ON MediaType.MediaTypeId = Track.MediaTypeId\nGROUP BY MediaType.Name\nORDER BY track_count ASC\nLIMIT 1;",
            "SELECT T1.Name FROM MediaType T1 JOIN Track T2 ON T1.MediaTypeId = T2.MediaTypeId GROUP BY T2.MediaTypeId ORDER BY COUNT(*) LIMIT 1"
        ],
        "rule_sql": []
    },
    "2980": {
        "db_id": "sakila_1",
        "question": "How many stores are there?",
        "ground_truth": "SELECT count(*) FROM store",
        "amends": [
            "Do query the `store` table instead of the `employees` table. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees;",
            "SELECT COUNT(*) FROM store;"
        ],
        "rule_sql": []
    },
    "6207": {
        "db_id": "roller_coaster",
        "question": "Show the statuses of roller coasters longer than 3300 or higher than 100.",
        "ground_truth": "SELECT Status FROM roller_coaster WHERE LENGTH  >  3300 OR Height  >  100",
        "amends": [
            "Do reference the table as `roller_coaster` instead of `roller_coasters`. Do use `OR` between the conditions `LENGTH > 3300` and `Height > 100` instead of `AND`. Do capitalize column names as `Status` and `Height` instead of lowercase `status` and `height`. The amended query now correctly returns records where either the length exceeds 3300 or the height exceeds 100, matching the intended logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT status FROM roller_coasters WHERE length > 3300 AND height > 100;",
            "SELECT Status FROM roller_coaster WHERE Length > 3300 OR Height > 100;"
        ],
        "rule_sql": []
    },
    "3732": {
        "db_id": "program_share",
        "question": "What is the owner of the channel that has the highest rating ratio?",
        "ground_truth": "SELECT OWNER FROM channel ORDER BY rating_in_percent DESC LIMIT 1",
        "amends": [
            "Do reference table `channel` instead of `channels`. Do use column `rating_in_percent` instead of `rating` in the ORDER BY clause. The amended query now correctly references the single table and appropriate rating column to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT owner FROM channels ORDER BY rating DESC LIMIT 1;",
            "SELECT Owner FROM channel ORDER BY rating_in_percent DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "182": {
        "db_id": "bike_1",
        "question": "For each zip code, select all those that have an average mean visiblity below 10.",
        "ground_truth": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_visibility_miles)  <  10",
        "amends": [
            "Do select only `zip_code` instead of including `AVG(mean_visibility)` with an alias. Do use table `weather` instead of `weather_data`. Do remove the `WHERE` clause filtering on `avg_visibility` instead of keeping it. Do add a `HAVING` clause with `avg(mean_visibility_miles) < 10` instead of omitting it. Do reference column `mean_visibility_miles` instead of `mean_visibility` in the aggregate function. The amended query now correctly filters groups based on the average visibility threshold using HAVING instead of incorrectly attempting to filter aggregates in the WHERE clause."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT zip_code, AVG(mean_visibility) as avg_visibility \nFROM weather_data \nWHERE avg_visibility < 10 \nGROUP BY zip_code",
            "SELECT zip_code FROM weather GROUP BY zip_code HAVING AVG(mean_visibility_miles) < 10"
        ],
        "rule_sql": []
    },
    "6776": {
        "db_id": "activity_1",
        "question": "Find the number of activities Mark Giuliano is involved in.",
        "ground_truth": "SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  \"Mark\" AND T1.lname  =  \"Giuliano\"",
        "amends": [
            "Do join `Faculty AS T1` and `Faculty_participates_in AS T2` on `T1.facID = T2.facID` instead of querying only the `activities` table. Do filter on `T1.fname = \"Mark\"` and `T1.lname = \"Giuliano\"` instead of filtering on `name = 'Mark Giuliano'`. Do count all joined records instead of counting from a single table. The amended query now correctly identifies faculty participation by joining related tables and using proper name filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM activities WHERE name = 'Mark Giuliano';",
            "SELECT COUNT(*) \nFROM Faculty AS T1\nJOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID\nWHERE T1.Fname = 'Mark' AND T1.Lname = 'Giuliano'"
        ],
        "rule_sql": []
    },
    "1119": {
        "db_id": "climbing",
        "question": "Count the number of different countries that climbers are from.",
        "ground_truth": "SELECT COUNT(DISTINCT Country) FROM climber",
        "amends": [
            "Do `COUNT(DISTINCT Country)` instead of `COUNT(*)` to count unique countries rather than all rows. Do reference table `climber` instead of `climbers` to use the correct table name. The amended query now correctly counts distinct countries from the climber table instead of counting all rows from the incorrect table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM climbers;",
            "SELECT COUNT(DISTINCT Country) FROM climber;"
        ],
        "rule_sql": []
    },
    "6547": {
        "db_id": "wine_1",
        "question": "Find the the grape whose white color grapes are used to produce wines with scores higher than 90.",
        "ground_truth": "SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  \"White\" AND T2.score  >  90",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do add `JOIN WINE AS T2` instead of querying only the `grapes` table. Do change the join condition to `ON T1.Grape = T2.Grape` instead of the previous single-table filter. Do change the score filter to reference `T2.score > 90` instead of the non-existent `score` column in the grapes table. Do change the color filter to reference `T1.Color = \"White\"` instead of `color = 'white'` with different quoting. The amended query now correctly joins the grapes and wine tables to find distinct white grapes that appear in wines with scores above 90, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT grape FROM grapes WHERE color = 'white' AND score > 90;",
            "SELECT DISTINCT T1.Grape\nFROM grapes AS T1\nJOIN wine AS T2 ON T1.Grape = T2.Grape\nWHERE T1.Color = \"White\" AND T2.Score > 90"
        ],
        "rule_sql": []
    },
    "4638": {
        "db_id": "college_3",
        "question": "Count the number of courses with more than 2 credits.",
        "ground_truth": "SELECT count(*) FROM COURSE WHERE Credits  >  2",
        "amends": [
            "Do reference table `COURSE` instead of `courses` and use column `Credits` instead of `credits` to match the correct schema naming conventions, while maintaining the same filter condition `> 2` and aggregate function `count(*)` to preserve the identical counting logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM courses WHERE credits > 2",
            "SELECT COUNT(*) FROM Course WHERE Credits > 2"
        ],
        "rule_sql": []
    },
    "1153": {
        "db_id": "body_builder",
        "question": "What is the average snatch score of body builders?",
        "ground_truth": "SELECT avg(Snatch) FROM body_builder",
        "amends": [
            "Do use the `avg` aggregate function on the `Snatch` column instead of `AVG` on `deadlift`. Do reference the `body_builder` table instead of `body_builders`. The amended query now correctly calculates the average Snatch value from the body_builder table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(deadlift) FROM body_builders;",
            "SELECT AVG(Snatch) FROM body_builder;"
        ],
        "rule_sql": []
    },
    "3293": {
        "db_id": "college_1",
        "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments",
        "ground_truth": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'",
        "amends": [
            "Do add joins to `student`, `enroll`, `CLASS`, `course`, and `department` tables instead of querying only `students` table. Do change the SELECT list to `stu_fname` instead of `first_name`. Do completely rewrite the WHERE clause to use `INTERSECT` between two department queries instead of the impossible `AND` condition with conflicting `department` values. Do add proper join conditions with `ON T1.stu_num = T2.stu_num`, `ON T2.class_code = T3.class_code`, `ON T3.crs_code = T4.crs_code`, and `ON T5.dept_code = T4.dept_code` instead of no joins. Do change the filter to use `T5.dept_name = 'Accounting'` and `T5.dept_name = 'Computer Info. Systems'` in separate INTERSECT branches instead of the contradictory single WHERE clause. The amended query now correctly finds students enrolled in both departments using INTERSECT logic instead of the impossible condition that would return no results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM students WHERE department = 'accounting' AND department = 'Computer Info. Systems'",
            "SELECT stu_fname\nFROM STUDENT\nWHERE STU_NUM IN (\n    SELECT T1.STU_NUM\n    FROM STUDENT T1\n    JOIN ENROLL T2 ON T1.STU_NUM = T2.STU_NUM\n    JOIN CLASS T3 ON T2.CLASS_CODE = T3.CLASS_CODE\n    JOIN COURSE T4 ON T3.CRS_CODE = T4.CRS_CODE\n    JOIN DEPARTMENT T5 ON T4.DEPT_CODE = T5.DEPT_CODE\n    WHERE T5.DEPT_NAME = 'Accounting'\n    INTERSECT\n    SELECT T1.STU_NUM\n    FROM STUDENT T1\n    JOIN ENROLL T2 ON T1.STU_NUM = T2.STU_NUM\n    JOIN CLASS T3 ON T2.CLASS_CODE = T3.CLASS_CODE\n    JOIN COURSE T4 ON T3.CRS_CODE = T4.CRS_CODE\n    JOIN DEPARTMENT T5 ON T4.DEPT_CODE = T5.DEPT_CODE\n    WHERE T5.DEPT_NAME = 'Computer Info. Systems'\n)"
        ],
        "rule_sql": []
    },
    "4741": {
        "db_id": "department_store",
        "question": "What are the ids of the two department store chains with the largest number of department stores?",
        "ground_truth": "SELECT dept_store_chain_id FROM department_stores GROUP BY dept_store_chain_id ORDER BY count(*) DESC LIMIT 2",
        "amends": [
            "Do select `dept_store_chain_id` instead of `chain_id` in the SELECT list. Do remove the alias `store_count` instead of keeping it. Do group by `dept_store_chain_id` instead of `chain_id`. Do order by `count(*)` directly instead of referencing the removed alias `store_count`. The amended query now correctly references the proper column name throughout and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT chain_id, COUNT(*) as store_count \nFROM department_stores \nGROUP BY chain_id \nORDER BY store_count DESC \nLIMIT 2;",
            "SELECT dept_store_chain_id FROM Department_Stores GROUP BY dept_store_chain_id ORDER BY COUNT(*) DESC LIMIT 2"
        ],
        "rule_sql": []
    },
    "2634": {
        "db_id": "inn_1",
        "question": "Find the name of rooms whose price is higher than the average price.",
        "ground_truth": "SELECT roomName FROM Rooms WHERE basePrice  >  ( SELECT avg(basePrice) FROM Rooms );",
        "amends": [
            "Do use `roomName` in the SELECT list instead of `name`. Do reference the `Rooms` table with proper capitalization instead of `rooms`. Do use `basePrice` column instead of `price` in both the main query and subquery. Do use `avg(basePrice)` with proper function capitalization instead of `AVG(price)`. The amended query now correctly references the schema elements and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM rooms WHERE price > (SELECT AVG(price) FROM rooms);",
            "SELECT roomName FROM Rooms WHERE basePrice > (SELECT AVG(basePrice) FROM Rooms);"
        ],
        "rule_sql": []
    },
    "3964": {
        "db_id": "hospital_1",
        "question": "What nurses are on call with block floor 1 and block code 1? Tell me their names.",
        "ground_truth": "SELECT nurse FROM on_call WHERE blockfloor  =  1 AND blockcode  =  1",
        "amends": [
            "Do reference the `nurse` column from the `on_call` table instead of the `name` column from the `nurses` table. Do use the `on_call` table as the data source instead of the `nurses` table. Do filter on `blockfloor = 1` and `blockcode = 1` instead of `block_floor = 1` and `block_code = 1` to match the correct column names in the target table. The amended query now correctly retrieves nurse information from the on_call table with the appropriate floor and code filters.",
            "Do select `nurse` instead of `n.Name` from the `Nurse` table. Do query only the `on_call` table instead of performing a `JOIN` between `Nurse` and `On_Call` tables. Do remove the join condition `n.EmployeeID = oc.Nurse` instead of including it. Do keep the filters `blockfloor = 1` and `blockcode = 1` in the `WHERE` clause as they remain correct. The amended query now directly retrieves nurse identifiers from the on_call table without unnecessary table joins, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM nurses WHERE block_floor = 1 AND block_code = 1;",
            "SELECT n.Name FROM Nurse n JOIN On_Call oc ON n.EmployeeID = oc.Nurse WHERE oc.BlockFloor = 1 AND oc.BlockCode = 1;",
            "SELECT nurse FROM On_Call WHERE BlockFloor = 1 AND BlockCode = 1;"
        ],
        "rule_sql": []
    },
    "2626": {
        "db_id": "inn_1",
        "question": "For each bed type, find the average room price.",
        "ground_truth": "SELECT bedType ,  avg(basePrice) FROM Rooms GROUP BY bedType;",
        "amends": [
            "Do select `bedType` and `avg(basePrice)` instead of `bed_type` and `AVG(price)`. Do group by `bedType` instead of `room_id` to correctly calculate average prices by bed type rather than per room. The amended query now matches the intended behavior of aggregating average base prices by bed type categories."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT bed_type, AVG(price) FROM rooms GROUP BY room_id;",
            "SELECT bedType, AVG(basePrice) FROM Rooms GROUP BY bedType;"
        ],
        "rule_sql": []
    },
    "969": {
        "db_id": "medicine_enzyme_interaction",
        "question": "Show the medicine names and trade names that cannot interact with the enzyme with product 'Heme'.",
        "ground_truth": "SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  'Protoporphyrinogen IX'",
        "amends": [
            "Do use `EXCEPT` set operation instead of `LEFT JOIN` with `IS NULL` filter. Do select from `medicine` directly instead of joining through `interaction` table. Do change the join to use `medicine_enzyme_interaction` instead of `interaction` table. Do join with `enzyme` on `T3.id = T2.enzyme_id` instead of `e.id = i.enzyme_id`. Do filter for `T3.product = 'Protoporphyrinogen IX'` instead of `e.product = 'Heme'`. Do remove the `LEFT JOIN` condition and `IS NULL` check entirely instead of keeping them. The amended query now correctly identifies medicines that do not interact with enzymes producing Protoporphyrinogen IX using set difference logic instead of null-check joins."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT m.name, m.trade_name \nFROM medicine m\nLEFT JOIN interaction i ON m.id = i.medicine_id\nLEFT JOIN enzyme e ON i.enzyme_id = e.id AND e.product = 'Heme'\nWHERE e.id IS NULL;",
            "SELECT name, Trade_Name FROM medicine\nEXCEPT\nSELECT m.name, m.Trade_Name \nFROM medicine m\nJOIN medicine_enzyme_interaction mei ON m.id = mei.medicine_id\nJOIN enzyme e ON mei.enzyme_id = e.id\nWHERE e.Product = 'Protoporphyrinogen IX'"
        ],
        "rule_sql": []
    },
    "177": {
        "db_id": "bike_1",
        "question": "List the name and the number of stations for all the cities that have at least 15 stations.",
        "ground_truth": "SELECT city ,  COUNT(*) FROM station GROUP BY city HAVING COUNT(*)  >=  15",
        "amends": [
            "Do use `COUNT(*)` instead of `COUNT(station_id)` to count all rows regardless of null values. Do move the aggregate filter to `HAVING` clause instead of incorrectly placing it in `WHERE` clause, since aggregate functions cannot be used in WHERE. Do reference table `station` instead of `stations` to match the correct table name. The amended query now correctly filters aggregated results using HAVING and counts all stations per city, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, COUNT(station_id) FROM stations GROUP BY city WHERE COUNT(station_id) >= 15;",
            "SELECT city, COUNT(*) AS station_count FROM station GROUP BY city HAVING COUNT(*) >= 15;"
        ],
        "rule_sql": []
    },
    "926": {
        "db_id": "insurance_fnol",
        "question": "What are the IDs of customers who have \"Diana\" in part of their names?",
        "ground_truth": "SELECT customer_id FROM customers WHERE customer_name LIKE \"%Diana%\"",
        "amends": [
            "Do use `customer_name` column instead of `name` column in the WHERE clause. Do use `LIKE \"%Diana%\"` pattern matching instead of exact equality `= 'Diana'` to allow for partial matches. The amended query now correctly searches for customers with names containing \"Diana\" anywhere in the text rather than requiring an exact match, ensuring it matches the intended behavior of the right SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_id FROM customers WHERE name = 'Diana';",
            "SELECT Customer_ID FROM Customers WHERE Customer_name LIKE '%Diana%'"
        ],
        "rule_sql": []
    },
    "6407": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "How many documents are with document type code BK for each product id?",
        "ground_truth": "SELECT count(*) ,  project_id FROM Documents WHERE document_type_code  =  \"BK\" GROUP BY project_id",
        "amends": [
            "Do count `*` instead of `product_id` in the SELECT list. Do select `project_id` instead of `product_id` as the grouping column. Do reference `project_id` in the GROUP BY clause instead of `product_id`. Do use double quotes `\"BK\"` for the string literal instead of single quotes `'BK'`. The amended query now correctly groups by project_id and counts documents with the specified document type code, matching the intended behavior.",
            "Do place `project_id` after `count(*)` in the SELECT list instead of before it, and do use lowercase `document_type_code` in the WHERE filter instead of mixed case `Document_Type_Code`, while maintaining the same aggregate count and grouping logic. The amended query now matches RIGHT_SQL's behavior with identical output.",
            "Do place `project_id` after `count(*)` in the SELECT list instead of before it, maintaining the same column order as the RIGHT_SQL. Do keep the same table source `Documents`, filter condition `document_type_code = \"BK\"`, and grouping by `project_id` without any changes to these elements. The amended query now correctly matches the RIGHT_SQL's behavior with identical logic and output structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_id, COUNT(*) FROM documents WHERE document_type_code = 'BK' GROUP BY product_id;",
            "SELECT project_id, COUNT(*) FROM Documents WHERE Document_Type_Code = \"BK\" GROUP BY project_id",
            "SELECT project_id, COUNT(*) \nFROM Documents \nWHERE document_type_code = \"BK\" \nGROUP BY project_id",
            "SELECT count(*), project_id FROM Documents WHERE document_type_code = \"BK\" GROUP BY project_id"
        ],
        "rule_sql": []
    },
    "2771": {
        "db_id": "election",
        "question": "Find the parties associated with the delegates from district 1 or 2. Who served as comptrollers of the parties?",
        "ground_truth": "SELECT T2.Comptroller FROM election AS T1 JOIN party AS T2 ON T1.Party  =  T2.Party_ID WHERE T1.District  =  1 OR T1.District  =  2",
        "amends": [
            "Do select `T2.Comptroller` instead of `party_name, comptroller_name`. Do use `FROM election AS T1 JOIN party AS T2` instead of `FROM delegates`. Do apply join condition `ON T1.Party = T2.Party_ID` instead of no join. Do use `WHERE T1.District = 1 OR T1.District = 2` instead of `WHERE district_id IN (1, 2)`. Do remove `GROUP BY party_name` instead of keeping it. Do remove `ORDER BY comptroller_name` instead of keeping it. The amended query now correctly retrieves comptroller names from the party table joined with election data filtered by district, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT party_name, comptroller_name FROM delegates WHERE district_id IN (1, 2) GROUP BY party_name ORDER BY comptroller_name;",
            "SELECT T2.Comptroller FROM election AS T1 JOIN party AS T2 ON T1.Party = T2.Party_ID WHERE T1.District = 1 OR T1.District = 2"
        ],
        "rule_sql": []
    },
    "2827": {
        "db_id": "restaurant_1",
        "question": "What is the gender of the student Linda Smith?",
        "ground_truth": "SELECT Sex FROM Student WHERE Fname = \"Linda\" AND Lname = \"Smith\";",
        "amends": [
            "Do reference table `Student` instead of `students` and use column `Sex` instead of `gender`. Do use column `Fname` instead of `first_name` and `Lname` instead of `last_name` with double quotes around string literals instead of single quotes. The amended query now correctly references the intended table and column names to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gender FROM students WHERE first_name = 'Linda' AND last_name = 'Smith';",
            "SELECT Sex FROM Student WHERE Fname = \"Linda\" AND Lname = \"Smith\";"
        ],
        "rule_sql": []
    },
    "6120": {
        "db_id": "customers_and_addresses",
        "question": "Tell me the number of orders with \"Second time\" as order detail.",
        "ground_truth": "SELECT count(*) FROM customer_orders WHERE order_details  =  \"Second time\"",
        "amends": [
            "Do reference the `customer_orders` table instead of the `orders` table. Do use the `order_details` column instead of the `order_detail` column. Do use double quotes for the string literal instead of single quotes. The amended query now correctly counts records from the customer_orders table where order_details equals \"Second time\", matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE order_detail = 'Second time';",
            "SELECT COUNT(*) FROM Customer_Orders WHERE order_details = \"Second time\";"
        ],
        "rule_sql": []
    },
    "6518": {
        "db_id": "wine_1",
        "question": "Give the name of the wine with the highest score.",
        "ground_truth": "SELECT Name FROM WINE ORDER BY Score LIMIT 1",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the `WINE` table instead of `wines`. Do remove the explicit `ASC` direction in the `ORDER BY` clause instead of keeping it, as ascending order is the default. The amended query now correctly retrieves the wine with the lowest score from the WINE table, matching the intended behavior.",
            "Do remove `DESC` from the `ORDER BY` clause instead of sorting in descending order, which changes the query to return the wine with the lowest score rather than the highest score. The amended query now matches RIGHT_SQL's behavior by ordering scores in ascending order to find the minimum score.",
            "Do remove `DESC` from the `ORDER BY` clause instead of sorting in descending order, which changes the query to return the wine with the lowest score rather than the highest score. The amended query now matches RIGHT_SQL's behavior by ordering scores in ascending order to find the minimum score."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM wines ORDER BY score ASC LIMIT 1;",
            "SELECT Name FROM wine ORDER BY Score DESC LIMIT 1;",
            "SELECT Name FROM wine ORDER BY Score DESC LIMIT 1;",
            "SELECT Name FROM wine ORDER BY Score DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "1289": {
        "db_id": "game_injury",
        "question": "Show the name, average attendance, total attendance for stadiums where no accidents happened.",
        "ground_truth": "SELECT name ,  average_attendance ,  total_attendance FROM stadium EXCEPT SELECT T2.name ,  T2.average_attendance ,  T2.total_attendance FROM game AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.id JOIN injury_accident AS T3 ON T1.id  =  T3.game_id",
        "amends": [
            "Do use `stadium` as the FROM source instead of `stadiums`. Do remove the `AVG(attendance)` and `SUM(attendance)` aggregates and instead select pre-calculated `average_attendance` and `total_attendance` columns. Do remove the `WHERE accidents > 0` filter and instead use an EXCEPT operation to exclude stadiums with injury accidents. Do add joins between `game`, `stadium`, and `injury_accident` tables through `T1.stadium_id = T2.id` and `T1.id = T3.game_id` instead of the single table approach. Do remove the GROUP BY clause entirely since aggregation is no longer needed. The amended query now correctly excludes stadiums with injury accidents by using table relationships instead of a direct filter, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, AVG(attendance) as average_attendance, SUM(attendance) as total_attendance \nFROM stadiums \nWHERE accidents > 0 \nGROUP BY name;",
            "SELECT s.name, s.Average_Attendance, s.Total_Attendance\nFROM stadium s\nWHERE s.id NOT IN (\n    SELECT DISTINCT g.stadium_id\n    FROM game g\n    JOIN injury_accident ia ON g.id = ia.game_id\n)"
        ],
        "rule_sql": []
    },
    "2596": {
        "db_id": "inn_1",
        "question": "What is the average base price of different bed type? List bed type and average base price.",
        "ground_truth": "SELECT bedType ,  avg(basePrice) FROM Rooms GROUP BY bedType;",
        "amends": [
            "Do use column name `bedType` instead of `bed_type` and `basePrice` instead of `price` in the SELECT list and GROUP BY clause. Do remove the alias `average_base_price` instead of keeping it, as the right SQL does not include an explicit alias. Do use table name `Rooms` instead of `rooms` in the FROM clause. The amended query now correctly references the actual schema column names and table name, matching the behavior of the right SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT bed_type, AVG(price) as average_base_price FROM rooms GROUP BY bed_type;",
            "SELECT bedType, AVG(basePrice) FROM Rooms GROUP BY bedType"
        ],
        "rule_sql": []
    },
    "5420": {
        "db_id": "shop_membership",
        "question": "Show all member names and registered branch names sorted by register year.",
        "ground_truth": "SELECT T3.name ,  T2.name FROM membership_register_branch AS T1 JOIN branch AS T2 ON T1.branch_id  =  T2.branch_id JOIN member AS T3 ON T1.member_id  =  T3.member_id ORDER BY T1.register_year",
        "amends": [
            "Do specify explicit table aliases `T3.name` and `T2.name` instead of ambiguous column references `member_name` and `branch_name`. Do join `membership_register_branch AS T1` with `branch AS T2` on `T1.branch_id = T2.branch_id` instead of omitting these tables entirely. Do add a second join to `member AS T3` on `T1.member_id = T3.member_id` instead of querying only a single table. Do reference `T1.register_year` in the ORDER BY instead of the non-existent `registration_year`. The amended query now correctly joins the three required tables and matches the RIGHT_SQL's behavior.",
            "Do remove `Register_Year` from the SELECT list instead of including it. Do use lowercase column names `name` instead of capitalized `Name` for both member and branch names. Do remove the alias `AS member_name` and `AS branch_name` instead of keeping them. Do use lowercase column references in the ORDER BY clause `register_year` instead of capitalized `Register_Year`. The amended query now correctly focuses on retrieving only member and branch names while maintaining proper lowercase column references throughout."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT member_name, branch_name FROM members ORDER BY registration_year;",
            "SELECT T3.Name AS member_name, T2.Name AS branch_name, T1.Register_Year\nFROM membership_register_branch AS T1\nJOIN branch AS T2 ON T1.Branch_ID = T2.Branch_ID\nJOIN member AS T3 ON T1.Member_ID = T3.Member_ID\nORDER BY T1.Register_Year;",
            "SELECT T3.name, T2.name\nFROM membership_register_branch AS T1\nJOIN branch AS T2 ON T1.Branch_ID = T2.Branch_ID\nJOIN member AS T3 ON T1.Member_ID = T3.Member_ID\nORDER BY T1.register_year;"
        ],
        "rule_sql": []
    },
    "5944": {
        "db_id": "cre_Theme_park",
        "question": "What are the details and star ratings of the three hotels with the lowest price ranges?",
        "ground_truth": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3",
        "amends": [
            "Do select specific columns `other_hotel_details` and `star_rating_code` instead of using `*` to select all columns. Do explicitly reference the table as `HOTELS` instead of `hotels` to match the correct case sensitivity. The amended query now correctly retrieves only the specified hotel details and star rating while maintaining the same ordering by price range and limit of 3 results, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM hotels ORDER BY price_range ASC LIMIT 3;",
            "SELECT other_hotel_details, star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3;"
        ],
        "rule_sql": []
    },
    "5913": {
        "db_id": "cre_Theme_park",
        "question": "What are the star rating descriptions of the hotels with price above 10000?",
        "ground_truth": "SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  10000",
        "amends": [
            "Do specify `T2.star_rating_description` instead of `star_rating_description` without table qualification. Do add `HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code = T2.star_rating_code` instead of just `FROM hotels` without the join. Do use `T1.price_range > 10000` instead of `price > 10000` with the correct column name and table alias. The amended query now correctly joins the hotels table with the reference table to retrieve star rating descriptions based on the matching star rating codes and filters by price range instead of an unspecified price column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT star_rating_description FROM hotels WHERE price > 10000;",
            "SELECT T2.star_rating_description \nFROM Hotels AS T1 \nJOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code = T2.star_rating_code \nWHERE T1.price_range > 10000"
        ],
        "rule_sql": []
    },
    "4491": {
        "db_id": "decoration_competition",
        "question": "Show the leader names and locations of colleges.",
        "ground_truth": "SELECT Leader_Name ,  College_Location FROM college",
        "amends": [
            "Do use column names `Leader_Name` and `College_Location` instead of `name` and `city`. Do reference table `college` instead of `colleges`. The amended query now correctly selects the specified columns from the appropriate table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, city FROM colleges;",
            "SELECT Leader_Name, College_Location FROM college;"
        ],
        "rule_sql": []
    },
    "5987": {
        "db_id": "game_1",
        "question": "Which game type has least number of games?",
        "ground_truth": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do reference the `gtype` column instead of `game_type` and omit the `game_count` alias. Do use `Video_games` as the table name instead of `games`. Do remove the explicit column alias in the ORDER BY clause and use `count(*)` directly instead of referencing the aliased `game_count`. Do maintain the GROUP BY on the game type column and LIMIT 1 to get the single most frequent result."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT game_type, COUNT(*) as game_count FROM games GROUP BY game_type ORDER BY game_count DESC LIMIT 1;",
            "SELECT GType FROM Video_Games GROUP BY GType ORDER BY COUNT(*) ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5930": {
        "db_id": "cre_Theme_park",
        "question": "Find the visit date and details of the tourist whose detail is 'Vincent'",
        "ground_truth": "SELECT T2.Visit_Date ,  T2.Visit_Details FROM VISITORS AS T1 JOIN VISITS AS T2 ON T1.Tourist_ID  =  T2.Tourist_ID WHERE T1.Tourist_Details  =  \"Vincent\"",
        "amends": [
            "Do use `T2.Visit_Date` and `T2.Visit_Details` instead of `visit_date` and `details`. Do join `VISITORS AS T1` and `VISITS AS T2` on `T1.Tourist_ID = T2.Tourist_ID` instead of querying only the `tourists` table. Do filter on `T1.Tourist_Details = \"Vincent\"` instead of `details = 'Vincent'`. The amended query now correctly retrieves visit information by joining the appropriate tables and filtering on the tourist details column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT visit_date, details FROM tourists WHERE details = 'Vincent';",
            "SELECT T2.Visit_Date, T2.Visit_Details \nFROM VISITORS AS T1 \nJOIN VISITS AS T2 ON T1.Tourist_ID = T2.Tourist_ID \nWHERE T1.Tourist_Details = 'Vincent'"
        ],
        "rule_sql": []
    },
    "6549": {
        "db_id": "wine_1",
        "question": "What are the wines that have prices higher than 50 and made of Red color grapes?",
        "ground_truth": "SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  \"Red\" AND T2.price  >  50",
        "amends": [
            "Do select `T2.Name` instead of `*` to return only specific columns. Do use `JOIN` between `Grapes AS T1` and `WINE AS T2` instead of querying only `wines` table. Do join on `T1.Grape = T2.Grape` instead of missing the table relationship entirely. Do filter with `T1.Color = \"Red\"` instead of `grape_color = 'Red'` to reference the correct table and column. Do filter with `T2.price > 50` instead of `price > 50` to explicitly specify the table source. The amended query now correctly joins tables and filters based on grape color and wine price to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM wines WHERE price > 50 AND grape_color = 'Red';",
            "SELECT T2.Name \nFROM grapes AS T1 \nJOIN wine AS T2 ON T1.Grape = T2.Grape \nWHERE T1.Color = \"Red\" \nAND T2.Price > 50"
        ],
        "rule_sql": []
    },
    "5183": {
        "db_id": "music_2",
        "question": "What are the names of the songs by the artist whose last name is \"Heilo\"?",
        "ground_truth": "SELECT T3.Title FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId WHERE T2.Lastname  =  \"Heilo\"",
        "amends": [
            "Do select `T3.Title` instead of `s.name` for the column output. Do use `Performance AS T1` joined to `Band AS T2` on `T1.bandmate = T2.id` instead of `songs s JOIN artists a ON s.artist_id = a.id` for the table sources and join conditions. Do then join to `Songs AS T3` on `T3.SongId = T1.SongId` instead of omitting this additional table relationship. Do filter on `T2.Lastname = \"Heilo\"` instead of `a.last_name = 'Heilo'` for the WHERE condition, using double quotes instead of single quotes for the string literal. The amended query now correctly navigates the Performance-Band-Songs relationship to find songs performed by band members with the specified last name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.name FROM songs s JOIN artists a ON s.artist_id = a.id WHERE a.last_name = 'Heilo';",
            "SELECT T3.Title \nFROM Performance AS T1 \nJOIN Band AS T2 ON T1.Bandmate = T2.Id \nJOIN Songs AS T3 ON T3.SongId = T1.SongId \nWHERE T2.Lastname = \"Heilo\""
        ],
        "rule_sql": []
    },
    "1725": {
        "db_id": "riding_club",
        "question": "Show different occupations along with the number of players in each occupation.",
        "ground_truth": "SELECT Occupation ,  COUNT(*) FROM player GROUP BY Occupation",
        "amends": [
            "Do reference the `player` table instead of `players` in the FROM clause. Do group by `Occupation` instead of `player_id` to correctly aggregate counts by occupation rather than individual players. Do capitalize `Occupation` in the SELECT list instead of lowercase `occupation` to match the column name. The amended query now correctly counts players by their occupation rather than producing one row per player_id, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT occupation, COUNT(*) FROM players GROUP BY player_id;",
            "SELECT Occupation, COUNT(*) AS Number_of_Players FROM player GROUP BY Occupation;"
        ],
        "rule_sql": []
    },
    "5862": {
        "db_id": "tracking_share_transactions",
        "question": "What are the purchase details of transactions with amount bigger than 10000?",
        "ground_truth": "SELECT T1.purchase_details FROM PURCHASES AS T1 JOIN TRANSACTIONS AS T2 ON T1.purchase_transaction_id  =  T2.transaction_id WHERE T2.amount_of_transaction  >  10000",
        "amends": [
            "Do select `T1.purchase_details` instead of `*` to return only specific columns. Do add `FROM PURCHASES AS T1 JOIN TRANSACTIONS AS T2` instead of `FROM transactions` to introduce a join between two tables. Do use `ON T1.purchase_transaction_id = T2.transaction_id` instead of no join condition to properly relate the tables. Do change the filter to `T2.amount_of_transaction > 10000` instead of `amount < 10000` to use the correct column name, table alias, and inequality direction. The amended query now correctly joins purchase and transaction data while filtering for larger transaction amounts."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM transactions WHERE amount < 10000;",
            "SELECT T1.purchase_details \nFROM Purchases AS T1 \nJOIN Transactions AS T2 ON T1.purchase_transaction_id = T2.transaction_id \nWHERE T2.amount_of_transaction > 10000"
        ],
        "rule_sql": []
    },
    "4294": {
        "db_id": "club_1",
        "question": "What are the first and last name of the president of the club \"Bootup Baltimore\"?",
        "ground_truth": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t2.position  =  \"President\"",
        "amends": [
            "Do use explicit table aliases `t3.fname` and `t3.lname` instead of ambiguous column names `first_name` and `last_name`. Do join three tables `club AS t1`, `member_of_club AS t2`, and `student AS t3` instead of querying a single `presidents` table. Do use `INNER JOIN` with proper join conditions `t1.clubid = t2.clubid` and `t2.stuid = t3.stuid` instead of no joins. Do add filter `t2.position = \"President\"` to identify club presidents instead of assuming all records are presidents. Do reference the club name column as `t1.clubname` instead of `club_name`. The amended query now correctly identifies student club presidents by joining through the membership relationship with proper filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM presidents WHERE club_name = 'Bootup Baltimore'",
            "SELECT t3.Fname, t3.LName \nFROM Club AS t1 \nINNER JOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID \nINNER JOIN Student AS t3 ON t2.StuID = t3.StuID \nWHERE t1.ClubName = 'Bootup Baltimore' AND t2.Position = 'President'"
        ],
        "rule_sql": []
    },
    "6370": {
        "db_id": "flight_company",
        "question": "What is the velocity of the pilot named 'Thompson'?",
        "ground_truth": "SELECT avg(velocity) FROM flight WHERE pilot  =  'Thompson'",
        "amends": [
            "Do select `avg(velocity)` instead of just `velocity` to calculate the average velocity. Do query from `flight` table instead of `pilots` table to access the correct data source. Do filter on `pilot = 'Thompson'` instead of `name = 'Thompson'` to use the appropriate column name for pilot identification. The amended query now correctly calculates average velocity from flight data for the specified pilot, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT velocity FROM pilots WHERE name = 'Thompson';",
            "SELECT AVG(Velocity) FROM flight WHERE Pilot = 'Thompson';"
        ],
        "rule_sql": []
    },
    "4622": {
        "db_id": "customers_campaigns_ecommerce",
        "question": "Find the types and details for all premises and order by the premise type.",
        "ground_truth": "SELECT premises_type ,  premise_details FROM premises ORDER BY premises_type",
        "amends": [
            "Do select specific columns `premises_type` and `premise_details` instead of using `*` to select all columns. Do use the correct column name `premises_type` instead of `premise_type` in both the SELECT list and ORDER BY clause. Do remove the `DESC` modifier from the ORDER BY clause instead of keeping descending order, making the sort default to ascending. The amended query now correctly selects only the specified columns with proper column naming and ascending sort order, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM premises ORDER BY premise_type DESC;",
            "SELECT premises_type, premise_details FROM Premises ORDER BY premises_type;"
        ],
        "rule_sql": []
    },
    "375": {
        "db_id": "flight_1",
        "question": "Show the name of employees with three lowest salaries.",
        "ground_truth": "SELECT name FROM Employee ORDER BY salary ASC LIMIT 3",
        "amends": [
            "Do reference the table as `Employee` instead of `employees` to match the correct table name. The amended query now matches RIGHT_SQL's behavior with the correct table reference."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM employees ORDER BY salary ASC LIMIT 3;",
            "SELECT name FROM Employee ORDER BY salary ASC LIMIT 3"
        ],
        "rule_sql": []
    },
    "4446": {
        "db_id": "network_2",
        "question": "Find the name of the person who has friends with age above 40 but not under age 30?",
        "ground_truth": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)",
        "amends": [
            "Do add `T1.name` with table alias instead of `name` without qualification. Do add `FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name` instead of `FROM persons` with simple table reference. Do change WHERE filter to `T2.friend IN (SELECT name FROM Person WHERE age > 40)` instead of `age > 40 AND age >= 30`. Do add EXCEPT operation with subquery `SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age < 30)` instead of omitting set operation. Do remove direct age filtering and instead use correlated subqueries through friend relationships. The amended query now correctly finds people whose friends are over 40 but excludes those who also have friends under 30, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM persons WHERE age > 40 AND age >= 30;",
            "SELECT T1.name\nFROM Person AS T1\nJOIN PersonFriend AS T2 ON T1.name = T2.name\nWHERE T2.friend IN (SELECT name FROM Person WHERE age > 40)\nEXCEPT\nSELECT T1.name\nFROM Person AS T1\nJOIN PersonFriend AS T2 ON T1.name = T2.name\nWHERE T2.friend IN (SELECT name FROM Person WHERE age < 30)"
        ],
        "rule_sql": []
    },
    "6142": {
        "db_id": "customers_and_addresses",
        "question": "What are the names of customers who have purchased both products Latte and Americano?",
        "ground_truth": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id JOIN products AS t4 ON t3.product_id  =  t4.product_id WHERE t4.product_details  =  'Latte' INTERSECT SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id JOIN products AS t4 ON t3.product_id  =  t4.product_id WHERE t4.product_details  =  'Americano'",
        "amends": [
            "Do select `customer_name` instead of `name` and use table alias `t1` instead of `c`. Do join `customer_orders` as `t2` instead of `orders` as `o` and use `customer_id` instead of `id` for the join condition. Do reference `product_details` instead of `name` in the WHERE clause and use `INTERSECT` instead of `GROUP BY` with `HAVING COUNT(DISTINCT p.name) = 2`. Do split into two separate queries with different filter conditions for 'Latte' and 'Americano' instead of using OR conditions in a single WHERE clause. The amended query now correctly identifies customers who have ordered both products using INTERSECT semantics instead of the incorrect grouping approach."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.name \nFROM customers c\nJOIN orders o ON c.id = o.customer_id\nJOIN order_items oi ON o.id = oi.order_id\nJOIN products p ON oi.product_id = p.id\nWHERE p.name = 'Latte' OR p.name = 'Americano'\nGROUP BY c.id\nHAVING COUNT(DISTINCT p.name) = 2;",
            "SELECT t1.customer_name\nFROM Customers t1\nJOIN Customer_Orders t2 ON t1.customer_id = t2.customer_id\nJOIN Order_Items oi ON t2.order_id = oi.order_id\nJOIN Products p ON oi.product_id = p.product_id\nWHERE p.product_details = 'Latte'\nINTERSECT\nSELECT t1.customer_name\nFROM Customers t1\nJOIN Customer_Orders t2 ON t1.customer_id = t2.customer_id\nJOIN Order_Items oi ON t2.order_id = oi.order_id\nJOIN Products p ON oi.product_id = p.product_id\nWHERE p.product_details = 'Americano'"
        ],
        "rule_sql": []
    },
    "223": {
        "db_id": "book_2",
        "question": "Show writers who have published a book with price more than 4000000.",
        "ground_truth": "SELECT T1.Writer FROM book AS T1 JOIN publication AS T2 ON T1.Book_ID  =  T2.Book_ID WHERE T2.Price  >  4000000",
        "amends": [
            "Do select `T1.Writer` instead of `*` to return only the writer column. Do use `FROM book AS T1 JOIN publication AS T2` instead of `FROM writers` to properly join the book and publication tables. Do apply the join condition `ON T1.Book_ID = T2.Book_ID` instead of no join condition to correctly relate books to their publications. Do filter with `WHERE T2.Price > 4000000` instead of `WHERE book_price > 4000000` to use the correct price column from the publication table. The amended query now correctly retrieves writers whose books have a publication price exceeding 4,000,000, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM writers WHERE book_price > 4000000;",
            "SELECT T1.Writer FROM book AS T1 JOIN publication AS T2 ON T1.Book_ID = T2.Book_ID WHERE T2.Price > 4000000"
        ],
        "rule_sql": []
    },
    "5136": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "What are the different product names? What is the average product price for each of them?",
        "ground_truth": "SELECT Product_Name ,  avg(Product_Price) FROM PRODUCTS GROUP BY Product_Name",
        "amends": [
            "Do reference `Product_Name` in both the SELECT list and GROUP BY clause instead of using `product_name` in SELECT and `product_id` in GROUP BY. Do use `avg(Product_Price)` instead of `AVG(price)` for the aggregate calculation. The amended query now correctly groups by the same column selected and uses the appropriate column names, matching the intended behavior of calculating average prices by product name rather than by product ID."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name, AVG(price) FROM products GROUP BY product_id;",
            "SELECT Product_Name, AVG(Product_Price) as average_price FROM Products GROUP BY Product_Name;"
        ],
        "rule_sql": []
    },
    "3404": {
        "db_id": "manufacturer",
        "question": "Find the name of the company that produces both furnitures with less than 6 components and furnitures with more than 10 components.",
        "ground_truth": "SELECT t3.name FROM furniture AS t1 JOIN furniture_manufacte AS t2 ON t1.Furniture_ID  =  t2.Furniture_ID JOIN manufacturer AS t3 ON t2.manufacturer_id  =  t3.manufacturer_id WHERE t1.num_of_component  <  6 INTERSECT SELECT t3.name FROM furniture AS t1 JOIN furniture_manufacte AS t2 ON t1.Furniture_ID  =  t2.Furniture_ID JOIN manufacturer AS t3 ON t2.manufacturer_id  =  t3.manufacturer_id WHERE t1.num_of_component  >  10",
        "amends": [
            "Do select `t3.name` from the `manufacturer` table instead of `company_name` from the `furniture` table. Do add joins to `furniture_manufacte` and `manufacturer` tables instead of querying only the `furniture` table. Do use `t1.num_of_component < 6` and `t1.num_of_component > 10` as separate conditions instead of the impossible `components < 6 AND components > 10`. Do structure the query as an `INTERSECT` between two separate result sets instead of a single contradictory filter. Do reference the correct column names `Furniture_ID` and `manufacturer_id` for join conditions instead of unspecified columns. The amended query now correctly identifies manufacturers who produce furniture with both fewer than 6 components and more than 10 components by using set intersection logic.",
            "Do use direct joins from `furniture` to `furniture_manufacte` to `manufacturer` instead of subqueries with DISTINCT. Do reference `t1.num_of_component` directly in WHERE clauses instead of filtering through subquery aliases. Do remove the unnecessary `Manufacturer_ID` selection and DISTINCT operations since INTERSECT inherently eliminates duplicates. Do maintain the same join conditions but with simplified table aliases (`t1` for furniture, `t2` for furniture_manufacte, `t3` for manufacturer) instead of the original complex subquery structure. The amended query now correctly identifies manufacturers producing furniture with both fewer than 6 components and more than 10 components through the INTERSECT operation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT company_name FROM furniture WHERE components < 6 AND components > 10;",
            "SELECT t3.Name\nFROM (\n    SELECT DISTINCT m.Manufacturer_ID, m.Name\n    FROM furniture_manufacte fm\n    JOIN manufacturer m ON fm.Manufacturer_ID = m.Manufacturer_ID\n    JOIN furniture f ON fm.Furniture_ID = f.Furniture_ID\n    WHERE f.Num_of_Component < 6\n) AS t1\nINTERSECT\nSELECT t3.Name\nFROM (\n    SELECT DISTINCT m.Manufacturer_ID, m.Name\n    FROM furniture_manufacte fm\n    JOIN manufacturer m ON fm.Manufacturer_ID = m.Manufacturer_ID\n    JOIN furniture f ON fm.Furniture_ID = f.Furniture_ID\n    WHERE f.Num_of_Component > 10\n) AS t3",
            "SELECT t3.Name\nFROM furniture t1\nJOIN furniture_manufacte t2 ON t1.Furniture_ID = t2.Furniture_ID\nJOIN manufacturer t3 ON t2.Manufacturer_ID = t3.Manufacturer_ID\nWHERE t1.Num_of_Component < 6\n\nINTERSECT\n\nSELECT t3.Name\nFROM furniture t1\nJOIN furniture_manufacte t2 ON t1.Furniture_ID = t2.Furniture_ID\nJOIN manufacturer t3 ON t2.Manufacturer_ID = t3.Manufacturer_ID\nWHERE t1.Num_of_Component > 10"
        ],
        "rule_sql": []
    },
    "538": {
        "db_id": "store_1",
        "question": "What are the top 5 countries by number of invoices and how many do they have?",
        "ground_truth": "SELECT billing_country ,  COUNT(*) FROM invoices GROUP BY billing_country ORDER BY count(*) DESC LIMIT 5;",
        "amends": [
            "Do use `billing_country` instead of `Country` in the SELECT list and GROUP BY clause. Do reference `count(*)` directly in the ORDER BY instead of using the alias `InvoiceCount`. Do remove the alias `as InvoiceCount` from the COUNT(*) expression instead of keeping it. The amended query now correctly references the actual column name and maintains consistent aggregation behavior throughout the query."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT Country, COUNT(*) as InvoiceCount FROM invoices GROUP BY Country ORDER BY InvoiceCount DESC LIMIT 5;",
            "SELECT billing_country, COUNT(*) \nFROM invoices \nGROUP BY billing_country \nORDER BY COUNT(*) DESC \nLIMIT 5"
        ],
        "rule_sql": []
    },
    "4201": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "Show the id of the employee named Ebba.",
        "ground_truth": "SELECT employee_ID FROM Employees WHERE employee_name  =  \"Ebba\"",
        "amends": [
            "Do reference the `employee_ID` column instead of `employee_id` to match the correct case sensitivity. Do reference the `Employees` table instead of `employees` to match the correct table name case. Do use the `employee_name` column filter instead of `name` to reference the correct column for name matching. Do use double quotes `\"Ebba\"` instead of single quotes `'Ebba'` for the string literal format. The amended query now correctly filters by employee name in the appropriate column with proper identifier casing and quotation style."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT employee_id FROM employees WHERE name = 'Ebba';",
            "SELECT Employee_ID FROM Employees WHERE Employee_Name = \"Ebba\";"
        ],
        "rule_sql": []
    },
    "1079": {
        "db_id": "match_season",
        "question": "Return the official native languages of countries who have players from Maryland or Duke colleges.",
        "ground_truth": "SELECT T1.Official_native_language FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.College  =  \"Maryland\" OR T2.College  =  \"Duke\"",
        "amends": [
            "Do select `Official_native_language` instead of `official_language`. Do use table alias `T1` for `country` instead of `countries` as `c`. Do join `match_season` as `T2` instead of `players` as `p`. Do use join condition `T1.Country_id = T2.Country` instead of `c.country_id = p.country_id`. Do remove `DISTINCT` instead of keeping it. Do use double quotes around string literals instead of single quotes. The amended query now correctly retrieves official native languages from the country table for matches involving colleges Maryland or Duke."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT c.official_language \nFROM countries c \nJOIN players p ON c.country_id = p.country_id \nWHERE p.college = 'Maryland' OR p.college = 'Duke';",
            "SELECT T1.Official_native_language FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id = T2.Country WHERE T2.College = \"Maryland\" OR T2.College = \"Duke\""
        ],
        "rule_sql": []
    },
    "19": {
        "db_id": "farm",
        "question": "What is the total horses record for each farm, sorted ascending?",
        "ground_truth": "SELECT Total_Horses FROM farm ORDER BY Total_Horses ASC",
        "amends": [
            "Do select only `Total_Horses` instead of selecting both `farm_name` and `SUM(horses)` with an alias. Do query from `farm` instead of `farms`. Do remove the `GROUP BY farm_name` clause instead of keeping it. Do order by `Total_Horses ASC` instead of `total_horses DESC`. The amended query now matches the RIGHT_SQL's behavior by selecting a single column from a different table without aggregation and with ascending sort order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT farm_name, SUM(horses) as total_horses FROM farms GROUP BY farm_name ORDER BY total_horses DESC;",
            "SELECT Total_Horses FROM farm ORDER BY Total_Horses ASC;"
        ],
        "rule_sql": []
    },
    "2699": {
        "db_id": "storm_record",
        "question": "Count the number of storms in which at least 1 person died.",
        "ground_truth": "SELECT count(*) FROM storm WHERE Number_Deaths  >  0",
        "amends": [
            "Do reference table `storm` instead of `storms` in the FROM clause. Do filter on `Number_Deaths > 0` instead of `deaths = 0` to count records with deaths rather than without deaths. Do use consistent lowercase `count(*)` instead of uppercase `COUNT(*)`. The amended query now correctly counts storm records where deaths occurred rather than where no deaths occurred, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM storms WHERE deaths = 0;",
            "SELECT count(*) FROM storm WHERE Number_Deaths > 0"
        ],
        "rule_sql": []
    },
    "6964": {
        "db_id": "culture_company",
        "question": "show the titles, and authors or editors for all books made after the year 1989.",
        "ground_truth": "SELECT book_title ,  author_or_editor FROM book_club WHERE YEAR  >  1989",
        "amends": [
            "Do select `book_title` and `author_or_editor` instead of `title` and `author`. Do query from `book_club` instead of `books`. The `YEAR > 1989` filter remains unchanged. The amended query now correctly references the book_club table with appropriate column names while maintaining the same filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, author FROM books WHERE year > 1989;",
            "SELECT book_title, author_or_editor FROM book_club WHERE Year > 1989"
        ],
        "rule_sql": []
    },
    "1486": {
        "db_id": "college_2",
        "question": "Find the names and average salaries of all departments whose average salary is greater than 42000.",
        "ground_truth": "SELECT dept_name ,  AVG (salary) FROM instructor GROUP BY dept_name HAVING AVG (salary)  >  42000",
        "amends": [
            "Do use `dept_name` instead of `department_name` for the column name and table alias. Do remove the `average_salary` alias instead of keeping it. Do reference the `instructor` table instead of the `employees` table. Do maintain the `GROUP BY dept_name` and `HAVING AVG(salary) > 42000` logic unchanged. The amended query now correctly calculates average salaries by department from the instructor table without unnecessary aliasing."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT department_name, AVG(salary) as average_salary \nFROM employees \nGROUP BY department_name \nHAVING AVG(salary) > 42000;",
            "SELECT dept_name, AVG(salary) FROM instructor GROUP BY dept_name HAVING AVG(salary) > 42000"
        ],
        "rule_sql": []
    },
    "4462": {
        "db_id": "network_2",
        "question": "Who has a friend that is from new york city?",
        "ground_truth": "SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.city  =  'new york city'",
        "amends": [
            "Do select `T2.name` from the joined table instead of `name` from a single table. Do use `FROM Person AS T1 JOIN PersonFriend AS T2` with an explicit join instead of querying only `users` table. Do apply the join condition `ON T1.name = T2.friend` to establish the relationship between tables instead of missing this connection. Do filter on `T1.city = 'new york city'` (lowercase) instead of `friend_city = 'New York City'` (uppercase) to match the correct column and case sensitivity. The amended query now correctly retrieves friends of people from New York City by properly joining the Person and PersonFriend tables with appropriate filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM users WHERE friend_city = 'New York City';",
            "SELECT T2.name \nFROM Person AS T1 \nJOIN PersonFriend AS T2 ON T1.name = T2.friend \nWHERE T1.city = 'new york city'"
        ],
        "rule_sql": []
    },
    "6315": {
        "db_id": "e_government",
        "question": "What is the payment method code and party phone of the party with the email 'enrico09@example.com'?",
        "ground_truth": "SELECT payment_method_code ,  party_phone FROM parties WHERE party_email  =  \"enrico09@example.com\"",
        "amends": [
            "Do reference `party_email` in the WHERE filter instead of `email` to correctly match the column name in the schema. Do use double quotes for the string literal \"enrico09@example.com\" instead of single quotes for consistency with the right SQL's formatting. The amended query now correctly filters by the party_email column and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT payment_method_code, party_phone FROM parties WHERE email = 'enrico09@example.com';",
            "SELECT payment_method_code, party_phone FROM Parties WHERE party_email = \"enrico09@example.com\""
        ],
        "rule_sql": []
    },
    "6399": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "Show the number of documents.",
        "ground_truth": "SELECT count(*) FROM Documents",
        "amends": [
            "Do use lowercase `count(*)` instead of uppercase `COUNT(*)` to match the function casing. Do reference table `Documents` instead of `documents` to use the correct table name case. The amended query now matches RIGHT_SQL's behavior with proper function casing and table name reference."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM documents WHERE id = 1;",
            "SELECT count(*) FROM Documents;"
        ],
        "rule_sql": []
    },
    "743": {
        "db_id": "customers_card_transactions",
        "question": "What is the transaction type that has processed the greatest total amount in transactions?",
        "ground_truth": "SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT 1",
        "amends": [
            "Do reference table `Financial_transactions` instead of `transactions` in the FROM clause. Do select only `transaction_type` instead of including `SUM(amount) as total_amount` in the SELECT list. Do use `sum(transaction_amount)` instead of `COUNT(*)` in the ORDER BY clause for sorting by total transaction amount rather than transaction count. Do remove the unnecessary aggregation column from SELECT while maintaining the GROUP BY on `transaction_type`. The amended query now correctly identifies the transaction type with the highest total transaction amount instead of the most frequent transaction type."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT transaction_type, SUM(amount) as total_amount FROM transactions GROUP BY transaction_type ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT transaction_type FROM Financial_Transactions GROUP BY transaction_type ORDER BY SUM(transaction_amount) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1760": {
        "db_id": "gymnast",
        "question": "What are the hometowns of gymnasts and the corresponding number of gymnasts?",
        "ground_truth": "SELECT T2.Hometown ,  COUNT(*) FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID GROUP BY T2.Hometown",
        "amends": [
            "Do join `people AS T2` on `T1.Gymnast_ID = T2.People_ID` instead of querying only the `gymnasts` table. Do select `T2.Hometown` instead of just `hometown` to specify the source table. Do use explicit table aliases `T1` and `T2` instead of no aliases. Do add the required join condition `T1.Gymnast_ID = T2.People_ID` instead of omitting it. Do reference the grouped column as `T2.Hometown` in GROUP BY instead of just `hometown` to maintain consistency with the SELECT clause. The amended query now correctly retrieves hometown information from the people table by joining with gymnast data."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT hometown, COUNT(*) FROM gymnasts GROUP BY hometown;",
            "SELECT T2.Hometown, COUNT(*) AS Number_of_Gymnasts\nFROM gymnast AS T1\nJOIN people AS T2 ON T1.Gymnast_ID = T2.People_ID\nGROUP BY T2.Hometown"
        ],
        "rule_sql": []
    },
    "514": {
        "db_id": "allergy_1",
        "question": "Which allergy is the most common?",
        "ground_truth": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference table `Has_allergy` instead of `patients` in the FROM clause. Do use `Allergy` column instead of `allergy` in both SELECT and GROUP BY clauses. Do remove the explicit column alias `count` and instead use the aggregate function `count(*)` directly in the ORDER BY clause instead of referencing the aliased column. The amended query now correctly selects from the appropriate table, uses the proper column name with correct casing, and orders by the actual count aggregation rather than an aliased column reference, matching the RIGHT_SQL's behavior.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, and do remove the explicit GROUP BY clause reference to `Allergy` instead of keeping it since the aggregation is implied by the ORDER BY clause. Do maintain the `ORDER BY count(*) DESC` and `LIMIT 1` to identify the most common allergy instead of altering the ranking logic. The amended query now matches RIGHT_SQL's behavior by returning only the allergy name with the highest frequency count."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT allergy, COUNT(*) as count FROM patients GROUP BY allergy ORDER BY count DESC LIMIT 1;",
            "SELECT Allergy, COUNT(*) FROM Has_Allergy GROUP BY Allergy ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT Allergy FROM Has_Allergy GROUP BY Allergy ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "5233": {
        "db_id": "music_2",
        "question": "What are the names of the songs without a lead vocal?",
        "ground_truth": "SELECT DISTINCT title FROM vocals AS t1 JOIN songs AS t2 ON t1.songid  =  t2.songid EXCEPT SELECT t2.title FROM vocals AS t1 JOIN songs AS t2 ON t1.songid  =  t2.songid WHERE TYPE  =  \"lead\"",
        "amends": [
            "Do use `SELECT DISTINCT title` instead of `SELECT name` to return unique song titles rather than names. Do add `FROM vocals AS t1 JOIN songs AS t2 ON t1.songid = t2.songid` instead of `FROM songs` to join the vocals and songs tables on the correct relationship. Do remove the `WHERE lead_vocal IS NULL` filter instead of keeping it, and instead use `EXCEPT` to exclude songs that have lead vocals. Do add the subquery `SELECT t2.title FROM vocals AS t1 JOIN songs AS t2 ON t1.songid = t2.songid WHERE TYPE = \"lead\"` to specifically identify songs with lead vocals for exclusion. The amended query now correctly identifies songs without any lead vocal entries by using set operations instead of null checking on a non-existent column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM songs WHERE lead_vocal IS NULL;",
            "SELECT DISTINCT Title FROM Songs\nEXCEPT\nSELECT t2.Title FROM Vocals AS t1 JOIN Songs AS t2 ON t1.SongId = t2.SongId WHERE Type = 'lead'"
        ],
        "rule_sql": []
    },
    "1749": {
        "db_id": "gymnast",
        "question": "Return the names of gymnasts who did not grow up in Santo Domingo.",
        "ground_truth": "SELECT T2.Name FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID WHERE T2.Hometown != \"Santo Domingo\"",
        "amends": [
            "Do select `T2.Name` from the `people` table instead of `name` from the `gymnasts` table. Do join `gymnast AS T1` with `people AS T2` on `T1.Gymnast_ID = T2.People_ID` instead of querying a single table. Do filter with `T2.Hometown != \"Santo Domingo\"` instead of `hometown = 'Santo Domingo'` to exclude rather than include Santo Domingo residents. The amended query now correctly retrieves gymnast names from the people table while excluding those from Santo Domingo, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM gymnasts WHERE hometown = 'Santo Domingo';",
            "SELECT T2.Name FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID = T2.People_ID WHERE T2.Hometown != 'Santo Domingo'"
        ],
        "rule_sql": []
    },
    "1775": {
        "db_id": "gymnast",
        "question": "What are the ages of the gymnasts, ordered descending by their total points?",
        "ground_truth": "SELECT T2.Age FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID ORDER BY T1.Total_Points DESC",
        "amends": [
            "Do select `T2.Age` from the `people` table instead of `age` from the `gymnasts` table. Do join `gymnast AS T1` with `people AS T2` on `T1.Gymnast_ID = T2.People_ID` instead of querying a single table. Do order by `T1.Total_Points DESC` instead of `age DESC`. The amended query now correctly retrieves age information from the people table while ordering by the gymnasts' performance metrics."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT age FROM gymnasts ORDER BY age DESC;",
            "SELECT T2.Age \nFROM gymnast AS T1 \nJOIN people AS T2 ON T1.Gymnast_ID = T2.People_ID \nORDER BY T1.Total_Points DESC"
        ],
        "rule_sql": []
    },
    "4983": {
        "db_id": "soccer_2",
        "question": "What are the different names of the colleges involved in the tryout in alphabetical order?",
        "ground_truth": "SELECT DISTINCT cName FROM tryout ORDER BY cName",
        "amends": [
            "Do select `cName` instead of `name` and use `DISTINCT` instead of omitting it. Do query from `tryout` instead of `colleges`. Do order by `cName` instead of `name` and use ascending order instead of `DESC`. The amended query now matches the intended behavior of selecting distinct college names in ascending order from the tryout table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM colleges ORDER BY name DESC;",
            "SELECT DISTINCT cName FROM Tryout ORDER BY cName ASC;"
        ],
        "rule_sql": []
    },
    "6685": {
        "db_id": "driving_school",
        "question": "What is the country in which the customer Carole Bernhard lived?",
        "ground_truth": "SELECT T2.country FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id WHERE T1.first_name = \"Carole\" AND T1.last_name = \"Bernhard\"",
        "amends": [
            "Do select `T2.country` from the Addresses table instead of `country` from the customers table. Do add a `JOIN` with `Addresses AS T2` on `T1.customer_address_id = T2.address_id` instead of querying only the customers table. Do reference `T1.first_name` and `T1.last_name` with table aliases instead of unqualified column names. Do use double quotes for string literals instead of single quotes. The amended query now correctly joins customer and address data to retrieve the country from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM customers WHERE first_name = 'Carole' AND last_name = 'Bernhard';",
            "SELECT T2.country \nFROM Customers AS T1\nJOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id\nWHERE T1.first_name = \"Carole\" AND T1.last_name = \"Bernhard\""
        ],
        "rule_sql": []
    },
    "6608": {
        "db_id": "train_station",
        "question": "Show the location with most number of train stations.",
        "ground_truth": "SELECT LOCATION FROM station GROUP BY LOCATION ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `LOCATION` instead of both `location` and `COUNT(*) as station_count`. Do use table name `station` instead of `train_stations`. Do order by `count(*) DESC` instead of `station_count ASC`. Do remove the explicit column alias `station_count` instead of keeping it. The amended query now correctly returns the location with the highest station count by ordering in descending order rather than ascending."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location, COUNT(*) as station_count FROM train_stations GROUP BY location ORDER BY station_count ASC LIMIT 1;",
            "SELECT Location FROM station GROUP BY Location ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2908": {
        "db_id": "icfp_1",
        "question": "Find the first names of all the authors who have written a paper with title containing the word \"Functional\".",
        "ground_truth": "SELECT t1.fname FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid WHERE t3.title LIKE \"%Functional%\"",
        "amends": [
            "Do select `t1.fname` instead of `first_name` to use the correct column name from the aliased table. Do add `authorship AS t2` and `papers AS t3` tables instead of omitting them to properly join through the authorship relationship. Do use `JOIN` with `t1.authid = t2.authid` and `t2.paperid = t3.paperid` instead of querying only the authors table to establish the correct table relationships. Do filter on `t3.title LIKE \"%Functional%\"` instead of `paper_title` to reference the correct table and column containing paper titles. The amended query now correctly joins through the authorship bridge table to find authors who have written papers with \"Functional\" in the title, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM authors WHERE paper_title LIKE '%Functional%';",
            "SELECT t1.fname \nFROM Authors AS t1\nJOIN Authorship AS t2 ON t1.authID = t2.authID\nJOIN Papers AS t3 ON t2.paperID = t3.paperID\nWHERE t3.title LIKE '%Functional%'"
        ],
        "rule_sql": []
    },
    "4041": {
        "db_id": "student_1",
        "question": "Which grade is studying in room 105?",
        "ground_truth": "SELECT DISTINCT grade FROM list WHERE classroom  =  105",
        "amends": [
            "Do select from `list` table instead of `students` table. Do use `classroom` column instead of `room` column for filtering. Do add `DISTINCT` to return unique grades instead of potentially duplicate values. The amended query now correctly retrieves distinct grade values from the appropriate classroom in the list table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT grade FROM students WHERE room = 105;",
            "SELECT DISTINCT Grade FROM list WHERE Classroom = 105;"
        ],
        "rule_sql": []
    },
    "3167": {
        "db_id": "station_weather",
        "question": "Find names and times of trains that run through stations for the local authority Chiltern.",
        "ground_truth": "SELECT t3.name ,  t3.time FROM station AS t1 JOIN route AS t2 ON t1.id  =  t2.station_id JOIN train AS t3 ON t2.train_id  =  t3.id WHERE t1.local_authority  =  \"Chiltern\"",
        "amends": [
            "Do use table aliases `t1`, `t2`, and `t3` for `station`, `route`, and `train` respectively instead of `t` and `s` for `trains` and `stations`. Do join through an intermediate `route` table using `t1.id = t2.station_id` and `t2.train_id = t3.id` instead of directly joining `trains` to `stations` on `t.station_id = s.id`. Do reference columns from the correct table `t3.name` and `t3.time` instead of `t.name` and `t.time`. Do use double quotes around string literal \"Chiltern\" instead of single quotes. The amended query now correctly navigates the relational schema through the route junction table to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT t.name, t.time FROM trains t JOIN stations s ON t.station_id = s.id WHERE s.local_authority = 'Chiltern'",
            "SELECT t3.name, t3.time FROM station t1 JOIN route t2 ON t1.id = t2.station_id JOIN train t3 ON t2.train_id = t3.id WHERE t1.local_authority = \"Chiltern\";"
        ],
        "rule_sql": []
    },
    "6067": {
        "db_id": "customers_and_addresses",
        "question": "What are the names of customers using the most popular payment method?",
        "ground_truth": "SELECT customer_name FROM customers WHERE payment_method  =  (SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1)",
        "amends": [
            "Do select `customer_name` instead of `c.name` and remove the joins to `orders` and `payments` tables instead of keeping them. Do use a WHERE filter with a subquery condition instead of GROUP BY and ORDER BY with COUNT. Do change the subquery to select `payment_method` from `customers` instead of from joined tables and group by `payment_method` instead of `customer_id`. Do remove the explicit table aliases and JOIN syntax instead of maintaining them. The amended query now correctly identifies customers using the most common payment method by analyzing payment_method distribution directly from the customers table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.name \nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nJOIN payments p ON o.order_id = p.order_id\nGROUP BY c.customer_id\nORDER BY COUNT(p.payment_method) DESC\nLIMIT 1;",
            "SELECT customer_name FROM Customers WHERE payment_method = (SELECT payment_method FROM Customers GROUP BY payment_method ORDER BY COUNT(*) DESC LIMIT 1)"
        ],
        "rule_sql": []
    },
    "2071": {
        "db_id": "party_people",
        "question": "Show party names and the number of events for each party.",
        "ground_truth": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id",
        "amends": [
            "Do join `party_events AS T1` with `party AS T2` on `T1.party_id = T2.party_id` instead of querying only the `events` table. Do select `T2.party_name` instead of `party_name` to ensure the correct party name is retrieved from the party table. Do group by `T1.party_id` instead of `party_name` to maintain proper aggregation while allowing the party name to be displayed correctly. The amended query now correctly joins the necessary tables and ensures accurate party name display with proper grouping."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT party_name, COUNT(*) FROM events GROUP BY party_name;",
            "SELECT T2.party_name, COUNT(T1.Event_ID) AS number_of_events FROM party_events AS T1 JOIN party AS T2 ON T1.Party_ID = T2.Party_ID GROUP BY T1.Party_ID"
        ],
        "rule_sql": []
    },
    "4553": {
        "db_id": "company_office",
        "question": "What are the maximum and minimum sales of the companies whose industries are not \"Banking\".",
        "ground_truth": "SELECT max(Sales_billion) ,  min(Sales_billion) FROM Companies WHERE Industry != \"Banking\"",
        "amends": [
            "Do use column name `Sales_billion` instead of `sales` in both aggregate functions. Do change the WHERE condition to `Industry != \"Banking\"` instead of `industry = 'Banking'` to exclude rather than include banking records. Do reference table `Companies` instead of `companies` with proper case sensitivity. The amended query now correctly calculates maximum and minimum sales values for non-banking industries, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(sales), MIN(sales) FROM companies WHERE industry = 'Banking';",
            "SELECT MAX(Sales_billion) AS max_sales, MIN(Sales_billion) AS min_sales FROM Companies WHERE Industry != \"Banking\";"
        ],
        "rule_sql": []
    },
    "6866": {
        "db_id": "flight_4",
        "question": "What are the cities with exactly two airports?",
        "ground_truth": "SELECT city FROM airports GROUP BY city HAVING count(*)  =  2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM airports GROUP BY city HAVING COUNT(*) = 2;"
        ],
        "rule_sql": []
    },
    "1461": {
        "db_id": "college_2",
        "question": "What are the names of students who have taken Statistics courses?",
        "ground_truth": "SELECT T3.name FROM course AS T1 JOIN takes AS T2 ON T1.course_id  =  T2.course_id JOIN student AS T3 ON T2.id  =  T3.id WHERE T1.dept_name  =  'Statistics'",
        "amends": [
            "Do select `T3.name` instead of `student_name` and use table aliases throughout. Do join three tables (`course AS T1`, `takes AS T2`, `student AS T3`) instead of querying a single `students` table. Do use `INNER JOIN` on `T1.course_id = T2.course_id` and `T2.id = T3.id` instead of no joins. Do filter on `T1.dept_name = 'Statistics'` instead of `course_name = 'Statistics'` to correctly identify the department rather than course name. The amended query now properly joins the course, takes, and student tables to find students enrolled in Statistics department courses, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_name FROM students WHERE course_name = 'Statistics';",
            "SELECT T3.name\nFROM course AS T1\nINNER JOIN takes AS T2 ON T1.course_id = T2.course_id\nINNER JOIN student AS T3 ON T2.ID = T3.ID\nWHERE T1.dept_name = 'Statistics'"
        ],
        "rule_sql": []
    },
    "4014": {
        "db_id": "ship_mission",
        "question": "List the nations that have more than two ships.",
        "ground_truth": "SELECT Nationality FROM ship GROUP BY Nationality HAVING COUNT(*)  >  2",
        "amends": [
            "Do reference the `Nationality` column instead of `nation` and use the `ship` table instead of `ships` while maintaining the same `GROUP BY` clause and `HAVING COUNT(*) > 2` condition, with all other elements remaining unchanged, resulting in a query that now correctly matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT nation FROM ships GROUP BY nation HAVING COUNT(*) > 2",
            "SELECT Nationality FROM ship GROUP BY Nationality HAVING COUNT(*) > 2"
        ],
        "rule_sql": []
    },
    "697": {
        "db_id": "customers_card_transactions",
        "question": "Show the number of customer cards.",
        "ground_truth": "SELECT count(*) FROM Customers_cards",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers;"
        ],
        "rule_sql": []
    },
    "1957": {
        "db_id": "cinema",
        "question": "In which locations are there more than one movie theater with capacity above 300?",
        "ground_truth": "SELECT LOCATION FROM cinema WHERE capacity  >  300 GROUP BY LOCATION HAVING count(*)  >  1",
        "amends": [
            "Do reference table `cinema` instead of `movie_theaters` in the FROM clause. Do remove the `COUNT(*)` column from the SELECT list instead of including it, keeping only the `LOCATION` field. Do maintain the `capacity > 300` WHERE filter and `GROUP BY LOCATION` with `HAVING count(*) > 1` conditions without changes. The amended query now matches RIGHT_SQL's behavior by selecting only location names from the correct table while preserving the grouping and filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location, COUNT(*) FROM movie_theaters WHERE capacity > 300 GROUP BY location HAVING COUNT(*) > 1;",
            "SELECT Location FROM cinema WHERE Capacity > 300 GROUP BY Location HAVING COUNT(*) > 1"
        ],
        "rule_sql": []
    },
    "4146": {
        "db_id": "film_rank",
        "question": "List the title of films that do not have any market estimation.",
        "ground_truth": "SELECT Title FROM film WHERE Film_ID NOT IN (SELECT Film_ID FROM film_market_estimation)",
        "amends": [
            "Do reference the `Title` column instead of `title` and use the `film` table instead of `films`. Do remove the `WHERE market_estimation IS NULL` filter and instead use a `NOT IN` subquery with `Film_ID NOT IN (SELECT Film_ID FROM film_market_estimation)` to identify films missing market estimation records. Do add the `film_market_estimation` table as a subquery source instead of omitting it. The amended query now correctly identifies films without market estimation data by checking for missing entries in the related table rather than relying on a potentially non-existent NULL column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM films WHERE market_estimation IS NULL;",
            "SELECT Title FROM film WHERE Film_ID NOT IN (SELECT Film_ID FROM film_market_estimation)"
        ],
        "rule_sql": []
    },
    "4713": {
        "db_id": "department_store",
        "question": "Find the number of different product types.",
        "ground_truth": "SELECT count(DISTINCT product_type_code) FROM products",
        "amends": [
            "Do `count(DISTINCT product_type_code)` instead of `COUNT(*)` to count distinct product type codes rather than all rows. The amended query now correctly counts unique product types instead of total products, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM products;",
            "SELECT COUNT(DISTINCT product_type_code) FROM Products;"
        ],
        "rule_sql": []
    },
    "4881": {
        "db_id": "school_player",
        "question": "Which schools have more than 1 player? Give me the school locations.",
        "ground_truth": "SELECT T2.Location FROM player AS T1 JOIN school AS T2 ON T1.School_ID  =  T2.School_ID GROUP BY T1.School_ID HAVING COUNT(*)  >  1",
        "amends": [
            "Do select `T2.Location` from the `school` table instead of `school_location` from the `players` table. Do join `school AS T2` to `player AS T1` using `T1.School_ID = T2.School_ID` instead of querying only the `players` table. Do group by `T1.School_ID` instead of `school_location` while keeping the same `HAVING COUNT(*) > 1` condition to find schools with multiple players. The amended query now correctly joins the player and school tables to retrieve the actual school location from the school table rather than relying on a potentially incorrect school_location field in the players table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT school_location FROM players GROUP BY school_location HAVING COUNT(*) > 1",
            "SELECT T2.Location \nFROM player AS T1 \nJOIN school AS T2 ON T1.School_ID = T2.School_ID \nGROUP BY T1.School_ID \nHAVING COUNT(*) > 1"
        ],
        "rule_sql": []
    },
    "5629": {
        "db_id": "swimming",
        "question": "Find the names of stadiums that the most swimmers have been to.",
        "ground_truth": "SELECT t3.name FROM record AS t1 JOIN event AS t2 ON t1.event_id  =  t2.id JOIN stadium AS t3 ON t3.id  =  t2.stadium_id GROUP BY t2.stadium_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `t3.name` instead of `stadium_name` and `swimmer_count`. Do use `FROM record AS t1 JOIN event AS t2 ON t1.event_id = t2.id JOIN stadium AS t3 ON t3.id = t2.stadium_id` instead of `FROM stadium_visits`. Do group by `t2.stadium_id` instead of `stadium_name`. Do order by `count(*) DESC` instead of `swimmer_count ASC`. Do maintain `LIMIT 1` but with the opposite sort direction. The amended query now correctly identifies the stadium with the most events by joining through the proper relationship chain between records, events, and stadiums."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT stadium_name, COUNT(swimmer_id) as swimmer_count\nFROM stadium_visits\nGROUP BY stadium_name\nORDER BY swimmer_count ASC\nLIMIT 1;",
            "SELECT t3.name\nFROM record AS t1\nJOIN event AS t2 ON t1.Event_ID = t2.ID\nJOIN stadium AS t3 ON t3.ID = t2.Stadium_ID\nGROUP BY t2.Stadium_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "4126": {
        "db_id": "film_rank",
        "question": "List all countries of markets in ascending alphabetical order.",
        "ground_truth": "SELECT Country FROM market ORDER BY Country ASC",
        "amends": [
            "Do select only `Country` instead of all columns with `*`. Do reference table `market` instead of `markets`. Do order by `Country ASC` instead of `country DESC`, changing both the column case and sort direction. The amended query now correctly selects only the Country column from the market table in ascending order, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM markets ORDER BY country DESC;",
            "SELECT Country FROM market ORDER BY Country ASC;"
        ],
        "rule_sql": []
    },
    "5788": {
        "db_id": "customer_complaints",
        "question": "Find the name and category of the most expensive product.",
        "ground_truth": "SELECT product_name ,  product_category_code FROM products ORDER BY product_price DESC LIMIT 1",
        "amends": [
            "Do select `product_name` and `product_category_code` instead of `name` and `category`. Do order by `product_price DESC` instead of `price ASC`. The amended query now correctly retrieves the highest-priced product's details with proper column names and sorting direction."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, category FROM products ORDER BY price ASC LIMIT 1;",
            "SELECT product_name, product_category_code FROM Products ORDER BY product_price DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6044": {
        "db_id": "game_1",
        "question": "What is the name of the game that has been played the most?",
        "ground_truth": "SELECT gname FROM Plays_games AS T1 JOIN Video_games AS T2 ON T1.gameid  =  T2.gameid GROUP BY T1.gameid ORDER BY sum(hours_played) DESC LIMIT 1",
        "amends": [
            "Do select `gname` from the `Video_games` table instead of `name` from the `games` table. Do add a `JOIN` between `Plays_games` and `Video_games` on `T1.gameid = T2.gameid` instead of querying a single table. Do add `GROUP BY T1.gameid` to aggregate by game instead of omitting grouping. Do order by `sum(hours_played)` instead of `plays` to use the correct aggregated metric. Do keep the `DESC` ordering and `LIMIT 1` to maintain the top result selection. The amended query now correctly joins the play data with game names, aggregates total hours played per game, and returns the game with the highest total play time, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM games ORDER BY plays DESC LIMIT 1;",
            "SELECT vg.GName\nFROM Video_Games vg\nJOIN Plays_Games pg ON vg.GameID = pg.GameID\nGROUP BY vg.GameID\nORDER BY SUM(pg.Hours_Played) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "4431": {
        "db_id": "network_2",
        "question": "What is the name of all the people who are older than at least one engineer? Order them by age.",
        "ground_truth": "SELECT name FROM Person WHERE age  >  (SELECT min(age) FROM person WHERE job  =  'engineer') ORDER BY age",
        "amends": [
            "Do reference table `Person` instead of `people` in both the main query and subquery. Do use lowercase `min(age)` instead of uppercase `MIN(age)` in the aggregate function. Do reference table `person` instead of `people` in the subquery's FROM clause. The amended query now correctly references the Person table consistently and uses proper lowercase function syntax, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM people WHERE age > (SELECT MIN(age) FROM people WHERE job = 'engineer') ORDER BY age;",
            "SELECT name FROM Person WHERE age > (SELECT min(age) FROM Person WHERE job = 'engineer') ORDER BY age;"
        ],
        "rule_sql": []
    },
    "4799": {
        "db_id": "aircraft",
        "question": "List the description of all aircrafts.",
        "ground_truth": "SELECT Description FROM aircraft",
        "amends": [
            "Do select only the `Description` column instead of selecting all columns with `*`. Do reference the table as `aircraft` instead of `aircrafts`. The amended query now correctly retrieves only the description column from the aircraft table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM aircrafts;",
            "SELECT Description FROM aircraft;"
        ],
        "rule_sql": []
    },
    "3962": {
        "db_id": "hospital_1",
        "question": "List the names of departments where some physicians are primarily affiliated with.",
        "ground_truth": "SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  1",
        "amends": [
            "Do reference `department` as `T2` instead of `departments` as `d` and use `affiliated_with` as `T1` instead of `physicians` as `p`. Do join on `T1.department = T2.departmentid` instead of `d.department_id = p.physician_id` to correctly link the affiliation relationship. Do filter on `PrimaryAffiliation = 1` instead of `p.primary_affiliation = 'yes'` to use the proper boolean numeric representation. Do select `T2.name` instead of `d.name` while maintaining the `DISTINCT` clause to eliminate duplicates. The amended query now correctly identifies departments with primary affiliations using the proper table relationships and filter conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT d.name FROM departments d JOIN physicians p ON d.department_id = p.physician_id WHERE p.primary_affiliation = 'yes'",
            "SELECT DISTINCT T2.Name \nFROM Affiliated_With AS T1 \nJOIN Department AS T2 ON T1.Department = T2.DepartmentID \nWHERE T1.PrimaryAffiliation = 1"
        ],
        "rule_sql": []
    },
    "4228": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "What is the location code with the most documents?",
        "ground_truth": "SELECT location_code FROM Document_locations GROUP BY location_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do query the `Document_locations` table instead of the `documents` table. Do use the correct table name `Document_locations` instead of `documents` to ensure the location codes are sourced from the appropriate table containing location information. The amended query now correctly retrieves location codes from the Document_locations table and matches the RIGHT_SQL's behavior.",
            "Do select only `location_code` instead of including `COUNT(Document_ID) AS document_count` in the SELECT list. Do use `count(*)` in the ORDER BY clause instead of referencing the alias `document_count`. Do maintain the same FROM source `Document_locations` and GROUP BY `location_code` without changes. Do preserve the ORDER BY DESC and LIMIT 1 structure but with the corrected aggregate reference. The amended query now correctly returns the location_code with the highest document count by ordering based on the actual count(*) value rather than an aliased column reference."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location_code FROM documents GROUP BY location_code ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT Location_Code, COUNT(Document_ID) AS document_count FROM Document_Locations GROUP BY Location_Code ORDER BY document_count DESC LIMIT 1;",
            "SELECT location_code FROM Document_locations GROUP BY location_code ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "64": {
        "db_id": "student_assessment",
        "question": "List the id of students who attended some courses?",
        "ground_truth": "SELECT student_id FROM student_course_attendance",
        "amends": [
            "Do select `student_id` from `student_course_attendance` table instead of from `students` table. Do remove the `WHERE course_id IS NOT NULL` filter instead of keeping it, as the correct table already contains the relevant attendance records without needing this condition. The amended query now correctly retrieves student IDs from the attendance tracking table rather than the general student information table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_id FROM students WHERE course_id IS NOT NULL",
            "SELECT DISTINCT student_id FROM Student_Course_Attendance"
        ],
        "rule_sql": []
    },
    "4479": {
        "db_id": "network_2",
        "question": "What is the name of the person who has the oldest average age for their friends, and what is that average age?",
        "ground_truth": "SELECT T2.name ,  avg(T1.age) FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend GROUP BY T2.name ORDER BY avg(T1.age) DESC LIMIT 1",
        "amends": [
            "Do use `Person AS T1` and `PersonFriend AS T2` as table sources instead of `persons p` and `friends f`. Do join on `T1.name = T2.friend` instead of `p.id = f.person_id`. Do select `T2.name` and `avg(T1.age)` without an alias instead of `p.name` and `AVG(f.age) as avg_age`. Do group by `T2.name` instead of `p.id`. Do order by `avg(T1.age)` directly instead of the alias `avg_age`. The amended query now correctly joins person data with friend relationships using name matching instead of ID matching and properly groups by friend names to calculate average ages."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.name, AVG(f.age) as avg_age\nFROM persons p\nJOIN friends f ON p.id = f.person_id\nGROUP BY p.id\nORDER BY avg_age DESC\nLIMIT 1;",
            "SELECT T2.name, AVG(T1.age) \nFROM Person AS T1 \nJOIN PersonFriend AS T2 ON T1.name = T2.friend \nGROUP BY T2.name \nORDER BY AVG(T1.age) DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "3378": {
        "db_id": "sports_competition",
        "question": "How many different position for players are listed?",
        "ground_truth": "SELECT count(DISTINCT POSITION) FROM player",
        "amends": [
            "Do use `count(DISTINCT POSITION)` instead of `COUNT(*)` to count distinct positions rather than all rows. Do reference the correct table name `player` instead of `players` to ensure the query targets the proper data source. The amended query now correctly counts unique player positions rather than total player records, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players;",
            "SELECT COUNT(DISTINCT Position) FROM player;"
        ],
        "rule_sql": []
    },
    "6519": {
        "db_id": "wine_1",
        "question": "Which winery is the wine that has the highest score from?",
        "ground_truth": "SELECT Winery FROM WINE ORDER BY SCORE LIMIT 1",
        "amends": [
            "Do reference table `WINE` instead of `wines` and use column `Winery` instead of `winery` to match the correct schema. Do use `ORDER BY SCORE` without specifying `ASC` direction instead of `ORDER BY score ASC` since ascending order is the default. The amended query now correctly retrieves the winery with the lowest score from the WINE table, matching the RIGHT_SQL's behavior.",
            "Do `ORDER BY SCORE` without `DESC` instead of `ORDER BY Score DESC` to sort in ascending order rather than descending order. The amended query now matches RIGHT_SQL's behavior by returning the winery with the lowest score instead of the highest score."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT winery FROM wines ORDER BY score ASC LIMIT 1;",
            "SELECT Winery FROM WINE ORDER BY Score DESC LIMIT 1;",
            "SELECT Winery FROM wine ORDER BY Score LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2543": {
        "db_id": "county_public_safety",
        "question": "Return the names of cities, ordered alphabetically.",
        "ground_truth": "SELECT Name FROM city ORDER BY Name ASC",
        "amends": [
            "Do select `Name` from the `city` table instead of `city` from the `cities` table. Do use `ASC` ordering instead of `DESC` ordering. The amended query now correctly retrieves city names in ascending order from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM cities ORDER BY city DESC;",
            "SELECT Name FROM city ORDER BY Name ASC;"
        ],
        "rule_sql": []
    },
    "4251": {
        "db_id": "club_1",
        "question": "Count the total number of clubs.",
        "ground_truth": "SELECT count(*) FROM club",
        "amends": [
            "Do query the `club` table instead of the `players` table. Do remove the `WHERE club IS NOT NULL` filter instead of keeping it. The amended query now correctly counts all records in the club table without unnecessary filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE club IS NOT NULL;",
            "SELECT COUNT(*) FROM Club;"
        ],
        "rule_sql": []
    },
    "4769": {
        "db_id": "department_store",
        "question": "What are id and name of the products whose price is lower than 600 or higher than 900?",
        "ground_truth": "SELECT product_id ,  product_name FROM products WHERE product_price  <  600 OR product_price  >  900",
        "amends": [
            "Do reference `product_id` and `product_name` instead of `id` and `name` in the SELECT list. Do use `product_price` instead of `price` in the WHERE clause. Do use `OR` instead of `AND` between the price conditions to select products where the price is either below 600 or above 900, instead of incorrectly requiring both conditions to be true simultaneously. The amended query now correctly matches the intended logic of selecting products outside the 600-900 price range."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, name FROM products WHERE price < 600 AND price > 900;",
            "SELECT product_id, product_name FROM Products WHERE product_price < 600 OR product_price > 900;"
        ],
        "rule_sql": []
    },
    "2307": {
        "db_id": "perpetrator",
        "question": "What is the location of the perpetrator with the largest kills.",
        "ground_truth": "SELECT LOCATION FROM perpetrator ORDER BY Killed DESC LIMIT 1",
        "amends": [
            "Do reference table `perpetrator` instead of `perpetrators` in the FROM clause. Do order by column `Killed` instead of `kills` in the ORDER BY clause. Do use uppercase `LOCATION` instead of lowercase `location` in the SELECT list. The amended query now correctly references the proper table name and column for ordering by kill count while maintaining the same limit behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location FROM perpetrators ORDER BY kills DESC LIMIT 1;",
            "SELECT LOCATION FROM perpetrator ORDER BY Killed DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "558": {
        "db_id": "store_1",
        "question": "What are the first and last names of the customers with the 10 cheapest invoices?",
        "ground_truth": "SELECT T1.first_name ,  T1.last_name FROM customers AS T1 JOIN invoices AS T2 ON T2.customer_id  =  T1.id ORDER BY total LIMIT 10;",
        "amends": [
            "Do use `T1.first_name` and `T1.last_name` instead of `c.FirstName` and `c.LastName` for column names. Do reference `customers AS T1` and `invoices AS T2` instead of `customers c` and `invoices i` for table aliases. Do join on `T2.customer_id = T1.id` instead of `c.CustomerId = i.CustomerId` for the join condition. Do order by `total` instead of `i.Total ASC` for the sort criteria. The amended query now correctly matches the RIGHT_SQL's behavior with proper column references, table aliases, join conditions, and ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.FirstName, c.LastName \nFROM customers c \nJOIN invoices i ON c.CustomerId = i.CustomerId \nORDER BY i.Total ASC \nLIMIT 10;",
            "SELECT T1.first_name, T1.last_name\nFROM customers AS T1\nJOIN invoices AS T2 ON T2.customer_id = T1.id\nORDER BY T2.total ASC\nLIMIT 10"
        ],
        "rule_sql": []
    },
    "4425": {
        "db_id": "network_2",
        "question": "What is the average age for a male in each job?",
        "ground_truth": "SELECT avg(age) ,  job FROM Person WHERE gender  =  'male' GROUP BY job",
        "amends": [
            "Do select `avg(age)` without an alias and include `job` in the SELECT list instead of selecting `job` and `AVG(age) as average_age`. Do use table `Person` instead of `employees` as the FROM source. Do group by `job` instead of grouping by `gender`. Do remove the explicit alias `average_age` instead of keeping it. The amended query now correctly calculates average age by job for male persons rather than incorrectly grouping by gender itself.",
            "Do place `job` after the aggregate function instead of before it in the SELECT list. Do use lowercase `avg(age)` instead of uppercase `AVG(age)` for the aggregate function. Do maintain the same `WHERE gender = 'male'` filter and `GROUP BY job` clause without changes. The amended query now correctly matches the RIGHT_SQL's behavior with proper column ordering and function casing."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT job, AVG(age) as average_age FROM employees WHERE gender = 'male' GROUP BY gender;",
            "SELECT job, AVG(age) FROM Person WHERE gender = 'male' GROUP BY job",
            "SELECT avg(age), job FROM Person WHERE gender = 'male' GROUP BY job"
        ],
        "rule_sql": []
    },
    "3799": {
        "db_id": "e_learning",
        "question": "What are the personal names and family names of the students? Sort the result in alphabetical order of the family name.",
        "ground_truth": "SELECT personal_name ,  family_name FROM Students ORDER BY family_name",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT personal_name, family_name FROM students ORDER BY personal_name ASC;"
        ],
        "rule_sql": []
    },
    "1430": {
        "db_id": "college_2",
        "question": "Find the name of the instructors who taught C Programming course before.",
        "ground_truth": "SELECT T1.name FROM instructor AS T1 JOIN teaches AS T2 ON T1.id  =  T2.id JOIN course AS T3 ON T2.course_id  =  T3.course_id WHERE T3.title  =  'C Programming'",
        "amends": [
            "Do use explicit table aliases `T1.name` instead of just `name`. Do add joins to `teaches AS T2` and `course AS T3` instead of querying only the `instructors` table. Do join `T1.id = T2.id` and `T2.course_id = T3.course_id` instead of filtering directly on course name. Do filter on `T3.title = 'C Programming'` instead of `course = 'C Programming'`. Do remove the `taught_before = 'yes'` condition instead of keeping it. The amended query now correctly joins through the relationship tables to find instructors teaching the specific course."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM instructors WHERE course = 'C Programming' AND taught_before = 'yes';",
            "SELECT T1.name \nFROM instructor AS T1\nJOIN teaches AS T2 ON T1.ID = T2.ID\nJOIN course AS T3 ON T2.course_id = T3.course_id\nWHERE T3.title = 'C Programming'"
        ],
        "rule_sql": []
    },
    "3820": {
        "db_id": "e_learning",
        "question": "What is the name of the course that has the most student enrollment?",
        "ground_truth": "SELECT T1.course_name FROM Courses AS T1 JOIN Student_Course_Enrolment AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do add `JOIN Student_Course_Enrolment AS T2 ON T1.course_id = T2.course_id` instead of querying only the `courses` table. Do add `GROUP BY T1.course_name` and `COUNT(*)` aggregation instead of using the raw `student_count` column. Do change `ORDER BY COUNT(*) DESC` instead of `ORDER BY student_count ASC` to sort by actual enrollment count rather than a potentially incorrect static value. Do qualify columns with table aliases as `T1.course_name` instead of unqualified `course_name`. The amended query now correctly calculates actual enrollment counts through the join and aggregation, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT course_name FROM courses ORDER BY student_count ASC LIMIT 1;",
            "SELECT T1.course_name\nFROM Courses AS T1\nJOIN Student_Course_Enrolment AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_name\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "3674": {
        "db_id": "baseball_1",
        "question": "How many times in total did the team Boston Red Stockings participate in postseason games?",
        "ground_truth": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' );",
        "amends": [
            "Do use a subquery with UNION instead of a single table query, joining `postseason` to `team` on both `team_id_winner` and `team_id_loser` instead of querying `postseason_games` directly. Do filter on `T2.name = 'Boston Red Stockings'` instead of `team_name = 'Boston Red Stockings'`, and do reference the correct column `team_id_br` for joining instead of assuming a direct team name match. Do count from the union of both winning and losing scenarios instead of counting from a single table that doesn't exist, ensuring all postseason appearances for the team are captured regardless of game outcome. The amended query now correctly matches the intended behavior by properly joining through the team table and accounting for both victory and defeat scenarios.",
            "Do use `SELECT *` instead of `SELECT p.year, p.round` to preserve all columns from the union subquery. Do add table aliases `AS T1` and `AS T2` instead of omitting them for explicit table referencing. Do use `T2.name` instead of `t.name` for consistent alias usage. Do remove the column alias `AS total_postseason_appearances` instead of keeping it since the outer query only returns a count. The amended query now correctly counts all postseason appearances by the Boston Red Stockings regardless of whether they were winners or losers, matching the intended behavior.",
            "Do use a single `JOIN` with `postseason AS T1` and `team AS T2` instead of nested joins with additional team tables. Do join directly on `T1.team_id_winner = T2.team_id_br` instead of the complex franchise-based join chain. Do remove the unnecessary `franchise_id` correlation logic and instead filter directly on `T2.name = 'Boston Red Stockings'` in both UNION branches. Do simplify the SELECT clause to `SELECT *` instead of `SELECT p.*` since the table aliases have changed. The amended query now correctly counts postseason games where Boston Red Stockings participated as either winner or loser by directly matching team identifiers instead of going through franchise relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM postseason_games WHERE team_name = 'Boston Red Stockings';",
            "SELECT COUNT(*) AS total_postseason_appearances\nFROM (\n    SELECT p.year, p.round\n    FROM postseason p\n    JOIN team t ON p.team_id_winner = t.team_id_br\n    WHERE t.name = 'Boston Red Stockings'\n    \n    UNION\n    \n    SELECT p.year, p.round\n    FROM postseason p\n    JOIN team t ON p.team_id_loser = t.team_id_br\n    WHERE t.name = 'Boston Red Stockings'\n)",
            "SELECT COUNT(*) \nFROM (\n    SELECT p.* \n    FROM postseason p \n    JOIN team T1 ON p.team_id_winner = T1.team_id_br \n    JOIN team T2 ON T1.franchise_id = T2.franchise_id \n    WHERE T2.name = 'Boston Red Stockings'\n    UNION\n    SELECT p.* \n    FROM postseason p \n    JOIN team T1 ON p.team_id_loser = T1.team_id_br \n    JOIN team T2 ON T1.franchise_id = T2.franchise_id \n    WHERE T2.name = 'Boston Red Stockings'\n)",
            "SELECT COUNT(*) \nFROM (\n    SELECT * \n    FROM postseason AS T1 \n    JOIN team AS T2 ON T1.team_id_winner = T2.team_id_br \n    WHERE T2.name = 'Boston Red Stockings'\n    \n    UNION ALL\n    \n    SELECT * \n    FROM postseason AS T1 \n    JOIN team AS T2 ON T1.team_id_loser = T2.team_id_br \n    WHERE T2.name = 'Boston Red Stockings'\n) AS postseason_games;"
        ],
        "rule_sql": []
    },
    "1879": {
        "db_id": "wrestler",
        "question": "What are the teams that have both wrestlers eliminated by Orton and wrestlers eliminated by Benjamin?",
        "ground_truth": "SELECT Team FROM Elimination WHERE Eliminated_By  =  \"Orton\" INTERSECT SELECT Team FROM Elimination WHERE Eliminated_By  =  \"Benjamin\"",
        "amends": [
            "Do use `INTERSECT` to find teams with eliminations by both wrestlers instead of multiple `JOIN` operations on the same table. Do query the `Elimination` table directly instead of joining through `teams` and `wrestlers` tables. Do reference `Eliminated_By` column instead of `eliminator_name` for filtering conditions. Do use `Team` column instead of `team_name` for the result set. Do remove the `DISTINCT` keyword since `INTERSECT` inherently returns unique results instead of keeping it. Do use double quotes around string literals 'Orton' and 'Benjamin' instead of single quotes. The amended query now correctly identifies teams that have been eliminated by both Orton and Benjamin using set intersection logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT team_name \nFROM teams t\nJOIN wrestlers w ON t.team_id = w.team_id\nJOIN eliminations e1 ON w.wrestler_id = e1.eliminated_wrestler_id\nJOIN eliminations e2 ON w.wrestler_id = e2.eliminated_wrestler_id\nWHERE e1.eliminator_name = 'Orton' AND e2.eliminator_name = 'Benjamin';",
            "SELECT Team FROM Elimination WHERE Eliminated_By = \"Orton\" INTERSECT SELECT Team FROM Elimination WHERE Eliminated_By = \"Benjamin\""
        ],
        "rule_sql": []
    },
    "5900": {
        "db_id": "cre_Theme_park",
        "question": "Find the address of the location named \"UK Gallery\".",
        "ground_truth": "SELECT Address FROM LOCATIONS WHERE Location_Name  =  \"UK Gallery\"",
        "amends": [
            "Do select `Address` instead of `name` in the SELECT list. Do filter on `Location_Name = \"UK Gallery\"` instead of `address = 'UK Gallery'` in the WHERE clause. The amended query now correctly retrieves the address where the location name matches \"UK Gallery\" instead of incorrectly looking for a name where the address equals 'UK Gallery', ensuring the query matches the intended behavior of the right SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM locations WHERE address = 'UK Gallery';",
            "SELECT Address FROM Locations WHERE Location_Name = 'UK Gallery';"
        ],
        "rule_sql": []
    },
    "1002": {
        "db_id": "university_basketball",
        "question": "What are the total enrollments of universities of each affiliation type?",
        "ground_truth": "SELECT sum(enrollment) ,  affiliation FROM university GROUP BY affiliation",
        "amends": [
            "Do use `sum(enrollment)` instead of `COUNT(*) as total_enrollments` for calculating total enrollments. Do reference the correct table name `university` instead of `universities`. Do place the aggregate function `sum(enrollment)` before the grouping column `affiliation` in the SELECT list instead of after it. The amended query now correctly sums enrollment values by affiliation rather than counting rows, using the proper table reference and column order.",
            "Do use lowercase `sum(enrollment)` without an alias instead of `SUM(Enrollment) as total_enrollments` with an alias. Do place `affiliation` after the aggregate function instead of listing it first in the SELECT clause. Do use lowercase `affiliation` in both SELECT and GROUP BY instead of mixed case `Affiliation`. The amended query now correctly aggregates enrollment by affiliation without unnecessary aliasing and maintains consistent case handling throughout."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT affiliation, COUNT(*) as total_enrollments FROM universities GROUP BY affiliation;",
            "SELECT Affiliation, SUM(Enrollment) as total_enrollments FROM university GROUP BY Affiliation;",
            "SELECT sum(enrollment), affiliation FROM university GROUP BY affiliation"
        ],
        "rule_sql": []
    },
    "1643": {
        "db_id": "wedding",
        "question": "Show all church names that have hosted least two weddings.",
        "ground_truth": "SELECT T1.name FROM church AS T1 JOIN wedding AS T2 ON T1.church_id  =  T2.church_id GROUP BY T1.church_id HAVING count(*)  >=  2",
        "amends": [
            "Do select `T1.name` from the `church` table instead of `church_name` from `weddings`. Do join `wedding AS T2` with an `INNER JOIN` on `T1.church_id = T2.church_id` instead of querying only the `weddings` table. Do group by `T1.church_id` instead of `church_name` to ensure proper aggregation. The amended query now correctly identifies churches that have hosted multiple weddings by properly joining the church and wedding tables and grouping on the church identifier."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT church_name FROM weddings GROUP BY church_name HAVING COUNT(*) >= 2;",
            "SELECT T1.Name \nFROM church AS T1\nINNER JOIN wedding AS T2 ON T1.Church_ID = T2.Church_ID\nGROUP BY T1.Church_ID\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "4548": {
        "db_id": "company_office",
        "question": "Find the names of the companies whose headquarters are not located in \"USA\".",
        "ground_truth": "SELECT name FROM Companies WHERE Headquarters != 'USA'",
        "amends": [
            "Do use table name `Companies` instead of `companies` to match the correct schema. Do use inequality filter `!= 'USA'` instead of equality filter `= 'USA'` to select companies not headquartered in the USA. The amended query now correctly returns companies with headquarters outside the United States, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM companies WHERE headquarters = 'USA';",
            "SELECT name FROM Companies WHERE Headquarters != 'USA';"
        ],
        "rule_sql": []
    },
    "615": {
        "db_id": "store_1",
        "question": "List the name of all playlist.",
        "ground_truth": "SELECT name FROM playlists;",
        "amends": [
            "Do specify the column `name` in the SELECT list instead of using `*` to select all columns. This amended query now matches the RIGHT_SQL's behavior by returning only the playlist names rather than all columns from the playlists table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM playlists;",
            "SELECT name FROM playlists;"
        ],
        "rule_sql": []
    },
    "1790": {
        "db_id": "small_bank_1",
        "question": "Find the checking balance and saving balance in the Brown\u2019s account.",
        "ground_truth": "SELECT T2.balance ,  T3.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid WHERE T1.name  =  'Brown'",
        "amends": [
            "Do use explicit table aliases `T2.balance` and `T3.balance` instead of direct column references `checking_balance` and `saving_balance`. Do join from `accounts AS T1` instead of querying only the accounts table. Do add `JOIN checking AS T2 ON T1.custid = T2.custid` instead of omitting the checking table join. Do add `JOIN savings AS T3 ON T1.custid = T3.custid` instead of omitting the savings table join. Do filter on `T1.name = 'Brown'` instead of `account_name = 'Brown'`. The amended query now correctly retrieves balances from related checking and savings tables through proper joins on customer ID, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT checking_balance, saving_balance FROM accounts WHERE account_name = 'Brown'",
            "SELECT T2.balance AS checking_balance, T3.balance AS saving_balance\nFROM accounts AS T1\nJOIN checking AS T2 ON T1.custid = T2.custid\nJOIN savings AS T3 ON T1.custid = T3.custid\nWHERE T1.name = 'Brown'"
        ],
        "rule_sql": []
    },
    "2735": {
        "db_id": "election",
        "question": "Count the total number of counties.",
        "ground_truth": "SELECT count(*) FROM county",
        "amends": [
            "Do query the `county` table instead of the `states` table. Do count all rows from the correct source table instead of counting from an incorrect table. The amended query now correctly counts records from the county table as specified in the target output."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM states;",
            "SELECT COUNT(*) FROM county;"
        ],
        "rule_sql": []
    },
    "267": {
        "db_id": "musical",
        "question": "Who are the nominees who have been nominated more than two times?",
        "ground_truth": "SELECT Nominee FROM musical GROUP BY Nominee HAVING COUNT(*)  >  2",
        "amends": [
            "Do select `Nominee` instead of `name, COUNT(*) as nomination_count` and move the aggregate filter to `HAVING COUNT(*) > 2` instead of incorrectly placing it in the `WHERE` clause where aggregate functions cannot be used. Do use table `musical` instead of `nominees` and remove the alias `nomination_count` from the output. Do group by `Nominee` instead of `name` and ensure the count condition is properly evaluated after grouping rather than before it. The amended query now correctly filters groups based on the aggregate count condition using HAVING instead of the invalid WHERE usage, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, COUNT(*) as nomination_count \nFROM nominees \nWHERE nomination_count > 2 \nGROUP BY name;",
            "SELECT Nominee FROM musical GROUP BY Nominee HAVING COUNT(*) > 2"
        ],
        "rule_sql": []
    },
    "2177": {
        "db_id": "formula_1",
        "question": "Find the forename and surname of drivers whose nationality is German?",
        "ground_truth": "SELECT forename ,  surname FROM drivers WHERE nationality = \"German\"",
        "amends": [
            "Do use `\"German\"` as the nationality filter instead of `'French'` to correctly select drivers with German nationality. The amended query now matches RIGHT_SQL's behavior by filtering for the specified nationality."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT forename, surname FROM drivers WHERE nationality = 'French';",
            "SELECT forename, surname FROM drivers WHERE nationality = \"German\";"
        ],
        "rule_sql": []
    },
    "6851": {
        "db_id": "flight_4",
        "question": "Return the cities with more than 3 airports in the United States.",
        "ground_truth": "SELECT city FROM airports WHERE country  =  'United States' GROUP BY city HAVING count(*)  >  3",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM airports WHERE country = 'United States' GROUP BY city HAVING COUNT(*) > 3;"
        ],
        "rule_sql": []
    },
    "3642": {
        "db_id": "baseball_1",
        "question": "Find the id and rank of the team that has the highest average attendance rate in 2014.",
        "ground_truth": "SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  2014 GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT 1;",
        "amends": [
            "Do select `T2.team_id` and `T2.rank` from the `team` table instead of `id` and `rank` from the `teams` table. Do join `home_game AS T1` with `team AS T2` on `T1.team_id = T2.team_id` instead of querying a single table. Do filter on `T1.year = 2014` in the WHERE clause instead of using a subquery to find the maximum attendance rate. Do group by `T1.team_id` and order by `avg(T1.attendance) DESC` with a `LIMIT 1` instead of using an equality subquery to find maximum attendance. Do remove the subquery entirely instead of keeping it. The amended query now correctly identifies the team with the highest average attendance in 2014 by joining the relevant tables and using proper aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, rank FROM teams WHERE attendance_rate = (SELECT MAX(attendance_rate) FROM teams WHERE year = 2014);",
            "SELECT T2.team_id, T2.rank\nFROM home_game AS T1\nJOIN team AS T2 ON T1.team_id = T2.team_id\nWHERE T1.year = 2014\nGROUP BY T1.team_id\nORDER BY AVG(T1.attendance) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3358": {
        "db_id": "sports_competition",
        "question": "What are the names of the clubs that have players in the position of \"Right Wing\"?",
        "ground_truth": "SELECT T1.name FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID WHERE T2.Position  =  \"Right Wing\"",
        "amends": [
            "Do select `T1.name` from the `club` table instead of `club_name` from the `players` table. Do join `club AS T1` with `player AS T2` on `T1.Club_ID = T2.Club_ID` instead of querying only the `players` table. Do filter on `T2.Position = \"Right Wing\"` instead of `position = 'Left Wing'` to correct the position criteria. The amended query now properly retrieves club names for players in the right wing position by joining the club and player tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT club_name FROM players WHERE position = 'Left Wing';",
            "SELECT T1.name \nFROM club AS T1 \nJOIN player AS T2 ON T1.Club_ID = T2.Club_ID \nWHERE T2.Position = \"Right Wing\""
        ],
        "rule_sql": []
    },
    "2691": {
        "db_id": "storm_record",
        "question": "Count the number of regions.",
        "ground_truth": "SELECT count(*) FROM region",
        "amends": [
            "Do query the `region` table instead of the `countries` table. The amended query now correctly counts records from the region table as specified in the target output."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries;",
            "SELECT COUNT(*) FROM region;"
        ],
        "rule_sql": []
    },
    "2213": {
        "db_id": "formula_1",
        "question": "What are the names of circuits that belong to UK or Malaysia?",
        "ground_truth": "SELECT name FROM circuits WHERE country = \"UK\" OR country = \"Malaysia\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM circuits WHERE country = 'UK' OR country = 'Malaysia';"
        ],
        "rule_sql": []
    },
    "5680": {
        "db_id": "dorm_1",
        "question": "Find the number of distinct amenities.",
        "ground_truth": "SELECT count(*) FROM dorm_amenity",
        "amends": [
            "Do query the `dorm_amenity` table instead of the `amenities` table, as the correct data source for counting amenities is the dormitory-specific amenity relationship table rather than a general amenities table. The amended query now correctly counts amenities associated with dormitories, matching the intended behavior of the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM amenities;",
            "SELECT COUNT(DISTINCT amenid) FROM Dorm_amenity;"
        ],
        "rule_sql": []
    },
    "3710": {
        "db_id": "baseball_1",
        "question": "Which park did the most people attend in 2008?",
        "ground_truth": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;",
        "amends": [
            "Do use `T2.park_name` from the `park` table instead of `park_name` from an unspecified source. Do join `home_game AS T1` with `park AS T2` on `T1.park_id = T2.park_id` instead of querying a single `parks` table. Do filter on `T1.year = 2008` instead of `year = 2008`. Do order by `T1.attendance DESC` instead of aggregating with `SUM(attendance)` and ordering by the sum. Do remove the `GROUP BY` clause and aggregation instead of grouping by park_name. The amended query now correctly retrieves the park with the highest single game attendance in 2008 rather than the total annual attendance per park, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT park_name, SUM(attendance) as total_attendance FROM parks WHERE year = 2008 GROUP BY park_name ORDER BY total_attendance DESC LIMIT 1;",
            "SELECT T2.park_name\nFROM home_game AS T1\nJOIN park AS T2 ON T1.park_id = T2.park_id\nWHERE T1.year = 2008\nORDER BY T1.attendance DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "801": {
        "db_id": "coffee_shop",
        "question": "Find the id and address of the shops whose score is below the average score.",
        "ground_truth": "SELECT shop_id ,  address FROM shop WHERE score  <  (SELECT avg(score) FROM shop)",
        "amends": [
            "Do reference `shop_id` instead of `id` and use table name `shop` instead of `shops` in both the main query and subquery. Do use lowercase `avg(score)` instead of uppercase `AVG(score)` in the subquery. The amended query now correctly references the shop_id column and uses the proper table name with consistent casing for the aggregate function."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, address FROM shops WHERE score < (SELECT AVG(score) FROM shops)",
            "SELECT Shop_ID, Address FROM shop WHERE Score < (SELECT avg(Score) FROM shop)"
        ],
        "rule_sql": []
    },
    "4633": {
        "db_id": "customers_campaigns_ecommerce",
        "question": "Show the shipping charge and customer id for customer orders with order status Cancelled or Paid.",
        "ground_truth": "SELECT order_shipping_charges ,  customer_id FROM customer_orders WHERE order_status_code  =  'Cancelled' OR order_status_code  =  'Paid'",
        "amends": [
            "Do reference `order_shipping_charges` instead of `shipping_charge` for the shipping cost column. Do query from `customer_orders` instead of `orders` as the source table. Do filter on `order_status_code` instead of `order_status` for the status column name. The amended query now correctly retrieves shipping charges and customer IDs from the appropriate table with the proper column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT shipping_charge, customer_id FROM orders WHERE order_status = 'Cancelled' OR order_status = 'Paid';",
            "SELECT order_shipping_charges, customer_id FROM Customer_Orders WHERE order_status_code IN ('Cancelled', 'Paid')"
        ],
        "rule_sql": []
    },
    "2148": {
        "db_id": "local_govt_in_alabama",
        "question": "What is the id of the event with the most participants?",
        "ground_truth": "SELECT Event_ID FROM Participants_in_Events GROUP BY Event_ID ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `Event_ID` instead of `id` and use `count(*)` in the ORDER BY instead of `participant_count`. Do use `GROUP BY Event_ID` instead of omitting grouping. Do order by `DESC` instead of `ASC` to find the event with the most participants. Do query from `Participants_in_Events` instead of `events` to access the participant relationship data. The amended query now correctly identifies the event with the highest number of participants by counting records in the participant-event mapping table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM events ORDER BY participant_count ASC LIMIT 1;",
            "SELECT Event_ID FROM Participants_in_Events GROUP BY Event_ID ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "6553": {
        "db_id": "wine_1",
        "question": "What are the numbers of wines for different grapes?",
        "ground_truth": "SELECT count(*) ,  Grape FROM WINE GROUP BY Grape",
        "amends": [
            "Do use `count(*)` without an alias instead of `COUNT(*)` without an alias. Do place `Grape` after the aggregate function instead of before it. Do capitalize `Grape` and `WINE` consistently instead of using lowercase `grape` and `wines`. The amended query now correctly groups by grape and counts records while maintaining proper SQL syntax and capitalization.",
            "Do place the `Grape` column after the aggregate function instead of before it in the SELECT list. Do maintain the same `GROUP BY Grape` clause instead of changing the grouping logic. The amended query now correctly displays the count of wines grouped by grape type while preserving the original data structure and matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT grape, COUNT(*) FROM wines GROUP BY grape;",
            "SELECT Grape, COUNT(*) FROM wine GROUP BY Grape;",
            "SELECT COUNT(*), Grape FROM wine GROUP BY Grape"
        ],
        "rule_sql": []
    },
    "1709": {
        "db_id": "epinions_1",
        "question": "For each user, return the name and the average rating of reviews given by them.",
        "ground_truth": "SELECT T1.name ,  avg(T2.rating) FROM useracct AS T1 JOIN review AS T2 ON T1.u_id  =  T2.u_id GROUP BY T2.u_id",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `u` and `r`. Do reference `T1.name` instead of `u.name` and `avg(T2.rating)` instead of `AVG(r.rating) as average_rating`. Do use table names `useracct` and `review` instead of `users` and `reviews`. Do join on `T1.u_id = T2.u_id` instead of `u.id = r.user_id`. Do group by `T2.u_id` instead of `u.id`. The amended query now correctly matches the intended behavior with proper table references and join conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT u.name, AVG(r.rating) as average_rating\nFROM users u\nJOIN reviews r ON u.id = r.user_id\nGROUP BY u.id;",
            "SELECT T1.name, AVG(T2.rating) as average_rating\nFROM useracct T1\nJOIN review T2 ON T1.u_id = T2.u_id\nGROUP BY T2.u_id"
        ],
        "rule_sql": []
    },
    "1560": {
        "db_id": "customers_and_invoices",
        "question": "Count the number of customers who do not have an account.",
        "ground_truth": "SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)",
        "amends": [
            "Do use `count(*)` instead of `COUNT(*)` for consistent function casing. Do filter with `customer_id NOT IN (subquery)` instead of `account_id IS NOT NULL` to exclude customers without accounts. Do add a correlated subquery `SELECT customer_id FROM Accounts` instead of omitting it to properly identify customers with accounts. The amended query now correctly counts only customers who do not have associated account records, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE account_id IS NOT NULL;",
            "SELECT count(*) \nFROM Customers \nWHERE customer_id NOT IN (SELECT customer_id FROM Accounts)"
        ],
        "rule_sql": []
    },
    "4811": {
        "db_id": "aircraft",
        "question": "List all pilot names in ascending alphabetical order.",
        "ground_truth": "SELECT Name FROM pilot ORDER BY Name ASC",
        "amends": [
            "Do reference the table as `pilot` instead of `pilots` and use column `Name` instead of `name` in both the SELECT list and ORDER BY clause. Do use `ASC` ordering instead of `DESC` ordering for the Name column. The amended query now correctly selects from the pilot table with proper column naming and ascending sort order to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM pilots ORDER BY name DESC;",
            "SELECT Name FROM pilot ORDER BY Name ASC;"
        ],
        "rule_sql": []
    },
    "3162": {
        "db_id": "station_weather",
        "question": "Find the number of trains starting from each origin.",
        "ground_truth": "SELECT origin ,  count(*) FROM train GROUP BY origin",
        "amends": [
            "Do `GROUP BY origin` instead of `GROUP BY destination` to correctly aggregate counts by the origin column rather than the destination column. Do reference table `train` instead of `trains` to use the correct table name. The amended query now correctly counts records grouped by their origin values, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT origin, COUNT(*) FROM trains GROUP BY destination;",
            "SELECT origin, COUNT(*) AS number_of_trains FROM train GROUP BY origin;"
        ],
        "rule_sql": []
    },
    "3552": {
        "db_id": "music_1",
        "question": "Find the file format that is used by the most files.",
        "ground_truth": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1",
        "amends": [
            "Do use column name `formats` instead of `format` in both the SELECT list and GROUP BY clause. Do order by `COUNT(*) DESC` instead of `COUNT(*) ASC` to get the most common format rather than the least common. Do remove the alias `count` from the aggregate function since it's not used in the ORDER BY clause. The amended query now correctly identifies the most frequently occurring format in the files table by counting occurrences in descending order.",
            "Do select only `formats` instead of including `COUNT(*)` in the SELECT list, as the aggregate function is only needed for ordering purposes. Do maintain the `GROUP BY formats` clause to group by the distinct format values. Do keep the `ORDER BY COUNT(*) DESC` to order by the count of records in descending order. Do preserve the `LIMIT 1` to return only the single most frequent format. The amended query now correctly returns only the format value with the highest count instead of returning both the format and its count."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT format, COUNT(*) as count FROM files GROUP BY format ORDER BY count ASC LIMIT 1;",
            "SELECT formats, COUNT(*) FROM files GROUP BY formats ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT formats FROM files GROUP BY formats ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3291": {
        "db_id": "college_1",
        "question": "Find the first name of the professor who is teaching two courses with code CIS-220 and QM-261.",
        "ground_truth": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'CIS-220' INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'QM-261'",
        "amends": [
            "Do use `INTERSECT` to find professors teaching both courses instead of using `AND` with the same column. Do join `employee` and `CLASS` tables on `emp_num = prof_num` instead of querying only the `professors` table. Do filter for `crs_code = 'CIS-220'` in one branch and `crs_code = 'QM-261'` in another instead of trying to match both values in a single `WHERE` clause. Do select `emp_fname` from the joined tables instead of `first_name` from a single table. The amended query now correctly identifies professors who teach both specified courses by using set intersection logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM professors WHERE course_code = 'CIS-220' AND course_code = 'QM-261'",
            "SELECT e.EMP_FNAME\nFROM EMPLOYEE e\nJOIN CLASS c1 ON e.EMP_NUM = c1.PROF_NUM\nWHERE c1.CRS_CODE = 'CIS-220'\nINTERSECT\nSELECT e.EMP_FNAME\nFROM EMPLOYEE e\nJOIN CLASS c2 ON e.EMP_NUM = c2.PROF_NUM\nWHERE c2.CRS_CODE = 'QM-261'"
        ],
        "rule_sql": []
    },
    "1230": {
        "db_id": "apartment_rentals",
        "question": "Show the average room count of the apartments that have booking status code \"Provisional\".",
        "ground_truth": "SELECT avg(room_count) FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.booking_status_code  =  \"Provisional\"",
        "amends": [
            "Do join `Apartment_Bookings AS T1` and `Apartments AS T2` on `T1.apt_id = T2.apt_id` instead of querying only the `apartments` table. Do reference `booking_status_code` from the `T1` table instead of `booking_status` from the `apartments` table. Do use double quotes around `\"Provisional\"` instead of single quotes. The amended query now correctly joins the booking and apartment tables to filter by booking status code and calculate the average room count for provisional bookings."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(room_count) FROM apartments WHERE booking_status = 'Provisional';",
            "SELECT AVG(CAST(T2.room_count AS REAL)) AS average_room_count\nFROM Apartment_Bookings AS T1\nJOIN Apartments AS T2 ON T1.apt_id = T2.apt_id\nWHERE T1.booking_status_code = \"Provisional\""
        ],
        "rule_sql": []
    },
    "5924": {
        "db_id": "cre_Theme_park",
        "question": "Find the details of the shops that can be reached by walk.",
        "ground_truth": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  \"walk\"",
        "amends": [
            "Do specify `T1.Shop_Details` in the SELECT list instead of using `*` to select all columns. Do add a `JOIN` with `TOURIST_ATTRACTIONS AS T2` instead of querying only the `shops` table. Do use the join condition `T1.Shop_ID = T2.Tourist_Attraction_ID` instead of no join condition. Do move the transportation filter to `T2.How_to_Get_There = \"walk\"` instead of `transportation = 'walk'` on the shops table. The amended query now correctly joins shops with tourist attractions and filters based on how to reach those attractions, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM shops WHERE transportation = 'walk'",
            "SELECT T1.Shop_Details \nFROM Shops AS T1 \nJOIN Tourist_Attractions AS T2 ON T1.Shop_ID = T2.Tourist_Attraction_ID \nWHERE T2.How_to_Get_There = 'walk'"
        ],
        "rule_sql": []
    },
    "5390": {
        "db_id": "tracking_software_problems",
        "question": "What are the ids of the problems reported after the date of any problems reported by Rylan Homenick?",
        "ground_truth": "SELECT T1.problem_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE date_problem_reported  >  ( SELECT max(date_problem_reported) FROM problems AS T3 JOIN staff AS T4 ON T3.reported_by_staff_id = T4.staff_id WHERE T4.staff_first_name = \"Rylan\" AND T4.staff_last_name = \"Homenick\" )",
        "amends": [
            "Do select `T1.problem_id` instead of `id` and add table aliases throughout. Do join `staff AS T2` on `T1.reported_by_staff_id = T2.staff_id` instead of no join. Do filter on `date_problem_reported` instead of `reported_date` and move the comparison to a subquery. Do use `max(date_problem_reported)` in the subquery instead of a single value and add proper filtering on `staff_first_name` and `staff_last_name` instead of just `reporter`. Do add explicit table aliases `T3` and `T4` in the subquery instead of unaliased references. The amended query now correctly identifies problems reported after the maximum date from the specified staff member, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM problems WHERE reported_date > (SELECT reported_date FROM problems WHERE reporter = 'Rylan Homenick')",
            "SELECT T1.problem_id\nFROM Problems AS T1\nJOIN Staff AS T2 ON T1.reported_by_staff_id = T2.staff_id\nWHERE T1.date_problem_reported > (\n    SELECT MAX(T3.date_problem_reported)\n    FROM Problems AS T3\n    JOIN Staff AS T4 ON T3.reported_by_staff_id = T4.staff_id\n    WHERE T4.staff_first_name = 'Rylan' AND T4.staff_last_name = 'Homenick'\n)"
        ],
        "rule_sql": []
    },
    "6064": {
        "db_id": "customers_and_addresses",
        "question": "What are the dates when customers with ids between 10 and 20 became customers?",
        "ground_truth": "SELECT date_became_customer FROM customers WHERE customer_id BETWEEN 10 AND 20",
        "amends": [
            "Do select `date_became_customer` instead of `customer_id, join_date` in the SELECT list. Do remove the `ORDER BY customer_id` clause instead of keeping it. Do omit the `join_date` column instead of including it. The amended query now correctly retrieves only the date_became_customer field for the specified customer range without unnecessary sorting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_id, join_date FROM customers WHERE customer_id BETWEEN 10 AND 20 ORDER BY customer_id;",
            "SELECT date_became_customer FROM Customers WHERE customer_id BETWEEN 10 AND 20"
        ],
        "rule_sql": []
    },
    "4022": {
        "db_id": "ship_mission",
        "question": "Show the distinct fate of missions that involve ships with nationality \"United States\"",
        "ground_truth": "SELECT DISTINCT T1.Fate FROM mission AS T1 JOIN ship AS T2 ON T1.Ship_ID  =  T2.Ship_ID WHERE T2.Nationality  =  \"United States\"",
        "amends": [
            "Do reference the `Fate` column from the `mission` table (aliased as `T1`) instead of directly from a non-existent `missions` table. Do join the `ship` table (aliased as `T2`) on `T1.Ship_ID = T2.Ship_ID` instead of querying a single table without proper joins. Do filter on `T2.Nationality = \"United States\"` instead of using a non-existent `ship_nationality` column. The amended query now correctly retrieves distinct fates by properly joining related tables and filtering on the ship's nationality attribute, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT fate FROM missions WHERE ship_nationality = 'United States'",
            "SELECT DISTINCT T1.Fate\nFROM mission T1\nJOIN ship T2 ON T1.Ship_ID = T2.Ship_ID\nWHERE T2.Nationality = 'United States'"
        ],
        "rule_sql": []
    },
    "1126": {
        "db_id": "climbing",
        "question": "List the distinct ranges of the mountains with the top 3 prominence.",
        "ground_truth": "SELECT DISTINCT Range FROM mountain ORDER BY Prominence DESC LIMIT 3",
        "amends": [
            "Do reference the table as `mountain` instead of `mountains` and use proper column capitalization with `Range` and `Prominence` instead of lowercase `range` and `prominence` to match the actual schema. The amended query now correctly selects distinct mountain ranges ordered by prominence, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT range FROM mountains ORDER BY prominence DESC LIMIT 3;",
            "SELECT DISTINCT Range FROM mountain ORDER BY Prominence DESC LIMIT 3"
        ],
        "rule_sql": []
    },
    "915": {
        "db_id": "insurance_fnol",
        "question": "List all the services in the alphabetical order.",
        "ground_truth": "SELECT service_name FROM services ORDER BY service_name",
        "amends": [
            "Do select only `service_name` instead of `*` to return all columns. Do use ascending `ORDER BY` without explicit direction instead of descending `DESC` ordering. The amended query now matches RIGHT_SQL's behavior by returning only the service names in ascending alphabetical order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM services ORDER BY service_name DESC;",
            "SELECT service_name FROM Services ORDER BY service_name;"
        ],
        "rule_sql": []
    },
    "3294": {
        "db_id": "college_1",
        "question": "What are the first names of all students taking accoutning and Computer Information Systems classes?",
        "ground_truth": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'",
        "amends": [
            "Do select `T1.stu_fname` from multiple joined tables instead of `first_name` from a single table. Do add joins with `enroll`, `CLASS`, `course`, and `department` tables instead of querying only the `students` table. Do filter on `T5.dept_name = 'Accounting'` and `T5.dept_name = 'Computer Info. Systems'` using separate queries with `INTERSECT` instead of filtering `major` column directly with `OR` conditions. Do use table aliases `T1` through `T5` for clarity instead of no aliases. The amended query now correctly identifies students enrolled in both departments through the intersection of two department-specific queries, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM students WHERE major = 'Accounting' OR major = 'Computer Information Systems';",
            "SELECT T1.STU_FNAME\nFROM STUDENT T1\nJOIN ENROLL T2 ON T1.STU_NUM = T2.STU_NUM\nJOIN CLASS T3 ON T2.CLASS_CODE = T3.CLASS_CODE\nJOIN COURSE T4 ON T3.CRS_CODE = T4.CRS_CODE\nJOIN DEPARTMENT T5 ON T4.DEPT_CODE = T5.DEPT_CODE\nWHERE T5.DEPT_NAME = 'Accounting'\nINTERSECT\nSELECT T1.STU_FNAME\nFROM STUDENT T1\nJOIN ENROLL T2 ON T1.STU_NUM = T2.STU_NUM\nJOIN CLASS T3 ON T2.CLASS_CODE = T3.CLASS_CODE\nJOIN COURSE T4 ON T3.CRS_CODE = T4.CRS_CODE\nJOIN DEPARTMENT T5 ON T4.DEPT_CODE = T5.DEPT_CODE\nWHERE T5.DEPT_NAME = 'Computer Info. Systems'"
        ],
        "rule_sql": []
    },
    "3577": {
        "db_id": "music_1",
        "question": "List the names of all genres in alphabetical oder, together with its ratings.",
        "ground_truth": "SELECT g_name ,  rating FROM genre ORDER BY g_name",
        "amends": [
            "Do reference the `g_name` column instead of `name` and use the `genre` table instead of `genres`. Do order by `g_name` instead of `name` and remove the explicit `ASC` direction since it is the default. The amended query now correctly selects from the appropriate table with the correct column names to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, rating FROM genres ORDER BY name ASC;",
            "SELECT g_name, rating FROM genre ORDER BY g_name;"
        ],
        "rule_sql": []
    },
    "937": {
        "db_id": "medicine_enzyme_interaction",
        "question": "List the names and the locations that the enzymes can make an effect.",
        "ground_truth": "SELECT name ,  LOCATION FROM enzyme",
        "amends": [
            "Do reference the `name` column instead of `enzyme_name` and use the correct table name `enzyme` instead of `enzymes`. Do remove the `WHERE effect = 'yes'` filter instead of keeping it, as the right query does not include any filtering condition. The amended query now correctly selects from the enzyme table without unnecessary filtering, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT enzyme_name, location FROM enzymes WHERE effect = 'yes';",
            "SELECT name, Location FROM enzyme;"
        ],
        "rule_sql": []
    },
    "5290": {
        "db_id": "manufactory_1",
        "question": "Find the name of companies whose revenue is between 100 and 150.",
        "ground_truth": "SELECT name FROM manufacturers WHERE revenue BETWEEN 100 AND 150",
        "amends": [
            "Do query the `manufacturers` table instead of the `companies` table. Do use the `BETWEEN` operator with `revenue BETWEEN 100 AND 150` instead of the `OR` condition with `revenue > 150 OR revenue < 100`, which incorrectly excluded the desired revenue range between 100 and 150. The amended query now correctly selects manufacturers with revenue values inclusively between 100 and 150, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM companies WHERE revenue > 150 OR revenue < 100;",
            "SELECT Name FROM Manufacturers WHERE Revenue BETWEEN 100 AND 150;"
        ],
        "rule_sql": []
    },
    "829": {
        "db_id": "chinook_1",
        "question": "What is the average unit price of all the tracks?",
        "ground_truth": "SELECT AVG(UnitPrice) FROM TRACK",
        "amends": [
            "Do reference the correct column name `UnitPrice` instead of the incorrect `price` column. Do reference the correct table name `TRACK` instead of the incorrect `tracks` table. The amended query now correctly calculates the average unit price from the TRACK table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(price) FROM tracks;",
            "SELECT AVG(UnitPrice) AS AverageUnitPrice FROM Track;"
        ],
        "rule_sql": []
    },
    "3988": {
        "db_id": "hospital_1",
        "question": "Find the name of physicians who are affiliated with Surgery or Psychiatry department.",
        "ground_truth": "SELECT T1.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T3.name  =  'Surgery' OR T3.name  =  'Psychiatry'",
        "amends": [
            "Do select `T1.name` from the `physician` table instead of `name` from `physicians`. Do join `affiliated_with` as `T2` on `T1.EmployeeID = T2.physician` instead of querying a single table. Do join `department` as `T3` on `T2.department = T3.DepartmentID` instead of filtering directly on department names. Do filter on `T3.name = 'Surgery' OR T3.name = 'Psychiatry'` instead of `department = 'Surgery' OR department = 'Psychiatry'` to properly reference the department table. The amended query now correctly joins through the affiliation relationship to find physicians associated with specific departments, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM physicians WHERE department = 'Surgery' OR department = 'Psychiatry'",
            "SELECT T1.Name \nFROM Physician T1\nJOIN Affiliated_With T2 ON T1.EmployeeID = T2.Physician\nJOIN Department T3 ON T2.Department = T3.DepartmentID\nWHERE T3.Name = 'Surgery' OR T3.Name = 'Psychiatry'"
        ],
        "rule_sql": []
    },
    "2647": {
        "db_id": "local_govt_mdm",
        "question": "What is the cmi cross reference id that is related to at least one council tax entry? List the cross reference id and source system code.",
        "ground_truth": "SELECT T1.cmi_cross_ref_id ,  T1.source_system_code FROM CMI_Cross_References AS T1 JOIN Council_Tax AS T2 ON T1.cmi_cross_ref_id  =  T2.cmi_cross_ref_id GROUP BY T1.cmi_cross_ref_id HAVING count(*)  >=  1",
        "amends": [
            "Do add `JOIN Council_Tax AS T2` with `ON T1.cmi_cross_ref_id = T2.cmi_cross_ref_id` instead of querying a single table with `WHERE council_tax_id IS NULL`. Do change the SELECT list to `T1.cmi_cross_ref_id, T1.source_system_code` instead of `cross_reference_id, source_system_code`. Do add `GROUP BY T1.cmi_cross_ref_id` and `HAVING count(*) >= 1` instead of filtering for NULL values. Do use table alias `T1` for `CMI_Cross_References` instead of the base table name. The amended query now correctly identifies cross references that have associated council tax records instead of those missing council tax IDs."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT cross_reference_id, source_system_code FROM cmi_cross_reference WHERE council_tax_id IS NULL;",
            "SELECT T1.cmi_cross_ref_id, T1.source_system_code\nFROM CMI_Cross_References AS T1\nJOIN Council_Tax AS T2 ON T1.cmi_cross_ref_id = T2.cmi_cross_ref_id\nGROUP BY T1.cmi_cross_ref_id\nHAVING COUNT(*) >= 1"
        ],
        "rule_sql": []
    },
    "3683": {
        "db_id": "baseball_1",
        "question": "What were all the salary values of players in 2010 and 2001?",
        "ground_truth": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001",
        "amends": [
            "Do query the `salary` table instead of the `players` table. Do use `UNION` to combine results from two separate queries instead of using `OR` in a single `WHERE` clause. Do specify `YEAR = 2010` in one query and `YEAR = 2001` in another query instead of combining both conditions with `OR`. The amended query now correctly retrieves salary data from the appropriate table using union operations to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT salary FROM players WHERE year = 2010 OR year = 2001;",
            "SELECT salary FROM salary WHERE year = 2010\nUNION\nSELECT salary FROM salary WHERE year = 2001"
        ],
        "rule_sql": []
    },
    "2779": {
        "db_id": "election",
        "question": "Sort the names of all counties in ascending order of population.",
        "ground_truth": "SELECT County_name FROM county ORDER BY Population ASC",
        "amends": [
            "Do select `County_name` instead of `name` and order by `Population ASC` instead of `population DESC`. Do use table `county` instead of `counties`. The amended query now correctly selects the county name column and orders by population in ascending order from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM counties ORDER BY population DESC;",
            "SELECT County_name FROM county ORDER BY Population ASC;"
        ],
        "rule_sql": []
    },
    "4700": {
        "db_id": "college_3",
        "question": "What is the average gradepoint for students with the last name Smith?",
        "ground_truth": "SELECT avg(T2.gradepoint) FROM ENROLLED_IN AS T1 JOIN GRADECONVERSION AS T2 JOIN STUDENT AS T3 ON T1.Grade  =  T2.lettergrade AND T1.StuID  =  T3.StuID WHERE T3.LName  =  \"Smith\"",
        "amends": [
            "Do use `avg(T2.gradepoint)` instead of `AVG(grade)` to calculate the average from the correct table and column. Do join three tables `ENROLLED_IN AS T1`, `GRADECONVERSION AS T2`, and `STUDENT AS T3` instead of querying only the `students` table. Do apply join conditions `T1.Grade = T2.lettergrade` and `T1.StuID = T3.StuID` instead of no join conditions. Do filter on `T3.LName = \"Smith\"` instead of `first_name = 'Smith'` to use the correct column name and table. Do remove the incorrect table reference `students` and add the proper table aliases and relationships. The amended query now correctly calculates the average grade point for students with last name Smith by properly joining the enrollment, grade conversion, and student tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(grade) FROM students WHERE first_name = 'Smith';",
            "SELECT AVG(T2.gradepoint) \nFROM Enrolled_in AS T1\nJOIN Gradeconversion AS T2 ON T1.Grade = T2.lettergrade\nJOIN Student AS T3 ON T1.StuID = T3.StuID\nWHERE T3.LName = 'Smith'"
        ],
        "rule_sql": []
    },
    "886": {
        "db_id": "chinook_1",
        "question": "Find the distinct unit prices for tracks.",
        "ground_truth": "SELECT distinct(UnitPrice) FROM TRACK",
        "amends": [
            "Do use `DISTINCT` instead of `GROUP BY` for selecting unique values. Do reference the column as `UnitPrice` instead of `price` to match the correct column name. Do reference the table as `TRACK` instead of `tracks` to match the correct table name. The amended query now correctly selects distinct UnitPrice values from the TRACK table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT price FROM tracks GROUP BY price;",
            "SELECT DISTINCT UnitPrice FROM Track;"
        ],
        "rule_sql": []
    },
    "6314": {
        "db_id": "e_government",
        "question": "Find the payment method and phone of the party with email \"enrico09@example.com\".",
        "ground_truth": "SELECT payment_method_code ,  party_phone FROM parties WHERE party_email  =  \"enrico09@example.com\"",
        "amends": [
            "Do select `payment_method_code` and `party_phone` instead of `payment_method` and `phone`. Do filter on `party_email` instead of `email` and use double quotes for the string literal instead of single quotes. The amended query now correctly references the actual column names and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT payment_method, phone FROM parties WHERE email = 'enrico09@example.com';",
            "SELECT payment_method_code, party_phone FROM Parties WHERE party_email = \"enrico09@example.com\""
        ],
        "rule_sql": []
    },
    "3568": {
        "db_id": "music_1",
        "question": "How many songs were released for each format?",
        "ground_truth": "SELECT count(*) ,  formats FROM files GROUP BY formats",
        "amends": [
            "Do `count(*)` as the first column instead of `format` and do `formats` as the grouping column instead of `artist`. Do use table `files` instead of `songs` and do group by `formats` instead of `artist`. The amended query now correctly counts records by file formats rather than attempting to group songs by artist with an undefined format column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT format, COUNT(*) FROM songs GROUP BY artist;",
            "SELECT COUNT(*) AS song_count, formats FROM files GROUP BY formats;"
        ],
        "rule_sql": []
    },
    "995": {
        "db_id": "university_basketball",
        "question": "What are the average enrollment size of the universities that are founded before 1850?",
        "ground_truth": "SELECT avg(enrollment) FROM university WHERE founded  <  1850",
        "amends": [
            "Do use table name `university` instead of `universities` in the FROM clause. Do change the WHERE filter to `founded < 1850` instead of `founded_year > 1850`, altering both the column reference from `founded_year` to `founded` and the comparison operator from greater-than to less-than. Do use lowercase `avg` function instead of uppercase `AVG` for the aggregate calculation. The amended query now correctly filters for universities founded before 1850 and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(enrollment) FROM universities WHERE founded_year > 1850;",
            "SELECT avg(Enrollment) FROM university WHERE founded < 1850"
        ],
        "rule_sql": []
    },
    "5857": {
        "db_id": "tracking_share_transactions",
        "question": "Show the transaction type descriptions and dates if the share count is smaller than 10.",
        "ground_truth": "SELECT T1.transaction_type_description ,  T2.date_of_transaction FROM Ref_Transaction_Types AS T1 JOIN TRANSACTIONS AS T2 ON T1.transaction_type_code  =  T2.transaction_type_code WHERE T2.share_count  <  10",
        "amends": [
            "Do join `Ref_Transaction_Types AS T1` and `TRANSACTIONS AS T2` instead of querying only the transactions table. Do use `T1.transaction_type_description` and `T2.date_of_transaction` instead of `transaction_type_description` and `date`. Do specify the join condition `ON T1.transaction_type_code = T2.transaction_type_code` instead of omitting the table relationship. Do change the filter to `T2.share_count < 10` instead of `share_count > 10` to use less-than comparison instead of greater-than. The amended query now correctly joins the reference table with transactions and applies the proper filter condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT transaction_type_description, date FROM transactions WHERE share_count > 10;",
            "SELECT T1.transaction_type_description, T2.date_of_transaction \nFROM Ref_Transaction_Types AS T1 \nJOIN Transactions AS T2 ON T1.transaction_type_code = T2.transaction_type_code \nWHERE T2.share_count < 10"
        ],
        "rule_sql": []
    },
    "4206": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "What is the role code with the largest number of employees?",
        "ground_truth": "SELECT role_code FROM Employees GROUP BY role_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `role_code` instead of including `COUNT(*)` in the SELECT list. Do order by `count(*) DESC` instead of `role_code DESC` to correctly identify the role with the highest count. The amended query now matches the intended behavior of finding the role_code with the most employees."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT role_code, COUNT(*) FROM employees GROUP BY role_code ORDER BY role_code DESC LIMIT 1;",
            "SELECT Role_Code FROM Employees GROUP BY Role_Code ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "3963": {
        "db_id": "hospital_1",
        "question": "What are the names of departments that have primarily affiliated physicians.",
        "ground_truth": "SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  1",
        "amends": [
            "Do select `DISTINCT T2.name` instead of `department_name` to return unique department names. Do use `affiliated_with AS T1 JOIN department AS T2` instead of just `departments` to properly join the two required tables. Do specify the join condition `ON T1.department = T2.departmentid` instead of omitting any join logic. Do add the filter `WHERE PrimaryAffiliation = 1` instead of `WHERE physician_count > 0` to check for primary affiliation status rather than physician count. The amended query now correctly identifies departments with primary affiliations rather than those with any physicians, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT department_name FROM departments WHERE physician_count > 0",
            "SELECT DISTINCT T2.Name \nFROM Affiliated_With AS T1 \nJOIN Department AS T2 ON T1.Department = T2.DepartmentID \nWHERE T1.PrimaryAffiliation = 1"
        ],
        "rule_sql": []
    },
    "4343": {
        "db_id": "tracking_grants_for_research",
        "question": "When did researchers start and stop working?",
        "ground_truth": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'",
        "amends": [
            "Do select `date_from` and `date_to` instead of `start_date` and `end_date`. Do use table `Project_Staff` instead of `researchers`. Do add filter `role_code = 'researcher'` instead of omitting it. Do remove `start_date IS NOT NULL` and `end_date IS NOT NULL` filters instead of keeping them. Do remove `ORDER BY start_date` instead of keeping it. The amended query now correctly filters for researcher roles in the Project_Staff table and matches the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT start_date, end_date FROM researchers WHERE start_date IS NOT NULL AND end_date IS NOT NULL ORDER BY start_date;",
            "SELECT date_from, date_to FROM Project_Staff WHERE role_code = 'researcher';"
        ],
        "rule_sql": []
    },
    "4980": {
        "db_id": "soccer_2",
        "question": "Find the name of players whose card is yes in the descending order of training hours.",
        "ground_truth": "SELECT pName FROM Player WHERE yCard  =  'yes' ORDER BY HS DESC",
        "amends": [
            "Do select `pName` instead of `name` and use table `Player` instead of `players`. Do filter on `yCard = 'yes'` instead of `card = 'yes'` and order by `HS DESC` instead of `training_hours ASC`. The amended query now correctly retrieves player names with yes cards ordered by hours in descending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM players WHERE card = 'yes' ORDER BY training_hours ASC;",
            "SELECT pName FROM Player WHERE yCard = 'yes' ORDER BY HS DESC;"
        ],
        "rule_sql": []
    },
    "5871": {
        "db_id": "tracking_share_transactions",
        "question": "Show the average amount of transactions for different lots.",
        "ground_truth": "SELECT T2.lot_id ,  avg(amount_of_transaction) FROM TRANSACTIONS AS T1 JOIN Transactions_Lots AS T2 ON T1.transaction_id  =  T2.transaction_id GROUP BY T2.lot_id",
        "amends": [
            "Do select `T2.lot_id` and `avg(amount_of_transaction)` instead of `lot_id` and `AVG(transaction_amount)`. Do add `JOIN Transactions_Lots AS T2` with `ON T1.transaction_id = T2.transaction_id` instead of omitting the join entirely. Do group by `T2.lot_id` instead of grouping by `transaction_amount`. The amended query now correctly joins the transactions table with transaction lots and calculates average transaction amounts per lot instead of per transaction amount value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT lot_id, AVG(transaction_amount) FROM transactions GROUP BY transaction_amount;",
            "SELECT T2.lot_id, AVG(T1.amount_of_transaction) \nFROM Transactions AS T1\nJOIN Transactions_Lots AS T2 ON T1.transaction_id = T2.transaction_id\nGROUP BY T2.lot_id"
        ],
        "rule_sql": []
    },
    "5058": {
        "db_id": "device",
        "question": "What is the average quantity of stocks?",
        "ground_truth": "SELECT avg(Quantity) FROM stock",
        "amends": [
            "Do use `avg(Quantity)` instead of `AVG(price)` to calculate the average of the quantity column rather than the price column. Do reference table `stock` instead of `stocks` to query from the correct table name. The amended query now correctly calculates the average quantity from the stock table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(price) FROM stocks;",
            "SELECT AVG(Quantity) FROM stock;"
        ],
        "rule_sql": []
    },
    "5798": {
        "db_id": "customer_complaints",
        "question": "Find the last name of the staff whose email address contains \"wrau\".",
        "ground_truth": "SELECT last_name FROM staff WHERE email_address LIKE \"%wrau%\"",
        "amends": [
            "Do select `last_name` instead of `first_name` from the staff table. Do filter on `email_address` instead of `email` using the LIKE pattern `%wrau%` instead of the same pattern. The amended query now correctly retrieves last names based on email address matching instead of first names based on a non-existent email column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM staff WHERE email LIKE '%wrau%'",
            "SELECT last_name FROM Staff WHERE email_address LIKE '%wrau%'"
        ],
        "rule_sql": []
    },
    "1910": {
        "db_id": "protein_institute",
        "question": "How many buildings are there?",
        "ground_truth": "SELECT count(*) FROM building",
        "amends": [
            "Do query the `building` table instead of the `employees` table. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees;",
            "SELECT COUNT(*) FROM building;"
        ],
        "rule_sql": []
    },
    "5260": {
        "db_id": "music_2",
        "question": "Which vocal type has the band mate with first name \"Marianne\" played the most?",
        "ground_truth": "SELECT TYPE FROM vocals AS T1 JOIN band AS T2 ON T1.bandmate  =  T2.id WHERE firstname  =  \"Marianne\" GROUP BY TYPE ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `vocals` and `band` tables on `T1.bandmate = T2.id` instead of querying only `band_mates`. Do filter on `firstname = 'Marianne'` instead of `first_name = 'Marianne'`. Do group by `TYPE` instead of `vocal_type`. Do order by `count(*) DESC` instead of ordering by the alias `count`. Do select only `TYPE` instead of selecting both `vocal_type` and `COUNT(*) as count`. The amended query now correctly joins the vocals and band tables to find Marianne's vocal type with proper grouping and ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT vocal_type, COUNT(*) as count \nFROM band_mates \nWHERE first_name = 'Marianne' \nGROUP BY vocal_type \nORDER BY count DESC \nLIMIT 1;",
            "SELECT v.Type\nFROM Vocals v\nJOIN Band b ON v.Bandmate = b.Id\nWHERE b.Firstname = 'Marianne'\nGROUP BY v.Type\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "6648": {
        "db_id": "driving_school",
        "question": "What is the zip code of staff with first name as Janessa and last name as Sawayn lived?",
        "ground_truth": "SELECT T1.zip_postcode FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id WHERE T2.first_name = \"Janessa\" AND T2.last_name = \"Sawayn\";",
        "amends": [
            "Do select `T1.zip_postcode` from the `Addresses` table instead of `zip_code` from the `staff` table. Do join `Addresses AS T1` with `Staff AS T2` using `ON T1.address_id = T2.staff_address_id` instead of querying only the `staff` table. Do keep the same `WHERE` filter conditions `first_name = 'Janessa'` and `last_name = 'Sawayn'` but apply them to `T2` (the Staff table) instead of directly to the staff table. The amended query now correctly retrieves zip code information from the Addresses table by joining with Staff table using the proper address relationship, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT zip_code FROM staff WHERE first_name = 'Janessa' AND last_name = 'Sawayn';",
            "SELECT T1.zip_postcode \nFROM Addresses AS T1\nJOIN Staff AS T2 ON T1.address_id = T2.staff_address_id\nWHERE T2.first_name = 'Janessa' AND T2.last_name = 'Sawayn'"
        ],
        "rule_sql": []
    },
    "1144": {
        "db_id": "climbing",
        "question": "Show the countries that have mountains with height more than 5600 stories and mountains with height less than 5200.",
        "ground_truth": "SELECT Country FROM mountain WHERE Height  >  5600 INTERSECT SELECT Country FROM mountain WHERE Height  <  5200",
        "amends": [
            "Do use `INTERSECT` to find countries with both `Height > 5600` and `Height < 5200` instead of the impossible condition `height > 5600 AND height < 5200`. Do query the `mountain` table instead of `mountains` and use proper column names `Country` and `Height` instead of lowercase versions. Do split the logic into two separate SELECT statements with the respective height conditions instead of combining them in a single WHERE clause. The amended query now correctly identifies countries that have mountains both taller than 5600 and shorter than 5200, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM mountains WHERE height > 5600 AND height < 5200;",
            "SELECT Country FROM mountain WHERE Height > 5600\nINTERSECT\nSELECT Country FROM mountain WHERE Height < 5200"
        ],
        "rule_sql": []
    },
    "5501": {
        "db_id": "voter_2",
        "question": "How many students does each advisor have?",
        "ground_truth": "SELECT Advisor ,  count(*) FROM STUDENT GROUP BY Advisor",
        "amends": [
            "Do reference the `Advisor` column instead of `advisor_id` in both the SELECT list and GROUP BY clause. Do use the correct table name `STUDENT` instead of `students` in the FROM clause. Do group by `Advisor` instead of `student_id` to properly aggregate counts by advisor rather than by individual students. The amended query now correctly counts students grouped by their advisor rather than attempting to group by student IDs while counting, which would produce incorrect results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT advisor_id, COUNT(*) FROM students GROUP BY student_id;",
            "SELECT Advisor, COUNT(*) AS student_count FROM Student GROUP BY Advisor;"
        ],
        "rule_sql": []
    },
    "6336": {
        "db_id": "e_government",
        "question": "Find the name of organizations whose names contain \"Party\".",
        "ground_truth": "SELECT organization_name FROM organizations WHERE organization_name LIKE \"%Party%\"",
        "amends": [
            "Do reference `organization_name` in the SELECT list instead of `name`. Do use double quotes for the string pattern instead of single quotes. The amended query now correctly selects the organization_name column with proper quoting, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM organizations WHERE name LIKE '%Party%';",
            "SELECT organization_name FROM Organizations WHERE organization_name LIKE \"%Party%\""
        ],
        "rule_sql": []
    },
    "2633": {
        "db_id": "inn_1",
        "question": "What are the name and id of the three highest priced rooms?",
        "ground_truth": "SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT 3;",
        "amends": [
            "Do select `RoomId` and `roomName` instead of `name` and `id`. Do reference table `Rooms` instead of `rooms`. Do order by `basePrice DESC` instead of `price ASC` while maintaining the same `LIMIT 3` clause. The amended query now correctly selects the specified columns from the proper table with the intended sorting direction."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, id FROM rooms ORDER BY price ASC LIMIT 3;",
            "SELECT RoomId, roomName FROM Rooms ORDER BY basePrice DESC LIMIT 3;"
        ],
        "rule_sql": []
    },
    "1018": {
        "db_id": "university_basketball",
        "question": "Return the maximum enrollment across all schools.",
        "ground_truth": "SELECT max(Enrollment) FROM university",
        "amends": [
            "Do use `max(Enrollment)` instead of `MIN(enrollment)` to select the maximum enrollment value rather than the minimum. Do reference the `university` table instead of the `schools` table to query from the correct data source. The amended query now correctly retrieves the maximum enrollment value from the university table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(enrollment) FROM schools;",
            "SELECT MAX(Enrollment) FROM university;"
        ],
        "rule_sql": []
    },
    "1494": {
        "db_id": "debate",
        "question": "What are the date and venue of each debate?",
        "ground_truth": "SELECT Date ,  Venue FROM debate",
        "amends": [
            "Do reference the table as `debate` instead of `debates` to match the correct table name. Do capitalize column names as `Date` and `Venue` instead of lowercase `date` and `venue` to match the correct column naming convention. Do remove the `WHERE date IS NOT NULL AND venue IS NOT NULL` filter instead of keeping it, as the right query does not include these null checks. Do remove the `ORDER BY date DESC` clause instead of including it, as the right query does not specify any ordering. The amended query now correctly selects from the debate table with proper column capitalization and without unnecessary filtering or sorting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT date, venue FROM debates WHERE date IS NOT NULL AND venue IS NOT NULL ORDER BY date DESC",
            "SELECT Date, Venue FROM debate"
        ],
        "rule_sql": []
    },
    "4261": {
        "db_id": "club_1",
        "question": "Return the last name for the members of the club named \"Hopkins Student Enterprises\".",
        "ground_truth": "SELECT t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Hopkins Student Enterprises\"",
        "amends": [
            "Do select `t3.lname` instead of `first_name` to retrieve the correct column from the student table. Do join three tables `club`, `member_of_club`, and `student` instead of querying only the `members` table to properly establish relationships through foreign keys. Do use `INNER JOIN` with `t1.clubid = t2.clubid` and `t2.stuid = t3.stuid` instead of no joins to correctly link club membership data. Do filter on `t1.clubname` instead of `club_name` using the proper table alias and column name. The amended query now correctly retrieves student last names for the specified club by properly joining the relational tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM members WHERE club_name = 'Hopkins Student Enterprises'",
            "SELECT t3.LName \nFROM Club t1\nINNER JOIN Member_of_club t2 ON t1.ClubID = t2.ClubID\nINNER JOIN Student t3 ON t2.StuID = t3.StuID\nWHERE t1.ClubName = 'Hopkins Student Enterprises'"
        ],
        "rule_sql": []
    },
    "6824": {
        "db_id": "flight_4",
        "question": "In how many cities are there airports in the country of Greenland?",
        "ground_truth": "SELECT count(DISTINCT city) FROM airports WHERE country  =  'Greenland'",
        "amends": [
            "Do `count(DISTINCT city)` instead of `COUNT(*)` to count distinct cities instead of all rows. Do keep the `WHERE country = 'Greenland'` filter unchanged. The amended query now correctly counts unique cities in Greenland instead of total airport records, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM airports WHERE country = 'Greenland';",
            "SELECT COUNT(DISTINCT city) FROM airports WHERE country = 'Greenland';"
        ],
        "rule_sql": []
    },
    "793": {
        "db_id": "coffee_shop",
        "question": "Find the purchase time, age and address of each member, and show the results in the order of purchase time.",
        "ground_truth": "SELECT Time_of_purchase ,  age ,  address FROM member ORDER BY Time_of_purchase",
        "amends": [
            "Do reference `Time_of_purchase` instead of `purchase_time` in the SELECT list and ORDER BY clause. Do use table name `member` instead of `members` in the FROM clause. Do order by `Time_of_purchase` instead of `age` to match the intended sorting logic. The amended query now correctly retrieves purchase time, age, and address data from the member table sorted by purchase time."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT purchase_time, age, address FROM members ORDER BY age;",
            "SELECT Time_of_purchase, Age, Address FROM member ORDER BY Time_of_purchase;"
        ],
        "rule_sql": []
    },
    "1402": {
        "db_id": "college_2",
        "question": "Find the number of courses provided in each semester and year.",
        "ground_truth": "SELECT count(*) ,  semester ,  YEAR FROM SECTION GROUP BY semester ,  YEAR",
        "amends": [
            "Do use the table name `SECTION` instead of `courses` in the FROM clause. Do include `YEAR` in both the SELECT list and GROUP BY clause instead of omitting it from the GROUP BY. Do place the `count(*)` expression first in the SELECT list instead of third. Do group by both `semester` and `YEAR` instead of only `semester` to ensure proper aggregation by both academic period dimensions. The amended query now correctly aggregates course counts by both semester and year from the SECTION table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT semester, year, COUNT(*) FROM courses GROUP BY semester;",
            "SELECT COUNT(*) AS course_count, semester, year FROM section GROUP BY semester, year ORDER BY year, semester;"
        ],
        "rule_sql": []
    },
    "2737": {
        "db_id": "election",
        "question": "What are the name and population of each county?",
        "ground_truth": "SELECT County_name ,  Population FROM county",
        "amends": [
            "Do select `County_name` and `Population` instead of `name` and `population`. Do query from `county` table instead of `states` table. The amended query now correctly retrieves county data from the appropriate table with the correct column names."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, population FROM states;",
            "SELECT County_name, Population FROM county;"
        ],
        "rule_sql": []
    },
    "5557": {
        "db_id": "products_gen_characteristics",
        "question": "Count the number of different characteristic names the product 'cumin' has.",
        "ground_truth": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  \"sesame\"",
        "amends": [
            "Do use `count(DISTINCT t3.characteristic_name)` instead of `COUNT(*)` to count distinct characteristics rather than all rows. Do join `products AS t1` instead of querying only the characteristics table to properly relate products to their characteristics. Do add `product_characteristics AS t2` with join condition `t1.product_id = t2.product_id` instead of omitting this intermediate relationship table. Do add `CHARACTERISTICS AS t3` with join condition `t2.characteristic_id = t3.characteristic_id` instead of querying characteristics directly without proper relationships. Do filter on `t1.product_name = \"sesame\"` instead of `product_name = 'cumin'` to query the correct product. The amended query now correctly counts distinct characteristics for the specified product by properly navigating the relational schema."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM characteristics WHERE product_name = 'cumin';",
            "SELECT COUNT(DISTINCT t3.characteristic_name) \nFROM products AS t1\nJOIN product_characteristics AS t2 ON t1.product_id = t2.product_id\nJOIN characteristics AS t3 ON t2.characteristic_id = t3.characteristic_id\nWHERE t1.product_name = 'sesame'"
        ],
        "rule_sql": []
    },
    "653": {
        "db_id": "journal_committee",
        "question": "Show the names of editors of age either 24 or 25.",
        "ground_truth": "SELECT Name FROM editor WHERE Age  =  24 OR Age  =  25",
        "amends": [
            "Do reference table `editor` instead of `editors` and use column names `Name` and `Age` instead of `name` and `age` to match the correct schema. The amended query now correctly selects from the proper table with the appropriate column names while maintaining the same filtering logic for ages 24 and 25."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM editors WHERE age = 24 OR age = 25;",
            "SELECT Name FROM editor WHERE Age = 24 OR Age = 25;"
        ],
        "rule_sql": []
    },
    "1124": {
        "db_id": "climbing",
        "question": "What is the name of the highest mountain?",
        "ground_truth": "SELECT Name FROM mountain ORDER BY Height DESC LIMIT 1",
        "amends": [
            "Do reference table `mountain` instead of `mountains` in the FROM clause. Do select column `Name` instead of `name` in the SELECT list. Do order by `Height DESC` instead of `height ASC` in the ORDER BY clause. The amended query now correctly retrieves the highest mountain from the proper table with appropriate column references and descending sort order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM mountains ORDER BY height ASC LIMIT 1;",
            "SELECT Name FROM mountain ORDER BY Height DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5520": {
        "db_id": "products_gen_characteristics",
        "question": "How many characteristics are there?",
        "ground_truth": "SELECT count(*) FROM CHARACTERISTICS",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM characteristics;"
        ],
        "rule_sql": []
    },
    "2364": {
        "db_id": "csu_1",
        "question": "How many campuses are there in Los Angeles county?",
        "ground_truth": "SELECT count(*) FROM campuses WHERE county  =  \"Los Angeles\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM campuses WHERE county = 'Los Angeles';"
        ],
        "rule_sql": []
    },
    "2453": {
        "db_id": "movie_1",
        "question": "In what years did a movie receive a 4 or 5 star rating, and list the years from oldest to most recently?",
        "ground_truth": "SELECT DISTINCT YEAR FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID WHERE T2.stars  >=  4 ORDER BY T1.year",
        "amends": [
            "Do add `DISTINCT` instead of omitting it to eliminate duplicate years. Do join `Rating AS T2` on `T1.mID = T2.mID` instead of querying only the `movies` table. Do reference `T2.stars` in the WHERE filter instead of `rating` to correctly access the rating column from the joined table. Do use table alias `T1.year` in SELECT and ORDER BY instead of just `year` for proper column qualification. The amended query now correctly retrieves distinct years from movies that have ratings of 4 stars or higher, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year FROM movies WHERE rating >= 4 ORDER BY year ASC;",
            "SELECT DISTINCT T1.year \nFROM Movie AS T1 \nJOIN Rating AS T2 ON T1.mID = T2.mID \nWHERE T2.stars >= 4 \nORDER BY T1.year ASC"
        ],
        "rule_sql": []
    },
    "2324": {
        "db_id": "csu_1",
        "question": "Report the name of all campuses in Los Angeles county.",
        "ground_truth": "SELECT campus FROM campuses WHERE county  =  \"Los Angeles\"",
        "amends": [
            "Do select `campus` instead of `name` to use the correct column name that matches the schema. Do use double quotes `\"Los Angeles\"` instead of single quotes `'Los Angeles'` for the string literal in the WHERE filter, though this may be a cosmetic difference depending on SQL dialect string handling conventions. The amended query now correctly retrieves the campus column from the campuses table filtered by Los Angeles county, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM campuses WHERE county = 'Los Angeles'",
            "SELECT Campus FROM Campuses WHERE County = \"Los Angeles\""
        ],
        "rule_sql": []
    },
    "6640": {
        "db_id": "driving_school",
        "question": "How many staff in total?",
        "ground_truth": "SELECT count(*) FROM Staff;",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers;"
        ],
        "rule_sql": []
    },
    "2726": {
        "db_id": "storm_record",
        "question": "Show all storm names affecting region \"Denmark\".",
        "ground_truth": "SELECT T3.name FROM affected_region AS T1 JOIN region AS T2 ON T1.region_id  =  T2.region_id JOIN storm AS T3 ON T1.storm_id  =  T3.storm_id WHERE T2.region_name  =  'Denmark'",
        "amends": [
            "Do use `T3.name` from the `storm` table instead of `name` from a non-existent `storms` table. Do join `affected_region AS T1` and `region AS T2` on `T1.region_id = T2.region_id` instead of querying a single table. Do add a second join to `storm AS T3` on `T1.storm_id = T3.storm_id` instead of missing the necessary table relationships. Do filter on `T2.region_name = 'Denmark'` instead of `region = 'Denmark'` to use the correct column name and table reference. The amended query now correctly retrieves storm names by properly joining through the region relationship tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM storms WHERE region = 'Denmark';",
            "SELECT T3.Name \nFROM affected_region AS T1\nJOIN region AS T2 ON T1.Region_id = T2.Region_id\nJOIN storm AS T3 ON T1.Storm_ID = T3.Storm_ID\nWHERE T2.Region_name = 'Denmark'"
        ],
        "rule_sql": []
    },
    "3746": {
        "db_id": "program_share",
        "question": "what are the names of the channels that broadcast in both morning and night?",
        "ground_truth": "SELECT t1.name FROM channel AS t1 JOIN broadcast AS t2 ON t1.channel_id  =  t2.channel_id WHERE t2.time_of_day  =  'Morning' INTERSECT SELECT t1.name FROM channel AS t1 JOIN broadcast AS t2 ON t1.channel_id  =  t2.channel_id WHERE t2.time_of_day  =  'Night'",
        "amends": [
            "Do use `JOIN` between `channel` and `broadcast` tables instead of querying only `channels`. Do reference `t2.time_of_day` column instead of `broadcast_time`. Do use `INTERSECT` to find channels broadcasting in both time periods instead of impossible `AND` condition with same column having two values. Do filter for `'Morning'` in first query and `'Night'` in second query instead of trying to match both values simultaneously. Do select `t1.name` from the joined tables instead of `channel_name` from a single table. The amended query now correctly identifies channels that broadcast during both morning and night time periods."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT channel_name FROM channels WHERE broadcast_time = 'morning' AND broadcast_time = 'night';",
            "SELECT t1.Name \nFROM channel t1 \nJOIN broadcast t2 ON t1.Channel_ID = t2.Channel_ID \nWHERE t2.Time_of_day = 'Morning'\nINTERSECT\nSELECT t1.Name \nFROM channel t1 \nJOIN broadcast t2 ON t1.Channel_ID = t2.Channel_ID \nWHERE t2.Time_of_day = 'Night'"
        ],
        "rule_sql": []
    },
    "5187": {
        "db_id": "music_2",
        "question": "What are the names of all songs produced by the artist with the first name \"Marianne\"?",
        "ground_truth": "SELECT T3.Title FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId WHERE T2.firstname  =  \"Marianne\"",
        "amends": [
            "Do select `T3.Title` instead of `s.name` and use table aliases `T1`, `T2`, `T3` instead of `s`, `a`. Do join `Performance AS T1` with `Band AS T2` on `T1.bandmate = T2.id` instead of joining `songs s` with `artists a` on `s.artist_id = a.id`. Do add a second join to `Songs AS T3` on `T3.SongId = T1.SongId` instead of omitting it. Do filter on `T2.firstname = \"Marianne\"` instead of `a.first_name = 'Marianne'` and use double quotes instead of single quotes for the string literal. The amended query now correctly navigates through the Performance-Band-Songs relationship to find songs performed by band members named Marianne, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.name FROM songs s JOIN artists a ON s.artist_id = a.id WHERE a.first_name = 'Marianne';",
            "SELECT T3.Title \nFROM Performance AS T1\nJOIN Band AS T2 ON T1.Bandmate = T2.Id\nJOIN Songs AS T3 ON T3.SongId = T1.SongId\nWHERE T2.Firstname = \"Marianne\""
        ],
        "rule_sql": []
    },
    "3323": {
        "db_id": "college_1",
        "question": "Find the first names and degree of all professors who are teaching some class in Computer Info. Systems department.",
        "ground_truth": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'",
        "amends": [
            "Do use `DISTINCT T2.emp_fname, T3.prof_high_degree` instead of `first_name, degree` to select specific columns with uniqueness. Do join four tables `CLASS AS T1`, `employee AS T2`, `professor AS T3`, and `department AS T4` instead of querying only `professors` with proper join conditions: `T1.prof_num = T2.emp_num`, `T2.emp_num = T3.emp_num`, and `T4.dept_code = T3.dept_code` instead of a simple table reference. Do filter on `T4.dept_name = 'Computer Info. Systems'` instead of `department = 'Computer Info. Systems'` to use the correct table relationship. The amended query now correctly retrieves distinct employee first names and highest degrees by properly joining across the employee-professor-department relationship structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, degree FROM professors WHERE department = 'Computer Info. Systems';",
            "SELECT DISTINCT T2.EMP_FNAME, T3.PROF_HIGH_DEGREE\nFROM CLASS AS T1\nJOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM\nJOIN PROFESSOR AS T3 ON T2.EMP_NUM = T3.EMP_NUM\nJOIN DEPARTMENT AS T4 ON T3.DEPT_CODE = T4.DEPT_CODE\nWHERE T4.DEPT_NAME = 'Computer Info. Systems'"
        ],
        "rule_sql": []
    },
    "1621": {
        "db_id": "customers_and_invoices",
        "question": "Show all product names and the number of customers having an order on each product.",
        "ground_truth": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name",
        "amends": [
            "Do use `JOIN` between `Order_items` and `Products` on `product_id` instead of `LEFT JOIN` between `products` and `orders` on `product_id`. Do add `Orders` table joined to `Order_items` on `order_id` instead of omitting it. Do count all rows with `count(*)` instead of counting `customer_id` which may miss orders without customers. Do reference tables with aliases `T1`, `T2`, `T3` instead of single-letter aliases. Do group by `product_name` from the Products table instead of the original grouping. The amended query now correctly counts all order items per product by properly joining through the order_items bridge table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.product_name, COUNT(o.customer_id) AS customer_count\nFROM products p\nLEFT JOIN orders o ON p.product_id = o.product_id\nGROUP BY p.product_name;",
            "SELECT T3.product_name, COUNT(*) AS number_of_customers\nFROM Order_Items T1\nJOIN Orders T2 ON T1.order_id = T2.order_id\nJOIN Products T3 ON T1.product_id = T3.product_id\nGROUP BY T3.product_name"
        ],
        "rule_sql": []
    },
    "4049": {
        "db_id": "student_1",
        "question": "What are the first names of the teachers who teach grade 1?",
        "ground_truth": "SELECT DISTINCT T2.firstname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE grade  =  1",
        "amends": [
            "Do select `T2.firstname` with `DISTINCT` instead of `first_name` without distinct. Do use `FROM list AS T1 JOIN teachers AS T2` instead of `FROM teachers` alone. Do add join condition `ON T1.classroom = T2.classroom` instead of omitting any join. Do keep `WHERE grade = 1` filter but apply it after joining instead of directly on teachers. The amended query now correctly finds distinct teacher firstnames from classrooms that have grade 1 students, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM teachers WHERE grade = 1;",
            "SELECT DISTINCT T2.FirstName FROM list AS T1 JOIN teachers AS T2 ON T1.Classroom = T2.Classroom WHERE T1.Grade = 1"
        ],
        "rule_sql": []
    },
    "5340": {
        "db_id": "manufactory_1",
        "question": "Select the average price of each manufacturer's products, showing only the manufacturer's code.",
        "ground_truth": "SELECT AVG(Price) ,  Manufacturer FROM Products GROUP BY Manufacturer",
        "amends": [
            "Do use column name `Manufacturer` instead of `manufacturer_code` in both the SELECT list and GROUP BY clause. Do place the aggregate function `AVG(Price)` first in the SELECT list instead of second. Do reference the correct column name `Price` instead of `price` for the average calculation. The amended query now correctly groups by manufacturer and calculates average prices using the proper column names as specified in the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT manufacturer_code, AVG(price) FROM products GROUP BY manufacturer_code",
            "SELECT AVG(Price) AS AveragePrice, Manufacturer FROM Products GROUP BY Manufacturer"
        ],
        "rule_sql": []
    },
    "5440": {
        "db_id": "shop_membership",
        "question": "Find the name of branches where have some members whose hometown is in Louisville, Kentucky and some in Hiram, Georgia.",
        "ground_truth": "SELECT T2.name FROM membership_register_branch AS T1 JOIN branch AS T2 ON T1.branch_id  =  T2.branch_id JOIN member AS T3 ON T1.member_id  =  T3.member_id WHERE T3.Hometown  =  'Louisville ,  Kentucky' INTERSECT SELECT T2.name FROM membership_register_branch AS T1 JOIN branch AS T2 ON T1.branch_id  =  T2.branch_id JOIN member AS T3 ON T1.member_id  =  T3.member_id WHERE T3.Hometown  =  'Hiram ,  Georgia'",
        "amends": [
            "Do use `INTERSECT` to find branches with members from both cities instead of `OR` which finds branches with members from either city. Do reference tables `membership_register_branch`, `branch`, and `member` instead of `branches` and `members`. Do join through `membership_register_branch` with `branch_id` and `member_id` instead of direct `branches` to `members` join. Do use proper column names `T2.name`, `T1.branch_id`, `T2.branch_id`, `T1.member_id`, `T3.member_id`, and `T3.Hometown` instead of `b.name`, `b.id`, `m.branch_id`. Do include spaces in city names `'Louisville , Kentucky'` and `'Hiram , Georgia'` instead of without spaces. Do remove `DISTINCT` since `INTERSECT` inherently returns unique results instead of keeping it. The amended query now correctly identifies branches that have members from both specified hometowns rather than either hometown."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT b.name \nFROM branches b \nJOIN members m ON b.id = m.branch_id \nWHERE m.hometown = 'Louisville, Kentucky' \nOR m.hometown = 'Hiram, Georgia';",
            "SELECT T2.Name\nFROM membership_register_branch T1\nJOIN branch T2 ON T1.Branch_ID = T2.Branch_ID\nJOIN member T3 ON T1.Member_ID = T3.Member_ID\nWHERE T3.Hometown = 'Louisville , Kentucky'\nINTERSECT\nSELECT T2.Name\nFROM membership_register_branch T1\nJOIN branch T2 ON T1.Branch_ID = T2.Branch_ID\nJOIN member T3 ON T1.Member_ID = T3.Member_ID\nWHERE T3.Hometown = 'Hiram , Georgia'"
        ],
        "rule_sql": []
    },
    "608": {
        "db_id": "store_1",
        "question": "How many orders does Luca Mancini have in his invoices?",
        "ground_truth": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = \"Lucas\" AND T1.last_name = \"Mancini\";",
        "amends": [
            "Do use an explicit `JOIN` between `customers` and `invoices` tables instead of a subquery in the `WHERE` clause. Do reference the correct table alias `T1` for the `customers` table instead of the base table name. Do filter on `T1.first_name = \"Lucas\"` instead of `first_name = 'Luca'` to match the correct spelling. Do filter on `T1.last_name = \"Mancini\"` instead of `last_name = 'Mancini'` while maintaining the correct case. Do use double quotes for string literals instead of single quotes for consistency. Do join on `T1.id = T2.customer_id` instead of the subquery approach to properly relate customers to their invoices. The amended query now correctly counts invoices for the specified customer using proper table joins and filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM invoices WHERE customer_id = (SELECT customer_id FROM customers WHERE first_name = 'Luca' AND last_name = 'Mancini');",
            "SELECT COUNT(*) \nFROM customers T1\nJOIN invoices T2 ON T1.id = T2.customer_id\nWHERE T1.first_name = \"Lucas\" AND T1.last_name = \"Mancini\""
        ],
        "rule_sql": []
    },
    "2385": {
        "db_id": "csu_1",
        "question": "How many undergraduates are there at San Jose State",
        "ground_truth": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  \"San Jose State University\"",
        "amends": [
            "Do use `sum(t1.undergraduate)` instead of `COUNT(*)` to aggregate specific enrollment data rather than counting all rows. Do join `discipline_enrollments AS t1` with `campuses AS t2` on `t1.campus = t2.id` instead of querying a single `students` table. Do filter with `t1.year = 2004` instead of omitting any year condition. Do filter with `t2.campus = \"San Jose State University\"` instead of `university = 'San Jose State'` to use the proper campus name from the joined table. Do remove the `level = 'undergraduate'` filter since the undergraduate count is now directly summed from the enrollment column. The amended query now correctly calculates undergraduate enrollment totals for the specified year and campus."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE university = 'San Jose State' AND level = 'undergraduate';",
            "SELECT SUM(t1.Undergraduate) AS total_undergraduates\nFROM discipline_enrollments AS t1\nJOIN Campuses AS t2 ON t1.Campus = t2.Id\nWHERE t1.Year = 2004\nAND t2.Campus = 'San Jose State University'"
        ],
        "rule_sql": []
    },
    "3073": {
        "db_id": "loan_1",
        "question": "What are the different names and credit scores of customers who have taken a loan?",
        "ground_truth": "SELECT DISTINCT T1.cust_name ,  T1.credit_score FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do select `T1.cust_name` and `T1.credit_score` with explicit table aliases instead of `name` and `credit_score` without table qualification. Do join `customer AS T1` with `loan AS T2` on `T1.cust_id = T2.cust_id` instead of querying only the `customers` table. Do remove the `WHERE loan_amount > 0` filter instead of keeping it, as the join condition now properly identifies customers with loans. The amended query now correctly identifies customers who have loans by joining the customer and loan tables, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, credit_score FROM customers WHERE loan_amount > 0",
            "SELECT DISTINCT T1.cust_name, T1.credit_score FROM customer AS T1 JOIN loan AS T2 ON T1.cust_ID = T2.cust_ID"
        ],
        "rule_sql": []
    },
    "6383": {
        "db_id": "flight_company",
        "question": "which countries have more than 2 airports?",
        "ground_truth": "SELECT country FROM airport GROUP BY country HAVING count(*)  >  2",
        "amends": [
            "Do reference the table as `airport` instead of `airports` in the FROM clause, correcting the table name to match the actual schema. Do maintain the identical GROUP BY clause on `country` and HAVING condition with `count(*) > 2` instead of changing any aggregation logic. The amended query now correctly references the single table and matches RIGHT_SQL's behavior.",
            "Do use lowercase `country` in the SELECT list instead of uppercase `Country`, and do remove the `airport_count` alias instead of keeping it. Do use lowercase `country` in the GROUP BY clause instead of uppercase `Country`. The amended query now correctly returns only the country column for countries with more than 2 airports, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM airports GROUP BY country HAVING COUNT(*) > 2",
            "SELECT Country, COUNT(*) as airport_count FROM airport GROUP BY Country HAVING COUNT(*) > 2",
            "SELECT country FROM airport GROUP BY country HAVING COUNT(*) > 2"
        ],
        "rule_sql": []
    },
    "5373": {
        "db_id": "tracking_software_problems",
        "question": "Find the ids of the problems reported after 1978-06-26.",
        "ground_truth": "SELECT problem_id FROM problems WHERE date_problem_reported > \"1978-06-26\"",
        "amends": [
            "Do select `problem_id` instead of `id` for the column name. Do use `date_problem_reported` instead of `reported_date` for the date column. Do apply `>` (greater than) comparison instead of `<` (less than) for the date filter. Do use double quotes `\"1978-06-26\"` instead of single quotes `'1978-06-26'` for the date literal. The amended query now correctly selects the appropriate column with the proper date comparison to match the intended logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM problems WHERE reported_date < '1978-06-26';",
            "SELECT problem_id FROM Problems WHERE date_problem_reported > \"1978-06-26\""
        ],
        "rule_sql": []
    },
    "3916": {
        "db_id": "hospital_1",
        "question": "What is the name of the patient who made the most recent appointment?",
        "ground_truth": "SELECT T1.name FROM patient AS T1 JOIN appointment AS T2 ON T1.ssn = T2.patient ORDER BY T2.start DESC LIMIT 1",
        "amends": [
            "Do select `T1.name` with table alias qualification instead of unqualified `name`. Do add `FROM patient AS T1 JOIN appointment AS T2` with explicit table aliases instead of the single table `FROM patients`. Do specify the join condition `ON T1.ssn = T2.patient` to properly relate patient and appointment tables instead of omitting the join entirely. Do order by `T2.start DESC` using the appointment start time instead of the non-existent `appointment_date` column. The amended query now correctly retrieves the most recent appointment patient by joining the tables and using the proper datetime field for sorting, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM patients ORDER BY appointment_date DESC LIMIT 1;",
            "SELECT T1.Name \nFROM Patient AS T1 \nJOIN Appointment AS T2 ON T1.SSN = T2.Patient \nORDER BY T2.Start DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "2598": {
        "db_id": "inn_1",
        "question": "What is the total number of people who could stay in the modern rooms in this inn?",
        "ground_truth": "SELECT sum(maxOccupancy) FROM Rooms WHERE decor  =  'modern';",
        "amends": [
            "Do use `sum(maxOccupancy)` instead of `SUM(capacity)` for the aggregate function and column reference. Do reference table `Rooms` instead of `rooms` for the correct table name. Do filter on `decor = 'modern'` instead of `room_type = 'modern'` for the appropriate column condition. The amended query now correctly calculates the total maximum occupancy for modern-decorated rooms rather than summing capacity based on room type."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(capacity) FROM rooms WHERE room_type = 'modern';",
            "SELECT SUM(maxOccupancy) FROM Rooms WHERE decor = 'modern';"
        ],
        "rule_sql": []
    },
    "2295": {
        "db_id": "entrepreneur",
        "question": "List the names of people that are not entrepreneurs.",
        "ground_truth": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM entrepreneur)",
        "amends": [
            "Do select `Name` instead of `name` in the SELECT list. Do change the WHERE filter to use `People_ID NOT IN` with a subquery selecting `People_ID FROM entrepreneur` instead of filtering directly on `occupation = 'entrepreneur'`. The amended query now correctly identifies people who are not entrepreneurs by checking against a dedicated entrepreneur table rather than relying on an occupation field, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM people WHERE occupation = 'entrepreneur';",
            "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM entrepreneur)"
        ],
        "rule_sql": []
    },
    "5558": {
        "db_id": "products_gen_characteristics",
        "question": "What are all the characteristic names of product \"sesame\"?",
        "ground_truth": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  \"sesame\"",
        "amends": [
            "Do add explicit table aliases and joins instead of querying a single table. Do join `products AS t1` with `product_characteristics AS t2` on `t1.product_id = t2.product_id` instead of omitting this relationship. Do join `CHARACTERISTICS AS t3` on `t2.characteristic_id = t3.characteristic_id` instead of missing this necessary table connection. Do select `t3.characteristic_name` from the CHARACTERISTICS table instead of directly from products where this column doesn't exist. Do maintain the WHERE filter on `t1.product_name = 'sesame'` but with proper table qualification. The amended query now correctly retrieves characteristic names through proper table relationships instead of attempting to access non-existent columns."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT characteristic_name FROM products WHERE product_name = 'sesame'",
            "SELECT t3.characteristic_name\nFROM products AS t1\nJOIN product_characteristics AS t2 ON t1.product_id = t2.product_id\nJOIN characteristics AS t3 ON t2.characteristic_id = t3.characteristic_id\nWHERE t1.product_name = 'sesame'"
        ],
        "rule_sql": []
    },
    "6478": {
        "db_id": "scientist_1",
        "question": "What is the average hours across all projects?",
        "ground_truth": "SELECT avg(hours) FROM projects",
        "amends": [
            "Do use `avg(hours)` in the SELECT list instead of `AVG(project_name)` to calculate the average of the hours column rather than attempting to average a text-based project_name field. This change correctly aggregates numeric data instead of applying an aggregate function to a non-numeric column that would produce incorrect results or errors."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(project_name) FROM projects;",
            "SELECT AVG(Hours) FROM Projects;"
        ],
        "rule_sql": []
    },
    "1711": {
        "db_id": "epinions_1",
        "question": "Find the name of the user who gave the highest rating.",
        "ground_truth": "SELECT T1.name FROM useracct AS T1 JOIN review AS T2 ON T1.u_id  =  T2.u_id ORDER BY T2.rating DESC LIMIT 1",
        "amends": [
            "Do add `T1.name` from the `useracct AS T1` table instead of selecting just `name` from `users`. Do add a `JOIN` with `review AS T2` on `T1.u_id = T2.u_id` instead of querying only the `users` table. Do order by `T2.rating DESC` instead of `rating DESC` to reference the joined table's rating column. The amended query now correctly joins user account and review data to find the highest-rated user based on review ratings rather than assuming a rating column exists in the users table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM users ORDER BY rating DESC LIMIT 1;",
            "SELECT T1.name FROM useracct AS T1 JOIN review AS T2 ON T1.u_id = T2.u_id ORDER BY T2.rating DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "309": {
        "db_id": "product_catalog",
        "question": "Find all the catalog publishers whose name contains \"Murray\"",
        "ground_truth": "SELECT distinct(catalog_publisher) FROM catalogs WHERE catalog_publisher LIKE \"%Murray%\"",
        "amends": [
            "Do select `distinct(catalog_publisher)` instead of `*` to return only unique publisher names rather than all columns. Do query from `catalogs` table instead of `publishers` to access the correct data source containing publisher information. Do use the column `catalog_publisher` instead of `name` to reference the appropriate publisher name field. Do maintain the `LIKE \"%Murray%\"` filter pattern to preserve the search logic for Murray-related publishers. The amended query now correctly retrieves distinct publisher names from the catalogs table matching the specified pattern."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM publishers WHERE name LIKE '%Murray%';",
            "SELECT DISTINCT catalog_publisher FROM Catalogs WHERE catalog_publisher LIKE '%Murray%'"
        ],
        "rule_sql": []
    },
    "5721": {
        "db_id": "dorm_1",
        "question": "How many dorms are there and what is the total capacity for each gender?",
        "ground_truth": "SELECT count(*) ,  sum(student_capacity) ,  gender FROM dorm GROUP BY gender",
        "amends": [
            "Do use `count(*)` without an alias instead of `COUNT(*) as dorm_count`, and do use `sum(student_capacity)` instead of `SUM(capacity)`. Do reference the table as `dorm` instead of `dorms`, and do place `gender` at the end of the SELECT list instead of at the beginning. The amended query now correctly references the table name and column names to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gender, COUNT(*) as dorm_count, SUM(capacity) as total_capacity FROM dorms GROUP BY gender;",
            "SELECT COUNT(*) as dorm_count, SUM(student_capacity), gender FROM Dorm GROUP BY gender;"
        ],
        "rule_sql": []
    },
    "386": {
        "db_id": "flight_1",
        "question": "What are the numbers of all flights coming from Los Angeles?",
        "ground_truth": "SELECT flno FROM Flight WHERE origin  =  \"Los Angeles\"",
        "amends": [
            "Do reference the `flno` column instead of `flight_number` and use the `Flight` table instead of `flights`. Do use the `origin` column filter instead of `departure_city` and use double quotes around 'Los Angeles' instead of single quotes. The amended query now correctly retrieves flight numbers from the Flight table where the origin is Los Angeles, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_city = 'Los Angeles';",
            "SELECT flno FROM flight WHERE origin = \"Los Angeles\";"
        ],
        "rule_sql": []
    },
    "3093": {
        "db_id": "behavior_monitoring",
        "question": "Return the cell phone number and email address for all students.",
        "ground_truth": "SELECT cell_mobile_number ,  email_address FROM STUDENTS",
        "amends": [
            "Do select `cell_mobile_number` and `email_address` instead of `phone_number` and `email`. Do filter on the correct column name `cell_mobile_number` instead of the incorrect `phone_number` with `phone_type` condition. The amended query now correctly retrieves mobile contact information from the STUDENTS table as intended."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT phone_number, email FROM students WHERE phone_type = 'landline';",
            "SELECT cell_mobile_number, email_address FROM Students;"
        ],
        "rule_sql": []
    },
    "5215": {
        "db_id": "music_2",
        "question": "How many different instruments does the musician with the last name \"Heilo\" use?",
        "ground_truth": "SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN Band AS T2 ON T1.bandmateid  =  T2.id WHERE T2.lastname  =  \"Heilo\"",
        "amends": [
            "Do select `count(DISTINCT instrument)` instead of `COUNT(*)`. Do join `instruments AS T1` with `Band AS T2` on `T1.bandmateid = T2.id` instead of querying only the `musicians` table. Do filter on `T2.lastname = \"Heilo\"` instead of `last_name = 'Heilo'`. The amended query now correctly counts distinct instruments played by band members with the last name Heilo instead of counting all musicians with that last name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM musicians WHERE last_name = 'Heilo';",
            "SELECT COUNT(DISTINCT T1.Instrument) \nFROM Instruments AS T1 \nJOIN Band AS T2 ON T1.BandmateId = T2.Id \nWHERE T2.Lastname = 'Heilo'"
        ],
        "rule_sql": []
    },
    "6809": {
        "db_id": "flight_4",
        "question": "How many airlines does Russia has?",
        "ground_truth": "SELECT count(*) FROM airlines WHERE country  =  'Russia'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM airlines WHERE country = 'Russia';"
        ],
        "rule_sql": []
    },
    "2115": {
        "db_id": "cre_Doc_Control_Systems",
        "question": "What is the name of the shipping agent of the document with id 2?",
        "ground_truth": "SELECT Ref_Shipping_Agents.shipping_agent_name FROM Ref_Shipping_Agents JOIN Documents ON Documents.shipping_agent_code = Ref_Shipping_Agents.shipping_agent_code WHERE Documents.document_id = 2;",
        "amends": [
            "Do select `shipping_agent_name` from `Ref_Shipping_Agents` instead of `agent_name` from `shipping_agents`. Do join `Documents` on `Documents.shipping_agent_code = Ref_Shipping_Agents.shipping_agent_code` instead of querying only the `shipping_agents` table. Do filter on `Documents.document_id = 2` instead of filtering directly on the shipping agent table. The amended query now correctly joins the documents table to retrieve the shipping agent name associated with a specific document ID, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT agent_name FROM shipping_agents WHERE document_id = 2;",
            "SELECT rsa.shipping_agent_name \nFROM Ref_Shipping_Agents rsa\nJOIN Documents d ON rsa.shipping_agent_code = d.shipping_agent_code\nWHERE d.document_id = 2;"
        ],
        "rule_sql": []
    },
    "4283": {
        "db_id": "club_1",
        "question": "What is the description of the club \"Pen and Paper Gaming\"?",
        "ground_truth": "SELECT clubdesc FROM club WHERE clubname  =  \"Pen and Paper Gaming\"",
        "amends": [
            "Do select `clubdesc` instead of `name` and use table `club` instead of `clubs`. Do filter on `clubname = \"Pen and Paper Gaming\"` instead of `description = 'Pen and Paper Gaming'`. The amended query now correctly retrieves the club description from the club table based on the club name filter, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM clubs WHERE description = 'Pen and Paper Gaming';",
            "SELECT clubdesc FROM Club WHERE clubname = 'Pen and Paper Gaming';"
        ],
        "rule_sql": []
    },
    "4012": {
        "db_id": "ship_mission",
        "question": "Please show the most common type of ships.",
        "ground_truth": "SELECT TYPE FROM ship GROUP BY TYPE ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select only `TYPE` instead of both `type` and `COUNT(*) as count`. Do reference table `ship` instead of `ships`. Do order by `COUNT(*) DESC` directly in the ORDER BY clause instead of referencing the alias `count`. The amended query now correctly returns only the ship type with the highest count rather than both the type and count value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT type, COUNT(*) as count FROM ships GROUP BY type ORDER BY count DESC LIMIT 1;",
            "SELECT Type FROM ship GROUP BY Type ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "5240": {
        "db_id": "music_2",
        "question": "What is the last name of the musician that have produced the most songs?",
        "ground_truth": "SELECT T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId GROUP BY lastname ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `Performance` and `Band` on `bandmate=id` and `Songs` on `SongId=SongId` instead of querying only `musicians`. Do select `lastname` from `Band` instead of `last_name` from `musicians`. Do add `GROUP BY lastname` with `count(*)` aggregation instead of ordering by `COUNT(songs.id)` without grouping. Do maintain `ORDER BY count(*) DESC LIMIT 1` to find the musician with most performances. The amended query now correctly identifies the band member with the highest song count through proper table joins and aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT last_name FROM musicians ORDER BY COUNT(songs.id) DESC LIMIT 1;",
            "SELECT b.Lastname \nFROM Performance p\nJOIN Band b ON p.Bandmate = b.Id\nJOIN Songs s ON p.SongId = s.SongId\nGROUP BY b.Lastname\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5041": {
        "db_id": "soccer_2",
        "question": "What are the names of the colleges that are larger than at least one college in Florida?",
        "ground_truth": "SELECT DISTINCT cName FROM college WHERE enr  >  (SELECT min(enr) FROM college WHERE state  =  'FL')",
        "amends": [
            "Do select `cName` instead of `name` and use `DISTINCT` instead of omitting it. Do reference table `college` instead of `colleges` and use column `enr` instead of `size` for the comparison. Do use filter `state = 'FL'` instead of `state = 'Florida'` in the subquery. The amended query now correctly selects distinct college names where enrollment exceeds the minimum enrollment of colleges in Florida."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM colleges WHERE size > (SELECT MIN(size) FROM colleges WHERE state = 'Florida');",
            "SELECT DISTINCT cName FROM College WHERE enr > (SELECT MIN(enr) FROM College WHERE state = 'FL')"
        ],
        "rule_sql": []
    },
    "3747": {
        "db_id": "program_share",
        "question": "Which channels broadcast both in the morning and at night? Give me the channel names.",
        "ground_truth": "SELECT t1.name FROM channel AS t1 JOIN broadcast AS t2 ON t1.channel_id  =  t2.channel_id WHERE t2.time_of_day  =  'Morning' INTERSECT SELECT t1.name FROM channel AS t1 JOIN broadcast AS t2 ON t1.channel_id  =  t2.channel_id WHERE t2.time_of_day  =  'Night'",
        "amends": [
            "Do select `t1.name` from the `channel` table instead of `channel_name` from `broadcasts`. Do join `channel AS t1` with `broadcast AS t2` on `t1.channel_id = t2.channel_id` instead of querying a single table. Do filter for `t2.time_of_day = 'Morning'` in one branch and `t2.time_of_day = 'Night'` in another using INTERSECT instead of using `AND` with contradictory `time = 'morning' AND time = 'night'` conditions. Do use proper table aliases `t1` and `t2` instead of no aliases. Do use correct column names `time_of_day` with proper capitalization instead of `time` with lowercase values. The amended query now correctly finds channels that broadcast during both morning and night times using INTERSECT logic instead of the impossible simultaneous time condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT channel_name FROM broadcasts WHERE time = 'morning' AND time = 'night';",
            "SELECT t1.Name FROM channel AS t1 JOIN broadcast AS t2 ON t1.Channel_ID = t2.Channel_ID WHERE t2.Time_of_day = 'Morning' INTERSECT SELECT t1.Name FROM channel AS t1 JOIN broadcast AS t2 ON t1.Channel_ID = t2.Channel_ID WHERE t2.Time_of_day = 'Night'"
        ],
        "rule_sql": []
    },
    "6760": {
        "db_id": "activity_1",
        "question": "Give me the the first and last name of the faculty who advises the most students.",
        "ground_truth": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.fname` and `T1.lname` with table aliases instead of `first_name` and `last_name` without aliases. Do add `FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID = T2.advisor` with an explicit join condition instead of a single table `FROM faculty`. Do add `GROUP BY T1.FacID` to aggregate by faculty member instead of omitting grouping. Do order by `count(*) DESC` to sort by actual student count instead of the non-existent `student_count` column. The amended query now correctly identifies the faculty member with the most advisees by joining Faculty and Student tables and counting relationships, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM faculty ORDER BY student_count DESC LIMIT 1;",
            "SELECT T1.Fname, T1.Lname\nFROM Faculty AS T1\nJOIN Student AS T2 ON T1.FacID = T2.Advisor\nGROUP BY T1.FacID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5189": {
        "db_id": "music_2",
        "question": "What are the first and last names of the artist who perfomed the song \"Badlands\"?",
        "ground_truth": "SELECT T2.firstname ,  T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId WHERE T3.Title  =  \"Badlands\"",
        "amends": [
            "Do select `T2.firstname` and `T2.lastname` from specific tables instead of `first_name` and `last_name` from a single table. Do use a three-table join structure with `Performance AS T1 JOIN Band AS T2 ON T1.bandmate = T2.id JOIN Songs AS T3 ON T3.SongId = T1.SongId` instead of querying only the `artists` table. Do filter on `T3.Title = \"Badlands\"` with proper table qualification instead of `song_title = 'Badlands'` against an incorrect table. The amended query now correctly joins performance, band, and song data to find band members who performed the specific song, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM artists WHERE song_title = 'Badlands';",
            "SELECT T2.Firstname, T2.Lastname \nFROM Performance AS T1 \nJOIN Band AS T2 ON T1.Bandmate = T2.Id \nJOIN Songs AS T3 ON T3.SongId = T1.SongId \nWHERE T3.Title = 'Badlands'"
        ],
        "rule_sql": []
    },
    "5257": {
        "db_id": "music_2",
        "question": "What are the types of vocals that the musician with the last name \"Heilo\" played in \"Der Kapitan\"?",
        "ground_truth": "SELECT TYPE FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid JOIN band AS T3 ON T1.bandmate  =  T3.id WHERE T3.lastname  =  \"Heilo\" AND T2.title  =  \"Der Kapitan\"",
        "amends": [
            "Do join `vocals AS T1` with `songs AS T2` on `T1.songid = T2.songid` and `band AS T3` on `T1.bandmate = T3.id` instead of querying only `musicians` table. Do filter on `T3.lastname = \"Heilo\"` and `T2.title = \"Der Kapitan\"` instead of `last_name = 'Heilo'` and `song_title = 'Der Kapitan'`. Do select `TYPE` from the joined tables instead of `vocal_type` from a single table. The amended query now correctly retrieves vocal type through proper table relationships instead of relying on incorrect column assumptions in a single table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT vocal_type FROM musicians WHERE last_name = 'Heilo' AND song_title = 'Der Kapitan';",
            "SELECT T1.Type \nFROM Vocals AS T1 \nJOIN Songs AS T2 ON T1.SongId = T2.SongId \nJOIN Band AS T3 ON T1.Bandmate = T3.Id \nWHERE T3.Lastname = 'Heilo' AND T2.Title = 'Der Kapitan'"
        ],
        "rule_sql": []
    },
    "4300": {
        "db_id": "club_1",
        "question": "How many members of \"Bootup Baltimore\" are older than 18?",
        "ground_truth": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.age  >  18",
        "amends": [
            "Do use explicit table joins with `club AS t1 JOIN member_of_club AS t2 ON t1.clubid = t2.clubid JOIN student AS t3 ON t2.stuid = t3.stuid` instead of querying a single `members` table. Do reference the club name through `t1.clubname = \"Bootup Baltimore\"` instead of `organization`. Do filter age through `t3.age > 18` instead of a direct age filter. Do add proper table aliases and join conditions to establish the relationship between club, membership, and student entities instead of assuming a denormalized structure. The amended query now correctly counts students who are members of the specified club and meet the age requirement, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM members WHERE organization = 'Bootup Baltimore' AND age > 18;",
            "SELECT COUNT(*) \nFROM Club AS t1 \nJOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID \nJOIN Student AS t3 ON t2.StuID = t3.StuID \nWHERE t1.ClubName = \"Bootup Baltimore\" \nAND t3.Age > 18"
        ],
        "rule_sql": []
    },
    "5827": {
        "db_id": "workshop_paper",
        "question": "For each college, return the college name and the count of authors with submissions from that college.",
        "ground_truth": "SELECT College ,  COUNT(*) FROM submission GROUP BY College",
        "amends": [
            "Do reference table `submission` instead of `authors` and use column `College` instead of `college_name` in both the SELECT list and GROUP BY clause, while keeping the COUNT(*) aggregation unchanged. The amended query now correctly counts submissions by college rather than authors by college name, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT college_name, COUNT(*) FROM authors GROUP BY college_name;",
            "SELECT College, COUNT(*) FROM submission GROUP BY College;"
        ],
        "rule_sql": []
    },
    "2164": {
        "db_id": "formula_1",
        "question": "What are the different driver ids and nationalities of all drivers who had a laptime of more than 100000 milliseconds?",
        "ground_truth": "SELECT DISTINCT T1.driverid ,  T1.nationality FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid WHERE T2.milliseconds >  100000",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do use fully qualified column references `T1.driverid` and `T1.nationality` instead of unqualified `driver_id` and `nationality`. Do add `JOIN laptimes AS T2` instead of querying only the `drivers` table. Do use join condition `ON T1.driverid = T2.driverid` instead of no join. Do move the filter to use `T2.milliseconds > 100000` instead of `laptime > 100000` on the wrong table. Do add table alias `T1` for the drivers table instead of no alias. The amended query now correctly joins the laptimes table to filter on milliseconds and returns distinct driver information, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT driver_id, nationality FROM drivers WHERE laptime > 100000",
            "SELECT DISTINCT T1.driverId, T1.nationality\nFROM drivers AS T1\nJOIN lapTimes AS T2 ON T1.driverId = T2.driverId\nWHERE T2.milliseconds > 100000"
        ],
        "rule_sql": []
    },
    "4853": {
        "db_id": "local_govt_and_lot",
        "question": "How many different status codes of things are there?",
        "ground_truth": "SELECT count(DISTINCT Status_of_Thing_Code) FROM Timed_Status_of_Things",
        "amends": [
            "Do `count(DISTINCT Status_of_Thing_Code)` instead of `COUNT(*)` to count distinct status codes rather than all rows. Do query from `Timed_Status_of_Things` instead of `things` to access the correct table containing status information. The amended query now correctly counts distinct status codes from the appropriate table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM things;",
            "SELECT COUNT(DISTINCT Status_of_Thing_Code) FROM Timed_Status_of_Things"
        ],
        "rule_sql": []
    },
    "613": {
        "db_id": "store_1",
        "question": "List all different genre types.",
        "ground_truth": "SELECT DISTINCT name FROM genres;",
        "amends": [
            "Do add `DISTINCT` instead of omitting it and do specify `name` instead of `*` in the SELECT list. Do remove the wildcard selection instead of keeping it. The amended query now matches RIGHT_SQL's behavior by returning unique genre names rather than all rows with potential duplicates."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM genres;",
            "SELECT DISTINCT name FROM genres;"
        ],
        "rule_sql": []
    },
    "2628": {
        "db_id": "inn_1",
        "question": "List the name of rooms with king or queen bed.",
        "ground_truth": "SELECT roomName FROM Rooms WHERE bedType  =  \"King\" OR bedType  =  \"Queen\";",
        "amends": [
            "Do reference the `roomName` column instead of `name` and use the correct table name `Rooms` instead of `rooms`. Do use the correct column name `bedType` instead of `bed_type` and the proper case values `\"King\"` and `\"Queen\"` instead of lowercase `'king'` and `'queen'`. The amended query now correctly references the schema elements and matches the intended case-sensitive filtering for king and queen bed types."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM rooms WHERE bed_type = 'king' OR bed_type = 'queen';",
            "SELECT roomName FROM Rooms WHERE bedType = 'King' OR bedType = 'Queen';"
        ],
        "rule_sql": []
    },
    "968": {
        "db_id": "medicine_enzyme_interaction",
        "question": "What are the medicine and trade names that can interact as an inhibitor and activitor with enzymes?",
        "ground_truth": "SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'inhibitor' INTERSECT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'activitor'",
        "amends": [
            "Do join `medicine` and `medicine_enzyme_interaction` tables instead of querying a single `medicines` table. Do use column `T1.name` instead of `medicine_name` and `T1.trade_name` instead of `trade_name`. Do filter with `interaction_type = 'inhibitor'` in one branch and `interaction_type = 'activitor'` in another instead of using `OR` with both conditions. Do use `INTERSECT` to find medicines that are both inhibitors and activators instead of finding medicines that are either inhibitors or activators. Do reference `T2.medicine_id = T1.id` for the join condition instead of the missing join in the original query. The amended query now correctly identifies medicines that interact as both inhibitors and activators rather than those that interact as either type."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT medicine_name, trade_name FROM medicines WHERE interaction_type = 'inhibitor' OR interaction_type = 'activator';",
            "SELECT T1.name, T1.Trade_Name\nFROM medicine T1\nJOIN medicine_enzyme_interaction T2 ON T2.medicine_id = T1.id\nWHERE T2.interaction_type = 'inhibitor'\nINTERSECT\nSELECT T1.name, T1.Trade_Name\nFROM medicine T1\nJOIN medicine_enzyme_interaction T2 ON T2.medicine_id = T1.id\nWHERE T2.interaction_type = 'activitor'"
        ],
        "rule_sql": []
    },
    "5205": {
        "db_id": "music_2",
        "question": "What instruments did the musician with the last name \"Heilo\" play in the song \"Le Pop\"?",
        "ground_truth": "SELECT T4.instrument FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId JOIN Instruments AS T4 ON T4.songid  =  T3.songid AND T4.bandmateid  =  T2.id WHERE T2.lastname  =  \"Heilo\" AND T3.title  =  \"Le Pop\"",
        "amends": [
            "Do join multiple tables including `Performance`, `Band`, `Songs`, and `Instruments` instead of querying only the `musicians` table. Do use explicit `JOIN` syntax with proper join conditions instead of a single table query. Do reference `T4.instrument` from the `Instruments` table instead of `instrument` from a non-existent column in `musicians`. Do filter on `T2.lastname = \"Heilo\"` and `T3.title = \"Le Pop\"` instead of `last_name = 'Heilo'` and `song_name = 'Le Pop'` using the correct column names from the appropriate tables. Do add proper join predicates including `T1.bandmate = T2.id`, `T3.SongId = T1.SongId`, and `T4.songid = T3.songid AND T4.bandmateid = T2.id` instead of omitting the necessary table relationships. The amended query now correctly retrieves instrument information through the proper table relationships and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT instrument FROM musicians WHERE last_name = 'Heilo' AND song_name = 'Le Pop';",
            "SELECT T4.Instrument\nFROM Performance T1\nJOIN Band T2 ON T1.Bandmate = T2.Id\nJOIN Songs T3 ON T1.SongId = T3.SongId\nJOIN Instruments T4 ON T4.SongId = T3.SongId AND T4.BandmateId = T2.Id\nWHERE T2.Lastname = 'Heilo' AND T3.Title = 'Le Pop'"
        ],
        "rule_sql": []
    },
    "746": {
        "db_id": "customers_card_transactions",
        "question": "What are the different account ids that have made financial transactions, as well as how many transactions correspond to each?",
        "ground_truth": "SELECT account_id ,  count(*) FROM Financial_transactions GROUP BY account_id",
        "amends": [
            "Do reference the `Financial_transactions` table instead of the generic `transactions` table. The amended query now correctly matches the RIGHT_SQL's behavior by using the specific table name required for the financial context."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT account_id, COUNT(*) FROM transactions GROUP BY account_id;",
            "SELECT account_id, COUNT(*) AS transaction_count\nFROM Financial_Transactions\nGROUP BY account_id\nORDER BY account_id;"
        ],
        "rule_sql": []
    },
    "6727": {
        "db_id": "activity_1",
        "question": "How many female Professors do we have?",
        "ground_truth": "SELECT count(*) FROM Faculty WHERE Sex  =  'F' AND Rank  =  \"Professor\"",
        "amends": [
            "Do reference table `Faculty` instead of `professors` and use column `Sex` with value `'F'` instead of `gender` with value `'male'`. Do add filter condition `Rank = \"Professor\"` instead of omitting it. The amended query now correctly counts female professors from the Faculty table instead of counting all male individuals from the professors table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM professors WHERE gender = 'male';",
            "SELECT COUNT(*) FROM Faculty WHERE Sex = 'F' AND Rank = 'Professor';"
        ],
        "rule_sql": []
    },
    "3991": {
        "db_id": "hospital_1",
        "question": "What are the names of patients who are not taking the medication of Procrastin-X.",
        "ground_truth": "SELECT name FROM patient EXCEPT SELECT T1.name FROM patient AS T1 JOIN Prescribes AS T2 ON T2.Patient  =  T1.SSN JOIN Medication AS T3 ON T2.Medication  =  T3.Code WHERE T3.name  =  'Procrastin-X'",
        "amends": [
            "Do use `EXCEPT` to exclude patients prescribed 'Procrastin-X' instead of simple inequality filtering. Do add joins to `Prescribes` and `Medication` tables instead of querying only the `patient` table. Do reference `T3.name = 'Procrastin-X'` instead of `medication != 'Procrastin-X'` to properly identify the medication by name rather than assuming a direct column. Do use table aliases `T1`, `T2`, and `T3` instead of no aliases. Do join on `T2.Patient = T1.SSN` and `T2.Medication = T3.Code` instead of no join conditions. The amended query now correctly identifies patients who have never been prescribed 'Procrastin-X' by excluding those who appear in the prescription records, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM patients WHERE medication != 'Procrastin-X';",
            "SELECT T1.Name\nFROM Patient T1\nEXCEPT\nSELECT T1.Name\nFROM Patient T1\nJOIN Prescribes T2 ON T2.Patient = T1.SSN\nJOIN Medication T3 ON T2.Medication = T3.Code\nWHERE T3.Name = 'Procrastin-X'"
        ],
        "rule_sql": []
    },
    "161": {
        "db_id": "bike_1",
        "question": "For each trip, return its ending station's installation date.",
        "ground_truth": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do select `T1.id` instead of `trip_id` and `T2.installation_date` instead of `installation_date`. Do reference `trip AS T1` instead of `trips` and `station AS T2` instead of `stations`. Do join on `T1.end_station_id = T2.id` instead of `trips.start_station_id = stations.station_id`. The amended query now correctly matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT trip_id, installation_date FROM trips JOIN stations ON trips.start_station_id = stations.station_id;",
            "SELECT T1.id, T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id = T2.id"
        ],
        "rule_sql": []
    },
    "4243": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "What are the ids of all the employees who authorize document destruction?",
        "ground_truth": "SELECT DISTINCT Destruction_Authorised_by_Employee_ID FROM Documents_to_be_destroyed",
        "amends": [
            "Do select `Destruction_Authorised_by_Employee_ID` instead of `employee_id`. Do query from `Documents_to_be_destroyed` instead of `employees`. Do remove the `WHERE authorization_type = 'document_creation'` filter instead of keeping it. Do add `DISTINCT` instead of omitting it. The amended query now correctly retrieves unique employee IDs authorized for document destruction from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT employee_id FROM employees WHERE authorization_type = 'document_creation';",
            "SELECT DISTINCT Destruction_Authorised_by_Employee_ID FROM Documents_to_be_Destroyed WHERE Destruction_Authorised_by_Employee_ID IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "2764": {
        "db_id": "election",
        "question": "What are the names of the county that the delegates on \"Appropriations\" committee belong to?",
        "ground_truth": "SELECT T1.County_name FROM county AS T1 JOIN election AS T2 ON T1.County_id  =  T2.District WHERE T2.Committee  =  \"Appropriations\"",
        "amends": [
            "Do select `T1.County_name` from the `county` table instead of `county` from the `delegates` table. Do join with the `election` table as `T2` instead of querying only the `delegates` table. Do use the join condition `T1.County_id = T2.District` instead of no join condition. Do filter on `T2.Committee = \"Appropriations\"` instead of `committee = 'Appropriations'`. The amended query now correctly retrieves county names by joining county and election tables with proper relationship mapping and filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT county FROM delegates WHERE committee = 'Appropriations'",
            "SELECT T1.County_name FROM county T1 JOIN election T2 ON T1.County_Id = T2.District WHERE T2.Committee = 'Appropriations'"
        ],
        "rule_sql": []
    },
    "3178": {
        "db_id": "college_1",
        "question": "What are the first and last name of all biology professors?",
        "ground_truth": "SELECT T3.EMP_FNAME ,  T3.EMP_LNAME FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code JOIN employee AS T3 ON T1.EMP_NUM  =  T3.EMP_NUM WHERE DEPT_NAME  =  \"Biology\"",
        "amends": [
            "Do select `T3.EMP_FNAME` and `T3.EMP_LNAME` from the `employee` table instead of `first_name` and `last_name` from the `professors` table. Do join three tables (`professor`, `department`, and `employee`) with `INNER JOIN` instead of querying only the `professors` table. Do use `T1.dept_code = T2.dept_code` for the first join condition instead of no join conditions. Do use `T1.EMP_NUM = T3.EMP_NUM` for the second join condition instead of no join conditions. Do filter on `DEPT_NAME = \"Biology\"` instead of `department = 'Biology'`. The amended query now correctly retrieves employee names by joining through proper relational links between professor, department, and employee tables, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM professors WHERE department = 'Biology';",
            "SELECT T3.EMP_FNAME, T3.EMP_LNAME \nFROM PROFESSOR T1\nINNER JOIN DEPARTMENT T2 ON T1.DEPT_CODE = T2.DEPT_CODE\nINNER JOIN EMPLOYEE T3 ON T1.EMP_NUM = T3.EMP_NUM\nWHERE T2.DEPT_NAME = 'Biology'"
        ],
        "rule_sql": []
    },
    "744": {
        "db_id": "customers_card_transactions",
        "question": "Return the type of transaction with the highest total amount.",
        "ground_truth": "SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT 1",
        "amends": [
            "Do reference `transaction_type` instead of `type` in the SELECT list and GROUP BY clause. Do reference `sum(transaction_amount)` instead of `SUM(amount) as total_amount` in both the aggregation and ORDER BY clause. Do reference `Financial_transactions` instead of `transactions` as the table source. Do remove the alias `total_amount` instead of keeping it, and do order by the aggregate expression directly instead of using an alias. The amended query now correctly references the proper column names and table while maintaining the same logic to find the transaction type with the highest total amount.",
            "Do remove `SUM(transaction_amount)` from the SELECT list instead of including it, and do change the ORDER BY clause to reference `sum(transaction_amount)` with lowercase function name instead of uppercase `SUM(transaction_amount)`, while keeping the same descending sort order and limit. The amended query now correctly returns only the transaction_type with the highest total transaction amount, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT type, SUM(amount) as total_amount FROM transactions GROUP BY type ORDER BY total_amount DESC LIMIT 1;",
            "SELECT transaction_type, SUM(transaction_amount) \nFROM Financial_Transactions \nGROUP BY transaction_type \nORDER BY SUM(transaction_amount) DESC \nLIMIT 1",
            "SELECT transaction_type\nFROM Financial_Transactions\nGROUP BY transaction_type\nORDER BY sum(transaction_amount) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5876": {
        "db_id": "tracking_share_transactions",
        "question": "Show the transaction type code that occurs the most frequently.",
        "ground_truth": "SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do order by `COUNT(*) DESC` instead of `count ASC` to find the most frequent transaction type rather than the least frequent. Do remove the `COUNT(*) as count` column from the SELECT list instead of including it since only the transaction_type_code is needed in the final output. The amended query now correctly identifies the most common transaction type by counting occurrences in descending order and matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT transaction_type_code, COUNT(*) as count FROM transactions GROUP BY transaction_type_code ORDER BY count ASC LIMIT 1;",
            "SELECT transaction_type_code \nFROM Transactions \nGROUP BY transaction_type_code \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "3634": {
        "db_id": "baseball_1",
        "question": "List the first and last name for players who participated in all star game in 1998.",
        "ground_truth": "SELECT name_first ,  name_last FROM player AS T1 JOIN all_star AS T2 ON T1.player_id  =  T2.player_id WHERE YEAR  =  1998",
        "amends": [
            "Do select `name_first` and `name_last` instead of `first_name` and `last_name`. Do join `player` table with `all_star` table using `LEFT JOIN` on `player_id` instead of querying only the `players` table. Do filter on `YEAR = 1998` in the `all_star` table instead of filtering on `all_star_year = 1998` in the base table. The amended query now correctly retrieves player names for those who were all-stars in 1998 by properly joining the relevant tables and filtering on the correct year column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM players WHERE all_star_year = 1998;",
            "SELECT p.name_first, p.name_last\nFROM player p\nLEFT JOIN all_star a ON p.player_id = a.player_id\nWHERE a.year = 1998;"
        ],
        "rule_sql": []
    },
    "2250": {
        "db_id": "machine_repair",
        "question": "What is the team with at least 2 technicians?",
        "ground_truth": "SELECT Team FROM technician GROUP BY Team HAVING COUNT(*)  >=  2",
        "amends": [
            "Do select `Team` instead of `team_name` and use `GROUP BY Team` instead of filtering without grouping. Do move the count condition to `HAVING COUNT(*) >= 2` instead of using `WHERE COUNT(technicians) >= 2` which is invalid syntax. Do query from `technician` table instead of `teams` table. Do use `COUNT(*)` instead of `COUNT(technicians)` to count all rows per group. The amended query now correctly groups technicians by team and filters for teams with at least two members, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name FROM teams WHERE COUNT(technicians) >= 2;",
            "SELECT Team FROM technician GROUP BY Team HAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "3421": {
        "db_id": "hr_1",
        "question": "what is the phone number of employees whose salary is in the range of 8000 and 12000?",
        "ground_truth": "SELECT phone_number FROM employees WHERE salary BETWEEN 8000 AND 12000",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT phone_number FROM employees WHERE salary BETWEEN 8000 AND 12000;"
        ],
        "rule_sql": []
    },
    "4941": {
        "db_id": "store_product",
        "question": "What is the total population for all the districts that have an area larger tahn the average city area?",
        "ground_truth": "SELECT sum(city_population) FROM district WHERE city_area  >  (SELECT avg(city_area) FROM district)",
        "amends": [
            "Do reference the `district` table instead of `districts` and use `city_population` instead of `population` in the SELECT clause. Do use `city_area` instead of `area` in the WHERE filter instead of the original column name. Do reference the `district` table in the subquery instead of `cities` and use `city_area` instead of `area` in the AVG function. The amended query now correctly calculates the sum of city populations from the district table where city area exceeds the average city area from the same table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(population) FROM districts WHERE area > (SELECT AVG(area) FROM cities);",
            "SELECT SUM(city_population) FROM district WHERE city_area > (SELECT AVG(city_area) FROM district)"
        ],
        "rule_sql": []
    },
    "466": {
        "db_id": "allergy_1",
        "question": "What are the different majors?",
        "ground_truth": "SELECT DISTINCT Major FROM Student",
        "amends": [
            "Do select only `Major` instead of all columns with `*`. Do add `DISTINCT` instead of omitting it to return unique majors. Do reference the correct table name `Student` instead of `students`."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM students;",
            "SELECT DISTINCT Major FROM Student;"
        ],
        "rule_sql": []
    },
    "830": {
        "db_id": "chinook_1",
        "question": "Find the average unit price for a track.",
        "ground_truth": "SELECT AVG(UnitPrice) FROM TRACK",
        "amends": [
            "Do reference the correct column name `UnitPrice` instead of the incorrect `price` column. Do reference the correct table name `TRACK` instead of the incorrect `tracks` table. The amended query now correctly calculates the average unit price from the TRACK table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(price) FROM tracks;",
            "SELECT AVG(UnitPrice) AS AverageUnitPrice FROM Track;"
        ],
        "rule_sql": []
    },
    "6835": {
        "db_id": "flight_4",
        "question": "Find the names of the top 10 airlines that operate the most number of routes.",
        "ground_truth": "SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT 10",
        "amends": [
            "Do join `airlines AS T1` with `routes AS T2` on `T1.alid = T2.alid` instead of querying only the `routes` table. Do select `T1.name` and `T2.alid` instead of `airline_name` and `route_count`. Do group by `T2.alid` instead of `airline_name`. Do order by `count(*) DESC` instead of `route_count DESC`. The amended query now correctly joins the airlines table to get the airline names and properly groups by the airline ID while maintaining the same limit behavior.",
            "Do include `T2.alid` in the SELECT list instead of omitting it, and do use `T2.alid` in the GROUP BY clause instead of grouping by the same column. Do keep the same JOIN condition `T1.alid = T2.alid` and maintain the ORDER BY `COUNT(*) DESC` with LIMIT 10. The amended query now correctly includes the grouped column in the output while maintaining the same aggregation and sorting behavior.",
            "Do include `T1.name` in the `GROUP BY` clause instead of omitting it, as non-aggregated columns must be grouped. Do remove the `COUNT(*) as route_count` aggregation from the `SELECT` list instead of keeping it, since the query only needs to return the grouped columns. Do maintain the `JOIN` on `T1.alid=T2.alid` and the `ORDER BY count(*) DESC LIMIT 10` without changes. The amended query now correctly handles the grouping requirements and matches the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT airline_name, COUNT(*) as route_count \nFROM routes \nGROUP BY airline_name \nORDER BY route_count DESC \nLIMIT 10;",
            "SELECT T1.name, COUNT(*) AS route_count\nFROM airlines AS T1\nJOIN routes AS T2 ON T1.alid = T2.alid\nGROUP BY T2.alid\nORDER BY COUNT(*) DESC\nLIMIT 10;",
            "SELECT T1.name, T2.alid, COUNT(*) as route_count\nFROM airlines AS T1\nJOIN routes AS T2 ON T1.alid = T2.alid\nGROUP BY T2.alid\nORDER BY COUNT(*) DESC\nLIMIT 10",
            "SELECT T1.name, T2.alid\nFROM airlines AS T1\nJOIN routes AS T2 ON T1.alid = T2.alid\nGROUP BY T2.alid, T1.name\nORDER BY COUNT(*) DESC\nLIMIT 10"
        ],
        "rule_sql": []
    },
    "894": {
        "db_id": "insurance_fnol",
        "question": "What are the phone numbers of customers using the policy with the code \"Life Insurance\"?",
        "ground_truth": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  \"Life Insurance\"",
        "amends": [
            "Do select `customer_phone` instead of `phone_number` and use table `available_policies` instead of `customers`. Do filter on `policy_type_code` instead of `policy_code` while maintaining the same filter value for Life Insurance. The amended query now correctly retrieves phone numbers from the appropriate policies table using the correct column names and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT phone_number FROM customers WHERE policy_code = 'Life Insurance';",
            "SELECT customer_phone FROM Available_Policies WHERE policy_type_code = 'Life Insurance';"
        ],
        "rule_sql": []
    },
    "2342": {
        "db_id": "csu_1",
        "question": "Find the count of universities whose campus fee is greater than the average campus fee.",
        "ground_truth": "SELECT count(*) FROM csu_fees WHERE campusfee  >  (SELECT avg(campusfee) FROM csu_fees)",
        "amends": [
            "Do reference table `csu_fees` instead of `universities` in both the main query and subquery. Do use column `campusfee` instead of `campus_fee` for both the comparison and aggregate calculation. Do maintain the same aggregate function `avg()` and comparison logic but with the corrected table and column names. The amended query now correctly counts records where campus fee exceeds the average, using the proper schema elements."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM universities WHERE campus_fee > (SELECT AVG(campus_fee) FROM universities);",
            "SELECT COUNT(*) FROM csu_fees WHERE CampusFee > (SELECT AVG(CampusFee) FROM csu_fees)"
        ],
        "rule_sql": []
    },
    "5148": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "How many distinct currency codes are there for all drama workshop groups?",
        "ground_truth": "SELECT count(DISTINCT Currency_Code) FROM Drama_Workshop_Groups",
        "amends": [
            "Do use `count(DISTINCT Currency_Code)` instead of `COUNT(*)` to count distinct currency codes rather than all rows. Do reference table `Drama_Workshop_Groups` instead of `workshop_groups` to query the correct table. Do remove the explicit `WHERE genre = 'drama'` filter instead of keeping it, as the table name already implies the drama genre. The amended query now correctly counts distinct currency codes from the Drama_Workshop_Groups table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM workshop_groups WHERE genre = 'drama';",
            "SELECT COUNT(DISTINCT Currency_Code) FROM Drama_Workshop_Groups;"
        ],
        "rule_sql": []
    },
    "6540": {
        "db_id": "wine_1",
        "question": "Count the number of appelations in Napa County.",
        "ground_truth": "SELECT count(*) FROM APPELLATIONS WHERE County  =  \"Napa\"",
        "amends": [
            "Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency with the right SQL's style. Do reference the table as `APPELLATIONS` instead of `appelations` to match the correct table name. Do use double quotes `\"Napa\"` instead of single quotes `'Napa'` for the string literal. Do reference the column as `County` instead of `county` to match the correct column name case. The amended query now correctly counts records from the APPELLATIONS table where the County column equals \"Napa\"."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM appelations WHERE county = 'Napa';",
            "SELECT count(*) FROM \"appellations\" WHERE \"County\" = \"Napa\""
        ],
        "rule_sql": []
    },
    "416": {
        "db_id": "flight_1",
        "question": "What is the name of each aircraft and how many flights does each one complete?",
        "ground_truth": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid",
        "amends": [
            "Do reference the aircraft name from the `Aircraft` table as `T2.name` instead of the incorrect `aircraft_name` column. Do join the `Flight` table as `T1` with the `Aircraft` table as `T2` using `ON T1.aid = T2.aid` instead of querying a single table without proper joins. Do group by `T1.aid` instead of grouping by `aircraft_id` which lacks proper table qualification. The amended query now correctly counts flights per aircraft by properly joining the flight and aircraft tables and returns the correct aircraft names from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT aircraft_name, COUNT(*) FROM flights GROUP BY aircraft_id;",
            "SELECT T2.name, COUNT(T1.flno) AS flight_count\nFROM flight T1\nJOIN aircraft T2 ON T1.aid = T2.aid\nGROUP BY T1.aid, T2.name"
        ],
        "rule_sql": []
    },
    "3660": {
        "db_id": "baseball_1",
        "question": "Which team offers the lowest average salary? Give me the name and id of the team.",
        "ground_truth": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT 1;",
        "amends": [
            "Do select `T1.name` and `T1.team_id` instead of `team_id`, `team_name`, and `AVG(salary)`. Do join `team AS T1` with `salary AS T2` on `T1.team_id = T2.team_id` instead of selecting from only `players`. Do group by `T1.team_id` instead of `team_id, team_name`. Do order by `avg(T2.salary)` instead of `avg_salary`. The amended query now correctly joins team and salary tables to calculate average salary per team."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_id, team_name, AVG(salary) as avg_salary FROM players GROUP BY team_id, team_name ORDER BY avg_salary ASC LIMIT 1;",
            "SELECT T1.name, T1.team_id\nFROM team AS T1\nJOIN salary AS T2 ON T1.team_id = T2.team_id\nGROUP BY T1.team_id\nORDER BY AVG(T2.salary) ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3198": {
        "db_id": "college_1",
        "question": "How many different departments are there in each school that has less than 5 apartments?",
        "ground_truth": "SELECT count(DISTINCT dept_name) ,  school_code FROM department GROUP BY school_code HAVING count(DISTINCT dept_name)  <  5",
        "amends": [
            "Do select `count(DISTINCT dept_name)` and `school_code` instead of `school` and `COUNT(DISTINCT department)`. Do use `FROM department` instead of `FROM departments`. Do remove the `WHERE apartments < 5` filter instead of keeping it. Do group by `school_code` instead of `school`. Do add `HAVING count(DISTINCT dept_name) < 5` instead of omitting it, moving the count filter from WHERE to HAVING since aggregate filters must be in HAVING rather than WHERE. The amended query now correctly filters on the aggregate count using HAVING and uses the proper table and column names to match the intended behavior.",
            "Do place `school_code` after the aggregate in the SELECT list instead of listing it first, and do use lowercase column names `school_code` and `dept_name` instead of uppercase `SCHOOL_CODE` and `DEPT_NAME`. Do maintain the same `COUNT(DISTINCT dept_name)` aggregate function and `HAVING` clause with the identical filter condition instead of changing the logic. The amended query now matches RIGHT_SQL's behavior with identical grouping and filtering semantics.",
            "Do place `school_code` after the aggregate in the SELECT list instead of before it, maintaining the same logical grouping. Do keep the `COUNT(DISTINCT dept_name)` aggregate function unchanged in both SELECT and HAVING clauses. Do preserve the `GROUP BY school_code` grouping and the `HAVING count(DISTINCT dept_name) < 5` filter condition without modification. The amended query now matches RIGHT_SQL's behavior with identical output results despite the column order difference in the SELECT clause."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT school, COUNT(DISTINCT department) \nFROM departments \nWHERE apartments < 5 \nGROUP BY school;",
            "SELECT SCHOOL_CODE, COUNT(DISTINCT DEPT_NAME) \nFROM DEPARTMENT \nGROUP BY SCHOOL_CODE \nHAVING COUNT(DISTINCT DEPT_NAME) < 5",
            "SELECT school_code, COUNT(DISTINCT dept_name) \nFROM department \nGROUP BY school_code \nHAVING COUNT(DISTINCT dept_name) < 5",
            "SELECT COUNT(DISTINCT dept_name) AS department_count, school_code FROM department GROUP BY school_code HAVING COUNT(DISTINCT dept_name) < 5"
        ],
        "rule_sql": []
    },
    "4977": {
        "db_id": "soccer_2",
        "question": "What information do you have on colleges sorted by increasing enrollment numbers?",
        "ground_truth": "SELECT * FROM College ORDER BY enr",
        "amends": [
            "Do reference the `College` table instead of `colleges` and use the `enr` column instead of `enrollment` for ordering. The amended query now correctly matches the RIGHT_SQL's behavior by using the proper table name and column reference."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM colleges ORDER BY enrollment DESC;",
            "SELECT * FROM College ORDER BY enr ASC;"
        ],
        "rule_sql": []
    },
    "71": {
        "db_id": "student_assessment",
        "question": "How many courses do the student whose id is 171 attend?",
        "ground_truth": "SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T2.student_id = 171",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE student_id = 171;"
        ],
        "rule_sql": []
    },
    "6850": {
        "db_id": "flight_4",
        "question": "How many airports are there per city in the US ordered from most to least?",
        "ground_truth": "SELECT count(*) ,  city FROM airports WHERE country  =  'United States' GROUP BY city ORDER BY count(*) DESC",
        "amends": [
            "Do use `count(*)` without an alias instead of `COUNT(*) as airport_count` in the SELECT list. Do reference `city` after the aggregate instead of before it. Do change the WHERE filter to `country = 'United States'` instead of `country = 'US'` to match the correct country name format. Do change the ORDER BY to use `count(*) DESC` instead of `airport_count ASC` to sort by the actual count in descending order rather than ascending. The amended query now correctly counts airports per city in the United States with proper country identification and appropriate sorting.",
            "Do place `count(*)` before `city` in the SELECT list instead of having `city` first. Do keep the same FROM source `airports`, WHERE filter `country = 'United States'`, GROUP BY `city`, and ORDER BY `count(*) DESC` without changes. The amended query now correctly matches the RIGHT_SQL's behavior with the proper column ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, COUNT(*) as airport_count FROM airports WHERE country = 'US' GROUP BY city ORDER BY airport_count ASC;",
            "SELECT city, count(*) FROM airports WHERE country = 'United States' GROUP BY city ORDER BY count(*) DESC",
            "SELECT count(*), city FROM airports WHERE country = 'United States' GROUP BY city ORDER BY count(*) DESC"
        ],
        "rule_sql": []
    },
    "6936": {
        "db_id": "tracking_orders",
        "question": "What are the distinct details of invoices created before 1989-09-03 or after 2007-12-25?",
        "ground_truth": "SELECT DISTINCT invoice_details FROM invoices WHERE invoice_date < \"1989-09-03\" OR invoice_date > \"2007-12-25\"",
        "amends": [
            "Do select only `invoice_details` instead of all columns with `*`. Do use `OR` between date conditions instead of `AND` to include invoices outside the date range rather than within an impossible date window. Do keep `DISTINCT` to eliminate duplicates as in the original. The amended query now correctly selects distinct invoice details for invoices dated before 1989-09-03 or after 2007-12-25, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT * FROM invoices WHERE invoice_date < '1989-09-03' AND invoice_date > '2007-12-25';",
            "SELECT DISTINCT invoice_details FROM Invoices WHERE invoice_date < '1989-09-03' OR invoice_date > '2007-12-25'"
        ],
        "rule_sql": []
    },
    "1683": {
        "db_id": "theme_gallery",
        "question": "Show the theme for exhibitions with both records of an attendance below 100 and above 500.",
        "ground_truth": "SELECT T2.theme FROM exhibition_record AS T1 JOIN exhibition AS T2 ON T1.exhibition_id  =  T2.exhibition_id WHERE T1.attendance  <  100 INTERSECT SELECT T2.theme FROM exhibition_record AS T1 JOIN exhibition AS T2 ON T1.exhibition_id  =  T2.exhibition_id WHERE T1.attendance  >  500",
        "amends": [
            "Do use `T2.theme` from the `exhibition` table instead of `theme` from a single table. Do join `exhibition_record AS T1` with `exhibition AS T2` on `T1.exhibition_id = T2.exhibition_id` instead of querying a single `exhibitions` table. Do split the query into two parts with `INTERSECT` instead of using `OR` in a single `WHERE` clause. Do filter the first part with `T1.attendance < 100` and the second part with `T1.attendance > 500` instead of combining both conditions with `OR`. Do use table aliases `T1` and `T2` for clarity instead of no aliases. The amended query now correctly finds themes that have both low attendance (under 100) and high attendance (over 500) records through the INTERSECT operation, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT theme FROM exhibitions WHERE attendance < 100 OR attendance > 500;",
            "SELECT T2.Theme\nFROM exhibition_record AS T1\nJOIN exhibition AS T2 ON T1.Exhibition_ID = T2.Exhibition_ID\nWHERE T1.Attendance < 100\nINTERSECT\nSELECT T2.Theme\nFROM exhibition_record AS T1\nJOIN exhibition AS T2 ON T1.Exhibition_ID = T2.Exhibition_ID\nWHERE T1.Attendance > 500"
        ],
        "rule_sql": []
    },
    "2349": {
        "db_id": "csu_1",
        "question": "What campus has the most degrees  conferrred over its entire existence?",
        "ground_truth": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1",
        "amends": [
            "Do use `sum(degrees)` in the ORDER BY clause instead of `degrees` to properly sort by the total degrees per campus rather than an individual degree value. Do remove `MAX(degrees)` from the SELECT list instead of including it since the query only needs to return the campus name. The amended query now correctly identifies the campus with the highest total degrees by summing all degrees per campus before ordering, matching the intended behavior.",
            "Do remove the `Campuses` table join and reference `campus` directly from the `degrees` table instead of joining on `d.Campus = c.Id` and selecting `c.Campus`. Do use lowercase `campus` and `degrees` in the SELECT and ORDER BY clauses instead of the original mixed case column references. Do maintain the same GROUP BY on `campus`, ORDER BY `sum(degrees)` DESC, and LIMIT 1 structure. The amended query now correctly aggregates degrees by campus directly from the degrees table without unnecessary table joins, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT campus, MAX(degrees) FROM degrees GROUP BY campus ORDER BY degrees DESC LIMIT 1;",
            "SELECT c.Campus\nFROM degrees d\nJOIN Campuses c ON d.Campus = c.Id\nGROUP BY d.Campus\nORDER BY SUM(d.Degrees) DESC\nLIMIT 1;",
            "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1338": {
        "db_id": "college_2",
        "question": "How many departments offer courses?",
        "ground_truth": "SELECT count(DISTINCT dept_name) FROM course",
        "amends": [
            "Do count `DISTINCT dept_name` instead of `COUNT(*)` to count unique department names rather than all rows. Do reference the `course` table instead of `courses` to use the correct table name. Do remove the `WHERE department_id IS NOT NULL` filter instead of keeping it since the requirement is to count all distinct department names regardless of null values. The amended query now correctly counts distinct department names from the course table without unnecessary filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM courses WHERE department_id IS NOT NULL;",
            "SELECT COUNT(DISTINCT dept_name) FROM course;"
        ],
        "rule_sql": []
    },
    "3022": {
        "db_id": "loan_1",
        "question": "List the name of all different customers who have some loan sorted by their total loan amount.",
        "ground_truth": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id GROUP BY T1.cust_name ORDER BY sum(T2.amount)",
        "amends": [
            "Do select `T1.cust_name` instead of `name` and add aggregation with `sum(T2.amount)` instead of referencing raw `loan_amount`. Do join `customer AS T1` with `loan AS T2` on `T1.cust_id = T2.cust_id` instead of querying only the `customers` table. Do add `GROUP BY T1.cust_name` instead of omitting grouping. Do order by `sum(T2.amount)` instead of `loan_amount DESC` and remove the descending sort direction. The amended query now correctly aggregates loan amounts per customer and matches the intended behavior.",
            "Do remove `SUM(T2.amount) as total_loan_amount` from the SELECT list instead of including it. Do change the ORDER BY clause to reference `sum(T2.amount)` directly instead of using the alias `total_loan_amount`. The amended query now correctly matches the RIGHT_SQL's behavior by only selecting customer names while maintaining the same grouping and ordering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM customers ORDER BY loan_amount DESC;",
            "SELECT T1.cust_name, SUM(T2.amount) as total_loan_amount\nFROM customer AS T1\nJOIN loan AS T2 ON T1.cust_ID = T2.cust_ID\nGROUP BY T1.cust_name\nORDER BY total_loan_amount;",
            "SELECT T1.cust_name\nFROM customer AS T1\nJOIN loan AS T2 ON T1.cust_ID = T2.cust_ID\nGROUP BY T1.cust_name\nORDER BY sum(T2.amount)"
        ],
        "rule_sql": []
    },
    "6898": {
        "db_id": "tracking_orders",
        "question": "Which customer made the most orders? Find the customer name.",
        "ground_truth": "SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name FROM customers ORDER BY customer_id DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "738": {
        "db_id": "customers_card_transactions",
        "question": "Return the average transaction amount, as well as the total amount of all transactions.",
        "ground_truth": "SELECT avg(transaction_amount) ,  sum(transaction_amount) FROM Financial_transactions",
        "amends": [
            "Do reference the `Financial_transactions` table instead of `transactions`, use the correct column name `transaction_amount` instead of `amount`, and add the `sum(transaction_amount)` aggregate function instead of omitting it, while keeping the `avg(transaction_amount)` calculation instead of the original `AVG(amount)`. The amended query now correctly calculates both average and total transaction amounts from the appropriate financial data source, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(amount) FROM transactions;",
            "SELECT AVG(transaction_amount) AS average_transaction_amount, SUM(transaction_amount) AS total_transaction_amount FROM Financial_Transactions"
        ],
        "rule_sql": []
    },
    "6041": {
        "db_id": "game_1",
        "question": "Show all student ids and the number of hours played.",
        "ground_truth": "SELECT Stuid ,  sum(hours_played) FROM Plays_games GROUP BY Stuid",
        "amends": [
            "Do use `sum(hours_played)` instead of `COUNT(hours_played)` to calculate total hours rather than count non-null values. Do add `GROUP BY Stuid` instead of omitting it to aggregate by student. Do reference table `Plays_games` instead of `students` as the correct data source. Do use column alias `Stuid` instead of `student_id` to match the actual column name. The amended query now correctly calculates total hours played per student from the appropriate table with proper aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_id, COUNT(hours_played) FROM students;",
            "SELECT StuID, SUM(Hours_Played) AS Hours_Played FROM Plays_Games GROUP BY StuID"
        ],
        "rule_sql": []
    },
    "2510": {
        "db_id": "movie_1",
        "question": "What are the titles of all movies that have rating star is between 3 and 5?",
        "ground_truth": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN 3 AND 5",
        "amends": [
            "Do select `T2.title` from the `Movie` table instead of `title` from the `movies` table. Do join `Rating AS T1` with `Movie AS T2` on `T1.mID = T2.mID` instead of querying a single table. Do filter with `T1.stars BETWEEN 3 AND 5` on the Rating table instead of `rating_star >= 3 AND rating_star <= 5` on a movies table. The amended query now correctly joins the Rating and Movie tables to filter movies based on their star ratings."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM movies WHERE rating_star >= 3 AND rating_star <= 5;",
            "SELECT T2.title \nFROM Rating AS T1 \nJOIN Movie AS T2 ON T1.mID = T2.mID \nWHERE T1.stars BETWEEN 3 AND 5"
        ],
        "rule_sql": []
    },
    "2659": {
        "db_id": "local_govt_mdm",
        "question": "Which distinct source system code includes the substring 'en'?",
        "ground_truth": "SELECT DISTINCT source_system_code FROM cmi_cross_references WHERE source_system_code LIKE '%en%'",
        "amends": [
            "Do reference table `cmi_cross_references` instead of `table_name` while keeping the same `SELECT DISTINCT source_system_code` clause and `WHERE source_system_code LIKE '%en%'` filter unchanged. The amended query now correctly queries from the intended table while preserving the identical selection logic and filtering behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT source_system_code FROM table_name WHERE source_system_code LIKE '%en%';",
            "SELECT DISTINCT source_system_code FROM CMI_Cross_References WHERE source_system_code LIKE '%en%'"
        ],
        "rule_sql": []
    },
    "4257": {
        "db_id": "club_1",
        "question": "Find each student's first name.",
        "ground_truth": "SELECT DISTINCT fname FROM student",
        "amends": [
            "Do select `fname` instead of `last_name` and add `DISTINCT` instead of omitting it, and do reference table `student` instead of `students`. The amended query now matches the intended behavior of selecting unique first names from the correct table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT last_name FROM students;",
            "SELECT DISTINCT Fname FROM Student;"
        ],
        "rule_sql": []
    },
    "2331": {
        "db_id": "csu_1",
        "question": "What campuses opened before 1800?",
        "ground_truth": "SELECT campus FROM campuses WHERE YEAR  <  1800",
        "amends": [
            "Do select only `campus` instead of all columns with `*`. Do change the filter to `YEAR < 1800` instead of `opened >= 1800`, which reverses both the column reference and the comparison operator. The amended query now correctly filters for campuses opened before 1800 rather than those opened in or after 1800, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM campuses WHERE opened >= 1800;",
            "SELECT Campus FROM Campuses WHERE Year < 1800"
        ],
        "rule_sql": []
    },
    "2330": {
        "db_id": "csu_1",
        "question": "Find the name of the campuses opened before 1800.",
        "ground_truth": "SELECT campus FROM campuses WHERE YEAR  <  1800",
        "amends": [
            "Do select `campus` instead of `name` for the column name. Do use `YEAR < 1800` instead of `opened > 1800` for the filter condition, changing both the column reference and the comparison operator/direction. The amended query now correctly selects campuses that opened before 1800 rather than after 1800, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM campuses WHERE opened > 1800;",
            "SELECT Campus FROM Campuses WHERE Year < 1800;"
        ],
        "rule_sql": []
    },
    "6978": {
        "db_id": "culture_company",
        "question": "Show publishers with a book published in 1989 and a book in 1990.",
        "ground_truth": "SELECT publisher FROM book_club WHERE YEAR  =  1989 INTERSECT SELECT publisher FROM book_club WHERE YEAR  =  1990",
        "amends": [
            "Do use `INTERSECT` to find publishers with books in both years instead of `OR` which finds publishers with books in either year. Do query from `book_club` table instead of `publishers` and `books` tables. Do use `publisher` column instead of `p.name`. Do use `YEAR` column instead of `b.year`. Do remove `DISTINCT` and join conditions since `INTERSECT` inherently returns distinct results. The amended query now correctly identifies publishers that have books published in both 1989 and 1990, matching the RIGHT_SQL's set intersection behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT p.name \nFROM publishers p \nJOIN books b ON p.id = b.publisher_id \nWHERE b.year = 1989 OR b.year = 1990",
            "SELECT Publisher FROM book_club WHERE Year = 1989\nINTERSECT\nSELECT Publisher FROM book_club WHERE Year = 1990"
        ],
        "rule_sql": []
    },
    "3505": {
        "db_id": "hr_1",
        "question": "display the employee number, name( first name and last name ), and salary for all employees who earn more than the average salary and who work in a department with any employee with a 'J' in their first name.",
        "ground_truth": "SELECT employee_id ,  first_name ,  last_name ,  salary FROM employees WHERE salary  >  ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%J%')",
        "amends": [
            "Do select individual columns `employee_id`, `first_name`, `last_name`, `salary` instead of concatenating `first_name || ' ' || last_name` with alias `name`. Do remove the concatenation expression and alias entirely instead of including them. The amended query now correctly returns separate first and last name columns as specified in the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT employee_id, first_name || ' ' || last_name AS name, salary\nFROM employees\nWHERE salary > (SELECT AVG(salary) FROM employees)\nAND department_id IN (SELECT department_id FROM employees WHERE first_name LIKE '%J%');",
            "SELECT employee_id, first_name, last_name, salary \nFROM employees \nWHERE salary > (SELECT AVG(salary) FROM employees) \nAND department_id IN (\n    SELECT DISTINCT department_id \n    FROM employees \n    WHERE first_name LIKE '%J%'\n)"
        ],
        "rule_sql": []
    },
    "4489": {
        "db_id": "decoration_competition",
        "question": "Show the most common country across members.",
        "ground_truth": "SELECT Country FROM member GROUP BY Country ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select only `Country` instead of both `country` and `member_count`. Do use `ORDER BY COUNT(*) DESC` instead of `ORDER BY member_count ASC` to get the country with the highest count rather than the lowest. Do reference table `member` instead of `members`. The amended query now correctly identifies the country with the most members by counting records per country and ordering descending by count."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) as member_count FROM members GROUP BY country ORDER BY member_count ASC LIMIT 1;",
            "SELECT Country FROM member GROUP BY Country ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3253": {
        "db_id": "college_1",
        "question": "What is the name of the department that has the largest number of students enrolled?",
        "ground_truth": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use a multi-table join structure connecting `CLASS`, `enroll`, `course`, and `department` tables instead of querying a single `departments` table. Do select `T4.dept_name` instead of `department_name`. Do join `CLASS` with `enroll` on `T1.class_code = T2.class_code` instead of no join condition. Do join with `course` on `T1.crs_code = T3.crs_code` instead of missing this relationship. Do join with `department` on `T3.dept_code = T4.dept_code` instead of direct department access. Do aggregate with `GROUP BY T3.dept_code` and count enrollments with `count(*)` instead of using a presumed `student_count` column. Do order by the actual enrollment count `count(*) DESC` instead of the non-existent `student_count DESC`. The amended query now correctly identifies the department with the highest enrollment by counting actual student enrollments through proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT department_name FROM departments ORDER BY student_count DESC LIMIT 1;",
            "SELECT T4.DEPT_NAME\nFROM CLASS T1\nJOIN ENROLL T2 ON T1.CLASS_CODE = T2.CLASS_CODE\nJOIN COURSE T3 ON T1.CRS_CODE = T3.CRS_CODE\nJOIN DEPARTMENT T4 ON T3.DEPT_CODE = T4.DEPT_CODE\nGROUP BY T3.DEPT_CODE\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1155": {
        "db_id": "body_builder",
        "question": "What are the birthdays of people in ascending order of height?",
        "ground_truth": "SELECT Birth_Date FROM People ORDER BY Height ASC",
        "amends": [
            "Do use column name `Birth_Date` instead of `birthday` and table name `People` instead of `people` to match the correct schema. Do change the sort order to `ASC` instead of `DESC` to order by ascending height rather than descending. The amended query now correctly selects the birth date column from the People table and orders results by height in ascending order, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT birthday FROM people ORDER BY height DESC;",
            "SELECT Birth_Date FROM People ORDER BY Height ASC;"
        ],
        "rule_sql": []
    },
    "586": {
        "db_id": "store_1",
        "question": "What is the count of customers that Steve Johnson supports?",
        "ground_truth": "SELECT count(*) FROM employees AS T1 JOIN customers AS T2 ON T2.support_rep_id = T1.id WHERE T1.first_name = \"Steve\" AND T1.last_name = \"Johnson\";",
        "amends": [
            "Do use an explicit `JOIN` between `employees` and `customers` on `support_rep_id = id` instead of a subquery with `employee_id`. Do reference the joined table `T1` in the WHERE clause for `first_name` and `last_name` filters instead of embedding them in a subquery. Do use table aliases `T1` and `T2` for clarity instead of no aliases. Do ensure the join condition correctly matches `support_rep_id` to `id` instead of the incorrect `employee_id` reference. The amended query now correctly counts customers associated with the specified employee by establishing the proper relationship between tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE support_rep_id = (SELECT employee_id FROM employees WHERE first_name = 'Steve' AND last_name = 'Johnson');",
            "SELECT COUNT(*) \nFROM customers T2\nJOIN employees T1 ON T2.support_rep_id = T1.id\nWHERE T1.first_name = 'Steve' AND T1.last_name = 'Johnson'"
        ],
        "rule_sql": []
    },
    "5200": {
        "db_id": "music_2",
        "question": "Find all the songs whose name contains the word \"the\".",
        "ground_truth": "SELECT title FROM songs WHERE title LIKE '% the %'",
        "amends": [
            "Do select `title` instead of `*` for the column list. Do use `LIKE '% the %'` instead of `= 'the'` for the filter condition to match titles containing the word \"the\" rather than exact equality. Do reference column `title` instead of `name` in both the SELECT list and WHERE clause. The amended query now correctly searches for song titles containing the word \"the\" and returns only the title column, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM songs WHERE name = 'the';",
            "SELECT title FROM Songs WHERE title LIKE '% the %'"
        ],
        "rule_sql": []
    },
    "1648": {
        "db_id": "wedding",
        "question": "How many churches have a wedding in year 2016?",
        "ground_truth": "SELECT COUNT (DISTINCT church_id) FROM wedding WHERE YEAR  =  2016",
        "amends": [
            "Do use `COUNT(DISTINCT church_id)` instead of `COUNT(*)` to count unique churches rather than all rows. Do query from the `wedding` table instead of the `churches` table to access the correct data source. Do filter on `YEAR = 2016` instead of `wedding_year = 2016` to use the proper column name for year filtering. The amended query now correctly counts distinct churches that performed weddings in 2016, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM churches WHERE wedding_year = 2016;",
            "SELECT COUNT(DISTINCT Church_ID) FROM wedding WHERE Year = 2016"
        ],
        "rule_sql": []
    },
    "687": {
        "db_id": "customers_card_transactions",
        "question": "Show distinct first and last names for all customers with an account.",
        "ground_truth": "SELECT DISTINCT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id",
        "amends": [
            "Do reference columns as `T1.customer_first_name` and `T1.customer_last_name` instead of `first_name` and `last_name`. Do add table `Accounts AS T2` with a `JOIN` on `T1.customer_id = T2.customer_id` instead of filtering with `WHERE account_id IS NOT NULL`. Do remove the `WHERE` clause entirely instead of keeping the `account_id IS NOT NULL` condition. The amended query now correctly joins the Customers and Accounts tables to find customers who have accounts, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT first_name, last_name FROM customers WHERE account_id IS NOT NULL",
            "SELECT DISTINCT T1.customer_first_name, T1.customer_last_name\nFROM Customers AS T1\nJOIN Accounts AS T2 ON T1.customer_id = T2.customer_id"
        ],
        "rule_sql": []
    },
    "5896": {
        "db_id": "cre_Theme_park",
        "question": "What are the price ranges of five star hotels?",
        "ground_truth": "SELECT price_range FROM HOTELS WHERE star_rating_code  =  \"5\"",
        "amends": [
            "Do reference the column `star_rating_code` instead of `stars` in the WHERE clause. Do use string literal `\"5\"` instead of numeric literal `5` for the filter condition. Do maintain the same table name `HOTELS` (case-insensitive) and output column `price_range` as in the original query. The amended query now correctly filters by the star rating code using the appropriate column name and string comparison to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT price_range FROM hotels WHERE stars = 5;",
            "SELECT price_range FROM Hotels WHERE star_rating_code = '5';"
        ],
        "rule_sql": []
    },
    "2315": {
        "db_id": "perpetrator",
        "question": "What are the countries of perpetrators? Show each country and the corresponding number of perpetrators there.",
        "ground_truth": "SELECT Country ,  COUNT(*) FROM perpetrator GROUP BY Country",
        "amends": [
            "Do reference the table as `perpetrator` instead of `perpetrators` and use column name `Country` instead of `country`. Do remove the alias `perpetrator_count` and the `ORDER BY` clause instead of including them. The amended query now correctly counts records by country from the perpetrator table without unnecessary ordering or aliasing."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) as perpetrator_count FROM perpetrators GROUP BY country ORDER BY perpetrator_count DESC;",
            "SELECT Country, COUNT(*) FROM perpetrator GROUP BY Country;"
        ],
        "rule_sql": []
    },
    "356": {
        "db_id": "flight_1",
        "question": "What is the id and name of the aircraft that can cover the maximum distance?",
        "ground_truth": "SELECT aid ,  name FROM Aircraft ORDER BY distance DESC LIMIT 1",
        "amends": [
            "Do select `aid` instead of `id` as the column identifier in the SELECT list, maintaining the same `name` column and `ORDER BY distance DESC LIMIT 1` structure, which correctly references the aircraft identifier column according to the schema. The amended query now matches RIGHT_SQL's behavior by using the appropriate column name for aircraft identification."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, name FROM aircraft ORDER BY distance DESC LIMIT 1;",
            "SELECT aid, name FROM aircraft ORDER BY distance DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4906": {
        "db_id": "store_product",
        "question": "Find the name all districts with city area greater than 10 or population larger than 100000",
        "ground_truth": "SELECT district_name FROM district WHERE city_area  >  10 OR City_Population  >  100000",
        "amends": [
            "Do select `district_name` instead of `name` and use table `district` instead of `districts`. Do filter on `City_Population > 100000` instead of `population > 100000` while keeping the `city_area > 10` condition unchanged. The amended query now correctly references the appropriate column names and table structure to match the intended logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM districts WHERE city_area > 10 OR population > 100000",
            "SELECT district_name FROM district WHERE City_Area > 10 OR City_Population > 100000"
        ],
        "rule_sql": []
    },
    "578": {
        "db_id": "store_1",
        "question": "How many customers live in the city of Prague?",
        "ground_truth": "SELECT count(*) FROM customers WHERE city = \"Prague\";",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE city = 'Prague';"
        ],
        "rule_sql": []
    },
    "3658": {
        "db_id": "baseball_1",
        "question": "For each team, return the team name, id and the maximum salary among the team.",
        "ground_truth": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;",
        "amends": [
            "Do add table `team AS T1` and `salary AS T2` with a `JOIN` on `T1.team_id = T2.team_id` instead of querying only the `teams` table without proper joins. Do change the SELECT list to use `T1.name` instead of `team_name` and `max(T2.salary)` instead of `MAX(salary)` to reference the correct table columns. Do modify the GROUP BY clause to use only `T1.team_id` instead of grouping by both `team_name` and `team_id` since team_id is sufficient for grouping when joined with salary data. The amended query now correctly joins the team and salary tables to calculate maximum salaries per team, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name, team_id, MAX(salary) FROM teams GROUP BY team_name, team_id",
            "SELECT T1.name, T1.team_id, MAX(T2.salary) \nFROM team AS T1 \nJOIN salary AS T2 ON T1.team_id = T2.team_id \nGROUP BY T1.team_id"
        ],
        "rule_sql": []
    },
    "1069": {
        "db_id": "match_season",
        "question": "Who are the different players and how many years has each played?",
        "ground_truth": "SELECT Player ,  Years_Played FROM player",
        "amends": [
            "Do use column name `Player` instead of `player_name` and `Years_Played` instead of `years_played` in the SELECT list. Do reference table `player` instead of `players` in the FROM clause. Do remove the `COUNT(*)` aggregate function and `GROUP BY player_id` clause instead of including them, as the right query appears to select direct column values rather than aggregated counts. Do use proper case for column aliases (`Years_Played`) instead of lowercase (`years_played`). The amended query now matches the right SQL's behavior of selecting individual player records rather than aggregated year counts."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name, COUNT(*) as years_played FROM players GROUP BY player_id",
            "SELECT Player, Years_Played FROM player;"
        ],
        "rule_sql": []
    },
    "4457": {
        "db_id": "network_2",
        "question": "What are the names of all females who are friends with Zach?",
        "ground_truth": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Zach' AND T1.gender  =  'female'",
        "amends": [
            "Do join `Person AS T1` with `PersonFriend AS T2` on `T1.name = T2.name` instead of querying only the `users` table. Do filter on `T2.friend = 'Zach'` instead of `friend = 'Zach'` and maintain `T1.gender = 'female'` instead of `gender = 'female'`. Do select `T1.name` with table qualification instead of just `name`. The amended query now correctly joins the Person and PersonFriend tables to find female persons who have Zach as a friend, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM users WHERE gender = 'female' AND friend = 'Zach';",
            "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T2.friend = 'Zach' AND T1.gender = 'female'"
        ],
        "rule_sql": []
    },
    "3501": {
        "db_id": "hr_1",
        "question": "display the employee name ( first name and last name ) and hire date for all employees in the same department as Clara excluding Clara.",
        "ground_truth": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  \"Clara\") AND first_name != \"Clara\"",
        "amends": [
            "Do reference `department_id` instead of `department` in both the main query and subquery. Do use double quotes `\"Clara\"` instead of single quotes `'Clara'` for string literals. Do maintain the same structure with a correlated subquery filtering by `first_name = \"Clara\"` and excluding that same name in the main query. The amended query now correctly matches the RIGHT_SQL's behavior by using the proper column name `department_id` throughout."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, hire_date FROM employees WHERE department = (SELECT department FROM employees WHERE first_name = 'Clara') AND first_name != 'Clara';",
            "SELECT FIRST_NAME, LAST_NAME, HIRE_DATE \nFROM employees \nWHERE DEPARTMENT_ID = (SELECT DEPARTMENT_ID FROM employees WHERE FIRST_NAME = \"Clara\") \nAND FIRST_NAME != \"Clara\""
        ],
        "rule_sql": []
    },
    "3332": {
        "db_id": "college_1",
        "question": "What are the first names of student who only took one course?",
        "ground_truth": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num GROUP BY T2.stu_num HAVING count(*)  =  1",
        "amends": [
            "Do select `T1.stu_fname` from the `student` table instead of `first_name` from `students`. Do add a `JOIN` with `enroll AS T2` on `T1.stu_num = T2.stu_num` instead of querying a single table. Do move the count condition to `HAVING count(*) = 1` instead of using `WHERE COUNT(course_id) = 1` which is invalid syntax. Do add `GROUP BY T2.stu_num` to properly aggregate the data instead of omitting grouping. Do use `count(*)` to count enrollments instead of `COUNT(course_id)` which would require grouping by student. The amended query now correctly identifies students with exactly one enrollment by joining the student and enrollment tables and using proper aggregation with HAVING."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM students WHERE COUNT(course_id) = 1;",
            "SELECT T1.STU_FNAME \nFROM STUDENT T1\nJOIN ENROLL T2 ON T1.STU_NUM = T2.STU_NUM\nGROUP BY T2.STU_NUM\nHAVING COUNT(*) = 1"
        ],
        "rule_sql": []
    },
    "3716": {
        "db_id": "mountain_photos",
        "question": "What are the name, height and prominence of mountains which do not belong to the range 'Aberdare Range'?",
        "ground_truth": "SELECT name ,  height ,  prominence FROM mountain WHERE range != 'Aberdare Range'",
        "amends": [
            "Do reference table `mountain` instead of `mountains` in the FROM clause. Do use inequality filter `range != 'Aberdare Range'` instead of equality filter `range = 'Aberdare Range'` in the WHERE clause. The amended query now correctly filters for mountains outside the Aberdare Range rather than within it, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, height, prominence FROM mountains WHERE range = 'Aberdare Range';",
            "SELECT name, Height, Prominence FROM mountain WHERE Range != 'Aberdare Range'"
        ],
        "rule_sql": []
    },
    "5360": {
        "db_id": "tracking_software_problems",
        "question": "List the first and last names of all distinct staff members who are assigned to the problem whose id is 1.",
        "ground_truth": "SELECT DISTINCT staff_first_name ,  staff_last_name FROM staff AS T1 JOIN problem_log AS T2 ON T1.staff_id = T2.assigned_to_staff_id WHERE T2.problem_id = 1",
        "amends": [
            "Do add `problem_log` table with `JOIN` instead of querying only `staff` table. Do use `staff_first_name` and `staff_last_name` column names instead of `first_name` and `last_name`. Do add join condition `ON T1.staff_id = T2.assigned_to_staff_id` instead of missing the table relationship. Do move the `problem_id = 1` filter to the joined `problem_log` table instead of applying it directly to `staff`. The amended query now correctly retrieves staff names by joining with problem assignments and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT first_name, last_name FROM staff WHERE problem_id = 1",
            "SELECT DISTINCT s.staff_first_name, s.staff_last_name\nFROM Staff s\nJOIN Problem_Log pl ON s.staff_id = pl.assigned_to_staff_id\nWHERE pl.problem_id = 1;"
        ],
        "rule_sql": []
    },
    "3407": {
        "db_id": "hr_1",
        "question": "List the full name (first and last name), and salary for those employees who earn below 6000.",
        "ground_truth": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000",
        "amends": [
            "Do use `salary < 6000` instead of `salary > 6000` in the WHERE filter, changing the comparison operator from greater-than to less-than to select employees earning below the threshold instead of above it. The amended query now matches RIGHT_SQL's behavior by correctly filtering for salaries under 6000."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, salary FROM employees WHERE salary > 6000;",
            "SELECT FIRST_NAME, LAST_NAME, SALARY FROM employees WHERE SALARY < 6000"
        ],
        "rule_sql": []
    },
    "3016": {
        "db_id": "loan_1",
        "question": "Find the city and state of the bank branch named morningside.",
        "ground_truth": "SELECT city ,  state FROM bank WHERE bname  =  'morningside'",
        "amends": [
            "Do reference table `bank` instead of `bank_branches` and use column `bname` instead of `branch_name` for the filter condition, while keeping the same `city` and `state` columns in the SELECT list and maintaining the exact same filter value 'morningside'. The amended query now correctly references the appropriate table and column names to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, state FROM bank_branches WHERE branch_name = 'morningside';",
            "SELECT city, state FROM bank WHERE bname = 'morningside';"
        ],
        "rule_sql": []
    },
    "5402": {
        "db_id": "shop_membership",
        "question": "Show name, address road, and city for all branches sorted by open year.",
        "ground_truth": "SELECT name ,  address_road ,  city FROM branch ORDER BY open_year",
        "amends": [
            "Do reference table `branch` instead of `branches` to correctly align with the actual table name in the schema. The amended query now matches RIGHT_SQL's behavior by using the proper table reference while preserving the same column selection and ordering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, address_road, city FROM branches ORDER BY open_year;",
            "SELECT Name, Address_road, City FROM branch ORDER BY Open_year;"
        ],
        "rule_sql": []
    },
    "5252": {
        "db_id": "music_2",
        "question": "Find all the songs that do not have a back vocal.",
        "ground_truth": "SELECT DISTINCT title FROM vocals AS t1 JOIN songs AS t2 ON t1.songid  =  t2.songid EXCEPT SELECT t2.title FROM vocals AS t1 JOIN songs AS t2 ON t1.songid  =  t2.songid WHERE TYPE  =  \"back\"",
        "amends": [
            "Do select only `title` instead of all columns with `*`. Do add `DISTINCT` instead of omitting it. Do change the source to a `JOIN` between `vocals` and `songs` on `songid` instead of querying only `songs`. Do add an `EXCEPT` operation to exclude songs with back vocals instead of filtering for them. Do remove the `WHERE back_vocal = 'yes'` filter instead of keeping it. The amended query now correctly identifies songs without back vocals by excluding those with vocal type \"back\" instead of incorrectly selecting songs with back vocals."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM songs WHERE back_vocal = 'yes';",
            "SELECT DISTINCT s.Title\nFROM Songs s\nEXCEPT\nSELECT DISTINCT s.Title\nFROM Songs s\nJOIN Vocals v ON s.SongId = v.SongId\nWHERE v.Type = 'back'"
        ],
        "rule_sql": []
    },
    "3831": {
        "db_id": "e_learning",
        "question": "Return the completion date for all the tests that have \"Fail\" result.",
        "ground_truth": "SELECT T1.date_of_completion FROM Student_Course_Enrolment AS T1 JOIN Student_Tests_Taken AS T2 ON T1.registration_id  =  T2.registration_id WHERE T2.test_result  =  \"Fail\"",
        "amends": [
            "Do select `T1.date_of_completion` instead of `test_date`. Do join `Student_Course_Enrolment AS T1` and `Student_Tests_Taken AS T2` instead of querying only `tests`. Do use `LEFT JOIN` on `T1.registration_id = T2.registration_id` instead of no join condition. Do filter on `T2.test_result = \"Fail\"` instead of `result = 'Pass'`. The amended query now correctly retrieves completion dates for students who failed tests rather than test dates for passing results, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT test_date FROM tests WHERE result = 'Pass';",
            "SELECT T1.date_of_completion \nFROM Student_Course_Enrolment AS T1 \nLEFT JOIN Student_Tests_Taken AS T2 ON T1.registration_id = T2.registration_id \nWHERE T2.test_result = \"Fail\""
        ],
        "rule_sql": []
    },
    "4144": {
        "db_id": "film_rank",
        "question": "List the names of studios that have at least two films.",
        "ground_truth": "SELECT Studio FROM film GROUP BY Studio HAVING COUNT(*)  >=  2",
        "amends": [
            "Do use `Studio` as the column name instead of `name` and move the aggregate condition to `HAVING COUNT(*) >= 2` instead of incorrectly placing `COUNT(films)` in the `WHERE` clause. Do change the table reference to `film` instead of `studios` and properly structure the query with `GROUP BY Studio` instead of omitting grouping. Do remove the incorrect table alias reference and use the correct aggregate function syntax with `COUNT(*)` instead of the invalid `COUNT(films)` expression. The amended query now correctly groups films by studio and filters for studios with at least two films using proper SQL aggregation semantics."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM studios WHERE COUNT(films) >= 2;",
            "SELECT Studio FROM film GROUP BY Studio HAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "5786": {
        "db_id": "customer_complaints",
        "question": "What is the description of the product named \"Chocolate\"?",
        "ground_truth": "SELECT product_description FROM products WHERE product_name  =  \"Chocolate\"",
        "amends": [
            "Do select `product_description` instead of `name` in the SELECT list. Do filter on `product_name = 'Chocolate'` instead of `description = 'Chocolate'` in the WHERE clause. The amended query now correctly retrieves product descriptions where the product name matches 'Chocolate' instead of incorrectly filtering by description, ensuring it matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM products WHERE description = 'Chocolate';",
            "SELECT product_description FROM Products WHERE product_name = 'Chocolate';"
        ],
        "rule_sql": []
    },
    "1343": {
        "db_id": "college_2",
        "question": "What are the titles for courses with two prerequisites?",
        "ground_truth": "SELECT T1.title FROM course AS T1 JOIN prereq AS T2 ON T1.course_id  =  T2.course_id GROUP BY T2.course_id HAVING count(*)  =  2",
        "amends": [
            "Do join `course AS T1` with `prereq AS T2` on `T1.course_id = T2.course_id` instead of querying only the `courses` table. Do use `GROUP BY T2.course_id` with `HAVING count(*) = 2` to count prerequisite relationships instead of filtering directly on `prerequisites = 2`. Do select `T1.title` from the joined result instead of just `title` from a single table. The amended query now correctly identifies courses with exactly two prerequisites by counting relationships in the prereq table rather than relying on a potentially incorrect prerequisites column value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM courses WHERE prerequisites = 2;",
            "SELECT T1.title \nFROM course AS T1 \nJOIN prereq AS T2 ON T1.course_id = T2.course_id \nGROUP BY T2.course_id \nHAVING COUNT(*) = 2"
        ],
        "rule_sql": []
    },
    "6334": {
        "db_id": "e_government",
        "question": "Find the payment method code used by more than 3 parties.",
        "ground_truth": "SELECT payment_method_code FROM parties GROUP BY payment_method_code HAVING count(*)  >  3",
        "amends": [
            "Do remove the `COUNT(*)` column from the SELECT list instead of including it, as the HAVING clause already filters groups by count and the query only needs to return the payment_method_code values that meet the criteria. The amended query now correctly returns only the payment_method_code values for groups having more than 3 records, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT payment_method_code, COUNT(*) FROM parties GROUP BY payment_method_code HAVING COUNT(*) > 3",
            "SELECT payment_method_code FROM Parties GROUP BY payment_method_code HAVING COUNT(*) > 3"
        ],
        "rule_sql": []
    },
    "3850": {
        "db_id": "insurance_policies",
        "question": "Which claims caused more than 2 settlements or have the maximum claim value? List the date the claim was made and the claim id.",
        "ground_truth": "SELECT T1.Date_Claim_Made ,  T1.Claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.Claim_id HAVING count(*)  >  2 UNION SELECT T1.Date_Claim_Made ,  T1.Claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id WHERE T1.Amount_Claimed  =  ( SELECT max(Amount_Claimed) FROM Claims )",
        "amends": [
            "Do add `JOIN Settlements AS T2 ON T1.Claim_id = T2.Claim_id` instead of querying only the `claims` table. Do change `claim_date` to `Date_Claim_Made` and `claim_id` to `Claim_id` with proper table aliasing instead of using bare column names. Do split the query into two parts with `UNION` instead of using `OR` in a single `WHERE` clause. Do move the count condition to `HAVING count(*) > 2` instead of `settlements > 2` in the `WHERE` clause. Do replace `MAX(claim_value)` with a correlated subquery `(SELECT max(Amount_Claimed) FROM Claims)` instead of using an aggregate function directly in the `WHERE` clause. Do change `claim_value` to `Amount_Claimed` in the value comparison instead of the original column name. The amended query now correctly identifies claims with more than two settlements and claims with the maximum claimed amount through proper aggregation and subquery techniques."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT claim_date, claim_id FROM claims WHERE settlements > 2 OR claim_value = MAX(claim_value);",
            "SELECT T1.Date_Claim_Made, T1.Claim_ID\nFROM Claims AS T1\nJOIN Settlements AS T2 ON T1.Claim_ID = T2.Claim_ID\nGROUP BY T1.Claim_ID\nHAVING COUNT(*) > 2\n\nUNION\n\nSELECT Date_Claim_Made, Claim_ID\nFROM Claims\nWHERE Amount_Claimed = (SELECT MAX(Amount_Claimed) FROM Claims)"
        ],
        "rule_sql": []
    },
    "1735": {
        "db_id": "riding_club",
        "question": "How many gold medals has the club with the most coaches won?",
        "ground_truth": "SELECT T1.club_id ,  T1.gold FROM match_result AS T1 JOIN coach AS T2 ON T1.club_id  =  T2.club_id GROUP BY T1.club_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.club_id` and `T1.gold` columns instead of `COUNT(*)` aggregate. Do use `FROM match_result AS T1 JOIN coach AS T2` with explicit table aliases instead of `FROM medals` with a subquery. Do add `ON T1.club_id = T2.club_id` join condition instead of using a correlated subquery. Do include `GROUP BY T1.club_id` instead of grouping only in the subquery. Do keep `ORDER BY count(*) DESC LIMIT 1` instead of the incorrect subquery approach. The amended query now correctly joins match results with coaches and returns the club with the highest count of records, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM medals WHERE club_id = (SELECT club_id FROM coaches GROUP BY club_id ORDER BY COUNT(*) DESC LIMIT 1);",
            "SELECT T1.club_id, T1.gold \nFROM match_result AS T1 \nJOIN coach AS T2 ON T1.club_id = T2.club_id \nGROUP BY T1.club_id \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "2713": {
        "db_id": "storm_record",
        "question": "How many storms occured in each region?",
        "ground_truth": "SELECT T1.region_name ,  count(*) FROM region AS T1 JOIN affected_region AS T2 ON T1.region_id = T2.region_id GROUP BY T1.region_id",
        "amends": [
            "Do join `region AS T1` and `affected_region AS T2` on `T1.region_id = T2.region_id` instead of querying only `storms` table. Do select `T1.region_name` instead of `region` and group by `T1.region_id` instead of `region`. The amended query now correctly counts storms by joining the region tables and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region, COUNT(*) FROM storms GROUP BY region;",
            "SELECT T1.region_name, COUNT(T2.Storm_ID) AS number_of_storms\nFROM region AS T1\nJOIN affected_region AS T2 ON T1.Region_id = T2.Region_id\nGROUP BY T1.Region_id, T1.region_name"
        ],
        "rule_sql": []
    },
    "1138": {
        "db_id": "climbing",
        "question": "Please show the countries and the number of climbers from each country.",
        "ground_truth": "SELECT Country ,  COUNT(*) FROM climber GROUP BY Country",
        "amends": [
            "Do use `COUNT(*)` instead of `COUNT(climber_id)` to count all rows regardless of null values. Do reference table `climber` instead of `climbers` to match the correct table name. Do capitalize `Country` consistently in both SELECT and GROUP BY clauses instead of using lowercase `country`. The amended query now correctly counts all climbers per country using the proper table reference and consistent column naming."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(climber_id) FROM climbers GROUP BY country;",
            "SELECT Country, COUNT(*) AS NumberOfClimbers FROM climber GROUP BY Country;"
        ],
        "rule_sql": []
    },
    "4274": {
        "db_id": "club_1",
        "question": "Find all members of \"Bootup Baltimore\" whose major is \"600\". Show the first name and last name.",
        "ground_truth": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.major  =  \"600\"",
        "amends": [
            "Do use explicit table aliases `t3.fname` and `t3.lname` instead of direct column names `first_name` and `last_name`. Do join three tables `club AS t1`, `member_of_club AS t2`, and `student AS t3` instead of querying a single `members` table. Do use `INNER JOIN` relationships with `t1.clubid = t2.clubid` and `t2.stuid = t3.stuid` instead of a simple WHERE filter. Do filter on `t1.clubname = \"Bootup Baltimore\"` instead of `organization = 'Bootup Baltimore'`. Do filter on `t3.major = \"600\"` as a string instead of `major = 600` as a number. The amended query now correctly joins the club membership relationships and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM members WHERE organization = 'Bootup Baltimore' AND major = 600;",
            "SELECT t3.Fname, t3.LName \nFROM Club AS t1 \nINNER JOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID \nINNER JOIN Student AS t3 ON t2.StuID = t3.StuID \nWHERE t1.ClubName = 'Bootup Baltimore' AND t3.Major = '600'"
        ],
        "rule_sql": []
    },
    "5596": {
        "db_id": "products_gen_characteristics",
        "question": "What are the names, details and data types of the characteristics which are never used by any product?",
        "ground_truth": "SELECT characteristic_name ,  other_characteristic_details ,  characteristic_data_type FROM CHARACTERISTICS EXCEPT SELECT t1.characteristic_name ,  t1.other_characteristic_details ,  t1.characteristic_data_type FROM CHARACTERISTICS AS t1 JOIN product_characteristics AS t2 ON t1.characteristic_id  =  t2.characteristic_id",
        "amends": [
            "Do use `EXCEPT` set operation instead of a `LEFT JOIN` with `IS NOT NULL` filter. Do select columns `characteristic_name`, `other_characteristic_details`, and `characteristic_data_type` instead of `name`, `details`, and `data_type`. Do reference table `CHARACTERISTICS` with alias `t1` in the second part of the `EXCEPT` instead of using a single table reference. Do use `JOIN` with `t1.characteristic_id = t2.characteristic_id` instead of `LEFT JOIN` with `c.id = pc.characteristic_id`. Do remove the `WHERE pc.characteristic_id IS NOT NULL` filter entirely instead of keeping it, as the `EXCEPT` operation inherently handles the set difference logic. The amended query now correctly identifies characteristics not associated with any products through set operations rather than the flawed left join approach."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.name, c.details, c.data_type \nFROM characteristics c\nLEFT JOIN product_characteristics pc ON c.id = pc.characteristic_id\nWHERE pc.characteristic_id IS NOT NULL;",
            "SELECT characteristic_name, other_characteristic_details, characteristic_data_type\nFROM Characteristics\nEXCEPT\nSELECT t1.characteristic_name, t1.other_characteristic_details, t1.characteristic_data_type\nFROM Characteristics t1\nJOIN Product_Characteristics t2 ON t1.characteristic_id = t2.characteristic_id"
        ],
        "rule_sql": []
    },
    "4071": {
        "db_id": "student_1",
        "question": "How many students are taught by teacher TARRING LEIA?",
        "ground_truth": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"TARRING\" AND T2.lastname  =  \"LEIA\"",
        "amends": [
            "Do use `list AS T1 JOIN teachers AS T2` as the FROM source instead of just `students`, and add the join condition `ON T1.classroom = T2.classroom` instead of omitting it. Do change the WHERE filter to `T2.firstname = \"TARRING\" AND T2.lastname = \"LEIA\"` instead of `teacher_name = 'TARRING LEIA'` to properly match separate first and last name fields. Do remove the incorrect table reference `students` and replace it with the correct table structure that requires joining two tables to establish the teacher-student relationship through classroom association. The amended query now correctly counts students by joining through classroom relationships and matching the teacher's separate first and last name fields instead of relying on a single concatenated teacher_name field."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE teacher_name = 'TARRING LEIA';",
            "SELECT COUNT(*) \nFROM list AS T1 \nJOIN teachers AS T2 ON T1.Classroom = T2.Classroom \nWHERE T2.FirstName = 'TARRING' AND T2.LastName = 'LEIA'"
        ],
        "rule_sql": []
    },
    "4323": {
        "db_id": "tracking_grants_for_research",
        "question": "What are the details of the project that is producing both patents and papers as outcomes?",
        "ground_truth": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Paper' INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Patent'",
        "amends": [
            "Do use `INTERSECT` to find projects with both outcomes instead of trying to use `AND` with the same column. Do join `Projects` with `Project_outcomes` on `project_id` instead of querying only the `projects` table. Do filter for `outcome_code = 'Paper'` in one branch and `outcome_code = 'Patent'` in another instead of incorrectly filtering for both values in the same condition. Do select only `project_details` instead of selecting all columns with `*`. Do properly structure the query as two separate SELECT statements combined with INTERSECT instead of a single WHERE clause with contradictory conditions. The amended query now correctly identifies projects that have both paper and patent outcomes by intersecting results from two separate joins."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM projects WHERE outcome = 'patents' AND outcome = 'papers';",
            "SELECT p.project_details\nFROM Projects p\nJOIN Project_Outcomes po ON p.project_id = po.project_id\nWHERE po.outcome_code = 'Paper'\nINTERSECT\nSELECT p.project_details\nFROM Projects p\nJOIN Project_Outcomes po ON p.project_id = po.project_id\nWHERE po.outcome_code = 'Patent'"
        ],
        "rule_sql": []
    },
    "4778": {
        "db_id": "department_store",
        "question": "What are the distinct names of customers who have purchased a keyboard?",
        "ground_truth": "SELECT DISTINCT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id JOIN order_items AS T3 ON T2.order_id  =  T3.order_id JOIN products AS T4 ON T3.product_id  =  T4.product_id WHERE T4.product_name  =  \"keyboard\"",
        "amends": [
            "Do add three JOIN operations instead of querying a single table, specifically joining `customer_orders` on `customer_id`, `order_items` on `order_id`, and `products` on `product_id` instead of omitting these relationships. Do reference columns with table aliases `T1.customer_name` instead of unqualified `customer_name` for clarity. Do filter on `T4.product_name = \"keyboard\"` instead of `product = 'keyboard'` to correctly identify the product through the proper table relationships. Do use double quotes around \"keyboard\" instead of single quotes for string literal consistency. The amended query now properly identifies customers who have actually ordered keyboards through the complete order fulfillment chain rather than assuming a direct product relationship in the customers table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT customer_name FROM customers WHERE product = 'keyboard';",
            "SELECT DISTINCT T1.customer_name\nFROM Customers T1\nJOIN Customer_Orders T2 ON T1.customer_id = T2.customer_id\nJOIN Order_Items T3 ON T2.order_id = T3.order_id\nJOIN Products T4 ON T3.product_id = T4.product_id\nWHERE T4.product_name = \"keyboard\""
        ],
        "rule_sql": []
    },
    "4266": {
        "db_id": "club_1",
        "question": "How many clubs does \"Linda Smith\" belong to?",
        "ground_truth": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  \"Linda\" AND t3.lname  =  \"Smith\"",
        "amends": [
            "Do add joins to `club AS t1`, `member_of_club AS t2`, and `student AS t3` instead of querying only the `clubs` table. Do change the FROM clause to include `JOIN member_of_club AS t2 ON t1.clubid = t2.clubid JOIN student AS t3 ON t2.stuid = t3.stuid` instead of a single table. Do change the WHERE filter to `t3.fname = \"Linda\" AND t3.lname = \"Smith\"` instead of `member_name = 'Linda Smith'` to properly match first and last name separately. Do remove the incorrect column reference `member_name` and instead use the correct student table columns for filtering. The amended query now correctly counts club memberships by joining through the relationship tables and matching the student's first and last name separately, fixing the logic to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM clubs WHERE member_name = 'Linda Smith';",
            "SELECT COUNT(*) \nFROM club AS t1 \nJOIN member_of_club AS t2 ON t1.ClubID = t2.ClubID \nJOIN student AS t3 ON t2.StuID = t3.StuID \nWHERE t3.Fname = 'Linda' AND t3.LName = 'Smith'"
        ],
        "rule_sql": []
    },
    "2755": {
        "db_id": "election",
        "question": "Find the distinct years when the governor was named \"Eliot Spitzer\".",
        "ground_truth": "SELECT DISTINCT YEAR FROM party WHERE Governor  =  \"Eliot Spitzer\"",
        "amends": [
            "Do reference table `party` instead of `governors` and column `Governor` instead of `name` while keeping the `DISTINCT` clause and maintaining the same filter condition for 'Eliot Spitzer'. Do use uppercase `YEAR` instead of lowercase `year` for consistency with the column naming convention. The amended query now correctly retrieves distinct years from the party table where the governor is Eliot Spitzer, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT year FROM governors WHERE name = 'Eliot Spitzer'",
            "SELECT DISTINCT Year FROM party WHERE Governor = 'Eliot Spitzer';"
        ],
        "rule_sql": []
    },
    "1689": {
        "db_id": "epinions_1",
        "question": "Find the id of the item whose title is \"orange\".",
        "ground_truth": "SELECT i_id FROM item WHERE title  =  \"orange\"",
        "amends": [
            "Do select `i_id` instead of `id` and reference table `item` instead of `items`. Do filter for `title = \"orange\"` instead of `title = 'apple'` to match the correct query logic and output requirements. The amended query now correctly retrieves the specified identifier from the appropriate table with the correct filter condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM items WHERE title = 'apple';",
            "SELECT i_id FROM item WHERE title = 'orange';"
        ],
        "rule_sql": []
    },
    "5251": {
        "db_id": "music_2",
        "question": "How many different songs have shared vocals?",
        "ground_truth": "SELECT count(DISTINCT title) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE TYPE  =  \"shared\"",
        "amends": [
            "Do count `DISTINCT title` instead of `COUNT(*)` to count unique song titles rather than all rows. Do join `vocals AS T1` with `songs AS T2` on `T1.songid = T2.songid` instead of querying only the `songs` table to incorporate vocal information. Do filter on `TYPE = \"shared\"` from the vocals table instead of `vocals = 'shared'` from the songs table to correctly identify shared vocal performances. The amended query now matches RIGHT_SQL's behavior by properly counting distinct songs with shared vocals through the appropriate table join and filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM songs WHERE vocals = 'shared';",
            "SELECT COUNT(DISTINCT T2.Title) \nFROM Vocals AS T1 \nJOIN Songs AS T2 ON T1.SongId = T2.SongId \nWHERE T1.Type = 'shared'"
        ],
        "rule_sql": []
    },
    "4890": {
        "db_id": "school_player",
        "question": "List the school color of the school that has the largest enrollment.",
        "ground_truth": "SELECT School_Colors FROM school ORDER BY Enrollment DESC LIMIT 1",
        "amends": [
            "Do use column name `School_Colors` instead of `school_color` and table name `school` instead of `schools`. Do order by `Enrollment DESC` instead of `enrollment ASC` to get the highest enrollment instead of the lowest. The amended query now correctly retrieves the school colors from the school with the highest enrollment."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT school_color FROM schools ORDER BY enrollment ASC LIMIT 1;",
            "SELECT School_Colors FROM school ORDER BY Enrollment DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2062": {
        "db_id": "party_people",
        "question": "What are the names of parties and their respective regions?",
        "ground_truth": "SELECT T1.party_name ,  T2.region_name FROM party AS T1 JOIN region AS T2 ON T1.region_id  =  T2.region_id",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference `T1.party_name` and `T2.region_name` instead of `party_name` and `region`. Do join `party AS T1` with `region AS T2` instead of `parties` with `regions`. Do use join condition `T1.region_id = T2.region_id` instead of `parties.region_id = regions.id`. The amended query now correctly matches the intended behavior with proper table aliasing and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT party_name, region FROM parties JOIN regions ON parties.region_id = regions.id;",
            "SELECT T1.Party_name, T2.Region_name FROM party AS T1 JOIN region AS T2 ON T1.Region_ID = T2.Region_ID"
        ],
        "rule_sql": []
    },
    "104": {
        "db_id": "student_assessment",
        "question": "What are all details of the students who registered but did not attend any course?",
        "ground_truth": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)",
        "amends": [
            "Do query from `student_course_registrations` instead of `students` to access the correct registration data. Do use a `NOT IN` subquery filtering by `student_id` from `student_course_attendance` instead of direct `WHERE` conditions on `registered` and `course_attendance` columns, as this correctly identifies students who are registered but have no attendance records. Do remove the explicit column filters `registered = 1` and `course_attendance > 0` since the subquery logic handles the attendance validation through the absence of records in the attendance table. The amended query now correctly identifies registered students with zero course attendance by checking for their absence in the attendance records table.",
            "Do query from `student_course_registrations` instead of `Students`, and remove the redundant `s.student_id IN` subquery instead of keeping it. Do use a single `NOT IN` condition with `student_course_attendance` instead of the previous compound logic. Do remove the unnecessary table alias `s` instead of maintaining it. The amended query now correctly identifies registrations without attendance by querying the registration table directly and filtering for students not found in the attendance records, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM students WHERE registered = 1 AND course_attendance > 0;",
            "SELECT s.* \nFROM Students s\nWHERE s.student_id IN (\n    SELECT scr.student_id \n    FROM Student_Course_Registrations scr\n) \nAND s.student_id NOT IN (\n    SELECT sca.student_id \n    FROM Student_Course_Attendance sca\n);",
            "SELECT * FROM Student_Course_Registrations WHERE student_id NOT IN (SELECT student_id FROM Student_Course_Attendance)"
        ],
        "rule_sql": []
    },
    "5902": {
        "db_id": "cre_Theme_park",
        "question": "Return the detail of the location named \"UK Gallery\".",
        "ground_truth": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  \"UK Gallery\"",
        "amends": [
            "Do select only `Other_Details` instead of all columns with `*`. Do reference the correct column name `Location_Name` instead of `name` for the filter condition. Do use double quotes `\"UK Gallery\"` instead of single quotes for the string literal. Do reference the correct table name `LOCATIONS` instead of `locations` with proper case sensitivity. The amended query now correctly retrieves only the Other_Details column from the LOCATIONS table where Location_Name equals \"UK Gallery\", matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM locations WHERE name = 'UK Gallery';",
            "SELECT Other_Details FROM LOCATIONS WHERE Location_Name = \"UK Gallery\";"
        ],
        "rule_sql": []
    },
    "2077": {
        "db_id": "party_people",
        "question": "What is the name of member in charge of greatest number of events?",
        "ground_truth": "SELECT T1.member_name FROM member AS T1 JOIN party_events AS T2 ON T1.member_id  =  T2.member_in_charge_id GROUP BY T2.member_in_charge_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.member_name` from the `member` table instead of `member_name` from `events`. Do join `party_events AS T2` with `ON T1.member_id = T2.member_in_charge_id` instead of querying `events` alone without any join. Do group by `T2.member_in_charge_id` instead of `member_name` to properly aggregate the count of events per member. The amended query now correctly joins member and party_events tables to count events per responsible member and returns the member with the most events, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT member_name FROM events GROUP BY member_name ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T1.Member_Name\nFROM member AS T1\nJOIN party_events AS T2 ON T1.Member_ID = T2.Member_in_charge_ID\nGROUP BY T2.Member_in_charge_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "795": {
        "db_id": "coffee_shop",
        "question": "Which address has both members younger than 30 and members older than 40?",
        "ground_truth": "SELECT address FROM member WHERE age  <  30 INTERSECT SELECT address FROM member WHERE age  >  40",
        "amends": [
            "Do use `INTERSECT` to find addresses that appear in both age groups instead of using `AND` with contradictory conditions. Do query from `member` table instead of `members` table. Do split into two separate queries for `age < 30` and `age > 40` instead of combining them with an impossible `AND` condition. Do remove the contradictory `age < 30 AND age > 40` filter that would never return results. The amended query now correctly finds addresses of members who are both under 30 and over 40 by using set intersection logic instead of an impossible single condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address FROM members WHERE age < 30 AND age > 40;",
            "SELECT Address FROM member WHERE Age < 30\nINTERSECT\nSELECT Address FROM member WHERE Age > 40;"
        ],
        "rule_sql": []
    },
    "1520": {
        "db_id": "insurance_and_eClaims",
        "question": "Which customer made the largest amount of claim in a single claim? Return the customer details.",
        "ground_truth": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)",
        "amends": [
            "Do select `customer_details` from the `customers` table instead of selecting all columns `c.*` and `MAX(claim_amount)`. Do join `claim_headers` as `t1` with `policies` as `t2` on `t1.policy_id = t2.policy_id` instead of joining `customers` directly with `claims`. Do then join `customers` as `t3` on `t2.customer_id = t3.customer_id` instead of the direct customer-claim join. Do add a WHERE filter comparing `t1.amount_claimed` to a subquery finding the maximum `amount_claimed` instead of using GROUP BY with MAX and ORDER BY DESC LIMIT 1. Do remove the GROUP BY clause and ORDER BY/LIMIT entirely instead of keeping them. Do use a correlated subquery to find the maximum claim amount instead of aggregating per customer. The amended query now correctly identifies customers with claims matching the overall maximum claim amount rather than finding the customer with their own maximum claim."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.*, MAX(claim_amount) as max_claim \nFROM customers c \nJOIN claims cl ON c.customer_id = cl.customer_id \nGROUP BY c.customer_id \nORDER BY max_claim DESC \nLIMIT 1;",
            "SELECT t3.Customer_Details\nFROM Claim_Headers t1\nJOIN Policies t2 ON t1.Policy_ID = t2.Policy_ID\nJOIN Customers t3 ON t2.Customer_ID = t3.Customer_ID\nWHERE t1.Amount_Claimed = (SELECT MAX(Amount_Claimed) FROM Claim_Headers);"
        ],
        "rule_sql": []
    },
    "2333": {
        "db_id": "csu_1",
        "question": "What campuses opened between 1935 and 1939?",
        "ground_truth": "SELECT campus FROM campuses WHERE YEAR  >=  1935 AND YEAR  <=  1939",
        "amends": [
            "Do select only `campus` instead of all columns with `*`. Do use column name `YEAR` instead of `opened_year` for the date comparison. Do use explicit range conditions `YEAR >= 1935 AND YEAR <= 1939` instead of the `BETWEEN` operator. The amended query now correctly filters campuses based on the year column with proper range conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM campuses WHERE opened_year BETWEEN 1935 AND 1939;",
            "SELECT Campus FROM Campuses WHERE Year >= 1935 AND Year <= 1939"
        ],
        "rule_sql": []
    },
    "5381": {
        "db_id": "tracking_software_problems",
        "question": "Sort all the distinct product names in alphabetical order.",
        "ground_truth": "SELECT DISTINCT product_name FROM product ORDER BY product_name",
        "amends": [
            "Do add `DISTINCT` instead of omitting it to eliminate duplicate product names. Do reference table `product` instead of `products` to match the correct table name. Do remove explicit `ASC` specification instead of keeping it since it's the default ordering. The amended query now correctly returns unique product names from the product table in alphabetical order, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name FROM products ORDER BY product_name ASC;",
            "SELECT DISTINCT product_name FROM Product ORDER BY product_name;"
        ],
        "rule_sql": []
    },
    "2365": {
        "db_id": "csu_1",
        "question": "How many campuses exist are in the county of LA?",
        "ground_truth": "SELECT count(*) FROM campuses WHERE county  =  \"Los Angeles\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM campuses WHERE county = 'Los Angeles';"
        ],
        "rule_sql": []
    },
    "4289": {
        "db_id": "club_1",
        "question": "Tell me the location of the club \"Hopkins Student Enterprises\".",
        "ground_truth": "SELECT clublocation FROM club WHERE clubname  =  \"Hopkins Student Enterprises\"",
        "amends": [
            "Do select `clublocation` instead of `name` and use table `club` instead of `clubs`. Do filter on `clubname = \"Hopkins Student Enterprises\"` instead of `location = 'Hopkins Student Enterprises'` and use double quotes instead of single quotes for the string literal. The amended query now correctly retrieves the club location from the appropriate table using the club name filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM clubs WHERE location = 'Hopkins Student Enterprises';",
            "SELECT ClubLocation FROM Club WHERE ClubName = \"Hopkins Student Enterprises\";"
        ],
        "rule_sql": []
    },
    "1824": {
        "db_id": "small_bank_1",
        "question": "Find the name and savings balance of the top 3 accounts with the highest saving balance sorted by savings balance in descending order.",
        "ground_truth": "SELECT T1.name ,  T2.balance FROM accounts AS T1 JOIN savings AS T2 ON T1.custid  =  T2.custid ORDER BY T2.balance DESC LIMIT 3",
        "amends": [
            "Do select `T1.name` and `T2.balance` instead of `name` and `savings_balance`. Do join `savings AS T2` on `T1.custid = T2.custid` instead of querying only the `accounts` table. Do order by `T2.balance DESC` instead of `savings_balance ASC`. The amended query now correctly joins account information with savings data and returns the top 3 highest balances instead of the lowest 3 values from a single table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, savings_balance FROM accounts ORDER BY savings_balance ASC LIMIT 3;",
            "SELECT T1.name, T2.balance \nFROM ACCOUNTS AS T1 \nJOIN SAVINGS AS T2 ON T1.custid = T2.custid \nORDER BY T2.balance DESC \nLIMIT 3"
        ],
        "rule_sql": []
    },
    "3818": {
        "db_id": "e_learning",
        "question": "What is the date of enrollment of the course named \"Spanish\"?",
        "ground_truth": "SELECT T2.date_of_enrolment FROM Courses AS T1 JOIN Student_Course_Enrolment AS T2 ON T1.course_id  =  T2.course_id WHERE T1.course_name  =  \"Spanish\"",
        "amends": [
            "Do select `T2.date_of_enrolment` from the Student_Course_Enrolment table instead of `enrollment_date` from courses. Do add a `JOIN` with `Student_Course_Enrolment AS T2` on `T1.course_id = T2.course_id` instead of querying only the courses table. Do use table aliases `Courses AS T1` instead of the bare table name. Do filter on `T1.course_name = \"Spanish\"` instead of the same condition without table qualification. The amended query now correctly retrieves enrollment dates from the student enrollment table rather than assuming the courses table contains this data directly, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT enrollment_date FROM courses WHERE course_name = 'Spanish';",
            "SELECT T2.date_of_enrolment \nFROM Courses AS T1 \nJOIN Student_Course_Enrolment AS T2 ON T1.course_id = T2.course_id \nWHERE T1.course_name = 'Spanish'"
        ],
        "rule_sql": []
    },
    "5456": {
        "db_id": "voter_2",
        "question": "What are the majors of male (sex is M) students?",
        "ground_truth": "SELECT Major FROM STUDENT WHERE Sex  =  \"M\"",
        "amends": [
            "Do reference table `STUDENT` instead of `students` and use column `Major` instead of `major` in the SELECT clause. Do filter on `Sex = \"M\"` instead of `sex = 'F'` in the WHERE clause, changing both the column reference from lowercase to uppercase and the filter value from female to male. The amended query now correctly selects from the STUDENT table with proper column capitalization and applies the intended male gender filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT major FROM students WHERE sex = 'F';",
            "SELECT Major FROM Student WHERE Sex = 'M';"
        ],
        "rule_sql": []
    },
    "624": {
        "db_id": "store_1",
        "question": "What is the name of the album that has the track Ball to the Wall?",
        "ground_truth": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = \"Balls to the Wall\";",
        "amends": [
            "Do reference table `albums AS T1` instead of `album`, and `tracks AS T2` instead of `track` in the FROM clause. Do use join condition `T1.id = T2.genre_id` instead of `album.album_id = track.album_id` for the ON predicate. Do filter for track name `\"Balls to the Wall\"` instead of `'Ball to the Wall'` in the WHERE clause. Do select column `T1.title` instead of `album.title` in the SELECT list. The amended query now correctly joins albums to tracks by genre_id instead of album_id and fixes the track name filter to match the intended search criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT album.title FROM album JOIN track ON album.album_id = track.album_id WHERE track.name = 'Ball to the Wall';",
            "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';"
        ],
        "rule_sql": []
    },
    "3981": {
        "db_id": "hospital_1",
        "question": "What are the procedures that cost more than 1000 or are specialized in by physician John Wen?",
        "ground_truth": "SELECT name FROM procedures WHERE cost  >  1000 UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  \"John Wen\"",
        "amends": [
            "Do select only `name` instead of `*` in the SELECT list. Do add a UNION operation to combine results from two separate queries instead of using a single OR condition. Do replace the direct filter `physician = 'John Wen'` with a join-based approach using `physician AS T1 JOIN trained_in AS T2 ON T1.employeeid = T2.physician JOIN procedures AS T3 ON T3.code = T2.treatment` instead of the simple column reference. Do use proper table aliases `T1`, `T2`, and `T3` for clarity instead of direct table references. Do filter on `T1.name = \"John Wen\"` instead of `physician = 'John Wen'` to correctly identify the physician by name rather than assuming the physician column exists in procedures. The amended query now correctly retrieves procedure names either by cost or by physician specialization through proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM procedures WHERE cost > 1000 OR physician = 'John Wen';",
            "SELECT name FROM procedures WHERE cost > 1000\nUNION\nSELECT T3.name FROM physician AS T1 \nJOIN trained_in AS T2 ON T1.employeeid = T2.physician \nJOIN procedures AS T3 ON T3.code = T2.treatment \nWHERE T1.name = 'John Wen'"
        ],
        "rule_sql": []
    },
    "592": {
        "db_id": "store_1",
        "question": "What is Nancy Edwards's address?",
        "ground_truth": "SELECT address FROM employees WHERE first_name = \"Nancy\" AND last_name = \"Edwards\";",
        "amends": [
            "Do query the `employees` table instead of the `customers` table. Do use double quotes for string literals `\"Nancy\"` and `\"Edwards\"` instead of single quotes `'Nancy'` and `'Edwards'`. The amended query now correctly retrieves the address from the employees table for Nancy Edwards."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address FROM customers WHERE first_name = 'Nancy' AND last_name = 'Edwards';",
            "SELECT address FROM employees WHERE first_name = \"Nancy\" AND last_name = \"Edwards\";"
        ],
        "rule_sql": []
    },
    "379": {
        "db_id": "flight_1",
        "question": "Show the id and salary of Mark Young.",
        "ground_truth": "SELECT eid ,  salary FROM Employee WHERE name  =  'Mark Young'",
        "amends": [
            "Do select `eid` instead of `id` and use a single `name` column filter with `'Mark Young'` instead of separate `first_name` and `last_name` conditions. Do reference table `Employee` instead of `employees` and remove the unnecessary `AND` operator. The amended query now correctly retrieves employee ID and salary using the consolidated name format."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, salary FROM employees WHERE first_name = 'Mark' AND last_name = 'Young'",
            "SELECT eid, salary FROM employee WHERE name = 'Mark Young';"
        ],
        "rule_sql": []
    },
    "4099": {
        "db_id": "company_employee",
        "question": "Show the names of companies in the banking or retailing industry?",
        "ground_truth": "SELECT Name FROM company WHERE Industry  =  \"Banking\" OR Industry  =  \"Retailing\"",
        "amends": [
            "Do use `OR` operator instead of `AND` for the industry filter to include companies in either banking or retailing instead of requiring both industries simultaneously. Do reference the correct table name `company` instead of `companies` and use proper column capitalization with `Name` and `Industry` instead of lowercase. Do use double quotes for string literals `\"Banking\"` and `\"Retailing\"` instead of single quotes. The amended query now correctly returns companies in either the banking or retailing industry instead of incorrectly requiring both industries, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM companies WHERE industry = 'banking' AND industry = 'retailing'",
            "SELECT \"Name\" FROM \"company\" WHERE \"Industry\" = \"Banking\" OR \"Industry\" = \"Retailing\";"
        ],
        "rule_sql": []
    },
    "3270": {
        "db_id": "college_1",
        "question": "What is the name of the department with the fewest professors?",
        "ground_truth": "SELECT T2.dept_name FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.dept_code ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do join `professor` to `department` on `dept_code` instead of querying `departments` alone without proper table relationships. Do add `GROUP BY T1.dept_code` to aggregate by department instead of attempting to count without grouping. Do use `count(*)` in the ORDER BY instead of `COUNT(professors.id)` which was incorrectly placed in the SELECT clause. Do reference `T2.dept_name` in the SELECT instead of `department_name` from an unspecified source. The amended query now correctly identifies the department with the fewest professors by properly joining tables, grouping by department code, and counting records per group."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT department_name FROM departments ORDER BY COUNT(professors.id) ASC LIMIT 1;",
            "SELECT d.DEPT_NAME\nFROM DEPARTMENT d\nJOIN PROFESSOR p ON d.DEPT_CODE = p.DEPT_CODE\nGROUP BY d.DEPT_CODE\nORDER BY COUNT(*) ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5282": {
        "db_id": "manufactory_1",
        "question": "Find the total revenue created by the companies whose headquarter is located at Austin.",
        "ground_truth": "SELECT sum(revenue) FROM manufacturers WHERE headquarter  =  'Austin'",
        "amends": [
            "Do reference the `manufacturers` table instead of the `companies` table in the FROM clause. Do use the correct column name `headquarter` instead of `headquarters` in the WHERE filter. Do use lowercase `sum(revenue)` instead of uppercase `SUM(revenue)` for the aggregate function. The amended query now correctly calculates revenue from manufacturers headquartered in Austin."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(revenue) FROM companies WHERE headquarters = 'Austin';",
            "SELECT sum(revenue) FROM manufacturers WHERE headquarter = 'Austin';"
        ],
        "rule_sql": []
    },
    "5031": {
        "db_id": "soccer_2",
        "question": "How many schools have students playing in goalie and mid-field positions?",
        "ground_truth": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid')",
        "amends": [
            "Do use a subquery with `INTERSECT` to find students who play both positions instead of counting all students who play either position. Do reference table `tryout` instead of tables `schools`, `students`, and `positions`. Do filter for `pPos = 'goalie'` and `pPos = 'mid'` in separate queries instead of using `OR` with `position_name` values. Do select `cName` for intersection instead of counting all records. Do remove the join conditions and school/student relationships instead of maintaining them. The amended query now correctly counts students who play both goalkeeper and midfield positions rather than those who play either position."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM schools s \nJOIN students st ON s.school_id = st.school_id \nJOIN positions p ON st.student_id = p.student_id \nWHERE p.position_name = 'goalie' OR p.position_name = 'mid-field'",
            "SELECT COUNT(*) \nFROM (\n    SELECT cName \n    FROM Tryout \n    WHERE pPos = 'goalie'\n    INTERSECT\n    SELECT cName \n    FROM Tryout \n    WHERE pPos = 'mid'\n)"
        ],
        "rule_sql": []
    },
    "674": {
        "db_id": "customers_card_transactions",
        "question": "Give the full name and phone of the customer who has the account name 162.",
        "ground_truth": "SELECT T2.customer_first_name ,  T2.customer_last_name ,  T2.customer_phone FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  \"162\"",
        "amends": [
            "Do select `customer_first_name`, `customer_last_name`, and `customer_phone` instead of `full_name` and `phone`. Do join `Accounts` and `Customers` tables on `customer_id` instead of querying only the `customers` table. Do filter on `account_name = \"162\"` instead of `account_id = 162`. Do use table aliases `T1` and `T2` for clarity instead of no aliases. The amended query now correctly retrieves customer information by joining accounts and filtering on account name rather than using a potentially incorrect account_id filter on the customers table alone."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT full_name, phone FROM customers WHERE account_id = 162;",
            "SELECT T2.customer_first_name, T2.customer_last_name, T2.customer_phone\nFROM Accounts T1\nJOIN Customers T2 ON T1.customer_id = T2.customer_id\nWHERE T1.account_name = '162'"
        ],
        "rule_sql": []
    },
    "4597": {
        "db_id": "solvency_ii",
        "question": "List the names of products that are not in any event.",
        "ground_truth": "SELECT Product_Name FROM Products WHERE Product_ID NOT IN (SELECT Product_ID FROM Products_in_Events)",
        "amends": [
            "Do reference `Product_Name` from the `Products` table instead of `name` from `products`. Do use `Product_ID` as the filter column instead of `product_id`. Do reference the `Products_in_Events` table in the subquery instead of `events`. Do maintain the `NOT IN` subquery structure but with corrected table and column references. The amended query now correctly identifies products not present in the product-event relationship table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM products WHERE product_id NOT IN (SELECT product_id FROM events)",
            "SELECT Product_Name FROM Products WHERE Product_ID NOT IN (SELECT Product_ID FROM Products_in_Events)"
        ],
        "rule_sql": []
    },
    "1979": {
        "db_id": "phone_market",
        "question": "List the names of phones in ascending order of price.",
        "ground_truth": "SELECT Name FROM phone ORDER BY Price ASC",
        "amends": [
            "Do reference table `phone` instead of `phones` and use column `Name` instead of `name` in the SELECT clause. Do use `Price ASC` ordering instead of `price DESC` to sort by ascending price rather than descending. The amended query now correctly references the intended table and columns with the proper ascending sort order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM phones ORDER BY price DESC;",
            "SELECT Name FROM phone ORDER BY Price ASC;"
        ],
        "rule_sql": []
    },
    "4216": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "Show the employee ids for all employees with role name \"Human Resource\" or \"Manager\".",
        "ground_truth": "SELECT T1.employee_id FROM Employees AS T1 JOIN ROLES AS T2 ON T1.role_code  =  T2.role_code WHERE T2.role_name  =  \"Human Resource\" OR T2.role_name  =  \"Manager\"",
        "amends": [
            "Do join `Employees AS T1` with `ROLES AS T2` on `T1.role_code = T2.role_code` instead of querying only the employees table without any join. Do filter with `T2.role_name = \"Human Resource\" OR T2.role_name = \"Manager\"` instead of the impossible condition `role_name = 'Human Resource' AND role_name = 'Manager'` which could never return results. Do select `T1.employee_id` with proper table qualification instead of just `employee_id`. The amended query now correctly retrieves employees who have either Human Resource or Manager roles by properly joining with the roles table and using logical OR instead of contradictory AND conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT employee_id FROM employees WHERE role_name = 'Human Resource' AND role_name = 'Manager'",
            "SELECT T1.Employee_ID \nFROM Employees AS T1\nJOIN Roles AS T2 ON T1.Role_Code = T2.Role_Code\nWHERE T2.Role_Name = 'Human Resource' OR T2.Role_Name = 'Manager'"
        ],
        "rule_sql": []
    },
    "6410": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "What are the names and dates for documents corresponding to project that has the details 'Graph Database project'?",
        "ground_truth": "SELECT document_name ,  document_date FROM Documents AS T1 JOIN projects AS T2 ON T1.project_id  =  T2.project_id WHERE T2.project_details  =  'Graph Database project'",
        "amends": [
            "Do select `document_date` instead of `date` and use table alias `T1` for the documents table. Do add `JOIN projects AS T2` instead of using a subquery, and specify the join condition `ON T1.project_id = T2.project_id` instead of the subquery filter. Do change the filter to reference `T2.project_details = 'Graph Database project'` instead of `details = 'Graph Database project'` within a subquery. The amended query now correctly joins the tables and references the proper column names, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT document_name, date FROM documents WHERE project_id = (SELECT project_id FROM projects WHERE details = 'Graph Database project')",
            "SELECT T1.Document_Name, T1.Document_Date \nFROM Documents AS T1 \nJOIN Projects AS T2 ON T1.Project_ID = T2.Project_ID \nWHERE T2.Project_Details = 'Graph Database project'"
        ],
        "rule_sql": []
    },
    "85": {
        "db_id": "student_assessment",
        "question": "Find the cell mobile number of the candidates whose assessment code is \"Fail\"?",
        "ground_truth": "SELECT T3.cell_mobile_number FROM candidates AS T1 JOIN candidate_assessments AS T2 ON T1.candidate_id = T2.candidate_id JOIN people AS T3 ON T1.candidate_id = T3.person_id WHERE T2.asessment_outcome_code = \"Fail\"",
        "amends": [
            "Do select `T3.cell_mobile_number` instead of `phone_number`. Do add joins to `candidate_assessments AS T2` and `people AS T3` instead of querying only the `candidates` table. Do use `LEFT JOIN` on `T1.candidate_id = T2.candidate_id` and `LEFT JOIN` on `T1.candidate_id = T3.person_id` instead of no joins. Do filter on `T2.asessment_outcome_code = \"Fail\"` instead of `assessment_code = 'Pass'`. The amended query now correctly retrieves mobile numbers for candidates with failed assessments by joining the necessary tables and using the proper filter condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT phone_number FROM candidates WHERE assessment_code = 'Pass';",
            "SELECT T3.cell_mobile_number\nFROM Candidates AS T1\nLEFT JOIN Candidate_Assessments AS T2 ON T1.candidate_id = T2.candidate_id\nLEFT JOIN People AS T3 ON T1.candidate_id = T3.person_id\nWHERE T2.asessment_outcome_code = 'Fail'"
        ],
        "rule_sql": []
    },
    "3435": {
        "db_id": "hr_1",
        "question": "display all the details from Employees table for those employees who was hired before 2002-06-21.",
        "ground_truth": "SELECT * FROM employees WHERE hire_date  <  '2002-06-21'",
        "amends": [
            "Do use the `employees` table name instead of `Employees` to match the correct schema. Do change the comparison operator to `<` for `hire_date` instead of `>` to select employees hired before June 21, 2002 instead of after that date. The amended query now correctly filters for employees hired before the specified date, matching the intended behavior of the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM Employees WHERE hire_date > '2002-06-21';",
            "SELECT * FROM employees WHERE hire_date < '2002-06-21';"
        ],
        "rule_sql": []
    },
    "5392": {
        "db_id": "tracking_software_problems",
        "question": "Find the top 3 products which have the largest number of problems?",
        "ground_truth": "SELECT T2.product_name FROM problems AS T1 JOIN product AS T2 ON T1.product_id = T2.product_id GROUP BY T2.product_name ORDER BY count(*) DESC LIMIT 3",
        "amends": [
            "Do select `T2.product_name` instead of `product_name` and remove the incorrect `COUNT(*) as problem_count` from the SELECT list. Do use `FROM problems AS T1 JOIN product AS T2` instead of `FROM products` to add the necessary tables and join. Do add the join condition `ON T1.product_id = T2.product_id` instead of omitting it. Do add `GROUP BY T2.product_name` instead of omitting grouping. Do change the ORDER BY to `count(*) DESC` instead of `problem_count ASC` to sort by the actual count in descending order. Do keep `LIMIT 3` as it was. The amended query now correctly counts problems per product and returns the top 3 products with the most problems, matching the RIGHT_SQL's behavior.",
            "Do remove `COUNT(*) as problem_count` from the SELECT list instead of including it, as the RIGHT_SQL only selects `T2.product_name`. Do keep the same FROM clause with `JOIN Product AS T2 ON T1.product_id = T2.product_id` unchanged. Do maintain the same `GROUP BY T2.product_name` grouping. Do preserve the `ORDER BY COUNT(*) DESC` ordering. Do retain the `LIMIT 3` clause. The amended query now matches RIGHT_SQL's behavior by selecting only the product names without the count aggregation in the output."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name, COUNT(*) as problem_count \nFROM products \nORDER BY problem_count ASC \nLIMIT 3;",
            "SELECT T2.product_name, COUNT(*) as problem_count\nFROM Problems AS T1\nJOIN Product AS T2 ON T1.product_id = T2.product_id\nGROUP BY T2.product_name\nORDER BY COUNT(*) DESC\nLIMIT 3",
            "SELECT T2.product_name\nFROM Problems AS T1\nJOIN Product AS T2 ON T1.product_id = T2.product_id\nGROUP BY T2.product_name\nORDER BY COUNT(*) DESC\nLIMIT 3"
        ],
        "rule_sql": []
    },
    "3395": {
        "db_id": "manufacturer",
        "question": "Which manufacturer has the most number of shops? List its name and year of opening.",
        "ground_truth": "SELECT open_year ,  name FROM manufacturer ORDER BY num_of_shops DESC LIMIT 1",
        "amends": [
            "Do select `open_year` and `name` columns instead of `manufacturer`, `COUNT(*) as shop_count`, and `year_opened`. Do query from `manufacturer` table instead of `shops` table. Do remove the `GROUP BY manufacturer` clause instead of keeping it. Do order by `num_of_shops DESC` instead of `shop_count DESC`. The amended query now correctly retrieves manufacturer details ordered by shop count from the appropriate table structure.",
            "Do use lowercase column names `open_year` and `name` instead of mixed case `Name` and `Open_Year`. Do use lowercase table name `manufacturer` instead of mixed case. Do use lowercase column name `num_of_shops` in ORDER BY instead of mixed case `Num_of_Shops`. The amended query now correctly matches the right SQL's behavior with consistent lowercase naming conventions.",
            "Do reverse the column order in the SELECT list, placing `open_year` before `name` instead of `name` before `open_year`. Do maintain the same `ORDER BY num_of_shops DESC` clause and `LIMIT 1` restriction without changes. The amended query now matches RIGHT_SQL's behavior by preserving the identical result set with only the column display order adjusted."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT manufacturer, COUNT(*) as shop_count, year_opened FROM shops GROUP BY manufacturer ORDER BY shop_count DESC LIMIT 1;",
            "SELECT Name, Open_Year FROM manufacturer ORDER BY Num_of_Shops DESC LIMIT 1;",
            "SELECT name, open_year FROM manufacturer ORDER BY num_of_shops DESC LIMIT 1;",
            "SELECT open_year, name FROM manufacturer ORDER BY num_of_shops DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "2042": {
        "db_id": "party_people",
        "question": "What are the different region names, ordered by labels?",
        "ground_truth": "SELECT DISTINCT region_name FROM region ORDER BY Label",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate region names. Do reference table `region` instead of `regions` to use the correct table name. Do order by `Label` instead of `region_id` to sort by the appropriate column. The amended query now correctly returns unique region names from the proper table sorted by label."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region_name FROM regions ORDER BY region_id;",
            "SELECT DISTINCT Region_name FROM region ORDER BY Label;"
        ],
        "rule_sql": []
    },
    "1485": {
        "db_id": "college_2",
        "question": "How many instructors teach a course in the Spring of 2010?",
        "ground_truth": "SELECT COUNT (DISTINCT ID) FROM teaches WHERE semester  =  'Spring' AND YEAR  =  2010",
        "amends": [
            "Do select `COUNT(DISTINCT ID)` from the `teaches` table instead of `COUNT(*)` from the `instructors` table. Do use the `teaches` table instead of the `instructors` table while keeping the same `semester = 'Spring'` and `year = 2010` filter conditions. The amended query now correctly counts distinct instructor IDs from the teaches table for Spring 2010 instead of counting all rows from the instructors table, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM instructors WHERE semester = 'Spring' AND year = 2010;",
            "SELECT COUNT(DISTINCT ID) FROM teaches WHERE semester = 'Spring' AND year = 2010;"
        ],
        "rule_sql": []
    },
    "4423": {
        "db_id": "network_2",
        "question": "How old is the average person for each job?",
        "ground_truth": "SELECT avg(age) ,  job FROM Person GROUP BY job",
        "amends": [
            "Do use `avg(age)` without an alias instead of `AVG(age)` with capitalization, do place `job` after the aggregate function instead of before it in the SELECT list, and do reference the table as `Person` instead of `people` while maintaining the same `GROUP BY job` structure. The amended query now correctly calculates average age by job from the Person table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT job, AVG(age) FROM people GROUP BY job;",
            "SELECT avg(age), job FROM Person GROUP BY job"
        ],
        "rule_sql": []
    },
    "122": {
        "db_id": "bike_1",
        "question": "What is the total and maximum duration for all trips with the bike id 636?",
        "ground_truth": "SELECT sum(duration) ,  max(duration) FROM trip WHERE bike_id  =  636",
        "amends": [
            "Do use `sum(duration)` without an alias instead of `SUM(duration) as total_duration`, and do use `max(duration)` instead of `AVG(duration) as average_duration`. Do reference table `trip` instead of `trips` while keeping the same `WHERE bike_id = 636` filter. The amended query now correctly calculates the sum and maximum duration for bike_id 636 from the trip table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(duration) as total_duration, AVG(duration) as average_duration FROM trips WHERE bike_id = 636;",
            "SELECT sum(duration), max(duration) FROM trip WHERE bike_id = 636"
        ],
        "rule_sql": []
    },
    "3012": {
        "db_id": "loan_1",
        "question": "Find the average number of customers in all banks of Utah state.",
        "ground_truth": "SELECT avg(no_of_customers) FROM bank WHERE state  =  'Utah'",
        "amends": [
            "Do reference the `no_of_customers` column instead of `customers` and use the correct table name `bank` instead of `banks`, while maintaining the same `AVG` aggregate function and `state = 'Utah'` filter condition. The amended query now correctly calculates the average number of customers for banks in Utah using the proper schema elements."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(customers) FROM banks WHERE state = 'Utah';",
            "SELECT AVG(no_of_customers) FROM bank WHERE state = 'Utah'"
        ],
        "rule_sql": []
    },
    "4800": {
        "db_id": "aircraft",
        "question": "What are the descriptions for the aircrafts?",
        "ground_truth": "SELECT Description FROM aircraft",
        "amends": [
            "Do select `Description` instead of `aircraft_name` and do reference table `aircraft` instead of `aircrafts`."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT aircraft_name FROM aircrafts;",
            "SELECT Description FROM aircraft;"
        ],
        "rule_sql": []
    },
    "4577": {
        "db_id": "company_office",
        "question": "Show the industries shared by companies whose headquarters are \"USA\" and companies whose headquarters are \"China\".",
        "ground_truth": "SELECT Industry FROM Companies WHERE Headquarters  =  \"USA\" INTERSECT SELECT Industry FROM Companies WHERE Headquarters  =  \"China\"",
        "amends": [
            "Do use `INTERSECT` to find common industries instead of the logically impossible `AND` condition that requires headquarters to be both 'USA' and 'China' simultaneously. Do reference the correct table name `Companies` instead of `companies` and column names `Industry` and `Headquarters` instead of `industry` and `headquarters`. Do use double quotes for string literals instead of single quotes. Do structure the query as two separate SELECT statements with INTERSECT instead of a single query with conflicting WHERE conditions. The amended query now correctly finds industries that exist in both USA and China headquarters locations, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT industry FROM companies WHERE headquarters = 'USA' AND headquarters = 'China';",
            "SELECT \"Industry\" FROM \"Companies\" WHERE \"Headquarters\" = \"USA\" INTERSECT SELECT \"Industry\" FROM \"Companies\" WHERE \"Headquarters\" = \"China\""
        ],
        "rule_sql": []
    },
    "3026": {
        "db_id": "loan_1",
        "question": "Find the number of different cities which banks are located at.",
        "ground_truth": "SELECT count(DISTINCT city) FROM bank",
        "amends": [
            "Do `count(DISTINCT city)` instead of `COUNT(*)` to count distinct cities rather than all rows. Do reference table `bank` instead of `banks` to use the correct table name. The amended query now correctly counts distinct cities from the bank table instead of counting all rows from the incorrect table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM banks;",
            "SELECT COUNT(DISTINCT city) FROM bank;"
        ],
        "rule_sql": []
    },
    "3780": {
        "db_id": "e_learning",
        "question": "How many distinct students are enrolled in courses?",
        "ground_truth": "SELECT count(DISTINCT student_id) FROM Student_Course_Enrolment",
        "amends": [
            "Do select `count(DISTINCT student_id)` instead of `COUNT(*)` to count unique student identifiers rather than all rows. Do query from `Student_Course_Enrolment` instead of `students` to access the enrollment data containing student IDs. The amended query now correctly counts distinct students from the enrollment table instead of counting all rows from a potentially incorrect source table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;",
            "SELECT COUNT(DISTINCT student_id) FROM Student_Course_Enrolment;"
        ],
        "rule_sql": []
    },
    "4999": {
        "db_id": "soccer_2",
        "question": "What are the names of all the players who received a yes during tryouts, and also what are the names of their colleges?",
        "ground_truth": "SELECT T1.pName ,  T2.cName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'",
        "amends": [
            "Do select `T1.pName` and `T2.cName` instead of `p.name` and `c.name`. Do join `tryout AS T2` instead of `colleges c` and use join condition `T1.pID = T2.pID` instead of `p.college_id = c.id`. Do filter on `T2.decision = 'yes'` instead of `p.tryout_result = 'yes'`. The amended query now correctly joins the player and tryout tables to filter based on tryout decisions rather than using a college join with an incorrect filter condition, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.name, c.name \nFROM players p \nJOIN colleges c ON p.college_id = c.id \nWHERE p.tryout_result = 'yes';",
            "SELECT T1.pName, T2.cName FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T2.decision = 'yes'"
        ],
        "rule_sql": []
    },
    "5104": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "What are the distinct payment method codes in all the invoices?",
        "ground_truth": "SELECT DISTINCT payment_method_code FROM INVOICES",
        "amends": [
            "Do select `payment_method_code` instead of `payment_method` to use the correct column name. Do add `DISTINCT` instead of omitting it to return unique values only. The amended query now correctly retrieves distinct payment method codes from the invoices table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT payment_method FROM invoices;",
            "SELECT DISTINCT payment_method_code FROM Invoices;"
        ],
        "rule_sql": []
    },
    "2137": {
        "db_id": "company_1",
        "question": "list the first and last names, and the addresses of all employees in the ascending order of their birth date.",
        "ground_truth": "SELECT fname ,  lname ,  address FROM employee ORDER BY Bdate",
        "amends": [
            "Do use column names `fname` and `lname` instead of `first_name` and `last_name`, and reference table `employee` instead of `employees`. Do order by `Bdate` instead of `birth_date` while maintaining the descending sort order. The amended query now correctly references the actual schema structure and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, address FROM employees ORDER BY birth_date DESC;",
            "SELECT Fname, Lname, Address FROM employee ORDER BY Bdate ASC;"
        ],
        "rule_sql": []
    },
    "225": {
        "db_id": "book_2",
        "question": "Show publishers that have more than one publication.",
        "ground_truth": "SELECT Publisher FROM publication GROUP BY Publisher HAVING COUNT(*)  >  1",
        "amends": [
            "Do select `Publisher` instead of `publisher_name` and use `publication` table instead of `publishers` table. Do move the aggregate condition to `HAVING COUNT(*) > 1` instead of placing it in the `WHERE` clause with `COUNT(publication_id) > 1`. Do group by `Publisher` instead of `publisher_id` and remove the incorrect table reference and column names. The amended query now correctly identifies publishers with multiple publications by using proper HAVING clause syntax and appropriate table and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT publisher_name FROM publishers WHERE COUNT(publication_id) > 1 GROUP BY publisher_id",
            "SELECT Publisher FROM publication GROUP BY Publisher HAVING COUNT(*) > 1;"
        ],
        "rule_sql": []
    },
    "5188": {
        "db_id": "music_2",
        "question": "Who performed the song named \"Badlands\"? Show the first name and the last name.",
        "ground_truth": "SELECT T2.firstname ,  T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId WHERE T3.Title  =  \"Badlands\"",
        "amends": [
            "Do select `T2.firstname` and `T2.lastname` from specific tables instead of `first_name` and `last_name` from a single table. Do use `FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate = T2.id JOIN Songs AS T3 ON T3.SongId = T1.SongId` instead of `FROM artists` with no joins. Do filter on `T3.Title = \"Badlands\"` instead of `song_name = 'Badlands'` to properly reference the song title from the Songs table. The amended query now correctly joins multiple tables to retrieve band member information for a specific song, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM artists WHERE song_name = 'Badlands';",
            "SELECT T2.Firstname, T2.Lastname \nFROM Performance AS T1 \nJOIN Band AS T2 ON T1.Bandmate = T2.Id \nJOIN Songs AS T3 ON T3.SongId = T1.SongId \nWHERE T3.Title = \"Badlands\""
        ],
        "rule_sql": []
    },
    "1342": {
        "db_id": "college_2",
        "question": "Find the title of courses that have two prerequisites?",
        "ground_truth": "SELECT T1.title FROM course AS T1 JOIN prereq AS T2 ON T1.course_id  =  T2.course_id GROUP BY T2.course_id HAVING count(*)  =  2",
        "amends": [
            "Do join `course AS T1` with `prereq AS T2` on `T1.course_id = T2.course_id` instead of querying only the `courses` table. Do use `GROUP BY T2.course_id` with `HAVING count(*) = 2` to count prerequisite relationships instead of filtering directly on `prerequisites = 2`. Do select `T1.title` from the joined result instead of just `title` from a single table. The amended query now correctly identifies courses with exactly two prerequisites by counting relationships in the prereq table rather than relying on a potentially incorrect prerequisites column value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM courses WHERE prerequisites = 2;",
            "SELECT T1.title \nFROM course AS T1 \nJOIN prereq AS T2 ON T1.course_id = T2.course_id \nGROUP BY T2.course_id \nHAVING COUNT(*) = 2"
        ],
        "rule_sql": []
    },
    "4442": {
        "db_id": "network_2",
        "question": "Find the name and age of the person who is a friend of Dan or Alice.",
        "ground_truth": "SELECT DISTINCT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Dan' OR T2.friend  =  'Alice'",
        "amends": [
            "Do use `DISTINCT T1.name, T1.age` instead of `name, age` without distinct. Do join `Person AS T1` with `PersonFriend AS T2` instead of querying only `persons`. Do specify `ON T1.name = T2.name` instead of missing the join condition. Do filter on `T2.friend = 'Dan' OR T2.friend = 'Alice'` instead of `friend = 'Dan' OR friend = 'Alice'` without table qualification. The amended query now correctly retrieves distinct person details by joining through the PersonFriend relationship table instead of directly filtering on a friend column that may not exist in the persons table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, age FROM persons WHERE friend = 'Dan' OR friend = 'Alice';",
            "SELECT DISTINCT T1.name, T1.age\nFROM Person AS T1\nJOIN PersonFriend AS T2 ON T1.name = T2.name\nWHERE T2.friend = 'Dan' OR T2.friend = 'Alice'"
        ],
        "rule_sql": []
    },
    "1453": {
        "db_id": "college_2",
        "question": "What are the names of students who haven't taken any Biology courses?",
        "ground_truth": "SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  'Biology')",
        "amends": [
            "Do select `name` from `student` instead of selecting `s.name` from multiple joined tables. Do use a `NOT IN` subquery instead of direct joins to filter students. Do reference `student` table directly instead of joining through `enrollments` and `courses`. Do filter with `dept_name = 'Biology'` in the subquery instead of `department = 'Biology'` in the main WHERE clause. Do use `takes` and `course` tables in the subquery instead of `enrollments` and `courses`. Do correlate on `id` and `course_id` in the subquery instead of joining through multiple tables in the main query. The amended query now correctly identifies students who have not taken Biology courses by using a NOT IN subquery with proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.name \nFROM students s\nJOIN enrollments e ON s.id = e.student_id\nJOIN courses c ON e.course_id = c.id\nWHERE c.department = 'Biology';",
            "SELECT name FROM student WHERE ID NOT IN (SELECT t.ID FROM takes t JOIN course c ON t.course_id = c.course_id WHERE c.dept_name = 'Biology')"
        ],
        "rule_sql": []
    },
    "1242": {
        "db_id": "apartment_rentals",
        "question": "Show the total number of rooms of the apartments in the building with short name \"Columbus Square\".",
        "ground_truth": "SELECT sum(T2.room_count) FROM Apartment_Buildings AS T1 JOIN Apartments AS T2 ON T1.building_id  =  T2.building_id WHERE T1.building_short_name  =  \"Columbus Square\"",
        "amends": [
            "Do select `sum(T2.room_count)` instead of `COUNT(*)` to calculate total room count rather than apartment count. Do join `Apartment_Buildings AS T1` and `Apartments AS T2` instead of querying only `apartments` to access building information. Do use `ON T1.building_id = T2.building_id` to properly relate buildings to their apartments. Do filter on `T1.building_short_name = \"Columbus Square\"` instead of `building_name = 'Columbus Square'` to use the correct column name and table reference. The amended query now correctly calculates total room count for the specified building by joining the appropriate tables and using the proper aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM apartments WHERE building_name = 'Columbus Square';",
            "SELECT SUM(CAST(T2.room_count AS INTEGER)) AS total_rooms\nFROM Apartment_Buildings AS T1\nJOIN Apartments AS T2 ON T1.building_id = T2.building_id\nWHERE T1.building_short_name = 'Columbus Square'"
        ],
        "rule_sql": []
    },
    "4605": {
        "db_id": "entertainment_awards",
        "question": "What is the average number of audience for festivals?",
        "ground_truth": "SELECT avg(Num_of_Audience) FROM festival_detail",
        "amends": [
            "Do reference the `festival_detail` table instead of the `festivals` table. Do use the `Num_of_Audience` column instead of the `audience` column. Do remove the `WHERE audience > 1000000` filter instead of keeping it. The amended query now correctly calculates the average number of audience members from the festival_detail table without unnecessary filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(audience) FROM festivals WHERE audience > 1000000;",
            "SELECT AVG(Num_of_Audience) FROM festival_detail;"
        ],
        "rule_sql": []
    },
    "1852": {
        "db_id": "wrestler",
        "question": "What are the names and location of the wrestlers?",
        "ground_truth": "SELECT Name ,  LOCATION FROM wrestler",
        "amends": [
            "Do use proper table name `wrestler` instead of incorrect pluralized `wrestlers`. Do capitalize column names `Name` and `LOCATION` instead of lowercase `name` and `location` to match the correct schema. Do remove the unnecessary `WHERE weight > 200` filter instead of including it, as the right query selects all records without filtering. The amended query now correctly accesses the proper table with the correct column casing and returns all records as intended."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, location FROM wrestlers WHERE weight > 200;",
            "SELECT Name, Location FROM wrestler"
        ],
        "rule_sql": []
    },
    "4393": {
        "db_id": "tracking_grants_for_research",
        "question": "What roles did staff members play between '2003-04-19 15:06:20' and '2016-03-15 00:33:18'?",
        "ground_truth": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'",
        "amends": [
            "Do select `role_code` from `Project_Staff` instead of `role` from `staff`. Do use `date_from > '2003-04-19 15:06:20'` and `date_to < '2016-03-15 00:33:18'` instead of `hire_date BETWEEN` with inclusive range. The amended query now correctly filters for records where the date range falls entirely within the specified period rather than including records that merely overlap with the boundary dates."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT role FROM staff WHERE hire_date BETWEEN '2003-04-19 15:06:20' AND '2016-03-15 00:33:18';",
            "SELECT DISTINCT role_code FROM Project_Staff WHERE date_from > '2003-04-19 15:06:20' AND date_to < '2016-03-15 00:33:18'"
        ],
        "rule_sql": []
    },
    "4048": {
        "db_id": "student_1",
        "question": "Find the first names of the teachers that teach first grade.",
        "ground_truth": "SELECT DISTINCT T2.firstname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE grade  =  1",
        "amends": [
            "Do select `DISTINCT T2.firstname` instead of `first_name` and add table alias `T2`. Do change FROM clause to `list AS T1 JOIN teachers AS T2` instead of just `teachers` and add join condition `ON T1.classroom = T2.classroom`. Do change WHERE filter to `grade = 1` (numeric) instead of `grade = '1st'` (string literal). The amended query now correctly retrieves distinct first names from teachers joined with list tables based on classroom matching, using proper numeric comparison for grade filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM teachers WHERE grade = '1st'",
            "SELECT DISTINCT T2.FirstName FROM list AS T1 JOIN teachers AS T2 ON T1.Classroom = T2.Classroom WHERE T1.Grade = 1"
        ],
        "rule_sql": []
    },
    "6338": {
        "db_id": "e_government",
        "question": "How many distinct payment methods are used by parties?",
        "ground_truth": "SELECT count(DISTINCT payment_method_code) FROM parties",
        "amends": [
            "Do `count(DISTINCT payment_method_code)` instead of `COUNT(*)` to count distinct payment method codes rather than all rows. Do add the `payment_method_code` column reference instead of omitting it to focus on specific data rather than total row count. The amended query now correctly counts distinct payment method codes from the parties table instead of simply counting all rows."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM parties;",
            "SELECT COUNT(DISTINCT payment_method_code) FROM Parties;"
        ],
        "rule_sql": []
    },
    "204": {
        "db_id": "bike_1",
        "question": "What are the different ids and names of the stations that have had more than 12 bikes available?",
        "ground_truth": "SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  12",
        "amends": [
            "Do use `DISTINCT` instead of omitting it, and select `T1.id` and `T1.name` instead of `station_id` and `name`. Do join `status AS T2` on `T1.id = T2.station_id` instead of querying only the stations table. Do filter on `T2.bikes_available > 12` instead of filtering on a non-existent `bikes_available` column in the stations table. The amended query now correctly joins the status table to access bike availability data and returns distinct station records matching the specified condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT station_id, name FROM stations WHERE bikes_available > 12",
            "SELECT DISTINCT T1.id, T1.name\nFROM station AS T1\nJOIN status AS T2 ON T1.id = T2.station_id\nWHERE T2.bikes_available > 12"
        ],
        "rule_sql": []
    },
    "4319": {
        "db_id": "club_1",
        "question": "Compute the average age of the members in the club \"Tennis Club\".",
        "ground_truth": "SELECT avg(t3.age) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Tennis Club\"",
        "amends": [
            "Do use explicit table joins with `club AS t1 JOIN member_of_club AS t2 ON t1.clubid = t2.clubid JOIN student AS t3 ON t2.stuid = t3.stuid` instead of querying a single `members` table. Do reference the age column as `t3.age` instead of just `age` without table qualification. Do filter on `t1.clubname = \"Tennis Club\"` instead of `club_name = 'Tennis Club'` to use the correct column name and table reference. Do use double quotes around the string literal instead of single quotes. The amended query now correctly joins the necessary tables to access student age data through the proper relationship structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age) FROM members WHERE club_name = 'Tennis Club';",
            "SELECT AVG(t3.age) AS average_age\nFROM club AS t1\nJOIN member_of_club AS t2 ON t1.ClubID = t2.ClubID\nJOIN student AS t3 ON t2.StuID = t3.StuID\nWHERE t1.ClubName = \"Tennis Club\""
        ],
        "rule_sql": []
    },
    "1831": {
        "db_id": "browser_web",
        "question": "What are the name and os of web client accelerators that do not work with only a 'Broadband' type connection?",
        "ground_truth": "SELECT name ,  operating_system FROM web_client_accelerator WHERE CONNECTION != 'Broadband'",
        "amends": [
            "Do reference column `operating_system` instead of `os` and table `web_client_accelerator` instead of `web_client_accelerators` in the FROM clause. Do use filter condition `CONNECTION != 'Broadband'` instead of `connection_type != 'Broadband'` in the WHERE clause. The amended query now correctly selects the operating system column from the proper table name with the appropriate connection filter condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, os FROM web_client_accelerators WHERE connection_type != 'Broadband';",
            "SELECT name, Operating_system FROM Web_client_accelerator WHERE Connection != 'Broadband'"
        ],
        "rule_sql": []
    },
    "2290": {
        "db_id": "entrepreneur",
        "question": "Return the investor who have invested in the greatest number of entrepreneurs.",
        "ground_truth": "SELECT Investor FROM entrepreneur GROUP BY Investor ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do reference the `Investor` column instead of `investor_name` and use the `entrepreneur` table instead of `investments`. Do use `COUNT(*)` instead of `COUNT(entrepreneur_id)` to count all rows in each group rather than counting non-null values of a specific column. The amended query now correctly identifies the investor with the most entrepreneurs by counting all records per investor group.",
            "Do select only `Investor` instead of selecting both `Investor` and `COUNT(*) AS entrepreneur_count`. Do order by `COUNT(*) DESC` instead of ordering by the alias `entrepreneur_count DESC`. The amended query now correctly returns only the Investor with the highest count while maintaining the same logical behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT investor_name FROM investments GROUP BY investor_name ORDER BY COUNT(entrepreneur_id) DESC LIMIT 1;",
            "SELECT Investor, COUNT(*) AS entrepreneur_count FROM entrepreneur GROUP BY Investor ORDER BY entrepreneur_count DESC LIMIT 1;",
            "SELECT Investor FROM entrepreneur GROUP BY Investor ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4825": {
        "db_id": "aircraft",
        "question": "List the names of aircrafts and the number of times it won matches.",
        "ground_truth": "SELECT T1.Aircraft ,  COUNT(*) FROM aircraft AS T1 JOIN MATCH AS T2 ON T1.Aircraft_ID  =  T2.Winning_Aircraft GROUP BY T2.Winning_Aircraft",
        "amends": [
            "Do specify `T1.Aircraft` instead of `aircraft_name` in the SELECT list. Do join `aircraft AS T1` to `MATCH AS T2` instead of querying only the `matches` table. Do use the join condition `T1.Aircraft_ID = T2.Winning_Aircraft` instead of missing the table relationship entirely. Do group by `T2.Winning_Aircraft` instead of `aircraft_name` to properly count matches per aircraft. The amended query now correctly counts matches per winning aircraft by establishing the proper table relationship through the join."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT aircraft_name, COUNT(*) FROM matches GROUP BY aircraft_name;",
            "SELECT T1.Aircraft, COUNT(T2.Winning_Aircraft) AS win_count\nFROM aircraft AS T1\nJOIN match AS T2 ON T1.Aircraft_ID = T2.Winning_Aircraft\nGROUP BY T2.Winning_Aircraft"
        ],
        "rule_sql": []
    },
    "3156": {
        "db_id": "assets_maintenance",
        "question": "Which assets did not incur any fault log? List the asset model.",
        "ground_truth": "SELECT asset_model FROM Assets WHERE asset_id NOT IN (SELECT asset_id FROM Fault_Log)",
        "amends": [
            "Do use a subquery with `NOT IN` to filter `asset_id` values that don't exist in the `Fault_Log` table instead of checking for `NULL` values in a `fault_log_id` column. Do reference the correct table name `Assets` instead of `assets` and maintain proper case sensitivity. Do remove the direct `IS NULL` filter on `fault_log_id` instead of keeping it, as the subquery approach correctly identifies assets without fault log entries by checking for the absence of matching `asset_id` values in the Fault_Log table rather than relying on a potentially missing foreign key reference. The amended query now correctly matches the intended behavior of finding assets that have no corresponding fault log entries."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT asset_model FROM assets WHERE fault_log_id IS NULL;",
            "SELECT asset_model FROM Assets WHERE asset_id NOT IN (SELECT asset_id FROM Fault_Log);"
        ],
        "rule_sql": []
    },
    "5024": {
        "db_id": "soccer_2",
        "question": "Find the names of either colleges in LA with greater than 15000 size or in state AZ with less than 13000 enrollment.",
        "ground_truth": "SELECT cName FROM College WHERE enr  <  13000 AND state = \"AZ\" UNION SELECT cName FROM College WHERE enr  >  15000 AND state = \"LA\"",
        "amends": [
            "Do use table alias `College` instead of `colleges` and column `cName` instead of `name`. Do change the WHERE clause structure to use separate UNION queries instead of a single complex OR condition. Do specify `enr < 13000 AND state = \"AZ\"` in the first branch instead of the original `(state = 'AZ' AND enrollment < 13000)`. Do specify `enr > 15000 AND state = \"LA\"` in the second branch instead of the original `(city = 'LA' AND size > 15000)`. Do use UNION instead of OR logic to combine the results, which ensures distinct records from both conditions. The amended query now correctly retrieves college names based on the specified enrollment and state criteria using proper UNION semantics."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM colleges WHERE (city = 'LA' AND size > 15000) OR (state = 'AZ' AND enrollment < 13000);",
            "SELECT cName FROM College WHERE enr > 15000 AND state = 'LA'\nUNION\nSELECT cName FROM College WHERE enr < 13000 AND state = 'AZ'"
        ],
        "rule_sql": []
    },
    "1100": {
        "db_id": "match_season",
        "question": "Show the name of colleges that have at least two players.",
        "ground_truth": "SELECT College FROM match_season GROUP BY College HAVING count(*)  >=  2",
        "amends": [
            "Do select `College` instead of `name` and use `count(*)` aggregation instead of `player_count` column. Do use `FROM match_season` instead of `FROM colleges` as the data source. Do move the count filter to `HAVING count(*) >= 2` instead of `WHERE player_count >= 2` and add `GROUP BY College` instead of omitting grouping. The amended query now correctly identifies colleges with at least two matches by counting occurrences in the match_season table rather than relying on a potentially incorrect player_count column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM colleges WHERE player_count >= 2;",
            "SELECT College FROM match_season GROUP BY College HAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "2983": {
        "db_id": "sakila_1",
        "question": "Count the number of different film ratings.",
        "ground_truth": "SELECT count(DISTINCT rating) FROM film",
        "amends": [
            "Do use `count(DISTINCT rating)` in the SELECT list instead of `COUNT(*)` with a GROUP BY clause. Do remove the `GROUP BY rating` clause instead of keeping it, as counting distinct values directly provides the unique count without grouping rows. The amended query now correctly counts distinct rating values from the film table instead of producing multiple counts grouped by rating."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM film GROUP BY rating;",
            "SELECT COUNT(DISTINCT rating) FROM film;"
        ],
        "rule_sql": []
    },
    "6173": {
        "db_id": "music_4",
        "question": "What is the average weeks on top of volumes associated with the artist aged 25 or younger?",
        "ground_truth": "SELECT avg(T2.Weeks_on_Top) FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T1.age  <=  25",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference `T2.Weeks_on_Top` instead of `weeks_on_top` without table qualification. Do use lowercase `avg` function instead of uppercase `AVG`. Do specify `artist AS T1` and `volume AS T2` instead of `volumes` and `artists` without aliases. Do join on `T1.Artist_ID = T2.Artist_ID` instead of `volumes.artist_id = artists.id`. Do filter on `T1.age <= 25` instead of `artists.age <= 25`. The amended query now correctly calculates the average weeks on top for artists aged 25 or younger using proper table references and join conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(weeks_on_top) FROM volumes JOIN artists ON volumes.artist_id = artists.id WHERE artists.age <= 25;",
            "SELECT avg(T2.Weeks_on_Top) \nFROM artist AS T1 \nJOIN volume AS T2 ON T1.Artist_ID = T2.Artist_ID \nWHERE T1.Age <= 25"
        ],
        "rule_sql": []
    },
    "4070": {
        "db_id": "student_1",
        "question": "Find the number of students taught by TARRING LEIA.",
        "ground_truth": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"TARRING\" AND T2.lastname  =  \"LEIA\"",
        "amends": [
            "Do join `list AS T1` with `teachers AS T2` on `T1.classroom = T2.classroom` instead of querying `students` table directly. Do filter on `T2.firstname = \"TARRING\"` and `T2.lastname = \"LEIA\"` instead of using `teacher = 'TARRING LEIA'`. Do use proper table relationships through classroom join instead of assuming teacher name is stored directly in students table. The amended query now correctly counts students by joining through classroom relationships and filtering on teacher names separately."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE teacher = 'TARRING LEIA';",
            "SELECT COUNT(*) \nFROM list AS T1\nJOIN teachers AS T2 ON T1.Classroom = T2.Classroom\nWHERE T2.FirstName = 'TARRING' AND T2.LastName = 'LEIA'"
        ],
        "rule_sql": []
    },
    "5421": {
        "db_id": "shop_membership",
        "question": "What are the names of the members and branches at which they are registered sorted by year of registration?",
        "ground_truth": "SELECT T3.name ,  T2.name FROM membership_register_branch AS T1 JOIN branch AS T2 ON T1.branch_id  =  T2.branch_id JOIN member AS T3 ON T1.member_id  =  T3.member_id ORDER BY T1.register_year",
        "amends": [
            "Do specify explicit table aliases `T3.name` and `T2.name` instead of ambiguous column references `member_name` and `branch_name`. Do join `membership_register_branch AS T1` with `branch AS T2` on `T1.branch_id = T2.branch_id` instead of omitting these tables entirely. Do add a second join to `member AS T3` on `T1.member_id = T3.member_id` instead of querying a single table. Do reference `T1.register_year` in the ORDER BY instead of `registration_year` which doesn't exist in the joined tables. The amended query now correctly retrieves member and branch names through proper table relationships and matches the RIGHT_SQL's behavior.",
            "Do remove `T1.Register_Year` from the SELECT list instead of including it. Do use lowercase column names `T3.name` and `T2.name` instead of uppercase aliases `member_name` and `branch_name`. Do use lowercase column references in the ORDER BY clause `T1.register_year` instead of `T1.Register_Year`. The amended query now matches RIGHT_SQL's behavior by focusing only on member and branch names while maintaining the same chronological ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT member_name, branch_name FROM members ORDER BY registration_year;",
            "SELECT T3.Name AS member_name, T2.Name AS branch_name, T1.Register_Year\nFROM membership_register_branch AS T1\nJOIN branch AS T2 ON T1.Branch_ID = T2.Branch_ID\nJOIN member AS T3 ON T1.Member_ID = T3.Member_ID\nORDER BY T1.Register_Year;",
            "SELECT T3.name, T2.name\nFROM membership_register_branch AS T1\nJOIN branch AS T2 ON T1.Branch_ID = T2.Branch_ID\nJOIN member AS T3 ON T1.Member_ID = T3.Member_ID\nORDER BY T1.register_year"
        ],
        "rule_sql": []
    },
    "4627": {
        "db_id": "customers_campaigns_ecommerce",
        "question": "Show the outcome code of mailshots along with the number of mailshots in each outcome code.",
        "ground_truth": "SELECT outcome_code ,  count(*) FROM mailshot_customers GROUP BY outcome_code",
        "amends": [
            "Do use table `mailshot_customers` instead of `mailshots` as the FROM source. The amended query now correctly counts outcomes from the appropriate customer-focused table rather than the general mailshots table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT outcome_code, COUNT(*) FROM mailshots GROUP BY outcome_code;",
            "SELECT outcome_code, COUNT(*) AS number_of_mailshots FROM Mailshot_Customers GROUP BY outcome_code;"
        ],
        "rule_sql": []
    },
    "4708": {
        "db_id": "college_3",
        "question": "What are the first names of all students that are not enrolled in courses?",
        "ground_truth": "SELECT Fname FROM STUDENT WHERE StuID NOT IN (SELECT StuID FROM ENROLLED_IN)",
        "amends": [
            "Do use `Fname` instead of `first_name` for the column selection. Do reference table `STUDENT` instead of `students` as the main source. Do use `StuID` instead of `student_id` for the primary key identifier. Do reference table `ENROLLED_IN` instead of `enrollments` in the subquery. The amended query now correctly matches the RIGHT_SQL's behavior with proper table and column names."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM students WHERE student_id NOT IN (SELECT student_id FROM enrollments);",
            "SELECT Fname FROM Student WHERE StuID NOT IN (SELECT StuID FROM Enrolled_in)"
        ],
        "rule_sql": []
    },
    "736": {
        "db_id": "customers_card_transactions",
        "question": "How many different types of transactions are there?",
        "ground_truth": "SELECT count(DISTINCT transaction_type) FROM Financial_Transactions",
        "amends": [
            "Do `count(DISTINCT transaction_type)` instead of `COUNT(*)` to count distinct transaction types rather than all rows. Do `FROM Financial_Transactions` instead of `FROM transactions` to query from the correct table. The amended query now correctly counts distinct transaction types from the Financial_Transactions table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM transactions;",
            "SELECT COUNT(DISTINCT transaction_type) FROM Financial_Transactions;"
        ],
        "rule_sql": []
    },
    "1553": {
        "db_id": "customers_and_invoices",
        "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.",
        "ground_truth": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'",
        "amends": [
            "Do select `T1.account_id`, `T1.date_account_opened`, `T1.account_name`, and `T1.other_account_details` instead of `id`, `account_name`, and `account_details`. Do join `Accounts AS T1` with `Customers AS T2` on `T1.customer_id = T2.customer_id` instead of querying only the `accounts` table. Do filter on `T2.customer_first_name = 'Meaghan'` instead of filtering directly on the accounts table's customer_first_name field. The amended query now correctly joins customer data to filter by customer name and returns the appropriate account details, matching the RIGHT_SQL's behavior.",
            "Do reorder the SELECT list to `T1.account_id`, `T1.date_account_opened`, `T1.account_name`, `T1.other_account_details` instead of the original sequence `T1.account_id`, `T1.account_name`, `T1.other_account_details`, `T1.date_account_opened`. The JOIN condition `T1.customer_id = T2.customer_id` and WHERE filter `T2.customer_first_name = 'Meaghan'` remain unchanged. The amended query now matches RIGHT_SQL's behavior with identical column selection and ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, account_name, account_details FROM accounts WHERE customer_first_name = 'Meaghan'",
            "SELECT T1.account_id, T1.account_name, T1.other_account_details, T1.date_account_opened FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id = T2.customer_id WHERE T2.customer_first_name = 'Meaghan'",
            "SELECT T1.account_id, T1.date_account_opened, T1.account_name, T1.other_account_details\nFROM Accounts AS T1\nJOIN Customers AS T2 ON T1.customer_id = T2.customer_id\nWHERE T2.customer_first_name = 'Meaghan'"
        ],
        "rule_sql": []
    },
    "2680": {
        "db_id": "party_host",
        "question": "Show the locations of parties and the names of the party hosts in ascending order of the age of the host.",
        "ground_truth": "SELECT T3.Location ,  T2.Name FROM party_host AS T1 JOIN HOST AS T2 ON T1.Host_ID  =  T2.Host_ID JOIN party AS T3 ON T1.Party_ID  =  T3.Party_ID ORDER BY T2.Age",
        "amends": [
            "Do use explicit table aliases `T3.Location` and `T2.Name` instead of ambiguous column references `location` and `host_name`. Do add `JOIN HOST AS T2 ON T1.Host_ID = T2.Host_ID` and `JOIN party AS T3 ON T1.Party_ID = T3.Party_ID` instead of querying a single table `parties`. Do change the ORDER BY to `T2.Age` instead of `host_age` to reference the correct column from the joined table. The amended query now properly joins the necessary tables to retrieve location and host information with correct column references and ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location, host_name FROM parties ORDER BY host_age DESC;",
            "SELECT T3.Location, T2.Name \nFROM party_host AS T1 \nJOIN host AS T2 ON T1.Host_ID = T2.Host_ID \nJOIN party AS T3 ON T1.Party_ID = T3.Party_ID \nORDER BY T2.Age ASC"
        ],
        "rule_sql": []
    },
    "2495": {
        "db_id": "movie_1",
        "question": "For each director, how many reviews have they received?",
        "ground_truth": "SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director",
        "amends": [
            "Do add `JOIN Rating AS T2 ON T1.mID = T2.mID` instead of querying only the `movies` table. Do specify `T1.director` instead of just `director` to clarify the table source. Do move the `count(*)` column to the first position instead of having `director` first. Do add table alias `Movie AS T1` instead of using the bare table name. The amended query now correctly joins the Movie and Rating tables to count ratings per director instead of just counting movies per director, matching the RIGHT_SQL's behavior.",
            "Do place the `count(*)` expression before `T1.director` in the SELECT list instead of listing `T1.director` first. Do omit the alias `review_count` for the count instead of including it. The amended query now correctly returns the director and their review count without the alias, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT director, COUNT(*) FROM movies GROUP BY director;",
            "SELECT T1.director, COUNT(*) AS review_count FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID = T2.mID GROUP BY T1.director",
            "SELECT count(*), T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID = T2.mID GROUP BY T1.director"
        ],
        "rule_sql": []
    },
    "3103": {
        "db_id": "behavior_monitoring",
        "question": "Find all information about student addresses, and sort by monthly rental in descending order.",
        "ground_truth": "SELECT * FROM Student_Addresses ORDER BY monthly_rental DESC",
        "amends": [
            "Do reference the `Student_Addresses` table instead of the `students` table. Do sort by `monthly_rental DESC` instead of `monthly_rental ASC` to change the sort order from ascending to descending. The amended query now correctly references the appropriate table and sorts in descending order as specified."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM students ORDER BY monthly_rental ASC;",
            "SELECT * FROM Student_Addresses ORDER BY monthly_rental DESC;"
        ],
        "rule_sql": []
    },
    "905": {
        "db_id": "insurance_fnol",
        "question": "What is the effective date of the claim that has the largest amount of total settlement?",
        "ground_truth": "SELECT t1.Effective_Date FROM claims AS t1 JOIN settlements AS t2 ON t1.claim_id  =  t2.claim_id GROUP BY t1.claim_id ORDER BY sum(t2.settlement_amount) DESC LIMIT 1",
        "amends": [
            "Do add `JOIN settlements AS t2 ON t1.claim_id = t2.claim_id` instead of querying only the claims table. Do add `GROUP BY t1.claim_id` instead of omitting grouping. Do change the ORDER BY to `sum(t2.settlement_amount) DESC` instead of `total_settlement DESC` since the total_settlement column doesn't exist and must be calculated from settlement amounts. Do select `t1.Effective_Date` with proper table alias instead of just `effective_date`. The amended query now correctly joins claims with settlements, groups by claim_id to calculate total settlements per claim, and orders by the summed settlement amounts to find the claim with the highest total settlement, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT effective_date FROM claims ORDER BY total_settlement DESC LIMIT 1;",
            "SELECT t1.Effective_Date\nFROM Claims AS t1\nJOIN Settlements AS t2 ON t1.Claim_ID = t2.Claim_ID\nGROUP BY t1.Claim_ID\nORDER BY SUM(t2.Settlement_Amount) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5235": {
        "db_id": "music_2",
        "question": "What are the different types of vocals?",
        "ground_truth": "SELECT DISTINCT TYPE FROM vocals",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT type FROM vocals;"
        ],
        "rule_sql": []
    },
    "2398": {
        "db_id": "candidate_poll",
        "question": "what are the top 3 highest support rates?",
        "ground_truth": "SELECT support_rate FROM candidate ORDER BY support_rate DESC LIMIT 3",
        "amends": [
            "Do reference table `candidate` instead of `elections` in the FROM clause. The amended query now correctly selects from the candidate table to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT support_rate FROM elections ORDER BY support_rate DESC LIMIT 3;",
            "SELECT Support_rate FROM candidate ORDER BY Support_rate DESC LIMIT 3;"
        ],
        "rule_sql": []
    },
    "5242": {
        "db_id": "music_2",
        "question": "What instrument did the musician with last name \"Heilo\" use in the song \"Badlands\"?",
        "ground_truth": "SELECT T4.instrument FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId JOIN Instruments AS T4 ON T4.songid  =  T3.songid AND T4.bandmateid  =  T2.id WHERE T2.lastname  =  \"Heilo\" AND T3.title  =  \"Badlands\"",
        "amends": [
            "Do join `Performance AS T1`, `Band AS T2`, `Songs AS T3`, and `Instruments AS T4` with explicit join conditions instead of querying a single `musicians` table. Do use `T2.lastname = \"Heilo\"` and `T3.title = \"Badlands\"` as WHERE filters instead of `last_name = 'Heilo'` and `song_title = 'Badlands'` on a single table. Do select `T4.instrument` from the joined `Instruments` table instead of `instrument` from a non-existent `musicians` table. Do add proper join predicates including `T1.bandmate = T2.id`, `T3.SongId = T1.SongId`, and `T4.songid = T3.songid AND T4.bandmateid = T2.id` instead of missing all relationship definitions. The amended query now correctly retrieves instruments by joining the necessary tables with proper relationships to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT instrument FROM musicians WHERE last_name = 'Heilo' AND song_title = 'Badlands';",
            "SELECT T4.Instrument\nFROM Performance AS T1\nJOIN Band AS T2 ON T1.Bandmate = T2.Id\nJOIN Songs AS T3 ON T1.SongId = T3.SongId\nJOIN Instruments AS T4 ON T4.SongId = T3.SongId AND T4.BandmateId = T2.Id\nWHERE T2.Lastname = 'Heilo' AND T3.Title = 'Badlands'"
        ],
        "rule_sql": []
    },
    "3713": {
        "db_id": "mountain_photos",
        "question": "List the id, color scheme, and name for all the photos.",
        "ground_truth": "SELECT id ,  color ,  name FROM photos",
        "amends": [
            "Do select `color` and `name` columns instead of `color_scheme` and `photo_name`. Do use the correct column names `color` and `name` instead of the incorrect `color_scheme` and `photo_name` that don't exist in the schema. The amended query now correctly retrieves the available columns from the photos table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, color_scheme, photo_name FROM photos",
            "SELECT id, color, name FROM photos;"
        ],
        "rule_sql": []
    },
    "2222": {
        "db_id": "formula_1",
        "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?",
        "ground_truth": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = \"Monaco Grand Prix\"",
        "amends": [
            "Do join `results AS T2` on `T1.raceid = T2.raceid` instead of querying only the `races` table. Do reference `T2.fastestlapspeed` instead of `fastest_lap_speed` from the races table. Do filter on `T1.name = \"Monaco Grand Prix\"` instead of `race_name = 'Monaco Grand Prix'`. Do use table aliases `T1` and `T2` instead of no aliases. The amended query now correctly retrieves the maximum fastest lap speed from the results table joined with races, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(fastest_lap_speed) FROM races WHERE race_name = 'Monaco Grand Prix' AND year = 2008;",
            "SELECT MAX(T2.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races AS T1\nJOIN results AS T2 ON T1.raceId = T2.raceId\nWHERE T1.name = 'Monaco Grand Prix' AND T1.year = 2008;"
        ],
        "rule_sql": []
    },
    "4862": {
        "db_id": "school_player",
        "question": "List the locations of schools in ascending order of enrollment.",
        "ground_truth": "SELECT LOCATION FROM school ORDER BY Enrollment ASC",
        "amends": [
            "Do reference the correct table name `school` instead of the incorrect plural `schools`. Do use the correct column name `Enrollment` instead of the incorrect `enrollment`. Do specify `ASC` sort order instead of `DESC` to sort in ascending rather than descending order. The amended query now correctly retrieves location data from the school table ordered by enrollment in ascending sequence, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location FROM schools ORDER BY enrollment DESC;",
            "SELECT Location FROM school ORDER BY Enrollment ASC;"
        ],
        "rule_sql": []
    },
    "2722": {
        "db_id": "storm_record",
        "question": "Show all storm names except for those with at least two affected regions.",
        "ground_truth": "SELECT name FROM storm EXCEPT SELECT T1.name FROM storm AS T1 JOIN affected_region AS T2 ON T1.storm_id  =  T2.storm_id GROUP BY T1.storm_id HAVING count(*)  >=  2",
        "amends": [
            "Do use `EXCEPT` instead of `NOT IN` with a subquery. Do reference the main table as `storm` instead of `storms`. Do add table aliases `T1` and `T2` instead of omitting them. Do use `JOIN` with explicit `ON T1.storm_id = T2.storm_id` instead of a correlated subquery. Do group by `T1.storm_id` instead of just `storm_id`. Do use `count(*)` instead of `COUNT(region_id)` for the aggregate condition. Do reference the table as `affected_region` instead of `affected_regions` in the join. The amended query now correctly identifies storms that have affected fewer than two regions using proper set operations and explicit joins."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM storms WHERE storm_id NOT IN (SELECT storm_id FROM affected_regions GROUP BY storm_id HAVING COUNT(region_id) >= 2);",
            "SELECT Name FROM storm\nEXCEPT\nSELECT T1.Name\nFROM storm T1\nJOIN affected_region T2 ON T1.Storm_ID = T2.Storm_ID\nGROUP BY T1.Storm_ID\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "4813": {
        "db_id": "aircraft",
        "question": "List names of all pilot aged 30 or younger in descending alphabetical order.",
        "ground_truth": "SELECT Name FROM pilot WHERE Age  <=  30 ORDER BY Name DESC",
        "amends": [
            "Do reference the `Name` column instead of `name` to match the correct column name casing. Do reference the `pilot` table instead of `pilots` to use the correct table name. Do reference the `Age` column instead of `age` to match the correct column name casing. Do use `ORDER BY Name DESC` instead of `ORDER BY name ASC` to sort in descending order rather than ascending order. The amended query now correctly retrieves pilot names from the pilot table where age is 30 or younger, sorted in descending alphabetical order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM pilots WHERE age <= 30 ORDER BY name ASC;",
            "SELECT Name FROM pilot WHERE Age <= 30 ORDER BY Name DESC;"
        ],
        "rule_sql": []
    },
    "5519": {
        "db_id": "products_gen_characteristics",
        "question": "Count the number of colors.",
        "ground_truth": "SELECT count(*) FROM ref_colors",
        "amends": [
            "Do reference the `ref_colors` table instead of the non-existent `colors` table, as the correct table name contains the `ref_` prefix that was omitted in the original query. The amended query now correctly counts records from the proper table reference and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM colors;",
            "SELECT COUNT(*) FROM Ref_Colors;"
        ],
        "rule_sql": []
    },
    "2203": {
        "db_id": "formula_1",
        "question": "What are the names of races held between 2009 and 2011?",
        "ground_truth": "SELECT name FROM races WHERE YEAR BETWEEN 2009 AND 2011",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM races WHERE year BETWEEN 2009 AND 2011;"
        ],
        "rule_sql": []
    },
    "1010": {
        "db_id": "university_basketball",
        "question": "How many universities have a location that contains NY?",
        "ground_truth": "SELECT count(*) FROM university WHERE LOCATION LIKE \"%NY%\"",
        "amends": [
            "Do reference table `university` instead of `universities` to match the correct table name. Do use `LIKE \"%NY%\"` instead of `= 'NY'` to find locations containing \"NY\" rather than exact matches. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency, though this is a cosmetic change. The amended query now correctly searches for locations containing \"NY\" in the proper table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM universities WHERE location = 'NY';",
            "SELECT count(*) FROM university WHERE Location LIKE \"%NY%\""
        ],
        "rule_sql": []
    },
    "5529": {
        "db_id": "products_gen_characteristics",
        "question": "Return the names of products in the category 'Spices'.",
        "ground_truth": "SELECT product_name FROM products WHERE product_category_code  =  \"Spices\"",
        "amends": [
            "Do select `product_name` instead of `name` and filter on `product_category_code` instead of `category`. Do use double quotes `\"Spices\"` instead of single quotes `'Spices'` for the string literal. The amended query now correctly references the actual column names and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM products WHERE category = 'Spices';",
            "SELECT product_name FROM Products WHERE product_category_code = \"Spices\""
        ],
        "rule_sql": []
    },
    "4129": {
        "db_id": "film_rank",
        "question": "What are the countries for each market ordered by decreasing number of cities?",
        "ground_truth": "SELECT Country FROM market ORDER BY Number_cities DESC",
        "amends": [
            "Do select `Country` instead of `country, COUNT(city) as city_count` and remove the aggregation. Do use table `market` instead of `markets` and remove the `GROUP BY country` clause. Do order by `Number_cities DESC` instead of `city_count ASC` and remove the alias reference. The amended query now correctly selects just the country column from the market table ordered by Number_cities in descending order, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(city) as city_count FROM markets GROUP BY country ORDER BY city_count ASC;",
            "SELECT Country FROM market ORDER BY Number_cities DESC;"
        ],
        "rule_sql": []
    },
    "2717": {
        "db_id": "storm_record",
        "question": "Return the name and max speed of the storm that affected the most regions.",
        "ground_truth": "SELECT T1.name ,  T1.max_speed FROM storm AS T1 JOIN affected_region AS T2 ON T1.storm_id  =  T2.storm_id GROUP BY T1.storm_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add table `storm AS T1` and `affected_region AS T2` with a `JOIN` on `T1.storm_id = T2.storm_id` instead of querying only the `storms` table. Do change the SELECT list to include `T1.name` and `T1.max_speed` instead of just `name` and `max_speed`. Do add `GROUP BY T1.storm_id` and change the ORDER BY to `count(*) DESC` instead of `max_speed DESC` to order by the number of affected regions per storm rather than maximum wind speed. The amended query now correctly identifies the storm that affected the most regions rather than simply the fastest storm, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, max_speed FROM storms ORDER BY max_speed DESC LIMIT 1;",
            "SELECT T1.Name, T1.Max_speed\nFROM storm AS T1\nJOIN affected_region AS T2 ON T1.Storm_ID = T2.Storm_ID\nGROUP BY T1.Storm_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5860": {
        "db_id": "tracking_share_transactions",
        "question": "Return the lot details and investor ids.",
        "ground_truth": "SELECT lot_details ,  investor_id FROM LOTS",
        "amends": [
            "Do specify explicit column names `lot_details` and `investor_id` instead of using `SELECT *` which returns all columns. Do reference the single table `LOTS` instead of performing a cross join between `lots` and `investors` tables. The amended query now correctly selects only the required columns from the appropriate table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM lots, investors;",
            "SELECT lot_details, investor_id FROM Lots"
        ],
        "rule_sql": []
    },
    "4514": {
        "db_id": "document_management",
        "question": "What are the names of documents that have both one of the three most common types and one of three most common structures?",
        "ground_truth": "SELECT document_name FROM documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT 3 INTERSECT SELECT document_name FROM documents GROUP BY document_structure_code ORDER BY count(*) DESC LIMIT 3",
        "amends": [
            "Do select `document_name` instead of `d.name` and remove the table alias. Do use `INTERSECT` to find common document names instead of joining on two subqueries. Do group by `document_type_code` and `document_structure_code` in separate queries instead of grouping by `type` and `structure` in joined subqueries. Do order by `count(*) DESC` instead of ordering by aliased `count` columns. Do apply `LIMIT 3` to each individual query result before intersecting instead of limiting the subqueries used for joining. Do remove the JOIN operations and subquery structure entirely instead of maintaining complex nested queries. The amended query now correctly finds document names that appear in both the top 3 most common document types and top 3 most common document structures using INTERSECT, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": -1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT d.name \nFROM documents d\nJOIN (\n    SELECT type, COUNT(*) as count\n    FROM documents\n    GROUP BY type\n    ORDER BY count DESC\n    LIMIT 3\n) common_types ON d.type = common_types.type\nJOIN (\n    SELECT structure, COUNT(*) as count\n    FROM documents\n    GROUP BY structure\n    ORDER BY count DESC\n    LIMIT 3\n) common_structures ON d.structure = common_structures.structure;",
            "SELECT document_name FROM Documents WHERE document_type_code IN (SELECT document_type_code FROM Documents GROUP BY document_type_code ORDER BY COUNT(*) DESC LIMIT 3) INTERSECT SELECT document_name FROM Documents WHERE document_structure_code IN (SELECT document_structure_code FROM Documents GROUP BY document_structure_code ORDER BY COUNT(*) DESC LIMIT 3)"
        ],
        "rule_sql": []
    },
    "554": {
        "db_id": "store_1",
        "question": "What are the titles of all the albums alphabetically ascending?",
        "ground_truth": "SELECT title FROM albums ORDER BY title;",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM albums ORDER BY title DESC;"
        ],
        "rule_sql": []
    },
    "3623": {
        "db_id": "music_1",
        "question": "List the duration, file size and format of songs whose genre is pop, ordered by title?",
        "ground_truth": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  \"pop\" ORDER BY T2.song_name",
        "amends": [
            "Do reference columns with table aliases `T1.duration`, `T1.file_size`, and `T1.formats` instead of bare column names `duration`, `file_size`, and `format`. Do use `FROM files AS T1 JOIN song AS T2` instead of `FROM songs` to properly join the files and song tables. Do specify the join condition `ON T1.f_id = T2.f_id` instead of omitting any join relationship. Do filter with `WHERE T2.genre_is = \"pop\"` instead of `WHERE genre = 'pop'` to use the correct column name and table reference. Do order by `T2.song_name` instead of `artist` to sort by the appropriate song attribute. The amended query now correctly joins the related tables and uses proper table-qualified column references to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT duration, file_size, format FROM songs WHERE genre = 'pop' ORDER BY artist;",
            "SELECT T1.duration, T1.file_size, T1.formats\nFROM files AS T1\nJOIN song AS T2 ON T1.f_id = T2.f_id\nWHERE T2.genre_is = 'pop'\nORDER BY T2.song_name"
        ],
        "rule_sql": []
    },
    "3605": {
        "db_id": "music_1",
        "question": "Find the names and number of works of all artists who have at least one English songs.",
        "ground_truth": "SELECT T1.artist_name ,  count(*) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  \"english\" GROUP BY T2.artist_name HAVING count(*)  >=  1",
        "amends": [
            "Do join `artist AS T1` with `song AS T2` on `T1.artist_name = T2.artist_name` instead of querying only the `songs` table. Do filter on `T2.languages = \"english\"` instead of `language = 'English'` and ensure the column reference includes the table alias. Do add a `HAVING count(*) >= 1` clause instead of omitting it, which explicitly filters groups with at least one record. Do reference `T2.artist_name` in the `GROUP BY` instead of just `artist_name` to maintain clarity with table aliases. The amended query now correctly joins artist and song tables, filters by language with proper table qualification, and includes explicit group filtering to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT artist_name, COUNT(*) FROM songs WHERE language = 'English' GROUP BY artist_name;",
            "SELECT T1.artist_name, COUNT(*) AS number_of_works\nFROM artist AS T1\nJOIN song AS T2 ON T1.artist_name = T2.artist_name\nWHERE T2.languages = 'english'\nGROUP BY T2.artist_name\nHAVING COUNT(*) >= 1"
        ],
        "rule_sql": []
    },
    "1587": {
        "db_id": "customers_and_invoices",
        "question": "Show the transaction types and the total amount of transactions.",
        "ground_truth": "SELECT transaction_type ,  sum(transaction_amount) FROM Financial_transactions GROUP BY transaction_type",
        "amends": [
            "Do reference the correct table `Financial_transactions` instead of `transactions`. Do use `sum(transaction_amount)` instead of `COUNT(*) as total_amount` to properly calculate the total transaction amounts rather than counting rows. Do remove the alias `total_amount` instead of keeping it since the aggregate function no longer requires an alias. The amended query now correctly calculates the sum of transaction amounts by transaction type from the appropriate Financial_transactions table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT transaction_type, COUNT(*) as total_amount FROM transactions GROUP BY transaction_type;",
            "SELECT transaction_type, SUM(transaction_amount) FROM Financial_Transactions GROUP BY transaction_type;"
        ],
        "rule_sql": []
    },
    "3377": {
        "db_id": "sports_competition",
        "question": "how many different positions are there?",
        "ground_truth": "SELECT count(DISTINCT POSITION) FROM player",
        "amends": [
            "Do use table `player` instead of `employees` and count `DISTINCT POSITION` instead of counting all rows with `COUNT(*)`."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees;",
            "SELECT COUNT(DISTINCT Position) FROM player;"
        ],
        "rule_sql": []
    },
    "5272": {
        "db_id": "manufactory_1",
        "question": "Who is the founder of Sony?",
        "ground_truth": "SELECT founder FROM manufacturers WHERE name  =  'Sony'",
        "amends": [
            "Do query the `manufacturers` table instead of the `companies` table. Do use the same column names `founder` and `name` with the same filter condition `= 'Sony'` instead of changing them. The amended query now correctly retrieves data from the appropriate table while maintaining the same selection criteria and filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT founder FROM companies WHERE name = 'Sony';",
            "SELECT Founder FROM Manufacturers WHERE Name = 'Sony';"
        ],
        "rule_sql": []
    },
    "1106": {
        "db_id": "match_season",
        "question": "What are the names of countries that have both players with position forward and players with position defender?",
        "ground_truth": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  \"Forward\" INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  \"Defender\"",
        "amends": [
            "Do use `INTERSECT` to find countries with both positions instead of joining the same table twice with different filters. Do reference `country_name` from the `country` table instead of `name` from `countries`. Do join with `match_season` table instead of `players` table. Do use proper column names `Country_id` and `Country` for the join condition instead of `id` and `country_id`. Do filter for positions \"Forward\" and \"Defender\" with proper capitalization instead of lowercase \"forward\" and \"defender\". Do remove the `DISTINCT` keyword since `INTERSECT` inherently returns unique results instead of keeping it. The amended query now correctly identifies countries that have both Forward and Defender positions by using set intersection rather than a flawed double join approach."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT c.name \nFROM countries c \nJOIN players p1 ON c.id = p1.country_id \nJOIN players p2 ON c.id = p2.country_id \nWHERE p1.position = 'forward' AND p2.position = 'defender';",
            "SELECT c.Country_name\nFROM country c\nJOIN match_season ms ON c.Country_id = ms.Country\nWHERE ms.Position = 'Forward'\nINTERSECT\nSELECT c.Country_name\nFROM country c\nJOIN match_season ms ON c.Country_id = ms.Country\nWHERE ms.Position = 'Defender'"
        ],
        "rule_sql": []
    },
    "691": {
        "db_id": "customers_card_transactions",
        "question": "How many customers do we have?",
        "ground_truth": "SELECT count(*) FROM Customers",
        "amends": [
            "Do specify the table source as `Customers` instead of `orders` to count the correct entity. The amended query now matches RIGHT_SQL's behavior by counting records from the Customers table rather than the orders table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders;",
            "SELECT COUNT(*) FROM Customers;"
        ],
        "rule_sql": []
    },
    "76": {
        "db_id": "student_assessment",
        "question": "What is the id of the candidate who most recently accessed the course?",
        "ground_truth": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1",
        "amends": [
            "Do select from `candidate_assessments` table instead of `course_access` table. Do order by `assessment_date DESC` instead of `access_date ASC`. The amended query now correctly retrieves candidate data from the assessments table with descending date ordering, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT candidate_id FROM course_access ORDER BY access_date ASC LIMIT 1;",
            "SELECT candidate_id FROM Candidate_Assessments ORDER BY assessment_date DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "258": {
        "db_id": "musical",
        "question": "Show names of musicals which have at least three actors.",
        "ground_truth": "SELECT T2.Name FROM actor AS T1 JOIN musical AS T2 ON T1.Musical_ID  =  T2.Musical_ID GROUP BY T1.Musical_ID HAVING COUNT(*)  >=  3",
        "amends": [
            "Do select `T2.Name` from the `musical` table instead of `name` from the `musicals` table. Do join `actor AS T1` to `musical AS T2` on `T1.Musical_ID = T2.Musical_ID` instead of querying only the `musicals` table. Do add `GROUP BY T1.Musical_ID` and move the count filter to `HAVING COUNT(*) >= 3` instead of using `WHERE actor_count >= 3` directly on the table. Do remove the incorrect `actor_count` column reference and instead count actual actor records through the join. The amended query now correctly identifies musicals with at least three actors by joining and counting related records, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM musicals WHERE actor_count >= 3;",
            "SELECT T2.Name FROM musical AS T2 JOIN actor AS T1 ON T1.Musical_ID = T2.Musical_ID GROUP BY T1.Musical_ID HAVING COUNT(*) >= 3"
        ],
        "rule_sql": []
    },
    "639": {
        "db_id": "store_1",
        "question": "List all tracks bought by customer Daan Peeters.",
        "ground_truth": "SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = \"Daan\" AND T4.last_name = \"Peeters\";",
        "amends": [
            "Do select only `T1.name` instead of `*` to return specific columns. Do add joins to `invoice_lines`, `invoices`, and `customers` tables instead of querying only the `tracks` table. Do use `JOIN` with proper join conditions `T1.id = T2.track_id`, `T3.id = T2.invoice_id`, and `T4.id = T3.customer_id` instead of no joins. Do filter on `T4.first_name = \"Daan\" AND T4.last_name = \"Peeters\"` instead of `customer_name = 'Daan Peeters'` to properly match the customer by first and last name separately. The amended query now correctly joins related tables to find tracks associated with the specific customer and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM tracks WHERE customer_name = 'Daan Peeters';",
            "SELECT T1.name \nFROM tracks T1\nJOIN invoice_lines T2 ON T1.id = T2.track_id\nJOIN invoices T3 ON T2.invoice_id = T3.id\nJOIN customers T4 ON T3.customer_id = T4.id\nWHERE T4.first_name = 'Daan' AND T4.last_name = 'Peeters'"
        ],
        "rule_sql": []
    },
    "859": {
        "db_id": "chinook_1",
        "question": "Find the first names of all customers that live in Brazil and have an invoice.",
        "ground_truth": "SELECT DISTINCT T1.FirstName FROM CUSTOMER AS T1 JOIN INVOICE AS T2 ON T1.CustomerId  =  T2.CustomerId WHERE T1.country  =  \"Brazil\"",
        "amends": [
            "Do use `DISTINCT T1.FirstName` instead of `first_name` without distinct. Do specify table alias `T1` for the column reference instead of omitting it. Do add `INVOICE AS T2` table with `JOIN` instead of filtering by `invoice_id IS NOT NULL`. Do use explicit join condition `ON T1.CustomerId = T2.CustomerId` instead of the implicit invoice_id filter. Do use double quotes around \"Brazil\" instead of single quotes. The amended query now correctly finds distinct customer names from Brazil who have invoices, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM customers WHERE country = 'Brazil' AND invoice_id IS NOT NULL",
            "SELECT DISTINCT T1.FirstName\nFROM Customer AS T1\nJOIN Invoice AS T2 ON T1.CustomerId = T2.CustomerId\nWHERE T1.Country = \"Brazil\""
        ],
        "rule_sql": []
    },
    "5428": {
        "db_id": "shop_membership",
        "question": "What is the name and open year for the branch with most number of memberships registered in 2016?",
        "ground_truth": "SELECT T2.name ,  T2.open_year FROM membership_register_branch AS T1 JOIN branch AS T2 ON T1.branch_id  =  T2.branch_id WHERE T1.register_year  =  2016 GROUP BY T2.branch_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `membership_register_branch AS T1` and `branch AS T2` as FROM sources instead of just `branches`. Do use `JOIN` with `T1.branch_id = T2.branch_id` instead of no join condition. Do add `WHERE T1.register_year = 2016` filter instead of omitting it. Do add `GROUP BY T2.branch_id` instead of no grouping. Do change ORDER BY to `count(*) DESC` instead of `open_year DESC`. Do keep `LIMIT 1` but now it applies to the grouped count rather than individual records. The amended query now correctly identifies the branch with the most members registered in 2016 rather than simply the most recently opened branch, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, open_year FROM branches ORDER BY open_year DESC LIMIT 1;",
            "SELECT T2.Name, T2.Open_year\nFROM membership_register_branch AS T1\nJOIN branch AS T2 ON T1.Branch_ID = T2.Branch_ID\nWHERE T1.Register_Year = '2016'\nGROUP BY T2.Branch_ID\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "3329": {
        "db_id": "college_1",
        "question": "Find the first names of professors who are teaching more than one class.",
        "ground_truth": "SELECT T2.emp_fname FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num GROUP BY T1.prof_num HAVING count(*)  >  1",
        "amends": [
            "Do select `T2.emp_fname` instead of `first_name` and use proper table aliasing. Do join `CLASS AS T1` with `employee AS T2` on `T1.prof_num = T2.emp_num` instead of querying only the `professors` table. Do add `GROUP BY T1.prof_num` instead of omitting grouping. Do move the count filter to `HAVING count(*) > 1` instead of placing it in the `WHERE` clause without aggregation context. Do remove the incorrect `WHERE COUNT(class_id) > 1` predicate that would cause a syntax error. The amended query now correctly identifies professors teaching multiple classes by joining class and employee tables, grouping by professor number, and filtering with HAVING instead of WHERE."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM professors WHERE COUNT(class_id) > 1",
            "SELECT T2.EMP_FNAME \nFROM CLASS AS T1 \nJOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM \nGROUP BY T1.PROF_NUM \nHAVING COUNT(*) > 1"
        ],
        "rule_sql": []
    },
    "2119": {
        "db_id": "cre_Doc_Control_Systems",
        "question": "What address was the document with id 4 mailed to?",
        "ground_truth": "SELECT Addresses.address_details FROM Addresses JOIN Documents_Mailed ON Documents_Mailed.mailed_to_address_id = Addresses.address_id WHERE document_id = 4;",
        "amends": [
            "Do select `Addresses.address_details` instead of `address` from `documents`. Do join `Addresses` with `Documents_Mailed` on `Documents_Mailed.mailed_to_address_id = Addresses.address_id` instead of querying only the `documents` table. Do filter on `document_id = 4` instead of `id = 5`. The amended query now correctly retrieves address details from the Addresses table joined with the mailing relationship table using the proper foreign key relationship and document identifier."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address FROM documents WHERE id = 5;",
            "SELECT Addresses.address_details \nFROM Documents_Mailed \nJOIN Addresses ON Documents_Mailed.mailed_to_address_id = Addresses.address_id \nWHERE Documents_Mailed.document_id = 4"
        ],
        "rule_sql": []
    },
    "5246": {
        "db_id": "music_2",
        "question": "What are the vocal types used in song \"Badlands\"?",
        "ground_truth": "SELECT TYPE FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Badlands\"",
        "amends": [
            "Do join `vocals AS T1` with `songs AS T2` on `T1.songid = T2.songid` instead of querying only the `songs` table. Do select `TYPE` from the joined vocals table instead of selecting `vocal_type` from songs alone. Do use double quotes around \"Badlands\" instead of single quotes for the string literal. The amended query now correctly retrieves vocal type information by joining the vocals and songs tables on their songid relationship, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT vocal_type FROM songs WHERE title = 'Badlands';",
            "SELECT T1.Type FROM Vocals AS T1 JOIN Songs AS T2 ON T1.SongId = T2.SongId WHERE T2.Title = \"Badlands\""
        ],
        "rule_sql": []
    },
    "2312": {
        "db_id": "perpetrator",
        "question": "What is the total kills of the perpetrators with height more than 1.84.",
        "ground_truth": "SELECT sum(T2.Killed) FROM people AS T1 JOIN perpetrator AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Height  >  1.84",
        "amends": [
            "Do reference the `perpetrator` table instead of `perpetrators` and join it with `people` on `People_ID` instead of querying a single table. Do use the column `T2.Killed` instead of `kills` and apply the height filter on `T1.Height` instead of directly on the perpetrator table. Do add the required table alias `T2` for the aggregate column reference instead of using a bare column name. The amended query now correctly joins the necessary tables and references the appropriate columns to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(kills) FROM perpetrators WHERE height > 1.84",
            "SELECT SUM(T2.Killed) AS total_kills\nFROM people T1\nJOIN perpetrator T2 ON T1.People_ID = T2.People_ID\nWHERE T1.Height > 1.84"
        ],
        "rule_sql": []
    },
    "2956": {
        "db_id": "sakila_1",
        "question": "Which store owns most items?",
        "ground_truth": "SELECT store_id FROM inventory GROUP BY store_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do query the `inventory` table instead of the `items` table. Do use `count(*)` in the ORDER BY clause instead of aliasing it as `item_count` in the SELECT list. Do order by count in descending order with `DESC` instead of ascending order with `ASC`. Do remove the `item_count` column from the SELECT list instead of including it. The amended query now correctly identifies the store with the highest inventory count by counting records in the inventory table and ordering descending."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT store_id, COUNT(*) as item_count FROM items GROUP BY store_id ORDER BY item_count ASC LIMIT 1;",
            "SELECT store_id FROM inventory GROUP BY store_id ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2613": {
        "db_id": "inn_1",
        "question": "What is the name of the room that can accommodate the most people?",
        "ground_truth": "SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT 1;",
        "amends": [
            "Do select `roomName` instead of `name` to use the correct column name from the schema. Do order by `maxOccupancy DESC` instead of `capacity ASC` to sort by the proper occupancy metric in descending order rather than ascending capacity. Do reference table `Rooms` instead of `rooms` to use the correct table name with proper capitalization. The amended query now correctly retrieves the room with the highest maximum occupancy rather than the smallest capacity, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM rooms ORDER BY capacity ASC LIMIT 1;",
            "SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1462": {
        "db_id": "college_2",
        "question": "Find the building, room number, semester and year of all courses offered by Psychology department sorted by course titles.",
        "ground_truth": "SELECT T2.building ,  T2.room_number ,  T2.semester ,  T2.year FROM course AS T1 JOIN SECTION AS T2 ON T1.course_id  =  T2.course_id WHERE T1.dept_name  =  'Psychology' ORDER BY T1.title",
        "amends": [
            "Do join `SECTION AS T2` instead of omitting it, and do join on `T1.course_id = T2.course_id` instead of missing the join condition entirely. Do reference columns with table aliases `T2.building`, `T2.room_number`, `T2.semester`, `T2.year` instead of unqualified `building`, `room_number`, `semester`, `year`. Do filter on `T1.dept_name = 'Psychology'` instead of `department = 'Psychology'` to use the correct column name and table reference. Do order by `T1.title` instead of `course_title` to use the proper column reference. The amended query now correctly joins the course and section tables to retrieve building and room information for psychology courses."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT building, room_number, semester, year FROM courses WHERE department = 'Psychology' ORDER BY course_title;",
            "SELECT T2.building, T2.room_number, T2.semester, T2.year\nFROM course AS T1\nJOIN section AS T2 ON T1.course_id = T2.course_id\nWHERE T1.dept_name = 'Psychology'\nORDER BY T1.title"
        ],
        "rule_sql": []
    },
    "1854": {
        "db_id": "wrestler",
        "question": "What are the elimination moves of wrestlers whose team is \"Team Orton\"?",
        "ground_truth": "SELECT Elimination_Move FROM Elimination WHERE Team  =  \"Team Orton\"",
        "amends": [
            "Do reference the `Elimination_Move` column instead of `elimination_moves`, and use the `Elimination` table instead of `wrestlers`. Do use double quotes around the string literal `\"Team Orton\"` instead of single quotes, and maintain the exact case sensitivity for the column and table names. The amended query now correctly retrieves elimination move data from the appropriate table with the proper filtering condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT elimination_moves FROM wrestlers WHERE team = 'Team Orton';",
            "SELECT \"Elimination_Move\" FROM \"Elimination\" WHERE \"Team\" = \"Team Orton\""
        ],
        "rule_sql": []
    },
    "6827": {
        "db_id": "flight_4",
        "question": "Find the number of routes whose destination airports are in Canada.",
        "ground_truth": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE country  =  'Canada'",
        "amends": [
            "Do join `airports AS T1` with `routes AS T2` on `T1.apid = T2.dst_apid` instead of querying only the `routes` table without any join. Do filter on `country = 'Canada'` instead of filtering on `destination_airport_country = 'Canada'` since the country information resides in the airports table rather than the routes table. The amended query now correctly counts routes to Canadian airports by properly joining the airports table to access country information and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM routes WHERE destination_airport_country = 'Canada';",
            "SELECT COUNT(*) \nFROM routes AS T2 \nJOIN airports AS T1 ON T1.apid = T2.dst_apid \nWHERE T1.country = 'Canada'"
        ],
        "rule_sql": []
    },
    "1565": {
        "db_id": "customers_and_invoices",
        "question": "How many accounts does each customer have? List the number and customer id.",
        "ground_truth": "SELECT count(*) ,  customer_id FROM Accounts GROUP BY customer_id",
        "amends": [
            "Do place `customer_id` after the aggregate function in the SELECT list instead of before it, maintaining the same logical grouping by `customer_id` but with corrected column ordering that follows standard SQL conventions for aggregate queries. The amended query now matches RIGHT_SQL's behavior with identical results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_id, COUNT(*) FROM accounts GROUP BY customer_id;",
            "SELECT COUNT(account_id) AS number_of_accounts, customer_id FROM Accounts GROUP BY customer_id;"
        ],
        "rule_sql": []
    },
    "3808": {
        "db_id": "e_learning",
        "question": "Find the addresses and author IDs of the course authors that teach at least two courses.",
        "ground_truth": "SELECT T1.address_line_1 ,  T2.author_id FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id GROUP BY T2.author_id HAVING Count(*)  >=  2",
        "amends": [
            "Do select `address_line_1` and `author_id` from separate tables instead of selecting `address` and `author_id` from a single table. Do join `Course_Authors_and_Tutors` with `Courses` on `author_id` instead of querying only `course_authors`. Do use table aliases `T1` and `T2` instead of no aliases. Do group by `T2.author_id` instead of `author_id` without table qualification. The amended query now correctly joins the author information with course data to find authors with multiple courses, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address, author_id FROM course_authors GROUP BY author_id HAVING COUNT(*) >= 2;",
            "SELECT T1.address_line_1, T2.author_id\nFROM Course_Authors_and_Tutors T1\nJOIN Courses T2 ON T1.author_id = T2.author_id\nGROUP BY T2.author_id\nHAVING COUNT(T2.course_id) >= 2"
        ],
        "rule_sql": []
    },
    "283": {
        "db_id": "twitter_1",
        "question": "Return the text of tweets about the topic 'intern'.",
        "ground_truth": "SELECT text FROM tweets WHERE text LIKE '%intern%'",
        "amends": [
            "Do select only `text` column instead of selecting all columns with `*`. Do filter with `LIKE '%intern%'` pattern matching on the `text` column instead of exact equality comparison on a non-existent `topic` column. Do remove the incorrect `topic` column reference entirely instead of including it in the WHERE clause. The amended query now correctly searches for tweets containing the word 'intern' in their text content rather than looking for a non-existent topic column with exact value matching."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM tweets WHERE topic = 'intern';",
            "SELECT text FROM tweets WHERE text LIKE '%intern%'"
        ],
        "rule_sql": []
    },
    "1577": {
        "db_id": "customers_and_invoices",
        "question": "How many transactions do we have?",
        "ground_truth": "SELECT count(*) FROM Financial_transactions",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers;"
        ],
        "rule_sql": []
    },
    "3541": {
        "db_id": "music_1",
        "question": "What is the name of the artist who produced the shortest song?",
        "ground_truth": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1",
        "amends": [
            "Do specify the table alias `T1` for `artist_name` instead of using the bare column name. Do join the `files` table as `T2` instead of omitting it entirely. Do use the join condition `T1.f_id = T2.f_id` instead of having no join relationship. Do order by `T2.duration` from the joined table instead of `duration` from the base table alone. Do reference the correct table source `song` instead of the incorrect table name `songs`. The amended query now correctly joins the necessary tables to access duration information and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT artist_name FROM songs ORDER BY duration ASC LIMIT 1;",
            "SELECT T1.artist_name FROM song T1 JOIN files T2 ON T1.f_id = T2.f_id ORDER BY T2.duration ASC LIMIT 1"
        ],
        "rule_sql": []
    },
    "3848": {
        "db_id": "e_learning",
        "question": "Find the common personal name of course authors and students.",
        "ground_truth": "SELECT personal_name FROM Course_Authors_and_Tutors INTERSECT SELECT personal_name FROM Students",
        "amends": [
            "Do reference `personal_name` instead of `name` in both SELECT lists. Do use table `Course_Authors_and_Tutors` instead of `authors` in the FROM clause. Do use table `Students` instead of `students` in the second FROM clause. The amended query now correctly intersects personal names from the specified tables matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM authors INTERSECT SELECT name FROM students;",
            "SELECT personal_name FROM Course_Authors_and_Tutors\nINTERSECT\nSELECT personal_name FROM Students;"
        ],
        "rule_sql": []
    },
    "6762": {
        "db_id": "activity_1",
        "question": "Which faculty members advise two ore more students? Give me their faculty ids.",
        "ground_truth": "SELECT T1.FacID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID HAVING count(*)  >=  2",
        "amends": [
            "Do use `T1.FacID` with table alias instead of `faculty_id` without alias. Do add `JOIN Student AS T2` instead of querying only the Faculty table. Do use `ON T1.FacID = T2.advisor` for the join condition instead of no join. Do add `GROUP BY T1.FacID` instead of no grouping. Do move the count filter to `HAVING count(*) >= 2` instead of using `WHERE student_count >= 2` in the base table. The amended query now correctly counts actual student relationships through the join instead of relying on a potentially incorrect student_count column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT faculty_id FROM faculty WHERE student_count >= 2;",
            "SELECT T1.FacID\nFROM Faculty AS T1\nJOIN Student AS T2 ON T1.FacID = T2.Advisor\nGROUP BY T1.FacID\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "5510": {
        "db_id": "voter_2",
        "question": "What is the most common major among female (sex is F) students?",
        "ground_truth": "SELECT Major FROM STUDENT WHERE Sex  =  \"F\" GROUP BY major ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `Major` instead of `major, COUNT(*) as count` to return only the major column instead of both major and count. Do filter on `Sex = \"F\"` instead of `sex = 'M'` to select female students instead of male students. Do order by `count(*) DESC` instead of `count DESC` to sort by the actual count of students rather than an aliased column. Do keep the `GROUP BY major` and `LIMIT 1` clauses as they correctly group by major and return the single highest count result."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT major, COUNT(*) as count FROM students WHERE sex = 'M' GROUP BY major ORDER BY count DESC LIMIT 1;",
            "SELECT Major FROM Student WHERE Sex = 'F' GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3124": {
        "db_id": "behavior_monitoring",
        "question": "Find the last names of teachers who are not involved in any detention.",
        "ground_truth": "SELECT last_name FROM Teachers EXCEPT SELECT T1.last_name FROM Teachers AS T1 JOIN Detention AS T2 ON T1.teacher_id  =  T2.teacher_id",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` subquery for better null safety and performance. Do reference the `Teachers` table with proper casing `Teachers` instead of lowercase `teachers` to match schema conventions. Do add table aliases `T1` and `T2` for clarity instead of omitting them. Do use explicit `JOIN` syntax with `ON T1.teacher_id = T2.teacher_id` instead of implicit correlation in the subquery. Do reference the correct table name `Detention` instead of `detentions` to match the actual schema. The amended query now correctly handles potential null values and matches the RIGHT_SQL's behavior using set operations rather than subquery negation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT last_name FROM teachers WHERE teacher_id NOT IN (SELECT teacher_id FROM detentions)",
            "SELECT T1.last_name\nFROM Teachers T1\nEXCEPT\nSELECT T2.last_name\nFROM Teachers T2\nJOIN Detention D ON T2.teacher_id = D.teacher_id;"
        ],
        "rule_sql": []
    },
    "4968": {
        "db_id": "soccer_2",
        "question": "What is average enrollment of colleges in the state FL?",
        "ground_truth": "SELECT avg(enr) FROM College WHERE state  =  'FL'",
        "amends": [
            "Do use the table alias `College` instead of `colleges` and the column alias `enr` instead of `enrollment` while keeping the aggregate function `avg` and filter condition `state = 'FL'` unchanged. The amended query now correctly references the intended table and column names while maintaining the same logical behavior of calculating the average enrollment for Florida colleges."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(enrollment) FROM colleges WHERE state = 'FL';",
            "SELECT AVG(enr) FROM College WHERE state = 'FL';"
        ],
        "rule_sql": []
    },
    "2889": {
        "db_id": "icfp_1",
        "question": "How many papers are written by authors from the institution \"University of Pennsylvania\"?",
        "ground_truth": "SELECT count(DISTINCT t1.title) FROM papers AS t1 JOIN authorship AS t2 ON t1.paperid  =  t2.paperid JOIN inst AS t3 ON t2.instid  =  t3.instid WHERE t3.name  =  \"University of Pennsylvania\"",
        "amends": [
            "Do count `DISTINCT t1.title` instead of `COUNT(*)` to count unique paper titles rather than all rows. Do join `authorship AS t2` on `t1.paperid = t2.paperid` and `inst AS t3` on `t2.instid = t3.instid` instead of querying only the `papers` table to properly connect papers to institutions through authorship. Do filter on `t3.name = \"University of Pennsylvania\"` instead of `institution = 'University of Pennsylvania'` to use the correct institution name column from the joined table. The amended query now correctly counts distinct paper titles from the University of Pennsylvania by properly joining through the authorship relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM papers WHERE institution = 'University of Pennsylvania';",
            "SELECT COUNT(DISTINCT t1.title) \nFROM Papers AS t1\nJOIN Authorship AS t2 ON t1.paperID = t2.paperID\nJOIN Inst AS t3 ON t2.instID = t3.instID\nWHERE t3.name = 'University of Pennsylvania'"
        ],
        "rule_sql": []
    },
    "2002": {
        "db_id": "gas_company",
        "question": "What is the minimum, maximum, and average market value for every company?",
        "ground_truth": "SELECT min(market_value) ,  max(market_value) ,  avg(market_value) FROM company",
        "amends": [
            "Do use the table name `company` instead of `companies` in the FROM clause. Do remove the column `company` from the SELECT list and GROUP BY clause instead of including it, as the aggregate functions are calculated across the entire table rather than grouped by company. Do maintain the same aggregate functions `MIN`, `MAX`, and `AVG` on `market_value` but adjust their formatting to lowercase instead of mixed case. The amended query now correctly calculates overall market value statistics without unnecessary grouping."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT company, MIN(market_value), MAX(market_value), AVG(market_value) FROM companies GROUP BY company;",
            "SELECT MIN(Market_Value) as min_market_value, MAX(Market_Value) as max_market_value, AVG(Market_Value) as avg_market_value FROM company;"
        ],
        "rule_sql": []
    },
    "2563": {
        "db_id": "county_public_safety",
        "question": "Which location has the most corresponding counties?",
        "ground_truth": "SELECT LOCATION FROM county_public_safety GROUP BY LOCATION ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do reference table `county_public_safety` instead of `counties` in the FROM clause. Do select only `LOCATION` instead of both `location` and `COUNT(*) as county_count` in the SELECT list. Do remove the explicit column alias `county_count` instead of keeping it. Do move the aggregate function `COUNT(*)` to the ORDER BY clause instead of including it in the SELECT list. The amended query now correctly identifies the location with the highest count from the county_public_safety table while matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location, COUNT(*) as county_count FROM counties GROUP BY location ORDER BY county_count DESC LIMIT 1;",
            "SELECT Location FROM county_public_safety GROUP BY Location ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4634": {
        "db_id": "customers_campaigns_ecommerce",
        "question": "Show the names of customers having an order with shipping method FedEx and order status Paid.",
        "ground_truth": "SELECT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE shipping_method_code  =  'FedEx' AND order_status_code  =  'Paid'",
        "amends": [
            "Do reference `T1.customer_name` instead of `c.name` for the column selection. Do use table alias `T1` for `customers` instead of `c` and join with `customer_orders AS T2` instead of `orders`. Do join on `T1.customer_id = T2.customer_id` instead of `c.customer_id = o.customer_id`. Do filter on `shipping_method_code = 'FedEx'` instead of `shipping_method = 'FedEx'` and `order_status_code = 'Paid'` instead of `order_status = 'Paid'`. The amended query now correctly references the proper table names, column names, and filtering conditions to match the intended logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.name \nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nWHERE o.shipping_method = 'FedEx' AND o.order_status = 'Paid';",
            "SELECT T1.customer_name\nFROM Customers AS T1\nJOIN Customer_Orders AS T2 ON T1.customer_id = T2.customer_id\nWHERE T2.shipping_method_code = 'FedEx'\nAND T2.order_status_code = 'Paid'"
        ],
        "rule_sql": []
    },
    "6719": {
        "db_id": "activity_1",
        "question": "Show all the distinct buildings that have faculty rooms.",
        "ground_truth": "SELECT DISTINCT building FROM Faculty",
        "amends": [
            "Do select from `Faculty` table instead of `rooms` table. Do remove the `WHERE room_type = 'office'` filter instead of keeping it. The amended query now correctly selects distinct buildings from the Faculty table without unnecessary filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT building FROM rooms WHERE room_type = 'office';",
            "SELECT DISTINCT Building FROM Faculty;"
        ],
        "rule_sql": []
    },
    "276": {
        "db_id": "twitter_1",
        "question": "How many users are there?",
        "ground_truth": "SELECT count(*) FROM user_profiles",
        "amends": [
            "Do query the `user_profiles` table instead of the `users` table. Do count all records from the correct table instead of using the wrong source table. The amended query now correctly counts records from the user_profiles table as specified in the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE id = 1;",
            "SELECT COUNT(*) FROM user_profiles;"
        ],
        "rule_sql": []
    },
    "4403": {
        "db_id": "network_2",
        "question": "What is the average age for all people in the table?",
        "ground_truth": "SELECT avg(age) FROM Person",
        "amends": [
            "Do use `avg(age)` instead of `AVG(name)` to calculate the average of numeric age values rather than attempting to average a string column. Do reference table `Person` instead of `people` to match the correct table name in the schema. The amended query now correctly calculates the average age from the Person table instead of the erroneous attempt to average a text-based name field."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(name) FROM people;",
            "SELECT AVG(age) FROM Person;"
        ],
        "rule_sql": []
    },
    "1142": {
        "db_id": "climbing",
        "question": "List the names of mountains that do not have any climber.",
        "ground_truth": "SELECT Name FROM mountain WHERE Mountain_ID NOT IN (SELECT Mountain_ID FROM climber)",
        "amends": [
            "Do select `Name` instead of `name` and use table `mountain` instead of `mountains`. Do change the filter to use `Mountain_ID NOT IN` subquery instead of `climber_id IS NULL`. Do add a correlated subquery `SELECT Mountain_ID FROM climber` instead of omitting it, which correctly identifies mountains without climbers by checking the climber table rather than relying on a potentially missing NULL check. The amended query now matches RIGHT_SQL's behavior by properly excluding mountains that have associated climbers."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM mountains WHERE climber_id IS NULL;",
            "SELECT Name FROM mountain WHERE Mountain_ID NOT IN (SELECT Mountain_ID FROM climber)"
        ],
        "rule_sql": []
    },
    "1877": {
        "db_id": "wrestler",
        "question": "What are the names of wrestlers who have never been eliminated?",
        "ground_truth": "SELECT Name FROM wrestler WHERE Wrestler_ID NOT IN (SELECT Wrestler_ID FROM elimination)",
        "amends": [
            "Do select `Name` from the `wrestler` table instead of `name` from `wrestlers`. Do use a subquery with `NOT IN` to filter by `Wrestler_ID` values not present in the `elimination` table instead of filtering by `elimination_count > 0`. Do reference the correct table name `wrestler` instead of `wrestlers` and use proper column casing. The amended query now correctly identifies wrestlers who have not been eliminated by checking their absence from the elimination records rather than relying on a count column that may not exist or be accurate."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM wrestlers WHERE elimination_count > 0;",
            "SELECT Name FROM wrestler WHERE Wrestler_ID NOT IN (SELECT Wrestler_ID FROM Elimination)"
        ],
        "rule_sql": []
    },
    "5679": {
        "db_id": "dorm_1",
        "question": "How many dorms are in the database?",
        "ground_truth": "SELECT count(*) FROM dorm",
        "amends": [
            "Do query the `dorm` table instead of the `students` table. Do remove the `WHERE dorm_id IS NOT NULL` filter instead of keeping it. The amended query now correctly counts all records in the dorm table as specified in the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE dorm_id IS NOT NULL;",
            "SELECT COUNT(*) FROM Dorm;"
        ],
        "rule_sql": []
    },
    "1257": {
        "db_id": "apartment_rentals",
        "question": "What are the top three apartment types in terms of the average room count? Give me the",
        "ground_truth": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT 3",
        "amends": [
            "Do select `apt_type_code` instead of `apartment_type` and remove the explicit `AVG(room_count)` alias instead of keeping it as `avg_rooms`. Do change the table name to `Apartments` instead of `apartments`. Do remove the explicit `GROUP BY` clause for the average calculation and instead use `ORDER BY avg(room_count)` directly instead of ordering by the aliased column. The amended query now correctly selects only the apartment type codes while ordering by the average room count in descending order and limiting to 3 results, matching the intended behavior.",
            "Do remove `AVG(room_count)` from the SELECT list instead of including it, as the query only needs to return apt_type_code values. Do keep the ORDER BY clause with `avg(room_count) DESC` instead of changing it, maintaining the sorting by average room count. Do preserve the GROUP BY `apt_type_code` and LIMIT 3 clauses without modification. The amended query now correctly returns only the top 3 apartment type codes ordered by their average room count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT apartment_type, AVG(room_count) as avg_rooms\nFROM apartments\nGROUP BY apartment_type\nORDER BY avg_rooms DESC\nLIMIT 3;",
            "SELECT apt_type_code, AVG(room_count) FROM Apartments GROUP BY apt_type_code ORDER BY AVG(room_count) DESC LIMIT 3;",
            "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY AVG(room_count) DESC LIMIT 3;"
        ],
        "rule_sql": []
    },
    "491": {
        "db_id": "allergy_1",
        "question": "Which major has most number of students?",
        "ground_truth": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference the table as `Student` instead of `students` to match the correct schema. Do remove the `COUNT(*)` from the SELECT list instead of including it, as only the `major` column is needed in the final output. The amended query now correctly returns only the major with the highest count of students, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT major, COUNT(*) FROM students GROUP BY major ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT major FROM Student GROUP BY major ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "4791": {
        "db_id": "department_store",
        "question": "Find the id and name of customers whose address contains WY state and do not use credit card for payment.",
        "ground_truth": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE \"%WY%\" AND payment_method_code != \"Credit Card\"",
        "amends": [
            "Do select `customer_id` and `customer_name` instead of `id` and `name`. Do use `customer_address` with pattern matching instead of `address`. Do use inequality condition `!= \"Credit Card\"` on `payment_method_code` instead of equality condition `= 'credit card'` on `payment_method`. The amended query now correctly filters for Wyoming addresses while excluding credit card payment methods with proper column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, name FROM customers WHERE address LIKE '%WY%' AND payment_method = 'credit card';",
            "SELECT customer_id, customer_name FROM Customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'Credit Card';"
        ],
        "rule_sql": []
    },
    "2649": {
        "db_id": "local_govt_mdm",
        "question": "What is the tax source system code related to the benefits and overpayments? List the code and the benifit id, order by benifit id.",
        "ground_truth": "SELECT T1.source_system_code ,  T2.council_tax_id FROM CMI_Cross_References AS T1 JOIN Benefits_Overpayments AS T2 ON T1.cmi_cross_ref_id  =  T2.cmi_cross_ref_id ORDER BY T2.council_tax_id",
        "amends": [
            "Do select `source_system_code` and `council_tax_id` instead of `tax_source_system_code` and `benefit_id`. Do use `FROM CMI_Cross_References AS T1 JOIN Benefits_Overpayments AS T2` instead of `FROM benefits_table`. Do add `ON T1.cmi_cross_ref_id = T2.cmi_cross_ref_id` join condition instead of omitting it. Do order by `T2.council_tax_id` instead of `benefit_id`. The amended query now correctly joins the two tables and selects the appropriate columns to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT tax_source_system_code, benefit_id FROM benefits_table ORDER BY benefit_id;",
            "SELECT T1.source_system_code, T2.council_tax_id \nFROM CMI_Cross_References AS T1 \nJOIN Benefits_Overpayments AS T2 ON T1.cmi_cross_ref_id = T2.cmi_cross_ref_id \nORDER BY T2.council_tax_id"
        ],
        "rule_sql": []
    },
    "6255": {
        "db_id": "ship_1",
        "question": "What types of ships have both ships that have Panama Flags and Malta flags?",
        "ground_truth": "SELECT TYPE FROM ship WHERE flag  =  'Panama' INTERSECT SELECT TYPE FROM ship WHERE flag  =  'Malta'",
        "amends": [
            "Do use `INTERSECT` to find common ship types instead of `OR` with `DISTINCT` which returns all types from either flag. Do query from table `ship` instead of `ships`. Do remove the `DISTINCT` keyword since `INTERSECT` inherently returns unique results. Do structure as two separate `SELECT TYPE FROM ship WHERE flag = 'Panama'` and `SELECT TYPE FROM ship WHERE flag = 'Malta'` queries combined with `INTERSECT` instead of a single query with `OR` condition. The amended query now correctly returns only ship types that appear with both Panama and Malta flags, matching the RIGHT_SQL's intersection behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT type FROM ships WHERE flag = 'Panama' OR flag = 'Malta';",
            "SELECT Type FROM Ship WHERE Flag = 'Panama' INTERSECT SELECT Type FROM Ship WHERE Flag = 'Malta'"
        ],
        "rule_sql": []
    },
    "2601": {
        "db_id": "inn_1",
        "question": "What is the least popular kind of decor?",
        "ground_truth": "SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT 1;",
        "amends": [
            "Do select `T2.decor` instead of `decor_type` and count `T2.decor` instead of `*` for the popularity metric. Do join `Reservations AS T1` with `Rooms AS T2` on `T1.Room = T2.RoomId` instead of querying only `decor_items` table. Do group by `T2.decor` instead of `decor_type` to aggregate by room decoration type. Do order by `count(T2.decor) ASC` instead of `popularity DESC` to find the least popular decoration rather than the most popular. The amended query now correctly identifies the least frequently used room decoration type based on reservation data instead of counting items in a decor catalog.",
            "Do remove `COUNT(T2.decor) AS reservation_count` from the SELECT list instead of including it. Do change the ORDER BY clause to use `count(T2.decor) ASC` instead of `reservation_count ASC` to reference the aggregate function directly rather than the alias. The amended query now correctly returns only the decor values while ordering by the count of reservations per decor, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT decor_type, COUNT(*) as popularity FROM decor_items GROUP BY decor_type ORDER BY popularity DESC LIMIT 1;",
            "SELECT T2.decor, COUNT(T2.decor) AS reservation_count\nFROM Reservations AS T1\nJOIN Rooms AS T2 ON T1.Room = T2.RoomId\nGROUP BY T2.decor\nORDER BY reservation_count ASC\nLIMIT 1;",
            "SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room = T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT 1"
        ],
        "rule_sql": []
    },
    "134": {
        "db_id": "bike_1",
        "question": "What are the start station's name and id for the one that had the most start trips in August?",
        "ground_truth": "SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE \"8/%\" GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select only `start_station_name` and `start_station_id` instead of including `COUNT(*) as trip_count` in the SELECT list. Do reference table `trip` instead of `trips`. Do use filter `start_date LIKE \"8/%\"` instead of `strftime('%m', start_time) = '08'` for month extraction. Do group by only `start_station_name` instead of both `start_station_name` and `start_station_id`. Do order by `COUNT(*) DESC` instead of `trip_count DESC` while maintaining the same descending count ordering. The amended query now correctly identifies the most popular starting station for August trips using proper date filtering and aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT start_station_name, start_station_id, COUNT(*) as trip_count \nFROM trips \nWHERE strftime('%m', start_time) = '08' \nGROUP BY start_station_name, start_station_id \nORDER BY trip_count DESC \nLIMIT 1;",
            "SELECT start_station_name, start_station_id\nFROM trip\nWHERE start_date LIKE '8/%'\nGROUP BY start_station_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5177": {
        "db_id": "music_2",
        "question": "return all columns of the albums created in the year of 2012.",
        "ground_truth": "SELECT * FROM Albums WHERE YEAR  =  2012",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM albums WHERE year = '2012';"
        ],
        "rule_sql": []
    },
    "4780": {
        "db_id": "department_store",
        "question": "What are the distinct names and phone numbers for suppliers who have red jeans?",
        "ground_truth": "SELECT DISTINCT T1.supplier_name ,  T1.supplier_phone FROM suppliers AS T1 JOIN product_suppliers AS T2 ON T1.supplier_id  =  T2.supplier_id JOIN products AS T3 ON T2.product_id  =  T3.product_id WHERE T3.product_name  =  \"red jeans\"",
        "amends": [
            "Do reference `supplier_name` and `supplier_phone` instead of `name` and `phone_number`. Do join through `product_suppliers` as an intermediate table instead of directly joining `suppliers` to `products`. Do use `T1.supplier_id = T2.supplier_id` and `T2.product_id = T3.product_id` as join conditions instead of `s.id = p.supplier_id`. Do filter on `product_name = \"red jeans\"` instead of separate `color = 'red'` and `type = 'jeans'` conditions. The amended query now correctly handles the many-to-many relationship through the junction table and matches the intended filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT s.name, s.phone_number\nFROM suppliers s\nJOIN products p ON s.id = p.supplier_id\nWHERE p.color = 'red' AND p.type = 'jeans';",
            "SELECT DISTINCT s.supplier_name, s.supplier_phone\nFROM Suppliers s\nJOIN Product_Suppliers ps ON s.supplier_id = ps.supplier_id\nJOIN Products p ON ps.product_id = p.product_id\nWHERE p.product_name = 'red jeans';"
        ],
        "rule_sql": []
    },
    "4873": {
        "db_id": "school_player",
        "question": "Count the number of distinct player positions.",
        "ground_truth": "SELECT count(DISTINCT POSITION) FROM player",
        "amends": [
            "Do use `count(DISTINCT POSITION)` instead of `COUNT(position)` to count unique positions rather than total occurrences. Do reference table `player` instead of `players` to use the correct table name. The amended query now correctly counts distinct positions from the player table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(position) FROM players;",
            "SELECT COUNT(DISTINCT Position) FROM player;"
        ],
        "rule_sql": []
    },
    "548": {
        "db_id": "store_1",
        "question": "What are the top 10 customers' first and last names with the highest gross sales, and also what are the sales?",
        "ground_truth": "SELECT T1.first_name ,  T1.last_name ,  SUM(T2.total) FROM customers AS T1 JOIN invoices AS T2 ON T2.customer_id  =  T1.id GROUP BY T1.id ORDER BY SUM(T2.total) DESC LIMIT 10;",
        "amends": [
            "Do add table `invoices AS T2` with a `JOIN` on `T2.customer_id = T1.id` instead of querying only the `customers` table. Do replace the direct `sales` column reference with `SUM(T2.total)` aggregation instead of using a simple column. Do add `GROUP BY T1.id` to properly aggregate the invoice totals instead of omitting grouping. Do change the `ORDER BY` clause to use `SUM(T2.total) DESC` instead of `sales DESC` to sort by the calculated sum. Do remove the direct `sales` column selection and instead calculate the total sales from related invoice records. The amended query now correctly aggregates invoice totals per customer and sorts by the calculated sum rather than relying on a potentially incorrect or missing sales column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, sales FROM customers ORDER BY sales DESC LIMIT 10;",
            "SELECT \n    c.first_name, \n    c.last_name, \n    SUM(i.total) AS sales\nFROM \n    customers c\nJOIN \n    invoices i ON i.customer_id = c.id\nGROUP BY \n    c.id\nORDER BY \n    sales DESC\nLIMIT 10;"
        ],
        "rule_sql": []
    },
    "396": {
        "db_id": "flight_1",
        "question": "What is the origin and destination for all flights whose price is higher than 300?",
        "ground_truth": "SELECT origin ,  destination FROM Flight WHERE price  >  300",
        "amends": [
            "Do reference table `Flight` instead of `flights` in the FROM clause. Do use filter `price > 300` instead of `price < 300` in the WHERE clause, changing the comparison operator from less than to greater than to select higher-priced flights instead of lower-priced ones. The amended query now correctly filters for flights with prices exceeding 300 rather than below 300, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT origin, destination FROM flights WHERE price < 300;",
            "SELECT origin, destination FROM flight WHERE price > 300;"
        ],
        "rule_sql": []
    },
    "482": {
        "db_id": "allergy_1",
        "question": "Give the number of students living in either HKG or CHI.",
        "ground_truth": "SELECT count(*) FROM Student WHERE city_code  =  \"HKG\" OR city_code  =  \"CHI\"",
        "amends": [
            "Do reference the `Student` table instead of `students`. Do use the correct column name `city_code` instead of `city`. Do use double quotes `\"HKG\"` and `\"CHI\"` for string literals instead of single quotes. The amended query now correctly counts records from the Student table where city_code equals HKG or CHI, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE city = 'HKG' OR city = 'CHI';",
            "SELECT COUNT(*) FROM Student WHERE city_code = \"HKG\" OR city_code = \"CHI\""
        ],
        "rule_sql": []
    },
    "2388": {
        "db_id": "csu_1",
        "question": "What is the campus fee of \"San Francisco State University\" in year 2000?",
        "ground_truth": "SELECT t1.campusfee FROM csu_fees AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t2.campus  =  \"San Francisco State University\" AND t1.year  =  2000",
        "amends": [
            "Do select `t1.campusfee` from the `csu_fees` table instead of `campus_fee` from the `universities` table. Do join `campuses AS t2` on `t1.campus = t2.id` instead of querying a single table. Do filter on `t2.campus = \"San Francisco State University\"` instead of `name = 'San Francisco State University'` to properly reference the campus name from the joined table. Do maintain the `t1.year = 2000` filter but apply it to the correct table. The amended query now correctly joins the fee and campus tables to retrieve the campus fee data for the specified university and year, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT campus_fee FROM universities WHERE name = 'San Francisco State University' AND year = 2000;",
            "SELECT t1.CampusFee FROM csu_fees AS t1 JOIN Campuses AS t2 ON t1.Campus = t2.Id WHERE t2.Campus = 'San Francisco State University' AND t1.Year = 2000"
        ],
        "rule_sql": []
    },
    "4398": {
        "db_id": "network_2",
        "question": "How many friends does Dan have?",
        "ground_truth": "SELECT count(T2.friend) FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T1.name  =  'Dan'",
        "amends": [
            "Do add `Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name` as the FROM source instead of querying only the `friends` table. Do change the SELECT clause to `count(T2.friend)` instead of `COUNT(*)` to count specific friend relationships. Do move the filter condition to `WHERE T1.name = 'Dan'` instead of `WHERE name = 'Dan'` to properly reference the joined table structure. The amended query now correctly counts the number of friends for a person named Dan by joining the appropriate relationship tables instead of querying a single table that lacks the necessary relationship structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM friends WHERE name = 'Dan';",
            "SELECT count(T2.friend) FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T1.name = 'Dan'"
        ],
        "rule_sql": []
    },
    "5359": {
        "db_id": "tracking_software_problems",
        "question": "What are the log id and entry description of each problem?",
        "ground_truth": "SELECT problem_log_id ,  log_entry_description FROM problem_log",
        "amends": [
            "Do select `problem_log_id` and `log_entry_description` instead of `log_id` and `problem_description`. Do query from `problem_log` table instead of `problems` table. The amended query now correctly retrieves log entry data from the appropriate problem log table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT log_id, problem_description FROM problems",
            "SELECT problem_log_id, log_entry_description FROM Problem_Log;"
        ],
        "rule_sql": []
    },
    "4427": {
        "db_id": "network_2",
        "question": "How old is the youngest person for each job?",
        "ground_truth": "SELECT min(age) ,  job FROM Person GROUP BY job",
        "amends": [
            "Do use `MIN(age)` instead of `MAX(age)` to find the minimum age rather than maximum age. Do place `job` after the aggregate function instead of before it in the SELECT list. Do reference table `Person` instead of `people` as the correct table name. Do remove the alias `youngest_age` instead of keeping it since the aggregate result no longer represents the youngest age. The amended query now correctly finds the minimum age for each job group and matches the RIGHT_SQL's behavior.",
            "Do place the `job` column after the aggregate function `min(age)` in the SELECT list instead of listing `job` first. Do maintain the same GROUP BY clause with `job` to ensure correct aggregation behavior. The amended query now correctly returns the minimum age for each job category while preserving the same logical result as the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT job, MAX(age) as youngest_age FROM people GROUP BY job;",
            "SELECT job, MIN(age) FROM Person GROUP BY job;",
            "SELECT MIN(age), job FROM Person GROUP BY job"
        ],
        "rule_sql": []
    },
    "468": {
        "db_id": "allergy_1",
        "question": "What cities do students live in?",
        "ground_truth": "SELECT DISTINCT city_code FROM Student",
        "amends": [
            "Do select `city_code` instead of `name` and add `DISTINCT` instead of omitting it. Do reference table `Student` instead of `students` and remove the `WHERE city IS NOT NULL` filter instead of keeping it. The amended query now matches the RIGHT_SQL's behavior by returning unique city codes from the Student table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM students WHERE city IS NOT NULL;",
            "SELECT DISTINCT city_code FROM Student"
        ],
        "rule_sql": []
    },
    "6085": {
        "db_id": "customers_and_addresses",
        "question": "Which city has the most customers living in?",
        "ground_truth": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `customer_addresses AS t2` on `t1.customer_id = t2.customer_id` and `addresses AS t3` on `t2.address_id = t3.address_id` instead of querying `customers` table alone. Do select `t3.city` from the joined address table instead of `city` directly from customers. Do group by `t3.city` instead of the original city column. The amended query now correctly retrieves city information from the addresses table through proper table relationships, matching the RIGHT_SQL's behavior.",
            "Do select only `t3.city` instead of including `COUNT(DISTINCT t1.customer_id) AS customer_count`. Do use `count(*)` in the `ORDER BY` clause instead of referencing the alias `customer_count`. Do remove the alias assignment from the count expression since it's no longer needed in the SELECT list. The amended query now correctly identifies the city with the highest number of customer records by counting all rows per city group rather than distinct customer counts, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, COUNT(*) FROM customers GROUP BY city ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT t3.city, COUNT(DISTINCT t1.customer_id) AS customer_count\nFROM Customers AS t1\nJOIN Customer_Addresses AS t2 ON t1.customer_id = t2.customer_id\nJOIN Addresses AS t3 ON t2.address_id = t3.address_id\nGROUP BY t3.city\nORDER BY customer_count DESC\nLIMIT 1;",
            "SELECT t3.city\nFROM Customers AS t1\nJOIN Customer_Addresses AS t2 ON t1.customer_id = t2.customer_id\nJOIN Addresses AS t3 ON t2.address_id = t3.address_id\nGROUP BY t3.city\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "3783": {
        "db_id": "e_learning",
        "question": "Find the number of distinct courses that have enrolled students.",
        "ground_truth": "SELECT count(course_id) FROM Student_Course_Enrolment",
        "amends": [
            "Do select `count(course_id)` from the `Student_Course_Enrolment` table instead of `COUNT(*)` from the `courses` table, which changes both the aggregation function and the source table to properly count enrolled students rather than just counting courses. This amendment ensures the query now correctly counts student course enrollments rather than simply counting course records.",
            "Do use `count(course_id)` instead of `COUNT(DISTINCT course_id)` to count all course_id values including duplicates rather than counting only distinct course_id values. The amended query now matches RIGHT_SQL's behavior by removing the DISTINCT modifier to count all enrollments rather than unique courses."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM courses;",
            "SELECT COUNT(DISTINCT course_id) FROM Student_Course_Enrolment;",
            "SELECT COUNT(course_id) FROM Student_Course_Enrolment"
        ],
        "rule_sql": []
    },
    "2676": {
        "db_id": "party_host",
        "question": "Show the nations that have both hosts older than 45 and hosts younger than 35.",
        "ground_truth": "SELECT Nationality FROM HOST WHERE Age  >  45 INTERSECT SELECT Nationality FROM HOST WHERE Age  <  35",
        "amends": [
            "Do use `Nationality` instead of `nation` in the SELECT list and reference table `HOST` instead of `hosts`. Do remove the contradictory `WHERE` filter combining `age > 45 AND age < 35` and instead use `INTERSECT` between two separate queries: one with `Age > 45` and another with `Age < 35`. Do use proper column name `Age` instead of `age` and table name `HOST` instead of `hosts`. The amended query now correctly finds nationalities of hosts who are both over 45 and under 35 by using set intersection instead of an impossible single condition, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT nation FROM hosts WHERE age > 45 AND age < 35;",
            "SELECT Nationality FROM host WHERE Age > '45' INTERSECT SELECT Nationality FROM host WHERE Age < '35';"
        ],
        "rule_sql": []
    },
    "4050": {
        "db_id": "student_1",
        "question": "Find the first names of all the teachers that teach in classroom 110.",
        "ground_truth": "SELECT firstname FROM teachers WHERE classroom  =  110",
        "amends": [
            "Do use column name `firstname` instead of `first_name` in the SELECT list, maintaining the same WHERE filter condition `classroom = 110` without any changes to the table source or filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM teachers WHERE classroom = 110;",
            "SELECT firstname FROM teachers WHERE classroom = 110"
        ],
        "rule_sql": []
    },
    "4186": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "What is the location code for the country \"Canada\"?",
        "ground_truth": "SELECT location_code FROM Ref_locations WHERE location_name  =  \"Canada\"",
        "amends": [
            "Do select `location_code` instead of `location` and use table `Ref_locations` instead of `countries`. Do filter on `location_name = \"Canada\"` instead of `country = 'Canada'` to correctly reference the appropriate column and table structure. The amended query now matches the intended behavior by selecting the location code from the reference table using the proper location name filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location FROM countries WHERE country = 'Canada';",
            "SELECT Location_Code FROM Ref_Locations WHERE Location_Name = 'Canada';"
        ],
        "rule_sql": []
    },
    "1137": {
        "db_id": "climbing",
        "question": "What are the times used by climbers who climbed mountains in the country of Uganda?",
        "ground_truth": "SELECT T1.Time FROM climber AS T1 JOIN mountain AS T2 ON T1.Mountain_ID  =  T2.Mountain_ID WHERE T2.Country  =  \"Uganda\"",
        "amends": [
            "Do select `T1.Time` instead of `climber_name, time_taken`. Do join `climber AS T1` with `mountain AS T2` on `T1.Mountain_ID = T2.Mountain_ID` instead of querying only the `climbers` table. Do filter on `T2.Country = \"Uganda\"` instead of `country = 'Uganda'` to reference the mountain's country rather than the climber's country. The amended query now correctly retrieves climb times from Uganda by joining through the mountain table to identify climbs in that country."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT climber_name, time_taken FROM climbers WHERE country = 'Uganda';",
            "SELECT T1.Time FROM climber AS T1 JOIN mountain AS T2 ON T1.Mountain_ID = T2.Mountain_ID WHERE T2.Country = \"Uganda\""
        ],
        "rule_sql": []
    },
    "2807": {
        "db_id": "news_report",
        "question": "What is the nationality of the journalist with the largest number of years working?",
        "ground_truth": "SELECT Nationality FROM journalist ORDER BY Years_working DESC LIMIT 1",
        "amends": [
            "Do reference the table as `journalist` instead of `journalists` to match the correct schema. Do use column name `Nationality` instead of `nationality` to maintain proper case sensitivity. Do use column name `Years_working` instead of `years_working` for accurate column reference. The amended query now correctly retrieves the nationality from the journalist table ordered by years of working experience."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT nationality FROM journalists ORDER BY years_working DESC LIMIT 1;",
            "SELECT Nationality FROM journalist ORDER BY Years_working DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6174": {
        "db_id": "music_4",
        "question": "Return the average number of weeks on top for volumes by artists that are at most 25 years old.",
        "ground_truth": "SELECT avg(T2.Weeks_on_Top) FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T1.age  <=  25",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference `T2.Weeks_on_Top` instead of `weeks_on_top` without table qualification. Do specify `artist AS T1` and `volume AS T2` instead of `volumes` and `artists` with different table names. Do use `JOIN` with `T1.Artist_ID = T2.Artist_ID` instead of `JOIN artists ON volumes.artist_id = artists.id` with different column naming. Do apply the age filter `T1.age <= 25` on the artist table instead of `artists.age <= 25`. The amended query now correctly calculates the average weeks on top for artists aged 25 or younger by properly joining the artist and volume tables with the correct column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(weeks_on_top) \nFROM volumes \nJOIN artists ON volumes.artist_id = artists.id \nWHERE artists.age <= 25;",
            "SELECT AVG(T2.Weeks_on_Top) FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID = T2.Artist_ID WHERE T1.Age <= 25"
        ],
        "rule_sql": []
    },
    "1808": {
        "db_id": "small_bank_1",
        "question": "Find the name of accounts whose checking balance is below the average checking balance.",
        "ground_truth": "SELECT T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  <  (SELECT avg(balance) FROM checking)",
        "amends": [
            "Do select `T1.name` from the `accounts` table instead of `name` from `accounts`. Do join with the `checking` table as `T2` on `T1.custid = T2.custid` instead of querying only the `accounts` table. Do filter on `T2.balance < (SELECT avg(balance) FROM checking)` instead of `checking_balance < (SELECT AVG(checking_balance) FROM accounts)`. Do remove the `ORDER BY checking_balance DESC` clause instead of keeping it. The amended query now correctly compares individual account balances against the average balance from the checking table rather than comparing against the average within the same table, and eliminates the unnecessary ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM accounts WHERE checking_balance < (SELECT AVG(checking_balance) FROM accounts) ORDER BY checking_balance DESC;",
            "SELECT T1.name \nFROM ACCOUNTS T1 \nJOIN CHECKING T2 ON T1.custid = T2.custid \nWHERE T2.balance < (SELECT AVG(balance) FROM CHECKING)"
        ],
        "rule_sql": []
    },
    "3031": {
        "db_id": "loan_1",
        "question": "Count the number of different account types.",
        "ground_truth": "SELECT count(DISTINCT acc_type) FROM customer",
        "amends": [
            "Do select `count(DISTINCT acc_type)` instead of `COUNT(*)`. Do use table `customer` instead of `accounts`. The amended query now correctly counts distinct account types from the customer table rather than counting all rows from the accounts table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM accounts;",
            "SELECT COUNT(DISTINCT acc_type) FROM customer;"
        ],
        "rule_sql": []
    },
    "5237": {
        "db_id": "music_2",
        "question": "What information is there on albums from 2010?",
        "ground_truth": "SELECT * FROM Albums WHERE YEAR  =  2010",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM albums WHERE year = '2010';"
        ],
        "rule_sql": []
    },
    "2028": {
        "db_id": "gas_company",
        "question": "What are the names of the managers for gas stations that are operated by the ExxonMobil company?",
        "ground_truth": "SELECT T3.manager_name FROM station_company AS T1 JOIN company AS T2 ON T1.company_id  =  T2.company_id JOIN gas_station AS T3 ON T1.station_id  =  T3.station_id WHERE T2.company  =  'ExxonMobil'",
        "amends": [
            "Do use explicit table aliases `T3.manager_name` instead of bare column reference `manager_name`. Do join three tables `station_company AS T1`, `company AS T2`, and `gas_station AS T3` instead of querying only `gas_stations`. Do add join conditions `T1.company_id = T2.company_id` and `T1.station_id = T3.station_id` instead of missing table relationships. Do filter on `T2.company = 'ExxonMobil'` instead of filtering directly on the gas_stations table. The amended query now correctly retrieves manager names by establishing proper relationships between company, station_company, and gas_station tables, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT manager_name FROM gas_stations WHERE company = 'ExxonMobil';",
            "SELECT T3.Manager_Name \nFROM station_company AS T1\nJOIN company AS T2 ON T1.Company_ID = T2.Company_ID\nJOIN gas_station AS T3 ON T1.Station_ID = T3.Station_ID\nWHERE T2.Company = 'ExxonMobil'"
        ],
        "rule_sql": []
    },
    "3481": {
        "db_id": "hr_1",
        "question": "get the details of employees who manage a department.",
        "ground_truth": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do change the FROM clause to use `employees AS T1 JOIN departments AS T2` instead of just `employees`. Do add the join condition `ON T1.department_id = T2.department_id` instead of having no join. Do change the WHERE clause to use `T1.employee_id = T2.manager_id` instead of `department_id IS NOT NULL`. Do add table aliases `T1` and `T2` instead of no aliases. The amended query now correctly joins employees with their respective department managers instead of simply filtering for non-null department IDs.",
            "Do remove the explicit table alias `T1.*` instead of keeping it, as the RIGHT_SQL uses a simple `*` which selects all columns from both joined tables. The join condition `T1.department_id = T2.department_id` and filter `T1.employee_id = T2.manager_id` remain unchanged, maintaining the same logic to find employees who are managers of their departments. The amended query now matches RIGHT_SQL's behavior by selecting all columns without the table-specific alias."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM employees WHERE department_id IS NOT NULL;",
            "SELECT DISTINCT T1.* FROM employees AS T1 JOIN departments AS T2 ON T1.department_id = T2.department_id WHERE T1.employee_id = T2.manager_id",
            "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id = T2.department_id WHERE T1.employee_id = T2.manager_id"
        ],
        "rule_sql": []
    },
    "3473": {
        "db_id": "hr_1",
        "question": "Find the first name and last name and department id for those employees who earn such amount of salary which is the smallest salary of any of the departments.",
        "ground_truth": "SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)",
        "amends": [
            "Do use `IN` for the subquery comparison instead of `=` to handle multiple minimum salaries per department, as the `=` operator would fail when the subquery returns more than one row from the `GROUP BY department_id` operation. Do keep the same `SELECT` list with `first_name`, `last_name`, and `department_id` instead of changing it. Do maintain the same `FROM employees` source and `WHERE salary` filter structure instead of altering them. Do preserve the identical subquery `SELECT MIN(salary) FROM employees GROUP BY department_id` instead of modifying its logic. The amended query now correctly handles cases where multiple employees share the minimum salary within their departments, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, department_id FROM employees WHERE salary = (SELECT MIN(salary) FROM employees GROUP BY department_id);",
            "SELECT first_name, last_name, department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)"
        ],
        "rule_sql": []
    },
    "3147": {
        "db_id": "assets_maintenance",
        "question": "Which fault log included the most number of faulty parts? List the fault log id, description and record time.",
        "ground_truth": "SELECT T1.fault_log_entry_id ,  T1.fault_description ,  T1.fault_log_entry_datetime FROM Fault_Log AS T1 JOIN Fault_Log_Parts AS T2 ON T1.fault_log_entry_id  =  T2.fault_log_entry_id GROUP BY T1.fault_log_entry_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.fault_log_entry_id`, `T1.fault_description`, and `T1.fault_log_entry_datetime` instead of `fault_log_id`, `description`, and `record_time`. Do use explicit table aliases `T1` and `T2` instead of no aliases. Do join `Fault_Log_Parts AS T2` on `T1.fault_log_entry_id = T2.fault_log_entry_id` instead of querying only the `fault_logs` table. Do group by `T1.fault_log_entry_id` instead of `fault_log_id`. Do order by `count(*)` instead of the alias `faulty_parts_count`. Do remove the explicit column alias `faulty_parts_count` instead of keeping it. The amended query now correctly joins the Fault_Log and Fault_Log_Parts tables to count associated parts and returns the appropriate columns with proper table references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT fault_log_id, description, record_time, COUNT(part_id) as faulty_parts_count\nFROM fault_logs\nGROUP BY fault_log_id\nORDER BY faulty_parts_count DESC\nLIMIT 1;",
            "SELECT T1.fault_log_entry_id, T1.fault_description, T1.fault_log_entry_datetime\nFROM Fault_Log AS T1\nJOIN Fault_Log_Parts AS T2 ON T1.fault_log_entry_id = T2.fault_log_entry_id\nGROUP BY T1.fault_log_entry_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "6172": {
        "db_id": "music_4",
        "question": "Return names of songs in volumes that are by artists that are at least 32 years old.",
        "ground_truth": "SELECT T2.Song FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T1.age  >=  32",
        "amends": [
            "Do reference the `songs` table as `T2` with column `Song` instead of `s.name` from `songs s`. Do use `artist AS T1` instead of `artists a` and `volume AS T2` instead of `volumes v`. Do change the join order to `artist AS T1 JOIN volume AS T2` instead of `songs s JOIN volumes v JOIN artists a`. Do use the join condition `T1.Artist_ID = T2.Artist_ID` instead of `s.volume_id = v.id` and `v.artist_id = a.id`. Do change the filter to `T1.age >= 32` instead of `a.age > 32`. The amended query now correctly retrieves songs from artists aged 32 or older by properly joining artist and volume tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.name \nFROM songs s\nJOIN volumes v ON s.volume_id = v.id\nJOIN artists a ON v.artist_id = a.id\nWHERE a.age > 32;",
            "SELECT T2.Song \nFROM artist AS T1 \nJOIN volume AS T2 ON T1.Artist_ID = T2.Artist_ID \nWHERE T1.Age >= 32"
        ],
        "rule_sql": []
    },
    "1028": {
        "db_id": "phone_1",
        "question": "What is the average ROM size of phones produced by the company named \"Nokia Corporation\"?",
        "ground_truth": "SELECT avg(T1.ROM_MiB) FROM chip_model AS T1 JOIN phone AS T2 ON T1.Model_name  =  T2.chip_model WHERE T2.Company_name = \"Nokia Corporation\";",
        "amends": [
            "Do join `chip_model AS T1` with `phone AS T2` on `T1.Model_name = T2.chip_model` instead of querying only the `phones` table. Do select `avg(T1.ROM_MiB)` instead of `AVG(ram_size)` to reference the correct column from the joined table. Do filter on `T2.Company_name = \"Nokia Corporation\"` instead of `company = 'Nokia Corporation'` to use the proper table alias and column name. The amended query now correctly joins the necessary tables and references the appropriate columns to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(ram_size) FROM phones WHERE company = 'Nokia Corporation';",
            "SELECT AVG(T1.ROM_MiB) \nFROM chip_model AS T1 \nJOIN phone AS T2 ON T1.Model_name = T2.chip_model \nWHERE T2.Company_name = 'Nokia Corporation'"
        ],
        "rule_sql": []
    },
    "307": {
        "db_id": "product_catalog",
        "question": "Find the name and level of catalog structure with level between 5 and 10.",
        "ground_truth": "SELECT catalog_level_name ,  catalog_level_number FROM Catalog_Structure WHERE catalog_level_number BETWEEN 5 AND 10",
        "amends": [
            "Do use column names `catalog_level_name` and `catalog_level_number` instead of `name` and `level`. Do use the `BETWEEN` operator with range `5 AND 10` instead of the `OR` condition `level > 10 OR level < 5` to properly select levels within the inclusive range. The amended query now correctly retrieves catalog levels between 5 and 10 inclusive, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, level FROM catalog_structure WHERE level > 10 OR level < 5;",
            "SELECT catalog_level_name, catalog_level_number FROM Catalog_Structure WHERE catalog_level_number BETWEEN 5 AND 10;"
        ],
        "rule_sql": []
    },
    "2830": {
        "db_id": "restaurant_1",
        "question": "Advisor 1121 has how many students?",
        "ground_truth": "SELECT count(*) FROM Student WHERE Advisor =  1121;",
        "amends": [
            "Do reference the table as `Student` instead of `students` and use the column name `Advisor` instead of `advisor_id` in the WHERE filter, while maintaining the same count aggregation logic. The amended query now correctly matches the intended behavior by using the proper table and column names from the schema."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE advisor_id = 1121;",
            "SELECT COUNT(*) FROM Student WHERE Advisor = 1121"
        ],
        "rule_sql": []
    },
    "80": {
        "db_id": "student_assessment",
        "question": "For every student who is registered for some course, how many courses are they registered for?",
        "ground_truth": "SELECT T1.student_id ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id",
        "amends": [
            "Do join `students AS T1` with `student_course_registrations AS T2` on `T1.student_id = T2.student_id` instead of querying only the `registrations` table. Do qualify `student_id` as `T1.student_id` in both SELECT and GROUP BY instead of using unqualified `student_id`. The amended query now correctly joins the student and registration tables to count course registrations per student, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_id, COUNT(*) FROM registrations GROUP BY student_id;",
            "SELECT T1.student_id, COUNT(T2.course_id) AS course_count\nFROM Students AS T1\nJOIN Student_Course_Registrations AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id"
        ],
        "rule_sql": []
    },
    "3048": {
        "db_id": "loan_1",
        "question": "Find the name of customer who has the lowest credit score.",
        "ground_truth": "SELECT cust_name FROM customer ORDER BY credit_score LIMIT 1",
        "amends": [
            "Do reference the `cust_name` column instead of `name` and use the `customer` table instead of `customers`. Do remove the explicit `ASC` direction from the `ORDER BY` clause instead of keeping it, as ascending order is the default. The amended query now correctly selects the customer name with the lowest credit score from the customer table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM customers ORDER BY credit_score ASC LIMIT 1;",
            "SELECT cust_name FROM customer ORDER BY credit_score LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1532": {
        "db_id": "insurance_and_eClaims",
        "question": "Which customers have an insurance policy with the type code \"Deputy\"? Give me the customer details.",
        "ground_truth": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  \"Deputy\"",
        "amends": [
            "Do select only `t2.customer_details` instead of all columns with `*`. Do add `DISTINCT` instead of omitting it. Do change the FROM source to a `JOIN` between `policies AS t1` and `customers AS t2` instead of querying only `customers`. Do add the join condition `ON t1.customer_id = t2.customer_id` instead of having no join. Do change the filter to use `t1.policy_type_code = \"Deputy\"` instead of `policy_type = 'Deputy'` on the customers table. The amended query now correctly joins policies and customers tables to find customers with specific policy types."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM customers WHERE policy_type = 'Deputy';",
            "SELECT DISTINCT t2.Customer_Details FROM Policies AS t1 JOIN Customers AS t2 ON t1.Customer_ID = t2.Customer_ID WHERE t1.Policy_Type_Code = 'Deputy'"
        ],
        "rule_sql": []
    },
    "5427": {
        "db_id": "shop_membership",
        "question": "What are the names and cities of the branches that do not have any registered members?",
        "ground_truth": "SELECT name ,  city FROM branch WHERE branch_id NOT IN (SELECT branch_id FROM membership_register_branch)",
        "amends": [
            "Do reference table `branch` instead of `branches` in the FROM clause. Do change the WHERE condition to use `branch_id NOT IN` with a subquery against `membership_register_branch` instead of filtering on `member_count = 0`. Do remove the direct column filter `member_count = 0` and instead implement the logic through a correlated subquery that identifies branches without members in the membership register. The amended query now correctly identifies branches without any registered members by checking against the membership registry table instead of relying on a potentially incorrect or missing member_count column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, city FROM branches WHERE member_count = 0;",
            "SELECT Name, City FROM branch WHERE Branch_ID NOT IN (SELECT Branch_ID FROM membership_register_branch);"
        ],
        "rule_sql": []
    },
    "6596": {
        "db_id": "wine_1",
        "question": "What is the average price for wines not produced in Sonoma county?",
        "ground_truth": "SELECT avg(price) FROM wine WHERE Appelation NOT IN (SELECT T1.Appelation FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  'Sonoma')",
        "amends": [
            "Do use `avg(price)` instead of `AVG(price)` for case consistency. Do change the table reference from `wines` to `wine` to match the correct schema. Do replace the simple `WHERE county != 'Sonoma'` filter with a subquery condition `WHERE Appelation NOT IN (SELECT T1.Appelation FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation = T2.Appelation WHERE T1.County = 'Sonoma')` instead, which properly excludes wines from Sonoma county by checking the APPELLATIONS table join rather than assuming the county field exists directly in the WINE table. Do add the required JOIN between APPELLATIONS and WINE tables in the subquery instead of omitting this necessary relationship. The amended query now correctly matches the RIGHT_SQL's behavior by properly filtering based on county information from the related APPELLATIONS table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(price) FROM wines WHERE county != 'Sonoma';",
            "SELECT avg(Price) FROM wine WHERE Appelation NOT IN (SELECT T1.Appelation FROM appellations AS T1 JOIN wine AS T2 ON T1.Appelation = T2.Appelation WHERE T1.County = 'Sonoma')"
        ],
        "rule_sql": []
    },
    "2097": {
        "db_id": "pilot_record",
        "question": "List the names of pilots that do not have any record.",
        "ground_truth": "SELECT Pilot_name FROM pilot WHERE Pilot_ID NOT IN (SELECT Pilot_ID FROM pilot_record)",
        "amends": [
            "Do select `Pilot_name` from the `pilot` table instead of `name` from `pilots`. Do use a `NOT IN` subquery filtering by `Pilot_ID` instead of checking `record IS NULL`. Do reference the `pilot_record` table in the subquery instead of omitting it. Do filter based on missing records in the related table instead of a direct NULL check on a column. The amended query now correctly identifies pilots without associated records by checking for missing entries in the pilot_record table rather than relying on a NULL value in the main table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM pilots WHERE record IS NULL;",
            "SELECT Pilot_name FROM pilot WHERE Pilot_ID NOT IN (SELECT Pilot_ID FROM pilot_record)"
        ],
        "rule_sql": []
    },
    "985": {
        "db_id": "university_basketball",
        "question": "How many schools are in the basketball match?",
        "ground_truth": "SELECT count(DISTINCT school_id) FROM basketball_match",
        "amends": [
            "Do select `count(DISTINCT school_id)` instead of `COUNT(*)` to count unique schools rather than all players. Do query from `basketball_match` table instead of `players` table to access the appropriate data source. Do remove the `WHERE sport = 'basketball'` filter instead of keeping it since the basketball_match table inherently contains only basketball data. The amended query now correctly counts distinct schools from basketball matches rather than counting all basketball players, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE sport = 'basketball';",
            "SELECT COUNT(DISTINCT School_ID) FROM basketball_match;"
        ],
        "rule_sql": []
    },
    "4456": {
        "db_id": "network_2",
        "question": "Find the names of females who are friends with Zach",
        "ground_truth": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Zach' AND T1.gender  =  'female'",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of no aliases. Do join `Person AS T1` with `PersonFriend AS T2` on `T1.name = T2.name` instead of querying only the `people` table. Do filter on `T2.friend = 'Zach'` instead of `friend = 'Zach'` to reference the correct table. Do filter on `T1.gender = 'female'` instead of `gender = 'female'` to reference the correct table. The amended query now correctly joins the Person and PersonFriend tables to find female persons who have Zach as a friend, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM people WHERE gender = 'female' AND friend = 'Zach'",
            "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T1.gender = 'female' AND T2.friend = 'Zach'"
        ],
        "rule_sql": []
    },
    "4677": {
        "db_id": "college_3",
        "question": "Find the rank of the faculty that the fewest faculties belong to.",
        "ground_truth": "SELECT Rank FROM FACULTY GROUP BY Rank ORDER BY count(*) ASC LIMIT 1",
        "amends": [
            "Do select only `Rank` instead of both `rank` and `COUNT(*) as count` in the SELECT list. Do order by `count(*) ASC` instead of ordering by the alias `count ASC`. Do remove the explicit column alias `as count` instead of keeping it. The amended query now correctly returns only the rank with the lowest count while maintaining the same logical behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT rank, COUNT(*) as count FROM Faculty GROUP BY rank ORDER BY count ASC LIMIT 1;",
            "SELECT Rank FROM Faculty GROUP BY Rank ORDER BY COUNT(*) ASC LIMIT 1"
        ],
        "rule_sql": []
    },
    "6045": {
        "db_id": "game_1",
        "question": "Show all game names played by at least 1000 hours.",
        "ground_truth": "SELECT gname FROM Plays_games AS T1 JOIN Video_games AS T2 ON T1.gameid  =  T2.gameid GROUP BY T1.gameid HAVING sum(hours_played)  >=  1000",
        "amends": [
            "Do select `gname` from the `Video_games` table instead of `game_name` from the `games` table. Do join `Plays_games` and `Video_games` tables on `gameid` instead of querying a single table. Do use `GROUP BY` on `gameid` and `HAVING` with `sum(hours_played)` aggregation instead of filtering individual records with `WHERE hours_played > 1000`. Do reference the aggregated sum with `>= 1000` instead of comparing individual values with `> 1000`. The amended query now correctly calculates total hours played per game and filters for games with cumulative playtime exceeding 1000 hours, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT game_name FROM games WHERE hours_played > 1000;",
            "SELECT vg.GName \nFROM Video_Games vg\nJOIN Plays_Games pg ON vg.GameID = pg.GameID\nGROUP BY vg.GameID, vg.GName\nHAVING SUM(pg.Hours_Played) >= 1000"
        ],
        "rule_sql": []
    },
    "6567": {
        "db_id": "wine_1",
        "question": "Find the distinct names of wines produced before the year of 2000 or after the year of 2010.",
        "ground_truth": "SELECT DISTINCT Name FROM WINE WHERE YEAR  <  2000 OR YEAR  >  2010",
        "amends": [
            "Do reference table `WINE` instead of `wines` and use column `Name` instead of `name`. Do change the WHERE condition to use `OR` between `YEAR < 2000` and `YEAR > 2010` instead of `AND`, which would return no results since a year cannot be both before 2000 and after 2010 simultaneously. The amended query now correctly returns wines from either before 2000 or after 2010, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT name FROM wines WHERE year < 2000 AND year > 2010;",
            "SELECT DISTINCT Name FROM wine WHERE Year < 2000 OR Year > 2010"
        ],
        "rule_sql": []
    },
    "2105": {
        "db_id": "cre_Doc_Control_Systems",
        "question": "What is the description of role code ED?",
        "ground_truth": "SELECT role_description FROM ROLES WHERE role_code = \"ED\";",
        "amends": [
            "Do select `role_description` instead of `description` to use the correct column name. Do use double quotes `\"ED\"` instead of single quotes `'ED'` for the string literal value. The amended query now correctly retrieves the role description for the specified role code."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM roles WHERE role_code = 'ED';",
            "SELECT role_description FROM Roles WHERE role_code = \"ED\";"
        ],
        "rule_sql": []
    },
    "4490": {
        "db_id": "decoration_competition",
        "question": "Which countries have more than two members?",
        "ground_truth": "SELECT Country FROM member GROUP BY Country HAVING COUNT(*)  >  2",
        "amends": [
            "Do reference the `Country` column instead of `country` to match the correct case sensitivity. Do use the table name `member` instead of `members` to reference the correct source table. Do remove the `COUNT(*)` from the SELECT list instead of including it, as only the grouped column is needed in the output. The amended query now correctly filters for countries with more than two members while returning only the country names as specified in the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) FROM members GROUP BY country HAVING COUNT(*) > 2",
            "SELECT Country FROM member GROUP BY Country HAVING COUNT(*) > 2"
        ],
        "rule_sql": []
    },
    "3893": {
        "db_id": "insurance_policies",
        "question": "Which customers do not have any policies? Find the details of these customers.",
        "ground_truth": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id",
        "amends": [
            "Do select `customer_details` instead of `*` and use `EXCEPT` instead of a simple filter. Do add a join with `Customer_Policies` on `customer_id` instead of filtering by `policy_id IS NOT NULL`. Do remove the `WHERE` clause entirely instead of keeping the incorrect filter logic. The amended query now correctly identifies customers without policies by using set operations instead of null checks, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM customers WHERE policy_id IS NOT NULL;",
            "SELECT Customer_Details FROM Customers\nEXCEPT\nSELECT c.Customer_Details \nFROM Customers c\nJOIN Customer_Policies cp ON c.Customer_ID = cp.Customer_ID;"
        ],
        "rule_sql": []
    },
    "1932": {
        "db_id": "cinema",
        "question": "How many cinema do we have?",
        "ground_truth": "SELECT count(*) FROM cinema",
        "amends": [
            "Do reference the `cinema` table instead of the `movies` table in the FROM clause. The amended query now correctly counts records from the cinema table as specified in the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies;",
            "SELECT COUNT(*) FROM cinema;"
        ],
        "rule_sql": []
    },
    "522": {
        "db_id": "allergy_1",
        "question": "What are the allergies the girl named Lisa has? And what are the types of them? Order the result by allergy names.",
        "ground_truth": "SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  \"Lisa\" ORDER BY T1.Allergy",
        "amends": [
            "Do use explicit table aliases `T1`, `T2`, and `T3` instead of direct column references without table context. Do join three tables `Allergy_type`, `Has_allergy`, and `Student` instead of querying a single `allergies` table. Do filter on `T3.Fname = \"Lisa\"` instead of `patient_name = 'Lisa' AND gender = 'Female'`. Do select `T1.Allergy` and `T1.AllergyType` instead of `allergy_name` and `type`. Do order by `T1.Allergy` instead of `allergy_name`. The amended query now correctly joins the relational schema to find Lisa's allergies through proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT allergy_name, type FROM allergies WHERE patient_name = 'Lisa' AND gender = 'Female' ORDER BY allergy_name;",
            "SELECT T1.Allergy, T1.AllergyType\nFROM Allergy_Type T1\nJOIN Has_Allergy T2 ON T1.Allergy = T2.Allergy\nJOIN Student T3 ON T2.StuID = T3.StuID\nWHERE T3.Fname = 'Lisa' AND T3.Sex = 'F'\nORDER BY T1.Allergy;"
        ],
        "rule_sql": []
    },
    "224": {
        "db_id": "book_2",
        "question": "Show the titles of books in descending order of publication price.",
        "ground_truth": "SELECT T1.Title FROM book AS T1 JOIN publication AS T2 ON T1.Book_ID  =  T2.Book_ID ORDER BY T2.Price DESC",
        "amends": [
            "Do join `book AS T1` with `publication AS T2` on `T1.Book_ID = T2.Book_ID` instead of querying only the `books` table. Do select `T1.Title` instead of `title` and order by `T2.Price DESC` instead of `publication_price ASC`. The amended query now correctly joins the book and publication tables to access the price information and sorts in descending order, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM books ORDER BY publication_price ASC;",
            "SELECT T1.Title FROM book AS T1 JOIN publication AS T2 ON T1.Book_ID = T2.Book_ID ORDER BY T2.Price DESC"
        ],
        "rule_sql": []
    },
    "3876": {
        "db_id": "insurance_policies",
        "question": "What are the claim dates and settlement dates of all the settlements?",
        "ground_truth": "SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Settlements",
        "amends": [
            "Do reference columns as `Date_Claim_Made` and `Date_Claim_Settled` instead of `claim_date` and `settlement_date` to match the actual table schema. Do use proper table name `Settlements` instead of `settlements` with correct casing. The amended query now correctly references the actual column and table names to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT claim_date, settlement_date FROM settlements WHERE claim_date > settlement_date;",
            "SELECT Date_Claim_Made, Date_Claim_Settled FROM Settlements;"
        ],
        "rule_sql": []
    },
    "3839": {
        "db_id": "e_learning",
        "question": "Which student are enrolled in at least two courses? Give me the student ID and personal name.",
        "ground_truth": "SELECT T1.student_id ,  T2.personal_name FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING COUNT(*)  >=  2",
        "amends": [
            "Do use `T1.student_id` and `T2.personal_name` with explicit table aliases instead of `student_id` and `personal_name` without table qualification. Do join `Student_Course_Enrolment AS T1` with `Students AS T2` on `T1.student_id = T2.student_id` instead of querying only the `students` table. Do move the aggregate condition to `HAVING COUNT(*) >= 2` instead of incorrectly placing `COUNT(course_id) >= 2` in the `WHERE` clause where aggregates are not allowed. Do add `GROUP BY T1.student_id` to properly group the results by student instead of omitting the necessary grouping clause. The amended query now correctly identifies students enrolled in at least two courses by properly joining enrollment data with student information and using appropriate aggregation with HAVING."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_id, personal_name \nFROM students \nWHERE COUNT(course_id) >= 2;",
            "SELECT T1.student_id, T2.personal_name\nFROM Student_Course_Enrolment AS T1\nJOIN Students AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "1120": {
        "db_id": "climbing",
        "question": "What are the names of mountains in ascending alphabetical order?",
        "ground_truth": "SELECT Name FROM mountain ORDER BY Name ASC",
        "amends": [
            "Do reference the `Name` column instead of `name` to match the correct case sensitivity. Do query from the `mountain` table instead of `mountains` to use the correct table name. Do use `ASC` ordering instead of `DESC` to sort in ascending rather than descending order. The amended query now correctly retrieves names from the mountain table in ascending alphabetical order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM mountains ORDER BY name DESC;",
            "SELECT Name FROM mountain ORDER BY Name ASC;"
        ],
        "rule_sql": []
    },
    "2742": {
        "db_id": "election",
        "question": "Show all the distinct districts for elections.",
        "ground_truth": "SELECT DISTINCT District FROM election",
        "amends": [
            "Do select only `District` instead of all columns with `*`, and do add `DISTINCT` to return unique district values instead of all duplicate records. Do reference the correct table name `election` instead of the incorrect plural form `elections`. The amended query now correctly returns only unique district names from the election table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM elections;",
            "SELECT DISTINCT District FROM election;"
        ],
        "rule_sql": []
    },
    "4356": {
        "db_id": "tracking_grants_for_research",
        "question": "Which project made the most number of outcomes? List the project details and the project id.",
        "ground_truth": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `Projects AS T1` with `Project_outcomes AS T2` on `T1.project_id = T2.project_id` instead of querying only the `projects` table. Do select `T1.project_details` and `T1.project_id` instead of `project_id`, `project_name`, and `COUNT(*) as outcome_count`. Do group by `T1.project_id` instead of `project_id`. Do order by `count(*) DESC` instead of `outcome_count DESC`. The amended query now correctly joins the projects and outcomes tables to count outcomes per project and returns the project with the highest outcome count, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT project_id, project_name, COUNT(*) as outcome_count \nFROM projects \nGROUP BY project_id \nORDER BY outcome_count DESC \nLIMIT 1;",
            "SELECT T1.project_details, T1.project_id\nFROM Projects AS T1\nJOIN Project_Outcomes AS T2 ON T1.project_id = T2.project_id\nGROUP BY T1.project_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5618": {
        "db_id": "swimming",
        "question": "Find all 200 meter and 300 meter results of swimmers with nationality \"Australia\".",
        "ground_truth": "SELECT meter_200 ,  meter_300 FROM swimmer WHERE nationality  =  'Australia'",
        "amends": [
            "Do select specific columns `meter_200` and `meter_300` instead of using `SELECT *` to return all columns. Do reference the table as `swimmer` instead of `swimmers` to match the correct table name. Do remove the incorrect `distance` filter condition using `200 OR 300` values since the right query focuses on retrieving the specific meter columns without distance-based filtering, instead of applying an unnecessary filter that doesn't align with the intended result set. The amended query now correctly retrieves only the Australian swimmers' 200-meter and 300-meter performance data from the proper table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM swimmers WHERE nationality = 'Australia' AND (distance = 200 OR distance = 300);",
            "SELECT meter_200, meter_300 FROM swimmer WHERE Nationality = 'Australia'"
        ],
        "rule_sql": []
    },
    "2769": {
        "db_id": "election",
        "question": "Find the parties associated with the delegates from district 1. Who served as governors of the parties?",
        "ground_truth": "SELECT T2.Governor FROM election AS T1 JOIN party AS T2 ON T1.Party  =  T2.Party_ID WHERE T1.District  =  1",
        "amends": [
            "Do select `T2.Governor` instead of `party_name, governor_name`. Do use `FROM election AS T1 JOIN party AS T2` instead of `FROM delegates`. Do apply join condition `ON T1.Party = T2.Party_ID` instead of no join. Do filter with `WHERE T1.District = 1` instead of `WHERE district = 1`. Do remove `GROUP BY party_name` instead of keeping it. The amended query now correctly retrieves governor names from joined election and party tables based on district filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT party_name, governor_name FROM delegates WHERE district = 1 GROUP BY party_name;",
            "SELECT T2.Governor FROM election AS T1 JOIN party AS T2 ON T1.Party = T2.Party_ID WHERE T1.District = 1"
        ],
        "rule_sql": []
    },
    "2443": {
        "db_id": "movie_1",
        "question": "How many reviewers are there?",
        "ground_truth": "SELECT count(*) FROM Reviewer",
        "amends": [
            "Do select from `Reviewer` table instead of `movies` table. Do count rows from the correct table instead of the wrong table. The amended query now correctly counts records from the Reviewer table as intended."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies;",
            "SELECT COUNT(*) FROM Reviewer;"
        ],
        "rule_sql": []
    },
    "765": {
        "db_id": "race_track",
        "question": "Show name, class, and date for all races.",
        "ground_truth": "SELECT name ,  CLASS ,  date FROM race",
        "amends": [
            "Do add `date` to the SELECT list instead of omitting it. Do change the table reference from `races` to `race` instead of using the incorrect table name. Do change the column reference from `class` to `CLASS` instead of using lowercase formatting. The amended query now correctly selects all required columns from the proper table and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, class FROM races",
            "SELECT Name, Class, Date FROM race;"
        ],
        "rule_sql": []
    },
    "6054": {
        "db_id": "game_1",
        "question": "what is the last name and gender of all students who played both Call of Destiny and Works of Widenius?",
        "ground_truth": "SELECT lname ,  sex FROM Student WHERE StuID IN (SELECT T1.StuID FROM Plays_games AS T1 JOIN Video_games AS T2 ON T1.GameID  =  T2.GameID WHERE T2.Gname  =  \"Call of Destiny\" INTERSECT SELECT T1.StuID FROM Plays_games AS T1 JOIN Video_games AS T2 ON T1.GameID  =  T2.GameID WHERE T2.Gname  =  \"Works of Widenius\")",
        "amends": [
            "Do use table `Student` with columns `lname` and `sex` instead of `students` with `last_name` and `gender`. Do replace the impossible `WHERE` condition requiring `game_played` to equal both 'Call of Destiny' and 'Works of Widenius' with an `INTERSECT` subquery that finds students who play both games. Do use proper table joins between `Plays_games` and `Video_games` on `GameID` instead of directly filtering a single `game_played` column. Do reference game names through `T2.Gname` with double quotes instead of single quotes. The amended query now correctly identifies students who play both specified games by using set intersection logic instead of the contradictory original condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT last_name, gender FROM students WHERE game_played = 'Call of Destiny' AND game_played = 'Works of Widenius'",
            "SELECT s.LName, s.Sex\nFROM Student s\nWHERE s.StuID IN (\n    SELECT pg1.StuID\n    FROM Plays_Games pg1\n    JOIN Video_Games vg1 ON pg1.GameID = vg1.GameID\n    WHERE vg1.GName = \"Call of Destiny\"\n    INTERSECT\n    SELECT pg2.StuID\n    FROM Plays_Games pg2\n    JOIN Video_Games vg2 ON pg2.GameID = vg2.GameID\n    WHERE vg2.GName = \"Works of Widenius\"\n)"
        ],
        "rule_sql": []
    },
    "259": {
        "db_id": "musical",
        "question": "What are the names of musicals who have at 3 or more actors?",
        "ground_truth": "SELECT T2.Name FROM actor AS T1 JOIN musical AS T2 ON T1.Musical_ID  =  T2.Musical_ID GROUP BY T1.Musical_ID HAVING COUNT(*)  >=  3",
        "amends": [
            "Do select `T2.Name` from the `musical` table instead of `m.name` from `musals`. Do use `JOIN` between `actor` and `musical` tables on `T1.Musical_ID = T2.Musical_ID` instead of a subquery with `IN` condition. Do group by `T1.Musical_ID` instead of grouping by `musical_id` in a subquery. Do keep the `HAVING COUNT(*) >= 3` condition instead of `HAVING COUNT(actor_id) >= 3` but maintain the same filtering logic. Do remove the subquery structure entirely instead of using nested query. The amended query now correctly joins actor and musical tables directly and matches the RIGHT_SQL's behavior of finding musicals with at least 3 actors."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT m.name \nFROM musicals m \nWHERE m.id IN (\n    SELECT musical_id \n    FROM cast_members \n    GROUP BY musical_id \n    HAVING COUNT(actor_id) >= 3\n)",
            "SELECT T2.Name \nFROM actor T1 \nJOIN musical T2 ON T1.Musical_ID = T2.Musical_ID \nGROUP BY T1.Musical_ID \nHAVING COUNT(*) >= 3"
        ],
        "rule_sql": []
    },
    "1847": {
        "db_id": "wrestler",
        "question": "What are the names of the wrestlers, ordered descending by days held?",
        "ground_truth": "SELECT Name FROM wrestler ORDER BY Days_held DESC",
        "amends": [
            "Do reference the `Name` column instead of `name` to match the correct column name casing. Do reference the `wrestler` table instead of `wrestlers` to use the correct table name. Do use `DESC` ordering instead of `ASC` to sort by days held in descending order rather than ascending order. The amended query now correctly retrieves names from the wrestler table sorted by days held in descending order, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM wrestlers ORDER BY days_held ASC;",
            "SELECT Name FROM wrestler ORDER BY Days_held DESC;"
        ],
        "rule_sql": []
    },
    "2074": {
        "db_id": "party_people",
        "question": "What are the names of members who are not in charge of any events?",
        "ground_truth": "SELECT member_name FROM member EXCEPT SELECT T1.member_name FROM member AS T1 JOIN party_events AS T2 ON T1.member_id  =  T2.member_in_charge_id",
        "amends": [
            "Do select `member_name` instead of `name` and use `EXCEPT` instead of `NOT IN` with a subquery. Do reference table `member` instead of `members` and remove the `WHERE` clause entirely. Do add a join between `member AS T1` and `party_events AS T2` on `T1.member_id = T2.member_in_charge_id` instead of checking for membership in an events table. The amended query now correctly identifies members not in charge of party events by using set operations instead of subquery negation, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM members WHERE member_id NOT IN (SELECT member_id FROM events)",
            "SELECT Member_Name FROM member EXCEPT SELECT T1.Member_Name FROM member AS T1 JOIN party_events AS T2 ON T1.Member_ID = T2.Member_in_charge_ID"
        ],
        "rule_sql": []
    },
    "4635": {
        "db_id": "college_3",
        "question": "How many courses are there in total?",
        "ground_truth": "SELECT count(*) FROM COURSE",
        "amends": [
            "Do query the `COURSE` table instead of the `students` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the COURSE table instead of students."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;",
            "SELECT count(*) FROM Course;"
        ],
        "rule_sql": []
    },
    "4458": {
        "db_id": "network_2",
        "question": "Find the female friends of Alice.",
        "ground_truth": "SELECT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T2.name  =  'Alice' AND T1.gender  =  'female'",
        "amends": [
            "Do select `T2.friend` instead of `*` from all columns. Do use `Person AS T1 JOIN PersonFriend AS T2` instead of a single `friends` table. Do apply the join condition `ON T1.name = T2.friend` instead of no join. Do filter with `T2.name = 'Alice'` instead of `name = 'Alice'`. Do filter with `T1.gender = 'female'` instead of `gender = 'male'`. The amended query now correctly finds female persons whose friends include Alice by joining the Person and PersonFriend tables with appropriate conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM friends WHERE gender = 'male' AND name = 'Alice';",
            "SELECT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.friend WHERE T2.name = 'Alice' AND T1.gender = 'female'"
        ],
        "rule_sql": []
    },
    "6367": {
        "db_id": "flight_company",
        "question": "List the vehicle flight number, date and pilot of all the flights, ordered by altitude.",
        "ground_truth": "SELECT vehicle_flight_number ,  date ,  pilot FROM flight ORDER BY altitude ASC",
        "amends": [
            "Do reference `vehicle_flight_number` instead of `flight_number` and use table `flight` instead of `flights`. Do add explicit `ASC` ordering instead of implicit ordering in the ORDER BY clause while maintaining the same column reference `altitude`."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT flight_number, date, pilot FROM flights ORDER BY altitude;",
            "SELECT Vehicle_Flight_number, Date, Pilot FROM flight ORDER BY Altitude ASC;"
        ],
        "rule_sql": []
    },
    "1056": {
        "db_id": "match_season",
        "question": "Show all official native languages that contain the word \"English\".",
        "ground_truth": "SELECT Official_native_language FROM country WHERE Official_native_language LIKE \"%English%\"",
        "amends": [
            "Do select `Official_native_language` instead of `*` from all columns. Do query from `country` table instead of `languages` table. Do use `Official_native_language` column for the LIKE filter instead of `name` column. Do remove the `official = 1` filter condition instead of keeping it, as the requirement is simply to find countries where English is the official native language. The amended query now correctly identifies countries with English as their official native language rather than searching through a languages table with different schema structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM languages WHERE name LIKE '%English%' AND official = 1;",
            "SELECT Official_native_language FROM country WHERE Official_native_language LIKE '%English%'"
        ],
        "rule_sql": []
    },
    "561": {
        "db_id": "store_1",
        "question": "List the number of invoices from Chicago, IL.",
        "ground_truth": "SELECT COUNT(*) FROM invoices WHERE billing_city  =  \"Chicago\" AND billing_state  =  \"IL\";",
        "amends": [
            "Do reference `billing_city` instead of `city` and `billing_state` instead of `state` in the WHERE clause filters, as the correct columns contain the billing address information rather than general city/state fields. Do use double quotes `\"Chicago\"` and `\"IL\"` instead of single quotes for string literals to match the right SQL's formatting convention. The amended query now correctly counts invoices based on billing location criteria and matches the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM invoices WHERE city = 'Chicago' AND state = 'IL';",
            "SELECT COUNT(*) FROM invoices WHERE billing_city = \"Chicago\" AND billing_state = \"IL\";"
        ],
        "rule_sql": []
    },
    "5936": {
        "db_id": "cre_Theme_park",
        "question": "What is the average price range of hotels for each each star rating code?",
        "ground_truth": "SELECT star_rating_code ,  avg(price_range) FROM HOTELS GROUP BY star_rating_code",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT star_rating_code, AVG(price_range) FROM hotels GROUP BY star_rating_code;"
        ],
        "rule_sql": []
    },
    "3296": {
        "db_id": "college_1",
        "question": "What is the average GPA of students taking ACCT-211?",
        "ground_truth": "SELECT avg(T2.stu_gpa) FROM enroll AS T1 JOIN student AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T1.class_code  =  T3.class_code WHERE T3.crs_code  =  'ACCT-211'",
        "amends": [
            "Do use `avg(T2.stu_gpa)` instead of `AVG(gpa)` to reference the correct column from the joined table. Do add `FROM enroll AS T1 JOIN student AS T2 ON T1.stu_num = T2.stu_num JOIN CLASS AS T3 ON T1.class_code = T3.class_code` instead of the single table `FROM students` to properly join the enrollment, student, and class tables. Do change the filter to `WHERE T3.crs_code = 'ACCT-211'` instead of `WHERE course = 'ACCT-211'` to filter by the correct course code column in the class table. The amended query now correctly calculates the average GPA for students enrolled in ACCT-211 by joining the necessary tables and using the proper column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(gpa) FROM students WHERE course = 'ACCT-211';",
            "SELECT AVG(T2.STU_GPA) \nFROM ENROLL AS T1 \nJOIN STUDENT AS T2 ON T1.STU_NUM = T2.STU_NUM \nJOIN CLASS AS T3 ON T1.CLASS_CODE = T3.CLASS_CODE \nWHERE T3.CRS_CODE = 'ACCT-211'"
        ],
        "rule_sql": []
    },
    "1436": {
        "db_id": "college_2",
        "question": "What is the course title of the prerequisite of course Mobile Computing?",
        "ground_truth": "SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.title  =  'Mobile Computing')",
        "amends": [
            "Do select `title` from `course` instead of `course_title` from `courses`. Do use `IN` with a subquery instead of `=` with a scalar subquery. Do reference `prereq_id` from the `prereq` table instead of `prerequisite` from the `courses` table. Do join `prereq AS T1` with `course AS T2` on `T1.course_id = T2.course_id` instead of using a single table subquery. Do filter on `T2.title = 'Mobile Computing'` instead of `course_title = 'Mobile Computing'`. The amended query now correctly handles the prerequisite relationship through a proper join structure instead of incorrectly assuming prerequisite data exists within the same table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT course_title FROM courses WHERE course_id = (SELECT prerequisite FROM courses WHERE course_title = 'Mobile Computing');",
            "SELECT c.title \nFROM course c\nWHERE c.course_id IN (\n    SELECT p.prereq_id \n    FROM prereq p\n    JOIN course c2 ON p.course_id = c2.course_id\n    WHERE c2.title = 'Mobile Computing'\n)"
        ],
        "rule_sql": []
    },
    "2768": {
        "db_id": "election",
        "question": "Who were the governors of the parties associated with delegates from district 1?",
        "ground_truth": "SELECT T2.Governor FROM election AS T1 JOIN party AS T2 ON T1.Party  =  T2.Party_ID WHERE T1.District  =  1",
        "amends": [
            "Do select `T2.Governor` instead of `governor_name` and change the data source completely from `delegates` to a join between `election AS T1` and `party AS T2` instead of a single table. Do add a join condition `ON T1.Party = T2.Party_ID` instead of no join, and maintain the filter `WHERE T1.District = 1` instead of `district = 1` but with proper table qualification. The amended query now correctly retrieves governor information through proper table relationships instead of relying on a potentially incorrect single table structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT governor_name FROM delegates WHERE district = 1",
            "SELECT T2.Governor \nFROM election AS T1 \nJOIN party AS T2 ON T1.Party = T2.Party_ID \nWHERE T1.District = 1"
        ],
        "rule_sql": []
    },
    "5851": {
        "db_id": "tracking_share_transactions",
        "question": "Show all dates of transactions whose type code is \"SALE\".",
        "ground_truth": "SELECT date_of_transaction FROM TRANSACTIONS WHERE transaction_type_code  =  \"SALE\"",
        "amends": [
            "Do select `date_of_transaction` instead of `date` and filter on `transaction_type_code = \"SALE\"` instead of `type_code = 'PURCHASE'`. The amended query now correctly references the appropriate column names and filter condition to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT date FROM transactions WHERE type_code = 'PURCHASE';",
            "SELECT date_of_transaction FROM Transactions WHERE transaction_type_code = 'SALE';"
        ],
        "rule_sql": []
    },
    "1093": {
        "db_id": "match_season",
        "question": "How many players are from each country?",
        "ground_truth": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name",
        "amends": [
            "Do specify `Country_name` from the `country` table instead of `country` from the `players` table. Do add a `JOIN` between `country AS T1` and `match_season AS T2` with the predicate `T1.Country_id = T2.Country` instead of querying only the `players` table. Do group by `T1.Country_name` instead of `country` to ensure proper aggregation with the joined data. The amended query now correctly counts matches per country by joining the country and match_season tables, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) FROM players GROUP BY country;",
            "SELECT T1.Country_name, COUNT(*) AS player_count\nFROM country AS T1\nJOIN match_season AS T2 ON T1.Country_id = T2.Country\nGROUP BY T1.Country_name;"
        ],
        "rule_sql": []
    },
    "6365": {
        "db_id": "school_bus",
        "question": "find the name of driver who is driving the school bus with the longest working history.",
        "ground_truth": "SELECT t1.name FROM driver AS t1 JOIN school_bus AS t2 ON t1.driver_id  =  t2.driver_id ORDER BY years_working DESC LIMIT 1",
        "amends": [
            "Do select `t1.name` from the `driver` table instead of just `name` from `drivers`. Do add a `JOIN` with `school_bus AS t2` on `t1.driver_id = t2.driver_id` instead of querying only a single table. Do order by `years_working DESC` instead of `working_history DESC` while keeping the `LIMIT 1`. The amended query now correctly retrieves the driver with the most years working who is associated with a school bus, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM drivers ORDER BY working_history DESC LIMIT 1;",
            "SELECT t1.Name FROM driver AS t1 JOIN school_bus AS t2 ON t1.Driver_ID = t2.Driver_ID ORDER BY t2.Years_Working DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "3076": {
        "db_id": "loan_1",
        "question": "Find the city and name of bank branches that provide business loans.",
        "ground_truth": "SELECT T1.bname ,  T1.city FROM bank AS T1 JOIN loan AS T2 ON T1.branch_id  =  T2.branch_id WHERE T2.loan_type  =  'Business'",
        "amends": [
            "Do join `bank AS T1` with `loan AS T2` on `T1.branch_id = T2.branch_id` instead of querying only `bank_branches` without proper table relationships. Do select `T1.bname` and `T1.city` instead of `city` and `name` to use qualified column names from the joined tables. Do filter on `T2.loan_type = 'Business'` instead of `loan_type = 'business'` to reference the correct table and use proper case sensitivity. The amended query now correctly joins the bank and loan tables to find business loans and matches the RIGHT_SQL's behavior.",
            "Do use `branch_id` in the join condition instead of `branch_ID` to match the correct column name. Do maintain the same column selection order of `T1.bname, T1.city` instead of `T1.city, T1.bname` to preserve the intended output sequence. The amended query now correctly joins on the proper column identifier while maintaining the same logical behavior as the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, name FROM bank_branches WHERE loan_type = 'business';",
            "SELECT T1.city, T1.bname FROM bank AS T1 JOIN loan AS T2 ON T1.branch_ID = T2.branch_ID WHERE T2.loan_type = 'Business'",
            "SELECT T1.bname, T1.city\nFROM bank AS T1\nJOIN loan AS T2 ON T1.branch_ID = T2.branch_ID\nWHERE T2.loan_type = 'Business'"
        ],
        "rule_sql": []
    },
    "5999": {
        "db_id": "game_1",
        "question": "How many sports do we have?",
        "ground_truth": "SELECT count(DISTINCT sportname) FROM Sportsinfo",
        "amends": [
            "Do select `count(DISTINCT sportname)` instead of `COUNT(*)`. Do use table `Sportsinfo` instead of `athletes`. Do add the `DISTINCT` modifier for counting unique sport names instead of counting all rows. The amended query now correctly counts distinct sports rather than total athlete records."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM athletes;",
            "SELECT COUNT(DISTINCT SportName) FROM SportsInfo;"
        ],
        "rule_sql": []
    },
    "2578": {
        "db_id": "inn_1",
        "question": "How many kids stay in the rooms reserved by ROY SWEAZY?",
        "ground_truth": "SELECT kids FROM Reservations WHERE FirstName = \"ROY\" AND LastName  =  \"SWEAZY\";",
        "amends": [
            "Do select `kids` instead of `COUNT(*)`. Do use `FROM Reservations` instead of `FROM kids` with a subquery. Do add filter conditions `FirstName = \"ROY\"` and `LastName = \"SWEAZY\"` instead of using a subquery with `guest_name = 'ROY SWEAZY'`. Do remove the `WHERE` clause with `room_id IN` subquery entirely instead of keeping the complex subquery structure. Do eliminate the unnecessary table `kids` and correlation logic instead of maintaining the multi-table approach. The amended query now directly retrieves the kids count from the Reservations table with proper name filtering, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM kids WHERE room_id IN (SELECT room_id FROM reservations WHERE guest_name = 'ROY SWEAZY')",
            "SELECT Kids FROM Reservations WHERE FirstName = 'ROY' AND LastName = 'SWEAZY';"
        ],
        "rule_sql": []
    },
    "172": {
        "db_id": "bike_1",
        "question": "What are the names of all stations that have more than 10 bikes available and are not located in San Jose?",
        "ground_truth": "SELECT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available)  >  10 EXCEPT SELECT name FROM station WHERE city  =  \"San Jose\"",
        "amends": [
            "Do add table `status AS T2` with a `JOIN` on `T1.id = T2.station_id` instead of querying only the `stations` table. Do change the aggregate condition to `HAVING avg(bikes_available) > 10` instead of the simple filter `bikes_available > 10` in the `WHERE` clause. Do add `GROUP BY T2.station_id` instead of omitting grouping. Do use `EXCEPT` to exclude `city = \"San Jose\"` records instead of the inequality filter `city != 'San Jose'`. Do reference the table as `station AS T1` instead of `stations`. The amended query now correctly calculates average bike availability per station and excludes San Jose stations using set operations instead of simple filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM stations WHERE bikes_available > 10 AND city != 'San Jose';",
            "SELECT T1.name\nFROM station AS T1\nJOIN status AS T2 ON T1.id = T2.station_id\nGROUP BY T2.station_id\nHAVING AVG(T2.bikes_available) > 10\nEXCEPT\nSELECT T1.name\nFROM station AS T1\nWHERE T1.city = 'San Jose'"
        ],
        "rule_sql": []
    },
    "5268": {
        "db_id": "music_2",
        "question": "What are all the songs in albums under label \"Universal Music Group\"?",
        "ground_truth": "SELECT T3.title FROM albums AS T1 JOIN tracklists AS T2 ON T1.aid  =  T2.albumid JOIN songs AS T3 ON T2.songid  =  T3.songid WHERE t1.label  =  \"Universal Music Group\"",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `s`, `a`, and `l`. Do select `T3.title` instead of `s.title`. Do change the FROM source to `albums AS T1` instead of starting with `songs s`. Do add an intermediate `tracklists AS T2` table instead of directly joining songs to albums. Do join on `T1.aid = T2.albumid` instead of `s.album_id = a.album_id`. Do join on `T2.songid = T3.songid` instead of the direct album-song relationship. Do filter on `t1.label = \"Universal Music Group\"` instead of `l.name = 'Universal Music Group'`. Do remove the labels table join entirely instead of including it. The amended query now correctly uses the tracklists bridge table to establish the proper relationship between albums and songs and filters directly on the album's label attribute."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.title \nFROM songs s\nJOIN albums a ON s.album_id = a.album_id\nJOIN labels l ON a.label_id = l.label_id\nWHERE l.name = 'Universal Music Group';",
            "SELECT T3.Title\nFROM Albums AS T1\nJOIN Tracklists AS T2 ON T1.AId = T2.AlbumId\nJOIN Songs AS T3 ON T2.SongId = T3.SongId\nWHERE T1.Label = 'Universal Music Group'"
        ],
        "rule_sql": []
    },
    "6357": {
        "db_id": "school_bus",
        "question": "Show the names of the drivers without a school bus.",
        "ground_truth": "SELECT name FROM driver WHERE driver_id NOT IN (SELECT driver_id FROM school_bus)",
        "amends": [
            "Do use table name `driver` instead of `drivers` in the FROM clause. Do change the WHERE condition to use a subquery with `driver_id NOT IN` instead of checking `school_bus_id IS NOT NULL`. Do remove the direct column reference to `school_bus_id` and instead use a correlated subquery that selects `driver_id` from the `school_bus` table. The amended query now correctly identifies drivers who are not assigned to any school bus by checking for absence in the school_bus table rather than relying on a potentially nullable foreign key column, ensuring the logic matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM drivers WHERE school_bus_id IS NOT NULL;",
            "SELECT Name FROM driver WHERE Driver_ID NOT IN (SELECT Driver_ID FROM school_bus)"
        ],
        "rule_sql": []
    },
    "2791": {
        "db_id": "election",
        "question": "Which party has the largest number of delegates?",
        "ground_truth": "SELECT T2.Party FROM election AS T1 JOIN party AS T2 ON T1.Party  =  T2.Party_ID GROUP BY T1.Party ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.Party` instead of `party` and `delegate_count`. Do use `FROM election AS T1 JOIN party AS T2` instead of `FROM delegates`. Do add join condition `ON T1.Party = T2.Party_ID` instead of omitting it. Do change grouping to `GROUP BY T1.Party` instead of `GROUP BY party`. Do order by `COUNT(*) DESC` instead of `delegate_count ASC`. The amended query now correctly joins election and party tables to find the party with the highest count of election records, matching the RIGHT_SQL's behavior.",
            "Do remove `COUNT(*) AS delegate_count` from the SELECT list instead of including it. Do keep `T2.Party` in the SELECT list instead of omitting it. The amended query now correctly returns only the party name with the highest delegate count rather than both the party name and count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT party, COUNT(*) as delegate_count FROM delegates GROUP BY party ORDER BY delegate_count ASC LIMIT 1;",
            "SELECT T2.Party, COUNT(*) AS delegate_count\nFROM election AS T1\nJOIN party AS T2 ON T1.Party = T2.Party_ID\nGROUP BY T1.Party\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT T2.Party FROM election AS T1 JOIN party AS T2 ON T1.Party = T2.Party_ID GROUP BY T1.Party ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "546": {
        "db_id": "store_1",
        "question": "What are the top 10 customers' first and last names by total number of orders and how many orders did they make?",
        "ground_truth": "SELECT T1.first_name ,  T1.last_name ,  COUNT(*) FROM customers AS T1 JOIN invoices AS T2 ON T2.customer_id  =  T1.id GROUP BY T1.id ORDER BY COUNT(*) DESC LIMIT 10;",
        "amends": [
            "Do add table alias `T1` for the `customers` table instead of omitting it. Do join with `invoices AS T2` on `T2.customer_id = T1.id` instead of querying only the `customers` table. Do use `COUNT(*)` instead of `COUNT(order_id)` to count all invoice records. Do group by `T1.id` instead of `customer_id` to ensure proper grouping with the joined table structure. Do order by `COUNT(*)` instead of the alias `total_orders` since the alias was removed. The amended query now correctly joins customer and invoice data to count orders per customer and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, COUNT(order_id) as total_orders\nFROM customers\nGROUP BY customer_id\nORDER BY total_orders DESC\nLIMIT 10;",
            "SELECT T1.first_name, T1.last_name, COUNT(*) AS order_count\nFROM customers AS T1\nJOIN invoices AS T2 ON T2.customer_id = T1.id\nGROUP BY T1.id\nORDER BY COUNT(*) DESC\nLIMIT 10"
        ],
        "rule_sql": []
    },
    "798": {
        "db_id": "coffee_shop",
        "question": "Which address do not have any member with the black membership card?",
        "ground_truth": "SELECT address FROM member EXCEPT SELECT address FROM member WHERE Membership_card  =  'Black'",
        "amends": [
            "Do use `EXCEPT` to exclude addresses from members with 'Black' membership cards instead of using `WHERE membership_card != 'black'` which would miss case variations. Do reference the table as `member` instead of `members` to match the correct schema. Do ensure proper case sensitivity by using `'Black'` instead of `'black'` to accurately filter membership cards. The amended query now correctly excludes addresses of members with Black membership cards regardless of case sensitivity issues, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address FROM members WHERE membership_card != 'black'",
            "SELECT DISTINCT Address FROM member\nEXCEPT\nSELECT DISTINCT Address FROM member WHERE Membership_card = 'Black';"
        ],
        "rule_sql": []
    },
    "5716": {
        "db_id": "dorm_1",
        "question": "List the first and last name of students who are not living in the city with code HKG, and sorted the results by their ages.",
        "ground_truth": "SELECT fname ,  lname FROM student WHERE city_code != 'HKG' ORDER BY age",
        "amends": [
            "Do use column names `fname` and `lname` instead of `first_name` and `last_name`. Do query from table `student` instead of `students`. Do order by `age` instead of `birth_date`. The amended query now matches the intended behavior with the correct table and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM students WHERE city_code != 'HKG' ORDER BY birth_date;",
            "SELECT Fname, LName FROM Student WHERE city_code != 'HKG' ORDER BY Age;"
        ],
        "rule_sql": []
    },
    "3243": {
        "db_id": "college_1",
        "question": "What is the first name of each student enrolled in class ACCT-211?",
        "ground_truth": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'",
        "amends": [
            "Do use explicit table aliases `T3.stu_fname` instead of ambiguous `first_name`. Do join three tables `CLASS AS T1`, `enroll AS T2`, and `student AS T3` instead of querying only `students`. Do use join conditions `T1.class_code = T2.class_code` and `T2.stu_num = T3.stu_num` instead of a simple filter. Do filter on `T1.crs_code = 'ACCT-211'` instead of `class = 'ACCT-211'`. Do remove `ORDER BY student_id LIMIT 1` instead of keeping the limiting clause. The amended query now correctly retrieves student first names by joining through enrollment and class tables using proper foreign key relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM students WHERE class = 'ACCT-211' ORDER BY student_id LIMIT 1;",
            "SELECT T3.stu_fname\nFROM CLASS AS T1\nJOIN enroll AS T2 ON T1.class_code = T2.class_code\nJOIN student AS T3 ON T2.stu_num = T3.stu_num\nWHERE T1.crs_code = 'ACCT-211'"
        ],
        "rule_sql": []
    },
    "6997": {
        "db_id": "culture_company",
        "question": "What are the titles of movies and books corresponding to companies incorporated in China?",
        "ground_truth": "SELECT T1.title ,  T3.book_title FROM movie AS T1 JOIN culture_company AS T2 ON T1.movie_id  =  T2.movie_id JOIN book_club AS T3 ON T3.book_club_id  =  T2.book_club_id WHERE T2.incorporated_in  =  'China'",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `m`, `b`, and `c`. Do select `T3.book_title` instead of `b.title`. Do join `culture_company AS T2` instead of `companies c`. Do use join condition `T1.movie_id = T2.movie_id` instead of `m.company_id = c.id`. Do join `book_club AS T3` instead of `books b`. Do use join condition `T3.book_club_id = T2.book_club_id` instead of `m.company_id = b.company_id`. Do filter on `T2.incorporated_in = 'China'` instead of `c.country = 'China'`. The amended query now correctly joins through the culture_company bridge table to connect movies with books via their respective IDs rather than incorrectly assuming direct company_id relationships, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT m.title, b.title \nFROM movies m\nJOIN books b ON m.company_id = b.company_id\nJOIN companies c ON m.company_id = c.id\nWHERE c.country = 'China';",
            "SELECT T1.Title AS movie_title, T3.Book_Title AS book_title\nFROM movie AS T1\nJOIN culture_company AS T2 ON T1.movie_id = T2.movie_id\nJOIN book_club AS T3 ON T3.book_club_id = T2.book_club_id\nWHERE T2.Incorporated_in = 'China'"
        ],
        "rule_sql": []
    },
    "1868": {
        "db_id": "wrestler",
        "question": "Show the reign and days held of wrestlers.",
        "ground_truth": "SELECT Reign ,  Days_held FROM wrestler",
        "amends": [
            "Do select `Reign` and `Days_held` instead of `name`, `reign`, and `days_held`. Do reference table `wrestler` instead of `wrestlers`. Do remove the `ORDER BY name` clause instead of keeping it. The amended query now correctly selects only the specified columns from the proper table without unnecessary ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, reign, days_held FROM wrestlers ORDER BY name;",
            "SELECT Reign, Days_held FROM wrestler"
        ],
        "rule_sql": []
    },
    "2195": {
        "db_id": "formula_1",
        "question": "Find the distinct driver id and the stop number of all drivers that have a shorter pit stop duration than some drivers in the race with id 841.",
        "ground_truth": "SELECT DISTINCT driverid ,  STOP FROM pitstops WHERE duration  <  (SELECT max(duration) FROM pitstops WHERE raceid  =  841)",
        "amends": [
            "Do use column name `driverid` instead of `driver_id`, and `STOP` instead of `stop_number`. Do reference table `pitstops` instead of `pit_stops`. Do remove the redundant `race_id = 841` filter from the WHERE clause instead of keeping it, since the subquery already filters by `raceid = 841`. Do use column name `raceid` in the subquery instead of `race_id`. Do maintain the same subquery logic comparing duration against the maximum duration for race 841. The amended query now correctly identifies drivers with pit stop durations below the maximum for race 841 while using the proper table and column names."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT driver_id, stop_number \nFROM pit_stops \nWHERE race_id = 841 \nAND duration < (SELECT MAX(duration) FROM pit_stops WHERE race_id = 841)",
            "SELECT DISTINCT driverId, stop\nFROM pitStops\nWHERE duration < (SELECT MAX(duration) FROM pitStops WHERE raceid = 841);"
        ],
        "rule_sql": []
    },
    "1021": {
        "db_id": "university_basketball",
        "question": "List names of all teams in the basketball competition, ordered by all home scores in descending order.",
        "ground_truth": "SELECT team_name FROM basketball_match ORDER BY All_Home DESC",
        "amends": [
            "Do reference the `basketball_match` table instead of the `teams` table. Do order by `All_Home` column instead of `home_score` column. The amended query now correctly retrieves team names ordered by the appropriate scoring metric from the correct table structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name FROM teams ORDER BY home_score DESC;",
            "SELECT Team_Name FROM basketball_match ORDER BY All_Home DESC;"
        ],
        "rule_sql": []
    },
    "5296": {
        "db_id": "manufactory_1",
        "question": "Find the name, headquarter and founder of the manufacturer that has the highest revenue.",
        "ground_truth": "SELECT name ,  headquarter ,  founder FROM manufacturers ORDER BY revenue DESC LIMIT 1",
        "amends": [
            "Do reference table `manufacturers` instead of `manufacturer` in the FROM clause, correcting the table name to match the actual schema. The amended query now correctly selects from the manufacturers table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, headquarter, founder FROM manufacturer ORDER BY revenue DESC LIMIT 1;",
            "SELECT Name, Headquarter, Founder FROM Manufacturers WHERE Revenue = (SELECT MAX(Revenue) FROM Manufacturers);"
        ],
        "rule_sql": []
    },
    "2536": {
        "db_id": "county_public_safety",
        "question": "List the distinct police forces of counties whose location is not on east side.",
        "ground_truth": "SELECT DISTINCT Police_force FROM county_public_safety WHERE LOCATION != \"East\"",
        "amends": [
            "Do reference the `Police_force` column instead of `police_force` to match the correct column name casing. Do query from the `county_public_safety` table instead of `counties` to use the correct data source. Do filter with `LOCATION != \"East\"` instead of `location != 'east'` to match the correct column name casing and string value. The amended query now correctly retrieves distinct police forces from the appropriate table with the proper filtering condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT police_force FROM counties WHERE location != 'east';",
            "SELECT DISTINCT Police_force FROM county_public_safety WHERE Location != 'East';"
        ],
        "rule_sql": []
    },
    "1907": {
        "db_id": "school_finance",
        "question": "Find the names of schools that have more than one donator with donation amount above 8.5.",
        "ground_truth": "SELECT T2.School_name FROM endowment AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id WHERE T1.amount  >  8.5 GROUP BY T1.school_id HAVING count(*)  >  1",
        "amends": [
            "Do select `T2.School_name` from the `school` table instead of `school_name` from the `donations` table. Do join `endowment AS T1` with `school AS T2` on `T1.school_id = T2.school_id` instead of querying only the `donations` table. Do filter on `T1.amount > 8.5` in the WHERE clause instead of `donation_amount > 8.5` without proper table qualification. Do group by `T1.school_id` instead of `school_name` to ensure proper aggregation. The amended query now correctly joins the endowment and school tables, uses qualified column references, and maintains the same aggregation logic to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT school_name FROM donations WHERE donation_amount > 8.5 GROUP BY school_name HAVING COUNT(*) > 1;",
            "SELECT T2.School_name\nFROM endowment AS T1\nJOIN School AS T2 ON T1.School_id = T2.School_id\nWHERE T1.amount > 8.5\nGROUP BY T1.School_id\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": []
    },
    "2824": {
        "db_id": "restaurant_1",
        "question": "What is the description of the restaurant type Sandwich?",
        "ground_truth": "SELECT ResTypeDescription FROM Restaurant_Type WHERE ResTypeName = \"Sandwich\";",
        "amends": [
            "Do use `ResTypeDescription` instead of `description` for the column selection. Do use `Restaurant_Type` instead of `restaurant_types` for the table name. Do use `ResTypeName` instead of `type` for the filter condition. Do use double quotes instead of single quotes around the string literal value. The amended query now correctly retrieves the restaurant type description for sandwich establishments using the proper schema structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM restaurant_types WHERE type = 'Sandwich';",
            "SELECT ResTypeDescription FROM Restaurant_Type WHERE ResTypeName = \"Sandwich\";"
        ],
        "rule_sql": []
    },
    "5868": {
        "db_id": "tracking_share_transactions",
        "question": "Show the average share count of transactions for different investors.",
        "ground_truth": "SELECT investor_id ,  avg(share_count) FROM TRANSACTIONS GROUP BY investor_id",
        "amends": [
            "Do use `avg(share_count)` instead of `AVG(share_price) as avg_share_count` to correctly calculate the average of the share_count column rather than the share_price column, and do remove the misleading alias `avg_share_count` instead of keeping it since the function now properly describes the calculation. The amended query now correctly calculates the average share count per investor instead of the average share price."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT investor_id, AVG(share_price) as avg_share_count FROM transactions GROUP BY investor_id;",
            "SELECT investor_id, AVG(share_count) FROM Transactions GROUP BY investor_id"
        ],
        "rule_sql": []
    },
    "5118": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "What is the payment method code used by the most orders?",
        "ground_truth": "SELECT payment_method_code FROM INVOICES GROUP BY payment_method_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do query the `INVOICES` table instead of the `orders` table. Do use `COUNT(*)` in the ORDER BY clause instead of aliasing it as `order_count` in the SELECT list. Do order by `COUNT(*) DESC` instead of `order_count ASC` to find the most frequent payment method rather than the least frequent. Do remove the explicit `COUNT(*)` column from the SELECT list instead of including it, as only the payment method code is needed. The amended query now correctly identifies the most frequently used payment method from the INVOICES table rather than the least frequent from the orders table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT payment_method_code, COUNT(*) as order_count FROM orders GROUP BY payment_method_code ORDER BY order_count ASC LIMIT 1;",
            "SELECT payment_method_code FROM Invoices GROUP BY payment_method_code ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4696": {
        "db_id": "college_3",
        "question": "What are the full names of students minoring in department 140?",
        "ground_truth": "SELECT T2.Fname ,  T2.Lname FROM MINOR_IN AS T1 JOIN STUDENT AS T2 ON T1.StuID  =  T2.StuID WHERE T1.DNO  =  140",
        "amends": [
            "Do select `T2.Fname` and `T2.Lname` instead of `first_name` and `last_name`. Do use a `JOIN` between `MINOR_IN AS T1` and `STUDENT AS T2` on `T1.StuID = T2.StuID` instead of querying only the `students` table. Do filter on `T1.DNO = 140` instead of `minor_department = 140`. The amended query now correctly joins the MINOR_IN and STUDENT tables to find students minoring in department 140, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM students WHERE minor_department = 140",
            "SELECT T2.Fname, T2.Lname FROM Minor_in AS T1 JOIN Student AS T2 ON T1.StuID = T2.StuID WHERE T1.DNO = 140"
        ],
        "rule_sql": []
    },
    "6341": {
        "db_id": "e_government",
        "question": "Return the party email that has used party services the greatest number of times.",
        "ground_truth": "SELECT t1.party_email FROM parties AS t1 JOIN party_services AS t2 ON t1.party_id  =  t2.customer_id GROUP BY t1.party_email ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `parties AS t1` with `party_services AS t2` on `t1.party_id = t2.customer_id` instead of querying only `party_services` without any join. Do select `t1.party_email` instead of `party_email` to ensure the column comes from the correct table. Do use `COUNT(*)` in the `ORDER BY` clause instead of referencing the alias `usage_count`. Do order by `count(*) DESC` instead of `usage_count ASC` to get the highest usage count rather than the lowest. Do remove the `usage_count` alias from the `SELECT` list instead of including it since it's not needed in the final output. The amended query now correctly identifies the party with the highest service usage by joining the parties table with party_services and ordering by descending count."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT party_email, COUNT(*) as usage_count FROM party_services GROUP BY party_email ORDER BY usage_count ASC LIMIT 1;",
            "SELECT t1.party_email\nFROM parties AS t1\nJOIN party_services AS t2 ON t1.party_id = t2.customer_id\nGROUP BY t1.party_id, t1.party_email\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "6804": {
        "db_id": "flight_4",
        "question": "What are the names of the airports in the city of Goroka?",
        "ground_truth": "SELECT name FROM airports WHERE city  =  'Goroka'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM airports WHERE city = 'Goroka';"
        ],
        "rule_sql": []
    },
    "5047": {
        "db_id": "soccer_2",
        "question": "How many states have a college with more students than average?",
        "ground_truth": "SELECT count(DISTINCT state) FROM college WHERE enr  >  (SELECT avg(enr) FROM college)",
        "amends": [
            "Do `count(DISTINCT state)` instead of `COUNT(*)` for the aggregate function. Do `college` instead of `colleges` for the table name. Do `enr` instead of `students` for the column name in both the WHERE filter and subquery. Do remove the asterisk wildcard instead of using it in the count function. The amended query now correctly counts distinct states where enrollment exceeds the average enrollment across all colleges."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM colleges WHERE students > (SELECT AVG(students) FROM colleges);",
            "SELECT COUNT(DISTINCT state) \nFROM College \nWHERE enr > (SELECT AVG(enr) FROM College)"
        ],
        "rule_sql": []
    },
    "5920": {
        "db_id": "cre_Theme_park",
        "question": "Find the names and descriptions of the photos taken at the tourist attraction called \"film festival\".",
        "ground_truth": "SELECT T1.Name ,  T1.Description FROM PHOTOS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID WHERE T2.Name  =  \"film festival\"",
        "amends": [
            "Do join `PHOTOS AS T1` with `TOURIST_ATTRACTIONS AS T2` instead of querying only the photos table. Do use the join condition `T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID` instead of filtering directly on the attraction column. Do filter on `T2.Name = \"film festival\"` instead of `attraction = 'film festival'` to properly reference the joined table. Do reference columns with table aliases `T1.Name` and `T1.Description` instead of bare column names for clarity. The amended query now correctly joins related tables and filters based on the tourist attraction name rather than assuming the photos table contains the attraction name directly."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, description FROM photos WHERE attraction = 'film festival';",
            "SELECT T1.Name, T1.Description \nFROM Photos AS T1 \nJOIN Tourist_Attractions AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID \nWHERE T2.Name = 'film festival'"
        ],
        "rule_sql": []
    },
    "4094": {
        "db_id": "student_1",
        "question": "Find the number of students in one classroom.",
        "ground_truth": "SELECT count(*) ,  classroom FROM list GROUP BY classroom",
        "amends": [
            "Do select `count(*)` and `classroom` instead of only `COUNT(*)`. Do use `FROM list` instead of `FROM students`. Do add `GROUP BY classroom` instead of omitting grouping. Do remove the `WHERE classroom_id = 1` filter instead of keeping it, as the right query aggregates across all classrooms rather than filtering to a specific one. The amended query now correctly counts records grouped by classroom rather than counting only classroom 1, matching the right SQL's behavior.",
            "Do place the `classroom` column after the aggregate function instead of before it in the SELECT list, maintaining the same logical grouping structure. Do keep the `COUNT(*)` aggregate function and `GROUP BY classroom` clause unchanged as they correctly calculate counts per classroom. The amended query now matches RIGHT_SQL's behavior by preserving the identical result set with only column ordering differences."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE classroom_id = 1;",
            "SELECT classroom, COUNT(*) FROM list GROUP BY classroom",
            "SELECT COUNT(*), classroom FROM list GROUP BY classroom"
        ],
        "rule_sql": []
    },
    "2604": {
        "db_id": "inn_1",
        "question": "Find the first and last names of people who payed more than the rooms' base prices.",
        "ground_truth": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  0",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do select `T1.firstname` and `T1.lastname` instead of `first_name` and `last_name`. Do use explicit `JOIN` syntax with `ON T1.Room = T2.RoomId` instead of a correlated subquery with `rooms.room_id = people.room_id`. Do filter with `T1.Rate - T2.basePrice > 0` instead of `payment > (SELECT base_price...)`. Do reference `Rate` and `basePrice` columns instead of `payment` and `base_price`. The amended query now correctly joins reservations and rooms tables and compares the rate difference directly instead of using a subquery, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM people WHERE payment > (SELECT base_price FROM rooms WHERE rooms.room_id = people.room_id);",
            "SELECT T1.FirstName, T1.LastName \nFROM Reservations T1\nJOIN Rooms T2 ON T1.Room = T2.RoomId\nWHERE T1.Rate - T2.basePrice > 0"
        ],
        "rule_sql": []
    },
    "4854": {
        "db_id": "local_govt_and_lot",
        "question": "Which organizations are not a parent organization of others? List the organization id.",
        "ground_truth": "SELECT organization_id FROM organizations EXCEPT SELECT parent_organization_id FROM organizations",
        "amends": [
            "Do use `EXCEPT` to find organization IDs that are not parent IDs instead of filtering for `parent_organization_id IS NULL`. Do select from the same table twice with different columns instead of a single filter condition. Do remove the `WHERE` clause entirely instead of keeping the null check. Do add a second query to exclude parent organization IDs instead of assuming null parent IDs indicate root organizations. The amended query now correctly identifies organizations that are not parent organizations of any other organization, matching the RIGHT_SQL's set difference behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT organization_id FROM organizations WHERE parent_organization_id IS NULL",
            "SELECT organization_id FROM Organizations\nEXCEPT\nSELECT parent_organization_id FROM Organizations WHERE parent_organization_id IS NOT NULL"
        ],
        "rule_sql": []
    },
    "5491": {
        "db_id": "voter_2",
        "question": "What is the average age of students who have city code \"NYC\" and have secretary votes for the spring election cycle?",
        "ground_truth": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  \"NYC\" AND T2.Election_Cycle  =  \"Spring\"",
        "amends": [
            "Do join `STUDENT AS T1` with `VOTING_RECORD AS T2` on `T1.StuID = SECRETARY_Vote` instead of querying only the `students` table without any join. Do reference the age column as `T1.Age` instead of just `age` and use table alias `T1` for clarity. Do filter on `T2.Election_Cycle = \"Spring\"` instead of `election_cycle = 'spring'` to use the correct table source and case sensitivity. Do remove the filter `secretary_votes > 0` from the WHERE clause instead of keeping it, as the join condition now properly handles the voting relationship. Do use double quotes around \"NYC\" and \"Spring\" instead of single quotes for string literals. The amended query now correctly joins the student and voting record tables to calculate the average age while properly filtering for NYC students in the spring election cycle, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age) FROM students WHERE city_code = 'NYC' AND secretary_votes > 0 AND election_cycle = 'spring';",
            "SELECT AVG(T1.Age) \nFROM Student AS T1\nJOIN Voting_record AS T2 ON T1.StuID = T2.Secretary_Vote\nWHERE T1.city_code = \"NYC\" AND T2.Election_Cycle = \"Spring\""
        ],
        "rule_sql": []
    },
    "4659": {
        "db_id": "college_3",
        "question": "List all information about courses sorted by credits in the ascending order.",
        "ground_truth": "SELECT * FROM COURSE ORDER BY Credits",
        "amends": [
            "Do reference table `COURSE` instead of `courses` to match the correct table name. Do order by `Credits` in ascending order instead of `credits DESC` to use the correct column name and default ascending sort instead of descending. Do maintain the `SELECT *` and absence of filtering clauses as they remain consistent between both queries. The amended query now correctly references the intended table with proper column naming and sorting direction to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM courses ORDER BY credits DESC;",
            "SELECT * FROM Course ORDER BY Credits ASC;"
        ],
        "rule_sql": []
    },
    "199": {
        "db_id": "bike_1",
        "question": "What are the dates in which the mean sea level pressure was between 30.3 and 31?",
        "ground_truth": "SELECT date FROM weather WHERE mean_sea_level_pressure_inches BETWEEN 30.3 AND 31",
        "amends": [
            "Do reference table `weather` instead of `weather_data`. Do use column `mean_sea_level_pressure_inches` instead of `mean_sea_level_pressure` for the pressure filter condition. The amended query now correctly filters pressure values in inches within the specified range."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT date FROM weather_data WHERE mean_sea_level_pressure BETWEEN 30.3 AND 31;",
            "SELECT date FROM weather WHERE mean_sea_level_pressure_inches BETWEEN 30.3 AND 31;"
        ],
        "rule_sql": []
    },
    "5544": {
        "db_id": "products_gen_characteristics",
        "question": "What is the color description of the product with name \"catnip\"?",
        "ground_truth": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code WHERE t1.product_name  =  \"catnip\"",
        "amends": [
            "Do select `t2.color_description` instead of `color`. Do add `JOIN ref_colors AS t2` instead of omitting this table. Do use join condition `ON t1.color_code = t2.color_code` instead of no join. Do filter on `t1.product_name = \"catnip\"` instead of `name = 'catnip'`. The amended query now correctly joins to the reference table to retrieve the color description rather than using a direct color field, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT color FROM products WHERE name = 'catnip';",
            "SELECT t2.color_description \nFROM Products AS t1 \nJOIN Ref_Colors AS t2 ON t1.color_code = t2.color_code \nWHERE t1.product_name = 'catnip'"
        ],
        "rule_sql": []
    },
    "1600": {
        "db_id": "customers_and_invoices",
        "question": "How many transactions correspond to each invoice number?",
        "ground_truth": "SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number",
        "amends": [
            "Do group by `invoice_number` instead of `transaction_id` to correctly aggregate counts per invoice. Do reference table `Financial_transactions` instead of `transactions` to use the correct data source. Do maintain the same `SELECT` list with `invoice_number` and `count(*)` but ensure the grouping aligns with the selected column. The amended query now correctly counts transactions per invoice number from the appropriate financial data table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT invoice_number, COUNT(*) FROM transactions GROUP BY transaction_id;",
            "SELECT invoice_number, COUNT(*) AS transaction_count FROM Financial_Transactions GROUP BY invoice_number;"
        ],
        "rule_sql": []
    },
    "4405": {
        "db_id": "network_2",
        "question": "How many different cities do people originate from?",
        "ground_truth": "SELECT count(DISTINCT city) FROM Person",
        "amends": [
            "Do select `count(DISTINCT city)` instead of `COUNT(*)` to count distinct cities rather than all rows. Do reference table `Person` instead of `people` to use the correct table name. The amended query now correctly counts distinct cities from the Person table instead of counting all rows from an incorrectly named table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM people;",
            "SELECT COUNT(DISTINCT city) FROM Person;"
        ],
        "rule_sql": []
    },
    "5264": {
        "db_id": "music_2",
        "question": "Find the name of songs that does not have a back vocal.",
        "ground_truth": "SELECT DISTINCT title FROM vocals AS t1 JOIN songs AS t2 ON t1.songid  =  t2.songid EXCEPT SELECT t2.title FROM vocals AS t1 JOIN songs AS t2 ON t1.songid  =  t2.songid WHERE TYPE  =  \"back\"",
        "amends": [
            "Do use `SELECT DISTINCT title` instead of `SELECT name` to retrieve unique song titles rather than names. Do join `vocals AS t1` with `songs AS t2` on `t1.songid = t2.songid` instead of querying only the `songs` table. Do add an `EXCEPT` operation to exclude songs with back vocals instead of filtering with `WHERE back_vocal = 'yes'`. Do include a subquery that selects `t2.title` from the joined tables where `TYPE = \"back\"` instead of the simple equality filter. Do completely restructure the query to use set operations for finding songs without back vocals instead of directly filtering for songs with back vocals. The amended query now correctly identifies songs that lack back vocals by using exception logic rather than incorrectly selecting songs that have them."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM songs WHERE back_vocal = 'yes';",
            "SELECT DISTINCT Title\nFROM Songs\nEXCEPT\nSELECT DISTINCT t2.Title\nFROM Vocals AS t1\nJOIN Songs AS t2 ON t1.SongId = t2.SongId\nWHERE t1.Type = 'back'"
        ],
        "rule_sql": []
    },
    "734": {
        "db_id": "customers_card_transactions",
        "question": "What are the different types of transactions?",
        "ground_truth": "SELECT DISTINCT transaction_type FROM Financial_Transactions",
        "amends": [
            "Do select only `transaction_type` instead of all columns with `*`. Do add `DISTINCT` instead of omitting it to return unique values. Do reference the correct table name `Financial_Transactions` instead of `transactions`. Do remove the `WHERE amount > 1000` filter instead of keeping it. The amended query now correctly returns distinct transaction types from the Financial_Transactions table as specified in the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM transactions WHERE amount > 1000;",
            "SELECT DISTINCT transaction_type FROM Financial_Transactions;"
        ],
        "rule_sql": []
    },
    "3941": {
        "db_id": "hospital_1",
        "question": "List the names of all the physicians who prescribe Thesisin as medication.",
        "ground_truth": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  \"Thesisin\"",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do change the source from `physicians` to `physician AS T1` instead of keeping the original table. Do add `JOIN prescribes AS T2 ON T1.employeeid = T2.physician` instead of no join. Do add `JOIN medication AS T3 ON T3.code = T2.medication` instead of no second join. Do change the filter from `medication = 'Thesisin'` to `T3.name = \"Thesisin\"` instead of filtering on the wrong column. Do change the column reference from `name` to `T1.name` instead of using an unqualified column. The amended query now correctly joins through the prescribes table to find physicians who prescribed the specific medication by name rather than incorrectly filtering directly on the physicians table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM physicians WHERE medication = 'Thesisin';",
            "SELECT DISTINCT T1.name\nFROM physician AS T1\nJOIN prescribes AS T2 ON T1.employeeid = T2.physician\nJOIN medication AS T3 ON T3.code = T2.medication\nWHERE T3.name = \"Thesisin\""
        ],
        "rule_sql": []
    },
    "1008": {
        "db_id": "university_basketball",
        "question": "Count the number of different affiliation types.",
        "ground_truth": "SELECT count(DISTINCT affiliation) FROM university",
        "amends": [
            "Do count `DISTINCT affiliation` instead of counting all rows with `COUNT(*)`. Do select from `university` table instead of from `affiliations` table. Do remove `GROUP BY type` instead of keeping it, as the distinct count should be performed across the entire table without grouping. The amended query now correctly counts unique affiliation values from the university table rather than grouping counts by type from the affiliations table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM affiliations GROUP BY type;",
            "SELECT COUNT(DISTINCT Affiliation) FROM university;"
        ],
        "rule_sql": []
    },
    "6009": {
        "db_id": "game_1",
        "question": "How many games are played for all football games by students on scholarship?",
        "ground_truth": "SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  \"Football\" AND onscholarship  =  'Y'",
        "amends": [
            "Do use `sum(gamesplayed)` instead of `COUNT(*)` to aggregate actual game counts rather than row counts. Do reference table `Sportsinfo` instead of `games` as the correct data source. Do filter on `sportname = \"Football\"` instead of `sport = 'football'` to match the correct column name and case-sensitive value. Do filter on `onscholarship = 'Y'` instead of `scholarship = 'yes'` to use the proper column name and abbreviated value format. The amended query now correctly calculates total games played for football scholarship athletes."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE sport = 'football' AND scholarship = 'yes';",
            "SELECT SUM(GamesPlayed) FROM SportsInfo WHERE SportName = 'Football' AND OnScholarship = 'Y'"
        ],
        "rule_sql": []
    },
    "1755": {
        "db_id": "gymnast",
        "question": "Return the total points of the gymnast with the lowest age.",
        "ground_truth": "SELECT T1.Total_Points FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID ORDER BY T2.Age ASC LIMIT 1",
        "amends": [
            "Do select `T1.Total_Points` instead of aggregating `SUM(points)` without grouping. Do join `gymnast AS T1` with `people AS T2` on `T1.Gymnast_ID = T2.People_ID` instead of querying only `gymnasts` table without joins. Do remove the `WHERE` filter on `age` and subquery for `MAX(age)` instead of using them. Do add `ORDER BY T2.Age ASC` instead of omitting ordering. Do add `LIMIT 1` instead of omitting row limiting. The amended query now correctly retrieves the youngest gymnast's points by joining tables and ordering by age rather than incorrectly aggregating all points for the maximum age."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(points) FROM gymnasts WHERE age = (SELECT MAX(age) FROM gymnasts);",
            "SELECT T1.Total_Points FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID = T2.People_ID ORDER BY T2.Age ASC LIMIT 1"
        ],
        "rule_sql": []
    },
    "659": {
        "db_id": "journal_committee",
        "question": "For each journal_committee, find the editor name and the journal theme.",
        "ground_truth": "SELECT T2.Name ,  T3.Theme FROM journal_committee AS T1 JOIN editor AS T2 ON T1.Editor_ID  =  T2.Editor_ID JOIN journal AS T3 ON T1.Journal_ID  =  T3.Journal_ID",
        "amends": [
            "Do add joins to `editor` and `journal` tables instead of selecting directly from `journal_committee` without proper relationships. Do use `T2.Name` instead of `editor_name` to reference the editor's name from the joined table. Do use `T3.Theme` instead of `journal_theme` to reference the journal theme from the joined table. Do add `JOIN editor AS T2 ON T1.Editor_ID = T2.Editor_ID` instead of omitting the editor table relationship. Do add `JOIN journal AS T3 ON T1.Journal_ID = T3.Journal_ID` instead of omitting the journal table relationship. Do use proper table aliases `T1`, `T2`, and `T3` instead of no aliases. The amended query now correctly joins the necessary tables to retrieve editor names and journal themes through their respective ID relationships, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT editor_name, journal_theme FROM journal_committee",
            "SELECT T2.Name, T3.Theme FROM journal_committee AS T1 JOIN editor AS T2 ON T1.Editor_ID = T2.Editor_ID JOIN journal AS T3 ON T1.Journal_ID = T3.Journal_ID"
        ],
        "rule_sql": []
    },
    "4052": {
        "db_id": "student_1",
        "question": "Find the last names of teachers teaching in classroom 109.",
        "ground_truth": "SELECT lastname FROM teachers WHERE classroom  =  109",
        "amends": [
            "Do select `lastname` instead of `first_name` in the SELECT list while keeping the same `WHERE classroom = 109` filter, maintaining the same table source and filtering condition but correcting the column selection to match the intended output."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM teachers WHERE classroom = 109;",
            "SELECT LastName FROM teachers WHERE Classroom = 109"
        ],
        "rule_sql": []
    },
    "261": {
        "db_id": "musical",
        "question": "How many musicals has each nominee been nominated for?",
        "ground_truth": "SELECT Nominee ,  COUNT(*) FROM musical GROUP BY Nominee",
        "amends": [
            "Do reference table `musical` instead of `nominations` and use column `Nominee` instead of `nominee` in both the SELECT list and GROUP BY clause instead of the lowercase version. The amended query now correctly queries the musical table with proper column casing."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT nominee, COUNT(*) FROM nominations GROUP BY nominee;",
            "SELECT Nominee, COUNT(*) AS Number_of_Nominations FROM musical GROUP BY Nominee;"
        ],
        "rule_sql": []
    },
    "6678": {
        "db_id": "driving_school",
        "question": "What is maximum, minimum and average amount of outstanding of customer?",
        "ground_truth": "SELECT max(amount_outstanding) ,  min(amount_outstanding) ,  avg(amount_outstanding) FROM Customers;",
        "amends": [
            "Do reference the correct column name `amount_outstanding` instead of the incorrect `outstanding` in all aggregate functions. Do use the proper table name `Customers` instead of `customers` to match the schema. The amended query now correctly calculates maximum, minimum, and average values from the amount_outstanding column in the Customers table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(outstanding), MIN(outstanding), AVG(outstanding) FROM customers",
            "SELECT MAX(amount_outstanding) AS max_outstanding, MIN(amount_outstanding) AS min_outstanding, AVG(amount_outstanding) AS avg_outstanding FROM Customers;"
        ],
        "rule_sql": []
    },
    "3451": {
        "db_id": "hr_1",
        "question": "Find the ids of the departments where any manager is managing 4 or more employees.",
        "ground_truth": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4",
        "amends": [
            "Do use `SELECT DISTINCT department_id` instead of `SELECT department_id` to eliminate duplicate department IDs. Do query from the `employees` table instead of the `departments` table as the primary data source. Do add `GROUP BY department_id, manager_id` instead of using a subquery with only `GROUP BY manager_id`. Do use `COUNT(employee_id)` instead of `COUNT(*)` to explicitly count employees. Do move the entire filtering logic to a single query with `HAVING COUNT(employee_id) >= 4` instead of using a subquery with `IN` clause. Do remove the WHERE clause and subquery structure entirely instead of maintaining the nested query approach. The amended query now correctly identifies departments where managers have at least 4 employees by grouping on both department and manager, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT department_id FROM departments WHERE manager_id IN (SELECT manager_id FROM employees GROUP BY manager_id HAVING COUNT(*) >= 4)",
            "SELECT DISTINCT department_id\nFROM employees\nGROUP BY department_id, manager_id\nHAVING COUNT(employee_id) >= 4"
        ],
        "rule_sql": []
    },
    "2166": {
        "db_id": "formula_1",
        "question": "What is the forename and surname of the driver with the shortest laptime?",
        "ground_truth": "SELECT T1.forename ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds LIMIT 1",
        "amends": [
            "Do add `JOIN laptimes AS T2 ON T1.driverid = T2.driverid` instead of querying only the `drivers` table. Do reference `T2.milliseconds` in the ORDER BY instead of `laptime` which doesn't exist. Do use table aliases `T1.forename` and `T1.surname` instead of unqualified column names. The amended query now correctly joins the laptimes table to find the driver with the fastest lap time based on milliseconds rather than attempting to order by a non-existent laptime column in the drivers table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT forename, surname FROM drivers ORDER BY laptime ASC LIMIT 1;",
            "SELECT T1.forename, T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverId = T2.driverId ORDER BY T2.milliseconds ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6273": {
        "db_id": "city_record",
        "question": "Which cities served as a host city after 2010?",
        "ground_truth": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city WHERE T2.year  >  2010",
        "amends": [
            "Do reference the `city` column as `T1.city` instead of just `city`. Do join `city AS T1` and `hosting_city AS T2` tables instead of querying only `host_cities`. Do use the join condition `T1.city_id = T2.host_city` instead of no join condition. Do filter on `T2.year > 2010` instead of `year > 2010`. The amended query now correctly retrieves cities by joining the appropriate tables and filtering on the hosting year."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM host_cities WHERE year > 2010;",
            "SELECT T1.City\nFROM city AS T1\nJOIN hosting_city AS T2 ON T1.City_ID = T2.Host_City\nWHERE T2.Year > 2010\nGROUP BY T1.City;"
        ],
        "rule_sql": []
    },
    "2936": {
        "db_id": "sakila_1",
        "question": "How many addresses are in the district of California?",
        "ground_truth": "SELECT count(*) FROM address WHERE district  =  'California'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM address WHERE district = 'California';"
        ],
        "rule_sql": []
    },
    "6715": {
        "db_id": "activity_1",
        "question": "How many faculty do we have?",
        "ground_truth": "SELECT count(*) FROM Faculty",
        "amends": [
            "Do query the `Faculty` table instead of the `students` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the Faculty table instead of the students table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;",
            "SELECT count(*) FROM Faculty;"
        ],
        "rule_sql": []
    },
    "4341": {
        "db_id": "tracking_grants_for_research",
        "question": "What are the task details, task ids, and project ids for the progrects that are detailed as 'omnis' or have at least 3 outcomes?",
        "ground_truth": "SELECT T1.task_details ,  T1.task_id ,  T2.project_id FROM Tasks AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id WHERE T2.project_details  =  'omnis' UNION SELECT T1.task_details ,  T1.task_id ,  T2.project_id FROM Tasks AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.project_id HAVING count(*)  >  2",
        "amends": [
            "Do add table `Projects AS T2` with `JOIN` on `T1.project_id = T2.project_id` instead of querying only `tasks` table. Do change filter to `T2.project_details = 'omnis'` instead of incorrect `project_details = 'omnis'` without table qualification. Do remove invalid `OR COUNT(outcomes) >= 3` in WHERE clause instead of keeping it, as aggregate functions cannot be used directly in WHERE. Do add second query with `UNION` that joins `Project_outcomes AS T3` on `T2.project_id = T3.project_id` instead of omitting this table. Do move count condition to `HAVING count(*) > 2` instead of incorrect WHERE usage, and do group by `T2.project_id` instead of no grouping. Do qualify all columns with table aliases `T1.task_details, T1.task_id, T2.project_id` instead of unqualified column references. The amended query now correctly handles both project details filtering and outcome counting through proper UNION and HAVING clauses."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT task_details, task_id, project_id FROM tasks WHERE project_details = 'omnis' OR COUNT(outcomes) >= 3",
            "SELECT T1.task_details, T1.task_id, T2.project_id\nFROM Tasks AS T1\nJOIN Projects AS T2 ON T1.project_id = T2.project_id\nWHERE T2.project_details = 'omnis'\n\nUNION\n\nSELECT T1.task_details, T1.task_id, T2.project_id\nFROM Tasks AS T1\nJOIN Projects AS T2 ON T1.project_id = T2.project_id\nJOIN Project_Outcomes AS T3 ON T2.project_id = T3.project_id\nGROUP BY T2.project_id\nHAVING COUNT(*) >= 3"
        ],
        "rule_sql": []
    },
    "2267": {
        "db_id": "entrepreneur",
        "question": "List the companies and the investors of entrepreneurs.",
        "ground_truth": "SELECT Company ,  Investor FROM entrepreneur",
        "amends": [
            "Do use table aliases `Company` and `Investor` instead of full column names `company_name` and `investor_name`. Do reference table `entrepreneur` instead of `entrepreneurs` and remove the JOIN clause entirely instead of including `JOIN investors ON entrepreneurs.id = investors.entrepreneur_id`. The amended query now correctly selects from a single table without unnecessary joins."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT company_name, investor_name FROM entrepreneurs JOIN investors ON entrepreneurs.id = investors.entrepreneur_id;",
            "SELECT Company, Investor FROM entrepreneur;"
        ],
        "rule_sql": []
    },
    "2491": {
        "db_id": "movie_1",
        "question": "What are the names of all directors who made one movie?",
        "ground_truth": "SELECT director FROM Movie GROUP BY director HAVING count(*)  =  1",
        "amends": [
            "Do use `director` instead of `name` as the column name and `Movie` instead of `directors` as the table source. Do use `GROUP BY director` with `HAVING count(*) = 1` instead of `WHERE COUNT(movies) = 1` to properly filter aggregated results after grouping rather than attempting to use an aggregate function in a WHERE clause, which is invalid syntax. Do remove the incorrect `COUNT(movies)` expression and replace it with the valid `count(*)` aggregate function in the HAVING clause. The amended query now correctly identifies directors with exactly one movie by using proper grouping and aggregation syntax."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM directors WHERE COUNT(movies) = 1;",
            "SELECT director FROM Movie GROUP BY director HAVING COUNT(*) = 1"
        ],
        "rule_sql": []
    },
    "5642": {
        "db_id": "railway",
        "question": "Show id and location of railways that are associated with more than one train.",
        "ground_truth": "SELECT T2.Railway_ID ,  T1.Location FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID HAVING COUNT(*)  >  1",
        "amends": [
            "Do select `T2.Railway_ID` and `T1.Location` instead of `id` and `location`. Do join `railway AS T1` with `train AS T2` on `T1.Railway_ID = T2.Railway_ID` instead of querying only the `railways` table. Do add `GROUP BY T2.Railway_ID` instead of omitting grouping. Do move the count filter to `HAVING COUNT(*) > 1` instead of using `WHERE train_count > 1`. The amended query now correctly counts trains per railway and filters for railways with multiple trains, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, location FROM railways WHERE train_count > 1;",
            "SELECT T1.Railway_ID, T1.Location\nFROM railway AS T1\nJOIN train AS T2 ON T1.Railway_ID = T2.Railway_ID\nGROUP BY T2.Railway_ID\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": []
    },
    "3570": {
        "db_id": "music_1",
        "question": "What are the different names for all songs that have a higher resolution than English songs?",
        "ground_truth": "SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  \"english\")",
        "amends": [
            "Do select `song_name` instead of `name` and add `DISTINCT` instead of omitting it. Do reference table `song` instead of `songs` and use column `languages` instead of `language`. Do use `min(resolution)` in the subquery instead of plain `resolution` to compare against the minimum value rather than any arbitrary value. Do use double quotes around `\"english\"` instead of single quotes around `'English'` for string literal consistency. The amended query now correctly finds distinct song names where resolution exceeds the minimum resolution of English-language songs."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM songs WHERE resolution > (SELECT resolution FROM songs WHERE language = 'English')",
            "SELECT DISTINCT song_name FROM song WHERE resolution > (SELECT MIN(resolution) FROM song WHERE languages = \"english\")"
        ],
        "rule_sql": []
    },
    "1352": {
        "db_id": "college_2",
        "question": "Find the total budgets of the Marketing or Finance department.",
        "ground_truth": "SELECT sum(budget) FROM department WHERE dept_name  =  'Marketing' OR dept_name  =  'Finance'",
        "amends": [
            "Do reference table `department` instead of `departments` and use column `dept_name` instead of `department_name` while keeping the same filter logic with `OR` conditions for 'Marketing' and 'Finance'. Do use lowercase `sum(budget)` instead of `SUM(budget)` while maintaining the same aggregation function. The amended query now correctly references the actual table and column names while preserving the intended filtering and aggregation behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(budget) FROM departments WHERE department_name = 'Marketing' OR department_name = 'Finance';",
            "SELECT sum(budget) FROM department WHERE dept_name = 'Marketing' OR dept_name = 'Finance'"
        ],
        "rule_sql": []
    },
    "4882": {
        "db_id": "school_player",
        "question": "Show the denomination of the school that has the most players.",
        "ground_truth": "SELECT T2.Denomination FROM player AS T1 JOIN school AS T2 ON T1.School_ID  =  T2.School_ID GROUP BY T1.School_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do add `JOIN school AS T2 ON T1.School_ID = T2.School_ID` instead of querying `schools` table directly. Do change the FROM clause to use `player AS T1` instead of missing the player table entirely. Do add `GROUP BY T1.School_ID` instead of omitting grouping. Do change the ORDER BY to use `COUNT(*)` instead of `COUNT(players.id)` which references a non-existent table alias. Do change the SELECT list to use `T2.Denomination` instead of `denomination` without proper table qualification. The amended query now correctly joins player and school tables, groups by school ID to count players per school, and returns the school denomination with the highest player count, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT denomination FROM schools ORDER BY COUNT(players.id) DESC LIMIT 1;",
            "SELECT T2.Denomination \nFROM player AS T1 \nJOIN school AS T2 ON T1.School_ID = T2.School_ID \nGROUP BY T1.School_ID \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "4056": {
        "db_id": "student_1",
        "question": "Report the first name and last name of all the students.",
        "ground_truth": "SELECT DISTINCT firstname ,  lastname FROM list",
        "amends": [
            "Do select `firstname` and `lastname` instead of just `first_name`. Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do source from table `list` instead of `students`. The amended query now correctly retrieves unique combinations of first and last names from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM students;",
            "SELECT DISTINCT FirstName, LastName FROM list;"
        ],
        "rule_sql": []
    },
    "3535": {
        "db_id": "music_1",
        "question": "What are the id of songs whose format is mp3.",
        "ground_truth": "SELECT f_id FROM files WHERE formats  =  \"mp3\"",
        "amends": [
            "Do select `f_id` from the `files` table instead of `id` from `songs`. Do filter on `formats = \"mp3\"` instead of `format = 'mp4'` to query the correct column with the proper value and single quotes. The amended query now correctly retrieves file identifiers for MP3 format files instead of song identifiers for MP4 format."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM songs WHERE format = 'mp4';",
            "SELECT f_id FROM files WHERE formats = 'mp3'"
        ],
        "rule_sql": []
    },
    "3978": {
        "db_id": "hospital_1",
        "question": "Find the names of procedures which physician John Wen was trained in.",
        "ground_truth": "SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  \"John Wen\"",
        "amends": [
            "Do reference the procedures table as `T3` instead of `p` and select `T3.name` instead of `p.name`. Do join `physician AS T1` instead of `physicians ph` and use `T1.employeeid = T2.physician` instead of `t.physician = ph.employeeid`. Do join `procedures AS T3` with `T3.code = T2.treatment` instead of `p.code = t.procedure`. Do use double quotes for the string comparison `\"John Wen\"` instead of single quotes. The amended query now correctly retrieves procedure names for physicians named John Wen by properly joining through the trained_in relationship with accurate column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.name \nFROM procedures p\nJOIN trained_in t ON p.code = t.procedure\nJOIN physicians ph ON t.physician = ph.employeeid\nWHERE ph.name = 'John Wen';",
            "SELECT T3.Name \nFROM Physician AS T1\nJOIN Trained_In AS T2 ON T1.EmployeeID = T2.Physician\nJOIN Procedures AS T3 ON T3.Code = T2.Treatment\nWHERE T1.Name = \"John Wen\""
        ],
        "rule_sql": []
    },
    "4710": {
        "db_id": "department_store",
        "question": "Give the ids of the three products purchased in the largest amounts.",
        "ground_truth": "SELECT product_id FROM product_suppliers ORDER BY total_amount_purchased DESC LIMIT 3",
        "amends": [
            "Do query the `product_suppliers` table instead of the `purchases` table. Do order by `total_amount_purchased` instead of `amount`. The amended query now correctly retrieves the top 3 product IDs based on total purchase amounts from the supplier data rather than individual purchase records."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_id FROM purchases ORDER BY amount DESC LIMIT 3;",
            "SELECT product_id FROM Product_Suppliers ORDER BY CAST(total_amount_purchased AS INTEGER) DESC LIMIT 3;"
        ],
        "rule_sql": []
    },
    "5092": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "List the order dates of all the bookings.",
        "ground_truth": "SELECT Order_Date FROM BOOKINGS",
        "amends": [
            "Do use the column alias `Order_Date` instead of `booking_date` to match the correct column name. Do maintain the same table source `BOOKINGS` without any changes to the FROM clause. The amended query now correctly selects the intended date column and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT booking_date FROM bookings;",
            "SELECT Order_Date FROM Bookings;"
        ],
        "rule_sql": []
    },
    "5547": {
        "db_id": "products_gen_characteristics",
        "question": "Return the color code and description for the product with the name 'chervil'.",
        "ground_truth": "SELECT t1.color_code ,  t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code WHERE t1.product_name  =  \"chervil\"",
        "amends": [
            "Do select `t1.color_code` and `t2.color_description` instead of `color` and `description`. Do join `ref_colors AS t2` instead of querying only the `products` table. Do use `ON t1.color_code = t2.color_code` to establish the join relationship instead of missing this table connection. Do filter on `t1.product_name = \"chervil\"` instead of `name = 'chervil'` to use the correct column name and table alias. The amended query now correctly joins the reference table to retrieve color descriptions and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT color, description FROM products WHERE name = 'chervil';",
            "SELECT t1.color_code, t2.color_description \nFROM Products AS t1 \nJOIN Ref_Colors AS t2 ON t1.color_code = t2.color_code \nWHERE t1.product_name = 'chervil'"
        ],
        "rule_sql": []
    },
    "6372": {
        "db_id": "flight_company",
        "question": "What are the names of the airports which are not in the country 'Iceland'?",
        "ground_truth": "SELECT name FROM airport WHERE country != 'Iceland'",
        "amends": [
            "Do reference table `airport` instead of `airports` and use inequality filter `country != 'Iceland'` instead of equality filter `country = 'Iceland'`."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM airports WHERE country = 'Iceland';",
            "SELECT name FROM airport WHERE Country != 'Iceland';"
        ],
        "rule_sql": []
    },
    "1853": {
        "db_id": "wrestler",
        "question": "Give the names and locations of all wrestlers.",
        "ground_truth": "SELECT Name ,  LOCATION FROM wrestler",
        "amends": [
            "Do use table name `wrestler` instead of `wrestlers` and capitalize column names `Name` and `LOCATION` instead of lowercase `name` and `location`, while maintaining the same `WHERE weight > 200` filter. The amended query now correctly references the actual table schema with proper column casing.",
            "Do use consistent column name casing `LOCATION` instead of mixed case `Location` while maintaining the same semantic meaning. The query structure remains identical with the same `SELECT` list columns `Name` and `LOCATION`, same `FROM` source `wrestler`, and same `WHERE` filter `weight > 200`. The amended query now matches the right SQL's behavior with only cosmetic formatting differences addressed.",
            "Do use consistent column name casing with `LOCATION` instead of `Location` to match the actual column name in the database schema. The amended query now correctly retrieves all wrestlers without any weight filter, matching the intended behavior of the right SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, location FROM wrestlers WHERE weight > 200;",
            "SELECT Name, Location FROM wrestler WHERE weight > 200",
            "SELECT Name, Location FROM wrestler WHERE weight > 200",
            "SELECT Name, Location FROM wrestler"
        ],
        "rule_sql": []
    },
    "2776": {
        "db_id": "election",
        "question": "Show the name of each party and the corresponding number of delegates from that party.",
        "ground_truth": "SELECT T2.Party ,  COUNT(*) FROM election AS T1 JOIN party AS T2 ON T1.Party  =  T2.Party_ID GROUP BY T1.Party",
        "amends": [
            "Do join `election AS T1` with `party AS T2` on `T1.Party = T2.Party_ID` instead of querying only the `delegates` table. Do select `T2.Party` instead of `party_name` as the party identifier. Do group by `T1.Party` instead of `party_name` to ensure proper aggregation alignment with the joined tables. The amended query now correctly matches the RIGHT_SQL's behavior by properly relating election data to party information through the appropriate join condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT party_name, COUNT(*) FROM delegates GROUP BY party_name;",
            "SELECT T2.Party, COUNT(T1.Delegate) AS Number_of_Delegates FROM election AS T1 JOIN party AS T2 ON T1.Party = T2.Party_ID GROUP BY T1.Party"
        ],
        "rule_sql": []
    },
    "3418": {
        "db_id": "hr_1",
        "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?",
        "ground_truth": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'",
        "amends": [
            "Do use `NOT LIKE` in the WHERE filter instead of `LIKE` to exclude names containing 'M' instead of including them. The amended query now correctly matches the RIGHT_SQL's behavior by filtering out employees whose first names contain the letter 'M'.",
            "Do use separate columns `first_name` and `last_name` instead of concatenating them with `FIRST_NAME || ' ' || LAST_NAME AS full_name`. Do maintain the original column names `first_name`, `last_name`, `hire_date`, `salary`, and `department_id` instead of using uppercase aliases. The amended query now correctly preserves individual name components while maintaining the same filtering logic with `first_name NOT LIKE '%M%'` and matches the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, hire_date, salary, department_id FROM employees WHERE first_name LIKE '%M%';",
            "SELECT FIRST_NAME || ' ' || LAST_NAME AS full_name, HIRE_DATE, SALARY, DEPARTMENT_ID FROM employees WHERE FIRST_NAME NOT LIKE '%M%'",
            "SELECT first_name, last_name, hire_date, salary, department_id FROM employees WHERE first_name NOT LIKE '%M%'"
        ],
        "rule_sql": []
    },
    "3695": {
        "db_id": "baseball_1",
        "question": "How much did the the player with first name Len and last name Barker earn between 1985 to 1990 in total?",
        "ground_truth": "SELECT sum(T1.salary) FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id WHERE T2.name_first  =  'Len' AND T2.name_last = 'Barker' AND T1.year BETWEEN 1985 AND 1990;",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of no aliases. Do join `salary AS T1` with `player AS T2` on `T1.player_id = T2.player_id` instead of using a subquery with `IN`. Do reference `T1.salary` and `T1.year` instead of unqualified `salary` and `yearID`. Do use column names `name_first` and `name_last` instead of `first_name` and `last_name`. Do filter on `T1.year BETWEEN 1985 AND 1990` instead of `yearID BETWEEN 1985 AND 1990`. The amended query now correctly joins the tables and uses the proper column names to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(salary) FROM salaries WHERE playerID IN (SELECT playerID FROM players WHERE first_name = 'Len' AND last_name = 'Barker') AND yearID BETWEEN 1985 AND 1990",
            "SELECT SUM(T1.salary) AS total_earnings\nFROM salary AS T1\nJOIN player AS T2 ON T1.player_id = T2.player_id\nWHERE T2.name_first = 'Len' \nAND T2.name_last = 'Barker'\nAND T1.year BETWEEN 1985 AND 1990"
        ],
        "rule_sql": []
    },
    "1826": {
        "db_id": "browser_web",
        "question": "How many main stream browsers whose market share is at least 5 exist?",
        "ground_truth": "SELECT count(*) FROM browser WHERE market_share  >=  5",
        "amends": [
            "Do reference table `browser` instead of `browsers` in the FROM clause. Do use `>=` comparison operator instead of `>` for the `market_share` filter to include records with exactly 5% market share. Do remove the `type = 'main_stream'` filter condition instead of keeping it, as the right query counts all browsers with market share of 5% or higher regardless of type. The amended query now correctly counts all records from the browser table where market_share is greater than or equal to 5, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM browsers WHERE market_share > 5 AND type = 'main_stream';",
            "SELECT COUNT(*) FROM browser WHERE market_share >= 5"
        ],
        "rule_sql": []
    },
    "4871": {
        "db_id": "school_player",
        "question": "Find the team of each player and sort them in ascending alphabetical order.",
        "ground_truth": "SELECT Team FROM player ORDER BY Team ASC",
        "amends": [
            "Do select `Team` instead of `player_name, team_name`. Do reference table `player` instead of `players`. Do order by `Team ASC` instead of `player_name DESC`."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name, team_name FROM players ORDER BY player_name DESC;",
            "SELECT Team FROM player ORDER BY Team ASC;"
        ],
        "rule_sql": []
    },
    "4545": {
        "db_id": "company_office",
        "question": "List the names of companies in descending order of market value.",
        "ground_truth": "SELECT name FROM Companies ORDER BY Market_Value_billion DESC",
        "amends": [
            "Do reference the table as `Companies` instead of `companies` to match the correct case sensitivity. Do order by `Market_Value_billion` instead of `market_value` to use the correct column name. Do use `DESC` ordering instead of `ASC` to sort in descending order rather than ascending. The amended query now correctly selects company names ordered by market value in descending order from the Companies table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM companies ORDER BY market_value ASC;",
            "SELECT name FROM Companies ORDER BY Market_Value_billion DESC;"
        ],
        "rule_sql": []
    },
    "2678": {
        "db_id": "party_host",
        "question": "Show the themes of parties and the names of the party hosts.",
        "ground_truth": "SELECT T3.Party_Theme ,  T2.Name FROM party_host AS T1 JOIN HOST AS T2 ON T1.Host_ID  =  T2.Host_ID JOIN party AS T3 ON T1.Party_ID  =  T3.Party_ID",
        "amends": [
            "Do use table aliases `T2` and `T3` instead of direct table names, and select `T2.Name` instead of `host_name`. Do join through junction table `party_host AS T1` instead of directly joining `parties` to `hosts`, using `T1.Host_ID = T2.Host_ID` instead of `parties.host_id = hosts.id`. Do add a second join to `party AS T3` on `T1.Party_ID = T3.Party_ID` instead of omitting it, and select `T3.Party_Theme` instead of `party_theme`. The amended query now correctly uses the many-to-many relationship structure through the junction table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT party_theme, host_name FROM parties JOIN hosts ON parties.host_id = hosts.id;",
            "SELECT T3.Party_Theme, T2.Name\nFROM party_host AS T1\nJOIN host AS T2 ON T1.Host_ID = T2.Host_ID\nJOIN party AS T3 ON T1.Party_ID = T3.Party_ID;"
        ],
        "rule_sql": []
    },
    "4318": {
        "db_id": "club_1",
        "question": "Retrieve the average age of members of the club \"Tennis Club\".",
        "ground_truth": "SELECT avg(t3.age) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Tennis Club\"",
        "amends": [
            "Do use explicit table joins with `club AS t1 JOIN member_of_club AS t2 ON t1.clubid = t2.clubid JOIN student AS t3 ON t2.stuid = t3.stuid` instead of querying a single `members` table. Do reference the age column with its table alias as `t3.age` instead of just `age`. Do filter on the correct column name `t1.clubname = \"Tennis Club\"` instead of `club_name = 'Tennis Club'`. Do use double quotes for string literals instead of single quotes. The amended query now correctly joins the three related tables to calculate average age of students in the Tennis Club, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age) FROM members WHERE club_name = 'Tennis Club';",
            "SELECT AVG(t3.age) AS average_age\nFROM club AS t1 \nJOIN member_of_club AS t2 ON t1.ClubID = t2.ClubID\nJOIN student AS t3 ON t2.StuID = t3.StuID\nWHERE t1.ClubName = \"Tennis Club\""
        ],
        "rule_sql": []
    },
    "2504": {
        "db_id": "movie_1",
        "question": "Find the title and star rating of the movie that got the least rating star for each reviewer.",
        "ground_truth": "SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference columns `T2.title`, `T1.rID`, and `T1.stars` instead of `reviewer_name`, `title`, and `rating`. Do use `min(T1.stars)` instead of `MAX(rating) as star_rating`. Do join `Rating AS T1` with `Movie AS T2` on `T1.mID = T2.mID` instead of joining `movies` with `reviews` on `movies.movie_id = reviews.movie_id` and then with `reviewers` on `reviews.reviewer_id = reviewers.reviewer_id`. Do group by `T1.rID` instead of `reviewer_name`. Do remove the `reviewer_name` column from the SELECT list instead of including it. The amended query now correctly retrieves movie titles with minimum star ratings grouped by reviewer ID.",
            "Do add `T1.rID` and `min(T1.stars)` to the SELECT list instead of omitting them, and do remove `T2.title` from the SELECT list instead of keeping it. Do change the FROM clause to use a simple JOIN without the subquery instead of using a WHERE clause with a subquery that checks for minimum stars. Do add GROUP BY T1.rID instead of omitting grouping, and do remove the WHERE filter with the subquery instead of keeping it. The amended query now correctly aggregates minimum stars by rID without the incorrect subquery logic that was filtering for minimum star ratings.",
            "Do include `T2.title`, `T1.rID`, and `T1.stars` in the SELECT list instead of only `T1.rID`, `T2.title`, and `MIN(T1.stars)`. Do add the raw `T1.stars` column to the output instead of omitting it, while keeping the `MIN(T1.stars)` aggregate function. The GROUP BY clause remains unchanged on `T1.rID`, but the amended query now includes both individual star ratings and the minimum star rating per reviewer, matching the RIGHT_SQL's behavior.",
            "Do include `T2.title` in the SELECT list instead of omitting it, and do reorder the columns as `T2.title, T1.rID, T1.stars, min(T1.stars)` instead of `T1.rID, T2.title, T1.stars, MIN(T1.stars)`. The amended query now correctly includes all necessary columns in the SELECT list while maintaining proper grouping semantics."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT reviewer_name, title, MAX(rating) as star_rating\nFROM movies\nJOIN reviews ON movies.movie_id = reviews.movie_id\nJOIN reviewers ON reviews.reviewer_id = reviewers.reviewer_id\nGROUP BY reviewer_name;",
            "SELECT T2.title, T1.stars\nFROM Rating AS T1\nJOIN Movie AS T2 ON T1.mID = T2.mID\nWHERE (T1.rID, T1.stars) IN (\n    SELECT rID, MIN(stars)\n    FROM Rating\n    GROUP BY rID\n)",
            "SELECT T1.rID, T2.title, MIN(T1.stars) AS star_rating\nFROM Rating AS T1\nJOIN Movie AS T2 ON T1.mID = T2.mID\nGROUP BY T1.rID",
            "SELECT T1.rID, T2.title, T1.stars, MIN(T1.stars) \nFROM Rating AS T1 \nJOIN Movie AS T2 ON T1.mID = T2.mID \nGROUP BY T1.rID",
            "SELECT T2.title, T1.rID, T1.stars, min(T1.stars) \nFROM Rating AS T1 \nJOIN Movie AS T2 ON T1.mID = T2.mID \nGROUP BY T1.rID"
        ],
        "rule_sql": []
    },
    "5604": {
        "db_id": "swimming",
        "question": "What is the name of the event that happened in the most recent year?",
        "ground_truth": "SELECT name FROM event ORDER BY YEAR DESC LIMIT 1",
        "amends": [
            "Do reference table `event` instead of `events` to correctly target the intended data source. The amended query now matches RIGHT_SQL's behavior by using the proper table name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM events ORDER BY year DESC LIMIT 1;",
            "SELECT Name FROM event ORDER BY Year DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5892": {
        "db_id": "cre_Theme_park",
        "question": "What is the name and detail of each staff member?",
        "ground_truth": "SELECT Name ,  Other_Details FROM Staff",
        "amends": [
            "Do select `Name` and `Other_Details` instead of `name` and `detail`. Do query from `Staff` table instead of `staff_members` table. Do use proper column names and table name that match the actual database schema, ensuring the query correctly retrieves the intended data from the right source table with the appropriate field names. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, detail FROM staff_members WHERE id = 1;",
            "SELECT Name, Other_Details FROM Staff;"
        ],
        "rule_sql": []
    },
    "4996": {
        "db_id": "soccer_2",
        "question": "Find the states where have some college students in tryout and their decisions are yes.",
        "ground_truth": "SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'",
        "amends": [
            "Do use `DISTINCT T1.state` instead of `state` to eliminate duplicates. Do join `college AS T1` with `tryout AS T2` on `T1.cName = T2.cName` instead of querying `students` table alone. Do filter on `T2.decision = 'yes'` instead of both `decision = 'yes'` and `tryout_status = 'college'`. Do remove the incorrect `tryout_status = 'college'` filter instead of keeping it. The amended query now correctly retrieves distinct states from colleges where tryout decisions are positive, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT state FROM students WHERE decision = 'yes' AND tryout_status = 'college'",
            "SELECT DISTINCT T1.state FROM College AS T1 JOIN Tryout AS T2 ON T1.cName = T2.cName WHERE T2.decision = 'yes'"
        ],
        "rule_sql": []
    },
    "5437": {
        "db_id": "shop_membership",
        "question": "How many total pounds were purchased in the year 2018 at all London branches?",
        "ground_truth": "SELECT sum(total_pounds) FROM purchase AS T1 JOIN branch AS T2 ON T1.branch_id  =  T2.branch_id WHERE T2.city  =  'London' AND T1.year  =  2018",
        "amends": [
            "Do select `sum(total_pounds)` instead of `SUM(quantity)` to aggregate the correct monetary value. Do join `purchase AS T1` with `branch AS T2` on `T1.branch_id = T2.branch_id` instead of querying a single table, enabling proper branch-city relationship resolution. Do filter on `T2.city = 'London'` instead of `branch_city = 'London'` to use the correct table and column reference from the joined branch table. Do maintain the `T1.year = 2018` filter but with proper table qualification instead of the unqualified `year = 2018`. The amended query now correctly aggregates total pounds from London branches in 2018 by properly joining the purchase and branch tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(quantity) FROM purchases WHERE year = 2018 AND branch_city = 'London';",
            "SELECT SUM(T1.Total_pounds) \nFROM purchase AS T1\nJOIN branch AS T2 ON T1.Branch_ID = T2.Branch_ID\nWHERE T2.City = 'London' AND T1.Year = '2018'"
        ],
        "rule_sql": []
    },
    "4250": {
        "db_id": "club_1",
        "question": "How many clubs are there?",
        "ground_truth": "SELECT count(*) FROM club",
        "amends": [
            "Do reference the `club` table directly in the FROM clause instead of querying the `players` table with a WHERE filter on `position = 'club'`. Do remove the incorrect WHERE condition `position = 'club'` instead of keeping it, as the right query simply counts all records from the club table without any filtering. The amended query now correctly counts all rows from the club table instead of attempting to filter players by position, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE position = 'club';",
            "SELECT COUNT(*) FROM Club;"
        ],
        "rule_sql": []
    },
    "2317": {
        "db_id": "perpetrator",
        "question": "What are the countries that have at least two perpetrators?",
        "ground_truth": "SELECT Country ,  COUNT(*) FROM perpetrator GROUP BY Country HAVING COUNT(*)  >=  2",
        "amends": [
            "Do reference table `perpetrator` instead of `perpetrators` and use column `Country` instead of `country` to match the correct schema. Do change the HAVING condition to `>= 2` instead of `> 1` to properly filter for counts of two or more instead of just greater than one. The amended query now correctly counts perpetrators by country and filters for countries with at least two occurrences.",
            "Do add `COUNT(*)` to the SELECT list instead of omitting it, and do use `COUNT(*)` in the HAVING clause instead of `COUNT(Perpetrator_ID)` to count all rows per group rather than just non-null Perpetrator_ID values. The amended query now correctly returns both country names and their corresponding counts for groups with at least two records, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) FROM perpetrators GROUP BY country HAVING COUNT(*) > 1",
            "SELECT Country FROM perpetrator GROUP BY Country HAVING COUNT(Perpetrator_ID) >= 2",
            "SELECT Country, COUNT(*) FROM perpetrator GROUP BY Country HAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "4948": {
        "db_id": "soccer_2",
        "question": "How many colleges in total?",
        "ground_truth": "SELECT count(*) FROM College",
        "amends": [
            "Do query the `College` table instead of the `students` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the College table instead of the students table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;",
            "SELECT count(*) FROM College;"
        ],
        "rule_sql": []
    },
    "4664": {
        "db_id": "college_3",
        "question": "What are the first names of students, ordered by age from greatest to least?",
        "ground_truth": "SELECT Fname FROM STUDENT ORDER BY Age DESC",
        "amends": [
            "Do use column name `Fname` instead of `first_name` and table name `STUDENT` instead of `students`. Do change the sort direction to `DESC` instead of `ASC` and use column name `Age` instead of `age`. The amended query now correctly references the schema elements and ordering direction to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM students ORDER BY age ASC;",
            "SELECT Fname FROM Student ORDER BY Age DESC;"
        ],
        "rule_sql": []
    },
    "5380": {
        "db_id": "tracking_software_problems",
        "question": "List the names of all the distinct product names in alphabetical order?",
        "ground_truth": "SELECT DISTINCT product_name FROM product ORDER BY product_name",
        "amends": [
            "Do add `DISTINCT` instead of omitting it to eliminate duplicate product names. Do change the table reference from `products` to `product` to match the correct source table. Do remove the `DESC` modifier from `ORDER BY product_name` instead of keeping it to sort in ascending order by default. The amended query now correctly returns unique product names from the product table in alphabetical order, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name FROM products ORDER BY product_name DESC;",
            "SELECT DISTINCT product_name FROM Product ORDER BY product_name;"
        ],
        "rule_sql": []
    },
    "1220": {
        "db_id": "apartment_rentals",
        "question": "Show the apartment numbers, start dates, and end dates of all the apartment bookings.",
        "ground_truth": "SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id",
        "amends": [
            "Do specify explicit table aliases `T2.apt_number`, `T1.booking_start_date` instead of ambiguous column names `apartment_number`, `start_date`, `end_date`. Do join `Apartment_Bookings AS T1` and `Apartments AS T2` with `ON T1.apt_id = T2.apt_id` instead of querying only the `bookings` table. Do remove the `WHERE apartment_number IS NOT NULL` filter instead of keeping it, as the join condition now properly handles the relationship. The amended query correctly links apartment bookings with their corresponding apartment details through the proper foreign key relationship.",
            "Do select `T1.booking_start_date` twice instead of `T1.booking_end_date` in the second position. The amended query now matches RIGHT_SQL's behavior by correctly retrieving the booking start date for both date fields instead of mixing start and end dates."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT apartment_number, start_date, end_date FROM bookings WHERE apartment_number IS NOT NULL",
            "SELECT T2.apt_number, T1.booking_start_date, T1.booking_end_date\nFROM Apartment_Bookings AS T1\nJOIN Apartments AS T2 ON T1.apt_id = T2.apt_id",
            "SELECT T2.apt_number, T1.booking_start_date, T1.booking_start_date \nFROM Apartment_Bookings AS T1\nJOIN Apartments AS T2 ON T1.apt_id = T2.apt_id"
        ],
        "rule_sql": []
    },
    "2654": {
        "db_id": "local_govt_mdm",
        "question": "List all information about customer master index, and sort them by details in descending order.",
        "ground_truth": "SELECT * FROM customer_master_index ORDER BY cmi_details DESC",
        "amends": [
            "Do order by `cmi_details DESC` instead of `details ASC` to use the correct column name with descending sort order instead of ascending. The amended query now matches RIGHT_SQL's behavior by properly sorting on the cmi_details column in descending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM customer_master_index ORDER BY details ASC;",
            "SELECT * FROM Customer_Master_Index ORDER BY cmi_details DESC;"
        ],
        "rule_sql": []
    },
    "4020": {
        "db_id": "ship_mission",
        "question": "Show names of ships involved in a mission launched after 1928.",
        "ground_truth": "SELECT T2.Name FROM mission AS T1 JOIN ship AS T2 ON T1.Ship_ID  =  T2.Ship_ID WHERE T1.Launched_Year  >  1928",
        "amends": [
            "Do select `T2.Name` from the `ship` table instead of `name` from the `ships` table. Do join `mission AS T1` with `ship AS T2` on `T1.Ship_ID = T2.Ship_ID` instead of querying only the `ships` table. Do filter on `T1.Launched_Year > 1928` from the mission table instead of `mission_year > 1928` from the ships table. The amended query now correctly retrieves ship names based on launch year from the mission table joined with ship details."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM ships WHERE mission_year > 1928;",
            "SELECT T2.Name FROM mission AS T1 JOIN ship AS T2 ON T1.Ship_ID = T2.Ship_ID WHERE T1.Launched_Year > 1928"
        ],
        "rule_sql": []
    },
    "3894": {
        "db_id": "insurance_policies",
        "question": "List the date the claim was made, the date it was settled and the amount settled for all the claims which had exactly one settlement.",
        "ground_truth": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  1",
        "amends": [
            "Do select `claim_id`, `date_claim_made`, and `Date_Claim_Settled` instead of `claim_date`, `settlement_date`, and `settlement_amount`. Do add `JOIN Settlements AS T2` instead of querying only the `claims` table. Do use `ON T1.Claim_id = T2.Claim_id` instead of no join condition. Do add `GROUP BY T1.claim_id` instead of omitting grouping. Do move the count filter to `HAVING count(*) = 1` instead of `WHERE settlement_count = 1`. The amended query now correctly joins claims with settlements and filters for claims with exactly one settlement, matching the intended behavior.",
            "Do remove `T1.Amount_Settled` from the SELECT list instead of including it, as it is not part of the GROUP BY clause. Do use lowercase `claim_id` column references instead of mixed case `Claim_ID` throughout the query. Do maintain the `JOIN` between `Claims` and `Settlements` on `T1.claim_id = T2.claim_id` instead of the original join condition. Do preserve the `GROUP BY T1.claim_id` and `HAVING count(*) = 1` logic to filter for claims with exactly one settlement record. The amended query now correctly selects only columns that are either grouped or aggregated, matching the right SQL's behavior.",
            "Do remove `T1.Amount_Settled` from the SELECT list instead of including it, and do remove `T1.Date_Claim_Settled` from the SELECT list instead of keeping it. Do use `T1.Claim_id = T2.Claim_id` in the JOIN condition instead of `T1.claim_id = T2.claim_id` for proper column name matching. The amended query now correctly returns only claim_id and date_claim_made columns while maintaining the same grouping and filtering logic to match the RIGHT_SQL's behavior.",
            "Do select `T1.claim_id`, `T1.date_claim_made`, and `T1.Date_Claim_Settled` instead of selecting `T1.claim_id`, `T1.date_claim_made`, `T2.Date_Claim_Settled`, and `T2.Amount_Settled`. Do remove the `T2.Amount_Settled` column from the SELECT list instead of including it. Do reference `T1.Date_Claim_Settled` instead of `T2.Date_Claim_Settled` to ensure the correct table source is used. The amended query now correctly retrieves only the necessary columns from the appropriate tables while maintaining the same grouping and filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT claim_date, settlement_date, settlement_amount \nFROM claims \nWHERE settlement_count = 1;",
            "SELECT T1.Claim_ID, T1.Date_Claim_Made, T1.Date_Claim_Settled, T1.Amount_Settled\nFROM Claims AS T1\nJOIN Settlements AS T2 ON T1.Claim_ID = T2.Claim_ID\nGROUP BY T1.Claim_ID\nHAVING COUNT(*) = 1",
            "SELECT T1.claim_id, T1.Date_Claim_Made, T1.Date_Claim_Settled, T1.Amount_Settled\nFROM Claims AS T1\nJOIN Settlements AS T2 ON T1.claim_id = T2.claim_id\nGROUP BY T1.claim_id\nHAVING count(*) = 1",
            "SELECT T1.claim_id, T1.date_claim_made, T2.Date_Claim_Settled, T2.Amount_Settled\nFROM Claims AS T1\nJOIN Settlements AS T2 ON T1.claim_id = T2.claim_id\nGROUP BY T1.claim_id\nHAVING COUNT(*) = 1",
            "SELECT T1.claim_id, T1.date_claim_made, T1.Date_Claim_Settled\nFROM Claims AS T1\nJOIN Settlements AS T2 ON T1.Claim_id = T2.Claim_id\nGROUP BY T1.claim_id\nHAVING COUNT(*) = 1"
        ],
        "rule_sql": []
    },
    "373": {
        "db_id": "flight_1",
        "question": "Show the id and name of the employee with maximum salary.",
        "ground_truth": "SELECT eid ,  name FROM Employee ORDER BY salary DESC LIMIT 1",
        "amends": [
            "Do select `eid` and `name` instead of `id` and `name`. Do use `ORDER BY salary DESC LIMIT 1` instead of a subquery with `WHERE salary = (SELECT MIN(salary))`. Do reference table `Employee` instead of `employees`. The amended query now correctly identifies the highest-paid employee rather than finding multiple employees with the minimum salary, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, name FROM employees WHERE salary = (SELECT MIN(salary) FROM employees);",
            "SELECT eid, name FROM employee ORDER BY salary DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "4822": {
        "db_id": "aircraft",
        "question": "What is the location and name of the winning aircraft?",
        "ground_truth": "SELECT T2.Location ,  T1.Aircraft FROM aircraft AS T1 JOIN MATCH AS T2 ON T1.Aircraft_ID  =  T2.Winning_Aircraft",
        "amends": [
            "Do specify `T2.Location` and `T1.Aircraft` in the SELECT list instead of `location` and `name`. Do join `MATCH AS T2` with `aircraft AS T1` using `ON T1.Aircraft_ID = T2.Winning_Aircraft` instead of querying only the `aircraft` table. Do remove the `WHERE status = 'winner'` filter instead of keeping it, as the winner status is now determined through the join with the MATCH table. The amended query now correctly retrieves winning aircraft locations by joining the aircraft and match tables instead of relying on a status field."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location, name FROM aircraft WHERE status = 'winner';",
            "SELECT T2.Location, T1.Aircraft FROM aircraft AS T1 JOIN match AS T2 ON T1.Aircraft_ID = T2.Winning_Aircraft"
        ],
        "rule_sql": []
    },
    "6822": {
        "db_id": "flight_4",
        "question": "How many airports' names have the word Interanation in them?",
        "ground_truth": "SELECT count(*) FROM airports WHERE name LIKE '%International%'",
        "amends": [
            "Do use the pattern `%International%` instead of `%Interanation%` in the WHERE filter to correctly match airport names containing 'International' instead of the misspelled 'Interanation'. Do maintain the same `COUNT(*)` aggregation and `airports` table source without changes. The amended query now correctly counts airports with 'International' in their name instead of searching for a non-existent spelling variant."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM airports WHERE name LIKE '%Interanation%';",
            "SELECT COUNT(*) FROM airports WHERE name LIKE '%International%'"
        ],
        "rule_sql": []
    },
    "4624": {
        "db_id": "customers_campaigns_ecommerce",
        "question": "Show all distinct product categories along with the number of mailshots in each category.",
        "ground_truth": "SELECT product_category ,  count(*) FROM mailshot_campaigns GROUP BY product_category",
        "amends": [
            "Do reference table `mailshot_campaigns` instead of `mailshots` and use column `product_category` instead of `category` in both the SELECT list and GROUP BY clause, while maintaining the same aggregate function `count(*)` to preserve the counting logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category, COUNT(*) FROM mailshots GROUP BY category;",
            "SELECT DISTINCT product_category, COUNT(*) AS mailshot_count\nFROM Mailshot_Campaigns\nGROUP BY product_category;"
        ],
        "rule_sql": []
    },
    "6593": {
        "db_id": "wine_1",
        "question": "Find the appelations that produce wines after the year of 2008 but not in Central Coast area.",
        "ground_truth": "SELECT Appelation FROM WINE WHERE YEAR  >  2008 EXCEPT SELECT Appelation FROM APPELLATIONS WHERE Area  =  \"Central Coast\"",
        "amends": [
            "Do use table `WINE` instead of `wines` and select column `Appelation` instead of `appelation`. Do remove the `WHERE` clause with conditions `year > 2008 AND region != 'Central Coast'` instead of keeping it. Do add an `EXCEPT` operation with a subquery selecting `Appelation` from `APPELLATIONS` where `Area = \"Central Coast\"` instead of omitting it. Do use uppercase column and table names throughout instead of lowercase. The amended query now correctly excludes Central Coast appellations using an EXCEPT operation rather than attempting to filter them in the WHERE clause, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT appelation FROM wines WHERE year > 2008 AND region != 'Central Coast';",
            "SELECT Appelation FROM WINE WHERE Year > 2008 EXCEPT SELECT Appelation FROM APPELLATIONS WHERE Area = 'Central Coast'"
        ],
        "rule_sql": []
    },
    "3004": {
        "db_id": "sakila_1",
        "question": "What are the first names of customers who have not rented any films after '2005-08-23 02:06:01'?",
        "ground_truth": "SELECT first_name FROM customer WHERE customer_id NOT IN( SELECT customer_id FROM rental WHERE rental_date  >  '2005-08-23 02:06:01' )",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM customer WHERE customer_id NOT IN (SELECT customer_id FROM rental WHERE rental_date > '2005-08-23 02:06:01')"
        ],
        "rule_sql": []
    },
    "230": {
        "db_id": "book_2",
        "question": "Show the publishers that have publications with price higher than 10000000 and publications with price lower than 5000000.",
        "ground_truth": "SELECT Publisher FROM publication WHERE Price  >  10000000 INTERSECT SELECT Publisher FROM publication WHERE Price  <  5000000",
        "amends": [
            "Do use `INTERSECT` to find publishers with both high and low prices instead of `OR` which finds publishers with either condition. Do reference `Publisher` column instead of `publisher_name`. Do use table name `publication` instead of `publications`. Do remove `DISTINCT` since `INTERSECT` inherently returns unique values. Do split into two separate queries for each price condition instead of combining with `OR` in a single query. The amended query now correctly identifies publishers that have both expensive publications (>10,000,000) and inexpensive publications (<5,000,000), matching the RIGHT_SQL's set intersection behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT publisher_name \nFROM publications \nWHERE price > 10000000 OR price < 5000000;",
            "SELECT Publisher FROM publication WHERE Price > 10000000 INTERSECT SELECT Publisher FROM publication WHERE Price < 5000000"
        ],
        "rule_sql": []
    },
    "2303": {
        "db_id": "perpetrator",
        "question": "How many perpetrators are there?",
        "ground_truth": "SELECT count(*) FROM perpetrator",
        "amends": [
            "Do query the `perpetrator` table instead of the `victims` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the perpetrator table instead of the victims table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM victims;",
            "SELECT count(*) FROM perpetrator;"
        ],
        "rule_sql": []
    },
    "3797": {
        "db_id": "e_learning",
        "question": "Sort the information about course authors and tutors in alphabetical order of the personal name.",
        "ground_truth": "SELECT * FROM Course_Authors_and_Tutors ORDER BY personal_name",
        "amends": [
            "Do reference the table as `Course_Authors_and_Tutors` instead of `course_authors_tutors` to match the correct table name. Do order by `personal_name` instead of `course_name` to sort by the appropriate column. The amended query now correctly selects from the proper table and orders results by personal names rather than course names, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM course_authors_tutors ORDER BY course_name ASC;",
            "SELECT * FROM Course_Authors_and_Tutors ORDER BY personal_name ASC;"
        ],
        "rule_sql": []
    },
    "1057": {
        "db_id": "match_season",
        "question": "What are the official native languages that contain the string \"English\".",
        "ground_truth": "SELECT Official_native_language FROM country WHERE Official_native_language LIKE \"%English%\"",
        "amends": [
            "Do select `Official_native_language` instead of `*` to return only the specific column needed. Do query from `country` table instead of `languages` table to access the correct data source containing official language information. Do filter on `Official_native_language LIKE \"%English%\"` instead of `language_name LIKE '%English%'` to use the appropriate column name for official languages. The amended query now correctly retrieves official native languages containing \"English\" from the country table instead of attempting to find language names in an unrelated languages table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM languages WHERE language_name LIKE '%English%';",
            "SELECT Official_native_language FROM country WHERE Official_native_language LIKE '%English%'"
        ],
        "rule_sql": []
    },
    "3625": {
        "db_id": "music_1",
        "question": "Find the names of the artists who have produced English songs but have never received rating higher than 8.",
        "ground_truth": "SELECT DISTINCT artist_name FROM song WHERE languages  =  \"english\" EXCEPT SELECT DISTINCT artist_name FROM song WHERE rating  >  8",
        "amends": [
            "Do select `artist_name` from the `song` table instead of `a.name` from joined `artists` and `songs` tables. Do use a single `song` table source instead of joining separate `artists` and `songs` tables. Do filter with `languages = \"english\"` instead of `s.language = 'English'`. Do use `EXCEPT` to exclude artists with high ratings instead of a `NOT IN` subquery. Do remove the explicit `DISTINCT` in the second part since `EXCEPT` inherently eliminates duplicates. Do reference `artist_name` directly in both query parts instead of using `artist_id` for filtering. The amended query now correctly identifies English-speaking artists while excluding those with high-rated songs using set operations."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT a.name \nFROM artists a\nJOIN songs s ON a.artist_id = s.artist_id\nWHERE s.language = 'English'\nAND a.artist_id NOT IN (\n    SELECT artist_id \n    FROM songs \n    WHERE rating > 8\n);",
            "SELECT artist_name FROM song WHERE languages = 'english' EXCEPT SELECT artist_name FROM song WHERE rating > 8"
        ],
        "rule_sql": []
    },
    "6692": {
        "db_id": "driving_school",
        "question": "List the number of customers that did not have any payment history.",
        "ground_truth": "SELECT count(*) FROM Customers WHERE customer_id NOT IN ( SELECT customer_id FROM Customer_Payments );",
        "amends": [
            "Do reference the `Customers` table instead of `customers` and use `Customer_Payments` instead of `payments` for the subquery source table. Do maintain the same `COUNT(*)` aggregation and `NOT IN` predicate logic with identical subquery structure. The amended query now correctly references the proper table names while preserving the original behavior of counting customers without payments."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE customer_id NOT IN (SELECT customer_id FROM payments)",
            "SELECT COUNT(*) \nFROM Customers \nWHERE customer_id NOT IN (\n    SELECT customer_id \n    FROM Customer_Payments\n)"
        ],
        "rule_sql": []
    },
    "5287": {
        "db_id": "manufactory_1",
        "question": "How many manufacturers have headquarters in either Tokyo or Beijing?",
        "ground_truth": "SELECT count(*) FROM manufacturers WHERE headquarter  =  'Tokyo' OR headquarter  =  'Beijing'",
        "amends": [
            "Do use `OR` operator between the headquarters conditions instead of `AND` operator, which would never return results since a headquarters cannot be both Tokyo and Beijing simultaneously. Do reference the correct column name `headquarter` instead of `headquarters` to match the actual schema. The amended query now correctly counts manufacturers with headquarters in either Tokyo or Beijing, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM manufacturers WHERE headquarters = 'Tokyo' AND headquarters = 'Beijing';",
            "SELECT COUNT(*) FROM Manufacturers WHERE headquarter = 'Tokyo' OR headquarter = 'Beijing';"
        ],
        "rule_sql": []
    },
    "3287": {
        "db_id": "college_1",
        "question": "How many professors who has a either Ph.D. or MA degree?",
        "ground_truth": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'",
        "amends": [
            "Do reference the correct table name `professor` instead of `professors`. Do use the correct column name `prof_high_degree` instead of `degree`. Do use `OR` logical operator to find records matching either 'Ph.D.' or 'MA' instead of `AND` which would find records matching both values simultaneously (an impossible condition). Do maintain the `COUNT(*)` aggregate function to count matching records instead of changing it."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM professors WHERE degree = 'Ph.D.' AND degree = 'MA';",
            "SELECT COUNT(*) FROM professor WHERE prof_high_degree = 'Ph.D.' OR prof_high_degree = 'MA'"
        ],
        "rule_sql": []
    },
    "6124": {
        "db_id": "customers_and_addresses",
        "question": "Find the total quantity of products associated with the orders in the \"Cancelled\" status.",
        "ground_truth": "SELECT sum(t2.order_quantity) FROM customer_orders AS t1 JOIN order_items AS t2 ON t1.order_id  =  t2.order_id WHERE t1.order_status  =  \"Cancelled\"",
        "amends": [
            "Do join `customer_orders AS t1` and `order_items AS t2` on `t1.order_id = t2.order_id` instead of querying only the `orders` table. Do reference `t2.order_quantity` instead of `quantity` for the sum calculation. Do filter on `t1.order_status = 'Cancelled'` instead of `status = 'Cancelled'` to ensure the correct table context. The amended query now properly aggregates cancelled order quantities from the joined order items table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(quantity) FROM orders WHERE status = 'Cancelled';",
            "SELECT SUM(t2.order_quantity) AS total_quantity\nFROM customer_orders AS t1\nJOIN order_items AS t2 ON t1.order_id = t2.order_id\nWHERE t1.order_status = 'Cancelled'"
        ],
        "rule_sql": []
    },
    "3115": {
        "db_id": "behavior_monitoring",
        "question": "Find the start and end dates of detentions of teachers with last name \"Schultz\".",
        "ground_truth": "SELECT T1.datetime_detention_start ,  datetime_detention_end FROM Detention AS T1 JOIN Teachers AS T2 ON T1.teacher_id  =  T2.teacher_id WHERE T2.last_name  =  \"Schultz\"",
        "amends": [
            "Do use fully qualified column names `T1.datetime_detention_start` and `datetime_detention_end` instead of unqualified `start_date` and `end_date`. Do add the `Teachers AS T2` table with a `JOIN` on `T1.teacher_id = T2.teacher_id` instead of querying only the `detentions` table. Do reference the teacher filter through the joined table as `T2.last_name = \"Schultz\"` instead of directly filtering on `teacher_last_name` in the original table. Do use proper table aliasing with `Detention AS T1` instead of the base table name alone. The amended query now correctly joins related tables to filter by teacher last name while maintaining proper referential integrity."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT start_date, end_date FROM detentions WHERE teacher_last_name = 'Schultz'",
            "SELECT T1.datetime_detention_start, T1.datetime_detention_end\nFROM Detention AS T1\nJOIN Teachers AS T2 ON T1.teacher_id = T2.teacher_id\nWHERE T2.last_name = 'Schultz'"
        ],
        "rule_sql": []
    },
    "6922": {
        "db_id": "tracking_orders",
        "question": "Which orders have shipment after 2000-01-01? Give me the order ids.",
        "ground_truth": "SELECT order_id FROM shipments WHERE shipment_date > \"2000-01-01\"",
        "amends": [
            "Do query the `shipments` table instead of the `orders` table. Do use the greater than operator `>` for `shipment_date` instead of the less than operator `<`. Do use double quotes `\"2000-01-01\"` for the date literal instead of single quotes `'2000-01-01'`. The amended query now correctly retrieves order IDs from the shipments table where shipment dates occur after January 1, 2000, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT order_id FROM orders WHERE shipment_date < '2000-01-01';",
            "SELECT order_id FROM Shipments WHERE shipment_date > \"2000-01-01\""
        ],
        "rule_sql": []
    },
    "4586": {
        "db_id": "solvency_ii",
        "question": "Show the prices of the products named \"Dining\" or \"Trading Policy\".",
        "ground_truth": "SELECT Product_Price FROM Products WHERE Product_Name  =  \"Dining\" OR Product_Name  =  \"Trading Policy\"",
        "amends": [
            "Do reference `Product_Price` instead of `price` and `Product_Name` instead of `name` in the SELECT and WHERE clauses. Do use `OR` instead of `AND` between the two name conditions to correctly retrieve products matching either name instead of incorrectly requiring both names simultaneously. Do use double quotes instead of single quotes for string literals in the WHERE clause. The amended query now correctly returns products with either \"Dining\" or \"Trading Policy\" as their name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT price FROM products WHERE name = 'Dining' AND name = 'Trading Policy'",
            "SELECT Product_Price FROM Products WHERE Product_Name = \"Dining\" OR Product_Name = \"Trading Policy\""
        ],
        "rule_sql": []
    },
    "2593": {
        "db_id": "inn_1",
        "question": "What are the room name and base price of the room with the lowest base price?",
        "ground_truth": "SELECT roomName ,  basePrice FROM Rooms ORDER BY basePrice ASC LIMIT 1;",
        "amends": [
            "Do use column names `roomName` and `basePrice` instead of `room_name` and `base_price`. Do sort by `basePrice` in ascending order using `ASC` instead of descending order with `DESC`. Do reference table `Rooms` instead of `rooms`. The amended query now correctly retrieves the room with the lowest base price instead of the highest, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT room_name, base_price FROM rooms ORDER BY base_price DESC LIMIT 1;",
            "SELECT roomName, basePrice FROM Rooms ORDER BY basePrice ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6541": {
        "db_id": "wine_1",
        "question": "Give me the average prices of wines that are produced by appelations in Sonoma County.",
        "ground_truth": "SELECT AVG(T2.Price) FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  \"Sonoma\"",
        "amends": [
            "Do join `APPELLATIONS AS T1` and `WINE AS T2` on `T1.Appelation = T2.Appelation` instead of querying `wines` table directly. Do reference `T2.Price` instead of `price` and use double quotes around `\"Sonoma\"` instead of single quotes. Do filter on `T1.County = \"Sonoma\"` instead of `county = 'Sonoma'` to properly relate appellation data to wine pricing. The amended query now correctly calculates average wine prices by joining appellation and wine tables to ensure county-based filtering matches the intended logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(price) FROM wines WHERE county = 'Sonoma';",
            "SELECT AVG(T2.Price) AS average_price FROM appellations AS T1 JOIN wine AS T2 ON T1.Appelation = T2.Appelation WHERE T1.County = \"Sonoma\""
        ],
        "rule_sql": []
    },
    "1962": {
        "db_id": "products_for_hire",
        "question": "What is the maximum total amount paid by a customer? List the customer id and amount.",
        "ground_truth": "SELECT customer_id ,  sum(amount_paid) FROM Payments GROUP BY customer_id ORDER BY sum(amount_paid) DESC LIMIT 1",
        "amends": [
            "Do reference the `amount_paid` column instead of `amount` in the SELECT list and aggregate function. Do use the correct table name `Payments` instead of `payments` in the FROM clause. Do order by the aggregate expression `sum(amount_paid)` instead of the alias `total_amount` in the ORDER BY clause. The amended query now correctly calculates the total amount paid per customer and identifies the customer with the highest payment total."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_id, SUM(amount) as total_amount FROM payments GROUP BY customer_id ORDER BY total_amount DESC LIMIT 1;",
            "SELECT customer_id, SUM(amount_paid) AS total_amount_paid\nFROM Payments\nGROUP BY customer_id\nORDER BY SUM(amount_paid) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "2134": {
        "db_id": "company_1",
        "question": "Find the names of departments that are located in Houston.",
        "ground_truth": "SELECT t1.dname FROM department AS t1 JOIN dept_locations AS t2 ON t1.dnumber  =  t2.dnumber WHERE t2.dlocation  =  'Houston'",
        "amends": [
            "Do reference `t1.dname` instead of `department_name` and use table alias `t1` instead of direct table reference. Do join `dept_locations AS t2` instead of querying only the `departments` table. Do use join condition `t1.dnumber = t2.dnumber` instead of no join condition. Do filter on `t2.dlocation = 'Houston'` instead of `city = 'Dallas'`. The amended query now correctly joins the department and location tables to filter by location and returns the appropriate department name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT department_name FROM departments WHERE city = 'Dallas';",
            "SELECT t1.Dname FROM department AS t1 JOIN dept_locations AS t2 ON t1.Dnumber = t2.Dnumber WHERE t2.Dlocation = 'Houston'"
        ],
        "rule_sql": []
    },
    "4059": {
        "db_id": "student_1",
        "question": "Which students study under the teacher named OTHA MOYER? Give me the first and last names of the students.",
        "ground_truth": "SELECT T1.firstname ,  T1.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"OTHA\" AND T2.lastname  =  \"MOYER\"",
        "amends": [
            "Do select `firstname` and `lastname` from table `list` instead of `first_name` and `last_name` from `students`. Do join `teachers` on `classroom` instead of using a subquery with `teacher_id`. Do use `JOIN` with condition `T1.classroom = T2.classroom` instead of a correlated subquery with `teacher_id`. Do filter directly on `T2.firstname = \"OTHA\"` and `T2.lastname = \"MOYER\"` in the WHERE clause instead of using a subquery predicate. Do reference tables with aliases `T1` and `T2` instead of no aliases. The amended query now correctly joins on classroom relationship instead of assuming teacher_id correlation, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM students WHERE teacher_id = (SELECT teacher_id FROM teachers WHERE first_name = 'OTHA' AND last_name = 'MOYER')",
            "SELECT T1.FirstName, T1.LastName FROM list T1 JOIN teachers T2 ON T1.Classroom = T2.Classroom WHERE T2.FirstName = 'OTHA' AND T2.LastName = 'MOYER'"
        ],
        "rule_sql": []
    },
    "6852": {
        "db_id": "flight_4",
        "question": "What is the number of cities in the United States with more than 3 airports?",
        "ground_truth": "SELECT city FROM airports WHERE country  =  'United States' GROUP BY city HAVING count(*)  >  3",
        "amends": [
            "Do select `city` instead of `COUNT(*)` and change the source table to `airports` instead of `cities`. Do add `GROUP BY city` instead of omitting it and move the count filter to `HAVING count(*) > 3` instead of using `WHERE airport_count > 3`. Do remove the incorrect column reference `airport_count` instead of keeping it. The amended query now correctly counts airports per city and filters for cities with more than 3 airports, matching the intended behavior.",
            "Do remove the `COUNT(*)` column from the SELECT list instead of including it, as the query only needs to return distinct city names that meet the grouping criteria. Do keep the same `WHERE` filter on `country = 'United States'` instead of changing it. Do maintain the `GROUP BY city` clause instead of altering it. Do preserve the `HAVING count(*) > 3` condition instead of modifying it, ensuring only cities with more than three airports in the United States are returned. The amended query now correctly returns only city names without the redundant count column while maintaining the same filtering and grouping logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities WHERE country = 'United States' AND airport_count > 3;",
            "SELECT city, COUNT(*) FROM airports WHERE country = 'United States' GROUP BY city HAVING COUNT(*) > 3",
            "SELECT city FROM airports WHERE country = 'United States' GROUP BY city HAVING COUNT(*) > 3"
        ],
        "rule_sql": []
    },
    "3405": {
        "db_id": "hr_1",
        "question": "Display the first name and department name for each employee.",
        "ground_truth": "SELECT T1.first_name ,  T2.department_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, department_name FROM employees JOIN departments ON employees.department_id = departments.department_id"
        ],
        "rule_sql": []
    },
    "1263": {
        "db_id": "apartment_rentals",
        "question": "Which apartment type code is the most common among apartments with more than one bathroom?",
        "ground_truth": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use column name `apt_type_code` instead of `apartment_type_code` and `bathroom_count` instead of `bathrooms`. Do reference table `Apartments` instead of `apartments`. Do remove the alias `count` from the SELECT list instead of keeping it. Do move the aggregate function `count(*)` to the ORDER BY clause instead of having it in the SELECT list with an alias. Do maintain the same GROUP BY clause with `apt_type_code` instead of `apartment_type_code`. The amended query now correctly selects only the apartment type code while ordering by the count of records with more than one bathroom, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT apartment_type_code, COUNT(*) as count \nFROM apartments \nWHERE bathrooms > 1 \nGROUP BY apartment_type_code \nORDER BY count DESC \nLIMIT 1;",
            "SELECT apt_type_code FROM Apartments WHERE bathroom_count > 1 GROUP BY apt_type_code ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2212": {
        "db_id": "formula_1",
        "question": "What is the id and last name of the driver who participated in the most races after 2010?",
        "ground_truth": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN results AS T2 ON T1.driverid  =  T2.driverid JOIN races AS T3 ON T2.raceid = T3.raceid WHERE T3.year > 2010 GROUP BY T1.driverid ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `JOIN results AS T2 ON T1.driverid = T2.driverid` and `JOIN races AS T3 ON T2.raceid = T3.raceid` instead of querying only the `drivers` table. Do change the filter to `T3.year > 2010` instead of `race_date > '2010-01-01'` to use the year column from the races table. Do use `T1.driverid` and `T1.surname` with table aliases instead of `driver_id` and `last_name` without aliases. Do maintain the `GROUP BY T1.driverid`, `ORDER BY count(*) DESC`, and `LIMIT 1` clauses as they correctly identify the driver with the most race results after 2010. The amended query now properly joins the necessary tables to filter by race year and count results, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT driver_id, last_name \nFROM drivers \nWHERE race_date > '2010-01-01' \nGROUP BY driver_id \nORDER BY COUNT(*) DESC \nLIMIT 1;",
            "SELECT T1.driverId, T1.surname\nFROM drivers AS T1\nJOIN results AS T2 ON T1.driverId = T2.driverId\nJOIN races AS T3 ON T2.raceId = T3.raceId\nWHERE T3.year > 2010\nGROUP BY T1.driverId\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5196": {
        "db_id": "music_2",
        "question": "What is the last name of the musician that have produced the most number of songs?",
        "ground_truth": "SELECT T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId GROUP BY lastname ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.lastname` from the `Band` table instead of `last_name` from `musicians`. Do join `Performance AS T1` with `Band AS T2` on `T1.bandmate = T2.id` and join `Songs AS T3` on `T3.SongId = T1.SongId` instead of missing these table sources and join conditions entirely. Do add `GROUP BY lastname` to aggregate by band member instead of omitting grouping. Do order by `count(*)` instead of `COUNT(songs.id)` to count performances rather than songs. The amended query now correctly counts performances per band member and returns the band member with the most performances, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT last_name FROM musicians ORDER BY COUNT(songs.id) DESC LIMIT 1;",
            "SELECT T2.Lastname\nFROM Performance AS T1\nJOIN Band AS T2 ON T1.Bandmate = T2.Id\nJOIN Songs AS T3 ON T3.SongId = T1.SongId\nGROUP BY T2.Lastname\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "3108": {
        "db_id": "behavior_monitoring",
        "question": "What are the id and first name of the student whose addresses have the highest average monthly rental?",
        "ground_truth": "SELECT T1.student_id ,  T2.first_name FROM Student_Addresses AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY AVG(monthly_rental) DESC LIMIT 1",
        "amends": [
            "Do add `Student_Addresses` table and `Students` table with a `JOIN` on `student_id` instead of querying only the `students` table. Do change the SELECT list to `T1.student_id` and `T2.first_name` instead of `id` and `first_name`. Do add `GROUP BY T1.student_id` instead of omitting it, which is necessary for the `AVG(monthly_rental)` aggregation. Do keep the `ORDER BY AVG(monthly_rental) DESC LIMIT 1` clause unchanged. The amended query now correctly joins the address and student tables to calculate average rental values per student before ordering and limiting the results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, first_name FROM students ORDER BY AVG(monthly_rental) DESC LIMIT 1;",
            "SELECT T1.student_id, T2.first_name\nFROM Student_Addresses T1\nJOIN Students T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY AVG(monthly_rental) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "1752": {
        "db_id": "gymnast",
        "question": "List the names of the top 5 oldest people.",
        "ground_truth": "SELECT Name FROM People ORDER BY Age DESC LIMIT 5",
        "amends": [
            "Do use column name `Name` instead of `name` and table name `People` instead of `people` to match proper case sensitivity. Do change the sort order to `DESC` instead of `ASC` for the `Age` column. The amended query now correctly retrieves the top 5 records ordered by age in descending order from the People table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM people ORDER BY age ASC LIMIT 5;",
            "SELECT Name FROM People ORDER BY Age DESC LIMIT 5;"
        ],
        "rule_sql": []
    },
    "1757": {
        "db_id": "gymnast",
        "question": "Return the average age across all gymnasts.",
        "ground_truth": "SELECT avg(T2.Age) FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID",
        "amends": [
            "Do use `avg(T2.Age)` instead of `SUM(age)` to calculate the average instead of the sum. Do join `gymnast AS T1` with `people AS T2` on `T1.Gymnast_ID = T2.People_ID` instead of querying only the `gymnasts` table. Do reference the correct column `T2.Age` from the joined table instead of the ambiguous `age` column. The amended query now correctly calculates the average age of gymnasts by joining with the people table to access age information."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(age) FROM gymnasts;",
            "SELECT AVG(T2.Age) FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID = T2.People_ID"
        ],
        "rule_sql": []
    },
    "59": {
        "db_id": "student_assessment",
        "question": "What are the ids of the students who registered for some courses but had the least number of courses for all students?",
        "ground_truth": "SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do select only `student_id` instead of including `COUNT(*) as course_count`. Do use `FROM student_course_registrations` instead of `FROM registrations`. Do remove the `HAVING` clause with its complex subquery that finds minimum course count instead of keeping it. Do add `ORDER BY count(*) LIMIT 1` instead of omitting ordering and limiting, which directly returns the student with the fewest registrations. Do remove the unnecessary grouping column alias and subquery structure instead of maintaining the complex nested aggregation approach."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_id, COUNT(*) as course_count\nFROM registrations\nGROUP BY student_id\nHAVING course_count = (SELECT MIN(course_count) FROM (SELECT student_id, COUNT(*) as course_count FROM registrations GROUP BY student_id))",
            "SELECT student_id FROM Student_Course_Registrations GROUP BY student_id ORDER BY COUNT(*) LIMIT 1"
        ],
        "rule_sql": []
    },
    "1896": {
        "db_id": "school_finance",
        "question": "List all the names of schools with an endowment amount smaller than or equal to 10.",
        "ground_truth": "SELECT T2.school_name FROM endowment AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id GROUP BY T1.school_id HAVING sum(T1.amount)  <=  10",
        "amends": [
            "Do select `T2.school_name` instead of `name` and use aggregation with `HAVING sum(T1.amount) <= 10` instead of direct column comparison `endowment > 10`. Do join `endowment AS T1` with `school AS T2` on `T1.school_id = T2.school_id` instead of querying a single `schools` table. Do add `GROUP BY T1.school_id` instead of omitting grouping. Do move the filter to `HAVING` instead of `WHERE` to properly aggregate endowment amounts before filtering. The amended query now correctly aggregates endowment amounts by school and filters for schools with total endowment less than or equal to 10, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM schools WHERE endowment > 10;",
            "SELECT T2.School_name \nFROM endowment AS T1 \nJOIN School AS T2 ON T1.School_id = T2.School_id \nGROUP BY T1.School_id \nHAVING SUM(T1.amount) <= 10"
        ],
        "rule_sql": []
    },
    "4175": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "When was the document named \"Marry CV\" stored? Give me the date.",
        "ground_truth": "SELECT date_stored FROM All_documents WHERE Document_name  =  \"Marry CV\"",
        "amends": [
            "Do reference `date_stored` instead of `date` in the SELECT list. Do use `All_documents` instead of `documents` as the table source. Do filter on `Document_name = \"Marry CV\"` instead of `name = 'Marry CV'` in the WHERE clause. The amended query now correctly retrieves the storage date from the specified document table with the proper column references and string literal syntax."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT date FROM documents WHERE name = 'Marry CV';",
            "SELECT Date_Stored FROM All_Documents WHERE Document_Name = 'Marry CV';"
        ],
        "rule_sql": []
    },
    "6493": {
        "db_id": "scientist_1",
        "question": "List the names of all scientists sorted in alphabetical order.",
        "ground_truth": "SELECT name FROM scientists ORDER BY name",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM scientists ORDER BY name DESC;"
        ],
        "rule_sql": []
    },
    "3774": {
        "db_id": "e_learning",
        "question": "List the addresses of all the course authors or tutors.",
        "ground_truth": "SELECT address_line_1 FROM Course_Authors_and_Tutors",
        "amends": [
            "Do select `address_line_1` instead of `address` from the table. Do use the table name `Course_Authors_and_Tutors` instead of `authors` as the data source. Do remove the `WHERE` clause filtering for `role = 'course author' OR role = 'tutor'` instead of keeping it, as the table name already implies the appropriate data scope. The amended query now correctly retrieves address information from the designated course authors and tutors table without unnecessary filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address FROM authors WHERE role = 'course author' OR role = 'tutor';",
            "SELECT address_line_1 FROM Course_Authors_and_Tutors;"
        ],
        "rule_sql": []
    },
    "5763": {
        "db_id": "dorm_1",
        "question": "What are the first and last names of all students who are living in a dorm with a TV Lounge?",
        "ground_truth": "SELECT T1.fname ,  T1.lname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')",
        "amends": [
            "Do select `fname` and `lname` from table `student` instead of `first_name` and `last_name` from `students`. Do join `lives_in` on `stuid` instead of querying `dorms` directly. Do use a subquery that joins `has_amenity` with `dorm_amenity` on `amenid` to filter for `amenity_name = 'TV Lounge'` instead of checking `has_tv_lounge = 'yes'` directly. Do reference the correct column names `dormid` in the subquery instead of `dorm_id`. The amended query now properly navigates the relationship between students, their dorm assignments, and dorm amenities through the appropriate join tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM students WHERE dorm_id IN (SELECT dorm_id FROM dorms WHERE has_tv_lounge = 'yes');",
            "SELECT s.Fname, s.LName \nFROM Student s\nJOIN Lives_in li ON s.StuID = li.stuid\nWHERE li.dormid IN (\n    SELECT ha.dormid \n    FROM Has_amenity ha\n    JOIN Dorm_amenity da ON ha.amenid = da.amenid\n    WHERE da.amenity_name = 'TV Lounge'\n)"
        ],
        "rule_sql": []
    },
    "3650": {
        "db_id": "baseball_1",
        "question": "What are the three countries that the least players are from?",
        "ground_truth": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;",
        "amends": [
            "Do use `birth_country` instead of `country` as the column name in both the SELECT list and GROUP BY clause. Do use `count(*)` directly in the ORDER BY clause instead of referencing the alias `player_count`. Do sort in `ASC` ascending order instead of `DESC` descending order. Do query from the `player` table instead of the `players` table. The amended query now correctly selects birth countries, counts players per country, and returns the three countries with the smallest player counts in ascending order, matching the RIGHT_SQL's behavior.",
            "Do remove the `COUNT(*) AS player_count` column from the SELECT list instead of including it, as the RIGHT_SQL only needs to return the birth_country values. Do keep the `GROUP BY birth_country` clause to group by country instead of omitting it. Do maintain the `ORDER BY count(*) ASC` to order by the count of players per country instead of changing it. Do preserve the `LIMIT 3` to return only the top three countries instead of modifying it. The amended query now matches RIGHT_SQL's behavior by returning only the birth_country values for the three countries with the fewest players."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) as player_count FROM players GROUP BY country ORDER BY player_count DESC LIMIT 3;",
            "SELECT birth_country, COUNT(*) AS player_count FROM player GROUP BY birth_country ORDER BY COUNT(*) ASC LIMIT 3;",
            "SELECT birth_country FROM player GROUP BY birth_country ORDER BY COUNT(*) ASC LIMIT 3"
        ],
        "rule_sql": []
    },
    "193": {
        "db_id": "bike_1",
        "question": "List all the distinct stations from which a trip of duration below 100 started.",
        "ground_truth": "SELECT DISTINCT start_station_name FROM trip WHERE duration  <  100",
        "amends": [
            "Do reference `start_station_name` instead of `start_station` in the SELECT list. Do reference table `trip` instead of `trips` in the FROM clause. The amended query now correctly selects from the appropriate table with the correct column name while preserving the DISTINCT modifier and duration filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT start_station FROM trips WHERE duration < 100;",
            "SELECT DISTINCT start_station_name FROM trip WHERE duration < 100;"
        ],
        "rule_sql": []
    },
    "2802": {
        "db_id": "news_report",
        "question": "How many journalists are there?",
        "ground_truth": "SELECT count(*) FROM journalist",
        "amends": [
            "Do query the `journalist` table instead of the `employees` table. Do use the `count(*)` aggregate function instead of `COUNT(*)` (though this is a cosmetic difference). Do remove the `WHERE job_title = 'reporter'` filter instead of keeping it, as the right query counts all journalists rather than filtering for a specific job title. The amended query now correctly counts all records in the journalist table instead of filtering employees by job title."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE job_title = 'reporter';",
            "SELECT count(*) FROM journalist;"
        ],
        "rule_sql": []
    },
    "2592": {
        "db_id": "inn_1",
        "question": "Which room has cheapest base price? List the room's name and the base price.",
        "ground_truth": "SELECT roomName ,  basePrice FROM Rooms ORDER BY basePrice ASC LIMIT 1;",
        "amends": [
            "Do use column names `roomName` and `basePrice` instead of `room_name` and `base_price`. Do sort by `basePrice` in ascending order using `ASC` instead of descending order with `DESC`. Do reference the table `Rooms` instead of `rooms`."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT room_name, base_price FROM rooms ORDER BY base_price DESC LIMIT 1;",
            "SELECT roomName, basePrice FROM Rooms ORDER BY basePrice ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2968": {
        "db_id": "sakila_1",
        "question": "What is the film title and inventory id of the item in the inventory which was rented most frequently?",
        "ground_truth": "SELECT T1.title ,  T2.inventory_id FROM film AS T1 JOIN inventory AS T2 ON T1.film_id  =  T2.film_id JOIN rental AS T3 ON T2.inventory_id  =  T3.inventory_id GROUP BY T2.inventory_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do remove `COUNT(r.rental_id) as rental_count` from the SELECT list instead of including it. Do change the GROUP BY clause to use only `T2.inventory_id` instead of grouping by both `f.title` and `i.inventory_id`. Do use `count(*)` in the ORDER BY clause instead of referencing the removed `rental_count` alias. Do add table aliases `T1`, `T2`, and `T3` instead of using full table names. The amended query now correctly groups by inventory_id only and orders by the count of rentals per inventory item, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT f.title, i.inventory_id, COUNT(r.rental_id) as rental_count\nFROM film f\nJOIN inventory i ON f.film_id = i.film_id\nJOIN rental r ON i.inventory_id = r.inventory_id\nGROUP BY f.title, i.inventory_id\nORDER BY rental_count DESC\nLIMIT 1;",
            "SELECT T1.title, T2.inventory_id\nFROM film T1\nJOIN inventory T2 ON T1.film_id = T2.film_id\nJOIN rental T3 ON T2.inventory_id = T3.inventory_id\nGROUP BY T2.inventory_id\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "947": {
        "db_id": "medicine_enzyme_interaction",
        "question": "What are the names of enzymes in the medicine named 'Amisulpride' that can serve as an 'inhibitor'?",
        "ground_truth": "SELECT T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id JOIN medicine AS T3 ON T2.medicine_id  =  T3.id WHERE T3.name  =  'Amisulpride' AND T2.interaction_type  =  'inhibitor'",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `e`, `mei`, and `m` for consistency. Do reference `T2.interaction_type` instead of `mei.interaction_type` to match the alias change. Do reference `T3.name` instead of `m.name` to maintain alias consistency throughout the query. The amended query now correctly matches the RIGHT_SQL's behavior with consistent table aliasing while preserving the same logical structure and filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT e.name \nFROM enzymes e \nJOIN medicine_enzyme_interactions mei ON e.id = mei.enzyme_id \nJOIN medicines m ON mei.medicine_id = m.id \nWHERE m.name = 'Amisulpride' AND mei.interaction_type = 'inhibitor';",
            "SELECT T1.name \nFROM enzyme T1\nJOIN medicine_enzyme_interaction T2 ON T1.id = T2.enzyme_id\nJOIN medicine T3 ON T2.medicine_id = T3.id\nWHERE T3.name = 'Amisulpride' AND T2.interaction_type = 'inhibitor'"
        ],
        "rule_sql": []
    },
    "1575": {
        "db_id": "customers_and_invoices",
        "question": "Show the number of customers for each gender.",
        "ground_truth": "SELECT gender ,  count(*) FROM Customers GROUP BY gender",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gender, COUNT(*) FROM customers GROUP BY gender;"
        ],
        "rule_sql": []
    },
    "3204": {
        "db_id": "college_1",
        "question": "For each classroom with at least 2 classes, how many classes are offered?",
        "ground_truth": "SELECT count(*) ,  class_room FROM CLASS GROUP BY class_room HAVING count(*)  >=  2",
        "amends": [
            "Do use `count(*)` and `class_room` in the SELECT list instead of `COUNT(*)` and `classroom`. Do reference table `CLASS` in the FROM clause instead of `classes`. Do group by `class_room` instead of `classroom`. The amended query now correctly counts records grouped by classroom from the CLASS table, filtering for groups with at least two records, matching the RIGHT_SQL's behavior.",
            "Do place `class_room` after the aggregate function instead of before it in the SELECT list, maintaining the same column order as in the GROUP BY clause. Do keep the same aggregate function `COUNT(*)` and the same HAVING condition `COUNT(*) >= 2` without any changes to the filtering logic. The amended query now correctly matches the RIGHT_SQL's behavior with identical output results.",
            "Do place `class_room` in the SELECT list after the aggregate instead of before it, maintaining the same column order as in the GROUP BY clause. Do keep the same aggregate function `COUNT(*)` and the same HAVING condition `COUNT(*) >= 2` without changes. The amended query now correctly positions the grouping column after the aggregate in the SELECT list while preserving the same logical behavior and output as the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT classroom, COUNT(*) FROM classes GROUP BY classroom HAVING COUNT(*) >= 2;",
            "SELECT class_room, COUNT(*) FROM CLASS GROUP BY class_room HAVING COUNT(*) >= 2",
            "SELECT class_room, COUNT(*) FROM CLASS GROUP BY class_room HAVING COUNT(*) >= 2",
            "SELECT COUNT(*), class_room FROM CLASS GROUP BY class_room HAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "3118": {
        "db_id": "behavior_monitoring",
        "question": "What are the monthly rentals of student addresses in Texas state?",
        "ground_truth": "SELECT T2.monthly_rental FROM Addresses AS T1 JOIN Student_Addresses AS T2 ON T1.address_id  =  T2.address_id WHERE T1.state_province_county  =  \"Texas\"",
        "amends": [
            "Do select `T2.monthly_rental` instead of `*` with all columns. Do use `FROM Addresses AS T1 JOIN Student_Addresses AS T2` instead of `FROM rentals` with a single table. Do apply join condition `ON T1.address_id = T2.address_id` instead of no join. Do filter with `WHERE T1.state_province_county = \"Texas\"` instead of `WHERE state = 'Texas' AND student = 'yes'`. Do remove `GROUP BY month` instead of keeping it. The amended query now correctly retrieves monthly rental data for students in Texas by joining address tables instead of using incorrect table and filter conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM rentals WHERE state = 'Texas' AND student = 'yes' GROUP BY month;",
            "SELECT T2.monthly_rental \nFROM Addresses AS T1 \nJOIN Student_Addresses AS T2 ON T1.address_id = T2.address_id \nWHERE T1.state_province_county = 'Texas'"
        ],
        "rule_sql": []
    },
    "1762": {
        "db_id": "gymnast",
        "question": "What is the most common hometown of gymnasts?",
        "ground_truth": "SELECT T2.Hometown FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID GROUP BY T2.Hometown ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do join `gymnast AS T1` with `people AS T2` on `T1.Gymnast_ID = T2.People_ID` instead of querying only the `gymnasts` table. Do select `T2.Hometown` instead of `hometown` to specify the source table. Do group by `T2.Hometown` instead of `hometown` to match the selected column. Do order by `COUNT(*) DESC` instead of `count DESC` to use the aggregate function directly rather than an alias. The amended query now correctly joins tables to access the hometown data and matches the RIGHT_SQL's behavior.",
            "Do remove `COUNT(*) AS count` from the SELECT list instead of including it, as the query only needs to return the hometown values. Do keep the same FROM clause with `gymnast AS T1 JOIN people AS T2` on `T1.Gymnast_ID = T2.People_ID` unchanged. Do maintain the same `GROUP BY T2.Hometown` grouping. Do preserve the `ORDER BY COUNT(*) DESC LIMIT 1` to find the hometown with the highest count of gymnasts. The amended query now correctly returns only the hometown name instead of both the hometown and count, while maintaining the same logic to identify the hometown with the most gymnasts, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT hometown, COUNT(*) as count FROM gymnasts GROUP BY hometown ORDER BY count DESC LIMIT 1;",
            "SELECT T2.Hometown, COUNT(*) AS count\nFROM gymnast AS T1\nJOIN people AS T2 ON T1.Gymnast_ID = T2.People_ID\nGROUP BY T2.Hometown\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT T2.Hometown \nFROM gymnast AS T1 \nJOIN people AS T2 ON T1.Gymnast_ID = T2.People_ID \nGROUP BY T2.Hometown \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5139": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "Find the product names whose average product price is below 1000000.",
        "ground_truth": "SELECT Product_Name FROM PRODUCTS GROUP BY Product_Name HAVING avg(Product_Price)  <  1000000",
        "amends": [
            "Do use `GROUP BY Product_Name` and `HAVING avg(Product_Price) < 1000000` instead of filtering individual rows with `WHERE price < 1000000`. Do select `Product_Name` instead of `product_name` and reference `Product_Price` instead of `price` for the aggregate calculation. The amended query now correctly groups products by name and filters based on average price rather than individual product prices, matching the intended behavior of the right SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name FROM products WHERE price < 1000000;",
            "SELECT Product_Name FROM Products GROUP BY Product_Name HAVING AVG(Product_Price) < 1000000"
        ],
        "rule_sql": []
    },
    "8": {
        "db_id": "department_management",
        "question": "In which year were most departments established?",
        "ground_truth": "SELECT creation FROM department GROUP BY creation ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use `creation` column instead of `year` for selection. Do add `GROUP BY creation` instead of omitting grouping. Do add `ORDER BY count(*) DESC` instead of ordering by nothing. Do add `LIMIT 1` instead of selecting all results. Do remove the `MAX()` aggregate function instead of keeping it since we're now grouping and ordering by count. The amended query now correctly identifies the most frequently occurring creation year by counting occurrences and selecting the top result, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(year) FROM departments;",
            "SELECT creation FROM department GROUP BY creation ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4317": {
        "db_id": "club_1",
        "question": "On average, how old are the members in the club \"Hopkins Student Enterprises\"?",
        "ground_truth": "SELECT avg(t3.age) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Hopkins Student Enterprises\"",
        "amends": [
            "Do specify the source tables with explicit joins instead of querying a single table, adding `club AS t1 JOIN member_of_club AS t2 ON t1.clubid = t2.clubid JOIN student AS t3 ON t2.stuid = t3.stuid` instead of just `FROM members`. Do reference the age column with its table alias as `t3.age` instead of just `age`. Do use the correct column name `clubname` in the WHERE filter instead of `club_name`, and use double quotes around the string literal instead of single quotes. The amended query now correctly joins the necessary tables to calculate the average age of students in the specified club."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age) FROM members WHERE club_name = 'Hopkins Student Enterprises';",
            "SELECT AVG(t3.age) AS average_age\nFROM Club AS t1\nJOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID\nJOIN Student AS t3 ON t2.StuID = t3.StuID\nWHERE t1.ClubName = \"Hopkins Student Enterprises\""
        ],
        "rule_sql": []
    },
    "2711": {
        "db_id": "storm_record",
        "question": "What are the names of regions that were not affected?",
        "ground_truth": "SELECT region_name FROM region WHERE region_id NOT IN (SELECT region_id FROM affected_region)",
        "amends": [
            "Do query from table `region` instead of `regions`. Do use a subquery with `NOT IN` condition on `region_id` instead of a direct filter on column `affected = 'yes'`. Do remove the `affected` column filter instead of keeping it. The amended query now correctly identifies regions not present in the affected_region table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region_name FROM regions WHERE affected = 'yes';",
            "SELECT Region_name FROM region WHERE Region_id NOT IN (SELECT Region_id FROM affected_region)"
        ],
        "rule_sql": []
    },
    "4556": {
        "db_id": "company_office",
        "question": "Count the number of distinct company industries.",
        "ground_truth": "SELECT count(DISTINCT Industry) FROM Companies",
        "amends": [
            "Do use `count(DISTINCT Industry)` instead of `COUNT(company)` to count distinct industry values rather than counting company occurrences per industry group. Do remove `GROUP BY industry` instead of keeping it since the aggregate function now operates across the entire table without grouping. Do reference `Industry` (capitalized) instead of `industry` (lowercase) to match the correct column name case. The amended query now correctly counts the number of distinct industries across all companies rather than counting companies per industry group, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(company) FROM companies GROUP BY industry;",
            "SELECT COUNT(DISTINCT Industry) FROM Companies;"
        ],
        "rule_sql": []
    },
    "1081": {
        "db_id": "match_season",
        "question": "Count the number of different official languages corresponding to countries that players who play Defender are from.",
        "ground_truth": "SELECT count(DISTINCT T1.Official_native_language) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  \"Defender\"",
        "amends": [
            "Do select `count(DISTINCT T1.Official_native_language)` instead of `COUNT(DISTINCT country.official_language)`. Do use `country AS T1` instead of `country` and add `match_season AS T2` instead of omitting it. Do join on `T1.Country_id = T2.Country` instead of `player.country_id = country.id`. Do filter on `T2.Position = \"Defender\"` instead of `player.position = 'Defender'` and remove the `player` table instead of keeping it. The amended query now correctly counts distinct official native languages from country records filtered by defender positions in match seasons."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT country.official_language) \nFROM player \nJOIN country ON player.country_id = country.id \nWHERE player.position = 'Defender';",
            "SELECT COUNT(DISTINCT T1.Official_native_language) \nFROM country AS T1 \nJOIN match_season AS T2 ON T1.Country_id = T2.Country \nWHERE T2.Position = 'Defender'"
        ],
        "rule_sql": []
    },
    "6588": {
        "db_id": "wine_1",
        "question": "Which 3 wineries produce the most wines made from white grapes?",
        "ground_truth": "SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  \"White\" GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT 3",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of no aliases. Do join `GRAPES AS T1` with `WINE AS T2` on `T1.GRAPE = T2.GRAPE` instead of querying only the `wines` table. Do filter on `T1.Color = \"White\"` instead of `grape_color = 'red'`. Do select only `T2.Winery` instead of both `winery` and `COUNT(*)`. Do use `ORDER BY count(*) DESC` instead of `ORDER BY wine_count DESC`. The amended query now correctly joins the grapes and wine tables to find wineries producing white wines ordered by count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT winery, COUNT(*) as wine_count \nFROM wines \nWHERE grape_color = 'red' \nGROUP BY winery \nORDER BY wine_count DESC \nLIMIT 3;",
            "SELECT T2.Winery\nFROM grapes AS T1\nJOIN wine AS T2 ON T1.Grape = T2.Grape\nWHERE T1.Color = 'White'\nGROUP BY T2.Winery\nORDER BY COUNT(*) DESC\nLIMIT 3"
        ],
        "rule_sql": []
    },
    "1624": {
        "db_id": "customers_and_invoices",
        "question": "How many different products correspond to each order id?",
        "ground_truth": "SELECT order_id ,  count(DISTINCT product_id) FROM Order_items GROUP BY order_id",
        "amends": [
            "Do select `count(DISTINCT product_id)` instead of `COUNT(*)` to count unique products rather than all rows. Do use table `Order_items` instead of `products` as the correct data source. Do group by `order_id` instead of the incorrect grouping. Do remove the unnecessary asterisk count and add the distinct product count to accurately track unique products per order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT order_id, COUNT(*) FROM products GROUP BY order_id;",
            "SELECT order_id, COUNT(DISTINCT product_id) AS unique_product_count FROM Order_Items GROUP BY order_id;"
        ],
        "rule_sql": []
    },
    "6363": {
        "db_id": "school_bus",
        "question": "How many drivers are from Hartford city or younger than 40?",
        "ground_truth": "SELECT count(*) FROM driver WHERE home_city  =  'Hartford' OR age  <  40",
        "amends": [
            "Do reference table `driver` instead of `drivers` for the correct table name. Do use `home_city` instead of `city` for the correct column name representing the city field. Do use `OR` instead of `AND` for the logical operator to include drivers who either live in Hartford OR are under 40 years old, rather than requiring both conditions simultaneously. The amended query now correctly counts drivers from Hartford or under age 40, matching the intended logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM drivers WHERE city = 'Hartford' AND age < 40;",
            "SELECT COUNT(*) FROM driver WHERE Home_city = 'Hartford' OR Age < 40"
        ],
        "rule_sql": []
    },
    "1313": {
        "db_id": "performance_attendance",
        "question": "Show different locations and the number of performances at each location.",
        "ground_truth": "SELECT LOCATION ,  COUNT(*) FROM performance GROUP BY LOCATION",
        "amends": [
            "Do group by `LOCATION` instead of `performance_id` to correctly count performances by location. Do reference table `performance` instead of `performances` to use the correct table name. The amended query now correctly counts performances grouped by location rather than by performance ID, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location, COUNT(*) FROM performances GROUP BY performance_id;",
            "SELECT Location, COUNT(Performance_ID) AS Number_of_Performances FROM performance GROUP BY Location;"
        ],
        "rule_sql": []
    },
    "2481": {
        "db_id": "movie_1",
        "question": "What are the different reviewer names, movie titles, and stars for every rating where the reviewer had the same name as the director?",
        "ground_truth": "SELECT DISTINCT T3.name ,  T2.title ,  T1.stars FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.director  =  T3.name",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT reviewer.name, movie.title, rating.stars\nFROM reviewer\nJOIN rating ON reviewer.rID = rating.rID\nJOIN movie ON rating.mID = movie.mID\nWHERE reviewer.name = movie.director;"
        ],
        "rule_sql": []
    },
    "5174": {
        "db_id": "music_2",
        "question": "What are all the labels?",
        "ground_truth": "SELECT DISTINCT label FROM Albums",
        "amends": [
            "Do select only the `label` column instead of selecting all columns with `*`. Do add `DISTINCT` to return unique labels instead of returning duplicates. Do change the table source to `Albums` instead of `labels`. Do remove the unnecessary semicolon at the end. The amended query now correctly returns distinct label values from the Albums table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM labels;",
            "SELECT DISTINCT Label FROM Albums"
        ],
        "rule_sql": []
    },
    "3019": {
        "db_id": "loan_1",
        "question": "What are the names of banks in the state of New York?",
        "ground_truth": "SELECT bname FROM bank WHERE state  =  'New York'",
        "amends": [
            "Do select `bname` instead of `name` and reference table `bank` instead of `banks`. Do filter for state `'New York'` instead of `'California'`."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM banks WHERE state = 'California';",
            "SELECT bname FROM bank WHERE state = 'New York';"
        ],
        "rule_sql": []
    },
    "1690": {
        "db_id": "epinions_1",
        "question": "List all information in the item table.",
        "ground_truth": "SELECT * FROM item",
        "amends": [
            "Do reference table `item` instead of `items` to ensure the query targets the correct database table. This amendment corrects the table name to match the intended schema structure, ensuring the query retrieves data from the proper source table rather than a non-existent or incorrectly named table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM items;",
            "SELECT * FROM item;"
        ],
        "rule_sql": []
    },
    "1535": {
        "db_id": "insurance_and_eClaims",
        "question": "Find the names of all the customers and staff members.",
        "ground_truth": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff",
        "amends": [
            "Do select `customer_details` from the `customers` table instead of `name`, and do select `staff_details` from the `staff` table instead of `name` to properly match the column names in each respective table. The amended query now correctly retrieves the appropriate details columns from each table while maintaining the UNION operation structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM customers UNION SELECT name FROM staff;",
            "SELECT Customer_Details AS Name FROM Customers\nUNION\nSELECT Staff_Details AS Name FROM Staff;"
        ],
        "rule_sql": []
    },
    "5106": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "What is the description of the marketing region China?",
        "ground_truth": "SELECT Marketing_Region_Descriptrion FROM Marketing_Regions WHERE Marketing_Region_Name  =  \"China\"",
        "amends": [
            "Do reference the column `Marketing_Region_Descriptrion` instead of `description` in the SELECT list. Do reference the table `Marketing_Regions` instead of `marketing_regions` in the FROM clause. Do use the filter condition `Marketing_Region_Name = \"China\"` instead of `region_name = 'China'` in the WHERE clause, changing both the column reference and the quote style. The amended query now correctly matches the RIGHT_SQL's behavior with proper column and table names."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM marketing_regions WHERE region_name = 'China';",
            "SELECT Marketing_Region_Descriptrion FROM Marketing_Regions WHERE Marketing_Region_Name = 'China';"
        ],
        "rule_sql": []
    },
    "6855": {
        "db_id": "flight_4",
        "question": "List the cities which have more than one airport and number of airports.",
        "ground_truth": "SELECT city ,  count(*) FROM airports GROUP BY city HAVING count(*)  >  1",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, COUNT(*) as airport_count FROM airports GROUP BY city HAVING airport_count > 1"
        ],
        "rule_sql": []
    },
    "517": {
        "db_id": "allergy_1",
        "question": "Show all allergy type with number of students affected.",
        "ground_truth": "SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype",
        "amends": [
            "Do join `Allergy_type AS T2` instead of querying `students` directly. Do reference `T2.allergytype` in the SELECT list instead of `allergy_type`. Do add a join condition `ON T1.allergy = T2.allergy` instead of missing the table relationship. Do use the joined table `Has_allergy AS T1` as the source instead of the base `students` table. The amended query now correctly counts allergies by joining the allergy mapping table with the allergy type reference table to ensure accurate categorization."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT allergy_type, COUNT(*) FROM students GROUP BY allergy_type;",
            "SELECT T2.AllergyType, COUNT(T1.StuID) AS NumberOfStudentsAffected\nFROM Has_Allergy AS T1\nJOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy\nGROUP BY T2.AllergyType"
        ],
        "rule_sql": []
    },
    "1856": {
        "db_id": "wrestler",
        "question": "What are the names of wrestlers and the elimination moves?",
        "ground_truth": "SELECT T2.Name ,  T1.Elimination_Move FROM elimination AS T1 JOIN wrestler AS T2 ON T1.Wrestler_ID  =  T2.Wrestler_ID",
        "amends": [
            "Do select `T2.Name` and `T1.Elimination_Move` instead of `wrestler_name` and `move_name`. Do use table aliases `T1` and `T2` instead of no aliases. Do join from `elimination AS T1` instead of `wrestlers`. Do join to `wrestler AS T2` instead of `moves`. Do use join condition `T1.Wrestler_ID = T2.Wrestler_ID` instead of `wrestlers.wrestler_id = moves.wrestler_id`. Do remove the `WHERE elimination = 'yes'` filter instead of keeping it, as the elimination logic is now handled through the elimination table join. The amended query now correctly retrieves elimination moves from the dedicated elimination table joined with wrestler information."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT wrestler_name, move_name FROM wrestlers JOIN moves ON wrestlers.wrestler_id = moves.wrestler_id WHERE elimination = 'yes';",
            "SELECT T2.Name, T1.Elimination_Move FROM Elimination AS T1 JOIN wrestler AS T2 ON T1.Wrestler_ID = T2.Wrestler_ID"
        ],
        "rule_sql": []
    },
    "61": {
        "db_id": "student_assessment",
        "question": "What are the first and last names of all the candidates?",
        "ground_truth": "SELECT T2.first_name ,  T2.last_name FROM candidates AS T1 JOIN people AS T2 ON T1.candidate_id = T2.person_id",
        "amends": [
            "Do add `T2.last_name` to the SELECT list instead of only selecting `first_name`. Do change the FROM source to `candidates AS T1 JOIN people AS T2` instead of just `candidates`. Do add the JOIN condition `ON T1.candidate_id = T2.person_id` instead of having no join condition. Do qualify the column reference as `T2.first_name` instead of the unqualified `first_name`. The amended query now correctly joins the candidates table with the people table to retrieve both first and last names from the associated person records."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM candidates;",
            "SELECT T2.first_name, T2.last_name FROM Candidates AS T1 JOIN People AS T2 ON T1.candidate_id = T2.person_id"
        ],
        "rule_sql": []
    },
    "1855": {
        "db_id": "wrestler",
        "question": "Return the elimination movies of wrestlers on Team Orton.",
        "ground_truth": "SELECT Elimination_Move FROM Elimination WHERE Team  =  \"Team Orton\"",
        "amends": [
            "Do select `Elimination_Move` instead of `*` to return only the specific column needed. Do query from `Elimination` table instead of `movies` to use the correct data source. Do filter on `Team = \"Team Orton\"` instead of `wrestler_team = 'Team Orton' AND movie_type = 'elimination'` to use the proper column name and remove the unnecessary movie_type condition. The amended query now correctly retrieves elimination moves for Team Orton from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM movies WHERE wrestler_team = 'Team Orton' AND movie_type = 'elimination';",
            "SELECT Elimination_Move FROM Elimination WHERE Team = 'Team Orton'"
        ],
        "rule_sql": []
    },
    "3479": {
        "db_id": "hr_1",
        "question": "find the name of all departments that do actually have one or more employees assigned to them.",
        "ground_truth": "SELECT DISTINCT T2.department_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id",
        "amends": [
            "Do select `DISTINCT T2.department_name` instead of `name` from the departments table. Do add a `JOIN` with `employees AS T1` on `T1.department_id = T2.department_id` instead of querying departments alone. Do remove the `WHERE employee_count = 0` filter instead of keeping it, as the logic now correctly identifies departments that actually have employees through the join relationship rather than relying on a potentially incorrect count field. The amended query now matches RIGHT_SQL's behavior by returning distinct department names that have associated employees."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM departments WHERE employee_count = 0;",
            "SELECT DISTINCT T2.department_name FROM departments AS T2 JOIN employees AS T1 ON T1.department_id = T2.department_id"
        ],
        "rule_sql": []
    },
    "4004": {
        "db_id": "ship_mission",
        "question": "List the name of ships whose nationality is not \"United States\".",
        "ground_truth": "SELECT Name FROM ship WHERE Nationality != \"United States\"",
        "amends": [
            "Do reference table `ship` instead of `ships` in the FROM clause. Do use column `Name` instead of `name` in the SELECT list. Do use inequality filter `Nationality != \"United States\"` instead of equality filter `nationality = 'United States'` in the WHERE clause. The amended query now correctly selects ships that are not from the United States instead of those that are."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM ships WHERE nationality = 'United States'",
            "SELECT Name FROM ship WHERE Nationality != \"United States\""
        ],
        "rule_sql": []
    },
    "4669": {
        "db_id": "college_3",
        "question": "Find the first names of faculties of rank Professor in alphabetic order.",
        "ground_truth": "SELECT Fname FROM FACULTY WHERE Rank  =  \"Professor\" ORDER BY Fname",
        "amends": [
            "Do use column name `Fname` instead of `first_name` and table name `FACULTY` instead of `faculties` in the SELECT clause and FROM source. Do use column name `Rank` instead of `rank` and value `\"Professor\"` instead of `'Professor'` in the WHERE filter. Do remove the `DESC` ordering modifier instead of keeping it in the ORDER BY clause. The amended query now matches RIGHT_SQL's behavior with correct column and table references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM faculties WHERE rank = 'Professor' ORDER BY first_name DESC;",
            "SELECT Fname FROM Faculty WHERE Rank = \"Professor\" ORDER BY Fname"
        ],
        "rule_sql": []
    },
    "5732": {
        "db_id": "dorm_1",
        "question": "Find the first and last name of students who are not in the largest major.",
        "ground_truth": "SELECT fname ,  lname FROM student WHERE major != (SELECT major FROM student GROUP BY major ORDER BY count(*) DESC LIMIT 1)",
        "amends": [
            "Do use column names `fname` and `lname` instead of `first_name` and `last_name`. Do reference table `student` instead of `students`. Do filter on column `major` instead of `major_id`. Do use subquery column `major` instead of `major_id`. Do use aggregate function `count(*)` instead of `COUNT(*)`. The amended query now correctly identifies students whose major differs from the most popular major by comparing the appropriate column values."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM students WHERE major_id != (SELECT major_id FROM students GROUP BY major_id ORDER BY COUNT(*) DESC LIMIT 1);",
            "SELECT fname, lname FROM Student WHERE major != (SELECT major FROM Student GROUP BY major ORDER BY COUNT(*) DESC LIMIT 1)"
        ],
        "rule_sql": []
    },
    "6135": {
        "db_id": "customers_and_addresses",
        "question": "Find the name of customers who did not pay with Cash.",
        "ground_truth": "SELECT customer_name FROM customers WHERE payment_method != 'Cash'",
        "amends": [
            "Do select `customer_name` instead of `name` and use `!= 'Cash'` instead of `= 'Cash'` in the WHERE filter, changing the payment method condition from equality to inequality to exclude rather than include cash payments."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM customers WHERE payment_method = 'Cash';",
            "SELECT customer_name FROM Customers WHERE payment_method != 'Cash';"
        ],
        "rule_sql": []
    },
    "5701": {
        "db_id": "dorm_1",
        "question": "How many different majors are there and how many different city codes are there for each student?",
        "ground_truth": "SELECT count(DISTINCT major) ,  count(DISTINCT city_code) FROM student",
        "amends": [
            "Do remove the `GROUP BY student_id` clause instead of grouping by individual students, as this was causing incorrect aggregation by student rather than counting distinct majors and city codes across all students. Do remove the column aliases `AS num_majors` and `AS num_city_codes` instead of keeping them, as the right query uses unaliased counts. Do use the correct table name `student` instead of `students` to match the schema. The amended query now correctly counts distinct majors and distinct city codes across the entire student table without grouping, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT major) AS num_majors, COUNT(DISTINCT city_code) AS num_city_codes FROM students GROUP BY student_id;",
            "SELECT COUNT(DISTINCT Major) AS num_majors, COUNT(DISTINCT city_code) AS num_city_codes FROM Student;"
        ],
        "rule_sql": []
    },
    "4944": {
        "db_id": "soccer_2",
        "question": "What is the total enrollment number of all colleges?",
        "ground_truth": "SELECT sum(enr) FROM College",
        "amends": [
            "Do reference the table as `College` instead of `colleges` and use the column name `enr` instead of `enrollment` in both the SELECT list and WHERE filter, while maintaining the same aggregation logic and filter condition. The amended query now correctly references the actual table and column names to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(enrollment) FROM colleges WHERE enrollment > 0;",
            "SELECT SUM(enr) AS total_enrollment FROM College;"
        ],
        "rule_sql": []
    },
    "2471": {
        "db_id": "movie_1",
        "question": "What are the titles and directors of all movies that have a rating higher than the average James Cameron film rating?",
        "ground_truth": "SELECT T2.title ,  T2.director FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  >  (SELECT avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T2.director  =  \"James Cameron\")",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of no aliases. Do join `Rating AS T1` with `Movie AS T2` on `T1.mID = T2.mID` instead of querying only the `movies` table. Do filter on `T1.stars > subquery` instead of `rating > subquery`. Do reference `T1.stars` in the aggregate subquery instead of `rating`. Do join tables in the subquery on `T1.mID = T2.mID` instead of using a single table. Do filter the subquery on `T2.director = \"James Cameron\"` instead of `director = 'James Cameron'`. The amended query now correctly compares movie ratings against the average rating of James Cameron's movies by properly joining the Rating and Movie tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, director FROM movies WHERE rating > (SELECT AVG(rating) FROM movies WHERE director = 'James Cameron')",
            "SELECT T2.title, T2.director\nFROM Rating AS T1\nJOIN Movie AS T2 ON T1.mID = T2.mID\nWHERE T1.stars > (\n    SELECT AVG(T1.stars)\n    FROM Rating AS T1\n    JOIN Movie AS T2 ON T1.mID = T2.mID\n    WHERE T2.director = \"James Cameron\"\n)"
        ],
        "rule_sql": []
    },
    "1370": {
        "db_id": "college_2",
        "question": "Find the names of the top 3 departments that provide the largest amount of courses?",
        "ground_truth": "SELECT dept_name FROM course GROUP BY dept_name ORDER BY count(*) DESC LIMIT 3",
        "amends": [
            "Do select `dept_name` instead of `department_name` and remove the `COUNT(*) as course_count` column from the SELECT list. Do use `course` as the FROM source instead of `departments`. Do remove the explicit GROUP BY column reference since it's implied by the SELECT list. Do use `count(*)` directly in the ORDER BY clause instead of referencing the alias `course_count`. Do maintain the DESC ordering and LIMIT 3 clause as in the original query. The amended query now correctly counts courses by department name from the course table instead of attempting to count from a departments table, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT department_name, COUNT(*) as course_count \nFROM departments \nGROUP BY department_name \nORDER BY course_count DESC \nLIMIT 3;",
            "SELECT dept_name FROM course GROUP BY dept_name ORDER BY count(*) DESC LIMIT 3"
        ],
        "rule_sql": []
    },
    "5956": {
        "db_id": "cre_Theme_park",
        "question": "What are the names and ids of the tourist attractions that are visited at most once?",
        "ground_truth": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1",
        "amends": [
            "Do add `JOIN VISITS AS T2` with `ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID` instead of querying only the `tourist_attractions` table. Do change the SELECT list to `T1.Name, T1.Tourist_Attraction_ID` instead of `name, id`. Do add `GROUP BY T2.Tourist_Attraction_ID` instead of no grouping. Do move the count filter to `HAVING count(*) <= 1` instead of `WHERE visits <= 1`. Do use proper table aliasing with `AS T1` and `AS T2` instead of no aliases. The amended query now correctly counts visits per attraction and filters for those with exactly one visit, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, id FROM tourist_attractions WHERE visits <= 1;",
            "SELECT T1.Name, T1.Tourist_Attraction_ID\nFROM Tourist_Attractions AS T1\nJOIN Visits AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID\nGROUP BY T2.Tourist_Attraction_ID\nHAVING COUNT(*) <= 1"
        ],
        "rule_sql": []
    },
    "4782": {
        "db_id": "department_store",
        "question": "Give the maximum and minimum product prices for each product type, grouped and ordered by product type.",
        "ground_truth": "SELECT max(product_price) ,  min(product_price) ,  product_type_code FROM products GROUP BY product_type_code ORDER BY product_type_code",
        "amends": [
            "Do use `max(product_price)` and `min(product_price)` instead of `MAX(price)` and `MIN(price)` to reference the correct column names. Do use `product_type_code` instead of `product_type` for both the grouping and ordering to match the actual column name. Do remove the aliases `max_price` and `min_price` instead of keeping them since they are not needed in the result set. The amended query now correctly aggregates by product price values using the proper column names and grouping criteria.",
            "Do place `product_type_code` at the end of the SELECT list instead of at the beginning, and do remove the aliases `max_price` and `min_price` instead of keeping them, while maintaining the same GROUP BY and ORDER BY logic. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_type, MAX(price) as max_price, MIN(price) as min_price FROM products GROUP BY product_type ORDER BY product_type;",
            "SELECT product_type_code, MAX(product_price) AS max_price, MIN(product_price) AS min_price FROM Products GROUP BY product_type_code ORDER BY product_type_code",
            "SELECT MAX(product_price), MIN(product_price), product_type_code FROM Products GROUP BY product_type_code ORDER BY product_type_code"
        ],
        "rule_sql": []
    },
    "4892": {
        "db_id": "school_player",
        "question": "List the locations of schools that do not have any player.",
        "ground_truth": "SELECT LOCATION FROM school WHERE School_ID NOT IN (SELECT School_ID FROM Player)",
        "amends": [
            "Do select `LOCATION` instead of `location` and use table `school` instead of `schools`. Do change the filter to `School_ID NOT IN` subquery instead of `player_id IS NULL`. Do add a correlated subquery `SELECT School_ID FROM Player` instead of omitting it, which properly identifies schools without associated players by checking against the Player table's School_ID references rather than relying on a potentially missing player_id column in the schools table. The amended query now correctly matches the intended behavior of finding school locations that have no corresponding entries in the Player table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location FROM schools WHERE player_id IS NULL;",
            "SELECT Location FROM school WHERE School_ID NOT IN (SELECT School_ID FROM player)"
        ],
        "rule_sql": []
    },
    "2183": {
        "db_id": "formula_1",
        "question": "Find all the forenames of distinct drivers who was in position 1 as standing and won?",
        "ground_truth": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1",
        "amends": [
            "Do add table `driverstandings AS T2` with a `JOIN` on `T1.driverid = T2.driverid` instead of querying only the `drivers` table. Do reference `position = 1` and `wins = 1` from `T2` instead of from the original table with `standing = 'won'`. Do keep `DISTINCT` on `T1.forename` instead of the original column reference. The amended query now correctly joins driver standings data to identify race winners."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT forename FROM drivers WHERE position = 1 AND standing = 'won';",
            "SELECT DISTINCT T1.forename\nFROM drivers AS T1\nJOIN driverStandings AS T2 ON T1.driverId = T2.driverId\nWHERE T2.position = 1 AND T2.wins = 1"
        ],
        "rule_sql": []
    },
    "4091": {
        "db_id": "student_1",
        "question": "For each fourth-grade classroom, show the classroom number and the total number of students using it.",
        "ground_truth": "SELECT classroom ,  count(*) FROM list WHERE grade  =  \"4\" GROUP BY classroom",
        "amends": [
            "Do reference table `list` instead of `students` and column `classroom` instead of `classroom_number` in the SELECT clause and GROUP BY. Do use string literal `\"4\"` instead of numeric `4` in the WHERE filter for the grade condition. The amended query now correctly counts students by classroom for grade 4 using the appropriate table structure and data type handling."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT classroom_number, COUNT(*) FROM students WHERE grade = 4 GROUP BY classroom_number;",
            "SELECT Classroom, COUNT(*) AS TotalStudents FROM list WHERE Grade = \"4\" GROUP BY Classroom"
        ],
        "rule_sql": []
    },
    "3241": {
        "db_id": "college_1",
        "question": "How many students enrolled in class ACCT-211?",
        "ground_truth": "SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code WHERE T1.crs_code  =  'ACCT-211'",
        "amends": [
            "Do use `FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code = T2.class_code` instead of `FROM students` with no joins. Do add the join condition `ON T1.class_code = T2.class_code` instead of omitting it. Do change the filter to `WHERE T1.crs_code = 'ACCT-211'` instead of `WHERE class = 'ACCT-211'` to reference the correct table and column. The amended query now correctly joins the CLASS and enroll tables and filters by course code instead of incorrectly querying a non-existent students table with a class filter, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE class = 'ACCT-211';",
            "SELECT COUNT(*) FROM CLASS AS T1 JOIN ENROLL AS T2 ON T1.CLASS_CODE = T2.CLASS_CODE WHERE T1.CRS_CODE = 'ACCT-211'"
        ],
        "rule_sql": []
    },
    "3899": {
        "db_id": "hospital_1",
        "question": "Find the department with the most employees.",
        "ground_truth": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;",
        "amends": [
            "Do select `name` from the `department` table instead of `department` and `COUNT(*) as employee_count` from the `employees` table. Do group by `departmentID` instead of `department`. Do order by `count(departmentID)` in descending order instead of `employee_count` in ascending order. Do use `LIMIT 1` to return a single result, maintaining the same limit behavior. The amended query now correctly retrieves the department name with the highest count of department IDs rather than counting employees per department."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT department, COUNT(*) as employee_count FROM employees GROUP BY department ORDER BY employee_count ASC LIMIT 1;",
            "SELECT d.Name \nFROM Department d \nGROUP BY d.DepartmentID \nORDER BY COUNT(d.DepartmentID) DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "206": {
        "db_id": "bike_1",
        "question": "What are the zip codes that have an average mean humidity below 70 and had at least 100 trips come through there?",
        "ground_truth": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100",
        "amends": [
            "Do use `INTERSECT` to find common zip codes instead of joining tables directly. Do calculate `avg(mean_humidity)` in the `HAVING` clause of the first subquery instead of in the `SELECT` list with an alias. Do use `count(*)` in the second subquery's `HAVING` clause instead of `COUNT(trip_id)`. Do remove the `WHERE` clause filter on the alias `avg_humidity` instead of keeping it, as aggregate filters must be in `HAVING`. Do separate the queries into two distinct `SELECT` statements with their own `GROUP BY` and `HAVING` clauses instead of a single joined query. Do use the correct table names `weather` and `trip` instead of `weather_data` and `trips`. The amended query now correctly identifies zip codes that meet both humidity and trip count criteria through set intersection."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT zip_code, AVG(mean_humidity) as avg_humidity, COUNT(trip_id) as trip_count\nFROM weather_data w\nJOIN trips t ON w.zip_code = t.zip_code\nWHERE avg_humidity < 70\nGROUP BY zip_code\nHAVING trip_count >= 100;",
            "SELECT zip_code FROM weather GROUP BY zip_code HAVING AVG(mean_humidity) < 70\nINTERSECT\nSELECT zip_code FROM trip GROUP BY zip_code HAVING COUNT(*) >= 100"
        ],
        "rule_sql": []
    },
    "4225": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "Find the starting date and ending data in location for the document named \"Robin CV\".",
        "ground_truth": "SELECT T1.date_in_location_from ,  T1.date_in_locaton_to FROM Document_locations AS T1 JOIN All_documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.document_name  =  \"Robin CV\"",
        "amends": [
            "Do select `T1.date_in_location_from` and `T1.date_in_locaton_to` instead of `start_date` and `end_date`. Do use `FROM Document_locations AS T1 JOIN All_documents AS T2` instead of `FROM documents`. Do add join condition `ON T1.document_id = T2.document_id` instead of omitting it. Do filter on `T2.document_name = \"Robin CV\"` instead of `name = 'Robin CV'`. Do remove `location IS NOT NULL` filter instead of keeping it. The amended query now correctly joins the document locations and documents tables to retrieve the appropriate date ranges for the specified document."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT start_date, end_date FROM documents WHERE name = 'Robin CV' AND location IS NOT NULL;",
            "SELECT T1.date_in_location_from, T1.date_in_locaton_to \nFROM Document_Locations AS T1 \nJOIN All_Documents AS T2 ON T1.document_id = T2.document_id \nWHERE T2.document_name = 'Robin CV'"
        ],
        "rule_sql": []
    },
    "1039": {
        "db_id": "phone_1",
        "question": "List the hardware model name for the phones that were produced by \"Nokia Corporation\" or whose screen mode type is \"Graphics.\"",
        "ground_truth": "SELECT DISTINCT T2.Hardware_Model_name FROM screen_mode AS T1 JOIN phone AS T2 ON T1.Graphics_mode = T2.screen_mode WHERE T1.Type  =  \"Graphics\" OR t2.Company_name  =  \"Nokia Corporation\"",
        "amends": [
            "Do use `DISTINCT T2.Hardware_Model_name` instead of `model_name` without distinct. Do join `screen_mode AS T1` with `phone AS T2` on `T1.Graphics_mode = T2.screen_mode` instead of querying a single `phones` table. Do filter with `T1.Type = \"Graphics\" OR T2.Company_name = \"Nokia Corporation\"` instead of `manufacturer = 'Nokia Corporation' OR screen_mode = 'Graphics'`. The amended query now correctly joins related tables and uses proper column references to match the intended logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model_name FROM phones WHERE manufacturer = 'Nokia Corporation' OR screen_mode = 'Graphics';",
            "SELECT DISTINCT T2.Hardware_Model_name\nFROM screen_mode AS T1\nJOIN phone AS T2 ON T1.Graphics_mode = T2.screen_mode\nWHERE T1.Type = \"Graphics\" OR T2.Company_name = \"Nokia Corporation\""
        ],
        "rule_sql": []
    },
    "3121": {
        "db_id": "behavior_monitoring",
        "question": "What is the zip code of the address where the teacher with first name \"Lyla\" lives?",
        "ground_truth": "SELECT T1.zip_postcode FROM Addresses AS T1 JOIN Teachers AS T2 ON T1.address_id  =  T2.address_id WHERE T2.first_name  =  \"Lyla\"",
        "amends": [
            "Do use `T1.zip_postcode` instead of `zip_code` in the SELECT list. Do join `Addresses AS T1` with `Teachers AS T2` instead of querying only the addresses table. Do use the join condition `T1.address_id = T2.address_id` instead of no join. Do filter on `T2.first_name = \"Lyla\"` instead of `teacher_first_name = 'Lyla'` to reference the correct table and column. Do use double quotes for the string literal instead of single quotes. The amended query now correctly joins the tables and references the appropriate columns to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT zip_code FROM addresses WHERE teacher_first_name = 'Lyla';",
            "SELECT T1.zip_postcode \nFROM Addresses AS T1 \nJOIN Teachers AS T2 ON T1.address_id = T2.address_id \nWHERE T2.first_name = \"Lyla\""
        ],
        "rule_sql": []
    },
    "6167": {
        "db_id": "music_4",
        "question": "Please show the songs that have result \"nominated\" at music festivals.",
        "ground_truth": "SELECT T2.Song FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T1.Result  =  \"Nominated\"",
        "amends": [
            "Do select `T2.Song` instead of `*` to specify the exact column needed. Do use `music_festival AS T1 JOIN volume AS T2` instead of just `songs` to properly join the two related tables. Do apply the join condition `ON T1.Volume = T2.Volume_ID` instead of no join condition to correctly relate the festival and volume data. Do filter on `T1.Result = \"Nominated\"` instead of `festival_result = 'nominated'` to use the correct table and column name with proper case sensitivity. The amended query now correctly retrieves nominated songs by joining festival results with song volume information."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM songs WHERE festival_result = 'nominated';",
            "SELECT T2.Song FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume = T2.Volume_ID WHERE T1.Result = \"Nominated\""
        ],
        "rule_sql": []
    },
    "3600": {
        "db_id": "music_1",
        "question": "What is the maximum and minimum resolution of all songs that are approximately 3 minutes long?",
        "ground_truth": "SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE \"3:%\"",
        "amends": [
            "Do join `files AS T1` to `song AS T2` on `T1.f_id = T2.f_id` instead of querying `songs` table directly without any joins. Do filter on `T1.duration LIKE \"3:%\"` instead of `duration = 180` to match time format patterns rather than exact numeric values. Do reference `T2.resolution` for both `MAX` and `MIN` aggregates instead of just `resolution` from the original table. The amended query now correctly joins the related tables and uses appropriate pattern matching for duration values, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(resolution), MIN(resolution) FROM songs WHERE duration = 180;",
            "SELECT MAX(T2.resolution) AS max_resolution, MIN(T2.resolution) AS min_resolution FROM files AS T1 JOIN song AS T2 ON T1.f_id = T2.f_id WHERE T1.duration LIKE '3:%'"
        ],
        "rule_sql": []
    },
    "3805": {
        "db_id": "e_learning",
        "question": "What are the addresses of the course authors who teach either \"operating system\" or \"data structure\" course.",
        "ground_truth": "SELECT T1.address_line_1 FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id WHERE T2.course_name  =  \"operating system\" OR T2.course_name  =  \"data structure\"",
        "amends": [
            "Do select `T1.address_line_1` instead of `address` and use proper table aliases. Do add `JOIN Courses AS T2` instead of querying only the authors table. Do use `ON T1.author_id = T2.author_id` instead of missing the join condition entirely. Do reference `T2.course_name` in the WHERE clause instead of `course_name` without table qualification. Do use double quotes for string literals instead of single quotes. The amended query now correctly joins the tables and properly qualifies column references to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address FROM authors WHERE course_name = 'operating system' OR course_name = 'data structure'",
            "SELECT T1.address_line_1 \nFROM Course_Authors_and_Tutors AS T1\nJOIN Courses AS T2 ON T1.author_id = T2.author_id\nWHERE T2.course_name = \"operating system\" OR T2.course_name = \"data structure\""
        ],
        "rule_sql": []
    },
    "5077": {
        "db_id": "device",
        "question": "What are the different software platforms for devices, and how many devices have each?",
        "ground_truth": "SELECT Software_Platform ,  COUNT(*) FROM device GROUP BY Software_Platform",
        "amends": [
            "Do reference the `Software_Platform` column instead of `platform` and use the `device` table instead of `devices` to match the correct schema. The amended query now correctly counts records grouped by software platform from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT platform, COUNT(*) FROM devices GROUP BY platform;",
            "SELECT Software_Platform, COUNT(*) AS device_count FROM device GROUP BY Software_Platform;"
        ],
        "rule_sql": []
    },
    "1927": {
        "db_id": "protein_institute",
        "question": "Show the protein name and the institution name.",
        "ground_truth": "SELECT T2.protein_name ,  T1.institution FROM institution AS T1 JOIN protein AS T2 ON T1.institution_id  =  T2.institution_id",
        "amends": [
            "Do reference `T2.protein_name` and `T1.institution` instead of `protein_name` and `institution_name`. Do use table aliases `T1` and `T2` instead of no aliases. Do specify `institution AS T1` and `protein AS T2` instead of `proteins` and `institutions`. Do join on `T1.institution_id = T2.institution_id` instead of `proteins.institution_id = institutions.id`. The amended query now correctly matches the intended behavior with proper table references and join conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT protein_name, institution_name FROM proteins JOIN institutions ON proteins.institution_id = institutions.id",
            "SELECT T2.protein_name, T1.Institution FROM Institution AS T1 JOIN protein AS T2 ON T1.Institution_id = T2.Institution_id"
        ],
        "rule_sql": []
    },
    "6103": {
        "db_id": "customers_and_addresses",
        "question": "What is the channel code and contact number of the customer contact channel that was active for the longest time?",
        "ground_truth": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1)",
        "amends": [
            "Do add a WHERE filter with a subquery that calculates `active_to_date - active_from_date` instead of omitting any filtering. Do remove the ORDER BY `active_time DESC` and LIMIT 1 from the main query instead of keeping them. Do add a correlated subquery that selects the maximum duration difference by ordering `active_to_date - active_from_date DESC` with LIMIT 1 instead of using a simple top record selection. The amended query now correctly identifies records with the maximum duration between active dates rather than simply the most recently active record, matching the RIGHT_SQL's behavior.",
            "Do use direct date subtraction `active_to_date - active_from_date` instead of `julianday(active_to_date) - julianday(active_from_date)` for simpler date arithmetic. Do calculate the maximum duration using `ORDER BY (active_to_date - active_from_date) DESC LIMIT 1` instead of `MAX(julianday(active_to_date) - julianday(active_from_date))` with a subquery filter. Do remove the `WHERE active_to_date IS NOT NULL` condition from the subquery instead of keeping it, as the ordering approach naturally handles null values. The amended query now correctly identifies records with the maximum date difference using a more efficient approach that matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT channel_code, contact_number FROM customer_contact_channels ORDER BY active_time DESC LIMIT 1;",
            "SELECT channel_code, contact_number\nFROM Customer_Contact_Channels\nWHERE (julianday(active_to_date) - julianday(active_from_date)) = (\n    SELECT MAX(julianday(active_to_date) - julianday(active_from_date))\n    FROM Customer_Contact_Channels\n    WHERE active_to_date IS NOT NULL\n)",
            "SELECT channel_code, contact_number\nFROM Customer_Contact_Channels\nWHERE (active_to_date - active_from_date) = (\n    SELECT (active_to_date - active_from_date)\n    FROM Customer_Contact_Channels\n    ORDER BY (active_to_date - active_from_date) DESC\n    LIMIT 1\n)"
        ],
        "rule_sql": []
    },
    "6619": {
        "db_id": "train_station",
        "question": "What are the names of the stations which serve both \"Ananthapuri Express\" and \"Guruvayur Express\" trains?",
        "ground_truth": "SELECT T2.name FROM train_station AS T1 JOIN station AS T2 ON T1.station_id  =  T2.station_id JOIN train AS T3 ON T3.train_id  =  T1.train_id WHERE T3.Name  =  \"Ananthapuri Express\" INTERSECT SELECT T2.name FROM train_station AS T1 JOIN station AS T2 ON T1.station_id  =  T2.station_id JOIN train AS T3 ON T3.train_id  =  T1.train_id WHERE T3.Name  =  \"Guruvayur Express\"",
        "amends": [
            "Do use a three-table join structure with `train_station`, `station`, and `train` tables instead of querying a single `stations` table. Do join on `train_id` and `station_id` keys instead of attempting to filter on multiple `train_name` values in a single table. Do use `INTERSECT` to find common stations between two trains instead of using `AND` with conflicting `train_name` conditions that would never return results. Do reference columns with proper table aliases like `T2.name` and `T3.Name` instead of simple column names without table context. Do use double quotes for string literals instead of single quotes. The amended query correctly identifies stations shared by both specified trains through set intersection rather than the impossible condition in the original query."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT station_name FROM stations WHERE train_name = 'Ananthapuri Express' AND train_name = 'Guruvayur Express'",
            "SELECT s.Name \nFROM station s\nJOIN train_station ts ON s.Station_ID = ts.Station_ID\nJOIN train t ON ts.Train_ID = t.Train_ID\nWHERE t.Name = \"Ananthapuri Express\"\nINTERSECT\nSELECT s.Name \nFROM station s\nJOIN train_station ts ON s.Station_ID = ts.Station_ID\nJOIN train t ON ts.Train_ID = t.Train_ID\nWHERE t.Name = \"Guruvayur Express\""
        ],
        "rule_sql": []
    },
    "2198": {
        "db_id": "formula_1",
        "question": "What are the different ids and stop durations of all the drivers whose stop lasted longer than the driver in the race with the id 841?",
        "ground_truth": "SELECT DISTINCT driverid ,  STOP FROM pitstops WHERE duration  >  (SELECT min(duration) FROM pitstops WHERE raceid  =  841)",
        "amends": [
            "Do select `driverid` and `STOP` instead of `driver_id` and `stop_duration`. Do use `DISTINCT` instead of omitting it. Do query from `pitstops` instead of `driver_stops`. Do filter with `duration >` instead of `stop_duration >`. Do use a subquery that selects `min(duration)` instead of just `stop_duration`. Do filter the subquery with `raceid = 841` instead of `race_id = 841`. The amended query now correctly identifies drivers with pit stop durations exceeding the minimum duration for race 841, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT driver_id, stop_duration FROM driver_stops WHERE stop_duration > (SELECT stop_duration FROM driver_stops WHERE race_id = 841);",
            "SELECT DISTINCT driverId, stop, duration \nFROM pitStops \nWHERE duration > (SELECT MIN(duration) FROM pitStops WHERE raceId = 841)"
        ],
        "rule_sql": []
    },
    "5760": {
        "db_id": "dorm_1",
        "question": "Find the name of dorms that do not have amenity TV Lounge.",
        "ground_truth": "SELECT dorm_name FROM dorm EXCEPT SELECT T1.dorm_name FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid JOIN dorm_amenity AS T3 ON T2.amenid  =  T3.amenid WHERE T3.amenity_name  =  'TV Lounge'",
        "amends": [
            "Do select `dorm_name` instead of `name` and use an `EXCEPT` operation instead of a simple `WHERE` filter. Do add joins between `dorm`, `has_amenity`, and `dorm_amenity` tables instead of querying only the `dorms` table. Do use proper table aliases `T1`, `T2`, and `T3` instead of no aliases. Do join on `T1.dormid = T2.dormid` and `T2.amenid = T3.amenid` instead of no join conditions. Do filter for `amenity_name = 'TV Lounge'` in the subquery instead of `amenity = 'TV Lounge'` in the main query. The amended query now correctly finds dorms that do NOT have the TV Lounge amenity by using EXCEPT to remove those that do, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM dorms WHERE amenity = 'TV Lounge';",
            "SELECT dorm_name FROM Dorm\nEXCEPT\nSELECT T1.dorm_name\nFROM Dorm T1\nJOIN Has_amenity T2 ON T1.dormid = T2.dormid\nJOIN Dorm_amenity T3 ON T2.amenid = T3.amenid\nWHERE T3.amenity_name = 'TV Lounge'"
        ],
        "rule_sql": []
    },
    "1758": {
        "db_id": "gymnast",
        "question": "What are the distinct hometowns of gymnasts with total points more than 57.5?",
        "ground_truth": "SELECT DISTINCT T2.Hometown FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID WHERE T1.Total_Points  >  57.5",
        "amends": [
            "Do join `gymnast AS T1` with `people AS T2` on `T1.Gymnast_ID = T2.People_ID` instead of querying only the `gymnasts` table. Do select `T2.Hometown` from the joined `people` table instead of selecting `hometown` directly from the `gymnasts` table. Do maintain the `WHERE` filter on `T1.Total_Points > 57.5` instead of filtering on `total_points` from the single table. The amended query now correctly retrieves hometown information from the related people table while maintaining the same filtering logic on gymnast performance data."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT hometown FROM gymnasts WHERE total_points > 57.5;",
            "SELECT DISTINCT T2.Hometown \nFROM gymnast AS T1 \nJOIN people AS T2 ON T1.Gymnast_ID = T2.People_ID \nWHERE T1.Total_Points > 57.5"
        ],
        "rule_sql": []
    },
    "4771": {
        "db_id": "department_store",
        "question": "Find the id of suppliers whose average amount purchased for each product is above 50000 or below 30000.",
        "ground_truth": "SELECT supplier_id FROM Product_Suppliers GROUP BY supplier_id HAVING avg(total_amount_purchased)  >  50000 OR avg(total_amount_purchased)  <  30000",
        "amends": [
            "Do use the `Product_Suppliers` table instead of `purchases` table. Do move the aggregate condition to `HAVING` clause instead of placing it in `WHERE` clause. Do use `avg(total_amount_purchased)` instead of `AVG(amount)` for the aggregate calculation. Do remove `product_id` from the `GROUP BY` clause instead of including it. Do simplify the `SELECT` list to only `supplier_id` instead of maintaining the same column. The amended query now correctly filters aggregated results using HAVING and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT supplier_id \nFROM purchases \nWHERE AVG(amount) > 50000 OR AVG(amount) < 30000 \nGROUP BY supplier_id, product_id",
            "SELECT supplier_id\nFROM Product_Suppliers\nGROUP BY supplier_id\nHAVING AVG(CAST(total_amount_purchased AS DECIMAL)) > 50000 \n   OR AVG(CAST(total_amount_purchased AS DECIMAL)) < 30000"
        ],
        "rule_sql": []
    },
    "5389": {
        "db_id": "tracking_software_problems",
        "question": "Which problems were reported before the date of any problem reported by the staff Lysanne Turcotte? Give me the ids of the problems.",
        "ground_truth": "SELECT T1.problem_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE date_problem_reported  <  ( SELECT min(date_problem_reported) FROM problems AS T3 JOIN staff AS T4 ON T3.reported_by_staff_id = T4.staff_id WHERE T4.staff_first_name = \"Lysanne\" AND T4.staff_last_name = \"Turcotte\" )",
        "amends": [
            "Do join `problems AS T1` with `staff AS T2` on `T1.reported_by_staff_id = T2.staff_id` instead of querying only the `problems` table. Do filter by `date_problem_reported < subquery` instead of `reported_date < subquery`. Do use a correlated subquery that joins `problems AS T3` with `staff AS T4` on `T3.reported_by_staff_id = T4.staff_id` instead of directly filtering by `reported_by = 'Lysanne Turcotte'`. Do add conditions `T4.staff_first_name = \"Lysanne\" AND T4.staff_last_name = \"Turcotte\"` in the subquery instead of using a single name field. Do select `T1.problem_id` with table alias instead of just `problem_id`. The amended query now correctly handles staff identification through proper table joins and name field separation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT problem_id FROM problems WHERE reported_date < (SELECT MIN(reported_date) FROM problems WHERE reported_by = 'Lysanne Turcotte')",
            "SELECT T1.problem_id\nFROM Problems AS T1\nJOIN Staff AS T2 ON T1.reported_by_staff_id = T2.staff_id\nWHERE T1.date_problem_reported < (\n    SELECT MIN(T3.date_problem_reported)\n    FROM Problems AS T3\n    JOIN Staff AS T4 ON T3.reported_by_staff_id = T4.staff_id\n    WHERE T4.staff_first_name = 'Lysanne' AND T4.staff_last_name = 'Turcotte'\n)"
        ],
        "rule_sql": []
    },
    "6624": {
        "db_id": "driving_school",
        "question": "How many vehicle in total?",
        "ground_truth": "SELECT count(*) FROM Vehicles;",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM vehicles;"
        ],
        "rule_sql": []
    },
    "4207": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "Find the code of the role that have the most employees.",
        "ground_truth": "SELECT role_code FROM Employees GROUP BY role_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT role_code FROM employees GROUP BY role_code ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1571": {
        "db_id": "customers_and_invoices",
        "question": "Show first name and id for all customers with at least 2 accounts.",
        "ground_truth": "SELECT T2.customer_first_name ,  T1.customer_id FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  2",
        "amends": [
            "Do select `T2.customer_first_name` and `T1.customer_id` instead of `first_name` and `id`. Do join `Accounts AS T1` with `Customers AS T2` on `T1.customer_id = T2.customer_id` instead of querying only the `customers` table. Do add `GROUP BY T1.customer_id` instead of omitting grouping. Do move the count filter to `HAVING count(*) >= 2` instead of using `WHERE COUNT(accounts) >= 2` which incorrectly applies an aggregate function in the WHERE clause. The amended query now correctly counts accounts per customer and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, id FROM customers WHERE COUNT(accounts) >= 2",
            "SELECT T2.customer_first_name, T1.customer_id\nFROM Accounts AS T1\nJOIN Customers AS T2 ON T1.customer_id = T2.customer_id\nGROUP BY T1.customer_id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "6544": {
        "db_id": "wine_1",
        "question": "Give the names and scores of wines made from white grapes.",
        "ground_truth": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  \"White\"",
        "amends": [
            "Do join `GRAPES AS T1` to `WINE AS T2` on `T1.Grape = T2.Grape` instead of querying `wines` table directly. Do filter on `T1.Color = \"White\"` instead of `grape_color = 'red'`. Do select `T2.Name` and `T2.Score` with proper table aliases instead of `name` and `score` without table qualification. The amended query now correctly joins the GRAPES and WINE tables to filter wines by grape color rather than assuming the color exists directly in the wines table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, score FROM wines WHERE grape_color = 'red';",
            "SELECT T2.Name, T2.Score FROM grapes AS T1 JOIN wine AS T2 ON T1.Grape = T2.Grape WHERE T1.Color = 'White'"
        ],
        "rule_sql": []
    },
    "5053": {
        "db_id": "device",
        "question": "What are the different carriers for devices, listed in alphabetical order?",
        "ground_truth": "SELECT Carrier FROM device ORDER BY Carrier ASC",
        "amends": [
            "Do remove `DISTINCT` instead of keeping it. Do reference `Carrier` instead of `carrier` and use the correct table name `device` instead of `devices`. Do remove the incorrect `device_name` column from the ORDER BY clause and instead order by `Carrier` ASC. The amended query now correctly selects carriers from the device table ordered alphabetically by carrier name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT carrier FROM devices ORDER BY device_name ASC;",
            "SELECT Carrier FROM device ORDER BY Carrier ASC;"
        ],
        "rule_sql": []
    },
    "6926": {
        "db_id": "tracking_orders",
        "question": "Sort all the distinct products in alphabetical order.",
        "ground_truth": "SELECT DISTINCT product_name FROM products ORDER BY product_name",
        "amends": [
            "Do select only `product_name` instead of all columns with `*`. Do add `DISTINCT` to eliminate duplicate product names instead of returning all rows. The ORDER BY clause remains unchanged with `product_name`. The amended query now correctly returns unique product names sorted alphabetically, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM products ORDER BY product_name;",
            "SELECT DISTINCT product_name FROM Products ORDER BY product_name;"
        ],
        "rule_sql": []
    },
    "2903": {
        "db_id": "icfp_1",
        "question": "Which institution has the most papers? Find the name of the institution.",
        "ground_truth": "SELECT t1.name FROM inst AS t1 JOIN authorship AS t2 ON t1.instid  =  t2.instid JOIN papers AS t3 ON t2.paperid  =  t3.paperid GROUP BY t1.name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `t1.name` from the `inst` table instead of `institution_name` from the `papers` table. Do join `authorship AS t2` on `t1.instid = t2.instid` instead of omitting this table and join condition. Do join `papers AS t3` on `t2.paperid = t3.paperid` instead of directly grouping by the papers table. Do group by `t1.name` instead of `institution_name` to properly aggregate by institution names from the correct table. The amended query now correctly joins the institution, authorship, and papers tables to count publications per institution and returns the institution with the most papers, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT institution_name FROM papers GROUP BY institution_name ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT t1.name\nFROM Inst AS t1\nJOIN Authorship AS t2 ON t1.instID = t2.instID\nJOIN Papers AS t3 ON t2.paperID = t3.paperID\nGROUP BY t1.name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5946": {
        "db_id": "cre_Theme_park",
        "question": "Which transportation method is used the most often to get to tourist attractions?",
        "ground_truth": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do use column `How_to_Get_There` instead of `transportation_method` in both the SELECT list and GROUP BY clause. Do use `COUNT(*)` directly in the ORDER BY clause instead of referencing the alias `usage_count`. Do maintain the same DESC ordering and LIMIT 1 to find the most frequent transportation method. The amended query now correctly identifies the most common transportation method by counting occurrences directly in the ORDER BY clause rather than relying on an aliased column reference.",
            "Do remove the `COUNT(*) AS usage_count` column from the SELECT list instead of including it, as the query only needs to return the `How_to_Get_There` value with the highest frequency rather than both the value and its count. The amended query now correctly returns just the most common transportation method by grouping on `How_to_Get_There`, ordering by the count in descending order, and limiting to one result, matching the intended behavior of identifying the single most frequently used transportation option."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT transportation_method, COUNT(*) as usage_count FROM tourist_attractions GROUP BY transportation_method ORDER BY usage_count DESC LIMIT 1;",
            "SELECT How_to_Get_There, COUNT(*) AS usage_count\nFROM Tourist_Attractions\nGROUP BY How_to_Get_There\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT How_to_Get_There \nFROM Tourist_Attractions \nGROUP BY How_to_Get_There \nORDER BY COUNT(*) DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "6932": {
        "db_id": "tracking_orders",
        "question": "Find the name of the customer who made the most orders.",
        "ground_truth": "SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name FROM customers ORDER BY customer_id DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "826": {
        "db_id": "chinook_1",
        "question": "What is the name of the artist with the greatest number of albums?",
        "ground_truth": "SELECT T2.Name FROM ALBUM AS T1 JOIN ARTIST AS T2 ON T1.ArtistId  =  T2.ArtistId GROUP BY T2.Name ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.Name` from the `ARTIST` table instead of `name` from the `artists` table. Do join `ALBUM AS T1` with `ARTIST AS T2` on `T1.ArtistId = T2.ArtistId` instead of querying only the `artists` table. Do add `GROUP BY T2.Name` and aggregate with `COUNT(*)` instead of omitting grouping and aggregation. Do order by `COUNT(*) DESC` instead of `artist_id DESC` to sort by album count rather than artist ID. Do keep `LIMIT 1` to return only the top result. The amended query now correctly identifies the artist with the most albums by joining the album and artist tables, grouping by artist name, counting albums, and ordering by the count descending."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM artists ORDER BY artist_id DESC LIMIT 1;",
            "SELECT T2.Name \nFROM Album AS T1 \nJOIN Artist AS T2 ON T1.ArtistId = T2.ArtistId \nGROUP BY T2.Name \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "852": {
        "db_id": "chinook_1",
        "question": "Find the cities corresponding to employees who help customers with the postal code 70174.",
        "ground_truth": "SELECT T2.City FROM CUSTOMER AS T1 JOIN EMPLOYEE AS T2 ON T1.SupportRepId  =  T2.EmployeeId WHERE T1.PostalCode  =  \"70174\"",
        "amends": [
            "Do join `CUSTOMER AS T1` and `EMPLOYEE AS T2` instead of querying only `employees` table. Do use `JOIN` with `ON T1.SupportRepId = T2.EmployeeId` instead of no join condition. Do select `T2.City` from the joined table instead of `city` from a single table. Do filter on `T1.PostalCode = \"70174\"` instead of `postal_code = '70174'` to reference the customer's postal code rather than the employee's. Do use double quotes around the literal value instead of single quotes. The amended query now correctly retrieves the city of employees who support customers with the specified postal code, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM employees WHERE postal_code = '70174';",
            "SELECT T2.City FROM Customer AS T1 JOIN Employee AS T2 ON T1.SupportRepId = T2.EmployeeId WHERE T1.PostalCode = \"70174\""
        ],
        "rule_sql": []
    },
    "553": {
        "db_id": "store_1",
        "question": "List every album ordered by album title in ascending order.",
        "ground_truth": "SELECT title FROM albums ORDER BY title;",
        "amends": [
            "Do select only `title` instead of all columns with `*`. Do order by `title` in ascending order instead of descending order with `album_title DESC`. The amended query now correctly selects only the title column and orders alphabetically by title in ascending order, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM albums ORDER BY album_title DESC;",
            "SELECT title FROM albums ORDER BY title ASC;"
        ],
        "rule_sql": []
    },
    "6591": {
        "db_id": "wine_1",
        "question": "List the grape, appelation and name of wines whose score is higher than 93 ordered by Name.",
        "ground_truth": "SELECT Grape ,  Appelation ,  Name FROM WINE WHERE Score  >  93 ORDER BY Name",
        "amends": [
            "Do reference table `WINE` instead of `wines` in the FROM clause. Do capitalize column names `Grape`, `Appelation`, and `Name` instead of lowercase `grape`, `appelation`, and `name` in the SELECT list. Do order by `Name` instead of `appelation` in the ORDER BY clause. The amended query now correctly references the proper table name with capitalized columns and orders results by name rather than appelation, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT grape, appelation, name FROM wines WHERE score > 93 ORDER BY appelation;",
            "SELECT Grape, Appelation, Name FROM WINE WHERE Score > 93 ORDER BY Name;"
        ],
        "rule_sql": []
    },
    "903": {
        "db_id": "insurance_fnol",
        "question": "Find the name of services that have been used for more than 2 times in first notification of loss.",
        "ground_truth": "SELECT t2.service_name FROM first_notification_of_loss AS t1 JOIN services AS t2 ON t1.service_id  =  t2.service_id GROUP BY t1.service_id HAVING count(*)  >  2",
        "amends": [
            "Do select `t2.service_name` from the joined table instead of `service_name` directly from the services table. Do join `first_notification_of_loss AS t1` with `services AS t2` on `t1.service_id = t2.service_id` instead of querying the services table alone. Do remove the `WHERE` clause with `usage_count > 2` and `notification_type = 'first_loss'` conditions and instead use `GROUP BY t1.service_id` with `HAVING count(*) > 2` to filter by notification count rather than usage count. The amended query now correctly identifies services with more than two first loss notifications by joining the notification table and counting occurrences, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT service_name FROM services WHERE usage_count > 2 AND notification_type = 'first_loss';",
            "SELECT t2.Service_name \nFROM First_Notification_of_Loss AS t1 \nJOIN Services AS t2 ON t1.Service_ID = t2.Service_ID \nGROUP BY t1.Service_ID \nHAVING COUNT(*) > 2"
        ],
        "rule_sql": []
    },
    "371": {
        "db_id": "flight_1",
        "question": "What is average and maximum salary of all employees.",
        "ground_truth": "SELECT avg(salary) ,  max(salary) FROM Employee",
        "amends": [
            "Do add `max(salary)` to the SELECT list instead of omitting it. Do change the table reference from `employees` to `Employee` instead of using the wrong table name. Do remove the `WHERE salary > 100000` filter instead of keeping it, as the right query calculates overall averages and maximums without filtering. The amended query now correctly calculates both average and maximum salary values from the Employee table without unnecessary filtering, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(salary) FROM employees WHERE salary > 100000;",
            "SELECT AVG(salary) AS average_salary, MAX(salary) AS maximum_salary FROM employee"
        ],
        "rule_sql": []
    },
    "99": {
        "db_id": "student_assessment",
        "question": "What are the id of students who registered courses or attended courses?",
        "ground_truth": "SELECT student_id FROM student_course_registrations UNION SELECT student_id FROM student_course_attendance",
        "amends": [
            "Do select `student_id` from `student_course_registrations` instead of `id` from `students` with nullable column checks. Do use `UNION` to combine results from two separate tables instead of checking `registered_courses` and `attended_courses` columns in a single table with `OR` conditions. Do remove the `WHERE` clause with `IS NOT NULL` filters instead of keeping them, as the union operation inherently handles distinct student IDs from both source tables. The amended query now correctly retrieves unique student IDs from both registration and attendance tables, matching the RIGHT_SQL's behavior of combining records from separate transactional tables rather than checking nullable columns in a master table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM students WHERE registered_courses IS NOT NULL OR attended_courses IS NOT NULL;",
            "SELECT student_id FROM Student_Course_Registrations\nUNION\nSELECT student_id FROM Student_Course_Attendance"
        ],
        "rule_sql": []
    },
    "3601": {
        "db_id": "music_1",
        "question": "What are the maximum duration and resolution of songs grouped and ordered by languages?",
        "ground_truth": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages",
        "amends": [
            "Do select `max(T1.duration)` and `max(T2.resolution)` instead of `MAX(duration)` and `MAX(resolution)`. Do add `T2.languages` to the SELECT list instead of omitting it. Do use `FROM files AS T1 JOIN song AS T2` instead of `FROM songs`. Do specify `ON T1.f_id = T2.f_id` for the join condition instead of no join condition. Do group by `T2.languages` instead of `language`. Do order by `T2.languages` instead of `language`. The amended query now correctly joins the files and song tables and aggregates data from both tables while maintaining the proper grouping and ordering logic.",
            "Do place `T2.languages` after the aggregate functions in the SELECT list instead of listing it first. Do maintain the same `JOIN` on `T1.f_id = T2.f_id` without changes to the join type or predicate. Do preserve the `GROUP BY T2.languages` and `ORDER BY T2.languages` clauses without modification. The amended query now correctly positions the grouping column after aggregate functions while maintaining identical logic and output behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language, MAX(duration), MAX(resolution) FROM songs GROUP BY language ORDER BY language;",
            "SELECT T2.languages, max(T1.duration) AS max_duration, max(T2.resolution) AS max_resolution FROM files AS T1 JOIN song AS T2 ON T1.f_id = T2.f_id GROUP BY T2.languages ORDER BY T2.languages",
            "SELECT max(T1.duration), max(T2.resolution), T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id = T2.f_id GROUP BY T2.languages ORDER BY T2.languages"
        ],
        "rule_sql": []
    },
    "3511": {
        "db_id": "hr_1",
        "question": "display the department id and the total salary for those departments which contains at least two employees.",
        "ground_truth": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT department_id, SUM(salary) as total_salary \nFROM employees \nGROUP BY department_id \nHAVING COUNT(*) > 1"
        ],
        "rule_sql": []
    },
    "1363": {
        "db_id": "college_2",
        "question": "What is the title of a course that is listed in both the Statistics and Psychology departments?",
        "ground_truth": "SELECT title FROM course WHERE dept_name  =  'Statistics' INTERSECT SELECT title FROM course WHERE dept_name  =  'Psychology'",
        "amends": [
            "Do use `INTERSECT` to find courses that belong to both departments instead of incorrectly using `AND` with the same column. Do reference the correct table name `course` instead of `courses`. Do use the correct column name `dept_name` instead of `department` for both department filters. Do structure the query as two separate SELECT statements with INTERSECT instead of a single WHERE clause with conflicting conditions. The amended query now correctly identifies courses that are listed under both Statistics and Psychology departments, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM courses WHERE department = 'Statistics' AND department = 'Psychology';",
            "SELECT title FROM course WHERE dept_name = 'Statistics' INTERSECT SELECT title FROM course WHERE dept_name = 'Psychology'"
        ],
        "rule_sql": []
    },
    "2498": {
        "db_id": "movie_1",
        "question": "What are the movie titles and average rating of the movies with the lowest average rating?",
        "ground_truth": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT 1",
        "amends": [
            "Do join `Rating AS T1` with `Movie AS T2` on `T1.mID = T2.mID` instead of querying only the `movies` table without proper joins. Do use `avg(T1.stars)` as the aggregate function instead of `AVG(rating)` to reference the correct column. Do include `GROUP BY T1.mID` to group by movie ID instead of omitting grouping entirely. Do reference `T2.title` in the SELECT list instead of just `title` to specify the table alias. Do order by `avg(T1.stars)` directly instead of using the alias `average_rating`. The amended query now correctly calculates average ratings by joining the Rating and Movie tables and grouping by movie ID to match the RIGHT_SQL's behavior.",
            "Do remove the `HAVING` clause with its subquery that finds minimum average stars instead of keeping it, as it incorrectly filters for only the absolute minimum rating. Do add `LIMIT 1` instead of omitting it to correctly return only the single movie with the lowest average rating. Do remove the `AS average_rating` alias instead of keeping it since the column naming is not essential for the result. The amended query now correctly identifies the movie with the lowest average rating by using ORDER BY with LIMIT instead of the complex HAVING subquery approach."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, AVG(rating) as average_rating FROM movies ORDER BY average_rating ASC LIMIT 1;",
            "SELECT T2.title, AVG(T1.stars) AS average_rating\nFROM Rating AS T1\nJOIN Movie AS T2 ON T1.mID = T2.mID\nGROUP BY T1.mID\nHAVING AVG(T1.stars) = (\n    SELECT MIN(avg_stars)\n    FROM (\n        SELECT AVG(stars) AS avg_stars\n        FROM Rating\n        GROUP BY mID\n    )\n)\nORDER BY AVG(T1.stars)",
            "SELECT T2.title, avg(T1.stars) \nFROM Rating AS T1 \nJOIN Movie AS T2 ON T1.mID = T2.mID \nGROUP BY T1.mID \nORDER BY avg(T1.stars) \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "2819": {
        "db_id": "news_report",
        "question": "List the event venues and names that have the top 2 most number of people attended.",
        "ground_truth": "SELECT venue ,  name FROM event ORDER BY Event_Attendance DESC LIMIT 2",
        "amends": [
            "Do select only `venue` and `name` columns instead of including `COUNT(*) as attendance_count`. Do query from `event` table instead of `events` table. Do remove the `GROUP BY venue, name` clause instead of grouping by these columns. Do remove the aggregate count calculation instead of computing attendance counts. Do order by `Event_Attendance` column instead of ordering by the computed `attendance_count`. Do keep the `LIMIT 2` clause as it remains unchanged. The amended query now correctly selects venue and name columns directly from the event table ordered by the existing Event_Attendance column rather than attempting to compute attendance counts through aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT venue, name, COUNT(*) as attendance_count FROM events GROUP BY venue, name ORDER BY attendance_count DESC LIMIT 2;",
            "SELECT Venue, Name FROM event ORDER BY Event_Attendance DESC LIMIT 2;"
        ],
        "rule_sql": []
    },
    "5062": {
        "db_id": "device",
        "question": "How many different software platforms are there for devices?",
        "ground_truth": "SELECT count(DISTINCT Software_Platform) FROM device",
        "amends": [
            "Do `count(DISTINCT Software_Platform)` instead of `COUNT(*)` to count distinct software platforms rather than all device records. Do reference the `device` table instead of `devices` to use the correct table name. The amended query now correctly counts distinct software platforms from the device table instead of counting all device records."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM devices;",
            "SELECT COUNT(DISTINCT Software_Platform) FROM device;"
        ],
        "rule_sql": []
    },
    "2357": {
        "db_id": "csu_1",
        "question": "how many degrees were conferred between 1998 and 2002?",
        "ground_truth": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  1998 AND T2.year  <=  2002 GROUP BY T1.campus",
        "amends": [
            "Do add `T1.campus` and `sum(T2.degrees)` instead of `COUNT(*)` to select specific campus names and sum degrees rather than counting rows. Do add `FROM campuses AS T1 JOIN degrees AS T2` instead of `FROM degrees` to include the campuses table and join it with degrees. Do add `ON T1.id = T2.campus` instead of omitting a join condition to properly relate campuses to their degrees. Do change the filter to `T2.year >= 1998 AND T2.year <= 2002` instead of `year BETWEEN 1998 AND 2002` to explicitly specify the year range on the degrees table. Do add `GROUP BY T1.campus` instead of omitting grouping to aggregate degrees by each campus. The amended query now correctly sums degrees by campus for the specified years instead of counting total degree records."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM degrees WHERE year BETWEEN 1998 AND 2002;",
            "SELECT T1.Campus, SUM(T2.Degrees) \nFROM Campuses AS T1 \nJOIN degrees AS T2 ON T1.Id = T2.Campus \nWHERE T2.Year >= 1998 AND T2.Year <= 2002 \nGROUP BY T1.Campus"
        ],
        "rule_sql": []
    },
    "1722": {
        "db_id": "riding_club",
        "question": "List the name and residence for players whose occupation is not \"Researcher\".",
        "ground_truth": "SELECT Player_name ,  residence FROM player WHERE Occupation != \"Researcher\"",
        "amends": [
            "Do reference `Player_name` instead of `name` and use `player` instead of `players` as the table source. Do filter with `!= \"Researcher\"` instead of `= 'Researcher'` for the occupation condition. The amended query now correctly excludes researchers rather than including them, matching the intended logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, residence FROM players WHERE occupation = 'Researcher';",
            "SELECT Player_name, Residence FROM player WHERE Occupation != \"Researcher\";"
        ],
        "rule_sql": []
    },
    "6908": {
        "db_id": "tracking_orders",
        "question": "What are the distinct ids of products ordered between 1975-01-01 and 1976-01-01??",
        "ground_truth": "SELECT DISTINCT T2.product_id FROM orders AS T1 JOIN order_items AS T2 ON T1.order_id = T2.order_id WHERE T1.date_order_placed >= \"1975-01-01\" AND T1.date_order_placed <= \"1976-01-01\"",
        "amends": [
            "Do join `order_items AS T2` instead of omitting it, and do reference `T2.product_id` instead of `product_id` directly. Do use `T1.date_order_placed` for date filtering instead of `order_date`, and do specify both `>=` and `<=` conditions instead of `BETWEEN`. Do add the join condition `ON T1.order_id = T2.order_id` instead of missing the table relationship. The amended query now correctly retrieves distinct product IDs from the joined tables with proper date filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT product_id FROM orders WHERE order_date BETWEEN '1975-01-01' AND '1976-01-01';",
            "SELECT DISTINCT T2.product_id\nFROM Orders AS T1\nJOIN Order_Items AS T2 ON T1.order_id = T2.order_id\nWHERE T1.date_order_placed >= '1975-01-01' AND T1.date_order_placed <= '1976-01-01'"
        ],
        "rule_sql": []
    },
    "6215": {
        "db_id": "roller_coaster",
        "question": "Show the names of countries that have more than one roller coaster.",
        "ground_truth": "SELECT T1.Name FROM country AS T1 JOIN roller_coaster AS T2 ON T1.Country_ID  =  T2.Country_ID GROUP BY T1.Name HAVING COUNT(*)  >  1",
        "amends": [
            "Do select `T1.Name` instead of `country` and do use table aliases `T1` and `T2` instead of direct table references. Do join `country AS T1` with `roller_coaster AS T2` on `T1.Country_ID = T2.Country_ID` instead of querying only the `roller_coasters` table. Do group by `T1.Name` instead of `country` while maintaining the `HAVING COUNT(*) > 1` condition. The amended query now correctly joins the country table with roller coaster data to count coasters per country name rather than relying on a potentially incorrect country field in the roller_coasters table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) FROM roller_coasters GROUP BY country HAVING COUNT(*) > 1",
            "SELECT T1.Name \nFROM country AS T1 \nJOIN roller_coaster AS T2 ON T1.Country_ID = T2.Country_ID \nGROUP BY T1.Name \nHAVING COUNT(*) > 1"
        ],
        "rule_sql": []
    },
    "5457": {
        "db_id": "voter_2",
        "question": "List the major of each male student.",
        "ground_truth": "SELECT Major FROM STUDENT WHERE Sex  =  \"M\"",
        "amends": [
            "Do reference `Major` instead of `major` and use table `STUDENT` instead of `students`. Do filter on `Sex = \"M\"` instead of `gender = 'female'` to select male students rather than female students. The amended query now correctly selects male students from the STUDENT table as specified in the target query."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT major FROM students WHERE gender = 'female';",
            "SELECT Major FROM Student WHERE Sex = 'M'"
        ],
        "rule_sql": []
    },
    "796": {
        "db_id": "coffee_shop",
        "question": "What is the membership card held by both members living in Hartford and ones living in Waterbury address?",
        "ground_truth": "SELECT membership_card FROM member WHERE address  =  'Hartford' INTERSECT SELECT membership_card FROM member WHERE address  =  'Waterbury'",
        "amends": [
            "Do use `INTERSECT` to find members who have both addresses instead of using `AND` with the same column which would never return results. Do query from the `member` table instead of the `members` table. Do split the query into two separate `SELECT` statements for each address condition instead of combining them with an impossible `AND` condition. Do maintain the same column selection `membership_card` but with the correct table name and logical operator. The amended query now correctly identifies members who have both Hartford and Waterbury addresses by using set intersection logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT membership_card FROM members WHERE address = 'Hartford' AND address = 'Waterbury';",
            "SELECT membership_card FROM member WHERE Address = 'Hartford'\nINTERSECT\nSELECT membership_card FROM member WHERE Address = 'Waterbury'"
        ],
        "rule_sql": []
    },
    "5384": {
        "db_id": "tracking_software_problems",
        "question": "What are the id of problems reported by the staff named Dameon Frami or Jolie Weber?",
        "ground_truth": "SELECT product_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE T2.staff_first_name = \"Dameon\" AND T2.staff_last_name = \"Frami\" UNION SELECT product_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE T2.staff_first_name = \"Jolie\" AND T2.staff_last_name = \"Weber\"",
        "amends": [
            "Do select `product_id` instead of `problem_id` and join `staff` table as `T2` on `T1.reported_by_staff_id = T2.staff_id` instead of filtering directly on `reported_by` string values. Do filter with `T2.staff_first_name = \"Dameon\" AND T2.staff_last_name = \"Frami\"` in the WHERE clause instead of `reported_by = 'Dameon Frami'`, and use the same approach for \"Jolie Weber\" in a separate UNION branch instead of OR conditions. Do structure the query as two separate SELECT statements joined with UNION instead of a single query with OR conditions, properly joining through the staff_id foreign key relationship rather than relying on concatenated name strings. The amended query now correctly matches the RIGHT_SQL's behavior by using proper relational joins through staff IDs rather than string matching on potentially inconsistent name formats.",
            "Do select `product_id` instead of `problem_id` from the Problems table. Do use table aliases `T1` and `T2` instead of `p` and `s` for better clarity. Do use double quotes `\"Dameon\"` and `\"Frami\"` instead of single quotes for string literals in the first WHERE clause, and similarly `\"Jolie\"` and `\"Weber\"` instead of single quotes in the second WHERE clause. The amended query now correctly retrieves product IDs for staff members with the specified names while maintaining the UNION operation between the two result sets."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT problem_id FROM problems WHERE reported_by = 'Dameon Frami' OR reported_by = 'Jolie Weber';",
            "SELECT p.problem_id\nFROM Problems p\nJOIN Staff s ON p.reported_by_staff_id = s.staff_id\nWHERE s.staff_first_name = 'Dameon' AND s.staff_last_name = 'Frami'\nUNION\nSELECT p.problem_id\nFROM Problems p\nJOIN Staff s ON p.reported_by_staff_id = s.staff_id\nWHERE s.staff_first_name = 'Jolie' AND s.staff_last_name = 'Weber'",
            "SELECT T1.product_id\nFROM Problems T1\nJOIN Staff T2 ON T1.reported_by_staff_id = T2.staff_id\nWHERE T2.staff_first_name = \"Dameon\" AND T2.staff_last_name = \"Frami\"\nUNION\nSELECT T1.product_id\nFROM Problems T1\nJOIN Staff T2 ON T1.reported_by_staff_id = T2.staff_id\nWHERE T2.staff_first_name = \"Jolie\" AND T2.staff_last_name = \"Weber\""
        ],
        "rule_sql": []
    },
    "4153": {
        "db_id": "film_rank",
        "question": "Which studios have never worked with the director Walter Hill?",
        "ground_truth": "SELECT Studio FROM film EXCEPT SELECT Studio FROM film WHERE Director  =  \"Walter Hill\"",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do reference table `film` instead of `studios` and `movies`. Do select column `Studio` instead of `studio_name`. Do filter for director `\"Walter Hill\"` instead of `'Walter Hill'`. Do remove the `DISTINCT` modifier since `EXCEPT` inherently returns distinct rows. The amended query now correctly uses set operations to find studios that have not produced films by Walter Hill, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT studio_name \nFROM studios \nWHERE studio_id NOT IN (\n    SELECT studio_id \n    FROM movies \n    WHERE director = 'Walter Hill'\n)",
            "SELECT Studio FROM film\nEXCEPT\nSELECT Studio FROM film WHERE Director = \"Walter Hill\""
        ],
        "rule_sql": []
    },
    "5850": {
        "db_id": "tracking_share_transactions",
        "question": "Show all transaction ids with transaction code 'PUR'.",
        "ground_truth": "SELECT transaction_id FROM TRANSACTIONS WHERE transaction_type_code  =  'PUR'",
        "amends": [
            "Do filter on `transaction_type_code = 'PUR'` instead of `transaction_code != 'PUR'` to correctly select purchase transactions by matching the specific code rather than excluding non-purchase codes, which changes both the column reference and the filter logic from inequality to equality comparison. The amended query now matches RIGHT_SQL's behavior by accurately identifying purchase transactions using the proper column and condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT transaction_id FROM transactions WHERE transaction_code != 'PUR'",
            "SELECT transaction_id FROM Transactions WHERE transaction_type_code = 'PUR';"
        ],
        "rule_sql": []
    },
    "77": {
        "db_id": "student_assessment",
        "question": "What is detail of the student who registered the most number of courses?",
        "ground_truth": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.student_details` instead of `*` and add aggregation with `GROUP BY T1.student_id`. Do add `JOIN` with `student_course_registrations AS T2` on `T1.student_id = T2.student_id` instead of querying only the `students` table. Do change `ORDER BY` to use `count(*) DESC` instead of `student_id DESC` to order by the number of course registrations. The amended query now correctly identifies the student with the most course registrations instead of simply returning the last student by ID."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM students ORDER BY student_id DESC LIMIT 1;",
            "SELECT T1.student_details\nFROM Students AS T1\nJOIN Student_Course_Registrations AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "2895": {
        "db_id": "icfp_1",
        "question": "Find papers whose second author has last name \"Turon\" and is affiliated with an institution in the country \"USA\".",
        "ground_truth": "SELECT t3.title FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid JOIN inst AS t4 ON t2.instid  =  t4.instid WHERE t4.country  =  \"USA\" AND t2.authorder  =  2 AND t1.lname  =  \"Turon\"",
        "amends": [
            "Do join multiple tables including `authors AS t1`, `authorship AS t2`, `papers AS t3`, and `inst AS t4` instead of querying only `papers` table. Do filter on `t1.lname = \"Turon\"` instead of `author2_lastname = 'Turon'`. Do filter on `t4.country = \"USA\"` instead of `country = 'USA'`. Do add `t2.authorder = 2` condition to specifically target second authors instead of omitting author order filtering. Do select only `t3.title` instead of selecting all columns with `*`. The amended query now correctly identifies papers where Turon is the second author from USA institutions by properly joining through the authorship relationship tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM papers WHERE author2_lastname = 'Turon' AND country = 'USA';",
            "SELECT t3.title\nFROM Authors AS t1\nJOIN Authorship AS t2 ON t1.authID = t2.authID\nJOIN Papers AS t3 ON t2.paperID = t3.paperID\nJOIN Inst AS t4 ON t2.instID = t4.instID\nWHERE t1.lname = \"Turon\"\nAND t4.country = \"USA\"\nAND t2.authOrder = 2;"
        ],
        "rule_sql": []
    },
    "4286": {
        "db_id": "club_1",
        "question": "Find the location of the club \"Pen and Paper Gaming\".",
        "ground_truth": "SELECT clublocation FROM club WHERE clubname  =  \"Pen and Paper Gaming\"",
        "amends": [
            "Do select `clublocation` instead of `name` and do use table `club` instead of `clubs`. Do filter on `clubname = \"Pen and Paper Gaming\"` instead of `location = 'Pen and Paper Gaming'`. The amended query now correctly retrieves the club location from the club table based on the club name, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM clubs WHERE location = 'Pen and Paper Gaming';",
            "SELECT ClubLocation FROM Club WHERE ClubName = 'Pen and Paper Gaming';"
        ],
        "rule_sql": []
    },
    "1073": {
        "db_id": "match_season",
        "question": "For each player, what are their name, season, and country that they belong to?",
        "ground_truth": "SELECT T2.Season ,  T2.Player ,  T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country",
        "amends": [
            "Do select `T2.Season`, `T2.Player`, and `T1.Country_name` instead of `name` and `season`. Do use a `JOIN` between `country AS T1` and `match_season AS T2` with predicate `T1.Country_id = T2.Country` instead of a single table `players`. Do add the `Country_name` column instead of omitting it, and do include the `Player` column instead of the generic `name`. The amended query now correctly joins related tables and selects the appropriate columns to match the intended behavior.",
            "Do reorder the SELECT list to `T2.Season, T2.Player, T1.Country_name` instead of `T2.Player, T2.Season, T1.Country_name` to match the column sequence in the RIGHT_SQL. The JOIN condition remains identical with `T1.Country_id = T2.Country` and no other structural changes are needed. The amended query now correctly matches the RIGHT_SQL's behavior with the proper column ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, season FROM players;",
            "SELECT T2.Player, T2.Season, T1.Country_name \nFROM country AS T1 \nJOIN match_season AS T2 ON T1.Country_id = T2.Country",
            "SELECT T2.Season, T2.Player, T1.Country_name \nFROM country AS T1 \nJOIN match_season AS T2 ON T1.Country_id = T2.Country"
        ],
        "rule_sql": []
    },
    "2020": {
        "db_id": "gas_company",
        "question": "What are the headquarters that have both a company in the banking and 'oil and gas' industries?",
        "ground_truth": "SELECT headquarters FROM company WHERE main_industry  =  'Banking' INTERSECT SELECT headquarters FROM company WHERE main_industry  =  'Oil and gas'",
        "amends": [
            "Do use `INTERSECT` to find common headquarters instead of a self-join with duplicate filtering. Do reference the single `company` table instead of aliasing it as `c1` and `c2`. Do filter for `main_industry = 'Banking'` in the first branch instead of `industry = 'banking'`. Do filter for `main_industry = 'Oil and gas'` in the second branch instead of `industry = 'oil and gas'`. Do remove the `DISTINCT` keyword since `INTERSECT` inherently returns unique values instead of keeping it. The amended query now correctly identifies headquarters that have companies in both banking and oil/gas industries using set intersection logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT hq.headquarters\nFROM companies c1\nJOIN companies c2 ON c1.headquarters = c2.headquarters\nWHERE c1.industry = 'banking' AND c2.industry = 'oil and gas';",
            "SELECT Headquarters FROM company WHERE Main_Industry = 'Banking' INTERSECT SELECT Headquarters FROM company WHERE Main_Industry = 'Oil and gas'"
        ],
        "rule_sql": []
    },
    "2285": {
        "db_id": "entrepreneur",
        "question": "What are the weights of entrepreneurs in descending order of money requested?",
        "ground_truth": "SELECT T2.Weight FROM entrepreneur AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T1.Money_Requested DESC",
        "amends": [
            "Do select `T2.Weight` from the `people` table instead of `weight` from the `entrepreneurs` table. Do join `entrepreneur AS T1` with `people AS T2` on `T1.People_ID = T2.People_ID` instead of querying only the `entrepreneurs` table. Do order by `T1.Money_Requested DESC` instead of `money_requested ASC` to sort in descending order. The amended query now correctly retrieves weight data from the related people table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT weight FROM entrepreneurs ORDER BY money_requested ASC;",
            "SELECT T2.Weight \nFROM entrepreneur AS T1\nJOIN people AS T2 ON T1.People_ID = T2.People_ID\nORDER BY T1.Money_Requested DESC;"
        ],
        "rule_sql": []
    },
    "5475": {
        "db_id": "voter_2",
        "question": "What are the distinct first names of the students who have class president votes?",
        "ground_truth": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE",
        "amends": [
            "Do select `T1.Fname` instead of `first_name` and do use table alias `T1` instead of no alias. Do add table `VOTING_RECORD AS T2` instead of omitting it and do use `JOIN` with condition `T1.StuID = T2.CLASS_Senator_VOTE` instead of no join. Do remove `WHERE class_president_votes > 0` filter instead of keeping it, as the join condition now handles the voting logic. The amended query correctly retrieves distinct first names of students who received class senator votes instead of class president votes."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT first_name FROM students WHERE class_president_votes > 0",
            "SELECT DISTINCT T1.Fname FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.Class_Senator_Vote"
        ],
        "rule_sql": []
    },
    "3288": {
        "db_id": "college_1",
        "question": "How many professors attained either Ph.D. or Masters degrees?",
        "ground_truth": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'",
        "amends": [
            "Do reference table `professor` instead of `professors` and use column `prof_high_degree` instead of `degree` for filtering. Do include the degree value `MA` instead of `Masters` while keeping the `Ph.D.` condition unchanged. The amended query now correctly counts records from the professor table where the highest degree is either Ph.D. or MA, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM professors WHERE degree = 'Ph.D.' OR degree = 'Masters';",
            "SELECT COUNT(*) FROM PROFESSOR WHERE PROF_HIGH_DEGREE = 'Ph.D.' OR PROF_HIGH_DEGREE = 'MA'"
        ],
        "rule_sql": []
    },
    "5064": {
        "db_id": "device",
        "question": "List the open date of open year of the shop named \"Apple\".",
        "ground_truth": "SELECT Open_Date ,  Open_Year FROM shop WHERE Shop_Name  =  \"Apple\"",
        "amends": [
            "Do select both `Open_Date` and `Open_Year` instead of only `open_date`. Do reference table `shop` instead of `shops`. Do filter on `Shop_Name = \"Apple\"` instead of `name = 'Apple' AND open_year = 'open'`. Do remove the incorrect filter condition `open_year = 'open'` instead of keeping it. The amended query now correctly retrieves both date and year columns from the specified table with the proper name filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT open_date FROM shops WHERE name = 'Apple' AND open_year = 'open'",
            "SELECT Open_Date, Open_Year FROM shop WHERE Shop_Name = 'Apple';"
        ],
        "rule_sql": []
    },
    "2329": {
        "db_id": "csu_1",
        "question": "What are the campuses that opened in 1958?",
        "ground_truth": "SELECT campus FROM campuses WHERE YEAR  =  1958",
        "amends": [
            "Do reference table `campuses` instead of `universities` in the FROM clause. Do use column `YEAR` instead of `opened` in the WHERE filter. Do use numeric comparison `= 1958` instead of string comparison `= '1958'` by removing the quotes around the year value. The amended query now correctly selects campus names from the campuses table filtered by the numeric year 1958 instead of attempting to match a string value in a different table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT campus FROM universities WHERE opened = '1958';",
            "SELECT Campus FROM Campuses WHERE Year = 1958"
        ],
        "rule_sql": []
    },
    "3209": {
        "db_id": "college_1",
        "question": "What is the number of professors for different school?",
        "ground_truth": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code",
        "amends": [
            "Do select `count(*)` and `T1.school_code` instead of `school` and `COUNT(*)`. Do join `department AS T1` with `professor AS T2` on `T1.dept_code = T2.dept_code` instead of querying only `professors` table. Do group by `T1.school_code` instead of `school`. The amended query now correctly counts professors per school by joining department and professor tables on their department code relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT school, COUNT(*) FROM professors GROUP BY school;",
            "SELECT COUNT(*) AS professor_count, T1.SCHOOL_CODE \nFROM DEPARTMENT AS T1 \nJOIN PROFESSOR AS T2 ON T1.DEPT_CODE = T2.DEPT_CODE \nGROUP BY T1.SCHOOL_CODE"
        ],
        "rule_sql": []
    },
    "6159": {
        "db_id": "music_4",
        "question": "What are the songs in volumes with more than 1 week on top?",
        "ground_truth": "SELECT Song FROM volume WHERE Weeks_on_Top  >  1",
        "amends": [
            "Do reference the `Song` column instead of `s.title` in the SELECT list. Do use the table name `volume` instead of `songs` and `volumes` with joins. Do remove the explicit table alias `s` and join condition `ON s.volume_id = v.id` instead of keeping them. Do reference the column `Weeks_on_Top` instead of `v.weeks_on_top` in the WHERE filter. The amended query now correctly selects songs from volumes based on weeks on top criteria without unnecessary joins."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.title \nFROM songs s \nJOIN volumes v ON s.volume_id = v.id \nWHERE v.weeks_on_top > 1;",
            "SELECT Song FROM volume WHERE Weeks_on_Top > 1"
        ],
        "rule_sql": []
    },
    "4987": {
        "db_id": "soccer_2",
        "question": "How many students participated in tryouts for each college by descennding count?",
        "ground_truth": "SELECT count(*) ,  cName FROM tryout GROUP BY cName ORDER BY count(*) DESC",
        "amends": [
            "Do use `count(*)` without an alias instead of `COUNT(*) as student_count`. Do select `cName` instead of `college`. Do use `GROUP BY cName` instead of `GROUP BY college`. Do order by `count(*) DESC` instead of `student_count ASC`. The amended query now correctly counts records grouped by cName in descending order, matching the intended behavior.",
            "Do place `count(*)` before `cName` in the SELECT list instead of having `cName` first. Do maintain the same `GROUP BY cName` and `ORDER BY count(*) DESC` clauses without changes. The amended query now correctly positions the aggregate function first while preserving the identical grouping and ordering logic, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT college, COUNT(*) as student_count FROM tryouts GROUP BY college ORDER BY student_count ASC;",
            "SELECT cName, count(*) FROM Tryout GROUP BY cName ORDER BY count(*) DESC",
            "SELECT count(*), cName FROM Tryout GROUP BY cName ORDER BY count(*) DESC"
        ],
        "rule_sql": []
    },
    "2557": {
        "db_id": "county_public_safety",
        "question": "How many cities are in counties that have populations of over 20000?",
        "ground_truth": "SELECT count(*) FROM city WHERE county_ID IN (SELECT county_ID FROM county_public_safety WHERE population  >  20000)",
        "amends": [
            "Do reference the `city` table instead of `cities` in the FROM clause. Do use a subquery with `county_ID IN (SELECT county_ID FROM county_public_safety WHERE population > 20000)` instead of directly filtering on `county_population > 20000` in the WHERE clause. Do reference the correct population column `population` from the `county_public_safety` table instead of the non-existent `county_population` column. The amended query now correctly counts cities located in counties with populations exceeding 20,000 by properly joining through the county_public_safety table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities WHERE county_population > 20000;",
            "SELECT COUNT(*) FROM city WHERE County_ID IN (SELECT County_ID FROM county_public_safety WHERE Population > 20000)"
        ],
        "rule_sql": []
    },
    "5192": {
        "db_id": "music_2",
        "question": "How many unique labels are there for albums?",
        "ground_truth": "SELECT count(DISTINCT label) FROM albums",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM albums;"
        ],
        "rule_sql": []
    },
    "6555": {
        "db_id": "wine_1",
        "question": "What are the average prices of wines for different years?",
        "ground_truth": "SELECT avg(Price) ,  YEAR FROM WINE GROUP BY YEAR",
        "amends": [
            "Do use `avg(Price)` with proper capitalization instead of `AVG(price)` with lowercase column reference. Do place the `YEAR` column after the aggregate function instead of listing it first in the SELECT clause. Do maintain the `GROUP BY YEAR` clause with proper capitalization instead of `GROUP BY year` with lowercase. The amended query now correctly calculates average prices grouped by year with proper column references and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, AVG(price) FROM wines GROUP BY year;",
            "SELECT AVG(Price) AS AveragePrice, Year FROM wine GROUP BY Year ORDER BY Year;"
        ],
        "rule_sql": []
    },
    "3990": {
        "db_id": "hospital_1",
        "question": "Find the names of patients who are not using the medication of Procrastin-X.",
        "ground_truth": "SELECT name FROM patient EXCEPT SELECT T1.name FROM patient AS T1 JOIN Prescribes AS T2 ON T2.Patient  =  T1.SSN JOIN Medication AS T3 ON T2.Medication  =  T3.Code WHERE T3.name  =  'Procrastin-X'",
        "amends": [
            "Do use `EXCEPT` to subtract patients prescribed 'Procrastin-X' instead of simple inequality filtering. Do add joins to `Prescribes` and `Medication` tables instead of querying only the `patient` table. Do reference `T3.name = 'Procrastin-X'` in the WHERE clause instead of filtering `medication != 'Procrastin-X'` directly. Do use proper table aliases `T1`, `T2`, and `T3` instead of no aliases. Do join on `T2.Patient = T1.SSN` and `T2.Medication = T3.Code` instead of no join conditions. The amended query now correctly identifies patients who have never been prescribed 'Procrastin-X' by excluding those who have received this medication, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM patients WHERE medication != 'Procrastin-X';",
            "SELECT T1.Name\nFROM Patient T1\nEXCEPT\nSELECT T1.Name\nFROM Patient T1\nJOIN Prescribes T2 ON T2.Patient = T1.SSN\nJOIN Medication T3 ON T2.Medication = T3.Code\nWHERE T3.Name = 'Procrastin-X'"
        ],
        "rule_sql": []
    },
    "6107": {
        "db_id": "customers_and_addresses",
        "question": "What is the name of the customer that made the order with the largest quantity?",
        "ground_truth": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t3.order_quantity  =  ( SELECT max(order_quantity) FROM order_items)",
        "amends": [
            "Do add `JOIN customer_orders AS t2 ON t1.customer_id = t2.customer_id` and `JOIN order_items AS t3 ON t2.order_id = t3.order_id` instead of querying only the `customers` table. Do add a WHERE filter `t3.order_quantity = (SELECT max(order_quantity) FROM order_items)` instead of ordering by `quantity DESC LIMIT 1`. Do remove `ORDER BY quantity DESC LIMIT 1` instead of keeping it. Do qualify the column as `t1.customer_name` instead of just `customer_name`. The amended query now correctly identifies customers with maximum order quantities through proper table joins and subquery filtering instead of relying on a simple limit approach."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name FROM customers ORDER BY quantity DESC LIMIT 1;",
            "SELECT t1.customer_name\nFROM Customers AS t1\nJOIN Customer_Orders AS t2 ON t1.customer_id = t2.customer_id\nJOIN Order_Items AS t3 ON t2.order_id = t3.order_id\nWHERE t3.order_quantity = (SELECT MAX(order_quantity) FROM Order_Items)"
        ],
        "rule_sql": []
    },
    "2406": {
        "db_id": "candidate_poll",
        "question": "List all people names in the order of their date of birth from old to young.",
        "ground_truth": "SELECT name FROM people ORDER BY date_of_birth",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM people ORDER BY date_of_birth ASC;"
        ],
        "rule_sql": []
    },
    "5797": {
        "db_id": "customer_complaints",
        "question": "Return complaint status codes have more than 3 corresponding complaints?",
        "ground_truth": "SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  3",
        "amends": [
            "Do reference `complaint_status_code` instead of `status_code` in both the SELECT list and GROUP BY clause. Do move the count filter to `HAVING count(*) > 3` instead of incorrectly placing `complaint_count > 3` in the WHERE clause where aggregate results are not available. Do remove the alias `complaint_count` from the SELECT list instead of keeping it since it's not needed when filtering by the aggregate in HAVING. The amended query now correctly filters groups by their aggregate count using HAVING instead of the invalid WHERE clause approach, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT status_code, COUNT(*) as complaint_count \nFROM complaints \nWHERE complaint_count > 3 \nGROUP BY status_code",
            "SELECT complaint_status_code FROM Complaints GROUP BY complaint_status_code HAVING COUNT(*) > 3"
        ],
        "rule_sql": []
    },
    "5991": {
        "db_id": "game_1",
        "question": "Show ids for all students who have advisor 1121.",
        "ground_truth": "SELECT StuID FROM Student WHERE Advisor  =  1121",
        "amends": [
            "Do reference the `StuID` column instead of `student_id` and use the `Student` table instead of `students`. Do filter on the `Advisor` column instead of `advisor_id` while maintaining the same filter value of `1121`. The amended query now correctly matches the intended behavior by using the proper table and column names from the schema."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_id FROM students WHERE advisor_id = 1121",
            "SELECT StuID FROM Student WHERE Advisor = 1121"
        ],
        "rule_sql": []
    },
    "6453": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "Show budget type codes and the number of documents in each budget type.",
        "ground_truth": "SELECT budget_type_code ,  count(*) FROM Documents_with_expenses GROUP BY budget_type_code",
        "amends": [
            "Do select `budget_type_code` instead of `budget_type` and use `Documents_with_expenses` as the source table instead of `documents`. Do group by `budget_type_code` instead of `document_id` to properly aggregate counts by budget type rather than by document identifier. The amended query now correctly counts documents grouped by their budget type codes using the appropriate source table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT budget_type, COUNT(*) FROM documents GROUP BY document_id;",
            "SELECT Budget_Type_Code, COUNT(Document_ID) AS Number_of_Documents FROM Documents_with_Expenses GROUP BY Budget_Type_Code;"
        ],
        "rule_sql": []
    },
    "1260": {
        "db_id": "apartment_rentals",
        "question": "Show the most common apartment type code.",
        "ground_truth": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use column name `apt_type_code` instead of `apartment_type_code` in both SELECT and GROUP BY clauses. Do order by `count(*) DESC` instead of `count ASC` to find the most frequent apartment type rather than the least frequent. Do remove the alias `count` from the SELECT list instead of including it since it's not needed for the ORDER BY when using the aggregate function directly. Do return only `apt_type_code` instead of both the code and count in the SELECT list. The amended query now correctly identifies the most common apartment type by counting occurrences in descending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT apartment_type_code, COUNT(*) as count FROM apartments GROUP BY apartment_type_code ORDER BY count ASC LIMIT 1;",
            "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5514": {
        "db_id": "voter_2",
        "question": "Report the distinct advisors who have more than 2 students.",
        "ground_truth": "SELECT Advisor FROM STUDENT GROUP BY Advisor HAVING count(*)  >  2",
        "amends": [
            "Do use the correct table name `STUDENT` instead of `advisors` and the correct column name `Advisor` instead of `advisor_name`. Do place the aggregate condition in a `HAVING` clause with `count(*) > 2` instead of incorrectly using `WHERE COUNT(student_id) > 2`. Do remove the incorrect `student_id` column reference from the count function and use `count(*)` instead. Do ensure proper grouping syntax by placing `GROUP BY Advisor` before the `HAVING` clause instead of mixing aggregate conditions in the `WHERE` clause. The amended query now correctly identifies advisors with more than two students by counting all rows in each advisor group."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT advisor_name FROM advisors WHERE COUNT(student_id) > 2 GROUP BY advisor_name",
            "SELECT Advisor FROM Student GROUP BY Advisor HAVING COUNT(*) > 2"
        ],
        "rule_sql": []
    },
    "471": {
        "db_id": "allergy_1",
        "question": "Show student ids for all male students.",
        "ground_truth": "SELECT StuID FROM Student WHERE Sex  =  'M'",
        "amends": [
            "Do select `StuID` instead of `student_id` and use table `Student` instead of `students`. Do filter on `Sex = 'M'` instead of `gender = 'female'` to match the correct gender criteria. The amended query now correctly retrieves male students from the Student table as specified in the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_id FROM students WHERE gender = 'female';",
            "SELECT StuID FROM Student WHERE Sex = 'M';"
        ],
        "rule_sql": []
    },
    "408": {
        "db_id": "flight_1",
        "question": "What place has the most flights coming from there?",
        "ground_truth": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference the table as `Flight` instead of `flights` in the FROM clause. Do remove the explicit column `flight_count` from the SELECT list instead of including it. Do change the ORDER BY direction to `DESC` instead of `ASC` to find the origin with the highest count. Do reference the aggregate function directly as `count(*)` in ORDER BY instead of using the alias `flight_count`. The amended query now correctly identifies the origin with the most flights by counting records per origin and sorting descending by count."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT origin, COUNT(*) as flight_count FROM flights GROUP BY origin ORDER BY flight_count ASC LIMIT 1;",
            "SELECT origin FROM flight GROUP BY origin ORDER BY count(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2954": {
        "db_id": "sakila_1",
        "question": "Which film actors (actresses) played a role in more than 30 films? List his or her first name and last name.",
        "ground_truth": "SELECT T2.first_name ,  T2.last_name FROM film_actor AS T1 JOIN actor AS T2 ON T1.actor_id  =  T2.actor_id GROUP BY T2.actor_id HAVING count(*)  >  30",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name \nFROM actor \nWHERE actor_id IN (\n    SELECT actor_id \n    FROM film_actor \n    GROUP BY actor_id \n    HAVING COUNT(film_id) > 30\n)"
        ],
        "rule_sql": []
    },
    "5465": {
        "db_id": "voter_2",
        "question": "Return all the distinct secretary votes made in the fall election cycle.",
        "ground_truth": "SELECT DISTINCT Secretary_Vote FROM VOTING_RECORD WHERE ELECTION_CYCLE  =  \"Fall\"",
        "amends": [
            "Do select `DISTINCT Secretary_Vote` instead of `*` with all columns. Do use table `VOTING_RECORD` instead of `votes`. Do filter on `ELECTION_CYCLE = \"Fall\"` instead of `election_cycle = 'fall'` with different case handling and quotes. Do remove the `position = 'secretary'` filter instead of keeping it. The amended query now correctly retrieves distinct secretary votes from the voting record for the fall election cycle."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM votes WHERE election_cycle = 'fall' AND position = 'secretary'",
            "SELECT DISTINCT Secretary_Vote FROM Voting_record WHERE Election_Cycle = 'Fall'"
        ],
        "rule_sql": []
    },
    "4863": {
        "db_id": "school_player",
        "question": "What is the list of school locations sorted in ascending order of school enrollment?",
        "ground_truth": "SELECT LOCATION FROM school ORDER BY Enrollment ASC",
        "amends": [
            "Do reference the `school` table instead of `schools` in the FROM clause. Do order by `Enrollment` in ascending order instead of descending order. Do use uppercase column names `LOCATION` and `Enrollment` instead of lowercase. The amended query now correctly retrieves location data from the school table sorted by enrollment in ascending order.",
            "Do remove the `Enrollment` column from the SELECT list instead of including it, while keeping the `ORDER BY Enrollment ASC` clause to sort by enrollment values without displaying them in the output. The amended query now matches RIGHT_SQL's behavior by selecting only location information while maintaining the enrollment-based sorting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location FROM schools ORDER BY enrollment DESC;",
            "SELECT LOCATION, Enrollment FROM school ORDER BY Enrollment ASC;",
            "SELECT LOCATION FROM school ORDER BY Enrollment ASC;"
        ],
        "rule_sql": []
    },
    "187": {
        "db_id": "bike_1",
        "question": "What are the ids and durations of the trips with the top 3 durations?",
        "ground_truth": "SELECT id ,  duration FROM trip ORDER BY duration DESC LIMIT 3",
        "amends": [
            "Do reference table `trip` instead of `trips` to correctly access the intended data source. The amended query now matches RIGHT_SQL's behavior by using the proper table name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, duration FROM trips ORDER BY duration DESC LIMIT 3;",
            "SELECT id, duration FROM trip ORDER BY duration DESC LIMIT 3;"
        ],
        "rule_sql": []
    },
    "92": {
        "db_id": "student_assessment",
        "question": "What are the different cities where people live?",
        "ground_truth": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id",
        "amends": [
            "Do add `addresses AS T1` and `people_addresses AS T2` as FROM sources instead of omitting them. Do add `JOIN` on `T1.address_id = T2.address_id` instead of having no join condition. Do change the column reference to `T1.city` instead of just `city` to specify the table source. Do keep `DISTINCT` and `city IS NOT NULL` filter instead of removing them. Do keep `ORDER BY city` instead of changing it. The amended query now correctly joins the addresses and people_addresses tables to retrieve distinct cities while maintaining the same filtering and ordering behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT city FROM people WHERE city IS NOT NULL ORDER BY city;",
            "SELECT DISTINCT T1.city\nFROM addresses AS T1\nJOIN people_addresses AS T2 ON T1.address_id = T2.address_id\nWHERE T1.city IS NOT NULL\nORDER BY T1.city"
        ],
        "rule_sql": []
    },
    "2394": {
        "db_id": "candidate_poll",
        "question": "How many candidates are there?",
        "ground_truth": "SELECT count(*) FROM candidate",
        "amends": [
            "Do query the `candidate` table instead of the `employees` table, as the data source has been completely changed to reflect the correct dataset being analyzed. The amended query now matches RIGHT_SQL's behavior by counting records from the appropriate candidate table rather than the incorrect employees table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees;",
            "SELECT COUNT(*) FROM candidate;"
        ],
        "rule_sql": []
    },
    "3290": {
        "db_id": "college_1",
        "question": "What is the number of professors who are in the Accounting or Biology departments?",
        "ground_truth": "SELECT count(*) FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T2.dept_name  =  'Accounting' OR T2.dept_name  =  'Biology'",
        "amends": [
            "Do join `professor` with `department` on `dept_code` instead of querying only the `professors` table. Do filter on `dept_name` with `OR` condition for 'Accounting' or 'Biology' instead of using `AND` with both department names which would always return zero results. Do use table aliases `T1` and `T2` for clarity instead of no aliases. The amended query now correctly counts professors from either the Accounting or Biology departments by properly joining with the department table and using appropriate filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM professors WHERE department = 'Accounting' AND department = 'Biology';",
            "SELECT COUNT(DISTINCT T1.EMP_NUM) \nFROM PROFESSOR T1\nJOIN DEPARTMENT T2 ON T1.DEPT_CODE = T2.DEPT_CODE\nWHERE T2.DEPT_NAME = 'Accounting' OR T2.DEPT_NAME = 'Biology'"
        ],
        "rule_sql": []
    },
    "3682": {
        "db_id": "baseball_1",
        "question": "How much salary did the top 3 well-paid players get in 2001?",
        "ground_truth": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;",
        "amends": [
            "Do reference the `salary` table instead of the `players` table in the FROM clause, as the salary data is stored in the correct table. The amended query now correctly retrieves salaries from the salary table for the year 2001, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT salary FROM players WHERE year = 2001 ORDER BY salary DESC LIMIT 3;",
            "SELECT salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;"
        ],
        "rule_sql": []
    },
    "3084": {
        "db_id": "loan_1",
        "question": "Find the average credit score of the customers who do not have any loan.",
        "ground_truth": "SELECT avg(credit_score) FROM customer WHERE cust_id NOT IN (SELECT cust_id FROM loan)",
        "amends": [
            "Do reference the `customer` table instead of `customers` and use `avg` instead of `AVG` for the aggregate function. Do change the filtering approach to use a `NOT IN` subquery against the `loan` table to find customers without loans instead of checking for `loan_id IS NULL` in the `customers` table. Do remove the direct `loan_id` column reference since it doesn't exist in the `customer` table schema and instead correlate through `cust_id` between tables. The amended query now correctly identifies customers without any loan records by using a subquery against the separate loan table instead of relying on a non-existent nullable loan_id column in the customer table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(credit_score) FROM customers WHERE loan_id IS NULL;",
            "SELECT avg(credit_score) FROM customer WHERE cust_ID NOT IN (SELECT cust_ID FROM loan)"
        ],
        "rule_sql": []
    },
    "2000": {
        "db_id": "gas_company",
        "question": "What are the names and headquarters of all companies ordered by descending market value?",
        "ground_truth": "SELECT company ,  headquarters FROM company ORDER BY market_value DESC",
        "amends": [
            "Do use column alias `company` instead of `name` in the SELECT list. Do reference table `company` instead of `companies` in the FROM clause. Do use `DESC` ordering instead of `ASC` in the ORDER BY clause. The amended query now correctly selects from the company table with proper column naming and descending market value ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, headquarters FROM companies ORDER BY market_value ASC;",
            "SELECT Company AS company, Headquarters FROM company ORDER BY Market_Value DESC;"
        ],
        "rule_sql": []
    },
    "5538": {
        "db_id": "products_gen_characteristics",
        "question": "Which category does the product named \"flax\" belong to?",
        "ground_truth": "SELECT product_category_code FROM products WHERE product_name  =  \"flax\"",
        "amends": [
            "Do reference `product_category_code` instead of `category` in the SELECT list. Do filter on `product_name = \"flax\"` instead of `name = 'flax'` in the WHERE clause, correcting both the column reference and string literal syntax. The amended query now correctly retrieves the product category code for products named flax using the proper column names and string quotation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category FROM products WHERE name = 'flax';",
            "SELECT product_category_code FROM Products WHERE product_name = 'flax';"
        ],
        "rule_sql": []
    },
    "6751": {
        "db_id": "activity_1",
        "question": "Show the ids of students whose advisors are professors.",
        "ground_truth": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  \"Professor\"",
        "amends": [
            "Do use explicit `JOIN` syntax with `Faculty AS T1 JOIN Student AS T2` instead of a subquery with `IN`. Do reference `T2.StuID` instead of `student_id` and join on `T1.FacID = T2.advisor` instead of filtering by `advisor_id IN (SELECT professor_id)`. Do add the filter `T1.rank = \"Professor\"` instead of omitting it, which ensures only professors are considered. Do use table aliases `T1` and `T2` instead of direct table names. The amended query now correctly matches the RIGHT_SQL's behavior by using an explicit join with proper filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_id FROM students WHERE advisor_id IN (SELECT professor_id FROM professors);",
            "SELECT T2.StuID\nFROM Faculty AS T1\nJOIN Student AS T2 ON T1.FacID = T2.Advisor\nWHERE T1.Rank = 'Professor'"
        ],
        "rule_sql": []
    },
    "2815": {
        "db_id": "news_report",
        "question": "Show the names of journalists that have reported more than one event.",
        "ground_truth": "SELECT T3.Name FROM news_report AS T1 JOIN event AS T2 ON T1.Event_ID  =  T2.Event_ID JOIN journalist AS T3 ON T1.journalist_ID  =  T3.journalist_ID GROUP BY T3.Name HAVING COUNT(*)  >  1",
        "amends": [
            "Do use `T3.Name` from the `journalist` table instead of `name` from the `journalists` table. Do join `news_report AS T1` and `event AS T2` on `T1.Event_ID = T2.Event_ID` instead of missing these source tables entirely. Do add a second join to `journalist AS T3` on `T1.journalist_ID = T3.journalist_ID` instead of omitting this relationship. Do group by `T3.Name` instead of `journalist_id` to properly aggregate by journalist name. Do use `HAVING COUNT(*) > 1` instead of `WHERE COUNT(event_id) > 1` to correctly apply the aggregate filter after grouping. The amended query now correctly identifies journalists who have reported on more than one event by properly joining the necessary tables and using HAVING for aggregate conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM journalists WHERE COUNT(event_id) > 1 GROUP BY journalist_id",
            "SELECT T3.Name\nFROM news_report AS T1\nJOIN event AS T2 ON T1.Event_ID = T2.Event_ID\nJOIN journalist AS T3 ON T1.journalist_ID = T3.journalist_ID\nGROUP BY T3.Name\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": []
    },
    "783": {
        "db_id": "race_track",
        "question": "Show the name and date for each race and its track name.",
        "ground_truth": "SELECT T1.name ,  T1.date ,  T2.name FROM race AS T1 JOIN track AS T2 ON T1.track_id  =  T2.track_id",
        "amends": [
            "Do reference tables with aliases `T1` and `T2` instead of using full table names. Do select columns `T1.name` and `T1.date` instead of `race_name` and `race_date`. Do use table names `race` and `track` instead of `races` and `tracks`. Do maintain the same `JOIN` condition on `T1.track_id = T2.track_id` instead of `races.track_id = tracks.track_id`. The amended query now correctly references the schema with proper table aliases and column selections while preserving the join logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT race_name, race_date, track_name FROM races JOIN tracks ON races.track_id = tracks.track_id",
            "SELECT T1.Name, T1.Date, T2.Name FROM race T1 JOIN track T2 ON T1.Track_ID = T2.Track_ID"
        ],
        "rule_sql": []
    },
    "2816": {
        "db_id": "news_report",
        "question": "List the names of journalists who have not reported any event.",
        "ground_truth": "SELECT Name FROM journalist WHERE journalist_ID NOT IN (SELECT journalist_ID FROM news_report)",
        "amends": [
            "Do reference table `journalist` instead of `journalists` and use column `journalist_ID` instead of `journalist_id`. Do use column `Name` instead of `name` in the SELECT list. Do reference subquery table `news_report` instead of `events` while maintaining the same NOT IN logic structure. The amended query now correctly filters for journalists not present in news reports rather than events."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM journalists WHERE journalist_id NOT IN (SELECT journalist_id FROM events)",
            "SELECT Name FROM journalist WHERE journalist_ID NOT IN (SELECT journalist_ID FROM news_report)"
        ],
        "rule_sql": []
    },
    "2176": {
        "db_id": "formula_1",
        "question": "What are the names and years of all races that had a driver with the last name Lewis?",
        "ground_truth": "SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = \"Lewis\"",
        "amends": [
            "Do add `results AS T1` and `drivers AS T3` tables instead of omitting them, and do use `JOIN races AS T2 ON T1.raceid = T2.raceid` and `JOIN drivers AS T3 ON T1.driverid = T3.driverid` instead of querying `races` alone. Do change the filter to `T3.forename = \"Lewis\"` instead of `driver_last_name = 'Lewis'` to properly reference the driver's first name from the joined drivers table. Do qualify the selected columns as `T2.name` and `T2.year` instead of unqualified `name` and `year` to specify the table source. The amended query now correctly joins through results to find races where drivers named Lewis participated, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, year FROM races WHERE driver_last_name = 'Lewis';",
            "SELECT T2.name, T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceId = T2.raceId JOIN drivers AS T3 ON T1.driverId = T3.driverId WHERE T3.forename = 'Lewis'"
        ],
        "rule_sql": []
    },
    "186": {
        "db_id": "bike_1",
        "question": "What are the dates that have the 5 highest cloud cover rates and what are the rates?",
        "ground_truth": "SELECT date ,  cloud_cover FROM weather ORDER BY cloud_cover DESC LIMIT 5",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT date, cloud_cover FROM weather ORDER BY cloud_cover DESC LIMIT 5;"
        ],
        "rule_sql": []
    },
    "4950": {
        "db_id": "soccer_2",
        "question": "How many players have more than 1000 hours of training?",
        "ground_truth": "SELECT count(*) FROM Player WHERE HS  >  1000",
        "amends": [
            "Do reference table `Player` instead of `players` in the FROM clause. Do filter on column `HS` instead of `training_hours` in the WHERE condition. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for the aggregate function. The amended query now correctly counts records from the Player table where HS values exceed 1000, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE training_hours > 1000;",
            "SELECT count(*) FROM Player WHERE HS > 1000"
        ],
        "rule_sql": []
    },
    "4480": {
        "db_id": "network_2",
        "question": "What is the total number of people who has no friend living in the city of Austin.",
        "ground_truth": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  'Austin')",
        "amends": [
            "Do `count(DISTINCT name)` instead of `COUNT(*)` to count distinct names rather than all rows. Do use `PersonFriend` table instead of `Person` as the main data source. Do filter with `friend NOT IN` instead of `person_id NOT IN` to check friend relationships. Do use a simpler subquery `SELECT name FROM person WHERE city = 'Austin'` instead of the complex join subquery with `Friend` and `Person` tables. Do remove the unnecessary table aliases and join operations that were present in the original subquery. The amended query now correctly counts distinct names of friends who are not from Austin, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM Person p\nWHERE p.person_id NOT IN (\n    SELECT f.person_id \n    FROM Friend f\n    JOIN Person p2 ON f.friend_id = p2.person_id\n    WHERE p2.city = 'Austin'\n)",
            "SELECT COUNT(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM Person WHERE city = 'Austin')"
        ],
        "rule_sql": []
    },
    "3044": {
        "db_id": "loan_1",
        "question": "Find the name of customers whose credit score is below the average credit scores of all customers.",
        "ground_truth": "SELECT cust_name FROM customer WHERE credit_score  <  (SELECT avg(credit_score) FROM customer)",
        "amends": [
            "Do reference `cust_name` instead of `name` and use table `customer` instead of `customers`. Do remove the redundant `WHERE credit_score IS NOT NULL` filter in the subquery since `AVG` already ignores NULL values, instead of including it. The amended query now correctly selects from the customer table with the proper column name and eliminates unnecessary filtering, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM customers WHERE credit_score < (SELECT AVG(credit_score) FROM customers WHERE credit_score IS NOT NULL)",
            "SELECT cust_name FROM customer WHERE credit_score < (SELECT AVG(credit_score) FROM customer)"
        ],
        "rule_sql": []
    },
    "1630": {
        "db_id": "wedding",
        "question": "Show the name, open date, and organizer for all churches.",
        "ground_truth": "SELECT name ,  open_date ,  organized_by FROM Church",
        "amends": [
            "Do reference the `organized_by` column instead of `organizer` to match the correct column name in the schema. Do use the correct table name `Church` instead of `churches` to reference the proper database object. Do maintain the same `SELECT` list structure with `name` and `open_date` columns as they are correctly included in both queries. Do preserve the `WHERE` filter on `type = 'cathedral'` as this condition remains valid and unchanged. The amended query now correctly retrieves cathedral information from the proper table with accurate column references, matching the RIGHT_SQL's behavior.",
            "Do use lowercase column names `name`, `open_date`, and `organized_by` instead of mixed case `Name`, `Open_Date`, and `Organized_by`. Do reference the table as `Church` instead of lowercase `church`. The amended query now matches RIGHT_SQL's behavior with identical case sensitivity and table reference.",
            "Do use the exact same column references `name`, `open_date`, and `organized_by` instead of changing any column selection. Do maintain the same table reference `church` instead of altering the source table. Do preserve the identical filter condition `type = 'cathedral'` instead of modifying the WHERE clause predicate. The amended query now matches RIGHT_SQL's behavior as both queries perform the identical selection from the church table with the same filtering criteria, with only insignificant whitespace and capitalization differences that do not affect the logical execution.",
            "Do use the exact same `SELECT` list with columns `name`, `open_date`, and `organized_by` instead of changing any column selection. Do maintain the identical `FROM` source `Church` instead of using a different table name. Do preserve the exact `WHERE` filter `type = 'cathedral'` instead of modifying the condition. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, open_date, organizer FROM churches WHERE type = 'cathedral';",
            "SELECT Name, Open_Date, Organized_by FROM church WHERE type = 'cathedral';",
            "SELECT name, open_date, organized_by FROM church WHERE type = 'cathedral';",
            "SELECT name, open_date, organized_by FROM church WHERE type = 'cathedral';",
            "SELECT name, open_date, organized_by FROM church;"
        ],
        "rule_sql": []
    },
    "1480": {
        "db_id": "college_2",
        "question": "Find courses that ran in Fall 2009 but not in Spring 2010.",
        "ground_truth": "SELECT course_id FROM SECTION WHERE semester  =  'Fall' AND YEAR  =  2009 EXCEPT SELECT course_id FROM SECTION WHERE semester  =  'Spring' AND YEAR  =  2010",
        "amends": [
            "Do query the `SECTION` table instead of the `courses` table. Do use separate filters for `semester = 'Fall'` and `YEAR = 2009` instead of the impossible condition `semester = 'Fall 2009' AND semester = 'Spring 2010'`. Do add an `EXCEPT` operation to subtract courses from Spring 2010 instead of attempting to find courses that satisfy both semester conditions simultaneously. Do remove the single combined semester/year filter and instead implement proper temporal logic using separate semester and year columns with set operations. The amended query now correctly identifies courses offered in Fall 2009 but not in Spring 2010, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT course_id FROM courses WHERE semester = 'Fall 2009' AND semester = 'Spring 2010';",
            "SELECT course_id FROM section WHERE semester = 'Fall' AND year = 2009\nEXCEPT\nSELECT course_id FROM section WHERE semester = 'Spring' AND year = 2010;"
        ],
        "rule_sql": []
    },
    "3832": {
        "db_id": "e_learning",
        "question": "List the dates of enrollment and completion of the student with personal name \"Karson\".",
        "ground_truth": "SELECT T1.date_of_enrolment ,  T1.date_of_completion FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id WHERE T2.personal_name  =  \"Karson\"",
        "amends": [
            "Do select `date_of_enrolment` and `date_of_completion` from the `Student_Course_Enrolment` table instead of `enrollment_date` and `completion_date` from the `students` table. Do join `Student_Course_Enrolment` with `Students` on `student_id` instead of querying only the `students` table. Do filter on `personal_name = \"Karson\"` instead of `first_name = 'Karson'` to use the correct column name and quotation style. The amended query now correctly retrieves enrollment data by joining the appropriate tables and using the proper column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT enrollment_date, completion_date FROM students WHERE first_name = 'Karson';",
            "SELECT s.date_of_enrolment, s.date_of_completion \nFROM Student_Course_Enrolment s\nJOIN Students st ON s.student_id = st.student_id\nWHERE st.personal_name = 'Karson'"
        ],
        "rule_sql": []
    },
    "4301": {
        "db_id": "club_1",
        "question": "Count the number of members in club \"Bootup Baltimore\" whose age is above 18.",
        "ground_truth": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.age  >  18",
        "amends": [
            "Do add joins to `club`, `member_of_club`, and `student` tables instead of querying only the `members` table. Do use `clubname` from the `club` table instead of `club_name` from a non-existent table. Do filter on `age` from the `student` table instead of from an undefined source. Do join on `clubid` and `stuid` keys instead of missing proper table relationships. The amended query now correctly counts students over 18 who are members of the specified club by establishing proper table relationships through joins."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM members WHERE club_name = 'Bootup Baltimore' AND age > 18;",
            "SELECT COUNT(*) \nFROM Student s\nJOIN Member_of_club m ON s.StuID = m.StuID\nJOIN Club c ON m.ClubID = c.ClubID\nWHERE c.ClubName = 'Bootup Baltimore' \nAND s.Age > 18"
        ],
        "rule_sql": []
    },
    "372": {
        "db_id": "flight_1",
        "question": "What is the average and largest salary of all employees?",
        "ground_truth": "SELECT avg(salary) ,  max(salary) FROM Employee",
        "amends": [
            "Do use `max(salary)` instead of `MIN(salary) as largest_salary` to correctly calculate the maximum salary. Do remove the alias `average_salary` instead of keeping it for the average calculation. Do reference the table as `Employee` instead of `employees` to match the correct schema. The amended query now correctly calculates both average and maximum salary values from the Employee table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(salary) as average_salary, MIN(salary) as largest_salary FROM employees;",
            "SELECT AVG(salary) AS average_salary, MAX(salary) AS largest_salary FROM employee"
        ],
        "rule_sql": []
    },
    "441": {
        "db_id": "allergy_1",
        "question": "How many different allergy types exist?",
        "ground_truth": "SELECT count(DISTINCT allergytype) FROM Allergy_type",
        "amends": [
            "Do select `count(DISTINCT allergytype)` instead of `COUNT(*)` to count distinct allergy types rather than all rows. Do reference table `Allergy_type` instead of `allergies` to query from the correct table containing allergy type information. The amended query now correctly counts distinct allergy types from the appropriate table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM allergies;",
            "SELECT COUNT(DISTINCT AllergyType) FROM Allergy_Type;"
        ],
        "rule_sql": []
    },
    "6890": {
        "db_id": "tracking_orders",
        "question": "Which order's shipment tracking number is \"3452\"? Give me the id of the order.",
        "ground_truth": "SELECT order_id FROM shipments WHERE shipment_tracking_number = \"3452\"",
        "amends": [
            "Do select `order_id` from the `shipments` table instead of `id` from the `orders` table. Do filter on `shipment_tracking_number` with string value \"3452\" instead of `tracking_number` with numeric value 3452. The amended query now correctly retrieves shipment tracking information from the appropriate table with proper data type handling."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM orders WHERE tracking_number = 3452;",
            "SELECT order_id FROM Shipments WHERE shipment_tracking_number = '3452';"
        ],
        "rule_sql": []
    },
    "702": {
        "db_id": "customers_card_transactions",
        "question": "What are the valid from and valid to dates for the card with the number 4560596484842?",
        "ground_truth": "SELECT date_valid_from ,  date_valid_to FROM Customers_cards WHERE card_number  =  \"4560596484842\"",
        "amends": [
            "Do reference table `Customers_cards` instead of `cards` in the FROM clause. Do use column names `date_valid_from` and `date_valid_to` instead of `valid_from` and `valid_to` in the SELECT list. Do use double quotes `\"4560596484842\"` instead of single quotes `'4560596484842'` for the string literal in the WHERE filter. The amended query now correctly retrieves the date validity columns from the appropriate customer cards table with proper string quoting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT valid_from, valid_to FROM cards WHERE card_number = '4560596484842';",
            "SELECT date_valid_from, date_valid_to FROM Customers_Cards WHERE card_number = \"4560596484842\""
        ],
        "rule_sql": []
    },
    "5617": {
        "db_id": "swimming",
        "question": "List countries that have more than one swimmer.",
        "ground_truth": "SELECT nationality ,  count(*) FROM swimmer GROUP BY nationality HAVING count(*)  >  1",
        "amends": [
            "Do use column `nationality` instead of `country` in both the SELECT list and GROUP BY clause. Do reference table `swimmer` instead of `swimmers` as the data source. The amended query now correctly identifies swimmers by nationality rather than country and uses the proper table name, matching the intended behavior of counting swimmers grouped by nationality where the count exceeds one."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) FROM swimmers GROUP BY country HAVING COUNT(*) > 1;",
            "SELECT Nationality, COUNT(*) as swimmer_count FROM swimmer GROUP BY Nationality HAVING COUNT(*) > 1"
        ],
        "rule_sql": []
    },
    "6020": {
        "db_id": "game_1",
        "question": "What is the sport with the most scholarship students?",
        "ground_truth": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do query the `Sportsinfo` table instead of the `students` table. Do use the column `sportname` instead of `sport` in both the SELECT list and GROUP BY clause. Do filter on `onscholarship = 'Y'` instead of `scholarship = 'yes'`. Do remove the alias `scholarship_count` and instead use `count(*)` directly in the ORDER BY clause. The amended query now correctly retrieves sports with scholarship information from the appropriate table using the proper column names and filter conditions.",
            "Do remove the `SportName` column from the SELECT list instead of including it, as the query only needs to return the sport name with the highest count. Do use lowercase `sportname` and `onscholarship` instead of mixed case `SportName` and `OnScholarship` to match the actual column names. Do maintain the same WHERE filter `onscholarship = 'Y'`, GROUP BY `sportname`, ORDER BY `count(*) DESC`, and LIMIT 1 clauses without changes. The amended query now correctly returns only the sport name with the highest count of scholarship athletes instead of returning both the sport name and the count value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT sport, COUNT(*) as scholarship_count FROM students WHERE scholarship = 'yes' GROUP BY sport ORDER BY scholarship_count DESC LIMIT 1;",
            "SELECT SportName, COUNT(*) FROM SportsInfo WHERE OnScholarship = 'Y' GROUP BY SportName ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT sportname FROM SportsInfo WHERE onscholarship = 'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "4766": {
        "db_id": "department_store",
        "question": "Return the phone numbers for all customers and suppliers.",
        "ground_truth": "SELECT customer_phone FROM customers UNION SELECT supplier_phone FROM suppliers",
        "amends": [
            "Do select `customer_phone` from the customers table instead of `phone`, and do select `supplier_phone` from the suppliers table instead of `phone`. The amended query now correctly references the appropriate phone column names from each table while maintaining the UNION operation to combine results from both sources."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT phone FROM customers UNION SELECT phone FROM suppliers;",
            "SELECT customer_phone AS phone FROM Customers\nUNION\nSELECT supplier_phone AS phone FROM Suppliers;"
        ],
        "rule_sql": []
    },
    "6277": {
        "db_id": "city_record",
        "question": "Find the venue of the competition \"1994 FIFA World Cup qualification\" which was hosted by \"Nanjing ( Jiangsu )\".",
        "ground_truth": "SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = \"Nanjing ( Jiangsu )\" AND T3.competition = \"1994 FIFA World Cup qualification\"",
        "amends": [
            "Do select `T3.venue` from the `MATCH` table instead of `venue` from `competitions`. Do join `city` as `T1` and `hosting_city` as `T2` on `T1.city_id = T2.host_city` instead of querying a single table. Do add a second join to `MATCH` as `T3` on `T2.match_id = T3.match_id` instead of no join. Do filter on `T1.city = \"Nanjing ( Jiangsu )\"` instead of `host_city = 'Nanjing ( Jiangsu )'`. Do filter on `T3.competition = \"1994 FIFA World Cup qualification\"` instead of `competition_name = '1994 FIFA World Cup qualification'`. The amended query now correctly navigates the relational schema through proper table joins to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT venue FROM competitions WHERE competition_name = '1994 FIFA World Cup qualification' AND host_city = 'Nanjing ( Jiangsu )';",
            "SELECT T3.Venue\nFROM city T1\nJOIN hosting_city T2 ON T1.City_ID = T2.Host_City\nJOIN match T3 ON T2.Match_ID = T3.Match_ID\nWHERE T1.City = 'Nanjing ( Jiangsu )'\nAND T3.Competition = '1994 FIFA World Cup qualification'"
        ],
        "rule_sql": []
    },
    "1909": {
        "db_id": "school_finance",
        "question": "List the name, IHSAA Football Class, and Mascot of the schools that have more than 6000 of budgeted amount or were founded before 2003, in the order of percent of total invested budget and total budgeted budget.",
        "ground_truth": "SELECT T1.School_name ,  T1.Mascot ,  T1.IHSAA_Football_Class FROM school AS T1 JOIN budget AS T2 ON T1.school_id  =  T2.school_id WHERE Budgeted  >  6000 OR YEAR  <  2003 ORDER BY T2.total_budget_percent_invested ,  T2.total_budget_percent_budgeted",
        "amends": [
            "Do select `T1.School_name`, `T1.Mascot`, and `T1.IHSAA_Football_Class` instead of `name`, `ihsaa_football_class`, and `mascot`. Do use `FROM school AS T1 JOIN budget AS T2` instead of `FROM schools` alone. Do add join condition `ON T1.school_id = T2.school_id` instead of omitting it. Do filter on `Budgeted > 6000` and `YEAR < 2003` instead of `budgeted_amount > 6000` and `founded_year < 2003`. Do order by `T2.total_budget_percent_invested` and `T2.total_budget_percent_budgeted` instead of `percent_total_invested_budget` and `total_budgeted_budget`. The amended query now correctly joins the school and budget tables and references the appropriate columns from each table.",
            "Do reorder the SELECT list to `School_name, Mascot, IHSAA_Football_Class` instead of `School_name, IHSAA_Football_Class, Mascot`. Do reference `YEAR` instead of `T2.Year` in the WHERE clause filter. The amended query now matches RIGHT_SQL's behavior with identical column ordering and proper column reference."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, ihsaa_football_class, mascot \nFROM schools \nWHERE budgeted_amount > 6000 OR founded_year < 2003 \nORDER BY percent_total_invested_budget, total_budgeted_budget;",
            "SELECT T1.School_name, T1.IHSAA_Football_Class, T1.Mascot \nFROM School AS T1 \nJOIN budget AS T2 ON T1.School_id = T2.School_id \nWHERE T2.Budgeted > 6000 OR T2.Year < 2003 \nORDER BY T2.total_budget_percent_invested, T2.total_budget_percent_budgeted",
            "SELECT T1.School_name, T1.Mascot, T1.IHSAA_Football_Class \nFROM School AS T1 \nJOIN budget AS T2 ON T1.School_id = T2.School_id \nWHERE T2.Budgeted > 6000 OR T2.Year < 2003 \nORDER BY T2.total_budget_percent_invested, T2.total_budget_percent_budgeted"
        ],
        "rule_sql": []
    },
    "5822": {
        "db_id": "workshop_paper",
        "question": "What is the average score of submissions?",
        "ground_truth": "SELECT avg(Scores) FROM submission",
        "amends": [
            "Do reference the `Scores` column instead of `score` to match the correct column name. Do reference the `submission` table instead of `submissions` to match the correct table name. Do use lowercase `avg` function instead of uppercase `AVG` for consistency with the correct query. The amended query now correctly calculates the average of the Scores column from the submission table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(score) FROM submissions WHERE score > 100;",
            "SELECT avg(Scores) FROM submission;"
        ],
        "rule_sql": []
    },
    "4058": {
        "db_id": "student_1",
        "question": "Find all students taught by OTHA MOYER. Output the first and last names of the students.",
        "ground_truth": "SELECT T1.firstname ,  T1.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"OTHA\" AND T2.lastname  =  \"MOYER\"",
        "amends": [
            "Do use table alias `T1` for the student table instead of `s`, and select columns `firstname` and `lastname` instead of `first_name` and `last_name`. Do join on `classroom` instead of `teacher_id` as the join condition. Do use table name `list` instead of `students` as the source table. Do use double quotes around string literals instead of single quotes. Do use table alias `T2` for the teachers table instead of `t`. The amended query now correctly joins students and teachers by classroom rather than teacher_id and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.first_name, s.last_name \nFROM students s \nJOIN teachers t ON s.teacher_id = t.teacher_id \nWHERE t.first_name = 'OTHA' AND t.last_name = 'MOYER';",
            "SELECT T1.FirstName, T1.LastName FROM list T1 JOIN teachers T2 ON T1.Classroom = T2.Classroom WHERE T2.FirstName = \"OTHA\" AND T2.LastName = \"MOYER\""
        ],
        "rule_sql": []
    },
    "262": {
        "db_id": "musical",
        "question": "Please show the nominee who has been nominated the greatest number of times.",
        "ground_truth": "SELECT Nominee FROM musical GROUP BY Nominee ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select only `Nominee` instead of both `nominee` and `nomination_count`, and do remove the explicit alias `nomination_count` instead of keeping it. Do change the table source to `musical` instead of `nominations`. Do change the aggregation to `COUNT(*)` in the `ORDER BY` clause instead of using the alias `nomination_count`. Do change the sort direction to `DESC` instead of `ASC` to find the nominee with the highest count rather than the lowest. The amended query now correctly identifies the nominee with the most nominations from the musical table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT nominee, COUNT(*) as nomination_count FROM nominations GROUP BY nominee ORDER BY nomination_count ASC LIMIT 1;",
            "SELECT Nominee FROM musical GROUP BY Nominee ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "69": {
        "db_id": "student_assessment",
        "question": "How many students attend course English?",
        "ground_truth": "SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = \"English\"",
        "amends": [
            "Do join `courses AS T1` and `student_course_attendance AS T2` on `T1.course_id = T2.course_id` instead of querying only the `students` table. Do filter on `T1.course_name = \"English\"` instead of `course = 'English'` to properly reference the course name from the courses table. Do use double quotes for the string literal instead of single quotes for consistency. The amended query now correctly counts student attendance for English courses by joining the appropriate tables and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE course = 'English';",
            "SELECT COUNT(DISTINCT T2.student_id) \nFROM courses AS T1 \nJOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id \nWHERE T1.course_name = \"English\""
        ],
        "rule_sql": []
    },
    "6479": {
        "db_id": "scientist_1",
        "question": "Find the name of project that continues for the longest time.",
        "ground_truth": "SELECT name FROM projects ORDER BY hours DESC LIMIT 1",
        "amends": [
            "Do order by `hours DESC` instead of `start_date DESC`."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM projects ORDER BY start_date DESC LIMIT 1;",
            "SELECT Name FROM Projects ORDER BY Hours DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1474": {
        "db_id": "college_2",
        "question": "List in alphabetic order the names of all distinct instructors.",
        "ground_truth": "SELECT DISTINCT name FROM  instructor ORDER BY name",
        "amends": [
            "Do add `DISTINCT` instead of omitting it to eliminate duplicate name values. Do remove the explicit `ASC` direction specification instead of keeping it since ascending order is the default. The amended query now correctly returns unique instructor names sorted alphabetically, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM instructors ORDER BY name ASC",
            "SELECT DISTINCT name FROM instructor ORDER BY name;"
        ],
        "rule_sql": []
    },
    "3478": {
        "db_id": "hr_1",
        "question": "What are the employee ids of employees who report to Payam, and what are their salaries?",
        "ground_truth": "SELECT employee_id ,  salary FROM employees WHERE manager_id  =  (SELECT employee_id FROM employees WHERE first_name  =  'Payam' )",
        "amends": [
            "Do use a subquery `(SELECT employee_id FROM employees WHERE first_name = 'Payam')` instead of directly filtering by `manager_name = 'Payam'` to properly reference the manager by their employee ID rather than name. Do filter on `manager_id` instead of `manager_name` to maintain referential integrity through the correct foreign key relationship. The amended query now correctly identifies employees who report to the manager named 'Payam' by first finding that manager's employee ID and then matching it against the manager_id field, ensuring accurate results that match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT employee_id, salary FROM employees WHERE manager_name = 'Payam';",
            "SELECT employee_id, salary FROM employees WHERE manager_id = (SELECT employee_id FROM employees WHERE first_name = 'Payam')"
        ],
        "rule_sql": []
    },
    "6502": {
        "db_id": "scientist_1",
        "question": "What are the SSN and names of scientists working on the project with the most hours?",
        "ground_truth": "SELECT T3.ssn ,  T3.name FROM assignedto AS T1 JOIN projects AS T2 ON T1.project  =  T2.code JOIN scientists AS T3 ON T1.scientist  =  T3.SSN WHERE T2.hours  =  (SELECT max(hours) FROM projects)",
        "amends": [
            "Do use explicit joins with `assignedto AS T1`, `projects AS T2`, and `scientists AS T3` instead of querying `Scientists` directly. Do join on `T1.project = T2.code` and `T1.scientist = T3.SSN` instead of using a subquery with `ProjectID`. Do filter with `T2.hours = (SELECT max(hours) FROM projects)` instead of `ORDER BY Hours DESC LIMIT 1`. Do select `T3.ssn` and `T3.name` instead of `SSN` and `Name` from the `Scientists` table directly. The amended query now correctly finds scientists working on the project with maximum hours by properly joining through the assignment table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SSN, Name FROM Scientists WHERE ProjectID = (SELECT ProjectID FROM Projects ORDER BY Hours DESC LIMIT 1);",
            "SELECT T3.ssn, T3.name\nFROM assignedto AS T1\nJOIN projects AS T2 ON T1.project = T2.code\nJOIN scientists AS T3 ON T1.scientist = T3.SSN\nWHERE T2.hours = (SELECT max(hours) FROM projects)"
        ],
        "rule_sql": []
    },
    "2945": {
        "db_id": "sakila_1",
        "question": "What are the payment dates for any payments that have an amount greater than 10 or were handled by a staff member with the first name Elsa?",
        "ground_truth": "SELECT payment_date FROM payment WHERE amount  >  10 UNION SELECT T1.payment_date FROM payment AS T1 JOIN staff AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.first_name  =  'Elsa'",
        "amends": [
            "Do use `UNION` to combine results from two separate queries instead of using `IN` with a subquery. Do add a second query with `JOIN` between `payment AS T1` and `staff AS T2` on `T1.staff_id = T2.staff_id` instead of the subquery approach. Do include the filter `T2.first_name = 'Elsa'` in the JOIN query's WHERE clause instead of the subquery condition. Do maintain the `amount > 10` filter in the first query instead of removing it. The amended query now correctly retrieves payment dates either where amount exceeds 10 or where staff first name is Elsa, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT payment_date FROM payment WHERE amount > 10 AND staff_id IN (SELECT staff_id FROM staff WHERE first_name = 'Elsa')",
            "SELECT payment_date FROM payment WHERE amount > 10\nUNION\nSELECT T1.payment_date FROM payment AS T1\nJOIN staff AS T2 ON T1.staff_id = T2.staff_id\nWHERE T2.first_name = 'Elsa'"
        ],
        "rule_sql": []
    },
    "4082": {
        "db_id": "student_1",
        "question": "For each classroom, report the classroom number and the number of grades using it.",
        "ground_truth": "SELECT classroom ,  count(DISTINCT grade) FROM list GROUP BY classroom",
        "amends": [
            "Do select `classroom` and `count(DISTINCT grade)` instead of `classroom_number` and `COUNT(*)`. Do use table `list` instead of `grades`. Do group by `classroom` instead of `classroom_number`. The amended query now correctly counts distinct grades per classroom rather than counting all rows, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT classroom_number, COUNT(*) FROM grades GROUP BY classroom_number;",
            "SELECT classroom, COUNT(DISTINCT Grade) FROM list GROUP BY classroom;"
        ],
        "rule_sql": []
    },
    "2976": {
        "db_id": "sakila_1",
        "question": "Which staff handled least number of payments? List the full name and the id.",
        "ground_truth": "SELECT T1.first_name ,  T1.last_name ,  T1.staff_id FROM staff AS T1 JOIN payment AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T1.staff_id ORDER BY count(*) ASC LIMIT 1",
        "amends": [
            "Do select `first_name`, `last_name`, and `staff_id` instead of including `payment_count` as an aggregate column. Do use `count(*)` in the ORDER BY clause instead of referencing the aliased `payment_count`. Do order by `count(*) ASC` instead of `payment_count DESC` to find the staff member with the fewest payments. Do group by only `T1.staff_id` instead of grouping by `staff_id`, `first_name`, and `last_name` since staff_id is sufficient for grouping. Do use table aliases `T1` and `T2` consistently instead of mixed alias usage. The amended query now correctly identifies the staff member with the minimum payment count by using ascending order on the count aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT staff_id, first_name, last_name, COUNT(payment_id) as payment_count\nFROM staff s\nJOIN payment p ON s.staff_id = p.staff_id\nGROUP BY staff_id, first_name, last_name\nORDER BY payment_count DESC\nLIMIT 1;",
            "SELECT T1.first_name, T1.last_name, T1.staff_id\nFROM staff T1\nJOIN payment T2 ON T1.staff_id = T2.staff_id\nGROUP BY T1.staff_id\nORDER BY COUNT(*) ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "2334": {
        "db_id": "csu_1",
        "question": "Find the name of the campuses that is in Northridge, Los Angeles or in San Francisco, San Francisco.",
        "ground_truth": "SELECT campus FROM campuses WHERE LOCATION  =  \"Northridge\" AND county  =  \"Los Angeles\" UNION SELECT campus FROM campuses WHERE LOCATION  =  \"San Francisco\" AND county  =  \"San Francisco\"",
        "amends": [
            "Do select `campus` instead of `name` from the campuses table. Do use `LOCATION` column instead of `city` for filtering campus locations. Do use `county` column instead of `state` for geographic classification. Do replace the OR condition with a `UNION` of two separate queries instead of using a single query with mixed AND/OR logic that could produce incorrect results due to operator precedence. Do use double quotes around string literals instead of single quotes for consistency. The amended query now correctly retrieves campuses from specific locations and counties using proper UNION semantics instead of potentially ambiguous boolean logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM campuses WHERE city = 'Northridge' AND state = 'Los Angeles' OR city = 'San Francisco' AND state = 'San Francisco';",
            "SELECT Campus FROM Campuses WHERE Location = \"Northridge\" AND County = \"Los Angeles\" UNION SELECT Campus FROM Campuses WHERE Location = \"San Francisco\" AND County = \"San Francisco\""
        ],
        "rule_sql": []
    },
    "359": {
        "db_id": "flight_1",
        "question": "Show names for all aircrafts with distances more than the average.",
        "ground_truth": "SELECT name FROM Aircraft WHERE distance  >  (SELECT avg(distance) FROM Aircraft)",
        "amends": [
            "Do reference the table as `Aircraft` instead of `aircrafts` to match the correct schema. Do use the aggregate function `avg` instead of `AVG` for proper case sensitivity. The amended query now correctly filters aircraft by comparing distance to the average distance from the same table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM aircrafts WHERE distance > (SELECT AVG(distance) FROM aircrafts)",
            "SELECT name FROM aircraft WHERE distance > (SELECT avg(distance) FROM aircraft)"
        ],
        "rule_sql": []
    },
    "6694": {
        "db_id": "driving_school",
        "question": "List first name and last name of customers that have more than 2 payments.",
        "ground_truth": "SELECT T2.first_name ,  T2.last_name FROM Customer_Payments AS T1 JOIN Customers AS T2 ON T1.customer_id = T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >  2;",
        "amends": [
            "Do join `Customer_Payments` and `Customers` tables instead of querying only the `customers` table. Do use `JOIN` with `ON T1.customer_id = T2.customer_id` instead of no join condition. Do add `GROUP BY T1.customer_id` instead of omitting grouping. Do move the count filter to `HAVING count(*) > 2` instead of `WHERE payment_count > 2`. Do reference columns with table aliases `T2.first_name` and `T2.last_name` instead of unqualified `first_name` and `last_name`. The amended query now correctly counts payments per customer and filters on the aggregate count instead of relying on a potentially non-existent `payment_count` column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM customers WHERE payment_count > 2",
            "SELECT c.first_name, c.last_name\nFROM Customers c\nJOIN Customer_Payments cp ON c.customer_id = cp.customer_id\nGROUP BY c.customer_id\nHAVING COUNT(*) > 2"
        ],
        "rule_sql": []
    },
    "1616": {
        "db_id": "customers_and_invoices",
        "question": "What are the different product names, and what is the sum of quantity ordered for each product?",
        "ground_truth": "SELECT T2.product_name ,  sum(T1.product_quantity) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id GROUP BY T2.product_name",
        "amends": [
            "Do reference `T2.product_name` instead of `product_name` and `sum(T1.product_quantity)` instead of `SUM(quantity)`. Do join `Products AS T2` on `T1.product_id = T2.product_id` instead of omitting the join entirely. Do use `T1.product_quantity` from the `Order_items AS T1` table instead of `quantity` from a non-existent `orders` table. Do group by `T2.product_name` instead of `product_id` to properly aggregate by the product name rather than the ID. The amended query now correctly joins the order items with products and aggregates quantities by product name, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name, SUM(quantity) FROM orders GROUP BY product_id;",
            "SELECT T2.product_name, SUM(T1.product_quantity) AS total_quantity\nFROM Order_Items AS T1\nJOIN Products AS T2 ON T1.product_id = T2.product_id\nGROUP BY T2.product_name"
        ],
        "rule_sql": []
    },
    "1148": {
        "db_id": "climbing",
        "question": "Show the names of mountains with height more than 5000 or prominence more than 1000.",
        "ground_truth": "SELECT Name FROM mountain WHERE Height  >  5000 OR Prominence  >  1000",
        "amends": [
            "Do reference the table as `mountain` instead of `mountains` to match the correct schema. Do use column names `Name`, `Height`, and `Prominence` instead of `name`, `height`, and `prominence` to match the correct case sensitivity. Do use `OR` instead of `AND` in the WHERE clause to include mountains that meet either height or prominence criteria instead of requiring both conditions simultaneously. The amended query now correctly retrieves all mountains with either height greater than 5000 or prominence greater than 1000, matching the intended logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM mountains WHERE height > 5000 AND prominence > 1000;",
            "SELECT Name FROM mountain WHERE Height > 5000 OR Prominence > 1000"
        ],
        "rule_sql": []
    },
    "5008": {
        "db_id": "soccer_2",
        "question": "Find the state of the college which player Charles is attending.",
        "ground_truth": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  'Charles'",
        "amends": [
            "Do select `T1.state` instead of `college`. Do use `FROM college AS T1 JOIN tryout AS T2 ON T1.cName = T2.cName JOIN player AS T3 ON T2.pID = T3.pID` instead of `FROM players`. Do add join conditions `ON T1.cName = T2.cName` and `ON T2.pID = T3.pID` instead of omitting them. Do filter with `T3.pName = 'Charles'` instead of `name = 'Charles'`. The amended query now correctly joins multiple tables to find the state of the college where player Charles tried out, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT college FROM players WHERE name = 'Charles';",
            "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName = T2.cName JOIN player AS T3 ON T2.pID = T3.pID WHERE T3.pName = 'Charles'"
        ],
        "rule_sql": []
    },
    "5156": {
        "db_id": "cre_Drama_Workshop_Groups",
        "question": "What is the marketing region code that has the most drama workshop groups?",
        "ground_truth": "SELECT Marketing_Region_Code FROM Drama_Workshop_Groups GROUP BY Marketing_Region_Code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference the `Drama_Workshop_Groups` table instead of `workshop_groups` with a `WHERE` filter. Do use the exact column name `Marketing_Region_Code` instead of `marketing_region_code`. Do remove the `WHERE workshop_type = 'drama'` filter condition instead of keeping it, as the table name already implies the specific workshop type. The amended query now correctly selects from the specialized drama workshop table and matches the RIGHT_SQL's behavior.",
            "Do remove the explicit `COUNT(*) as group_count` column from the SELECT list instead of including it, and do reference the aggregate function directly in the ORDER BY clause as `count(*)` instead of using the column alias `group_count`. Do maintain the same GROUP BY clause on `Marketing_Region_Code` and LIMIT 1 constraint to identify the region with the highest count of drama workshop groups. The amended query now correctly returns only the Marketing_Region_Code value while preserving the ranking logic based on group count."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT marketing_region_code \nFROM workshop_groups \nWHERE workshop_type = 'drama' \nGROUP BY marketing_region_code \nORDER BY COUNT(*) DESC \nLIMIT 1;",
            "SELECT Marketing_Region_Code, COUNT(*) as group_count\nFROM Drama_Workshop_Groups\nGROUP BY Marketing_Region_Code\nORDER BY group_count DESC\nLIMIT 1;",
            "SELECT Marketing_Region_Code \nFROM Drama_Workshop_Groups \nGROUP BY Marketing_Region_Code \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "6689": {
        "db_id": "driving_school",
        "question": "What is the city with the most customers?",
        "ground_truth": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT 1;",
        "amends": [
            "Do join the `Addresses` table as `T2` on `T1.customer_address_id = T2.address_id` instead of querying only the `customers` table without any join. Do select `T2.city` instead of `city` to explicitly reference the joined table. Do use `COUNT(*)` in the `ORDER BY` clause instead of ordering by the alias `customer_count`. Do order by `DESC` instead of `ASC` to find the city with the highest count rather than the lowest. Do remove the column alias `customer_count` instead of keeping it since it's not used in the final selection. The amended query now correctly identifies the city with the most customers by joining the necessary address information and ordering by descending count.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, and do remove the alias `AS` from `Customers AS T1` and `Addresses AS T2` instead of keeping them, as these are purely cosmetic changes that do not affect the query logic. The amended query now correctly returns only the city with the highest count of customers while maintaining the same join condition, grouping, ordering, and limit behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, COUNT(*) as customer_count FROM customers GROUP BY city ORDER BY customer_count ASC LIMIT 1;",
            "SELECT T2.city, COUNT(*) \nFROM Customers T1\nJOIN Addresses T2 ON T1.customer_address_id = T2.address_id\nGROUP BY T2.city\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T2.city\nFROM Customers T1\nJOIN Addresses T2 ON T1.customer_address_id = T2.address_id\nGROUP BY T2.city\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "1759": {
        "db_id": "gymnast",
        "question": "Give the different hometowns of gymnasts that have a total point score of above 57.5.",
        "ground_truth": "SELECT DISTINCT T2.Hometown FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID WHERE T1.Total_Points  >  57.5",
        "amends": [
            "Do join `gymnast AS T1` with `people AS T2` on `T1.Gymnast_ID = T2.People_ID` instead of querying only the `gymnasts` table. Do select `T2.Hometown` from the joined `people` table instead of `hometown` directly from `gymnasts`. Do use the correct table alias and column reference `T1.Total_Points` in the WHERE filter instead of `total_points` from a single table. The amended query now correctly retrieves hometown information from the related people table while filtering based on gymnast performance metrics, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT hometown FROM gymnasts WHERE total_points > 57.5;",
            "SELECT DISTINCT T2.Hometown \nFROM gymnast AS T1 \nJOIN people AS T2 ON T1.Gymnast_ID = T2.People_ID \nWHERE T1.Total_Points > 57.5"
        ],
        "rule_sql": []
    },
    "5043": {
        "db_id": "soccer_2",
        "question": "What are the names of all colleges with a larger enrollment than the largest college in Florida?",
        "ground_truth": "SELECT cName FROM college WHERE enr  >  (SELECT max(enr) FROM college WHERE state  =  'FL')",
        "amends": [
            "Do use column name `cName` instead of `name` and table name `college` instead of `colleges`. Do use column `enr` instead of `enrollment` in both the main query and subquery. Do use state filter `'FL'` instead of `'Florida'` in the subquery. Do use aggregate function `max(enr)` instead of `MAX(enrollment)` in the subquery. The amended query now correctly filters for colleges with enrollment greater than the maximum enrollment of colleges in Florida using the proper column names and state abbreviation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM colleges WHERE enrollment > (SELECT MAX(enrollment) FROM colleges WHERE state = 'Florida');",
            "SELECT cName FROM College WHERE enr > (SELECT MAX(enr) FROM College WHERE state = 'FL')"
        ],
        "rule_sql": []
    },
    "671": {
        "db_id": "customers_card_transactions",
        "question": "Show other account details for account with name 338.",
        "ground_truth": "SELECT other_account_details FROM Accounts WHERE account_name  =  \"338\"",
        "amends": [
            "Do select `other_account_details` instead of `*` for all columns. Do reference table `Accounts` instead of `accounts` with proper case. Do filter on `account_name = \"338\"` instead of `account_id = 338` using string comparison rather than numeric. Do use double quotes around the string literal instead of no quotes for the numeric value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM accounts WHERE account_id = 338;",
            "SELECT other_account_details FROM Accounts WHERE account_name = \"338\""
        ],
        "rule_sql": []
    },
    "2586": {
        "db_id": "inn_1",
        "question": "How many kids stay in the room DAMIEN TRACHSEL checked in on Sep 21, 2010?",
        "ground_truth": "SELECT Kids FROM Reservations WHERE CheckIn  =  \"2010-09-21\" AND FirstName  =  \"DAMIEN\" AND LastName  =  \"TRACHSEL\";",
        "amends": [
            "Do select `Kids` instead of `COUNT(*)` and use table `Reservations` instead of `kids`. Do filter with `CheckIn = \"2010-09-21\"` instead of a subquery and add `FirstName = \"DAMIEN\"` and `LastName = \"TRACHSEL\"` instead of the subquery's `guest_name = 'DAMIEN TRACHSEL'` condition. Do remove the subquery entirely instead of using it to filter by `room_id`. The amended query now correctly retrieves the number of kids directly from the Reservations table using the guest's first and last name with the check-in date, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM kids WHERE room_id = (SELECT room_id FROM checkins WHERE guest_name = 'DAMIEN TRACHSEL' AND checkin_date = '2010-09-21')",
            "SELECT Kids FROM Reservations WHERE CheckIn = \"2010-09-21\" AND FirstName = \"DAMIEN\" AND LastName = \"TRACHSEL\";"
        ],
        "rule_sql": []
    },
    "6377": {
        "db_id": "flight_company",
        "question": "What is the most common company type, and how many are there?",
        "ground_truth": "SELECT TYPE ,  count(*) FROM operate_company GROUP BY TYPE ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference table `operate_company` instead of `companies` and use column `TYPE` instead of `company_type` in both SELECT and GROUP BY clauses. Do use `count(*)` without an alias instead of `COUNT(*) as count` in the SELECT list. Do maintain the same ORDER BY `count(*) DESC` and `LIMIT 1` structure. The amended query now correctly references the intended table and column names while preserving the aggregation logic to find the most frequent company type."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT company_type, COUNT(*) as count FROM companies GROUP BY company_type ORDER BY count DESC LIMIT 1;",
            "SELECT Type, count(*) FROM operate_company GROUP BY Type ORDER BY count(*) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "3595": {
        "db_id": "music_1",
        "question": "Return the names of singers who are from UK and released an English song.",
        "ground_truth": "SELECT artist_name FROM artist WHERE country  =  \"UK\" INTERSECT SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  \"english\"",
        "amends": [
            "Do select `artist_name` instead of `singer_name` and use table `artist` instead of `singers`. Do change the filter approach to use `INTERSECT` with a subquery instead of a single `WHERE` clause. Do add a join between `artist` and `song` tables on `artist_name` instead of keeping a single table. Do move the language filter to the subquery's `WHERE` clause on `song.languages` instead of applying it directly to the main table. Do use double quotes around string literals instead of single quotes. The amended query now correctly finds artists from the UK who have songs in English by intersecting two result sets, matching the RIGHT_SQL's behavior.",
            "Do use `INTERSECT` with consistent table references instead of mixing base table and joined table queries. Do add an explicit join between `artist AS T1` and `song AS T2` on `T1.artist_name = T2.artist_name` instead of querying the song table independently. Do reference `T1.artist_name` in the second SELECT instead of directly using `artist_name` to maintain table context. Do move the language filter to the WHERE clause of the joined query instead of applying it to a standalone song table query. Do use lowercase comparison `\"english\"` instead of `\"English\"` for consistent string matching. The amended query now correctly finds artists from the UK who have songs in English by properly joining the tables instead of using an invalid intersection approach."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT singer_name FROM singers WHERE country = 'UK' AND language = 'English';",
            "SELECT artist_name FROM artist WHERE country = \"UK\"\nINTERSECT\nSELECT artist_name FROM song WHERE languages = \"English\"",
            "SELECT artist_name FROM artist WHERE country = \"UK\"\nINTERSECT\nSELECT T1.artist_name FROM artist AS T1\nJOIN song AS T2 ON T1.artist_name = T2.artist_name\nWHERE T2.languages = \"english\""
        ],
        "rule_sql": []
    },
    "1945": {
        "db_id": "cinema",
        "question": "Show the title and director for all films.",
        "ground_truth": "SELECT title ,  directed_by FROM film",
        "amends": [
            "Do select `directed_by` instead of `producer` as the second column in the SELECT list. Do reference the table as `film` instead of `films` in the FROM clause. The amended query now correctly retrieves film titles with their directors from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, producer FROM films;",
            "SELECT Title, Directed_by FROM film;"
        ],
        "rule_sql": []
    },
    "3274": {
        "db_id": "college_1",
        "question": "What are the first names of all professors not teaching any classes?",
        "ground_truth": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num",
        "amends": [
            "Do select `emp_fname` from the `employee` table instead of `first_name` from `professors`. Do use a job code filter `emp_jobcode = 'PROF'` in the WHERE clause instead of omitting it. Do replace the `NOT IN` subquery with `EXCEPT` set operation instead of keeping the subquery approach. Do join `employee AS T1` with `CLASS AS T2` on `emp_num = prof_num` instead of using a subquery that references `professor_id` from different tables. Do remove the direct table reference to `professors` and instead filter employee records by job code to identify professors. The amended query now correctly identifies professors by job code and uses proper table relationships through explicit joins rather than assuming table structures."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM professors WHERE professor_id NOT IN (SELECT professor_id FROM classes);",
            "SELECT emp_fname FROM employee WHERE emp_jobcode = 'PROF' EXCEPT SELECT e.emp_fname FROM employee e JOIN CLASS c ON e.emp_num = c.prof_num WHERE e.emp_jobcode = 'PROF'"
        ],
        "rule_sql": []
    },
    "5918": {
        "db_id": "cre_Theme_park",
        "question": "Which tourist attraction is associated with the photo \"game1\"? Return its name.",
        "ground_truth": "SELECT T2.Name FROM PHOTOS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID WHERE T1.Name  =  \"game1\"",
        "amends": [
            "Do add `PHOTOS AS T1 JOIN` and `TOURIST_ATTRACTIONS AS T2` as FROM sources instead of only `tourist_attractions`. Do use `JOIN` with `ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID` instead of no join condition. Do change the WHERE filter to `T1.Name = \"game1\"` instead of `photo = 'game1'`. Do select `T2.Name` instead of just `name`. The amended query now correctly joins the PHOTOS and TOURIST_ATTRACTIONS tables to find attractions associated with photos named \"game1\" instead of incorrectly searching for a photo column in the tourist_attractions table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM tourist_attractions WHERE photo = 'game1';",
            "SELECT T2.Name \nFROM Photos AS T1 \nJOIN Tourist_Attractions AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID \nWHERE T1.Name = 'game1'"
        ],
        "rule_sql": []
    },
    "2080": {
        "db_id": "party_people",
        "question": "Which event names were used more than twice for party events?",
        "ground_truth": "SELECT event_name FROM party_events GROUP BY event_name HAVING count(*)  >  2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT event_name FROM party_events GROUP BY event_name HAVING COUNT(*) > 2;"
        ],
        "rule_sql": []
    },
    "4246": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "Show the ids of all employees who don't destroy any document.",
        "ground_truth": "SELECT employee_id FROM Employees EXCEPT SELECT Destroyed_by_Employee_ID FROM Documents_to_be_destroyed",
        "amends": [
            "Do use `EXCEPT` set operation to exclude destroyed documents instead of filtering with `WHERE document_destroyed = 0`. Do reference the `Employees` table with proper case sensitivity instead of lowercase `employees`. Do add a subquery `SELECT Destroyed_by_Employee_ID FROM Documents_to_be_destroyed` to identify employees who destroyed documents instead of relying on a boolean flag. Do remove the `WHERE` clause entirely instead of keeping the potentially incorrect filter condition. The amended query now correctly identifies employees who haven't destroyed any documents by using set difference rather than a simple boolean check, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT employee_id FROM employees WHERE document_destroyed = 0",
            "SELECT Employee_ID FROM Employees\nEXCEPT\nSELECT Destroyed_by_Employee_ID FROM Documents_to_be_Destroyed"
        ],
        "rule_sql": []
    },
    "2849": {
        "db_id": "customer_deliveries",
        "question": "List the names and emails of customers who payed by Visa card.",
        "ground_truth": "SELECT customer_email ,  customer_name FROM customers WHERE payment_method  =  'Visa'",
        "amends": [
            "Do select `customer_email` and `customer_name` instead of `name` and `email`. Do filter for `payment_method = 'Visa'` instead of `payment_method = 'Mastercard'`. The amended query now correctly retrieves customer information for Visa payment method users.",
            "Do maintain the same column selection of `customer_name` and `customer_email` but change their order to `customer_email, customer_name` instead of `customer_name, customer_email`. Do keep the same table source `Customers` with the same case instead of changing it to lowercase `customers`. Do preserve the identical WHERE filter `payment_method = 'Visa'` without any changes to the predicate logic. The amended query now matches RIGHT_SQL's behavior with identical column selection and filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, email FROM customers WHERE payment_method = 'Mastercard';",
            "SELECT customer_name, customer_email FROM Customers WHERE payment_method = 'Visa';",
            "SELECT customer_email, customer_name FROM Customers WHERE payment_method = 'Visa';"
        ],
        "rule_sql": []
    },
    "4193": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "Find the name and description of the role with code \"MG\".",
        "ground_truth": "SELECT role_name ,  role_description FROM ROLES WHERE role_code  =  \"MG\"",
        "amends": [
            "Do use `role_name` and `role_description` instead of `name` and `description` in the SELECT list. Do use double quotes `\"MG\"` instead of single quotes `'MG'` for the string literal in the WHERE filter. The amended query now correctly references the actual column names and uses proper string quoting to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, description FROM roles WHERE role_code = 'MG';",
            "SELECT role_name, role_description FROM Roles WHERE Role_Code = \"MG\";"
        ],
        "rule_sql": []
    },
    "6097": {
        "db_id": "customers_and_addresses",
        "question": "Which contact channel has been used by the customer with name \"Tillman Ernser\"?",
        "ground_truth": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  \"Tillman Ernser\"",
        "amends": [
            "Do select `channel_code` instead of `channel` and add `DISTINCT` instead of omitting it. Do use `customers` table aliased as `t1` instead of `contacts` table and add `JOIN` with `customer_contact_channels` table aliased as `t2` instead of a single table. Do specify join condition `ON t1.customer_id = t2.customer_id` instead of no join condition. Do keep filter on `customer_name = 'Tillman Ernser'` but move it to the `customers` table instead of the original table. The amended query now correctly retrieves distinct channel codes from the joined customer and contact channels tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT channel FROM contacts WHERE customer_name = 'Tillman Ernser';",
            "SELECT DISTINCT t2.channel_code\nFROM Customers t1\nJOIN Customer_Contact_Channels t2 ON t1.customer_id = t2.customer_id\nWHERE t1.customer_name = 'Tillman Ernser'"
        ],
        "rule_sql": []
    },
    "6100": {
        "db_id": "customers_and_addresses",
        "question": "Return the the \"active to date\" of the latest contact channel used by the customer named \"Tillman Ernser\".",
        "ground_truth": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  \"Tillman Ernser\"",
        "amends": [
            "Do select `max(t2.active_to_date)` as an aggregate instead of just `active_to_date` without aggregation. Do join `customers AS t1` with `customer_contact_channels AS t2` on `t1.customer_id = t2.customer_id` instead of querying only `contact_channels` table. Do filter on `t1.customer_name = 'Tillman Ernser'` instead of filtering directly on `customer_name` in the contact_channels table. Do remove `ORDER BY created_at DESC LIMIT 1` instead of using ordering and limiting to get the maximum value. The amended query now correctly retrieves the maximum active_to_date for the specified customer by properly joining the customer and contact channel tables and using aggregate functions instead of ordering/limiting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT active_to_date FROM contact_channels WHERE customer_name = 'Tillman Ernser' ORDER BY created_at DESC LIMIT 1;",
            "SELECT MAX(t2.active_to_date) \nFROM Customers AS t1 \nJOIN Customer_Contact_Channels AS t2 ON t1.customer_id = t2.customer_id \nWHERE t1.customer_name = 'Tillman Ernser'"
        ],
        "rule_sql": []
    },
    "3789": {
        "db_id": "e_learning",
        "question": "Return the login names of the students whose family name is \"Ward\".",
        "ground_truth": "SELECT login_name FROM Students WHERE family_name  =  \"Ward\"",
        "amends": [
            "Do select `login_name` instead of `first_name` from the `Students` table instead of `students`. Do filter on `family_name = \"Ward\"` instead of `last_name = 'Ward'` using double quotes instead of single quotes for the string literal. The amended query now correctly retrieves login names for students with the specified family name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM students WHERE last_name = 'Ward';",
            "SELECT login_name FROM Students WHERE family_name = \"Ward\""
        ],
        "rule_sql": []
    },
    "677": {
        "db_id": "customers_card_transactions",
        "question": "Show all customer ids and the number of accounts for each customer.",
        "ground_truth": "SELECT customer_id ,  count(*) FROM Accounts GROUP BY customer_id",
        "amends": [
            "Do group by `customer_id` instead of `account_id` to correctly aggregate counts per customer rather than per account. Do reference table `Accounts` instead of `accounts` to match the correct case sensitivity. The amended query now correctly counts accounts per customer and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_id, COUNT(*) FROM accounts GROUP BY account_id;",
            "SELECT customer_id, COUNT(account_id) AS number_of_accounts FROM Accounts GROUP BY customer_id"
        ],
        "rule_sql": []
    },
    "3576": {
        "db_id": "music_1",
        "question": "What are the names and genders of all artists who released songs in the month of March?",
        "ground_truth": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE \"%Mar%\"",
        "amends": [
            "Do select `T1.artist_name` and `T1.gender` with table aliases instead of `name` and `gender` without table qualification. Do join `artist AS T1` with `song AS T2` on `T1.artist_name = T2.artist_name` instead of querying only the `artists` table. Do filter on `T2.releasedate LIKE \"%Mar%\"` from the joined song table instead of `release_date LIKE '%-03-%'` from the artists table. Do use the joined song table's release date column for month filtering instead of the artist table's date field, ensuring the query correctly identifies artists with songs released in March rather than artists with any March-related date in their own record."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, gender FROM artists WHERE release_date LIKE '%-03-%';",
            "SELECT T1.artist_name, T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name = T2.artist_name WHERE T2.releasedate LIKE '%Mar%'"
        ],
        "rule_sql": []
    },
    "893": {
        "db_id": "insurance_fnol",
        "question": "What are the customer phone numbers under the policy \"Life Insurance\"?",
        "ground_truth": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  \"Life Insurance\"",
        "amends": [
            "Do select `customer_phone` instead of `phone` and do use table `available_policies` instead of `customers`. Do use column `policy_type_code` instead of `policy_type` and do use double quotes `\"Life Insurance\"` instead of single quotes for the string literal. The amended query now correctly retrieves phone numbers from the appropriate policies table using the correct column names and string formatting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT phone FROM customers WHERE policy_type = 'Life Insurance';",
            "SELECT customer_phone FROM Available_Policies WHERE policy_type_code = \"Life Insurance\";"
        ],
        "rule_sql": []
    },
    "189": {
        "db_id": "bike_1",
        "question": "For each station, return its longitude and the average duration of trips that started from the station.",
        "ground_truth": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id",
        "amends": [
            "Do specify `T1.name` and `T1.long` instead of `station_id` and `longitude` in the SELECT list. Do use `avg(T2.duration)` instead of `AVG(duration)` with proper table qualification. Do join `station AS T1` with `trip AS T2` instead of querying only the trips table. Do use `ON T1.id = T2.start_station_id` instead of missing join conditions. Do group by `T2.start_station_id` instead of `station_id`. The amended query now correctly joins station and trip tables to calculate average trip durations per station while including station details."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT station_id, longitude, AVG(duration) FROM trips GROUP BY station_id;",
            "SELECT T1.name, T1.long, AVG(T2.duration) AS average_duration\nFROM station AS T1\nJOIN trip AS T2 ON T1.id = T2.start_station_id\nGROUP BY T2.start_station_id"
        ],
        "rule_sql": []
    },
    "2875": {
        "db_id": "icfp_1",
        "question": "Find the first names and last names of the authors whose institution affiliation is \"University of Oxford\".",
        "ground_truth": "SELECT DISTINCT t1.fname ,  t1.lname FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN inst AS t3 ON t2.instid  =  t3.instid WHERE t3.name  =  \"University of Oxford\"",
        "amends": [
            "Do select `t1.fname` and `t1.lname` instead of `first_name` and `last_name`. Do add `DISTINCT` instead of omitting it. Do change the FROM clause to use `authors AS t1` joined with `authorship AS t2` on `t1.authid = t2.authid` instead of a single table. Do add a second join with `inst AS t3` on `t2.instid = t3.instid` instead of no join. Do change the WHERE filter to `t3.name = \"University of Oxford\"` instead of `institution = 'University of Oxford'`. The amended query now correctly filters by institution name through proper table relationships instead of relying on a potentially missing or incorrect column in the authors table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM authors WHERE institution = 'University of Oxford';",
            "SELECT DISTINCT t1.fname, t1.lname\nFROM Authors AS t1\nJOIN Authorship AS t2 ON t1.authID = t2.authID\nJOIN Inst AS t3 ON t2.instID = t3.instID\nWHERE t3.name = 'University of Oxford'"
        ],
        "rule_sql": []
    },
    "1837": {
        "db_id": "browser_web",
        "question": "How many accelerators are not compatible with the browsers listed ?",
        "ground_truth": "SELECT count(*) FROM web_client_accelerator WHERE id NOT IN ( SELECT accelerator_id FROM accelerator_compatible_browser );",
        "amends": [
            "Do query the `web_client_accelerator` table instead of `accelerators`. Do use a subquery with `NOT IN` to filter records where `accelerator_id` is not present in `accelerator_compatible_browser` instead of checking for `NULL` values in `browser_compatibility`. Do count records from the correct table with proper filtering logic instead of using an incorrect null check approach. The amended query now correctly identifies accelerators without browser compatibility records by checking for missing relationships in the join table rather than relying on a potentially incorrect null column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM accelerators WHERE browser_compatibility IS NULL;",
            "SELECT COUNT(*) \nFROM Web_client_accelerator \nWHERE id NOT IN (SELECT DISTINCT accelerator_id FROM accelerator_compatible_browser)"
        ],
        "rule_sql": []
    },
    "4189": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "Count the total number of roles listed.",
        "ground_truth": "SELECT count(*) FROM ROLES",
        "amends": [
            "Do reference the `ROLES` table instead of the `employees` table in the FROM clause. Do remove the `WHERE role IS NOT NULL` filter instead of keeping it, as the count should include all records from the ROLES table regardless of null values. The amended query now correctly counts all rows in the ROLES table without unnecessary filtering, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE role IS NOT NULL;",
            "SELECT COUNT(*) FROM Roles;"
        ],
        "rule_sql": []
    },
    "572": {
        "db_id": "store_1",
        "question": "How many albums has Billy Cobam released?",
        "ground_truth": "SELECT count(*) FROM albums AS T1 JOIN artists AS T2 ON  T1.artist_id = T2.id WHERE T2.name = \"Billy Cobham\";",
        "amends": [
            "Do join `artists AS T2` on `T1.artist_id = T2.id` instead of querying only the `albums` table. Do filter on `T2.name = \"Billy Cobham\"` instead of filtering directly on `artist_name` from the albums table. Do use proper table aliases and join syntax instead of relying on a potentially incorrect or non-existent `artist_name` column in the albums table. The amended query now correctly counts albums by joining with the artists table to verify the artist name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM albums WHERE artist_name = 'Billy Cobam';",
            "SELECT COUNT(*) AS album_count\nFROM albums AS T1\nJOIN artists AS T2 ON T1.artist_id = T2.id\nWHERE T2.name = 'Billy Cobham';"
        ],
        "rule_sql": []
    },
    "2003": {
        "db_id": "gas_company",
        "question": "Show all main industry for all companies.",
        "ground_truth": "SELECT DISTINCT main_industry FROM company",
        "amends": [
            "Do select only `main_industry` instead of all columns with `*`. Do add `DISTINCT` to return unique values instead of returning all rows. Do reference the correct table name `company` instead of `companies`. The amended query now correctly returns distinct main industry values from the company table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM companies;",
            "SELECT DISTINCT Main_Industry FROM company;"
        ],
        "rule_sql": []
    },
    "1716": {
        "db_id": "epinions_1",
        "question": "Find the names of users who did not leave any review.",
        "ground_truth": "SELECT name FROM useracct WHERE u_id NOT IN (SELECT u_id FROM review)",
        "amends": [
            "Do reference table `useracct` instead of `users` in the FROM clause. Do use column `u_id` instead of `user_id` in both the main query and subquery. Do reference table `review` instead of `reviews` in the subquery. The amended query now correctly filters for user accounts not found in the review table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM users WHERE user_id NOT IN (SELECT user_id FROM reviews);",
            "SELECT name FROM useracct WHERE u_id NOT IN (SELECT u_id FROM review)"
        ],
        "rule_sql": []
    },
    "2529": {
        "db_id": "movie_1",
        "question": "What are the names of all reviewers that have given 3 or 4 stars for reviews?",
        "ground_truth": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  3 INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  4",
        "amends": [
            "Do join `Rating AS T1` with `Reviewer AS T2` on `T1.rID = T2.rID` instead of querying a single `reviews` table. Do filter for `stars = 3` in one branch and `stars = 4` in another branch instead of using `OR` in a single WHERE clause. Do use `INTERSECT` to find reviewers who have both ratings instead of finding reviewers with either rating. Do select `T2.name` from the Reviewer table instead of `reviewer_name` from a reviews table. The amended query now correctly identifies reviewers who have given both 3-star and 4-star ratings, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT reviewer_name FROM reviews WHERE stars = 3 OR stars = 4;",
            "SELECT T2.name\nFROM Rating AS T1\nJOIN Reviewer AS T2 ON T1.rID = T2.rID\nWHERE T1.stars = 3\nINTERSECT\nSELECT T2.name\nFROM Rating AS T1\nJOIN Reviewer AS T2 ON T1.rID = T2.rID\nWHERE T1.stars = 4"
        ],
        "rule_sql": []
    },
    "2854": {
        "db_id": "customer_deliveries",
        "question": "Find the payment method that is used most frequently.",
        "ground_truth": "SELECT payment_method FROM Customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `payment_method` instead of including `COUNT(*) as count`. Do use `Customers` table instead of `payments` table. Do order by `count(*) DESC` instead of `count ASC`. Do remove the explicit count column from SELECT list instead of keeping it. The amended query now correctly identifies payment methods from the Customers table and orders by descending frequency count."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT payment_method, COUNT(*) as count FROM payments GROUP BY payment_method ORDER BY count ASC LIMIT 1;",
            "SELECT payment_method FROM Customers GROUP BY payment_method ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5764": {
        "db_id": "dorm_1",
        "question": "Find the first name and age of students who are living in the dorms that do not have amenity TV Lounge.",
        "ground_truth": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')",
        "amends": [
            "Do use `T1.fname` and `T1.age` instead of `first_name` and `age` with explicit table aliases. Do join `student AS T1` with `lives_in AS T2` on `T1.stuid = T2.stuid` instead of querying `students` table directly. Do filter using `T2.dormid NOT IN` subquery instead of `dorm_id IN` with positive condition. Do reference `has_amenity AS T3` and `dorm_amenity AS T4` joined on `T3.amenid = T4.amenid` instead of single `dorms` table. Do check for amenity name `'TV Lounge'` in `WHERE T4.amenity_name = 'TV Lounge'` instead of `amenity != 'TV Lounge'`. The amended query now correctly identifies students not living in dorms with TV Lounge amenities by properly traversing the relationship tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, age FROM students WHERE dorm_id IN (SELECT dorm_id FROM dorms WHERE amenity != 'TV Lounge');",
            "SELECT T1.Fname, T1.Age\nFROM Student AS T1\nJOIN Lives_in AS T2 ON T1.StuID = T2.stuid\nWHERE T2.dormid NOT IN (\n    SELECT T3.dormid\n    FROM Has_amenity AS T3\n    JOIN Dorm_amenity AS T4 ON T3.amenid = T4.amenid\n    WHERE T4.amenity_name = 'TV Lounge'\n)"
        ],
        "rule_sql": []
    },
    "6812": {
        "db_id": "flight_4",
        "question": "What is the highest elevation of an airport in the country of Iceland?",
        "ground_truth": "SELECT max(elevation) FROM airports WHERE country  =  'Iceland'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(elevation) FROM airports WHERE country = 'Iceland';"
        ],
        "rule_sql": []
    },
    "1858": {
        "db_id": "wrestler",
        "question": "List the names of wrestlers and the teams in elimination in descending order of days held.",
        "ground_truth": "SELECT T2.Name ,  T1.Team FROM elimination AS T1 JOIN wrestler AS T2 ON T1.Wrestler_ID  =  T2.Wrestler_ID ORDER BY T2.Days_held DESC",
        "amends": [
            "Do select `T2.Name` and `T1.Team` instead of `wrestler_name` and `team_name`. Do use `FROM elimination AS T1 JOIN wrestler AS T2` instead of `FROM wrestlers`. Do add join condition `ON T1.Wrestler_ID = T2.Wrestler_ID` instead of omitting it. Do order by `T2.Days_held DESC` instead of `days_held ASC`. The amended query now correctly joins the elimination and wrestler tables to retrieve wrestler names with their respective teams and sorts by days held in descending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT wrestler_name, team_name FROM wrestlers ORDER BY days_held ASC;",
            "SELECT T2.Name, T1.Team \nFROM Elimination AS T1 \nJOIN wrestler AS T2 ON T1.Wrestler_ID = T2.Wrestler_ID \nORDER BY T2.Days_held DESC"
        ],
        "rule_sql": []
    },
    "1211": {
        "db_id": "apartment_rentals",
        "question": "What are the apartment number and the room count of each apartment?",
        "ground_truth": "SELECT apt_number ,  room_count FROM Apartments",
        "amends": [
            "Do reference the column as `apt_number` instead of `apartment_number` to match the correct column name in the schema. Do reference the table as `Apartments` instead of `apartments` to use the proper table name with correct casing. The WHERE clause remains unchanged as `room_count > 5` since the filter condition is correct in both queries. The amended query now correctly selects from the proper table with the correct column names while maintaining the same filtering logic.",
            "Do maintain the exact same `SELECT apt_number, room_count` column list instead of changing it. Do preserve the identical `FROM Apartments` source table instead of modifying it. Do keep the identical `WHERE room_count > 5` filter condition instead of altering it. The amended query now matches RIGHT_SQL's behavior as both queries are functionally identical with only insignificant whitespace differences.",
            "Do maintain the exact same `SELECT apt_number, room_count` column list instead of changing it. Do preserve the identical `FROM Apartments` source table instead of modifying it. Do keep the identical `WHERE room_count > 5` filter condition instead of altering it. The amended query now correctly matches the RIGHT_SQL's behavior by maintaining all original elements without any substantive changes.",
            "Do maintain the same `SELECT apt_number, room_count` column list instead of changing it. Do keep the same `FROM Apartments` source table instead of modifying it. Do remove the `WHERE room_count > 5` filter condition instead of including it, as the right query returns all apartments without filtering. The amended query now matches the right SQL's behavior of selecting all apartment records without any room count restrictions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT apartment_number, room_count FROM apartments WHERE room_count > 5;",
            "SELECT apt_number, room_count FROM Apartments WHERE room_count > 5;",
            "SELECT apt_number, room_count FROM Apartments WHERE room_count > 5",
            "SELECT apt_number, room_count FROM Apartments WHERE room_count > 5",
            "SELECT apt_number, room_count FROM Apartments"
        ],
        "rule_sql": []
    },
    "6813": {
        "db_id": "flight_4",
        "question": "Find the name of the airports located in Cuba or Argentina.",
        "ground_truth": "SELECT name FROM airports WHERE country  =  'Cuba' OR country  =  'Argentina'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM airports WHERE country = 'Cuba' OR country = 'Argentina';"
        ],
        "rule_sql": []
    },
    "6673": {
        "db_id": "driving_school",
        "question": "For each customer status code, how many customers are classified that way?",
        "ground_truth": "SELECT customer_status_code , count(*) FROM Customers GROUP BY customer_status_code;",
        "amends": [
            "Do select `customer_status_code` instead of `status_code` and group by `customer_status_code` instead of `customer_id` to properly aggregate counts by status category rather than individual customers. Do reference the correct table name `Customers` instead of `customers` to match the actual schema. The amended query now correctly counts customers grouped by their status codes rather than producing per-customer counts, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT status_code, COUNT(*) FROM customers GROUP BY customer_id;",
            "SELECT customer_status_code, COUNT(*) AS customer_count FROM Customers GROUP BY customer_status_code;"
        ],
        "rule_sql": []
    },
    "1395": {
        "db_id": "college_2",
        "question": "What are the greatest and average capacity for rooms in each building?",
        "ground_truth": "SELECT max(capacity) ,  avg(capacity) ,  building FROM classroom GROUP BY building",
        "amends": [
            "Do use `classroom` as the table name instead of `rooms` to reference the correct data source. Do place the `building` column at the end of the SELECT list instead of at the beginning to match the intended output structure. Do remove the `greatest_capacity` and `average_capacity` column aliases instead of keeping them, as the right query uses unaliased aggregate functions. Do use lowercase `max` and `avg` function names instead of uppercase `MAX` and `AVG` for consistency with the target query format. The amended query now correctly calculates maximum and average capacity grouped by building from the classroom table without unnecessary aliases."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT building, MAX(capacity) as greatest_capacity, AVG(capacity) as average_capacity FROM rooms GROUP BY building;",
            "SELECT max(capacity), avg(capacity), building FROM classroom GROUP BY building"
        ],
        "rule_sql": []
    },
    "5824": {
        "db_id": "workshop_paper",
        "question": "What is the author of the submission with the highest score?",
        "ground_truth": "SELECT Author FROM submission ORDER BY Scores DESC LIMIT 1",
        "amends": [
            "Do reference the `Author` column instead of `author` to match the correct case sensitivity. Do reference the `submission` table instead of `submissions` to use the correct table name. Do order by `Scores DESC` instead of `score ASC` to sort by the correct column name in descending order rather than ascending. Do use the correct column name `Scores` instead of `score` to match the intended scoring metric. The amended query now correctly retrieves the author with the highest score from the submission table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author FROM submissions ORDER BY score ASC LIMIT 1;",
            "SELECT Author FROM submission ORDER BY Scores DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3827": {
        "db_id": "e_learning",
        "question": "List the name and the number of enrolled student for each course.",
        "ground_truth": "SELECT T1.course_name ,  COUNT(*) FROM Courses AS T1 JOIN Student_Course_Enrolment AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name",
        "amends": [
            "Do join `Courses AS T1` to `Student_Course_Enrolment AS T2` on `T1.course_id = T2.course_id` instead of querying only the `students` table without proper table relationships. Do reference `T1.course_name` in both SELECT and GROUP BY clauses instead of using an unqualified `course_name` that lacks table context. The amended query now correctly counts student enrollments per course by establishing the proper join relationship between course and enrollment tables, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT course_name, COUNT(*) FROM students GROUP BY course_name;",
            "SELECT T1.course_name, COUNT(T2.student_id) AS enrolled_students\nFROM Courses AS T1\nJOIN Student_Course_Enrolment AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_name;"
        ],
        "rule_sql": []
    },
    "2526": {
        "db_id": "movie_1",
        "question": "What are names of the movies that are either made before 1980 or directed by James Cameron?",
        "ground_truth": "SELECT title FROM Movie WHERE director  =  \"James Cameron\" OR YEAR   <  1980",
        "amends": [
            "Do reference the table as `Movie` instead of `movies` in the FROM clause. Do use `OR` instead of `AND` between the conditions to include movies directed by James Cameron regardless of year or movies from before 1980 regardless of director, instead of requiring both conditions simultaneously. Do remove the unnecessary parentheses around the WHERE conditions and use double quotes for the string literal instead of single quotes. The amended query now correctly returns all movies directed by James Cameron or released before 1980, matching the intended logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM movies WHERE year < 1980 AND director = 'James Cameron';",
            "SELECT title FROM Movie WHERE year < 1980 OR director = \"James Cameron\""
        ],
        "rule_sql": []
    },
    "4242": {
        "db_id": "cre_Doc_Tracking_DB",
        "question": "Show the ids of all employees who have authorized destruction.",
        "ground_truth": "SELECT DISTINCT Destruction_Authorised_by_Employee_ID FROM Documents_to_be_destroyed",
        "amends": [
            "Do select `Destruction_Authorised_by_Employee_ID` instead of `employee_id`. Do query from `Documents_to_be_destroyed` instead of `employees`. Do add `DISTINCT` instead of omitting it. Do remove the `WHERE destruction_authorized = 'yes'` filter instead of keeping it. The amended query now correctly retrieves unique employee IDs authorized for document destruction from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT employee_id FROM employees WHERE destruction_authorized = 'yes';",
            "SELECT DISTINCT Destruction_Authorised_by_Employee_ID FROM Documents_to_be_Destroyed;"
        ],
        "rule_sql": []
    },
    "4475": {
        "db_id": "network_2",
        "question": "What are the names, ages, and jobs of all people who are friends with Alice for the longest amount of time?",
        "ground_truth": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `p` and `f`. Do change the FROM source to `Person AS T1` instead of `people p`. Do change the JOIN to `PersonFriend AS T2` instead of `friends f`. Do modify the JOIN condition to `T1.name = T2.name` instead of `p.id = f.friend_id`. Do replace the WHERE filter with `T2.friend = 'Alice'` instead of the subquery `f.person_id = (SELECT id FROM people WHERE name = 'Alice')`. Do add an additional WHERE condition `T2.year = (SELECT max(YEAR) FROM PersonFriend WHERE friend = 'Alice')` instead of omitting it. Do remove the ORDER BY and LIMIT clauses instead of keeping them. The amended query now correctly retrieves information about the person who has been friends with Alice for the longest duration by using a correlated subquery to find the maximum friendship year rather than relying on ordering and limiting results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.name, p.age, p.job\nFROM people p\nJOIN friends f ON p.id = f.friend_id\nWHERE f.person_id = (SELECT id FROM people WHERE name = 'Alice')\nORDER BY f.friendship_duration DESC\nLIMIT 1;",
            "SELECT T1.name, T1.age, T1.job\nFROM Person AS T1\nJOIN PersonFriend AS T2 ON T1.name = T2.name\nWHERE T2.friend = 'Alice'\nAND T2.year = (SELECT MAX(year) FROM PersonFriend WHERE friend = 'Alice')"
        ],
        "rule_sql": []
    },
    "3788": {
        "db_id": "e_learning",
        "question": "What are the login names of the students with family name \"Ward\"?",
        "ground_truth": "SELECT login_name FROM Students WHERE family_name  =  \"Ward\"",
        "amends": [
            "Do select `login_name` instead of `first_name` from the `Students` table instead of `students`. Do filter on `family_name` instead of `last_name` with the value `\"Ward\"` instead of `'Ward'`. The amended query now correctly retrieves login names for students with the specified family name, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM students WHERE last_name = 'Ward';",
            "SELECT login_name FROM Students WHERE family_name = 'Ward';"
        ],
        "rule_sql": []
    },
    "2624": {
        "db_id": "inn_1",
        "question": "Find the number of rooms with price higher than 120 for different decor.",
        "ground_truth": "SELECT decor , count(*) FROM Rooms WHERE basePrice  >  120 GROUP BY decor;",
        "amends": [
            "Do reference the `Rooms` table instead of `rooms` in the FROM clause. Do use the `basePrice` column instead of `price` in the WHERE filter condition. The amended query now correctly references the proper table name and column name to filter rooms by base price exceeding 120, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT decor, COUNT(*) FROM rooms WHERE price > 120 GROUP BY decor;",
            "SELECT decor, COUNT(*) AS room_count FROM Rooms WHERE basePrice > 120 GROUP BY decor;"
        ],
        "rule_sql": []
    },
    "1539": {
        "db_id": "insurance_and_eClaims",
        "question": "Find the name of the customer that has been involved in the most policies.",
        "ground_truth": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t2.customer_details ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `t2.customer_details` instead of `customer_name` from a different table. Do join `policies AS t1` with `customers AS t2` on `t1.customer_id = t2.customer_id` instead of querying only the `customers` table. Do add `GROUP BY t2.customer_details` and aggregate with `count(*)` instead of no grouping or aggregation. Do order by `count(*) DESC` instead of `customer_id DESC` to find the customer with the most policies. Do keep `LIMIT 1` to return the top result. The amended query now correctly identifies the customer with the highest policy count rather than simply the last customer by ID, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name FROM customers ORDER BY customer_id DESC LIMIT 1;",
            "SELECT t2.Customer_Details\nFROM Policies AS t1\nJOIN Customers AS t2 ON t1.Customer_ID = t2.Customer_ID\nGROUP BY t2.Customer_Details\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "2146": {
        "db_id": "local_govt_in_alabama",
        "question": "What is the most common participant type?",
        "ground_truth": "SELECT participant_type_code FROM participants GROUP BY participant_type_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `participant_type_code` instead of `participant_type` and remove the `COUNT(*) as count` column from the SELECT list instead of including it. Do group by `participant_type_code` instead of `participant_type` and order by `count(*) DESC` instead of `count ASC` while keeping the `LIMIT 1` clause. The amended query now correctly identifies the most frequent participant type by counting occurrences in descending order rather than finding the least frequent type in ascending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT participant_type, COUNT(*) as count FROM participants GROUP BY participant_type ORDER BY count ASC LIMIT 1;",
            "SELECT participant_type_code FROM Participants GROUP BY participant_type_code ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "3560": {
        "db_id": "music_1",
        "question": "What is the average song duration for the songs that are in mp3 format and whose resolution below 800?",
        "ground_truth": "SELECT avg(T1.duration) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.formats  =  \"mp3\" AND T2.resolution   <  800",
        "amends": [
            "Do specify `avg(T1.duration)` with table alias instead of `AVG(duration)` without qualification. Do use `FROM files AS T1 JOIN song AS T2` with explicit table aliases and join instead of `FROM songs` with a single table. Do change the join condition to `ON T1.f_id = T2.f_id` instead of no join condition. Do use `T1.formats = \"mp3\"` with table qualification instead of `format = 'mp3'` without qualification. Do change the filter to `T2.resolution < 800` with table qualification and reversed inequality instead of `resolution > 800` without qualification. The amended query now correctly joins the files and song tables, qualifies all column references, and fixes the resolution filter logic to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(duration) FROM songs WHERE format = 'mp3' AND resolution > 800;",
            "SELECT AVG(T1.duration) FROM files AS T1 JOIN song AS T2 ON T1.f_id = T2.f_id WHERE T1.formats = 'mp3' AND T2.resolution < 800"
        ],
        "rule_sql": []
    },
    "1251": {
        "db_id": "apartment_rentals",
        "question": "Sort the apartment numbers in ascending order of room count.",
        "ground_truth": "SELECT apt_number FROM Apartments ORDER BY room_count ASC",
        "amends": [
            "Do use column name `apt_number` instead of `apartment_number` in the SELECT list. Do change the sort direction to `ASC` instead of `DESC` in the ORDER BY clause. The amended query now correctly selects the appropriate column and sorts in ascending order as specified in the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT apartment_number FROM apartments ORDER BY room_count DESC;",
            "SELECT apt_number FROM Apartments ORDER BY room_count ASC;"
        ],
        "rule_sql": []
    },
    "62": {
        "db_id": "student_assessment",
        "question": "List the id of students who never attends courses?",
        "ground_truth": "SELECT student_id FROM students WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)",
        "amends": [
            "Do reference the `student_course_attendance` table instead of the `attendance` table in the subquery, as the correct table contains the attendance records that should be excluded from the main query results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_id FROM students WHERE student_id NOT IN (SELECT student_id FROM attendance)",
            "SELECT student_id FROM Students WHERE student_id NOT IN (SELECT DISTINCT student_id FROM Student_Course_Attendance)"
        ],
        "rule_sql": []
    },
    "380": {
        "db_id": "flight_1",
        "question": "What is the id and salary of the employee named Mark Young?",
        "ground_truth": "SELECT eid ,  salary FROM Employee WHERE name  =  'Mark Young'",
        "amends": [
            "Do select `eid` and `salary` instead of `id` and `name`. Do use table name `Employee` instead of `employees`. Do keep the filter `name = 'Mark Young'` unchanged. The amended query now correctly retrieves employee ID and salary data from the Employee table while maintaining the same filtering condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, name FROM employees WHERE name = 'Mark Young';",
            "SELECT eid, salary FROM employee WHERE name = 'Mark Young';"
        ],
        "rule_sql": []
    },
    "5778": {
        "db_id": "customer_complaints",
        "question": "Which products has been complained by the customer who has filed least amount of complaints?",
        "ground_truth": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do select `DISTINCT t1.product_name` instead of `p.product_name` without distinct. Do join `customers AS t3` without an ON condition instead of joining with `cust ON c.customer_id = cust.customer_id`. Do remove the HAVING clause with subquery instead of keeping it to find maximum complaint counts. Do order by `count(*)` instead of `COUNT(c.complaint_id) ASC`. The amended query now correctly selects distinct product names from joined tables with simplified grouping and ordering logic.",
            "Do use `t1.product_name` with alias `t1` instead of `p.product_name` with alias `p`. Do join `complaints AS t2` instead of `Complaints c`. Do add `GROUP BY t3.customer_id` instead of omitting it. Do move the subquery logic to main query with `ORDER BY count(*) LIMIT 1` instead of using a correlated subquery. Do remove the `WHERE` clause with subquery instead of keeping it. Do use explicit table aliases `t1`, `t2`, `t3` consistently instead of mixed naming. The amended query now correctly groups by customer and finds products for the customer with the fewest complaints."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.product_name \nFROM products p\nJOIN complaints c ON p.product_id = c.product_id\nJOIN customers cust ON c.customer_id = cust.customer_id\nGROUP BY cust.customer_id\nHAVING COUNT(c.complaint_id) = (SELECT MAX(COUNT(complaint_id)) FROM complaints GROUP BY customer_id)\nORDER BY COUNT(c.complaint_id) ASC\nLIMIT 1;",
            "SELECT DISTINCT p.product_name\nFROM Complaints c\nJOIN Products p ON c.product_id = p.product_id\nJOIN Customers t3\nWHERE c.customer_id = (\n    SELECT customer_id\n    FROM Complaints\n    GROUP BY customer_id\n    ORDER BY COUNT(*) ASC\n    LIMIT 1\n)",
            "SELECT DISTINCT t1.product_name\nFROM Products AS t1\nJOIN Complaints AS t2 ON t1.product_id = t2.product_id\nJOIN Customers AS t3\nGROUP BY t3.customer_id\nORDER BY count(*) ASC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "4630": {
        "db_id": "customers_campaigns_ecommerce",
        "question": "What are the name and payment method of customers who have both mailshots in 'Order' outcome and mailshots in 'No Response' outcome.",
        "ground_truth": "SELECT T2.customer_name ,  T2.payment_method FROM mailshot_customers AS T1 JOIN customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.outcome_code  =  'Order' INTERSECT SELECT T2.customer_name ,  T2.payment_method FROM mailshot_customers AS T1 JOIN customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.outcome_code  =  'No Response'",
        "amends": [
            "Do use `INTERSECT` to find customers with both outcomes instead of joining the same table twice. Do reference `mailshot_customers` instead of `mailshots` as the source table. Do use `outcome_code` instead of `outcome` for the outcome column. Do select `customer_name` instead of `name` from the customers table. Do add proper table aliases `T1` and `T2` instead of single-letter aliases. Do remove the redundant double join condition and replace it with set intersection logic. The amended query now correctly identifies customers who have both 'Order' and 'No Response' outcomes using INTERSECT semantics instead of potentially incorrect join logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.name, c.payment_method \nFROM customers c\nJOIN mailshots m1 ON c.customer_id = m1.customer_id\nJOIN mailshots m2 ON c.customer_id = m2.customer_id\nWHERE m1.outcome = 'Order' AND m2.outcome = 'No Response';",
            "SELECT c.customer_name, c.payment_method\nFROM Customers c\nWHERE c.customer_id IN (\n    SELECT customer_id\n    FROM Mailshot_Customers\n    WHERE outcome_code = 'Order'\n    INTERSECT\n    SELECT customer_id\n    FROM Mailshot_Customers\n    WHERE outcome_code = 'No Response'\n)"
        ],
        "rule_sql": []
    },
    "367": {
        "db_id": "flight_1",
        "question": "How many employees have salary between 100000 and 200000?",
        "ground_truth": "SELECT count(*) FROM Employee WHERE salary BETWEEN 100000 AND 200000",
        "amends": [
            "Do use `BETWEEN 100000 AND 200000` instead of `salary > 200000 AND salary < 100000` to correctly capture the salary range between 100,000 and 200,000. Do reference table `Employee` instead of `employees` to match the correct table name. The amended query now correctly counts employees with salaries in the inclusive range of 100,000 to 200,000 instead of the logically impossible condition where salary is both greater than 200,000 and less than 100,000."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE salary > 200000 AND salary < 100000;",
            "SELECT COUNT(*) FROM employee WHERE salary BETWEEN 100000 AND 200000"
        ],
        "rule_sql": []
    },
    "4092": {
        "db_id": "student_1",
        "question": "Find the name of the teacher who teaches the largest number of students.",
        "ground_truth": "SELECT T2.firstname ,  T2.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom GROUP BY T2.firstname ,  T2.lastname ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.firstname` and `T2.lastname` instead of `teacher_name`. Do use `FROM list AS T1 JOIN teachers AS T2` instead of `FROM teachers`. Do add join condition `ON T1.classroom = T2.classroom` instead of omitting it. Do add `GROUP BY T2.firstname, T2.lastname` instead of omitting grouping. Do order by `count(*) DESC` instead of `student_count DESC`. The amended query now correctly identifies teachers by counting their associated students from the list table rather than relying on a potentially incorrect student_count column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT teacher_name FROM teachers ORDER BY student_count DESC LIMIT 1;",
            "SELECT T2.FirstName, T2.LastName\nFROM list AS T1\nJOIN teachers AS T2 ON T1.Classroom = T2.Classroom\nGROUP BY T2.FirstName, T2.LastName\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "4026": {
        "db_id": "ship_mission",
        "question": "Show the types of ships that have both ships with tonnage larger than 6000 and ships with tonnage smaller than 4000.",
        "ground_truth": "SELECT TYPE FROM ship WHERE Tonnage  >  6000 INTERSECT SELECT TYPE FROM ship WHERE Tonnage  <  4000",
        "amends": [
            "Do remove `DISTINCT` and change the logical structure to use `INTERSECT` between two separate queries instead of using `OR` in a single `WHERE` clause. Do reference table as `ship` instead of `ships` and use column name `Tonnage` instead of `tonnage`. Do split the original condition into two separate `SELECT` statements with `Tonnage > 6000` in one query and `Tonnage < 4000` in another, then combine them with `INTERSECT` to find ship types that satisfy both conditions instead of using `OR` which would return types that satisfy either condition. The amended query now correctly identifies ship types that have both large (>6000) and small (<4000) tonnage vessels, matching the RIGHT_SQL's set intersection behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT type FROM ships WHERE tonnage > 6000 OR tonnage < 4000;",
            "SELECT Type FROM ship WHERE Tonnage > 6000\nINTERSECT\nSELECT Type FROM ship WHERE Tonnage < 4000"
        ],
        "rule_sql": []
    },
    "4366": {
        "db_id": "tracking_grants_for_research",
        "question": "For grants with both documents described as 'Regular' and documents described as 'Initial Application', list its start date.",
        "ground_truth": "SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Regular' INTERSECT SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Initial Application'",
        "amends": [
            "Do select `T1.grant_start_date` from `Grants AS T1` instead of `start_date` from `grants`. Do join `Documents AS T2` on `T1.grant_id = T2.grant_id` and `Document_Types AS T3` on `T2.document_type_code = T3.document_type_code` instead of querying a single table. Do filter on `T3.document_description = 'Regular'` in one branch and `T3.document_description = 'Initial Application'` in another instead of using `AND` with contradictory conditions. Do use `INTERSECT` to find common `grant_start_date` values between Regular and Initial Application documents instead of attempting to find rows where both descriptions apply simultaneously. The amended query correctly identifies grants that have both document types by finding the intersection of start dates rather than seeking impossible simultaneous conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT start_date FROM grants WHERE document_description = 'Regular' AND document_description = 'Initial Application';",
            "SELECT T1.grant_start_date\nFROM Grants AS T1\nJOIN Documents AS T2 ON T1.grant_id = T2.grant_id\nJOIN Document_Types AS T3 ON T2.document_type_code = T3.document_type_code\nWHERE T3.document_description = 'Regular'\nINTERSECT\nSELECT T1.grant_start_date\nFROM Grants AS T1\nJOIN Documents AS T2 ON T1.grant_id = T2.grant_id\nJOIN Document_Types AS T3 ON T2.document_type_code = T3.document_type_code\nWHERE T3.document_description = 'Initial Application'"
        ],
        "rule_sql": []
    },
    "3775": {
        "db_id": "e_learning",
        "question": "What is the address of each course author or tutor?",
        "ground_truth": "SELECT address_line_1 FROM Course_Authors_and_Tutors",
        "amends": [
            "Do select `address_line_1` instead of `name, email`. Do source from `Course_Authors_and_Tutors` instead of `authors`. The amended query now correctly retrieves address information from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, email FROM authors;",
            "SELECT address_line_1 FROM Course_Authors_and_Tutors;"
        ],
        "rule_sql": []
    },
    "1625": {
        "db_id": "customers_and_invoices",
        "question": "Show order ids and the total quantity in each order.",
        "ground_truth": "SELECT order_id ,  sum(product_quantity) FROM Order_items GROUP BY order_id",
        "amends": [
            "Do select `order_id` and `sum(product_quantity)` instead of `order_id` and `COUNT(*) as total_quantity`. Do use `Order_items` table instead of `orders` table. Do remove the alias `total_quantity` instead of keeping it. The amended query now correctly calculates the total product quantity per order from the Order_items table rather than counting order occurrences."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT order_id, COUNT(*) as total_quantity FROM orders GROUP BY order_id;",
            "SELECT order_id, SUM(product_quantity) FROM Order_Items GROUP BY order_id"
        ],
        "rule_sql": []
    },
    "6027": {
        "db_id": "game_1",
        "question": "Show all male student ids who don't play football.",
        "ground_truth": "SELECT StuID FROM Student WHERE sex  =  'M' EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  \"Football\"",
        "amends": [
            "Do select `StuID` instead of `student_id` and use table `Student` instead of `students`. Do change the filter to `sex = 'M'` instead of `gender = 'male'` and remove the `sport = 'football'` condition from the WHERE clause. Do add an EXCEPT clause with a subquery selecting `StuID` from `Sportsinfo` where `sportname = \"Football\"` instead of including the sport filter directly in the main query. This changes the logic to find male students who do not play football rather than those who do. The amended query now correctly implements set difference logic to exclude football players from the male student population."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_id FROM students WHERE gender = 'male' AND sport = 'football';",
            "SELECT StuID FROM Student WHERE Sex = 'M' EXCEPT SELECT StuID FROM SportsInfo WHERE SportName = 'Football'"
        ],
        "rule_sql": []
    },
    "3841": {
        "db_id": "e_learning",
        "question": "What are the student IDs and middle names of the students enrolled in at most two courses?",
        "ground_truth": "SELECT T1.student_id ,  T2.middle_name FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING COUNT(*)  <=  2",
        "amends": [
            "Do select `T1.student_id` and `T2.middle_name` from separate tables instead of selecting both from a single table. Do join `Student_Course_Enrolment AS T1` with `Students AS T2` on `T1.student_id = T2.student_id` instead of querying only the students table. Do remove the `middle_name` from GROUP BY and group only by `T1.student_id` instead of grouping by both columns. Do move the count filter to `HAVING COUNT(*) <= 2` instead of using COUNT in WHERE. Do use table aliases `T1` and `T2` for clarity instead of no aliases. The amended query now correctly counts course enrollments per student and retrieves the corresponding middle name, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_id, middle_name FROM students WHERE COUNT(course_id) <= 2 GROUP BY student_id, middle_name",
            "SELECT T1.student_id, T2.middle_name\nFROM Student_Course_Enrolment AS T1\nJOIN Students AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nHAVING COUNT(*) <= 2"
        ],
        "rule_sql": []
    },
    "3318": {
        "db_id": "college_1",
        "question": "What are the names of all students who took a class and the corresponding course descriptions?",
        "ground_truth": "SELECT T1.stu_fname ,  T1.stu_lname ,  T4.crs_description FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code",
        "amends": [
            "Do select `stu_fname`, `stu_lname`, and `crs_description` instead of `name` and `description`. Do use table aliases `T1`, `T2`, `T3`, and `T4` instead of `s`, `cl`, and `c`. Do join through the `enroll` table (`T2`) instead of directly joining `students` to `classes`. Do use join conditions `T1.stu_num = T2.stu_num`, `T2.class_code = T3.class_code`, and `T3.crs_code = T4.crs_code` instead of `s.id = cl.student_id` and `cl.course_id = c.id`. Do reference tables `student`, `enroll`, `CLASS`, and `course` instead of `students`, `classes`, and `courses`. The amended query now correctly navigates the enrollment relationship through the proper intermediary table structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.name, c.description FROM students s JOIN classes cl ON s.id = cl.student_id JOIN courses c ON cl.course_id = c.id",
            "SELECT T1.STU_FNAME, T1.STU_LNAME, T4.CRS_DESCRIPTION\nFROM STUDENT T1\nJOIN ENROLL T2 ON T1.STU_NUM = T2.STU_NUM\nJOIN CLASS T3 ON T2.CLASS_CODE = T3.CLASS_CODE\nJOIN COURSE T4 ON T3.CRS_CODE = T4.CRS_CODE;"
        ],
        "rule_sql": []
    },
    "5087": {
        "db_id": "device",
        "question": "What are the carriers of devices that are not in stock anywhere?",
        "ground_truth": "SELECT Carrier FROM device WHERE Device_ID NOT IN (SELECT Device_ID FROM stock)",
        "amends": [
            "Do remove `DISTINCT` instead of keeping it. Do change the table reference from `devices` to `device` instead of using the wrong table name. Do replace the `stock_quantity > 0` filter with a subquery condition `Device_ID NOT IN (SELECT Device_ID FROM stock)` instead of the incorrect stock availability logic. Do capitalize the column name `Carrier` instead of lowercase `carrier`. The amended query now correctly identifies carriers from the device table where devices are not present in the stock table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT carrier FROM devices WHERE stock_quantity > 0;",
            "SELECT Carrier FROM device WHERE Device_ID NOT IN (SELECT Device_ID FROM stock)"
        ],
        "rule_sql": []
    },
    "2757": {
        "db_id": "election",
        "question": "Return all the information for each election record.",
        "ground_truth": "SELECT * FROM election",
        "amends": [
            "Do reference table `election` instead of `elections` to use the correct table name that matches the database schema. This change ensures the query targets the proper table containing the election data rather than a non-existent or incorrectly named table, thus fixing the table reference error that would prevent the query from executing successfully. The amended query now correctly retrieves all columns from the election table where election_id equals 1, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM elections WHERE election_id = 1;",
            "SELECT * FROM election;"
        ],
        "rule_sql": []
    },
    "5587": {
        "db_id": "products_gen_characteristics",
        "question": "What are the unit of measure and category code for the 'chervil' product?",
        "ground_truth": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  \"chervil\"",
        "amends": [
            "Do join `ref_product_categories AS t2` instead of querying only the `products` table. Do reference columns `t2.unit_of_measure` and `t2.product_category_code` instead of `unit_of_measure` and `category_code` from the products table. Do use an `INNER JOIN` with predicate `t1.product_category_code = t2.product_category_code` instead of no join condition. Do filter on `t1.product_name = \"chervil\"` instead of `product_name = 'chervil'` with corrected table reference. The amended query now correctly retrieves category information from the reference table instead of the base products table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT unit_of_measure, category_code FROM products WHERE product_name = 'chervil';",
            "SELECT t2.unit_of_measure, t2.product_category_code \nFROM Products AS t1\nINNER JOIN Ref_Product_Categories AS t2 ON t1.product_category_code = t2.product_category_code\nWHERE t1.product_name = 'chervil'"
        ],
        "rule_sql": []
    },
    "489": {
        "db_id": "allergy_1",
        "question": "Show all majors and corresponding number of students.",
        "ground_truth": "SELECT major ,  count(*) FROM Student GROUP BY major",
        "amends": [
            "Do reference the table as `Student` instead of `students` to match the correct schema. The amended query now matches RIGHT_SQL's behavior with identical logic and results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT major, COUNT(*) FROM students GROUP BY major;",
            "SELECT Major, COUNT(*) AS NumberOfStudents FROM Student GROUP BY Major;"
        ],
        "rule_sql": []
    },
    "2953": {
        "db_id": "sakila_1",
        "question": "Return the full name and id of the actor or actress who starred in the greatest number of films.",
        "ground_truth": "SELECT T2.first_name ,  T2.last_name ,  T2.actor_id FROM film_actor AS T1 JOIN actor AS T2 ON T1.actor_id  =  T2.actor_id GROUP BY T2.actor_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do change the FROM source to `film_actor AS T1 JOIN actor AS T2` instead of just `actors`. Do add the join condition `ON T1.actor_id = T2.actor_id` instead of omitting it. Do add `GROUP BY T2.actor_id` instead of omitting grouping. Do change the ORDER BY to `count(*) DESC` instead of `actor_id DESC`. Do keep `LIMIT 1` but now applied after grouping and counting. The amended query now correctly identifies the actor with the most film appearances by counting film_actor records per actor, matching the RIGHT_SQL's behavior.",
            "Do select individual columns `T2.first_name`, `T2.last_name`, and `T2.actor_id` instead of concatenating them into a single `full_name` alias. The amended query now correctly returns the separate name components while maintaining the same grouping, ordering, and limit behavior to identify the actor with the most film appearances."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_id, first_name, last_name \nFROM actors \nORDER BY actor_id DESC \nLIMIT 1;",
            "SELECT T2.actor_id, T2.first_name || ' ' || T2.last_name AS full_name\nFROM film_actor AS T1\nJOIN actor AS T2 ON T1.actor_id = T2.actor_id\nGROUP BY T2.actor_id\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT T2.first_name, T2.last_name, T2.actor_id\nFROM film_actor AS T1\nJOIN actor AS T2 ON T1.actor_id = T2.actor_id\nGROUP BY T2.actor_id\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "41": {
        "db_id": "farm",
        "question": "What are the themes of competitions that have corresponding host cities with more than 1000 residents?",
        "ground_truth": "SELECT T2.Theme FROM city AS T1 JOIN farm_competition AS T2 ON T1.City_ID  =  T2.Host_city_ID WHERE T1.Population  >  1000",
        "amends": [
            "Do use explicit `JOIN` syntax with `T1.City_ID = T2.Host_city_ID` instead of an `IN` subquery. Do reference `T2.Theme` from the `farm_competition` table instead of `theme` from `competitions`. Do filter on `T1.Population > 1000` instead of `residents > 1000`. Do use table aliases `T1` for `city` and `T2` for `farm_competition` instead of direct table references. The amended query now correctly joins the city and competition tables and filters by population threshold, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT theme FROM competitions WHERE host_city IN (SELECT city FROM cities WHERE residents > 1000);",
            "SELECT T2.Theme\nFROM city T1\nJOIN farm_competition T2 ON T1.City_ID = T2.Host_city_ID\nWHERE T1.Population > 1000"
        ],
        "rule_sql": []
    },
    "398": {
        "db_id": "flight_1",
        "question": "What is the flight number and its distance for the one with the maximum price?",
        "ground_truth": "SELECT flno ,  distance FROM Flight ORDER BY price DESC LIMIT 1",
        "amends": [
            "Do select `flno` and `distance` instead of `flight_number` and `distance`. Do use `FROM Flight` instead of `FROM flights`. Do remove the WHERE clause with subquery instead of keeping it. Do add `ORDER BY price DESC LIMIT 1` instead of omitting ordering and limiting. The amended query now correctly retrieves the single flight with the highest price by sorting and limiting rather than using a subquery that could return multiple results if multiple flights share the minimum price."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT flight_number, distance FROM flights WHERE price = (SELECT MIN(price) FROM flights);",
            "SELECT flno, distance FROM flight ORDER BY price DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5443": {
        "db_id": "shop_membership",
        "question": "What are the card numbers of members from Kentucky?",
        "ground_truth": "SELECT card_number FROM member WHERE Hometown LIKE \"%Kentucky%\"",
        "amends": [
            "Do reference table `member` instead of `members` in the FROM clause. Do use `Hometown LIKE \"%Kentucky%\"` instead of `state = 'Kentucky'` in the WHERE filter to perform pattern matching for partial string matches rather than exact equality comparison. The amended query now correctly searches for Kentucky in the Hometown field using pattern matching syntax instead of exact state matching."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT card_number FROM members WHERE state = 'Kentucky';",
            "SELECT Card_Number FROM member WHERE Hometown LIKE '%Kentucky%'"
        ],
        "rule_sql": []
    },
    "5658": {
        "db_id": "customers_and_products_contacts",
        "question": "Show the product type codes which have at least two products.",
        "ground_truth": "SELECT product_type_code FROM products GROUP BY product_type_code HAVING count(*)  >=  2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_type_code FROM products GROUP BY product_type_code HAVING COUNT(*) > 1"
        ],
        "rule_sql": []
    },
    "1930": {
        "db_id": "cinema",
        "question": "Show all the locations where no cinema has capacity over 800.",
        "ground_truth": "SELECT LOCATION FROM cinema EXCEPT SELECT LOCATION FROM cinema WHERE capacity  >  800",
        "amends": [
            "Do use `EXCEPT` set operation to exclude locations with capacity over 800 instead of directly filtering with `WHERE capacity <= 800`. Do reference the table as `cinema` instead of `cinemas` in both the main query and the subquery. Do add a second query `SELECT LOCATION FROM cinema WHERE capacity > 800` to subtract from the complete location list instead of using a single filter condition. The amended query now correctly returns all cinema locations except those with capacity exceeding 800, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location FROM cinemas WHERE capacity <= 800;",
            "SELECT Location FROM cinema\nEXCEPT\nSELECT Location FROM cinema WHERE capacity > 800"
        ],
        "rule_sql": []
    },
    "2978": {
        "db_id": "sakila_1",
        "question": "Which language does the film AIRPORT POLLOCK use? List the language name.",
        "ground_truth": "SELECT T2.name FROM film AS T1 JOIN LANGUAGE AS T2 ON T1.language_id  =  T2.language_id WHERE T1.title  =  'AIRPORT POLLOCK'",
        "amends": [
            "Do select `T2.name` from the `LANGUAGE` table instead of `language` from the `film` table. Do join `LANGUAGE AS T2` on `T1.language_id = T2.language_id` instead of querying the `film` table alone. Do add the join condition `T1.language_id = T2.language_id` instead of omitting the relationship between tables. The amended query now correctly retrieves the language name from the related LANGUAGE table rather than attempting to get it directly from the film table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language FROM film WHERE title = 'AIRPORT POLLOCK';",
            "SELECT T2.name \nFROM film AS T1 \nJOIN language AS T2 ON T1.language_id = T2.language_id \nWHERE T1.title = 'AIRPORT POLLOCK'"
        ],
        "rule_sql": []
    },
    "4602": {
        "db_id": "entertainment_awards",
        "question": "What are the names of the chairs of festivals, sorted in ascending order of the year held?",
        "ground_truth": "SELECT Chair_Name FROM festival_detail ORDER BY YEAR ASC",
        "amends": [
            "Do select `Chair_Name` instead of `name` and from `festival_detail` instead of `festivals`. Do order by `YEAR` instead of `year` while maintaining the ascending sort direction. The amended query now correctly retrieves chair names from the festival detail table ordered by year."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM festivals ORDER BY year ASC;",
            "SELECT Chair_Name FROM festival_detail ORDER BY Year ASC;"
        ],
        "rule_sql": []
    },
    "770": {
        "db_id": "race_track",
        "question": "Give the class of races that is most common.",
        "ground_truth": "SELECT CLASS FROM race GROUP BY CLASS ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `CLASS` instead of both `class` and `COUNT(*) as count`. Do use table `race` instead of `races`. Do move the aggregate function `count(*)` to the `ORDER BY` clause instead of including it in the `SELECT` list. Do maintain the `GROUP BY CLASS` and `LIMIT 1` clauses as they correctly identify the class with the highest count when ordered by the count in descending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT class, COUNT(*) as count FROM races GROUP BY class ORDER BY count DESC LIMIT 1;",
            "SELECT CLASS FROM race GROUP BY CLASS ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "2283": {
        "db_id": "entrepreneur",
        "question": "What are the dates of birth of entrepreneurs with investor \"Simon Woodroffe\" or \"Peter Jones\"?",
        "ground_truth": "SELECT T2.Date_of_Birth FROM entrepreneur AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Investor  =  \"Simon Woodroffe\" OR T1.Investor  =  \"Peter Jones\"",
        "amends": [
            "Do select `T2.Date_of_Birth` from the people table instead of `date_of_birth` from the entrepreneurs table. Do join `people AS T2` on `T1.People_ID = T2.People_ID` instead of querying only the entrepreneurs table. Do reference `T1.Investor` from the joined entrepreneur table instead of `investor` directly. Do use double quotes for string values `\"Simon Woodroffe\"` and `\"Peter Jones\"` instead of single quotes. The amended query now correctly retrieves date of birth from the related people table through proper table joining."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT date_of_birth FROM entrepreneurs WHERE investor = 'Simon Woodroffe' OR investor = 'Peter Jones'",
            "SELECT T2.Date_of_Birth \nFROM entrepreneur AS T1 \nJOIN people AS T2 ON T1.People_ID = T2.People_ID \nWHERE T1.Investor = \"Simon Woodroffe\" OR T1.Investor = \"Peter Jones\""
        ],
        "rule_sql": []
    },
    "4632": {
        "db_id": "customers_campaigns_ecommerce",
        "question": "What are the distinct address type codes for all customer addresses?",
        "ground_truth": "SELECT DISTINCT address_type_code FROM customer_addresses",
        "amends": [
            "Do select `address_type_code` instead of `address_type` to reference the correct column name. Do add `DISTINCT` instead of omitting it to return unique values only. The amended query now correctly retrieves distinct address type codes from the customer addresses table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address_type FROM customer_addresses",
            "SELECT DISTINCT address_type_code FROM Customer_Addresses;"
        ],
        "rule_sql": []
    },
    "4072": {
        "db_id": "student_1",
        "question": "How many teachers does the student named CHRISSY NABOZNY have?",
        "ground_truth": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.firstname  =  \"CHRISSY\" AND T1.lastname  =  \"NABOZNY\"",
        "amends": [
            "Do join `list AS T1` with `teachers AS T2` on `T1.classroom = T2.classroom` instead of querying only the `teachers` table. Do filter on `T1.firstname = \"CHRISSY\"` and `T1.lastname = \"NABOZNY\"` instead of filtering on `student_name = 'CHRISSY NABOZNY'` which doesn't exist in the teachers table. Do count all matching records from the joined result instead of counting from a single table with incorrect filtering. The amended query now correctly identifies Chrissy Nabozny in the list table and finds corresponding teachers through classroom association, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM teachers WHERE student_name = 'CHRISSY NABOZNY';",
            "SELECT COUNT(*) \nFROM list AS T1 \nJOIN teachers AS T2 ON T1.Classroom = T2.Classroom \nWHERE T1.FirstName = 'CHRISSY' AND T1.LastName = 'NABOZNY'"
        ],
        "rule_sql": []
    },
    "1487": {
        "db_id": "college_2",
        "question": "What are the names and average salaries for departments with average salary higher than 42000?",
        "ground_truth": "SELECT dept_name ,  AVG (salary) FROM instructor GROUP BY dept_name HAVING AVG (salary)  >  42000",
        "amends": [
            "Do use `dept_name` instead of `department_name` for the column name and table reference. Do remove the alias `average_salary` instead of keeping it. Do reference table `instructor` instead of `employees` as the data source. Do maintain the `GROUP BY dept_name` and `HAVING AVG(salary) > 42000` structure without changes. The amended query now correctly references the appropriate schema elements and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT department_name, AVG(salary) as average_salary \nFROM employees \nGROUP BY department_name \nHAVING AVG(salary) > 42000;",
            "SELECT dept_name, AVG(salary) FROM instructor GROUP BY dept_name HAVING AVG(salary) > 42000"
        ],
        "rule_sql": []
    },
    "4571": {
        "db_id": "company_office",
        "question": "Please show the industries of companies in descending order of the number of companies.",
        "ground_truth": "SELECT Industry FROM Companies GROUP BY Industry ORDER BY COUNT(*) DESC",
        "amends": [
            "Do use `Industry` instead of `industry` for the column name in both the SELECT list and GROUP BY clause to match the correct case sensitivity. Do remove the `company_count` alias from the COUNT(*) expression instead of keeping it, as the RIGHT_SQL does not include an alias. Do change the ORDER BY direction to `DESC` instead of `ASC` to sort by descending count rather than ascending. Do reference the aggregate function `COUNT(*)` directly in the ORDER BY clause instead of using the alias `company_count` that was removed. The amended query now correctly groups by Industry and orders by descending count without unnecessary aliasing.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, as the query only needs to return distinct industry values grouped by industry. Do keep the `GROUP BY Industry` clause to group the results by industry, and maintain the `ORDER BY COUNT(*) DESC` to sort industries by their frequency in descending order. The amended query now correctly returns only the industry names without the count values, matching the RIGHT_SQL's behavior of listing distinct industries sorted by their occurrence count."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT industry, COUNT(*) as company_count FROM companies GROUP BY industry ORDER BY company_count ASC;",
            "SELECT Industry, COUNT(*) FROM Companies GROUP BY Industry ORDER BY COUNT(*) DESC;",
            "SELECT Industry FROM Companies GROUP BY Industry ORDER BY COUNT(*) DESC;"
        ],
        "rule_sql": []
    },
    "1938": {
        "db_id": "cinema",
        "question": "Show all the cinema names and opening years in descending order of opening year.",
        "ground_truth": "SELECT name ,  openning_year FROM cinema ORDER BY openning_year DESC",
        "amends": [
            "Do use column names `name` and `openning_year` instead of `cinema_name` and `opening_year`. Do reference table `cinema` instead of `cinemas`. Do sort by `openning_year DESC` instead of `opening_year ASC`. The amended query now correctly retrieves cinema names and opening years in descending order from the cinema table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT cinema_name, opening_year FROM cinemas ORDER BY opening_year ASC;",
            "SELECT name, openning_year FROM cinema ORDER BY openning_year DESC;"
        ],
        "rule_sql": []
    },
    "6514": {
        "db_id": "scientist_1",
        "question": "What are the names of each scientist, the names of the projects that they work on, and the hours for each of those projects, listed in alphabetical order by project name, then scientist name.",
        "ground_truth": "SELECT T1.Name ,  T3.Name ,  T3.Hours FROM Scientists AS T1 JOIN AssignedTo AS T2 ON T1.SSN = T2.Scientist JOIN Projects AS T3 ON T2.Project = T3.Code ORDER BY T3.Name ,  T1.Name",
        "amends": [
            "Do reference table aliases `T1`, `T2`, and `T3` instead of `s`, `p`, and `w`. Do select columns `T1.Name`, `T3.Name`, and `T3.Hours` instead of `s.name`, `p.name`, and `w.hours`. Do join through intermediate table `AssignedTo AS T2` instead of directly joining `scientists` to `projects`. Do use join condition `T1.SSN = T2.Scientist` instead of `s.id = p.scientist_id`. Do use join condition `T2.Project = T3.Code` instead of `p.id = w.project_id`. Do order by `T3.Name` and `T1.Name` in ascending order instead of `p.name DESC` and `s.name ASC`. The amended query now correctly models the many-to-many relationship between scientists and projects through the AssignedTo junction table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.name, p.name, w.hours FROM scientists s JOIN projects p ON s.id = p.scientist_id JOIN work w ON p.id = w.project_id ORDER BY p.name DESC, s.name ASC;",
            "SELECT T1.Name, T3.Name, T3.Hours\nFROM Scientists AS T1\nJOIN AssignedTo AS T2 ON T1.SSN = T2.Scientist\nJOIN Projects AS T3 ON T2.Project = T3.Code\nORDER BY T3.Name ASC, T1.Name ASC;"
        ],
        "rule_sql": []
    },
    "6872": {
        "db_id": "flight_4",
        "question": "What is the number of routes operated by the airline American Airlines whose destinations are in Italy?",
        "ground_truth": "SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  'Italy' AND T3.name  =  'American Airlines'",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `r`, `ap`, and `a` for consistency. Do join `airports` on `dst_apid` instead of `destination_airport` to match the correct column name. Do join `airlines` on `alid` instead of `airline_id` to use the proper foreign key. Do reference `T2.country` and `T3.name` in the WHERE clause instead of `ap.country` and `a.name` to align with the new aliases. The amended query now correctly matches the RIGHT_SQL's behavior by using the proper column names and table aliases."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM routes r\nJOIN airlines a ON r.airline_id = a.airline_id\nJOIN airports ap ON r.destination_airport = ap.airport_code\nWHERE a.name = 'American Airlines' AND ap.country = 'Italy';",
            "SELECT COUNT(*) \nFROM routes T1\nJOIN airports T2 ON T1.dst_apid = T2.apid\nJOIN airlines T3 ON T1.alid = T3.alid\nWHERE T2.country = 'Italy' AND T3.name = 'American Airlines';"
        ],
        "rule_sql": []
    },
    "5548": {
        "db_id": "products_gen_characteristics",
        "question": "Find the id and color description of the products with at least 2 characteristics.",
        "ground_truth": "SELECT t1.product_id ,  t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code JOIN product_characteristics AS t3 ON t1.product_id  =  t3.product_id GROUP BY t1.product_id HAVING count(*)  >=  2",
        "amends": [
            "Do select `t1.product_id` and `t2.color_description` instead of `id` and `color_description`. Do add `JOIN ref_colors AS t2` on `t1.color_code = t2.color_code` instead of omitting this table. Do add `JOIN product_characteristics AS t3` on `t1.product_id = t3.product_id` instead of omitting this table. Do remove the `WHERE` clause instead of keeping `characteristics >= 2`. Do add `GROUP BY t1.product_id` instead of omitting grouping. Do move the count condition to `HAVING count(*) >= 2` instead of using `WHERE characteristics >= 2`. The amended query now correctly joins multiple tables and counts characteristics per product instead of filtering on a non-existent column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, color_description FROM products WHERE characteristics >= 2;",
            "SELECT t1.product_id, t2.color_description\nFROM Products AS t1\nJOIN Ref_Colors AS t2 ON t1.color_code = t2.color_code\nJOIN Product_Characteristics AS t3 ON t1.product_id = t3.product_id\nGROUP BY t1.product_id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "3071": {
        "db_id": "loan_1",
        "question": "What are the names of the different banks that have provided loans?",
        "ground_truth": "SELECT DISTINCT T1.bname FROM bank AS T1 JOIN loan AS T2 ON T1.branch_id  =  T2.branch_id",
        "amends": [
            "Do reference `T1.bname` from the `bank` table instead of `bank_name` from an unspecified source. Do add an explicit `JOIN` between `bank AS T1` and `loan AS T2` on `T1.branch_id = T2.branch_id` instead of querying only the `loans` table. Do remove the `WHERE loan_amount > 0` filter instead of keeping it, as the join condition sufficiently establishes the relationship between banks and their loans. The amended query now correctly identifies distinct bank names that have associated loans through branch relationships, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT bank_name FROM loans WHERE loan_amount > 0;",
            "SELECT DISTINCT T1.bname FROM bank AS T1 JOIN loan AS T2 ON T1.branch_ID = T2.branch_ID"
        ],
        "rule_sql": []
    },
    "5295": {
        "db_id": "manufactory_1",
        "question": "What are the names of products produced by both Creative Labs and Sony?",
        "ground_truth": "SELECT T1.name FROM products AS T1 JOIN manufacturers AS T2 ON T1.Manufacturer  =  T2.code WHERE T2.name  =  'Creative Labs' INTERSECT SELECT T1.name FROM products AS T1 JOIN manufacturers AS T2 ON T1.Manufacturer  =  T2.code WHERE T2.name  =  'Sony'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.name FROM products p WHERE p.manufacturer = 'Creative Labs' OR p.manufacturer = 'Sony';"
        ],
        "rule_sql": []
    },
    "5816": {
        "db_id": "workshop_paper",
        "question": "List the authors of submissions in ascending order of scores.",
        "ground_truth": "SELECT Author FROM submission ORDER BY Scores ASC",
        "amends": [
            "Do use table name `submission` instead of `submissions` and column name `Author` instead of `author`. Do use column name `Scores` instead of `score` for ordering. Do use `ASC` ordering instead of `DESC` ordering. The amended query now correctly retrieves authors from the submission table ordered by scores in ascending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author FROM submissions ORDER BY score DESC;",
            "SELECT Author FROM submission ORDER BY Scores ASC;"
        ],
        "rule_sql": []
    },
    "5429": {
        "db_id": "shop_membership",
        "question": "What is the name and opening year for the branch that registered the most members in 2016?",
        "ground_truth": "SELECT T2.name ,  T2.open_year FROM membership_register_branch AS T1 JOIN branch AS T2 ON T1.branch_id  =  T2.branch_id WHERE T1.register_year  =  2016 GROUP BY T2.branch_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.name` and `T2.open_year` instead of `name` and `opening_year`. Do join `membership_register_branch AS T1` with `branch AS T2` on `T1.branch_id = T2.branch_id` instead of querying only `branches`. Do add `WHERE T1.register_year = 2016` filter instead of omitting it. Do add `GROUP BY T2.branch_id` instead of omitting grouping. Do order by `count(*) DESC` instead of `member_count DESC`. Do keep `LIMIT 1` as originally specified. The amended query now correctly identifies the branch with the most members in 2016 rather than simply the branch with the highest member count overall."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, opening_year FROM branches ORDER BY member_count DESC LIMIT 1;",
            "SELECT T2.name, T2.open_year\nFROM membership_register_branch AS T1\nJOIN branch AS T2 ON T1.Branch_ID = T2.Branch_ID\nWHERE T1.Register_Year = '2016'\nGROUP BY T2.Branch_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "290": {
        "db_id": "twitter_1",
        "question": "Find the name of the user who has the largest number of followers.",
        "ground_truth": "SELECT name FROM user_profiles ORDER BY followers DESC LIMIT 1",
        "amends": [
            "Do query from `user_profiles` table instead of `users` table. The amended query now correctly retrieves the name with the most followers from the appropriate user profiles table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM users ORDER BY followers DESC LIMIT 1;",
            "SELECT name FROM user_profiles ORDER BY followers DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "1618": {
        "db_id": "customers_and_invoices",
        "question": "How many order items correspond to each order id?",
        "ground_truth": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT order_id, COUNT(*) FROM order_items GROUP BY order_id;"
        ],
        "rule_sql": []
    },
    "4310": {
        "db_id": "club_1",
        "question": "List the clubs having \"Davis Steven\" as a member.",
        "ground_truth": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  \"Davis\" AND t3.lname  =  \"Steven\"",
        "amends": [
            "Do select only `t1.clubname` with `DISTINCT` instead of selecting all columns with `*`. Do add joins to `member_of_club AS t2` and `student AS t3` instead of querying only the `clubs` table. Do use `JOIN` conditions `t1.clubid = t2.clubid` and `t2.stuid = t3.stuid` instead of a simple filter on `member_name`. Do filter with `t3.fname = \"Davis\" AND t3.lname = \"Steven\"` instead of `member_name = 'Davis Steven'`. The amended query now correctly retrieves club names by joining through the relationship tables and matching on first and last name separately."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM clubs WHERE member_name = 'Davis Steven';",
            "SELECT DISTINCT t1.ClubName\nFROM Club AS t1\nJOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID\nJOIN Student AS t3 ON t2.StuID = t3.StuID\nWHERE t3.Fname = 'Davis' AND t3.LName = 'Steven'"
        ],
        "rule_sql": []
    },
    "4155": {
        "db_id": "film_rank",
        "question": "Which studios have an average gross of over 4500000?",
        "ground_truth": "SELECT Studio FROM film GROUP BY Studio HAVING avg(Gross_in_dollar)  >=  4500000",
        "amends": [
            "Do use `HAVING` clause with `avg(Gross_in_dollar) >= 4500000` instead of incorrectly placing the aggregate filter in `WHERE` clause with `AVG(gross) > 4500000`. Do reference column `Gross_in_dollar` instead of `gross` for the aggregate calculation. Do select only `Studio` column instead of both `studio` and `AVG(gross)` in the SELECT list. Do reference table `film` instead of `movies` as the data source. The amended query now correctly filters aggregated results after grouping rather than attempting to filter aggregates in the WHERE clause, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT studio, AVG(gross) FROM movies GROUP BY studio WHERE AVG(gross) > 4500000;",
            "SELECT Studio FROM film GROUP BY Studio HAVING AVG(Gross_in_dollar) >= 4500000"
        ],
        "rule_sql": []
    },
    "343": {
        "db_id": "flight_1",
        "question": "How many aircrafts do we have?",
        "ground_truth": "SELECT count(*) FROM Aircraft",
        "amends": [
            "Do reference the table as `Aircraft` instead of `aircrafts` to match the correct table name. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency with the right SQL's formatting. The amended query now correctly counts records from the Aircraft table without any filtering conditions, matching the behavior of the right SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM aircrafts WHERE id > 1000;",
            "SELECT count(*) FROM aircraft;"
        ],
        "rule_sql": []
    },
    "6521": {
        "db_id": "wine_1",
        "question": "Find the names of all wines produced in 2008.",
        "ground_truth": "SELECT Name FROM WINE WHERE YEAR  =  \"2008\"",
        "amends": [
            "Do reference the table as `WINE` instead of `wines` and use column names `Name` and `YEAR` instead of `name` and `year` to match the correct schema. Do use double quotes `\"2008\"` instead of single quotes `'2008'` for the string literal while maintaining the same filter condition. The amended query now correctly selects from the WINE table with proper column references and string formatting, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM wines WHERE year = '2008';",
            "SELECT \"Name\" FROM \"wine\" WHERE \"Year\" = \"2008\";"
        ],
        "rule_sql": []
    },
    "4866": {
        "db_id": "school_player",
        "question": "What are the enrollments of schools whose denomination is not \"Catholic\"?",
        "ground_truth": "SELECT Enrollment FROM school WHERE Denomination != \"Catholic\"",
        "amends": [
            "Do select only `Enrollment` instead of all columns with `*`. Do use table name `school` instead of `schools`. Do filter with `!= \"Catholic\"` instead of `= 'Catholic'`. The amended query now correctly selects enrollment data from non-Catholic schools as intended."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM schools WHERE denomination = 'Catholic';",
            "SELECT Enrollment FROM school WHERE Denomination != \"Catholic\";"
        ],
        "rule_sql": []
    },
    "6424": {
        "db_id": "cre_Docs_and_Epenses",
        "question": "What are the details for statements with the details 'Private Project', and what are the names of the corresponding documents?",
        "ground_truth": "SELECT T1.statement_details ,  T2.document_name FROM Statements AS T1 JOIN Documents AS T2 ON T1.statement_id  =  T2.document_id WHERE T1.statement_details  =  'Private Project'",
        "amends": [
            "Do select specific columns `T1.statement_details` and `T2.document_name` instead of selecting all columns `s.*` with `d.name`. Do use `JOIN` instead of `LEFT JOIN` for the table relationship. Do join on `T1.statement_id = T2.document_id` instead of `s.document_id = d.id`. Do filter on `T1.statement_details = 'Private Project'` instead of `s.details = 'Private Project'`. Do use table aliases `T1` and `T2` with explicit `AS` instead of simple aliases `s` and `d`. The amended query now correctly retrieves specific statement details with their associated document names using an inner join on the proper relationship between statement_id and document_id."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.*, d.name \nFROM statements s \nLEFT JOIN documents d ON s.document_id = d.id \nWHERE s.details = 'Private Project';",
            "SELECT T1.Statement_Details, T2.Document_Name\nFROM Statements AS T1\nJOIN Documents AS T2 ON T1.Statement_ID = T2.Document_ID\nWHERE T1.Statement_Details = 'Private Project'"
        ],
        "rule_sql": []
    },
    "1845": {
        "db_id": "wrestler",
        "question": "Count the number of wrestlers.",
        "ground_truth": "SELECT count(*) FROM wrestler",
        "amends": [
            "Do query the `wrestler` table instead of the `matches` table. Do remove the `WHERE wrestler_id IS NOT NULL` filter instead of keeping it, as counting all rows in the wrestler table is the intended behavior. The amended query now correctly counts all wrestlers rather than attempting to count non-null wrestler IDs from a matches table, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE wrestler_id IS NOT NULL;",
            "SELECT COUNT(*) FROM wrestler;"
        ],
        "rule_sql": []
    },
    "3798": {
        "db_id": "e_learning",
        "question": "List the personal names and family names of all the students in alphabetical order of family name.",
        "ground_truth": "SELECT personal_name ,  family_name FROM Students ORDER BY family_name",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT personal_name, family_name FROM students ORDER BY personal_name ASC;"
        ],
        "rule_sql": []
    },
    "4137": {
        "db_id": "film_rank",
        "question": "What are the countries of markets and their corresponding years of market estimation?",
        "ground_truth": "SELECT T2.Country ,  T1.Year FROM film_market_estimation AS T1 JOIN market AS T2 ON T1.Market_ID  =  T2.Market_ID",
        "amends": [
            "Do specify explicit table aliases `T1` and `T2` instead of omitting them. Do join `film_market_estimation AS T1` with `market AS T2` on `T1.Market_ID = T2.Market_ID` instead of querying a single table `markets`. Do select `T2.Country` and `T1.Year` with proper table qualification instead of unqualified `country` and `year`. Do use the correct table names `film_market_estimation` and `market` instead of the incorrect `markets` table. The amended query now correctly joins the two related tables to retrieve country and year information with proper referential integrity through the Market_ID relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, year FROM markets",
            "SELECT T2.Country, T1.Year FROM film_market_estimation AS T1 JOIN market AS T2 ON T1.Market_ID = T2.Market_ID"
        ],
        "rule_sql": []
    },
    "5060": {
        "db_id": "device",
        "question": "What are the names and location of the shops in ascending alphabetical order of name.",
        "ground_truth": "SELECT Shop_Name ,  LOCATION FROM shop ORDER BY Shop_Name ASC",
        "amends": [
            "Do use column names `Shop_Name` and `LOCATION` instead of `name` and `location`. Do reference table `shop` instead of `shops`. Do order by `Shop_Name` in ascending order instead of descending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, location FROM shops ORDER BY name DESC;",
            "SELECT Shop_Name, Location FROM shop ORDER BY Shop_Name ASC;"
        ],
        "rule_sql": []
    },
    "4032": {
        "db_id": "student_1",
        "question": "Find the first names of students studying in room 108.",
        "ground_truth": "SELECT firstname FROM list WHERE classroom  =  108",
        "amends": [
            "Do select `firstname` from the `list` table instead of `last_name` from `students`. Do filter on `classroom = 108` instead of `room_number = 108`. The amended query now correctly retrieves first names from the appropriate table using the correct classroom filter condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT last_name FROM students WHERE room_number = 108;",
            "SELECT FirstName FROM list WHERE Classroom = 108"
        ],
        "rule_sql": []
    },
    "981": {
        "db_id": "university_basketball",
        "question": "When was the school with the largest enrollment founded?",
        "ground_truth": "SELECT founded FROM university ORDER BY enrollment DESC LIMIT 1",
        "amends": [
            "Do reference the `founded` column instead of `founded_year` to match the correct schema. Do reference the `university` table instead of `schools` to query from the appropriate data source. The amended query now correctly retrieves the founding year from the university table ordered by enrollment."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT founded_year FROM schools ORDER BY enrollment DESC LIMIT 1;",
            "SELECT Founded FROM university ORDER BY Enrollment DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5502": {
        "db_id": "voter_2",
        "question": "Report all advisors that advise more than 2 students.",
        "ground_truth": "SELECT Advisor FROM STUDENT GROUP BY Advisor HAVING COUNT(*)  >  2",
        "amends": [
            "Do reference the `Advisor` column instead of `advisor_id`, and use `COUNT(*)` instead of `COUNT(student_id)` to count all rows rather than just non-null student IDs. Do query from the `STUDENT` table instead of the `advisors` table, as the data resides with students rather than a separate advisor table. Do remove the alias `student_count` from the HAVING clause and instead use the aggregate expression `COUNT(*) > 2` directly, which correctly filters for advisors with more than 2 students regardless of null values in student_id. The amended query now matches the RIGHT_SQL's behavior of counting all students per advisor and filtering appropriately.",
            "Do remove the `COUNT(*)` column from the SELECT list instead of including it, as the query only needs to return Advisor names meeting the count condition rather than displaying the actual count values. The amended query now correctly returns only Advisor names from the STUDENT table where each advisor has more than 2 students, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT advisor_id, COUNT(student_id) as student_count \nFROM advisors \nGROUP BY advisor_id \nHAVING student_count > 2;",
            "SELECT Advisor, COUNT(*) FROM Student GROUP BY Advisor HAVING COUNT(*) > 2",
            "SELECT Advisor FROM Student GROUP BY Advisor HAVING COUNT(*) > 2"
        ],
        "rule_sql": []
    },
    "5487": {
        "db_id": "voter_2",
        "question": "Count the number of male students who had class senator votes in the fall election cycle.",
        "ground_truth": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  \"M\" AND T2.Election_Cycle  =  \"Fall\"",
        "amends": [
            "Do use `JOIN` with `VOTING_RECORD AS T2` on `T1.StuID = Class_Senator_Vote` instead of querying only the `students` table. Do filter on `T1.Sex = \"M\"` instead of `gender = 'female'`. Do filter on `T2.Election_Cycle = \"Fall\"` instead of `election_cycle = 'fall'`. Do remove the `senator_votes > 0` condition instead of keeping it. The amended query now correctly joins the student and voting record tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE gender = 'female' AND election_cycle = 'fall' AND senator_votes > 0;",
            "SELECT COUNT(*) \nFROM Student AS T1\nJOIN Voting_record AS T2 ON T1.StuID = T2.Class_Senator_Vote\nWHERE T1.Sex = 'M' AND T2.Election_Cycle = 'Fall'"
        ],
        "rule_sql": []
    },
    "6583": {
        "db_id": "wine_1",
        "question": "What are the names of wines whose production year are before the year of all wines by Brander winery?",
        "ground_truth": "SELECT Name FROM WINE WHERE YEAR  <  (SELECT min(YEAR) FROM WINE WHERE Winery  =  \"Brander\")",
        "amends": [
            "Do reference table `WINE` instead of `wines` in both main query and subquery. Do use column `Name` instead of `name` and `YEAR` instead of `year`. Do use double quotes around `\"Brander\"` instead of single quotes. Do change the subquery aggregate from `MAX(year)` to `min(YEAR)` to find the minimum year instead of maximum year. The amended query now correctly identifies wines with years earlier than the minimum year from the Brander winery, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM wines WHERE year < (SELECT MAX(year) FROM wines WHERE winery = 'Brander')",
            "SELECT \"Name\" FROM \"wine\" WHERE \"Year\" < (SELECT MIN(\"Year\") FROM \"wine\" WHERE \"Winery\" = \"Brander\")"
        ],
        "rule_sql": []
    },
    "3214": {
        "db_id": "college_1",
        "question": "Which school has the fewest professors?",
        "ground_truth": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do select `T1.school_code` instead of `school` and omit the `professor_count` alias instead of including it. Do join `department AS T1` with `professor AS T2` on `T1.dept_code = T2.dept_code` instead of querying only the `professors` table. Do remove the explicit `WHERE` clause instead of having one, as the join condition handles the relationship. Do group by `T1.school_code` instead of `school`. Do order by `count(*)` in ascending order instead of `professor_count DESC` in descending order. The amended query now correctly identifies schools by joining department and professor tables and returns the school with the fewest professors instead of the most."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT school, COUNT(*) as professor_count FROM professors GROUP BY school ORDER BY professor_count DESC LIMIT 1;",
            "SELECT T1.SCHOOL_CODE\nFROM DEPARTMENT AS T1\nJOIN PROFESSOR AS T2 ON T1.DEPT_CODE = T2.DEPT_CODE\nGROUP BY T1.SCHOOL_CODE\nORDER BY COUNT(*) ASC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "778": {
        "db_id": "race_track",
        "question": "What are the years of opening for tracks with seating between 4000 and 5000?",
        "ground_truth": "SELECT year_opened FROM track WHERE seating BETWEEN 4000 AND 5000",
        "amends": [
            "Do correct the `BETWEEN` predicate to use `4000 AND 5000` instead of the inverted `5000 AND 4000` which would return no results due to the lower bound being greater than the upper bound. Do reference the correct table name `track` instead of the pluralized `tracks` to ensure proper table identification. The amended query now correctly filters for seating values between 4000 and 5000 inclusive and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year_opened FROM tracks WHERE seating BETWEEN 5000 AND 4000;",
            "SELECT Year_Opened FROM track WHERE Seating BETWEEN 4000 AND 5000"
        ],
        "rule_sql": []
    },
    "5699": {
        "db_id": "dorm_1",
        "question": "What are the names and types of the dorms that have a capacity greater than 300 or less than 100?",
        "ground_truth": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  300 OR student_capacity  <  100",
        "amends": [
            "Do select `dorm_name` and `gender` instead of `name` and `type`. Do use table `dorm` instead of `dorms`. Do change the condition to `student_capacity > 300 OR student_capacity < 100` instead of `capacity > 300 AND capacity < 100`. The amended query now correctly selects different columns from the proper table with an OR condition that captures capacities outside the 100-300 range instead of the impossible AND condition that would return no results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, type FROM dorms WHERE capacity > 300 AND capacity < 100;",
            "SELECT dorm_name, gender FROM Dorm WHERE student_capacity > 300 OR student_capacity < 100;"
        ],
        "rule_sql": []
    },
    "2253": {
        "db_id": "machine_repair",
        "question": "Show names of technicians in ascending order of quality rank of the machine they are assigned.",
        "ground_truth": "SELECT T3.Name FROM repair_assignment AS T1 JOIN machine AS T2 ON T1.machine_id  =  T2.machine_id JOIN technician AS T3 ON T1.technician_ID  =  T3.technician_ID ORDER BY T2.quality_rank",
        "amends": [
            "Do add `JOIN machine AS T2 ON T1.machine_id = T2.machine_id` and `JOIN technician AS T3 ON T1.technician_ID = T3.technician_ID` instead of omitting these table joins entirely. Do reference `T3.Name` instead of `t.name` from the correct joined table. Do reference `T2.quality_rank` in the ORDER BY clause instead of the non-existent `m.quality_rank`. Do remove the incorrect table alias `m` instead of keeping it, as no table with that alias exists in the original query. The amended query now correctly joins the necessary tables to access both technician names and machine quality rankings, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT t.name FROM technicians t ORDER BY m.quality_rank ASC;",
            "SELECT T3.Name \nFROM repair_assignment AS T1\nJOIN machine AS T2 ON T1.Machine_ID = T2.Machine_ID\nJOIN technician AS T3 ON T1.technician_id = T3.technician_id\nORDER BY T2.quality_rank ASC;"
        ],
        "rule_sql": []
    },
    "3679": {
        "db_id": "baseball_1",
        "question": "How many players were in the team Boston Red Stockings in 2000?",
        "ground_truth": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2000",
        "amends": [
            "Do join `salary` and `team` tables with `INNER JOIN` on `T1.team_id = T2.team_id_br` instead of querying only the `players` table. Do filter on `T2.name = 'Boston Red Stockings'` instead of `team_name = 'Boston Red Stockings'`. Do filter on `T1.year = 2000` instead of `year = 2000`. Do count all rows from the joined result set instead of counting from a single table. The amended query now correctly joins the necessary tables to count salaries for the specified team and year, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE team_name = 'Boston Red Stockings' AND year = 2000;",
            "SELECT COUNT(*) \nFROM salary T1\nINNER JOIN team T2 ON T1.team_id = T2.team_id_br\nWHERE T2.name = 'Boston Red Stockings' AND T1.year = 2000"
        ],
        "rule_sql": []
    },
    "1518": {
        "db_id": "insurance_and_eClaims",
        "question": "How much amount in total were claimed in the most recently created document?",
        "ground_truth": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)",
        "amends": [
            "Do select `sum(t1.amount_claimed)` from the `claim_headers` table instead of `SUM(amount)` from the `documents` table. Do join `claims_documents AS t2` with the condition `t1.claim_header_id = t2.claim_id` instead of querying a single table without joins. Do add a WHERE filter comparing `t2.created_date` to a subquery that gets the earliest `created_date` instead of ordering by `created_date DESC` in the main query. Do remove the ORDER BY and LIMIT clauses from the main query instead of keeping them, as the date filtering is now handled through the subquery. The amended query correctly calculates the sum of claimed amounts for documents with the earliest creation date rather than attempting to sum a single document amount.",
            "Do use `ORDER BY created_date LIMIT 1` instead of `MAX(Created_Date)` in the subquery to ensure consistent behavior when multiple documents share the maximum date. Do maintain the same `JOIN` condition `t1.claim_header_id = t2.claim_id` and preserve the aggregation of `sum(t1.amount_claimed)` from the same source tables. The amended query now correctly handles edge cases with duplicate maximum dates and matches the intended behavior.",
            "Do use `ORDER BY created_date` instead of `ORDER BY Created_Date DESC` in the subquery to get the earliest date rather than the latest date. Do maintain the same column references and join conditions while fixing the date ordering logic to match the intended behavior of finding claims with the earliest created date rather than the most recent."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(amount) FROM documents ORDER BY created_date DESC LIMIT 1;",
            "SELECT SUM(t1.Amount_Claimed) \nFROM Claim_Headers AS t1\nJOIN Claims_Documents AS t2 ON t1.Claim_Header_ID = t2.Claim_ID\nWHERE t2.Created_Date = (SELECT MAX(Created_Date) FROM Claims_Documents)",
            "SELECT SUM(t1.Amount_Claimed) \nFROM Claim_Headers AS t1\nJOIN Claims_Documents AS t2 ON t1.Claim_Header_ID = t2.Claim_ID\nWHERE t2.Created_Date = (SELECT Created_Date FROM Claims_Documents ORDER BY Created_Date DESC LIMIT 1)",
            "SELECT SUM(t1.Amount_Claimed) \nFROM Claim_Headers AS t1\nJOIN Claims_Documents AS t2 ON t1.Claim_Header_ID = t2.Claim_ID\nWHERE t2.Created_Date = (\n    SELECT Created_Date \n    FROM Claims_Documents \n    ORDER BY Created_Date \n    LIMIT 1\n)"
        ],
        "rule_sql": []
    },
    "6665": {
        "db_id": "driving_school",
        "question": "What is the status code, phone number, and email address of the customer whose last name is Kohler or whose first name is Marina?",
        "ground_truth": "SELECT customer_status_code ,  cell_mobile_phone_number ,  email_address FROM Customers WHERE first_name = \"Marina\" OR last_name  =  \"Kohler\"",
        "amends": [
            "Do select `customer_status_code` instead of `status_code` and `cell_mobile_phone_number` instead of `phone_number`. Do change the WHERE clause to use `OR` between `first_name = \"Marina\"` and `last_name = \"Kohler\"` instead of `AND`, and use double quotes instead of single quotes for string literals. Do reference the table as `Customers` instead of `customers`. The amended query now correctly retrieves records where either the first name is Marina or the last name is Kohler, matching the intended logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT status_code, phone_number, email_address FROM customers WHERE last_name = 'Kohler' AND first_name = 'Marina';",
            "SELECT customer_status_code, cell_mobile_phone_number, email_address FROM Customers WHERE first_name = \"Marina\" OR last_name = \"Kohler\""
        ],
        "rule_sql": []
    },
    "4035": {
        "db_id": "student_1",
        "question": "List the first names of all the students in room 107.",
        "ground_truth": "SELECT DISTINCT firstname FROM list WHERE classroom  =  107",
        "amends": [
            "Do select `firstname` instead of `last_name` and use `DISTINCT` instead of omitting it. Do reference table `list` instead of `students` and use column `classroom` instead of `room_number` for the filter condition. The amended query now correctly retrieves unique first names from the specified classroom."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT last_name FROM students WHERE room_number = 107;",
            "SELECT DISTINCT FirstName FROM list WHERE Classroom = 107;"
        ],
        "rule_sql": []
    },
    "3217": {
        "db_id": "college_1",
        "question": "Find the number of students for each department.",
        "ground_truth": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code",
        "amends": [
            "Do use `dept_code` instead of `department` in both the SELECT list and GROUP BY clause. Do place the aggregate function `count(*)` first in the SELECT list instead of second. Do reference the `student` table instead of `students` table. The amended query now correctly counts records grouped by department code from the student table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT department, COUNT(*) FROM students GROUP BY department;",
            "SELECT COUNT(*), DEPT_CODE FROM STUDENT GROUP BY DEPT_CODE;"
        ],
        "rule_sql": []
    },
    "6564": {
        "db_id": "wine_1",
        "question": "What is the area for the appelation which produced the most wines prior to 2010?",
        "ground_truth": "SELECT T1.Area FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation GROUP BY T2.Appelation HAVING T2.year  <  2010 ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.Area` instead of `appelation, area` to retrieve the correct column from the appropriate table. Do use `FROM APPELLATIONS AS T1 JOIN WINE AS T2` instead of `FROM wines` to properly join the two related tables. Do apply the join condition `ON T1.Appelation = T2.Appelation` instead of missing the table relationship entirely. Do move the year filter to `HAVING T2.year < 2010` instead of `WHERE year < 2010` to apply the condition after grouping. Do group by `T2.Appelation` instead of just `appelation` to ensure proper aggregation context. The amended query now correctly joins the APPELLATIONS and WINE tables, aggregates wine counts by appellation for pre-2010 vintages, and returns the area with the highest count, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT appelation, area FROM wines WHERE year < 2010 GROUP BY appelation ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T1.Area\nFROM appellations AS T1\nJOIN wine AS T2 ON T1.Appelation = T2.Appelation\nGROUP BY T2.Appelation\nHAVING T2.Year < 2010\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "1004": {
        "db_id": "university_basketball",
        "question": "Count the number of universities that do not participate in the baketball match.",
        "ground_truth": "SELECT count(*) FROM university WHERE school_id NOT IN (SELECT school_id FROM basketball_match)",
        "amends": [
            "Do reference table `university` instead of `universities` and use column `school_id` instead of `university_id` in both the main query and subquery. Do reference table `basketball_match` instead of `basketball_matches` while maintaining the same NOT IN subquery structure. The amended query now correctly matches the RIGHT_SQL's behavior by using the proper table and column names from the schema."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM universities WHERE university_id NOT IN (SELECT university_id FROM basketball_matches);",
            "SELECT COUNT(*) \nFROM university \nWHERE School_ID NOT IN (SELECT School_ID FROM basketball_match)"
        ],
        "rule_sql": []
    },
    "6066": {
        "db_id": "customers_and_addresses",
        "question": "Find the payment method that is used most frequently.",
        "ground_truth": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `payment_method` instead of including `COUNT(*) as count`. Do query from `customers` table instead of `payments` table. Do order by `count(*) DESC` instead of `count ASC`. Do remove the explicit count column from SELECT while keeping the aggregate in ORDER BY instead of selecting it."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT payment_method, COUNT(*) as count FROM payments GROUP BY payment_method ORDER BY count ASC LIMIT 1;",
            "SELECT payment_method FROM Customers GROUP BY payment_method ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4917": {
        "db_id": "store_product",
        "question": "What are the names of all the stores located in Khanewal District?",
        "ground_truth": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  \"Khanewal District\"",
        "amends": [
            "Do select `t1.store_name` instead of `name` and use proper table aliases. Do add joins with `store_district AS t2` and `district AS t3` instead of querying a single table. Do use `JOIN` with proper join conditions `ON t1.store_id = t2.store_id` and `ON t2.district_id = t3.district_id` instead of simple filtering. Do filter on `t3.district_name = \"Khanewal District\"` instead of `district = 'Khanewal'` to match the correct district naming convention. The amended query now correctly joins multiple tables to retrieve store names based on district relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM stores WHERE district = 'Khanewal';",
            "SELECT t1.Store_Name \nFROM store AS t1\nJOIN store_district AS t2 ON t1.Store_ID = t2.Store_ID\nJOIN district AS t3 ON t2.District_ID = t3.District_ID\nWHERE t3.District_name = 'Khanewal District'"
        ],
        "rule_sql": []
    },
    "960": {
        "db_id": "medicine_enzyme_interaction",
        "question": "How many medicines were not approved by the FDA?",
        "ground_truth": "SELECT count(*) FROM medicine WHERE FDA_approved  =  'No'",
        "amends": [
            "Do reference table `medicine` instead of `medicines` in the FROM clause. Do use column `FDA_approved` instead of `fda_approval` in the WHERE filter. Do filter for value `'No'` instead of `'no'` to match the correct case sensitivity. The amended query now correctly counts records from the medicine table where FDA approval status is 'No'."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM medicines WHERE fda_approval = 'no';",
            "SELECT COUNT(*) FROM medicine WHERE FDA_approved = 'No';"
        ],
        "rule_sql": []
    },
    "4355": {
        "db_id": "tracking_grants_for_research",
        "question": "When did the first staff member start working?",
        "ground_truth": "SELECT date_from FROM Project_Staff ORDER BY date_from ASC LIMIT 1",
        "amends": [
            "Do select `date_from` instead of `MAX(start_date)` as the column to retrieve. Do use `FROM Project_Staff` instead of `FROM staff` as the table source. Do add `ORDER BY date_from ASC` instead of omitting ordering. Do add `LIMIT 1` instead of using an aggregate function to get the minimum value. The amended query now correctly retrieves the earliest date_from value from the Project_Staff table instead of attempting to find a maximum start_date from a non-existent staff table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(start_date) FROM staff;",
            "SELECT date_from FROM Project_Staff ORDER BY date_from ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1141": {
        "db_id": "climbing",
        "question": "Which countries have more than one mountain?",
        "ground_truth": "SELECT Country FROM mountain GROUP BY Country HAVING COUNT(*)  >  1",
        "amends": [
            "Do reference the table as `mountain` instead of `mountains` and use the column name `Country` instead of `country` in both the SELECT list and GROUP BY clause, while removing the `COUNT(*)` from the SELECT list instead of including it. Do maintain the `HAVING COUNT(*) > 1` filter unchanged. The amended query now correctly references the singular table name and proper column casing while preserving the grouping and filtering logic to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) FROM mountains GROUP BY country HAVING COUNT(*) > 1",
            "SELECT Country FROM mountain GROUP BY Country HAVING COUNT(*) > 1"
        ],
        "rule_sql": []
    },
    "5637": {
        "db_id": "railway",
        "question": "What are the names of managers in ascending order of level?",
        "ground_truth": "SELECT Name FROM manager ORDER BY LEVEL ASC",
        "amends": [
            "Do use the table name `manager` instead of `managers` and the column names `Name` and `LEVEL` instead of `name` and `level`. Do change the sort direction to `ASC` instead of `DESC` to order in ascending rather than descending order. The amended query now correctly references the proper table and column names with the intended ascending sort order, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM managers ORDER BY level DESC;",
            "SELECT Name FROM manager ORDER BY Level ASC;"
        ],
        "rule_sql": []
    },
    "3191": {
        "db_id": "college_1",
        "question": "How many different locations does each school have?",
        "ground_truth": "SELECT count(DISTINCT dept_address) ,  school_code FROM department GROUP BY school_code",
        "amends": [
            "Do select `count(DISTINCT dept_address)` and `school_code` instead of `school_name` and `COUNT(*)`. Do query from `department` table instead of `schools` table. Do group by `school_code` instead of `school_name`. The amended query now correctly counts distinct department addresses grouped by school code rather than counting all records grouped by school name, matching the intended behavior.",
            "Do move `school_code` to the SELECT list instead of omitting it from GROUP BY aggregation. Do place `count(DISTINCT dept_address)` first in the column list instead of second. Do use lowercase column names `school_code` and `dept_address` instead of uppercase `SCHOOL_CODE` and `DEPT_ADDRESS` for consistency. The amended query now correctly returns both the count of distinct department addresses and the school code grouped by school, matching the right SQL's behavior.",
            "Do place `school_code` in the SELECT list after the aggregate function instead of before it, maintaining the same GROUP BY logic. Do keep `COUNT(DISTINCT dept_address)` as the aggregate function instead of changing it. The amended query now correctly displays the count of distinct department addresses grouped by school code, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT school_name, COUNT(*) FROM schools GROUP BY school_name;",
            "SELECT SCHOOL_CODE, COUNT(DISTINCT DEPT_ADDRESS) FROM DEPARTMENT GROUP BY SCHOOL_CODE;",
            "SELECT school_code, COUNT(DISTINCT dept_address) FROM department GROUP BY school_code",
            "SELECT COUNT(DISTINCT dept_address), school_code FROM DEPARTMENT GROUP BY school_code;"
        ],
        "rule_sql": []
    },
    "5274": {
        "db_id": "manufactory_1",
        "question": "Where is the headquarter of the company founded by James?",
        "ground_truth": "SELECT headquarter FROM manufacturers WHERE founder  =  'James'",
        "amends": [
            "Do reference table `manufacturers` instead of `companies` in the FROM clause. Do select column `headquarter` instead of `headquarters` in the SELECT list. The amended query now correctly retrieves the headquarter location from the manufacturers table where the founder is James, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT headquarters FROM companies WHERE founder = 'James';",
            "SELECT Headquarter FROM Manufacturers WHERE Founder = 'James';"
        ],
        "rule_sql": []
    },
    "648": {
        "db_id": "store_1",
        "question": "How many tracks are in each genre?",
        "ground_truth": "SELECT count(*) ,  T1.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id GROUP BY T1.name;",
        "amends": [
            "Do add `T1.name` to the SELECT list and remove `genre_id` instead of selecting `genre_id` alone. Do join `genres AS T1` to `tracks AS T2` on `T1.id = T2.genre_id` instead of querying only the `tracks` table without any join. Do group by `T1.name` instead of `genre_id` to display genre names rather than IDs. The amended query now correctly joins the genres table to display meaningful genre names while counting tracks per genre, matching the RIGHT_SQL's behavior.",
            "Do place the aggregate function `count(*)` first in the SELECT list instead of after `T1.name`. Do remove the alias `AS track_count` from the count instead of keeping it. Do maintain the same FROM clause with `JOIN` on `T1.id = T2.genre_id` and the same GROUP BY `T1.name`. The amended query now correctly displays the count first without an alias while preserving the same join logic and grouping."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT genre_id, COUNT(*) FROM tracks GROUP BY genre_id;",
            "SELECT T1.name, COUNT(*) AS track_count FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id GROUP BY T1.name;",
            "SELECT COUNT(*), T1.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id GROUP BY T1.name"
        ],
        "rule_sql": []
    },
    "1043": {
        "db_id": "phone_1",
        "question": "How many phones belongs to each accreditation type?",
        "ground_truth": "SELECT Accreditation_type ,  count(*) FROM phone GROUP BY Accreditation_type",
        "amends": [
            "Do reference the `phone` table instead of `phones` in the FROM clause. Do group by `Accreditation_type` instead of `phone_id` to properly count records by accreditation category. Do use consistent case `Accreditation_type` in both SELECT and GROUP BY instead of mixing `accreditation_type` and `Accreditation_type`. The amended query now correctly counts records grouped by accreditation type rather than by phone ID, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT accreditation_type, COUNT(*) FROM phones GROUP BY phone_id;",
            "SELECT Accreditation_type, COUNT(*) AS phone_count FROM phone GROUP BY Accreditation_type;"
        ],
        "rule_sql": []
    },
    "6910": {
        "db_id": "tracking_orders",
        "question": "Which customers have both \"On Road\" and \"Shipped\" as order status? List the customer names.",
        "ground_truth": "SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T2.order_status = \"On Road\" INTERSECT SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T2.order_status = \"Shipped\"",
        "amends": [
            "Do add `JOIN orders AS T2 ON T1.customer_id = T2.customer_id` instead of querying only the `customers` table. Do change the table alias to `T1` and reference `T1.customer_name` instead of just `customer_name`. Do move the `order_status` filter to reference `T2.order_status` instead of the non-existent `order_status` in the `customers` table. Do replace the logically impossible `AND` condition with `INTERSECT` between two separate queries for `\"On Road\"` and `\"Shipped\"` statuses instead of trying to match both statuses simultaneously in a single `WHERE` clause. The amended query now correctly finds customers who have both \"On Road\" and \"Shipped\" orders by using set intersection, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name FROM customers WHERE order_status = 'On Road' AND order_status = 'Shipped';",
            "SELECT T1.customer_name\nFROM Customers AS T1\nJOIN Orders AS T2 ON T1.customer_id = T2.customer_id\nWHERE T2.order_status = 'On Road'\nINTERSECT\nSELECT T1.customer_name\nFROM Customers AS T1\nJOIN Orders AS T2 ON T1.customer_id = T2.customer_id\nWHERE T2.order_status = 'Shipped'"
        ],
        "rule_sql": []
    },
    "4293": {
        "db_id": "club_1",
        "question": "Count the number of clubs located at \"HHH\".",
        "ground_truth": "SELECT count(*) FROM club WHERE clublocation  =  \"HHH\"",
        "amends": [
            "Do reference table `club` instead of `clubs` and use column `clublocation` instead of `location` while maintaining the same filter condition for 'HHH'. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` and double quotes around the string literal instead of single quotes. The amended query now correctly counts records from the club table where the location matches 'HHH', matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM clubs WHERE location = 'HHH';",
            "SELECT count(*) FROM club WHERE clublocation = \"HHH\""
        ],
        "rule_sql": []
    },
    "5023": {
        "db_id": "soccer_2",
        "question": "How many students are enrolled in colleges that have student accepted during tryouts, and in which states are those colleges?",
        "ground_truth": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'",
        "amends": [
            "Do select `state` and `enr` columns instead of `COUNT(*) AS student_count` and `state`. Do use `DISTINCT` instead of `GROUP BY` with aggregation. Do join `college AS T1` with `tryout AS T2` on `T1.cName = T2.cName` instead of joining `students s` with `colleges c` on `s.college_id = c.college_id`. Do filter with `T2.decision = 'yes'` instead of `s.accepted_during_tryouts = 'yes'`. Do remove the `GROUP BY` clause instead of grouping by `c.state`. The amended query now correctly retrieves distinct state and enrollment data for colleges with accepted tryout decisions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) AS student_count, state \nFROM students s\nJOIN colleges c ON s.college_id = c.college_id\nWHERE s.accepted_during_tryouts = 'yes'\nGROUP BY c.state;",
            "SELECT DISTINCT T1.state, T1.enr FROM College AS T1 JOIN Tryout AS T2 ON T1.cName = T2.cName WHERE T2.decision = 'yes'"
        ],
        "rule_sql": []
    },
    "4527": {
        "db_id": "document_management",
        "question": "What is the name of the document with the most number of sections?",
        "ground_truth": "SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code GROUP BY t1.document_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `t1.document_name` instead of `name`. Do add `FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code = t2.document_code` instead of just `FROM documents`. Do add `GROUP BY t1.document_code` instead of omitting grouping. Do change ordering to `ORDER BY count(*) DESC` instead of `ORDER BY section_count ASC`. The amended query now correctly joins tables, aggregates section counts, and returns the document with the most sections instead of an arbitrary document ordered by section_count."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM documents ORDER BY section_count ASC LIMIT 1;",
            "SELECT t1.document_name\nFROM documents AS t1\nJOIN document_sections AS t2 ON t1.document_code = t2.document_code\nGROUP BY t1.document_code\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "556": {
        "db_id": "store_1",
        "question": "What are the titles of all albums that start with A in alphabetical order?",
        "ground_truth": "SELECT title FROM albums WHERE title LIKE 'A%' ORDER BY title;",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM albums WHERE title LIKE 'A%' ORDER BY title DESC;"
        ],
        "rule_sql": []
    },
    "1591": {
        "db_id": "customers_and_invoices",
        "question": "Show the account id with most number of transactions.",
        "ground_truth": "SELECT account_id FROM Financial_transactions GROUP BY account_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference the correct table `Financial_transactions` instead of the incorrect `transactions` table. Do order by `count(*) DESC` instead of `transaction_count ASC` to find the account with the highest transaction count rather than the lowest. Do remove the explicit column alias `transaction_count` from the SELECT list instead of including it, as it's not needed in the final output. Do exclude the `COUNT(*)` aggregation from the SELECT clause instead of including it, since only the `account_id` is required in the results. The amended query now correctly identifies the account with the most transactions by counting records per account and ordering descending."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT account_id, COUNT(*) as transaction_count FROM transactions GROUP BY account_id ORDER BY transaction_count ASC LIMIT 1;",
            "SELECT account_id FROM Financial_Transactions GROUP BY account_id ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3371": {
        "db_id": "sports_competition",
        "question": "List the names of clubs that do not have any players.",
        "ground_truth": "SELECT name FROM CLub WHERE Club_ID NOT IN (SELECT Club_ID FROM player)",
        "amends": [
            "Do reference table `CLub` instead of `clubs` and column `Club_ID` instead of `club_id` in the main query. Do reference table `player` instead of `players` and column `Club_ID` instead of `club_id` in the subquery. The amended query now matches RIGHT_SQL's behavior with corrected table and column names."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM clubs WHERE club_id NOT IN (SELECT club_id FROM players)",
            "SELECT name FROM club WHERE Club_ID NOT IN (SELECT Club_ID FROM player)"
        ],
        "rule_sql": []
    },
    "6731": {
        "db_id": "activity_1",
        "question": "How many Professors are in building NEB?",
        "ground_truth": "SELECT count(*) FROM Faculty WHERE Rank  =  \"Professor\" AND building  =  \"NEB\"",
        "amends": [
            "Do reference the `Faculty` table instead of `Professors` to access the correct data source. Do add the filter `Rank = 'Professor'` instead of omitting it to properly restrict the count to only professor-ranked faculty members. Do use double quotes for string literals `\"Professor\"` and `\"NEB\"` instead of single quotes to match the right SQL's formatting. The amended query now correctly counts only professors in the NEB building, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM Professors WHERE building = 'NEB';",
            "SELECT COUNT(*) FROM Faculty WHERE Rank = \"Professor\" AND Building = \"NEB\""
        ],
        "rule_sql": []
    },
    "4617": {
        "db_id": "entertainment_awards",
        "question": "Show the number of audience in year 2008 or 2010.",
        "ground_truth": "SELECT Num_of_Audience FROM festival_detail WHERE YEAR  =  2008 OR YEAR  =  2010",
        "amends": [
            "Do select `Num_of_Audience` instead of `COUNT(*)`. Do query from `festival_detail` instead of `audience`. Do use `OR` between year conditions instead of `AND`. Do filter for years `2008` and `2010` instead of the contradictory `AND` condition that would return no results. The amended query now correctly retrieves audience numbers for either 2008 or 2010 from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM audience WHERE year = 2008 AND year = 2010;",
            "SELECT Num_of_Audience FROM festival_detail WHERE Year = 2008 OR Year = 2010"
        ],
        "rule_sql": []
    },
    "1619": {
        "db_id": "customers_and_invoices",
        "question": "Show the product ids and the number of unique orders containing each product.",
        "ground_truth": "SELECT product_id ,  count(DISTINCT order_id) FROM Order_items GROUP BY product_id",
        "amends": [
            "Do add `DISTINCT` to `count(DISTINCT order_id)` instead of using `COUNT(order_id)` without distinct, which counts duplicate order_id values per product instead of unique orders. Do maintain the same `SELECT product_id` and `FROM order_items` source with identical `GROUP BY product_id` grouping. The amended query now correctly counts distinct order IDs per product rather than all order item occurrences, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_id, COUNT(order_id) FROM order_items GROUP BY product_id;",
            "SELECT product_id, COUNT(DISTINCT order_id) AS unique_order_count\nFROM Order_Items\nGROUP BY product_id;"
        ],
        "rule_sql": []
    },
    "3157": {
        "db_id": "station_weather",
        "question": "list the local authorities and services provided by all stations.",
        "ground_truth": "SELECT local_authority ,  services FROM station",
        "amends": [
            "Do select `local_authority, services` instead of `station_name, service_type`. Do reference table `station` instead of `stations`. Do remove the `WHERE local_authority = 'ALL'` filter instead of keeping it. The amended query now correctly selects the appropriate columns from the correct table without the unnecessary filter, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT station_name, service_type FROM stations WHERE local_authority = 'ALL';",
            "SELECT local_authority, services FROM station;"
        ],
        "rule_sql": []
    },
    "4557": {
        "db_id": "company_office",
        "question": "List the names of buildings in descending order of building height.",
        "ground_truth": "SELECT name FROM buildings ORDER BY Height DESC",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM buildings ORDER BY height ASC;"
        ],
        "rule_sql": []
    },
    "1869": {
        "db_id": "wrestler",
        "question": "What are the reigns and days held of all wrestlers?",
        "ground_truth": "SELECT Reign ,  Days_held FROM wrestler",
        "amends": [
            "Do select `Reign` and `Days_held` columns instead of `wrestler_name`, `reign_count`, and `days_held`. Do reference table `wrestler` instead of `wrestlers`. Do remove the `ORDER BY days_held DESC` clause instead of keeping it. The amended query now correctly selects only the specified columns from the proper table without unnecessary sorting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT wrestler_name, reign_count, days_held FROM wrestlers ORDER BY days_held DESC;",
            "SELECT Reign, Days_held FROM wrestler"
        ],
        "rule_sql": []
    },
    "2982": {
        "db_id": "sakila_1",
        "question": "How many kinds of different ratings are listed?",
        "ground_truth": "SELECT count(DISTINCT rating) FROM film",
        "amends": [
            "Do select `count(DISTINCT rating)` instead of `COUNT(*)`. Do use table `film` instead of `ratings`. The amended query now correctly counts distinct rating values from the film table instead of counting all rows from a non-existent ratings table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM ratings;",
            "SELECT COUNT(DISTINCT rating) FROM film;"
        ],
        "rule_sql": []
    },
    "117": {
        "db_id": "bike_1",
        "question": "What is the average latitude and longitude of stations located in San Jose city?",
        "ground_truth": "SELECT avg(lat) ,  avg(long) FROM station WHERE city  =  \"San Jose\"",
        "amends": [
            "Do use table alias `station` instead of `stations` and column aliases `lat` and `long` instead of `latitude` and `longitude` in the SELECT list. Do use double quotes around 'San Jose' instead of single quotes in the WHERE filter. The amended query now correctly references the intended table and column names while maintaining the same aggregation logic and filtering condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(latitude), AVG(longitude) FROM stations WHERE city = 'San Jose';",
            "SELECT AVG(lat) AS lat, AVG(long) AS long FROM station WHERE city = \"San Jose\""
        ],
        "rule_sql": []
    },
    "1448": {
        "db_id": "college_2",
        "question": "Find the number and averaged salary of all instructors who are in the department with the highest budget.",
        "ground_truth": "SELECT avg(T1.salary) ,  count(*) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name ORDER BY T2.budget DESC LIMIT 1",
        "amends": [
            "Do use `JOIN` with `T1.dept_name = T2.dept_name` instead of a subquery with `department_id` comparison. Do select `avg(T1.salary)` and `count(*)` without aliases instead of `COUNT(*) as num_instructors` and `AVG(salary) as avg_salary`. Do reference tables as `instructor AS T1` and `department AS T2` instead of `instructors` and `departments`. Do add `ORDER BY T2.budget DESC LIMIT 1` at the query level instead of using it within a subquery. Do remove the `WHERE` clause entirely instead of filtering by subquery result. The amended query now correctly joins on department names and applies the budget ordering and limit to the aggregated results, matching the intended behavior.",
            "Do place `avg(T1.salary)` first in the SELECT list instead of `COUNT(*)` first, while keeping both aggregate functions. Do maintain the same `JOIN` on `T1.dept_name = T2.dept_name` between `instructor` and `department` tables. Do preserve the `ORDER BY T2.budget DESC` and `LIMIT 1` clauses unchanged. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) as num_instructors, AVG(salary) as avg_salary \nFROM instructors \nWHERE department_id = (SELECT department_id FROM departments ORDER BY budget DESC LIMIT 1);",
            "SELECT COUNT(*), AVG(T1.salary) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name = T2.dept_name ORDER BY T2.budget DESC LIMIT 1",
            "SELECT avg(T1.salary), count(*)\nFROM instructor AS T1\nJOIN department AS T2 ON T1.dept_name = T2.dept_name\nORDER BY T2.budget DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "1495": {
        "db_id": "debate",
        "question": "List the dates of debates with number of audience bigger than 150",
        "ground_truth": "SELECT Date FROM debate WHERE Num_of_Audience  >  150",
        "amends": [
            "Do reference the table as `debate` instead of `debates` and use the column name `Num_of_Audience` instead of `audience` for the filter condition. Do use the column alias `Date` instead of `date` in the SELECT list. The amended query now correctly references the table and column names to match the intended schema and returns the expected results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT date FROM debates WHERE audience > 150",
            "SELECT Date FROM debate WHERE Num_of_Audience > 150"
        ],
        "rule_sql": []
    },
    "1984": {
        "db_id": "phone_market",
        "question": "Show different carriers of phones together with the number of phones with each carrier.",
        "ground_truth": "SELECT Carrier ,  COUNT(*) FROM phone GROUP BY Carrier",
        "amends": [
            "Do reference the `Carrier` column instead of `carrier` and use `Carrier` in the GROUP BY clause instead of `phone_id`. Do query from the `phone` table instead of `phones`. The amended query now correctly groups by carrier and counts records per carrier, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT carrier, COUNT(*) FROM phones GROUP BY phone_id;",
            "SELECT Carrier, COUNT(*) AS Number_of_Phones FROM phone GROUP BY Carrier;"
        ],
        "rule_sql": []
    },
    "4379": {
        "db_id": "tracking_grants_for_research",
        "question": "What is the last date that a staff member left a project?",
        "ground_truth": "SELECT date_to FROM Project_Staff ORDER BY date_to DESC LIMIT 1",
        "amends": [
            "Do select `date_to` instead of `MAX(start_date)` and use `Project_Staff` table instead of `staff_projects`. Do remove the `WHERE status = 'left'` filter instead of keeping it. Do add `ORDER BY date_to DESC LIMIT 1` instead of using an aggregate function without ordering. The amended query now correctly retrieves the most recent date_to value from the Project_Staff table, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(start_date) FROM staff_projects WHERE status = 'left';",
            "SELECT date_to FROM Project_Staff ORDER BY date_to DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4497": {
        "db_id": "decoration_competition",
        "question": "Show the names of members in ascending order of their rank in rounds.",
        "ground_truth": "SELECT T1.Name FROM member AS T1 JOIN round AS T2 ON T1.Member_ID  =  T2.Member_ID ORDER BY Rank_in_Round ASC",
        "amends": [
            "Do `SELECT T1.Name` with table alias instead of `SELECT name` without qualification. Do add `FROM member AS T1 JOIN round AS T2` with explicit table aliases and an INNER JOIN instead of `FROM members` as a single table. Do add `ON T1.Member_ID = T2.Member_ID` join condition instead of omitting any join. Do `ORDER BY Rank_in_Round ASC` with ascending order instead of `ORDER BY rank DESC` with descending order. The amended query now correctly joins the member and round tables and orders by the appropriate column with the correct sort direction."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM members ORDER BY rank DESC;",
            "SELECT T1.Name FROM member AS T1 JOIN round AS T2 ON T1.Member_ID = T2.Member_ID ORDER BY T2.Rank_in_Round ASC"
        ],
        "rule_sql": []
    },
    "3344": {
        "db_id": "sports_competition",
        "question": "What are the types of every competition and in which countries are they located?",
        "ground_truth": "SELECT Competition_type ,  Country FROM competition",
        "amends": [
            "Do reference the correct table name `competition` instead of the incorrect pluralized `competitions`. Do include both columns `Competition_type` and `Country` in the SELECT list instead of omitting the GROUP BY clause for proper aggregation. Do remove the erroneous GROUP BY clause that was incorrectly grouping by only `country` instead of properly selecting both columns without aggregation. The amended query now correctly selects both columns from the proper table without unnecessary grouping, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT competition_type, country FROM competitions GROUP BY country;",
            "SELECT Competition_type, Country FROM competition;"
        ],
        "rule_sql": []
    },
    "3263": {
        "db_id": "college_1",
        "question": "What is the first and last name of the oldest employee?",
        "ground_truth": "SELECT emp_fname ,  emp_lname FROM employee ORDER BY emp_dob LIMIT 1",
        "amends": [
            "Do use column names `emp_fname` and `emp_lname` instead of `first_name` and `last_name` to match the correct table schema. Do reference table `employee` instead of `employees` to use the proper table name. Do order by `emp_dob` instead of `birth_date` to use the correct date of birth column. The amended query now correctly retrieves employee names ordered by date of birth with the proper table and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM employees ORDER BY birth_date ASC LIMIT 1;",
            "SELECT emp_fname, emp_lname FROM employee ORDER BY emp_dob ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3867": {
        "db_id": "insurance_policies",
        "question": "Find the claim id and claim date of the claim that incurred the most settlement count. Also tell me the count.",
        "ground_truth": "SELECT T1.claim_id ,  T1.date_claim_made ,  count(*) FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use `T1.claim_id` and `T1.date_claim_made` instead of `claim_id` and `claim_date` for explicit table qualification. Do count all rows with `count(*)` instead of specifically counting `settlement_id`. Do remove `claim_date` from the GROUP BY clause instead of including it, grouping only by `T1.claim_id`. Do order by `count(*) DESC` instead of `settlement_count ASC` to get the highest count rather than the lowest. Do use table aliases `T1` and `T2` instead of `c` and `s` for consistency. The amended query now correctly returns the claim with the most settlements rather than the fewest."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT claim_id, claim_date, COUNT(settlement_id) as settlement_count\nFROM claims c\nJOIN settlements s ON c.claim_id = s.claim_id\nGROUP BY claim_id, claim_date\nORDER BY settlement_count ASC\nLIMIT 1;",
            "SELECT T1.Claim_ID, T1.Date_Claim_Made, COUNT(*) AS settlement_count\nFROM Claims T1\nJOIN Settlements T2 ON T1.Claim_ID = T2.Claim_ID\nGROUP BY T1.Claim_ID\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "1470": {
        "db_id": "college_2",
        "question": "Find the names of all instructors in the Art department who have taught some course and the course_id.",
        "ground_truth": "SELECT name ,  course_id FROM instructor AS T1 JOIN teaches AS T2 ON T1.ID  =  T2.ID WHERE T1.dept_name  =  'Art'",
        "amends": [
            "Do select `name` and `course_id` instead of `instructor_name` and `course_id`. Do use `FROM instructor AS T1 JOIN teaches AS T2` instead of `FROM instructors` with a single table. Do add the join condition `ON T1.ID = T2.ID` instead of omitting any join. Do filter on `T1.dept_name = 'Art'` instead of `department = 'Art'`. Do remove the `taught_course IS NOT NULL` filter instead of keeping it. The amended query now correctly joins instructor and teaches tables to retrieve art department instructors and their courses."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT instructor_name, course_id FROM instructors WHERE department = 'Art' AND taught_course IS NOT NULL",
            "SELECT T1.name, T2.course_id FROM instructor AS T1 JOIN teaches AS T2 ON T1.ID = T2.ID WHERE T1.dept_name = 'Art'"
        ],
        "rule_sql": []
    },
    "5228": {
        "db_id": "music_2",
        "question": "How many songs have a lead vocal?",
        "ground_truth": "SELECT count(DISTINCT title) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE TYPE  =  \"lead\"",
        "amends": [
            "Do `count(DISTINCT title)` instead of `COUNT(*)` to count unique song titles rather than all rows. Do add `vocals AS T1 JOIN songs AS T2 ON T1.songid = T2.songid` instead of querying only the `songs` table to incorporate vocalist information through a join. Do change the filter to `TYPE = \"lead\"` instead of `lead_vocal = 'yes'` to use the correct column name and value format from the joined vocals table. The amended query now correctly counts distinct song titles with lead vocalists, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM songs WHERE lead_vocal = 'yes';",
            "SELECT COUNT(DISTINCT T2.Title) \nFROM Vocals AS T1 \nJOIN Songs AS T2 ON T1.SongId = T2.SongId \nWHERE T1.Type = 'lead'"
        ],
        "rule_sql": []
    },
    "2605": {
        "db_id": "inn_1",
        "question": "What are the first and last names of people who payed more than the rooms' base prices?",
        "ground_truth": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  0",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do select `T1.firstname` and `T1.lastname` instead of `first_name` and `last_name`. Do join `Reservations AS T1` with `Rooms AS T2` instead of querying from a single `people` table. Do use join condition `ON T1.Room = T2.RoomId` instead of subquery correlation `rooms.room_id = people.room_id`. Do filter with `T1.Rate - T2.basePrice > 0` instead of `payment_amount > (SELECT base_price...)`. Do remove the subquery entirely instead of keeping it. The amended query now correctly joins reservation and room data to compare rates against base prices."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM people WHERE payment_amount > (SELECT base_price FROM rooms WHERE rooms.room_id = people.room_id);",
            "SELECT T1.FirstName, T1.LastName \nFROM Reservations AS T1 \nJOIN Rooms AS T2 ON T1.Room = T2.RoomId \nWHERE T1.Rate - T2.basePrice > 0"
        ],
        "rule_sql": []
    },
    "3886": {
        "db_id": "insurance_policies",
        "question": "Which kind of policy type was chosen by the most customers?",
        "ground_truth": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference `Policy_Type_Code` from the `Customer_Policies` table instead of `policy_type` from the `customers` table. Do use `count(*)` directly in the ORDER BY clause instead of aliasing it as `customer_count` in the SELECT list. Do remove the explicit column alias `customer_count` from the SELECT list instead of including it. The amended query now correctly aggregates policy types from the appropriate table and orders by the count directly without unnecessary column aliasing, matching the intended behavior.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, as only the `Policy_Type_Code` column is needed to identify the most frequent policy type. Do keep the `GROUP BY Policy_Type_Code` clause to aggregate by policy type. Do maintain the `ORDER BY count(*) DESC` to sort by descending count of policies. Do preserve the `LIMIT 1` to return only the top result. The amended query now correctly returns only the policy type code with the highest count instead of returning both the code and the count value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT policy_type, COUNT(*) as customer_count FROM customers GROUP BY policy_type ORDER BY customer_count DESC LIMIT 1;",
            "SELECT Policy_Type_Code, COUNT(*) FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5374": {
        "db_id": "tracking_software_problems",
        "question": "What are the ids of the problems which are reported before 1978-06-26?",
        "ground_truth": "SELECT problem_id FROM problems WHERE date_problem_reported < \"1978-06-26\"",
        "amends": [
            "Do select `problem_id` instead of `id` for the column name. Do use `date_problem_reported` instead of `reported_date` for the date column. Do apply the `<` operator for dates before June 26, 1978 instead of the `>` operator. The amended query now correctly filters for problems reported before the specified date rather than after it, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM problems WHERE reported_date > '1978-06-26';",
            "SELECT problem_id FROM Problems WHERE date_problem_reported < '1978-06-26';"
        ],
        "rule_sql": []
    },
    "5656": {
        "db_id": "customers_and_products_contacts",
        "question": "Show names and phones of customers who do not have address information.",
        "ground_truth": "SELECT customer_name ,  customer_phone FROM customers WHERE customer_id NOT IN (SELECT customer_id FROM customer_address_history)",
        "amends": [
            "Do select `customer_name` and `customer_phone` instead of `name` and `phone`. Do use a subquery filter with `customer_id NOT IN` instead of checking `address IS NOT NULL`. The amended query now correctly identifies customers without address history rather than those with non-null addresses, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, phone FROM customers WHERE address IS NOT NULL;",
            "SELECT customer_name, customer_phone \nFROM Customers \nWHERE customer_id NOT IN (\n    SELECT customer_id \n    FROM Customer_Address_History\n)"
        ],
        "rule_sql": []
    },
    "4466": {
        "db_id": "network_2",
        "question": "Who has friends that are older than the average age? Print their friends and their ages as well",
        "ground_truth": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)",
        "amends": [
            "Do use `SELECT DISTINCT T2.name, T2.friend, T1.age` instead of `SELECT f.name, f.age` to include additional columns and ensure uniqueness. Do join `Person AS T1` and `PersonFriend AS T2` with `ON T1.name = T2.friend` instead of querying only the `friends` table. Do filter with `WHERE T1.age > (SELECT avg(age) FROM person)` instead of `WHERE f.age > (SELECT AVG(age) FROM friends)` to reference the correct table in the subquery. Do remove `ORDER BY f.age DESC` instead of keeping it as the ordering is no longer needed. The amended query now correctly retrieves distinct friend relationships with age comparison against the person table average."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT f.name, f.age \nFROM friends f \nWHERE f.age > (SELECT AVG(age) FROM friends) \nORDER BY f.age DESC;",
            "SELECT DISTINCT T2.name, T2.friend, T1.age\nFROM Person AS T1\nJOIN PersonFriend AS T2 ON T1.name = T2.friend\nWHERE T1.age > (SELECT AVG(age) FROM Person)"
        ],
        "rule_sql": []
    },
    "304": {
        "db_id": "product_catalog",
        "question": "What are the attribute data types with more than 3 attribute definitions?",
        "ground_truth": "SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING count(*)  >  3",
        "amends": [
            "Do reference `attribute_data_type` instead of `data_type` and use `Attribute_Definitions` instead of `attributes` as the table source. Do move the count filter to `HAVING count(*) > 3` instead of incorrectly placing it in the `WHERE` clause where aggregate functions cannot be used. Do remove the alias `attribute_count` from the SELECT list instead of keeping it since the RIGHT_SQL only selects the grouped column without the count. The amended query now correctly filters groups with more than 3 records using HAVING instead of the invalid WHERE clause with aggregate conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT data_type, COUNT(*) as attribute_count \nFROM attributes \nWHERE attribute_count > 3 \nGROUP BY data_type",
            "SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING COUNT(*) > 3"
        ],
        "rule_sql": []
    },
    "65": {
        "db_id": "student_assessment",
        "question": "What are the ids of all students who have attended at least one course?",
        "ground_truth": "SELECT student_id FROM student_course_attendance",
        "amends": [
            "Do query from the `student_course_attendance` table instead of the `students` table. Do remove the `WHERE course_count > 0` filter instead of keeping it. The amended query now correctly retrieves student IDs from the attendance tracking table rather than filtering based on a course count field in a different table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_id FROM students WHERE course_count > 0;",
            "SELECT DISTINCT student_id FROM Student_Course_Attendance"
        ],
        "rule_sql": []
    },
    "1445": {
        "db_id": "college_2",
        "question": "What are the names of instructors who didn't teach courses in the Spring?",
        "ground_truth": "SELECT name FROM instructor WHERE id NOT IN (SELECT id FROM teaches WHERE semester  =  'Spring')",
        "amends": [
            "Do reference table `instructor` instead of `instructors` and column `id` instead of `instructor_id` in the main query. Do reference table `teaches` instead of `courses` and column `id` instead of `instructor_id` in the subquery. Do keep the filter `semester = 'Spring'` unchanged in the subquery. The amended query now correctly matches the RIGHT_SQL's behavior by using the appropriate table and column names from the schema."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM instructors WHERE instructor_id NOT IN (SELECT instructor_id FROM courses WHERE semester = 'Spring');",
            "SELECT name FROM instructor WHERE id NOT IN (SELECT id FROM teaches WHERE semester = 'Spring')"
        ],
        "rule_sql": []
    },
    "3160": {
        "db_id": "station_weather",
        "question": "How many trains have 'Express' in their names?",
        "ground_truth": "SELECT count(*) FROM train WHERE name LIKE \"%Express%\"",
        "amends": [
            "Do reference table `train` instead of `trains` to correctly match the database schema. Do use double quotes `\"%Express%\"` instead of single quotes `'%Express%'` for the LIKE pattern to maintain consistency with the query's string literal formatting. The amended query now correctly counts records from the train table containing 'Express' in the name, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM trains WHERE name LIKE '%Express%';",
            "SELECT COUNT(*) FROM \"train\" WHERE \"name\" LIKE \"%Express%\""
        ],
        "rule_sql": []
    },
    "4628": {
        "db_id": "customers_campaigns_ecommerce",
        "question": "Show the names of customers who have at least 2 mailshots with outcome code 'Order'.",
        "ground_truth": "SELECT T2.customer_name FROM mailshot_customers AS T1 JOIN customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE outcome_code  =  'Order' GROUP BY T1.customer_id HAVING count(*)  >=  2",
        "amends": [
            "Do add `mailshot_customers AS T1` joined to `customers AS T2` on `T1.customer_id = T2.customer_id` instead of querying only the `customers` table. Do change the SELECT list to `T2.customer_name` instead of `customer_name` to specify the table alias. Do move the count condition to `HAVING count(*) >= 2` instead of using `mailshot_count >= 2` in the WHERE clause. Do add `GROUP BY T1.customer_id` instead of omitting grouping. Do keep the `outcome_code = 'Order'` filter in the WHERE clause instead of removing it. The amended query now correctly counts mailshot occurrences per customer and filters for those with at least two orders, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name FROM customers WHERE mailshot_count >= 2 AND outcome_code = 'Order';",
            "SELECT T2.customer_name\nFROM mailshot_customers AS T1\nJOIN customers AS T2 ON T1.customer_id = T2.customer_id\nWHERE T1.outcome_code = 'Order'\nGROUP BY T1.customer_id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "3520": {
        "db_id": "hr_1",
        "question": "What are the full names and cities of employees who have the letter Z in their first names?",
        "ground_truth": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'",
        "amends": [
            "Do add table aliases `T1`, `T2`, and `T3` instead of using unqualified column names. Do join `departments AS T2` on `T1.department_id = T2.department_id` instead of omitting this table entirely. Do join `locations AS T3` on `T2.location_id = T3.location_id` instead of omitting this table and its relationship. Do reference `T3.city` instead of just `city` to specify the source table. Do use case-insensitive `LIKE '%z%'` instead of case-sensitive `LIKE '%Z%'` for broader matching. The amended query now correctly joins through the department-location hierarchy to retrieve the city from the appropriate table and uses proper case-insensitive pattern matching.",
            "Do select individual columns `first_name`, `last_name`, and `city` instead of concatenating them into a single `full_name` alias. Do maintain the same `JOIN` conditions on `department_id` and `location_id` without changes. Do preserve the `WHERE` filter on `first_name LIKE '%z%'` exactly as in the original query. The amended query now matches RIGHT_SQL's behavior by returning separate columns rather than a concatenated result."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, city FROM employees WHERE first_name LIKE '%Z%';",
            "SELECT T1.FIRST_NAME || ' ' || T1.LAST_NAME AS full_name, T3.CITY\nFROM employees AS T1\nJOIN departments AS T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID\nJOIN locations AS T3 ON T2.LOCATION_ID = T3.LOCATION_ID\nWHERE T1.FIRST_NAME LIKE '%z%'",
            "SELECT T1.first_name, T1.last_name, T3.city\nFROM employees AS T1\nJOIN departments AS T2 ON T1.department_id = T2.department_id\nJOIN locations AS T3 ON T2.location_id = T3.location_id\nWHERE T1.first_name LIKE '%z%'"
        ],
        "rule_sql": []
    },
    "6495": {
        "db_id": "scientist_1",
        "question": "Find the number of scientists involved for each project name.",
        "ground_truth": "SELECT count(*) ,  T1.name FROM projects AS T1 JOIN assignedto AS T2 ON T1.code  =  T2.project GROUP BY T1.name",
        "amends": [
            "Do select `count(*)` and `T1.name` instead of `project_name` and `COUNT(*)`. Do join `projects AS T1` and `assignedto AS T2` with `ON T1.code = T2.project` instead of querying only the `scientists` table. Do group by `T1.name` instead of `project_name`. The amended query now correctly counts assignments per project by joining the projects and assignedto tables instead of incorrectly counting scientists directly, matching the RIGHT_SQL's behavior.",
            "Do include `T1.name` in the SELECT list instead of omitting it, and do place the `count(*)` aggregate first instead of second in the column order. Do use lowercase `name` instead of uppercase `Name` for the column reference, and do use lowercase `code` and `project` instead of uppercase `Code` and `Project` in the join condition. The amended query now correctly returns both the project name and count of assignments while maintaining proper grouping semantics."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT project_name, COUNT(*) FROM scientists GROUP BY project_name;",
            "SELECT T1.Name, COUNT(*) FROM Projects AS T1 JOIN AssignedTo AS T2 ON T1.Code = T2.Project GROUP BY T1.Name",
            "SELECT count(*), T1.name FROM projects AS T1 JOIN assignedto AS T2 ON T1.code = T2.project GROUP BY T1.name"
        ],
        "rule_sql": []
    },
    "1819": {
        "db_id": "small_bank_1",
        "question": "What are the names, checking balances, and savings balances of customers, ordered by the total of checking and savings balances descending?",
        "ground_truth": "SELECT T2.balance ,  T3.balance ,  T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid ORDER BY T2.balance + T3.balance DESC",
        "amends": [
            "Do select `T2.balance` and `T3.balance` as separate columns instead of combining them into `checking_balance` and `savings_balance`. Do join from `accounts AS T1` instead of querying `customers` directly. Do add `JOIN checking AS T2 ON T1.custid = T2.custid` instead of omitting the checking table join. Do add `JOIN savings AS T3 ON T1.custid = T3.custid` instead of omitting the savings table join. Do order by `T2.balance + T3.balance DESC` instead of ordering by `checking_balance DESC` alone. The amended query now correctly aggregates and sorts by the total balance across both account types, matching the RIGHT_SQL's behavior.",
            "Do reorder the SELECT list to `T2.balance, T3.balance, T1.name` instead of `T1.name, T2.balance, T3.balance` while keeping the same column selection. The FROM clause with `JOIN checking` and `JOIN savings` on `T1.custid = T2.custid` and `T1.custid = T3.custid` remains unchanged, as do the ORDER BY clause using `T2.balance + T3.balance DESC` and all table aliases. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, checking_balance, savings_balance FROM customers ORDER BY checking_balance DESC;",
            "SELECT T1.name, T2.balance, T3.balance\nFROM ACCOUNTS AS T1\nJOIN CHECKING AS T2 ON T1.custid = T2.custid\nJOIN SAVINGS AS T3 ON T1.custid = T3.custid\nORDER BY T2.balance + T3.balance DESC",
            "SELECT T2.balance, T3.balance, T1.name\nFROM accounts AS T1\nJOIN checking AS T2 ON T1.custid = T2.custid\nJOIN savings AS T3 ON T1.custid = T3.custid\nORDER BY T2.balance + T3.balance DESC"
        ],
        "rule_sql": []
    },
    "5176": {
        "db_id": "music_2",
        "question": "Find all the albums in 2012.",
        "ground_truth": "SELECT * FROM Albums WHERE YEAR  =  2012",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM albums WHERE year = 2011;"
        ],
        "rule_sql": []
    },
    "4947": {
        "db_id": "soccer_2",
        "question": "How many students, on average, does each college have enrolled?",
        "ground_truth": "SELECT avg(enr) FROM College",
        "amends": [
            "Do use the correct table name `College` instead of `colleges` and the correct column name `enr` instead of `student_count` while maintaining the same aggregate function `avg`. The amended query now correctly references the proper table and column names to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(student_count) FROM colleges;",
            "SELECT AVG(enr) AS average_enrollment FROM College;"
        ],
        "rule_sql": []
    },
    "4373": {
        "db_id": "tracking_grants_for_research",
        "question": "What are the details of all organizations that are described as Sponsors and sort the results in ascending order?",
        "ground_truth": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  'Sponsor' ORDER BY organisation_details",
        "amends": [
            "Do select `organisation_details` instead of `*` and do use explicit table aliases `T1` and `T2` instead of no aliases. Do join `Organisations` with `organisation_Types` on `T1.organisation_type = T2.organisation_type` instead of querying only `organizations` table. Do filter on `T2.organisation_type_description = 'Sponsor'` instead of `description = 'Sponsor'` and do order by `organisation_details` instead of `name DESC`. The amended query now correctly joins related tables to filter by organization type description rather than assuming the description exists directly in the organizations table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM organizations WHERE description = 'Sponsor' ORDER BY name DESC;",
            "SELECT T1.organisation_details \nFROM Organisations T1\nJOIN Organisation_Types T2 ON T1.organisation_type = T2.organisation_type\nWHERE T2.organisation_type_description = 'Sponsor'\nORDER BY T1.organisation_details ASC;"
        ],
        "rule_sql": []
    },
    "4468": {
        "db_id": "network_2",
        "question": "Who is the friend of Zach with longest year relationship?",
        "ground_truth": "SELECT friend FROM PersonFriend WHERE name =  'Zach' AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  'Zach')",
        "amends": [
            "Do select `friend` instead of `friend_name` and use table `PersonFriend` instead of `friends`. Do add filter `AND YEAR = (SELECT max(YEAR) FROM PersonFriend WHERE name = 'Zach')` instead of using `ORDER BY relationship_year DESC LIMIT 1`. Do remove the `ORDER BY` and `LIMIT` clauses entirely instead of keeping them. The amended query now correctly finds the most recent friend by using a subquery to get the maximum year rather than relying on ordering and limiting, ensuring it matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT friend_name FROM friends WHERE name = 'Zach' ORDER BY relationship_year DESC LIMIT 1;",
            "SELECT friend FROM PersonFriend WHERE name = 'Zach' AND year = (SELECT MAX(year) FROM PersonFriend WHERE name = 'Zach')"
        ],
        "rule_sql": []
    },
    "4107": {
        "db_id": "company_employee",
        "question": "Show names of companies and that of employees in descending order of number of years working for that employee.",
        "ground_truth": "SELECT T3.Name ,  T2.Name FROM employment AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID JOIN company AS T3 ON T1.Company_ID  =  T3.Company_ID ORDER BY T1.Year_working",
        "amends": [
            "Do reference `T3.Name` and `T2.Name` instead of `company.name` and `employee.name`. Do use `employment AS T1` as the primary table instead of directly joining `company` and `employee`. Do join `people AS T2` on `T1.People_ID = T2.People_ID` instead of joining `employee` on `company.id = employee.company_id`. Do add a second join to `company AS T3` on `T1.Company_ID = T3.Company_ID` instead of having company as the first table. Do order by `T1.Year_working` instead of `employee.years_worked`. The amended query now correctly uses the employment bridge table to connect people and companies while preserving the intended result ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT company.name, employee.name FROM company JOIN employee ON company.id = employee.company_id ORDER BY employee.years_worked ASC;",
            "SELECT T3.Name AS Company_Name, T2.Name AS Employee_Name\nFROM employment AS T1\nJOIN people AS T2 ON T1.People_ID = T2.People_ID\nJOIN company AS T3 ON T1.Company_ID = T3.Company_ID\nORDER BY T1.Year_working DESC;"
        ],
        "rule_sql": []
    }
}