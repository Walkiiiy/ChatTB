{
  "test_config": {
    "base_model": "/home/ubuntu/walkiiiy/ChatTB/Process_model/models--Qwen3-8B",
    "adapter_path": "/home/ubuntu/walkiiiy/ChatTB/Process_model/models--globalAssumer_Qwen3_8b_Spider-Bird",
    "dataset": "/home/ubuntu/walkiiiy/ChatTB/Bird_dev/rules_res_type.json",
    "num_samples": 100,
    "deepseek_model": "deepseek-coder",
    "generation_params": {
      "max_new_tokens": 256,
      "temperature": 0.1,
      "do_sample": true
    }
  },
  "statistics": {
    "total_questions": 100,
    "with_sft_rules": {
      "correct_answers": 33,
      "failed_executions": 0,
      "accuracy": 0.33
    },
    "with_dataset_rules": {
      "correct_answers": 55,
      "failed_executions": 0,
      "accuracy": 0.55
    },
    "without_rules": {
      "correct_answers": 33,
      "failed_executions": 0,
      "accuracy": 0.33
    },
    "improvements": {
      "sft_vs_no_rules": {
        "absolute": 0.0,
        "relative": 0.0,
        "description": "SFT rules provide +0.000 (+0.0%) accuracy improvement over baseline"
      },
      "dataset_vs_no_rules": {
        "absolute": 0.22000000000000003,
        "relative": 22.000000000000004,
        "description": "Dataset rules provide +0.220 (+22.0%) accuracy improvement over baseline"
      },
      "sft_vs_dataset": {
        "absolute": -0.22000000000000003,
        "relative": -22.000000000000004,
        "description": "SFT rules provide -0.220 (-22.0%) accuracy improvement over dataset rules"
      }
    }
  },
  "results": [
    {
      "sample_idx": 0,
      "question": "How many of the molecules are carcinogenic?",
      "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.label = '+'",
      "db_id": "toxicology",
      "generated_rules": "Rule 1:\nCondition: When the question asks about carcinogenic molecules\nOperation: join the molecule table (T1) with the carcinogen table (T2) using T1.molecule_id = T2.molecule_id to identify carcinogenic molecules.",
      "dataset_rules": "Condition: When referencing the molecule table\nOperation: use alias T instead of the bare table name.\n\nCondition: When referencing the molecule table\nOperation: use alias T instead of the bare table name for clarity.",
      "sql_with_sft_rules": "SELECT COUNT(*) FROM molecule JOIN carcinogen ON molecule.molecule_id = carcinogen.molecule_id;",
      "sql_without_rules": "SELECT COUNT(*) FROM molecule WHERE label = 'carcinogenic';",
      "sql_with_dataset_rules": "SELECT COUNT(*) FROM molecule AS T WHERE T.label = 'carcinogenic';",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 1,
      "question": "How many card border with black color ? List out the card id.",
      "ground_truth": "SELECT id FROM cards WHERE borderColor = 'black' GROUP BY id",
      "db_id": "card_games",
      "generated_rules": "Rule 1:\nCondition: When the question asks for card border color\nOperation: use the exact column \"borderColor\" from the \"cards\" table instead of \"color\" from \"cards\" table.",
      "dataset_rules": "Condition: When the question asks for card border with black color\nOperation: use the exact literal value 'black' for the borderColor filter condition.",
      "sql_with_sft_rules": "SELECT id FROM cards WHERE borderColor = 'black';",
      "sql_without_rules": "SELECT id FROM cards WHERE borderColor = 'black';",
      "sql_with_dataset_rules": "SELECT id FROM cards WHERE borderColor = 'black';",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 2,
      "question": "When was the last f1 season whereby Brands Hatch hosted the British Grand Prix?",
      "ground_truth": "SELECT T2.date FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Brands Hatch' AND T2.name = 'British Grand Prix' ORDER BY T2.year DESC LIMIT 1",
      "db_id": "formula_1",
      "generated_rules": "Rule 1:\nCondition: When the question asks about a specific race at a specific circuit\nOperation: join the circuits table (T1) with the races table (T2) using T1.circuitId = T2.circuitId to link circuit information to race data.",
      "dataset_rules": "Condition: When answering about \"last f1 season with British Grand Prix at Brands Hatch\"\nOperation: make sure the output order: T2.date\n\nCondition: When the question mentions \"Brands Hatch\"\nOperation: \"Brands Hatch\" actually means T1.name = 'Brands Hatch' in schema.\n\nCondition: When the question mentions \"British Grand Prix\"\nOperation: \"British Grand Prix\" actually means T2.name = 'British Grand Prix' in schema.",
      "sql_with_sft_rules": "SELECT MAX(r.year) FROM races r JOIN circuits c ON r.circuitId = c.circuitId WHERE c.name = 'Brands Hatch' AND r.name LIKE '%British Grand Prix%';",
      "sql_without_rules": "SELECT MAX(r.year) FROM races r JOIN circuits c ON r.circuitId = c.circuitId WHERE c.name = 'Brands Hatch' AND r.name LIKE '%British Grand Prix%';",
      "sql_with_dataset_rules": "SELECT T2.date FROM circuits T1 JOIN races T2 ON T1.circuitId = T2.circuitId WHERE T1.name = 'Brands Hatch' AND T2.name = 'British Grand Prix' ORDER BY T2.date DESC LIMIT 1;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 3,
      "question": "Among all the atoms from 21 to 25, list all the molecules that are carcinogenic.",
      "ground_truth": "SELECT DISTINCT T2.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE SUBSTR(T1.atom_id, -2) BETWEEN '21' AND '25' AND T2.label = '+'",
      "db_id": "toxicology",
      "generated_rules": "Rule 1:\nCondition: When the question asks about molecules containing atoms from 21 to 25\nOperation: use the \"connected\" table as T1 and join with \"atom\" as T2 on T1.atom_id = T2.atom_id to find atoms with atomic numbers in that range.",
      "dataset_rules": "Condition: When the question mentions \"carcinogenic\"\nOperation: \"carcinogenic\" actually means \"T2.label = '+'\" in schema.\n\nCondition: When answering about molecules containing atoms from 21 to 25\nOperation: make sure the output order: T2.molecule_id\n\nCondition: When the question mentions \"atoms from 21 to 25\"\nOperation: extract the numeric part from T1.atom_id using SUBSTR(T1.atom_id, -2) and check if it is between '21' and '25'\n\nCondition: When the question mentions \"carcinogenic\"\nOperation: use T2.label = '+' as the condition for carcinogenic molecules\n\nCondition: When the question mentions \"carcinogenic\"\nOperation: \"carcinogenic\" actually means \"molecule label = '+' in schema\".\n\nCondition: When the question mentions \"carcinogenic\"\nOperation: \"carcinogenic\" actually means \"T2.label = '+' in schema\"\n\nCondition: When the question mentions \"carcinogenic\"\nOperation: \"carcinogenic\" actually means \"label in schema\" with values like '+' and '-'.",
      "sql_with_sft_rules": "SELECT DISTINCT m.molecule_id FROM molecule m WHERE m.label = 'carcinogenic' AND m.molecule_id IN ( SELECT DISTINCT a.molecule_id FROM connected c JOIN atom a ON c.atom_id = a.atom_id WHERE CAST(a.element AS INTEGER) BETWEEN 21 AND 25 );",
      "sql_without_rules": "SELECT DISTINCT m.molecule_id FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id WHERE CAST(SUBSTR(a.atom_id, 5) AS INTEGER) BETWEEN 21 AND 25 AND m.label = 'carcinogenic';",
      "sql_with_dataset_rules": "SELECT DISTINCT T2.molecule_id FROM atom AS T1 JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE CAST(SUBSTR(T1.atom_id, -2) AS INTEGER) BETWEEN 21 AND 25 AND T2.label = '+';",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 4,
      "question": "To which artist does the card with the text \"Das perfekte Gegenmittel zu einer dichten Formation\" belong?",
      "ground_truth": "SELECT DISTINCT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.flavorText LIKE '%DAS perfekte Gegenmittel zu einer dichten Formation%'",
      "db_id": "card_games",
      "generated_rules": "Rule 1:\nCondition: When the question asks about artist for a card with specific text\nOperation: use the \"artist\" column from the \"cards\" table instead of \"author\" from \"books\" table.",
      "dataset_rules": "Condition: When the question asks about artist for a card with specific text\nOperation: use DISTINCT T1.artist to select unique artist values from the main table.",
      "sql_with_sft_rules": "SELECT artist FROM cards WHERE text LIKE '%Das perfekte Gegenmittel zu einer dichten Formation%';",
      "sql_without_rules": "SELECT c.artist FROM cards c JOIN foreign_data fd ON c.uuid = fd.uuid WHERE fd.text = 'Das perfekte Gegenmittel zu einer dichten Formation';",
      "sql_with_dataset_rules": "SELECT DISTINCT cards.artist FROM cards WHERE cards.text = \"Das perfekte Gegenmittel zu einer dichten Formation\";",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 5,
      "question": "How many matches were held in the league Germany 1. Bundesliga\nfrom August to October 2008?",
      "ground_truth": "SELECT COUNT(t2.id) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Germany 1. Bundesliga' AND SUBSTR(t2.`date`, 1, 7) BETWEEN '2008-08' AND '2008-10'",
      "db_id": "european_football_2",
      "generated_rules": "Rule 1:\nCondition: When the question asks about matches in a specific league\nOperation: join the Match table (T1) with the League table (T2) using T1.league_id = T2.id to properly identify the league.",
      "dataset_rules": "Condition: When answering about matches in a specific league\nOperation: use tables League as T1 and Match as T2 with an inner join on T1.id = T2.league_id.\n\nCondition: When answering about matches in a specific league\nOperation: join League AS t1 with Match AS t2 on t1.id = t2.league_id to properly relate league information to matches.\n\nCondition: When the question mentions \"Germany 1. Bundesliga\"\nOperation: filter on t1.name = 'Germany 1. Bundesliga' instead of directly filtering on a league column in the matches table.\n\nCondition: When answering about matches in a specific league\nOperation: join League AS t1 and Match AS t2 where t1.id = t2.league_id to link league information with match data.",
      "sql_with_sft_rules": "SELECT COUNT(*) FROM Match JOIN League ON Match.league_id = League.id WHERE League.name = 'Germany 1. Bundesliga' AND Match.date BETWEEN '2008-08-01' AND '2008-10-31';",
      "sql_without_rules": "SELECT COUNT(*) FROM Match JOIN League ON Match.league_id = League.id WHERE League.name = 'Germany 1. Bundesliga' AND Match.season = '2008/2009' AND Match.date BETWEEN '2008-08-01' AND '2008-10-31';",
      "sql_with_dataset_rules": "SELECT COUNT(*) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Germany 1. Bundesliga' AND t2.date BETWEEN '2008-08-01' AND '2008-10-31';",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 6,
      "question": "Among the posts owned by an elder user, how many of them have a score of over 19?",
      "ground_truth": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Score >= 20 AND T2.Age > 65",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks about \"posts owned by an elder user\"\nOperation: use \"OwnerUserId = 1\" instead of age-based filtering.",
      "dataset_rules": "Condition: When referencing columns from joined tables\nOperation: use qualified references like T2.language instead of unqualified column names.",
      "sql_with_sft_rules": "SELECT COUNT(*) FROM posts WHERE OwnerUserId = 1 AND Score > 19;",
      "sql_without_rules": "SELECT COUNT(*) FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE u.Age >= 65 AND p.Score > 19;",
      "sql_with_dataset_rules": "SELECT COUNT(*) FROM posts JOIN users ON posts.OwnerUserId = users.Id WHERE users.Age > 60 AND posts.Score > 19;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 7,
      "question": "Give the event ID, location, and status of events conducted from November 2019 to March 2020.",
      "ground_truth": "SELECT event_id, location, status FROM event WHERE date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-11-01' AND '2020-03-31'",
      "db_id": "student_club",
      "generated_rules": "Rule 1:\nCondition: When the question asks for events conducted from November 2019 to March 2020\nOperation: use date range filtering with event_date between '2019-11-01' and '2020-03-31' inclusive.",
      "dataset_rules": "Condition: When the question asks about events\nOperation: use table \"event\" instead of \"events\" as the data source.",
      "sql_with_sft_rules": "SELECT event_id, location, status FROM event WHERE event_date BETWEEN '2019-11-01' AND '2020-03-31';",
      "sql_without_rules": "SELECT event_id, location, status FROM event WHERE event_date BETWEEN '2019-11-01' AND '2020-03-31';",
      "sql_with_dataset_rules": "SELECT event_id, location, status FROM event WHERE event_date BETWEEN '2019-11-01' AND '2020-03-31';",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 8,
      "question": "User No.23853 gave a comment to a post at 9:08:18 on 2013/7/12, was that post well-finished?",
      "ground_truth": "SELECT IIF(T2.ClosedDate IS NULL, 'NOT well-finished', 'well-finished') AS resylt FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.UserId = 23853 AND T1.CreationDate = '2013-07-12 09:08:18.0'",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks about a user's comment on a post\nOperation: join the comments table (T1) with the posts table (T2) using T1.PostId = T2.Id to link comments to their corresponding posts.",
      "dataset_rules": "Condition: When answering about whether a post is well-finished\nOperation: use conditional logic to return 'well-finished' if T2.ClosedDate IS NULL, otherwise 'NOT well-finished' as the result.\n\nCondition: When the question mentions a user comment\nOperation: query the comments table as T1 instead of posts, and filter on T1.UserId = 23853 instead of user_id.\n\nCondition: When the question specifies a comment time\nOperation: use the exact timestamp literal '2013-07-12 09:08:18.0' for T1.CreationDate instead of '2013-07-12 09:08:18'.",
      "sql_with_sft_rules": "SELECT p.Id, p.AnswerCount, p.CommentCount, p.FavoriteCount, p.Score, p.ViewCount FROM comments c JOIN posts p ON c.PostId = p.Id WHERE c.UserId = 23853 AND c.CreationDate = '2013-07-12 09:08:18';",
      "sql_without_rules": "SELECT p.Id, p.ClosedDate, p.AcceptedAnswerId, p.AnswerCount FROM comments c JOIN posts p ON c.PostId = p.Id WHERE c.UserId = 23853 AND c.CreationDate = '2013-07-12 09:08:18';",
      "sql_with_dataset_rules": "SELECT CASE WHEN T2.ClosedDate IS NULL THEN 'well-finished' ELSE 'NOT well-finished' END AS result FROM comments T1 JOIN posts T2 ON T1.PostId = T2.Id WHERE T1.UserId = 23853 AND T1.CreationDate = '2013-07-12 09:08:18.0';",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 9,
      "question": "Identify the total number of posts with views above average.",
      "ground_truth": "SELECT Id FROM posts WHERE ViewCount > ( SELECT AVG(ViewCount) FROM posts )",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When referencing the posts table\nOperation: use the exact table name \"Post\" instead of \"posts\".\n\nRule 2:\nCondition: When referencing the posts table\nOperation: use table name \"Post\" instead of \"posts\" to match the correct schema.\n\nRule 3:\nCondition: When referencing the posts table\nOperation: use the exact table name \"Post\" instead of \"posts\".\n\nRule 4:\nCondition: When referencing the posts table\nOperation: use the exact table name \"Post\" instead of \"posts\".\n\nRule 5:\nCondition: When referencing the posts table\nOperation: use the exact table name \"Post\" instead of \"posts\".",
      "dataset_rules": "Condition: When the question asks for posts with views above average\nOperation: use \"ViewCount\" instead of \"views\" as the exact column name from the schema.",
      "sql_with_sft_rules": "SELECT COUNT(*) FROM Post WHERE ViewCount > (SELECT AVG(ViewCount) FROM Post);",
      "sql_without_rules": "SELECT COUNT(*) FROM posts WHERE ViewCount > (SELECT AVG(ViewCount) FROM posts WHERE ViewCount IS NOT NULL);",
      "sql_with_dataset_rules": "SELECT COUNT(*) FROM posts WHERE ViewCount > (SELECT AVG(ViewCount) FROM posts WHERE ViewCount IS NOT NULL);",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 10,
      "question": "What is the average number of posts voted by the oldest users?",
      "ground_truth": "SELECT AVG(PostId) FROM votes WHERE UserId IN ( SELECT Id FROM users WHERE Age = ( SELECT MAX(Age) FROM users ) )",
      "db_id": "codebase_community",
      "generated_rules": "No definitional rules found.",
      "dataset_rules": "Condition: When answering about \"average number of posts voted by the oldest users\"\nOperation: calculate the average of PostId from the votes table.",
      "sql_with_sft_rules": "SELECT AVG(post_count) AS average_posts_voted FROM ( SELECT u.Id, COUNT(DISTINCT v.PostId) AS post_count FROM users u JOIN votes v ON u.Id = v.UserId WHERE u.Age = (SELECT MAX(Age) FROM users WHERE Age IS NOT NULL) GROUP BY u.Id ) user_post_counts;",
      "sql_without_rules": "SELECT AVG(post_count) AS avg_posts_voted FROM ( SELECT u.Id, COUNT(DISTINCT v.PostId) AS post_count FROM users u JOIN votes v ON u.Id = v.UserId WHERE u.Age = (SELECT MAX(Age) FROM users WHERE Age IS NOT NULL) GROUP BY u.Id );",
      "sql_with_dataset_rules": "SELECT AVG(PostId) FROM votes;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 11,
      "question": "Among all superheroes created by George Lucas, identify the percentage of female superheroes.",
      "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.gender = 'Female' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T2.publisher_name = 'George Lucas'",
      "db_id": "superhero",
      "generated_rules": "Rule 1:\nCondition: When answering about superheroes created by a specific publisher\nOperation: join superhero table as T1 with publisher table as T2 using T1.publisher_id = T2.id to establish the publisher relationship.",
      "dataset_rules": "Condition: When answering about superheroes created by George Lucas\nOperation: use table aliases T1 for superheroes, T2 for publisher, and T3 for gender.",
      "sql_with_sft_rules": "SELECT (COUNT(CASE WHEN T3.gender = 'Female' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_female FROM superhero AS T1 JOIN publisher AS T2 ON T1.publisher_id = T2.id JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T2.publisher_name = 'George Lucas';",
      "sql_without_rules": "SELECT (COUNT(CASE WHEN g.gender = 'Female' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_female FROM superhero s JOIN publisher p ON s.publisher_id = p.id JOIN gender g ON s.gender_id = g.id WHERE p.publisher_name = 'George Lucas';",
      "sql_with_dataset_rules": "SELECT (COUNT(CASE WHEN T3.gender = 'Female' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_female FROM superhero T1 JOIN publisher T2 ON T1.publisher_id = T2.id JOIN gender T3 ON T1.gender_id = T3.id WHERE T2.publisher_name = 'George Lucas';",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 12,
      "question": "Indicate the top source of funds received in September 2019 based on their amount.",
      "ground_truth": "SELECT source FROM income WHERE date_received BETWEEN '2019-09-01' and '2019-09-30' ORDER BY source DESC LIMIT 1",
      "db_id": "student_club",
      "generated_rules": "Rule 1:\nCondition: When answering about \"top source of funds received in September 2019\"\nOperation: make sure the output order: source, SUM(amount) as total_amount.\n\nRule 2:\nCondition: When the question mentions \"source\"\nOperation: \"source\" actually means \"source in income table\".\n\nRule 3:\nCondition: When the question mentions \"September 2019\"\nOperation: filter on date_received using LIKE '9/%/2019%' pattern.",
      "dataset_rules": "Condition: When answering about \"top source of funds received in September 2019\"\nOperation: make sure the output order: source.\n\nCondition: When the question mentions \"September 2019\"\nOperation: use date_received BETWEEN '2019-09-01' and '2019-09-30' filter.\n\nCondition: When the question asks for \"top source based on their amount\"\nOperation: order by source DESC and keep the first 1 row.",
      "sql_with_sft_rules": "SELECT source, SUM(amount) as total_amount FROM income WHERE date_received LIKE '9/%/2019%' GROUP BY source ORDER BY total_amount DESC LIMIT 1;",
      "sql_without_rules": "SELECT source, SUM(amount) AS total_amount FROM income WHERE date_received LIKE '2019-09%' GROUP BY source ORDER BY total_amount DESC LIMIT 1;",
      "sql_with_dataset_rules": "SELECT source FROM income WHERE date_received BETWEEN '2019-09-01' AND '2019-09-30' ORDER BY amount DESC, source LIMIT 1;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 13,
      "question": "Among all the players whose weight is under 130, how many of them preferred foot in attacking is left?",
      "ground_truth": "SELECT COUNT(DISTINCT t1.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.weight < 130 AND t2.preferred_foot = 'left'",
      "db_id": "european_football_2",
      "generated_rules": "Rule 1:\nCondition: When the question asks about players with weight under 130\nOperation: use \"weight < 130\" as the filter condition.\n\nRule 2:\nCondition: When the question asks about players who prefer left foot\nOperation: use \"preferred_foot = 'Left'\" as the filter condition.",
      "dataset_rules": "Condition: When the question involves both player attributes and player information\nOperation: join Player table as T1 with Player_Attributes table as T2 using INNER JOIN ON t1.player_api_id = t2.player_api_id.\n\nCondition: When filtering by preferred foot\nOperation: apply the condition t2.preferred_foot = 'left' to the Player_Attributes table (T2).",
      "sql_with_sft_rules": "SELECT COUNT(DISTINCT p.id) FROM Player p JOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id WHERE p.weight < 130 AND pa.preferred_foot = 'Left';",
      "sql_without_rules": "SELECT COUNT(DISTINCT p.id) FROM Player p JOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id WHERE p.weight < 130 AND pa.preferred_foot = 'left';",
      "sql_with_dataset_rules": "SELECT COUNT(*) FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.weight < 130 AND T2.preferred_foot = 'left';",
      "result_with_sft_rules": 0,
      "result_without_rules": 1,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 14,
      "question": "Which racetrack hosted the most recent race? Indicate the full location.",
      "ground_truth": "SELECT T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId ORDER BY T2.date DESC LIMIT 1",
      "db_id": "formula_1",
      "generated_rules": "Rule 1:\nCondition: When the question asks about \"racetrack\" and \"location\"\nOperation: use \"T2.name\" for the racetrack name and \"T2.location\" for the location details.",
      "dataset_rules": "Condition: When answering about \"most recent race\"\nOperation: order results by T2.date in descending order and keep only the first row.\n\nCondition: When the question mentions \"racetrack\" and \"location\"\nOperation: use T1.location from the circuits table (aliased as T1) to represent the full location.",
      "sql_with_sft_rules": "SELECT T2.location FROM races T1 JOIN circuits T2 ON T1.circuitId = T2.circuitId ORDER BY T1.date DESC LIMIT 1;",
      "sql_without_rules": "SELECT c.location FROM races r JOIN circuits c ON r.circuitId = c.circuitId ORDER BY r.date DESC LIMIT 1;",
      "sql_with_dataset_rules": "SELECT T1.location FROM circuits T1 JOIN races T2 ON T1.circuitId = T2.circuitId ORDER BY T2.date DESC LIMIT 1;",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 15,
      "question": "How many customers in KAM had a consumption of less than 30,000 for the year 2012?",
      "ground_truth": "SELECT COUNT(*) FROM ( SELECT T2.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'KAM' AND SUBSTRING(T2.Date, 1, 4) = '2012' GROUP BY T2.CustomerID HAVING SUM(T2.Consumption) < 30000 ) AS t1",
      "db_id": "debit_card_specializing",
      "generated_rules": "Rule 1:\nCondition: When the question asks about customers\nOperation: use the exact table name \"customer\" instead of \"customers\".\n\nRule 2:\nCondition: When the question asks about customers in a specific segment\nOperation: use the exact literal 'KAM' for the Segment column comparison.\n\nRule 3:\nCondition: When the question asks about consumption values\nOperation: use the exact column name \"Consumption\" from the yearmonth table.\n\nRule 4:\nCondition: When the question asks about customers\nOperation: use table \"customer\" instead of \"customers\" as the data source.",
      "dataset_rules": "Condition: When the question mentions \"customers in KAM\"\nOperation: use \"T1.Segment = 'KAM'\" for filtering instead of region-based filtering.",
      "sql_with_sft_rules": "SELECT COUNT(DISTINCT CustomerID) FROM customer WHERE Segment = 'KAM' AND CustomerID IN ( SELECT CustomerID FROM yearmonth WHERE strftime('%Y', Date) = '2012' GROUP BY CustomerID HAVING SUM(Consumption) < 30000 );",
      "sql_without_rules": "SELECT COUNT(DISTINCT y.CustomerID) FROM yearmonth y JOIN customers c ON y.CustomerID = c.CustomerID WHERE c.Segment = 'KAM' AND y.Date LIKE '2012%' AND y.Consumption < 30000;",
      "sql_with_dataset_rules": "SELECT COUNT(DISTINCT T1.CustomerID) FROM customers T1 JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'KAM' AND T2.Date LIKE '2012%' AND T2.Consumption < 30000;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 16,
      "question": "Find the average weight of the heroes who are aliens.",
      "ground_truth": "SELECT CAST(SUM(T1.weight_kg) AS REAL) / COUNT(T1.id) FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Alien'",
      "db_id": "superhero",
      "generated_rules": "Rule 1:\nCondition: When answering about \"average weight of heroes who are aliens\"\nOperation: make sure the output order: AVG(weight_kg).\n\nRule 2:\nCondition: When the question mentions \"aliens\"\nOperation: \"aliens\" actually means \"race = 'Alien' in schema\" using exact literal 'Alien'.",
      "dataset_rules": "No definitional rules found.",
      "sql_with_sft_rules": "SELECT AVG(weight_kg) FROM superhero WHERE race_id = (SELECT id FROM race WHERE race = 'Alien');",
      "sql_without_rules": "SELECT AVG(s.weight_kg) FROM superhero s JOIN race r ON s.race_id = r.id WHERE r.race = 'Alien';",
      "sql_with_dataset_rules": "SELECT AVG(weight_kg) FROM superhero WHERE race_id = (SELECT id FROM race WHERE race = 'Alien');",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 17,
      "question": "Among products comments with 0 score, what is the total number of users ages 40 years old?",
      "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Score = 0 AND T2.Age = 40",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks about \"products comments with 0 score\"\nOperation: use table \"comments\" instead of \"posts\" and filter on \"Score = 0\" instead of \"score = 0\".",
      "dataset_rules": "No definitional rules found.",
      "sql_with_sft_rules": "SELECT COUNT(DISTINCT u.Id) FROM comments c JOIN users u ON c.UserId = u.Id WHERE c.Score = 0 AND u.Age = 40;",
      "sql_without_rules": "SELECT COUNT(DISTINCT u.Id) FROM comments c JOIN users u ON c.UserId = u.Id WHERE c.Score = 0 AND u.Age = 40;",
      "sql_with_dataset_rules": "SELECT COUNT(DISTINCT u.Id) FROM users u JOIN comments c ON u.Id = c.UserId WHERE c.Score = 0 AND u.Age = 40;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 18,
      "question": "What are the name of badge that users who have the highest reputation obtained?",
      "ground_truth": "SELECT T2.name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId ORDER BY T1.Reputation DESC LIMIT 1",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks for badge names\nOperation: use \"T1.Name\" from the \"badges\" table instead of \"badge_name\" from \"badges\".\n\nRule 2:\nCondition: When the question asks for badge names\nOperation: select \"T2\".\"name\" from the \"badges\" table instead of \"badge_name\" from \"badges\".\n\nRule 3:\nCondition: When the question asks for badge names\nOperation: select \"T2\".\"name\" from the \"badges\" table instead of \"badge_name\" from the \"users\" table.",
      "dataset_rules": "Condition: When the question asks for the highest reputation user's badge\nOperation: rank users by T1.Reputation in descending order and keep the first 1 row.",
      "sql_with_sft_rules": "SELECT T2.Name FROM badges T2 WHERE T2.UserId IN ( SELECT Id FROM users WHERE Reputation = (SELECT MAX(Reputation) FROM users) );",
      "sql_without_rules": "SELECT DISTINCT b.Name FROM badges b JOIN users u ON b.UserId = u.Id WHERE u.Reputation = (SELECT MAX(Reputation) FROM users);",
      "sql_with_dataset_rules": "SELECT DISTINCT b.Name FROM badges b JOIN users u ON b.UserId = u.Id WHERE u.Id = ( SELECT Id FROM users ORDER BY Reputation DESC LIMIT 1 );",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 19,
      "question": "Lists all types of cards in German.",
      "ground_truth": "SELECT T1.subtypes, T1.supertypes FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'German' AND T1.subtypes IS NOT NULL AND T1.supertypes IS NOT NULL",
      "db_id": "card_games",
      "generated_rules": "Rule 1:\nCondition: When the question asks for \"types of cards\"\nOperation: use the exact column token \"type\" from the cards table.\n\nRule 2:\nCondition: When the question specifies \"in German\"\nOperation: filter on language = 'German' using the exact literal 'German'.",
      "dataset_rules": "Condition: When answering about \"types of cards in German\"\nOperation: make sure the output order: T1.subtypes, T1.supertypes.\n\nCondition: When the question mentions \"German\"\nOperation: \"German\" actually means T2.language = 'German' in schema.",
      "sql_with_sft_rules": "SELECT DISTINCT type FROM cards WHERE uuid IN (SELECT uuid FROM foreign_data WHERE language = 'German');",
      "sql_without_rules": "SELECT DISTINCT fd.type FROM foreign_data fd WHERE fd.language = 'German';",
      "sql_with_dataset_rules": "SELECT DISTINCT T1.subtypes, T1.supertypes FROM cards T1 JOIN foreign_data T2 ON T1.uuid = T2.uuid WHERE T2.language = 'German';",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 20,
      "question": "What are the bonds that have phosphorus and nitrogen as their atom elements?",
      "ground_truth": "SELECT T2.bond_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id IN ( SELECT T3.bond_id FROM connected AS T3 INNER JOIN atom AS T4 ON T3.atom_id = T4.atom_id WHERE T4.element = 'p' ) AND T1.element = 'n'",
      "db_id": "toxicology",
      "generated_rules": "Rule 1:\nCondition: When the question asks about bonds with specific atom elements\nOperation: use the \"connected\" table as T1 and join with \"atom\" table as T2 on T1.atom_id = T2.atom_id instead of querying the \"bonds\" table directly.",
      "dataset_rules": "Condition: When answering about bonds with phosphorus and nitrogen as atom elements\nOperation: make sure the output order: T2.bond_id",
      "sql_with_sft_rules": "SELECT DISTINCT b.bond_id FROM connected c1 JOIN atom a1 ON c1.atom_id = a1.atom_id JOIN connected c2 ON c1.bond_id = c2.bond_id JOIN atom a2 ON c2.atom_id = a2.atom_id JOIN bond b ON c1.bond_id = b.bond_id WHERE (a1.element = 'Phosphorus' AND a2.element = 'Nitrogen') OR (a1.element = 'Nitrogen' AND a2.element = 'Phosphorus');",
      "sql_without_rules": "SELECT DISTINCT b.bond_id FROM bond b JOIN connected c ON b.bond_id = c.bond_id JOIN atom a1 ON c.atom_id = a1.atom_id JOIN atom a2 ON c.atom_id2 = a2.atom_id WHERE (a1.element = 'Phosphorus' AND a2.element = 'Nitrogen') OR (a1.element = 'Nitrogen' AND a2.element = 'Phosphorus');",
      "sql_with_dataset_rules": "SELECT DISTINCT T2.bond_id FROM connected T1 JOIN atom a1 ON T1.atom_id = a1.atom_id JOIN atom a2 ON T1.atom_id2 = a2.atom_id JOIN bond T2 ON T1.bond_id = T2.bond_id WHERE (a1.element = 'Phosphorus' AND a2.element = 'Nitrogen') OR (a1.element = 'Nitrogen' AND a2.element = 'Phosphorus');",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 21,
      "question": "What percentage of bonds have the most common combination of atoms' elements?",
      "ground_truth": "SELECT CAST((SELECT COUNT(T1.atom_id) FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id GROUP BY T2.bond_type ORDER BY COUNT(T2.bond_id) DESC LIMIT 1 ) AS REAL) * 100 / ( SELECT COUNT(atom_id) FROM connected )",
      "db_id": "toxicology",
      "generated_rules": "Rule 1:\nCondition: When the question asks for percentage\nOperation: do not divide by 100.0 factor as the percentage calculation should return the decimal value directly.\n\nRule 2:\nCondition: When the question asks for percentage of bonds with the most common atom element combination\nOperation: first identify the most frequent element pair combination across all bonds.\n\nRule 3:\nCondition: When the question asks for percentage of bonds with the most common atom element combination\nOperation: first identify the most frequent element pair combination across all bonds.\n\nRule 4:\nCondition: When the question asks for percentage of bonds with the most common atom element combination\nOperation: first identify the most frequent element pair combination across all bonds.\n\nRule 5:\nCondition: When the question asks for percentage of bonds with the most common atom element combination\nOperation: first identify the most frequent element pair combination across all bonds.\n\nRule 6:\nCondition: When the question asks for percentage of bonds with the most common atom element combination\nOperation: first identify the most frequent element pair combination across all bonds.\n\nRule 7:\nCondition: When the question asks for percentage of bonds with the most common atom element combination\nOperation: first identify the most frequent element pair combination across all bonds.\n\nRule 8",
      "dataset_rules": "Condition: When answering about bonds and their atom elements\nOperation: combine data from both connected and bond tables using an inner join where T1.bond_id = T2.bond_id instead of using only one table.",
      "sql_with_sft_rules": "SELECT (COUNT(*) * 1.0 / (SELECT COUNT(*) FROM bond)) AS percentage FROM connected c JOIN atom a1 ON c.atom_id = a1.atom_id JOIN atom a2 ON c.atom_id2 = a2.atom_id WHERE (a1.element, a2.element) = ( SELECT a1.element, a2.element FROM connected c JOIN atom a1 ON c.atom_id = a1.atom_id JOIN atom a2 ON c.atom_id2 = a2.atom_id GROUP BY a1.element, a2.element ORDER BY COUNT(*) DESC LIMIT 1 );",
      "sql_without_rules": "WITH bond_elements AS ( SELECT b.bond_id, a1.element AS element1, a2.element AS element2, CASE WHEN a1.element <= a2.element THEN a1.element || '-' || a2.element ELSE a2.element || '-' || a1.element END AS element_pair FROM bond b JOIN connected c ON b.bond_id = c.bond_id JOIN atom a1 ON c.atom_id = a1.atom_id JOIN atom a2 ON c.atom_id2 = a2.atom_id ), element_pair_counts AS ( SELECT element_pair, COUNT(*) AS pair_count FROM bond_elements GROUP BY element_pair ), max_pair AS ( SELECT MAX(pair_count) AS max_count FROM element_pair_counts ), total_bonds AS ( SELECT COUNT(*) AS total_count FROM bond ) SELECT (max_count * 100.0 / total_count) AS percentage FROM max_pair, total_bonds;",
      "sql_with_dataset_rules": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM bond)) AS percentage FROM ( SELECT bond.bond_id FROM bond INNER JOIN connected ON bond.bond_id = connected.bond_id INNER JOIN atom a1 ON connected.atom_id = a1.atom_id INNER JOIN atom a2 ON connected.atom_id2 = a2.atom_id GROUP BY bond.bond_id, CASE WHEN a1.element <= a2.element THEN a1.element || '-' || a2.element ELSE a2.element || '-' || a1.element END HAVING COUNT(*) = ( SELECT COUNT(*) FROM bond b2 INNER JOIN connected c2 ON b2.bond_id = c2.bond_id INNER JOIN atom a3 ON c2.atom_id = a3.atom_id INNER JOIN atom a4 ON c2.atom_id2 = a4.atom_id GROUP BY b2.bond_id, CASE WHEN a3.element <= a4.element THEN a3.element || '-' || a4.element ELSE a4.element || '-' || a3.element END ORDER BY COUNT(*) DESC LIMIT 1 ) );",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 22,
      "question": "Identify the number of adult users who have cast over 5000 upvotes.",
      "ground_truth": "SELECT COUNT(Id) FROM users WHERE Age BETWEEN 19 AND 65 AND UpVotes > 5000",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks for \"number of adult users\"\nOperation: count distinct users using COUNT(DISTINCT T1.UserId) instead of counting all rows.",
      "dataset_rules": "No definitional rules found.",
      "sql_with_sft_rules": "SELECT COUNT(DISTINCT u.Id) FROM users u WHERE u.Age >= 18 AND u.UpVotes > 5000;",
      "sql_without_rules": "SELECT COUNT(*) FROM users WHERE Age >= 18 AND UpVotes > 5000;",
      "sql_with_dataset_rules": "SELECT COUNT(*) FROM users WHERE Age >= 18 AND UpVotes > 5000;",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 23,
      "question": "State the names and full communication address of high schools in Monterey which has more than 800 free or reduced price meals for ages 15-17?",
      "ground_truth": "SELECT T1.`School Name`, T2.Street, T2.City, T2.State, T2.Zip FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Monterey' AND T1.`Free Meal Count (Ages 5-17)` > 800 AND T1.`School Type` = 'High Schools (Public)'",
      "db_id": "california_schools",
      "generated_rules": "Rule 1:\nCondition: When the question asks for school names and addresses\nOperation: select \"T1\".\"school_name\" and \"T2\".\"school_address\" as output columns.",
      "dataset_rules": "Condition: When answering about high schools in Monterey\nOperation: use T1.School Name, T2.Street, T2.City, T2.State, and T2.Zip as output columns in that order.\n\nCondition: When the question mentions \"Monterey\"\nOperation: filter on T2.County = 'Monterey' exactly.\n\nCondition: When the question mentions \"more than 800 free or reduced price meals\"\nOperation: filter on T1.\"Free Meal Count (Ages 5-17)\" > 800.\n\nCondition: When the question mentions \"high schools\"\nOperation: filter on T1.\"School Type\" = 'High Schools (Public)' exactly.",
      "sql_with_sft_rules": "SELECT T1.\"School Name\" as school_name, T2.Street || ', ' || T2.City || ', ' || T2.State || ' ' || T2.Zip as school_address FROM frpm T1 JOIN schools T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Monterey' AND T1.\"FRPM Count (Ages 5-17)\" > 800 AND T1.\"High Grade\" LIKE '%12%';",
      "sql_without_rules": "SELECT s.School, s.Street, s.City, s.Zip, s.State FROM schools s JOIN frpm f ON s.CDSCode = f.CDSCode WHERE s.County = 'Monterey' AND s.GSserved LIKE '%12%' AND f.`FRPM Count (Ages 5-17)` > 800;",
      "sql_with_dataset_rules": "SELECT T1.\"School Name\", T2.Street, T2.City, T2.State, T2.Zip FROM frpm AS T1 JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Monterey' AND T1.\"Free Meal Count (Ages 5-17)\" > 800 AND T1.\"School Type\" = 'High Schools (Public)';",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 24,
      "question": "Which student has the hometown of Lincolnton, North Carolina with the zip code of 28092? List their full name and position.",
      "ground_truth": "SELECT T1.first_name, T1.last_name, T1.position FROM member AS T1 INNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip WHERE T2.city = 'Lincolnton' AND T2.state = 'North Carolina' AND T2.zip_code = 28092",
      "db_id": "student_club",
      "generated_rules": "Rule 1:\nCondition: When the question asks for a student's full name\nOperation: select both \"first_name\" and \"last_name\" columns from the \"member\" table instead of a single \"name\" column.\n\nRule 2:\nCondition: When the question asks for a student's position\nOperation: include the \"position\" column from the \"member\" table in the output.",
      "dataset_rules": "Condition: When answering about students with hometown information\nOperation: select from \"member\" AS T1 instead of \"students\" table.\n\nCondition: When the question mentions \"hometown of Lincolnton, North Carolina\"\nOperation: use T2.city = 'Lincolnton' and T2.state = 'North Carolina' instead of hometown filtering.\n\nCondition: When the question mentions \"zip code of 28092\"\nOperation: use T2.zip_code = 28092 (numeric value) instead of string comparison.",
      "sql_with_sft_rules": "SELECT m.first_name, m.last_name, m.position FROM member m JOIN zip_code z ON m.zip = z.zip_code WHERE z.city = 'Lincolnton' AND z.short_state = 'NC' AND z.zip_code = 28092;",
      "sql_without_rules": "SELECT m.first_name, m.last_name, m.position FROM member m JOIN zip_code z ON m.zip = z.zip_code WHERE z.city = 'Lincolnton' AND z.short_state = 'NC' AND z.zip_code = 28092;",
      "sql_with_dataset_rules": "SELECT T1.first_name, T1.last_name, T1.position FROM member AS T1 JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.city = 'Lincolnton' AND T2.state = 'North Carolina' AND T2.zip_code = 28092;",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 25,
      "question": "How many triple type bonds are there?",
      "ground_truth": "SELECT COUNT(T.bond_id) FROM bond AS T WHERE T.bond_type = '#'",
      "db_id": "toxicology",
      "generated_rules": "Rule 1:\nCondition: When the question asks about bonds\nOperation: use the \"bond\" table instead of \"bonds\" to match the correct schema table name.\n\nRule 2:\nCondition: When the question asks about bonds\nOperation: use table \"bond\" instead of \"bonds\" to reference the correct table.",
      "dataset_rules": "Condition: When referencing the bond table\nOperation: use alias T instead of the bare table name bonds.\n\nCondition: When referencing the bond table\nOperation: use the exact table name \"bond\" with alias \"T1\" instead of \"bonds\".",
      "sql_with_sft_rules": "SELECT COUNT(*) FROM bond WHERE bond_type = 'triple';",
      "sql_without_rules": "SELECT COUNT(*) FROM bond WHERE bond_type = 'triple';",
      "sql_with_dataset_rules": "SELECT COUNT(*) FROM bond AS T1 WHERE T1.bond_type = 'triple';",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 26,
      "question": "Where is Malaysian Grand Prix held? Give the location coordinates.",
      "ground_truth": "SELECT DISTINCT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'Malaysian Grand Prix'",
      "db_id": "formula_1",
      "generated_rules": "Rule 1:\nCondition: When the question asks about a specific race like \"Malaysian Grand Prix\"\nOperation: filter the races table using the exact literal 'Malaysian Grand Prix' for the name column.",
      "dataset_rules": "Condition: When the question asks for location coordinates of a specific Grand Prix\nOperation: select T1.lat and T1.lng as the coordinate columns instead of latitude and longitude.\n\nCondition: When the question asks for location coordinates\nOperation: use the exact column names \"lat\" and \"lng\" from the circuits table instead of \"latitude\" and \"longitude\".\n\nCondition: When the question asks for location coordinates\nOperation: use the exact column names \"lat\" and \"lng\" instead of \"latitude\" and \"longitude\" from the circuits table",
      "sql_with_sft_rules": "SELECT lat, lng FROM circuits WHERE circuitId IN (SELECT circuitId FROM races WHERE name = 'Malaysian Grand Prix');",
      "sql_without_rules": "SELECT lat, lng FROM circuits WHERE name = 'Malaysian Grand Prix';",
      "sql_with_dataset_rules": "SELECT c.lat, c.lng FROM circuits c JOIN races r ON c.circuitId = r.circuitId WHERE r.name = 'Malaysian Grand Prix';",
      "result_with_sft_rules": 1,
      "result_without_rules": 0,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 27,
      "question": "For the earliest customer, what segment did he/she have?",
      "ground_truth": "SELECT T2.Segment FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID ORDER BY Date ASC LIMIT 1",
      "db_id": "debit_card_specializing",
      "generated_rules": "Rule 1:\nCondition: When the question asks about \"segment\"\nOperation: use the exact column name \"Segment\" from the customers table.\n\nRule 2:\nCondition: When the question asks about \"segment\"\nOperation: use the exact column name \"Segment\" from table \"customers\" instead of \"segment\".\n\nRule 3:\nCondition: When the question asks about \"segment\"\nOperation: use the exact column name \"Segment\" from the customers table.",
      "dataset_rules": "Condition: When answering about \"the earliest customer\"\nOperation: make sure the output order: sort by Date ASC to find the earliest transaction.",
      "sql_with_sft_rules": "SELECT c.Segment FROM customers c WHERE c.CustomerID = (SELECT CustomerID FROM transactions_1k ORDER BY Date ASC, Time ASC LIMIT 1);",
      "sql_without_rules": "SELECT c.Segment FROM customers c WHERE c.CustomerID = (SELECT CustomerID FROM transactions_1k ORDER BY Date, Time LIMIT 1);",
      "sql_with_dataset_rules": "SELECT c.Segment FROM customers c JOIN transactions_1k t ON c.CustomerID = t.CustomerID ORDER BY t.Date ASC LIMIT 1;",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 28,
      "question": "How many negative comments did Neil McGuigan get in his posts?",
      "ground_truth": "SELECT COUNT(T3.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN comments AS T3 ON T2.Id = T3.PostId WHERE T1.DisplayName = 'Neil McGuigan' AND T3.Score < 60",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks about comments\nOperation: use the \"Comments\" table instead of \"votes\" table.\n\nRule 2:\nCondition: When the question asks about comments for a specific user\nOperation: join the users table as T1 and comments table as T2 using T1.Id = T2.UserId to link user accounts to their comments.\n\nRule 3:\nCondition: When the question asks about comments\nOperation: use table \"Comments\" instead of \"votes\" as the data source.",
      "dataset_rules": "Condition: When the question asks about comments for a specific user\nOperation: join users as T1 with posts as T2 using T1.Id = T2.OwnerUserId, then join comments as T3 with T2 using T2.Id = T3.PostId to establish the proper relationships between users, their posts, and comments on those posts.",
      "sql_with_sft_rules": "SELECT COUNT(*) FROM users T1 JOIN comments T2 ON T1.Id = T2.UserId JOIN posts ON T2.PostId = posts.Id WHERE T1.DisplayName = 'Neil McGuigan' AND T2.Score < 0;",
      "sql_without_rules": "SELECT COUNT(*) FROM comments c JOIN posts p ON c.PostId = p.Id JOIN users u ON p.OwnerUserId = u.Id WHERE u.DisplayName = 'Neil McGuigan' AND c.Score < 0;",
      "sql_with_dataset_rules": "SELECT COUNT(*) FROM users AS T1 JOIN posts AS T2 ON T1.Id = T2.OwnerUserId JOIN comments AS T3 ON T2.Id = T3.PostId WHERE T1.DisplayName = 'Neil McGuigan' AND T3.Score < 0;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 29,
      "question": "List out the type of events which have remaining budget more than 30 USD.",
      "ground_truth": "SELECT T1.type FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.remaining > 30",
      "db_id": "student_club",
      "generated_rules": "Rule 1:\nCondition: When the question asks for event types with remaining budget more than 30 USD\nOperation: use \"T2.type\" as the output column instead of \"event_type\".",
      "dataset_rules": "Condition: When the question asks about \"type of events\"\nOperation: select \"T1.type\" from the \"event\" table instead of \"event_type\" from \"events\" table.",
      "sql_with_sft_rules": "SELECT DISTINCT T2.type FROM budget JOIN event T2 ON budget.link_to_event = T2.event_id WHERE budget.remaining > 30;",
      "sql_without_rules": "SELECT DISTINCT e.type FROM event e JOIN budget b ON e.event_id = b.link_to_event WHERE b.remaining > 30;",
      "sql_with_dataset_rules": "SELECT DISTINCT e.type FROM event e JOIN budget b ON e.event_id = b.link_to_event WHERE b.remaining > 30;",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 30,
      "question": "What was the longest time that Lewis Hamilton had spent at a pit stop?",
      "ground_truth": "SELECT T1.duration FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton' ORDER BY T1.duration DESC LIMIT 1",
      "db_id": "formula_1",
      "generated_rules": "Rule 1:\nCondition: When answering about \"longest time that Lewis Hamilton had spent at a pit stop\"\nOperation: make sure the output order: T2.duration DESC LIMIT 1.\n\nRule 2:\nCondition: When the question mentions \"Lewis Hamilton\"\nOperation: \"Lewis Hamilton\" actually means \"T1.forename = 'Lewis' AND T1.surname = 'Hamilton'\" in schema.",
      "dataset_rules": "Condition: When the question mentions \"Lewis Hamilton\"\nOperation: filter by T3.forename = 'Lewis' AND T3.surname = 'Hamilton' instead of driver_name = 'Lewis Hamilton'.\n\nCondition: When the question mentions \"Lewis Hamilton\"\nOperation: \"Lewis Hamilton\" actually means \"T3.forename = 'Lewis' AND T3.surname = 'Hamilton'\" in schema.\n\nCondition: When the question mentions \"Lewis Hamilton\"\nOperation: \"Lewis Hamilton\" actually means \"T1.forename = 'Lewis' AND T1.surname = 'Hamilton' in schema\".\n\nCondition: When the question mentions \"Lewis Hamilton\"\nOperation: \"Lewis Hamilton\" actually means \"T3.forename = 'Lewis' and T3.surname = 'Hamilton'\" in schema.\n\nCondition: When the question mentions \"Lewis Hamilton\"\nOperation: this corresponds to filtering drivers where forename = 'Lewis' AND surname = 'Hamilton' in the \"drivers\" table.\n\nCondition: When the question mentions \"Lewis Hamilton\"\nOperation: \"Lewis Hamilton\" actually means \"T3.forename = 'Lewis' AND T3.surname = 'Hamilton'\" in schema.\n\nCondition: When the question mentions \"Lewis Hamilton\"\nOperation: use T3.forename = 'Lewis' AND T3.surname = 'Hamilton' for filtering.\n\nCondition: When the question mentions \"Lewis Hamilton\"\nOperation: filter using both T1.forename = 'Lewis' and T1.surname = 'Hamilton' to match the driver's full name.\n\nCondition: When answering about \"longest time spent at a pit stop\"\nOperation: make sure the output order: duration DESC LIMIT 1.\n\nCondition: When the question mentions \"Lewis Hamilton\"\nOperation: \"Lewis Hamilton\" actually means \"T2.forename = 'Lewis' AND T2.surname = 'Hamilton' in schema\".\n\nCondition: When the question asks for the longest time spent at a pit stop for Lewis Hamilton\nOperation: return only the duration value instead of including driver name columns in the output.\n\nCondition: When the question mentions \"Lewis Hamilton\"\nOperation: \"Lewis Hamilton\" actually means \"T2.forename = 'Lewis' AND T2.surname = 'Hamilton'\" in schema.",
      "sql_with_sft_rules": "SELECT T2.duration FROM drivers AS T1 JOIN pitStops AS T2 ON T1.driverId = T2.driverId WHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton' ORDER BY T2.duration DESC LIMIT 1;",
      "sql_without_rules": "SELECT MAX(p.milliseconds) FROM pitStops p JOIN drivers d ON p.driverId = d.driverId WHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';",
      "sql_with_dataset_rules": "SELECT MAX(p.duration) FROM pitStops p JOIN drivers d ON p.driverId = d.driverId WHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';",
      "result_with_sft_rules": 1,
      "result_without_rules": 0,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 31,
      "question": "Which of these circuits is located at a higher latitude, Silverstone Circuit, Hockenheimring or Hungaroring?",
      "ground_truth": "SELECT name FROM circuits WHERE name IN ('Silverstone Circuit', 'Hockenheimring', 'Hungaroring') ORDER BY lat DESC LIMIT 1",
      "db_id": "formula_1",
      "generated_rules": "Rule 1:\nCondition: When the question asks about circuits by name\nOperation: use the exact column \"name\" from table \"circuits\" for filtering, not \"circuit_name\".",
      "dataset_rules": "Condition: When the question asks about latitude comparison between specific circuits\nOperation: use the exact circuit names 'Silverstone Circuit', 'Hockenheimring', and 'Hungaroring' as specified in the question.",
      "sql_with_sft_rules": "SELECT name, lat FROM circuits WHERE name IN ('Silverstone Circuit', 'Hockenheimring', 'Hungaroring') ORDER BY lat DESC LIMIT 1;",
      "sql_without_rules": "SELECT name, lat FROM circuits WHERE name IN ('Silverstone Circuit', 'Hockenheimring', 'Hungaroring') ORDER BY lat DESC LIMIT 1;",
      "sql_with_dataset_rules": "SELECT name, lat FROM circuits WHERE name IN ('Silverstone Circuit', 'Hockenheimring', 'Hungaroring') ORDER BY lat DESC LIMIT 1;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 32,
      "question": "What is the average total price of the transactions taken place in gas stations in the Czech Republic?",
      "ground_truth": "SELECT AVG(T1.Price) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Country = 'CZE'",
      "db_id": "debit_card_specializing",
      "generated_rules": "Rule 1:\nCondition: When answering about average total price of transactions\nOperation: make sure the output order: average of Price.\n\nRule 2:\nCondition: When the question mentions \"gas stations in the Czech Republic\"\nOperation: \"Czech Republic\" actually means \"Country = 'Czech Republic'\" in the gasstations table.",
      "dataset_rules": "Condition: When the question mentions \"Czech Republic\"\nOperation: use the exact country code 'CZE' instead of the full name 'Czech Republic' for the Country column.\n\nCondition: When the question mentions \"Czech Republic\"\nOperation: \"Czech Republic\" actually means \"T2.Country = 'CZE'\" in schema.\n\nCondition: When the question mentions \"Czech Republic\"\nOperation: use country code 'CZE' instead of full name 'Czech Republic' and reference T2.Country for filtering.\n\nCondition: When answering about average transaction price in gas stations in the Czech Republic\nOperation: make sure the output order: AVG(T1.Price).\n\nCondition: When the question mentions \"gas stations\"\nOperation: use table \"gasstations\" as T2 and join with T1 using T1.GasStationID = T2.GasStationID.\n\nCondition: When the question mentions \"Czech Republic\"\nOperation: use country code 'CZE' instead of the full name, filtering on T2.Country = 'CZE'.",
      "sql_with_sft_rules": "SELECT AVG(t.Price) FROM transactions_1k t JOIN gasstations g ON t.GasStationID = g.GasStationID WHERE g.Country = 'Czech Republic';",
      "sql_without_rules": "SELECT AVG(t.Price) FROM transactions_1k t JOIN gasstations g ON t.GasStationID = g.GasStationID WHERE g.Country = 'Czech Republic';",
      "sql_with_dataset_rules": "SELECT AVG(T1.Price) FROM transactions_1k AS T1 JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Country = 'CZE';",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 33,
      "question": "List the edhrecRank for cards with frame version 2015.",
      "ground_truth": "SELECT edhrecRank FROM cards WHERE frameVersion = 2015",
      "db_id": "card_games",
      "generated_rules": "Rule 1:\nCondition: When the question asks for \"edhrecRank\"\nOperation: use the exact column name \"edhrecRank\" from the cards table.",
      "dataset_rules": "Condition: When the question mentions \"frame version\"\nOperation: use the exact column name \"frameVersion\" from the cards table.",
      "sql_with_sft_rules": "SELECT edhrecRank FROM cards WHERE frameVersion = '2015';",
      "sql_without_rules": "SELECT edhrecRank FROM cards WHERE frameVersion = '2015';",
      "sql_with_dataset_rules": "SELECT edhrecRank FROM cards WHERE frameVersion = '2015';",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 34,
      "question": "Is there any card from Erica Yang artist in pauper format and available in paper? If so, indicate its ID.",
      "ground_truth": "SELECT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Erica Yang' AND T2.format = 'pauper' AND T1.availability = 'paper'",
      "db_id": "card_games",
      "generated_rules": "Rule 1:\nCondition: When the question asks about cards from a specific artist\nOperation: use the exact column \"artist\" from the \"cards\" table with the exact literal value 'Erica Yang'.\n\nRule 2:\nCondition: When the question asks about cards in a specific format\nOperation: use the exact column \"format\" from the \"legalities\" table with the exact literal value 'pauper'.\n\nRule 3:\nCondition: When the question asks about card availability in paper format\nOperation: use the exact column \"availability\" from the \"cards\" table with the exact literal value 'paper'.",
      "dataset_rules": "Condition: When answering about cards from a specific artist\nOperation: use T1.artist with the exact literal 'Erica Yang' to filter cards.\n\nCondition: When the question asks about cards from artist 'Erica Yang'\nOperation: filter rows where T1.artist equals 'Erica Yang' exactly.\n\nCondition: When the question specifies 'pauper format'\nOperation: filter rows where T2.format equals 'pauper' exactly.\n\nCondition: When the question asks about cards 'available in paper'\nOperation: filter rows where T1.availability equals 'paper' exactly (not pattern matching).",
      "sql_with_sft_rules": "SELECT c.id FROM cards c JOIN legalities l ON c.uuid = l.uuid WHERE c.artist = 'Erica Yang' AND l.format = 'pauper' AND c.availability = 'paper';",
      "sql_without_rules": "SELECT c.id FROM cards c JOIN legalities l ON c.uuid = l.uuid WHERE c.artist = 'Erica Yang' AND l.format = 'Pauper' AND l.status = 'Legal' AND (c.hasFoil = 1 OR c.hasNonFoil = 1);",
      "sql_with_dataset_rules": "SELECT T1.id FROM cards T1 JOIN legalities T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Erica Yang' AND T2.format = 'pauper' AND T1.availability = 'paper';",
      "result_with_sft_rules": 1,
      "result_without_rules": 0,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 35,
      "question": "Calculate the percentage of cards in Spanish. List them by name.",
      "ground_truth": "SELECT ( SELECT CAST(SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM foreign_data ), name FROM foreign_data WHERE language = 'Spanish'",
      "db_id": "card_games",
      "generated_rules": "Rule 1:\nCondition: When the question asks for percentage\nOperation: do not divide by 100.0 factor as the percentage calculation should return the decimal value directly.\n\nRule 2:\nCondition: When the question asks for percentage of cards in Spanish\nOperation: use the exact literal 'Spanish' for the language condition.\n\nRule 3:\nCondition: When the question asks for percentage of cards in Spanish\nOperation: use the exact literal 'Spanish' for the language condition.\n\nRule 4:\nCondition: When the question asks for percentage of cards in Spanish\nOperation: calculate the ratio of cards where T1.language = 'Spanish' divided by total cards, then multiply by 100.\n\nRule 5:\nCondition: When the question asks for percentage of cards in Spanish\nOperation: calculate the ratio of cards where T1.language = 'Spanish' divided by total cards, then multiply by 100.\n\nRule 6:\nCondition: When the question asks for percentage of cards in Spanish\nOperation: use the exact literal 'Spanish' for the language condition.\n\nRule 7:\nCondition: When the question asks for percentage of cards in Spanish\nOperation: use the exact literal 'Spanish' for the language condition.\n\nRule 8:\nCondition",
      "dataset_rules": "Condition: When answering about percentage of cards in Spanish\nOperation: use the \"foreign_data\" table instead of the \"cards\" table.",
      "sql_with_sft_rules": "SELECT (COUNT(CASE WHEN fd.language = 'Spanish' THEN 1 END) * 100.0 / COUNT(*)) AS percentage, c.name FROM cards c LEFT JOIN foreign_data fd ON c.uuid = fd.uuid GROUP BY c.name;",
      "sql_without_rules": "SELECT (COUNT(CASE WHEN fd.language = 'Spanish' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_spanish, c.name FROM cards c LEFT JOIN foreign_data fd ON c.uuid = fd.uuid AND fd.language = 'Spanish' GROUP BY c.name ORDER BY c.name;",
      "sql_with_dataset_rules": "SELECT name, (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM foreign_data)) as percentage FROM foreign_data WHERE language = 'Spanish' GROUP BY name;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 36,
      "question": "Please provide top three sets that don't appear in Magic: The Gathering Online, along with their names in in alphabetical order.",
      "ground_truth": "SELECT name FROM sets WHERE mtgoCode IS NULL ORDER BY name LIMIT 3",
      "db_id": "card_games",
      "generated_rules": "Rule 1:\nCondition: When the question asks for sets that don't appear in Magic: The Gathering Online\nOperation: filter sets where \"isOnlineOnly\" equals 1 instead of using \"isOnlineOnly = 0\".\n\nRule 2:\nCondition: When the question asks for set names\nOperation: select the exact column \"name\" from the \"sets\" table.",
      "dataset_rules": "No definitional rules found.",
      "sql_with_sft_rules": "SELECT name FROM sets WHERE isOnlineOnly = 1 ORDER BY name LIMIT 3;",
      "sql_without_rules": "SELECT s.name FROM sets s WHERE s.mtgoCode IS NULL ORDER BY s.name LIMIT 3;",
      "sql_with_dataset_rules": "SELECT s.name FROM sets s WHERE s.mtgoCode IS NULL ORDER BY s.name LIMIT 3;",
      "result_with_sft_rules": 0,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 37,
      "question": "How long did it take the user, known by his or her display name 'Zolomon' to get the badge? Count from the date the user's account was created.",
      "ground_truth": "SELECT T1.Date - T2.CreationDate FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Zolomon'",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks about a user with display name 'Zolomon'\nOperation: filter using DisplayName = 'Zolomon' exactly as written.",
      "dataset_rules": "Condition: When the question asks about time duration between a user's account creation and badge date\nOperation: calculate the difference using direct date subtraction T1.Date - T2.CreationDate instead of date conversion functions.\n\nCondition: When the question asks for all matching records\nOperation: do not apply any row limiting clauses like LIMIT 1.",
      "sql_with_sft_rules": "SELECT julianday(b.Date) - julianday(u.CreationDate) FROM badges b JOIN users u ON b.UserId = u.Id WHERE u.DisplayName = 'Zolomon';",
      "sql_without_rules": "SELECT MIN(b.Date) - u.CreationDate AS TimeToBadge FROM badges b JOIN users u ON b.UserId = u.Id WHERE u.DisplayName = 'Zolomon' LIMIT 1;",
      "sql_with_dataset_rules": "SELECT b.Date - u.CreationDate FROM badges b JOIN users u ON b.UserId = u.Id WHERE u.DisplayName = 'Zolomon';",
      "result_with_sft_rules": 0,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 38,
      "question": "What is the administrator's email address for the school with the highest number of test takers who received SAT scores of at least 1500?Provide the name of the school.",
      "ground_truth": "SELECT T2.AdmEmail1, T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
      "db_id": "california_schools",
      "generated_rules": "Rule 1:\nCondition: When the question asks for administrator's email address\nOperation: select \"AdmEmail1\" from the \"schools\" table instead of \"admin_email\" from \"schools\".\n\nRule 2:\nCondition: When the question asks for the school name\nOperation: select \"School\" from the \"schools\" table instead of \"school_name\" from \"schools\".",
      "dataset_rules": "Condition: When answering about the highest number of test takers with SAT scores ≥1500\nOperation: rank schools by T1.NumGE1500 in descending order and keep the first row.\n\nCondition: When answering about \"administrator's email address for the school with the highest number of test takers who received SAT scores of at least 1500\"\nOperation: make sure the output order: AdmEmail1, School\n\nCondition: When the question asks for the school with the highest number of test takers who received SAT scores of at least 1500\nOperation: rank rows by T1.NumGE1500 in descending order and keep the first 1 row.",
      "sql_with_sft_rules": "SELECT s.School, s.AdmEmail1 FROM schools s JOIN satscores sat ON s.CDSCode = sat.cds WHERE sat.NumGE1500 = (SELECT MAX(NumGE1500) FROM satscores) LIMIT 1;",
      "sql_without_rules": "SELECT s.School, s.AdmEmail1 FROM schools s JOIN satscores sat ON s.CDSCode = sat.cds WHERE sat.NumGE1500 = (SELECT MAX(NumGE1500) FROM satscores) LIMIT 1;",
      "sql_with_dataset_rules": "SELECT s.AdmEmail1, s.School FROM satscores t1 JOIN schools s ON t1.cds = s.CDSCode ORDER BY t1.NumGE1500 DESC LIMIT 1;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 39,
      "question": "State code numbers of top 3 yougest drivers. How many Netherlandic drivers among them?",
      "ground_truth": "SELECT COUNT(*) FROM ( SELECT T1.nationality FROM drivers AS T1 ORDER BY JULIANDAY(T1.dob) DESC LIMIT 3) AS T3 WHERE T3.nationality = 'Dutch'",
      "db_id": "formula_1",
      "generated_rules": "Rule 1:\nCondition: When answering about \"top 3 youngest drivers\"\nOperation: rank drivers by T1.dob in ascending order and keep the first 3 rows.\n\nRule 2:\nCondition: When the question mentions \"Netherlandic drivers\"\nOperation: filter for rows where T1.nationality equals exactly 'Netherlands'.",
      "dataset_rules": "Condition: When the question asks for \"top 3 youngest drivers\"\nOperation: rank drivers by JULIANDAY(dob) in descending order (most recent birth dates first) and keep the first 3 rows.\n\nCondition: When the question mentions \"Netherlandic drivers\"\nOperation: \"Netherlandic\" actually means \"Dutch\" in the schema, so use nationality = 'Dutch' exactly.",
      "sql_with_sft_rules": "SELECT COUNT(*) FROM ( SELECT d.driverId, d.code, d.dob, d.nationality FROM drivers d ORDER BY d.dob ASC LIMIT 3 ) AS youngest_drivers WHERE nationality = 'Netherlands';",
      "sql_without_rules": "SELECT d.code, COUNT(*) OVER (PARTITION BY d.nationality = 'Dutch') AS netherlandic_count FROM drivers d WHERE d.dob IS NOT NULL ORDER BY d.dob DESC LIMIT 3;",
      "sql_with_dataset_rules": "SELECT COUNT(*) FROM ( SELECT d.driverId, d.number, d.nationality FROM drivers d ORDER BY JULIANDAY(d.dob) DESC LIMIT 3 ) AS youngest_drivers WHERE nationality = 'Dutch';",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 40,
      "question": "Which race was Alex Yoong in when he was in track number less than 20?",
      "ground_truth": "SELECT T1.name FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Alex' AND T3.surname = 'Yoong' AND T2.position < 20",
      "db_id": "formula_1",
      "generated_rules": "Rule 1:\nCondition: When answering about races for a specific driver\nOperation: join results table as T1 with drivers table as T2 using T1.driverId = T2.driverId to link driver information.",
      "dataset_rules": "Condition: When the question mentions \"race\"\nOperation: \"race\" actually means \"T2.race\" in schema\n\nCondition: When the question mentions \"race\"\nOperation: select T2.race instead of a direct column from the main table.\n\nCondition: When the question mentions \"race\"\nOperation: \"race\" actually means \"T3.name in schema\"\n\nCondition: When answering about \"which race Alex Yoong was in with track number less than 20\"\nOperation: make sure the output order: T1.name\n\nCondition: When the question mentions \"race\"\nOperation: \"race\" actually means \"T1.name in schema\"\n\nCondition: When the question mentions \"race\"\nOperation: \"race\" actually means \"T2.name in schema\"",
      "sql_with_sft_rules": "SELECT T1.raceId FROM results AS T1 JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T2.forename = 'Alex' AND T2.surname = 'Yoong' AND T1.number < 20;",
      "sql_without_rules": "SELECT r.name FROM races r JOIN results res ON r.raceId = res.raceId JOIN drivers d ON res.driverId = d.driverId WHERE d.forename = 'Alex' AND d.surname = 'Yoong' AND res.number < 20;",
      "sql_with_dataset_rules": "SELECT DISTINCT r.name FROM results res JOIN drivers d ON res.driverId = d.driverId JOIN races r ON res.raceId = r.raceId WHERE d.forename = 'Alex' AND d.surname = 'Yoong' AND res.number < 20;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 41,
      "question": "Please list the diseases of the patients born after 1985-1-1 and have a normal Rhuematoid Factor.",
      "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.RA = '-' OR T2.RA = '+-') AND T1.Birthday > '1985-01-01'",
      "db_id": "thrombosis_prediction",
      "generated_rules": "Rule 1:\nCondition: When the question asks about diseases of patients\nOperation: use the \"Diagnosis\" column from the \"Patient\" table instead of \"disease\" from \"patients\".",
      "dataset_rules": "Condition: When answering about \"diseases of patients\"\nOperation: make sure the output column is T1.Diagnosis instead of disease.",
      "sql_with_sft_rules": "SELECT DISTINCT p.Diagnosis FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE p.Birthday > '1985-01-01' AND l.RF = 'normal';",
      "sql_without_rules": "SELECT DISTINCT p.Diagnosis FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE p.Birthday > '1985-01-01' AND l.RF = 'normal';",
      "sql_with_dataset_rules": "SELECT DISTINCT T1.Diagnosis FROM Patient JOIN Examination AS T1 ON Patient.ID = T1.ID JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE Patient.Birthday > '1985-01-01' AND Laboratory.RF = 'normal';",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 42,
      "question": "What was the build up play speed class for \"Willem II\" on 2011/2/22?",
      "ground_truth": "SELECT t2.buildUpPlaySpeedClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Willem II' AND SUBSTR(t2.`date`, 1, 10) = '2011-02-22'",
      "db_id": "european_football_2",
      "generated_rules": "Rule 1:\nCondition: When the question asks about build up play speed class for a team\nOperation: use the exact column name \"buildUpPlaySpeedClass\" from the Team_Attributes table.",
      "dataset_rules": "Condition: When answering about \"build up play speed class\" for a team\nOperation: use the column \"buildUpPlaySpeedClass\" from table \"Team_Attributes\" (aliased as t2) instead of directly from \"team_attributes\".",
      "sql_with_sft_rules": "SELECT ta.buildUpPlaySpeedClass FROM Team_Attributes ta JOIN Team t ON ta.team_api_id = t.team_api_id WHERE t.team_long_name = 'Willem II' AND ta.date = '2011/2/22';",
      "sql_without_rules": "SELECT ta.buildUpPlaySpeedClass FROM Team_Attributes ta JOIN Team t ON ta.team_api_id = t.team_api_id WHERE t.team_long_name = 'Willem II' AND ta.date = '2011/2/22';",
      "sql_with_dataset_rules": "SELECT t2.buildUpPlaySpeedClass FROM Team_Attributes t2 JOIN Team t ON t2.team_api_id = t.team_api_id WHERE t.team_long_name = 'Willem II' AND t2.date = '2011/2/22';",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 43,
      "question": "Please list top three molecules that have single bonds between two atoms and are not carcinogenic in alphabetical order.",
      "ground_truth": "SELECT DISTINCT T2.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-' AND T2.label = '-' ORDER BY T2.molecule_id LIMIT 3",
      "db_id": "toxicology",
      "generated_rules": "Rule 1:\nCondition: When the question asks for molecules with single bonds\nOperation: filter rows where T2.bond_type equals 'single' exactly.\n\nRule 2:\nCondition: When the question asks for molecules that are not carcinogenic\nOperation: filter rows where T1.label does not contain 'carcinogen' exactly.\n\nRule 3:\nCondition: When the question asks for top three molecules\nOperation: take the first 3 rows after ordering.\n\nRule 4:\nCondition: When the question asks for alphabetical order\nOperation: order by T1.label in ascending order.",
      "dataset_rules": "Condition: When answering about molecules with specific bond types and labels\nOperation: combine bond table as T1 and molecule table as T2 using an inner match where T1.molecule_id equals T2.molecule_id.\n\nCondition: When the question mentions \"single bonds\"\nOperation: filter for T1.bond_type = '-' exactly.\n\nCondition: When the question mentions \"not carcinogenic\"\nOperation: filter for T2.label = '-' exactly.\n\nCondition: When the question asks for alphabetical order\nOperation: order results by T2.molecule_id in ascending sequence.\n\nCondition: When the question mentions \"single bonds\"\nOperation: \"single\" actually means \"bond_type = '-' in schema\".\n\nCondition: When the question mentions \"single bonds\"\nOperation: \"single bonds\" actually means \"bond_type = '-' in schema\".\n\nCondition: When the question mentions \"not carcinogenic\"\nOperation: \"not carcinogenic\" actually means \"T2.label = '-' in schema\"",
      "sql_with_sft_rules": "SELECT DISTINCT m.molecule_id, m.label FROM molecule m JOIN bond b ON m.molecule_id = b.molecule_id WHERE b.bond_type = 'single' AND m.label NOT LIKE '%carcinogen%' ORDER BY m.label ASC LIMIT 3;",
      "sql_without_rules": "SELECT m.molecule_id FROM molecule m JOIN bond b ON m.molecule_id = b.molecule_id WHERE b.bond_type = 'single' AND m.label != 'carcinogenic' GROUP BY m.molecule_id ORDER BY m.molecule_id ASC LIMIT 3;",
      "sql_with_dataset_rules": "SELECT DISTINCT T2.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-' AND T2.label = '-' ORDER BY T2.molecule_id ASC LIMIT 3;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 44,
      "question": "List down two molecule id of triple bond non carcinogenic molecules with element carbon.",
      "ground_truth": "SELECT DISTINCT T2.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#' AND T1.element = 'c' AND T2.label = '-'",
      "db_id": "toxicology",
      "generated_rules": "Rule 1:\nCondition: When the question asks for \"molecule id\"\nOperation: use the exact identifier \"molecule_id\" from the molecule table.\n\nRule 2:\nCondition: When the question asks for \"molecule id\"\nOperation: use the exact identifier \"molecule_id\" from the molecule table.\n\nRule 3:\nCondition: When the question asks for \"molecule id\"\nOperation: use the exact identifier \"molecule_id\" from the molecule table.\n\nRule 4:\nCondition: When the question asks for \"molecule id\"\nOperation: use the exact identifier \"molecule_id\" from the molecule table.\n\nRule 5:\nCondition: When the question asks for \"molecule id\"\nOperation: use the exact identifier \"molecule_id\" from the molecule table.\n\nRule 6:\nCondition: When the question asks for \"molecule id\"\nOperation: use the exact identifier \"molecule_id\" from the molecule table.\n\nRule 7:\nCondition: When the question asks for \"molecule id\"\nOperation: use the exact identifier \"molecule_id\" from the molecule table.\n\nRule 8:\nCondition: When the question asks for \"molecule id\"\nOperation: use the exact identifier \"molecule_id\" from the molecule table.",
      "dataset_rules": "Condition: When the question mentions \"triple bond\"\nOperation: \"triple bond\" actually means \"T1.bond_type = '#'\" in schema.\n\nCondition: When the question mentions \"triple bond\"\nOperation: \"triple bond\" actually means \"bond_type = '#' in schema\"\n\nCondition: When answering about \"molecule id of triple bond non carcinogenic molecules with element carbon\"\nOperation: make sure the output order: T2.molecule_id\n\nCondition: When the question mentions \"triple bond\"\nOperation: \"triple bond\" actually means \"T3.bond_type = '#'\" in schema\n\nCondition: When the question mentions \"element carbon\"\nOperation: \"element carbon\" actually means \"T1.element = 'c'\" in schema\n\nCondition: When the question mentions \"non carcinogenic\"\nOperation: \"non carcinogenic\" actually means \"T2.label = '-'\" in schema\n\nCondition: When the question asks for \"molecule id\"\nOperation: compute the distinct values of T2.molecule_id instead of all values\n\nCondition: When the question mentions \"element carbon\"\nOperation: \"carbon\" actually means \"c\" in schema, so use T1.element = 'c' exactly.",
      "sql_with_sft_rules": "SELECT DISTINCT m.molecule_id FROM molecule m JOIN bond b ON m.molecule_id = b.molecule_id JOIN connected c ON b.bond_id = c.bond_id JOIN atom a1 ON c.atom_id = a1.atom_id JOIN atom a2 ON c.atom_id2 = a2.atom_id WHERE b.bond_type = 'triple' AND m.label != 'carcinogenic' AND (a1.element = 'carbon' OR a2.element = 'carbon') LIMIT 2;",
      "sql_without_rules": "SELECT DISTINCT m.molecule_id FROM molecule m JOIN bond b ON m.molecule_id = b.molecule_id JOIN connected c ON b.bond_id = c.bond_id JOIN atom a1 ON c.atom_id = a1.atom_id JOIN atom a2 ON c.atom_id2 = a2.atom_id WHERE b.bond_type = 'triple' AND m.label != 'carcinogenic' AND (a1.element = 'carbon' OR a2.element = 'carbon') LIMIT 2;",
      "sql_with_dataset_rules": "SELECT DISTINCT T2.molecule_id FROM atom T1 JOIN molecule T2 ON T1.molecule_id = T2.molecule_id JOIN connected T3 ON T1.atom_id = T3.atom_id JOIN bond T4 ON T3.bond_id = T4.bond_id WHERE T1.element = 'c' AND T2.label = '-' AND T4.bond_type = '#' LIMIT 2;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 45,
      "question": "List all the frame styles and cards Allen Williams worked on and find any banned cards if there are any.",
      "ground_truth": "SELECT DISTINCT T1.frameVersion, T1.name , IIF(T2.status = 'Banned', T1.name, 'NO') FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Allen Williams'",
      "db_id": "card_games",
      "generated_rules": "Rule 1:\nCondition: When answering about frame styles and cards by artist\nOperation: make sure the output order: T1.frameVersion, T2.name.\n\nRule 2:\nCondition: When the question mentions \"cards Allen Williams worked on\"\nOperation: \"Allen Williams\" actually means T2.artist = 'Allen Williams' in schema.\n\nRule 3:\nCondition: When the question mentions \"banned cards\"\nOperation: \"banned\" actually means T1.banned = '1' in schema.",
      "dataset_rules": "Condition: When the question mentions \"cards\"\nOperation: \"cards\" actually means \"card AS T1\" in schema.\n\nCondition: When the question mentions \"cards\"\nOperation: \"cards\" actually means \"T1 table\" in schema.\n\nCondition: When the question mentions \"cards\"\nOperation: \"cards\" actually means \"T1.name in schema\"\n\nCondition: When answering about \"frame styles and cards Allen Williams worked on\"\nOperation: make sure the output order: T1.frameVersion, T1.name, and a conditional expression for banned status.\n\nCondition: When the question mentions \"frame styles\"\nOperation: \"frame styles\" actually means \"T1.frameVersion in schema\".\n\nCondition: When the question mentions \"cards\"\nOperation: \"cards\" actually means \"T1.name in schema\".\n\nCondition: When the question asks about \"banned cards\"\nOperation: use a conditional expression IIF(T2.status = 'Banned', T1.name, 'NO') to determine banned status.",
      "sql_with_sft_rules": "SELECT DISTINCT cards.frameVersion, cards.name FROM cards JOIN legalities ON cards.uuid = legalities.uuid WHERE cards.artist = 'Allen Williams' AND legalities.status = 'banned' ORDER BY cards.frameVersion, cards.name;",
      "sql_without_rules": "SELECT DISTINCT c.frameVersion, c.name, l.status FROM cards c LEFT JOIN legalities l ON c.uuid = l.uuid AND l.status = 'banned' WHERE c.artist = 'Allen Williams';",
      "sql_with_dataset_rules": "SELECT T1.frameVersion, T1.name, IIF(T2.status = 'Banned', T1.name, 'NO') FROM cards AS T1 LEFT JOIN legalities AS T2 ON T1.uuid = T2.uuid AND T2.status = 'Banned' WHERE T1.artist = 'Allen Williams';",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 46,
      "question": "How many patients have a normal anti-DNA level, yet their data are not recorded.",
      "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.DNA < 8 AND T1.Description IS NULL",
      "db_id": "thrombosis_prediction",
      "generated_rules": "Rule 1:\nCondition: When the question asks about patients with normal anti-DNA level\nOperation: use the exact column \"DNA\" from the Laboratory table with value 'Normal' instead of \"anti_dna_level = 'Normal'\".",
      "dataset_rules": "No definitional rules found.",
      "sql_with_sft_rules": "SELECT COUNT(DISTINCT p.ID) FROM Patient p WHERE NOT EXISTS ( SELECT 1 FROM Laboratory l WHERE l.ID = p.ID AND l.DNA = 'Normal' );",
      "sql_without_rules": "SELECT COUNT(DISTINCT p.ID) FROM Patient p LEFT JOIN Laboratory l ON p.ID = l.ID AND l.DNA = 'normal' WHERE l.ID IS NULL;",
      "sql_with_dataset_rules": "SELECT COUNT(DISTINCT p.ID) FROM Patient p LEFT JOIN Laboratory l ON p.ID = l.ID AND l.DNA = 'normal' WHERE l.ID IS NULL;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 47,
      "question": "What city and state did the President of the Student_Club grow up?",
      "ground_truth": "SELECT T2.city, T2.state FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.position = 'President'",
      "db_id": "student_club",
      "generated_rules": "Rule 1:\nCondition: When the question asks about a person's hometown city and state\nOperation: use the exact column names \"T2.city\" and \"T2.state\" from the zip_code table instead of \"city\" and \"state\" from the member table.",
      "dataset_rules": "Condition: When the question asks for city and state information\nOperation: select \"T2\".\"city\" and \"T2\".\"state\" from the \"zip_code\" table instead of directly from the \"Student_Club\" table.",
      "sql_with_sft_rules": "SELECT T2.city, T2.state FROM member JOIN zip_code T2 ON member.zip = T2.zip_code WHERE member.position = 'President';",
      "sql_without_rules": "SELECT z.city, z.state FROM member m JOIN zip_code z ON m.zip = z.zip_code WHERE m.position = 'President';",
      "sql_with_dataset_rules": "SELECT z.city, z.state FROM member m JOIN zip_code z ON m.zip = z.zip_code WHERE m.position = 'President';",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 48,
      "question": "How many meeting events were held in 2020?",
      "ground_truth": "SELECT COUNT(event_id) FROM event WHERE type = 'Meeting' AND SUBSTR(event_date, 1, 4) = '2020'",
      "db_id": "student_club",
      "generated_rules": "Rule 1:\nCondition: When the question asks about \"meeting events\"\nOperation: filter events where the \"type\" column equals exactly 'meeting'.",
      "dataset_rules": "Condition: When referencing the events table\nOperation: use table name \"event\" instead of \"events\" to match the correct schema.",
      "sql_with_sft_rules": "SELECT COUNT(*) FROM event WHERE type = 'meeting' AND event_date LIKE '2020%';",
      "sql_without_rules": "SELECT COUNT(*) FROM event WHERE type = 'meeting' AND event_date LIKE '2020%';",
      "sql_with_dataset_rules": "SELECT COUNT(*) FROM event WHERE event_date LIKE '2020%' AND type = 'meeting';",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 49,
      "question": "What is the display name of the user who last edited the post \"Examples for teaching: Correlation does not mean causation\"?",
      "ground_truth": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T1.Title = 'Examples for teaching: Correlation does not mean causation'",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks for \"display name\"\nOperation: use the exact column token \"DisplayName\" from the users table.\n\nRule 2:\nCondition: When the question asks for \"display name\"\nOperation: use the exact column token \"DisplayName\" from the users table.\n\nRule 3:\nCondition: When the question asks for \"display name\"\nOperation: use the exact column token \"Name\" from the customers table.\n\nRule 4:\nCondition: When the question asks for \"display name\"\nOperation: use the exact column token \"Name\" from the customers table.\n\nRule 5:\nCondition: When the question asks for \"display name\"\nOperation: use the exact column token \"Name\" from the Customers table.\n\nRule 6:\nCondition: When the question asks for \"display name\"\nOperation: use the exact column token \"Name\" from the Customers table.\n\nRule 7:\nCondition: When the question asks for \"display name\"\nOperation: use the exact column token \"Name\" from the Customers table.\n\nRule 8:\nCondition: When the question asks for \"display name\"\nOperation: use the exact column token \"Name\" from the Customers table.\n\nRule 9:\nCondition: When the question asks for \"display name\"\nOperation",
      "dataset_rules": "Condition: When the question asks for the user who last edited a specific post\nOperation: filter posts where T1.title equals 'Examples for teaching: Correlation does not mean causation' exactly as specified.",
      "sql_with_sft_rules": "SELECT u.DisplayName FROM posts p JOIN users u ON p.LastEditorUserId = u.Id WHERE p.Title = 'Examples for teaching: Correlation does not mean causation';",
      "sql_without_rules": "SELECT LastEditorDisplayName FROM posts WHERE Title = 'Examples for teaching: Correlation does not mean causation';",
      "sql_with_dataset_rules": "SELECT LastEditorDisplayName FROM posts WHERE Title = 'Examples for teaching: Correlation does not mean causation';",
      "result_with_sft_rules": 1,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 50,
      "question": "How many molecules are carcinogenic and have the bromine element?",
      "ground_truth": "SELECT COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.element = 'br'",
      "db_id": "toxicology",
      "generated_rules": "Rule 1:\nCondition: When the question asks about molecules containing bromine\nOperation: use the \"atom\" table instead of \"molecules\" table to access bromine information.",
      "dataset_rules": "No definitional rules found.",
      "sql_with_sft_rules": "SELECT COUNT(DISTINCT m.molecule_id) FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id WHERE m.label = 'carcinogenic' AND a.element = 'Br';",
      "sql_without_rules": "SELECT COUNT(DISTINCT m.molecule_id) FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id WHERE m.label = 'carcinogenic' AND a.element = 'Br';",
      "sql_with_dataset_rules": "SELECT COUNT(DISTINCT m.molecule_id) FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id WHERE m.label = 'carcinogenic' AND a.element = 'Br';",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 51,
      "question": "Which player has the strongest overall strength?",
      "ground_truth": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t2.overall_rating DESC LIMIT 1",
      "db_id": "european_football_2",
      "generated_rules": "Rule 1:\nCondition: When the question asks about \"player_name\"\nOperation: use the exact column token \"Player_name\" from the Player table.\n\nRule 2:\nCondition: When the question asks about \"player_name\"\nOperation: use the exact column token \"Player_name\" from the Player table.\n\nRule 3:\nCondition: When the question asks about \"player_name\"\nOperation: use the exact column token \"Player_name\" from the Player table.\n\nRule 4:\nCondition: When the question asks about \"player_name\"\nOperation: use the exact column token \"Player_name\" from the Player table.\n\nRule 5:\nCondition: When the question asks about \"player_name\"\nOperation: use the exact column token \"Player_name\" from the Player table.\n\nRule 6:\nCondition: When the question asks about \"player_name\"\nOperation: use the exact column token \"Player_name\" from the Player table.\n\nRule 7:\nCondition: When the question asks about \"player_name\"\nOperation: use the exact column token \"Player_name\" from the Player table.\n\nRule 8:\nCondition: When the question asks about \"player_name\"\nOperation: use the exact column token \"Player_name\" from the Player table.\n\nRule 9:\nCondition: When the",
      "dataset_rules": "Condition: When the question asks about \"player\"\nOperation: use \"t1.player_name\" from the \"Player\" table instead of \"name\" from \"players\".",
      "sql_with_sft_rules": "SELECT Player_name FROM Player JOIN Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id ORDER BY strength DESC LIMIT 1;",
      "sql_without_rules": "SELECT p.player_name, pa.strength FROM Player p JOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id ORDER BY pa.strength DESC LIMIT 1;",
      "sql_with_dataset_rules": "SELECT t1.player_name FROM Player AS t1 JOIN Player_Attributes ON t1.player_api_id = Player_Attributes.player_api_id ORDER BY Player_Attributes.strength DESC LIMIT 1;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 52,
      "question": "Count the fastest superheroes.",
      "ground_truth": "SELECT COUNT(T3.superhero_name) FROM hero_attribute AS T1 INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id INNER JOIN superhero AS T3 ON T1.hero_id = T3.id WHERE T2.attribute_name = 'Speed' AND T1.attribute_value = 100",
      "db_id": "superhero",
      "generated_rules": "Rule 1:\nCondition: When the question mentions \"fastest\"\nOperation: \"fastest\" actually means \"speed\" in the superpower table.\n\nRule 2:\nCondition: When answering about \"Count the fastest superheroes\"\nOperation: make sure the output order: COUNT(T1.hero_id).\n\nRule 3:\nCondition: When the question mentions \"fastest\"\nOperation: \"fastest\" actually means \"speed\" in schema, so filter on T2.power_name = 'speed' instead of sorting by speed.",
      "dataset_rules": "Condition: When answering about \"fastest superheroes\"\nOperation: make sure the output order: COUNT(T3.superhero_name).\n\nCondition: When the question mentions \"fastest superheroes\"\nOperation: use the exact literal 'Speed' for T2.attribute_name and the exact value 100 for T1.attribute_value.",
      "sql_with_sft_rules": "SELECT COUNT(DISTINCT T1.hero_id) FROM hero_power T1 JOIN superpower T2 ON T1.power_id = T2.id WHERE T2.power_name = 'speed';",
      "sql_without_rules": "SELECT COUNT(*) FROM superhero s JOIN hero_attribute ha ON s.id = ha.hero_id JOIN attribute a ON ha.attribute_id = a.id WHERE a.attribute_name = 'Speed' AND ha.attribute_value = (SELECT MAX(attribute_value) FROM hero_attribute WHERE attribute_id = ha.attribute_id);",
      "sql_with_dataset_rules": "SELECT COUNT(T3.superhero_name) FROM hero_attribute T1 JOIN attribute T2 ON T1.attribute_id = T2.id JOIN superhero T3 ON T1.hero_id = T3.id WHERE T2.attribute_name = 'Speed' AND T1.attribute_value = 100;",
      "result_with_sft_rules": 0,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 53,
      "question": "How many posts by Matt Parker have more than 4 votes?",
      "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id INNER JOIN votes AS T4 ON T4.PostId = T3.Id WHERE T1.DisplayName = 'Matt Parker' GROUP BY T2.PostId, T4.Id HAVING COUNT(T4.Id) > 4",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks about posts by a specific user\nOperation: join the users table (T1) and posts table (T2) using an inner match where T1.Id equals T2.OwnerUserId.",
      "dataset_rules": "Condition: When answering about \"posts by Matt Parker\"\nOperation: make sure to join tables users (T1), posts (T2), postHistory (T3), and votes (T4) using the relationships implied by the schema.\n\nCondition: When answering about \"posts by Matt Parker\"\nOperation: make sure to join tables users (T1), posts (T2), postHistory (T3), and votes (T4) using the relationships implied by the schema.\n\nCondition: When the question mentions \"Matt Parker\"\nOperation: use T1.DisplayName = 'Matt Parker' exactly to filter by user display name.\n\nCondition: When answering about \"posts by Matt Parker\"\nOperation: make sure to include the posts table (T3) in the FROM clause and join it between postHistory and votes tables.\n\nCondition: When answering about \"posts by Matt Parker\"\nOperation: make sure to include the posts table (T3) in the FROM clause and join it between postHistory and votes tables.",
      "sql_with_sft_rules": "SELECT COUNT(*) FROM users u INNER JOIN posts p ON u.Id = p.OwnerUserId INNER JOIN votes v ON p.Id = v.PostId WHERE u.DisplayName = 'Matt Parker' GROUP BY p.Id HAVING COUNT(v.Id) > 4;",
      "sql_without_rules": "SELECT COUNT(DISTINCT p.Id) FROM posts p JOIN users u ON p.OwnerUserId = u.Id JOIN votes v ON p.Id = v.PostId WHERE u.DisplayName = 'Matt Parker' GROUP BY p.Id HAVING COUNT(v.Id) > 4;",
      "sql_with_dataset_rules": "SELECT COUNT(DISTINCT T2.Id) FROM users T1 JOIN posts T2 ON T1.Id = T2.OwnerUserId JOIN postHistory T3 ON T2.Id = T3.PostId JOIN votes T4 ON T2.Id = T4.PostId WHERE T1.DisplayName = 'Matt Parker' GROUP BY T2.Id HAVING COUNT(T4.Id) > 4;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 54,
      "question": "How many British drivers who were born in 1980?",
      "ground_truth": "SELECT COUNT(driverId) FROM drivers WHERE nationality = 'British' AND STRFTIME('%Y', dob) = '1980'",
      "db_id": "formula_1",
      "generated_rules": "Rule 1:\nCondition: When the question asks about \"British drivers\"\nOperation: use \"nationality = 'British'\" instead of \"country = 'Britain'\" to filter for British nationality.",
      "dataset_rules": "No definitional rules found.",
      "sql_with_sft_rules": "SELECT COUNT(*) FROM drivers WHERE nationality = 'British' AND strftime('%Y', dob) = '1980';",
      "sql_without_rules": "SELECT COUNT(*) FROM drivers WHERE nationality = 'British' AND strftime('%Y', dob) = '1980';",
      "sql_with_dataset_rules": "SELECT COUNT(*) FROM drivers WHERE nationality = 'British' AND strftime('%Y', dob) = '1980';",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 55,
      "question": "Among the cards with a white border color, how many of them have unknown power?",
      "ground_truth": "SELECT SUM(CASE WHEN power LIKE '%*%' OR power IS NULL THEN 1 ELSE 0 END) FROM cards WHERE borderColor = 'white'",
      "db_id": "card_games",
      "generated_rules": "Rule 1:\nCondition: When the question asks about cards with a specific border color\nOperation: use the exact literal 'white' for borderColor comparison.\n\nRule 2:\nCondition: When the question asks about cards with unknown power\nOperation: use the exact literal 'unknown' for power comparison.",
      "dataset_rules": "Condition: When the question mentions \"white border color\"\nOperation: use the exact column token \"borderColor\" with literal value 'white' for filtering.",
      "sql_with_sft_rules": "SELECT COUNT(*) FROM cards WHERE borderColor = 'white' AND power = 'unknown';",
      "sql_without_rules": "SELECT COUNT(*) FROM cards WHERE borderColor = 'white' AND power IS NULL;",
      "sql_with_dataset_rules": "SELECT COUNT(*) FROM cards WHERE borderColor = 'white' AND power IS NULL;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 56,
      "question": "What percentage is Landon Donovan's overall rating higher than Jordan Bowery on 2013/7/12?",
      "ground_truth": "SELECT (SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Jordan Bowery' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) LvsJ_percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2013-07-12'",
      "db_id": "european_football_2",
      "generated_rules": "Rule 1:\nCondition: When the question asks for percentage difference between two players' overall ratings\nOperation: use conditional aggregation with SUM(CASE) to handle both players in a single query instead of cross-joining the same table twice.\n\nRule 2:\nCondition: When the question asks for percentage\nOperation: do not divide by 100.0 factor as the percentage calculation should return the decimal value directly.",
      "dataset_rules": "Condition: When referencing player names\nOperation: use T1.player_name from the Player table with exact literals 'Abdou Diallo' and 'Aaron Appindangoye' including proper capitalization and spacing.\n\nCondition: When referencing player names\nOperation: use the exact column token \"player_name\" from the appropriate table instead of assuming both exist in a single table.\n\nCondition: When answering about percentage difference between two players' ratings\nOperation: use a single Player table (alias t1) and a single Player_Attributes table (alias t2) joined together.\n\nCondition: When answering about percentage difference between two players' ratings\nOperation: use conditional aggregation with SUM(CASE WHEN) instead of direct column subtraction to handle multiple records.\n\nCondition: When referencing player names\nOperation: use exact column name \"player_name\" with literals 'Landon Donovan' and 'Jordan Bowery' exactly as specified.",
      "sql_with_sft_rules": "SELECT (SUM(CASE WHEN p.player_name = 'Landon Donovan' THEN pa.overall_rating ELSE 0 END) - SUM(CASE WHEN p.player_name = 'Jordan Bowery' THEN pa.overall_rating ELSE 0 END)) * 1.0 / SUM(CASE WHEN p.player_name = 'Jordan Bowery' THEN pa.overall_rating ELSE 0 END) * 100.0 AS percentage_difference FROM Player p JOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id WHERE p.player_name IN ('Landon Donovan', 'Jordan Bowery') AND pa.date = '2013-07-12';",
      "sql_without_rules": "SELECT ((donovan.overall_rating - bowery.overall_rating) * 100.0 / bowery.overall_rating) AS percentage_higher FROM Player_Attributes donovan JOIN Player p_donovan ON donovan.player_api_id = p_donovan.player_api_id JOIN Player_Attributes bowery ON bowery.date = donovan.date JOIN Player p_bowery ON bowery.player_api_id = p_bowery.player_api_id WHERE p_donovan.player_name = 'Landon Donovan' AND p_bowery.player_name = 'Jordan Bowery' AND donovan.date = '2013-07-12' AND bowery.date = '2013-07-12';",
      "sql_with_dataset_rules": "SELECT (SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) - SUM(CASE WHEN t1.player_name = 'Jordan Bowery' THEN t2.overall_rating ELSE 0 END)) * 100.0 / SUM(CASE WHEN t1.player_name = 'Jordan Bowery' THEN t2.overall_rating ELSE 0 END) AS percentage_difference FROM Player t1 JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name IN ('Landon Donovan', 'Jordan Bowery') AND t2.date = '2013-07-12';",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 57,
      "question": "What is the display name of the user who acquired the first Autobiographer badge?",
      "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.`Name` = 'Autobiographer' ORDER BY T2.Date LIMIT 1",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks for \"display name\"\nOperation: use the exact column token \"DisplayName\" from the users table.\n\nRule 2:\nCondition: When the question asks for \"display name\"\nOperation: use the exact column token \"DisplayName\" from the users table.\n\nRule 3:\nCondition: When the question asks for \"display name\"\nOperation: use the exact column token \"Name\" from the customers table.\n\nRule 4:\nCondition: When the question asks for \"display name\"\nOperation: use the exact column token \"Name\" from the customers table.\n\nRule 5:\nCondition: When the question asks for \"display name\"\nOperation: use the exact column token \"Name\" from the Customers table.\n\nRule 6:\nCondition: When the question asks for \"display name\"\nOperation: use the exact column token \"Name\" from the Customers table.\n\nRule 7:\nCondition: When the question asks for \"display name\"\nOperation: use the exact column token \"Name\" from the Customers table.\n\nRule 8:\nCondition: When the question asks for \"display name\"\nOperation: use the exact column token \"Name\" from the Customers table.\n\nRule 9:\nCondition: When the question asks for \"display name\"\nOperation",
      "dataset_rules": "No definitional rules found.",
      "sql_with_sft_rules": "SELECT u.DisplayName FROM users u JOIN badges b ON u.Id = b.UserId WHERE b.Name = 'Autobiographer' ORDER BY b.Date ASC LIMIT 1;",
      "sql_without_rules": "SELECT u.DisplayName FROM badges b JOIN users u ON b.UserId = u.Id WHERE b.Name = 'Autobiographer' ORDER BY b.Date ASC LIMIT 1;",
      "sql_with_dataset_rules": "SELECT u.DisplayName FROM badges b JOIN users u ON b.UserId = u.Id WHERE b.Name = 'Autobiographer' ORDER BY b.Date ASC LIMIT 1;",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 58,
      "question": "What is the eyes colour of Abraham Sapien?",
      "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.full_name = 'Abraham Sapien'",
      "db_id": "superhero",
      "generated_rules": "Rule 1:\nCondition: When the question asks for eye color\nOperation: select \"T2.Color\" from the \"Eyes\" table instead of \"eye_color\" from a single table.",
      "dataset_rules": "Condition: When the question asks about eye color\nOperation: join the superhero table (T1) with the colour table (T2) using T1.eye_colour_id = T2.id to get the actual color value from T2.colour instead of using T1.eye_color directly.\n\nCondition: When the question asks about eye color\nOperation: retrieve the \"colour\" column from table \"colour\" (aliased as T2) instead of \"eye_color\" from the \"characters\" table.",
      "sql_with_sft_rules": "SELECT c.colour FROM superhero s JOIN colour c ON s.eye_colour_id = c.id WHERE s.superhero_name = 'Abraham Sapien';",
      "sql_without_rules": "SELECT c.colour FROM superhero s JOIN colour c ON s.eye_colour_id = c.id WHERE s.superhero_name = 'Abraham Sapien';",
      "sql_with_dataset_rules": "SELECT c.colour FROM superhero s JOIN colour c ON s.eye_colour_id = c.id WHERE s.superhero_name = 'Abraham Sapien';",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 59,
      "question": "What are the race and alignment of Cameron Hicks?",
      "ground_truth": "SELECT T2.race, T3.alignment FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id INNER JOIN alignment AS T3 ON T1.alignment_id = T3.id WHERE T1.superhero_name = 'Cameron Hicks'",
      "db_id": "superhero",
      "generated_rules": "Rule 1:\nCondition: When the question asks for race and alignment of a character\nOperation: select T1.race and T2.alignment from the joined tables instead of directly from a single table.",
      "dataset_rules": "Condition: When the question mentions \"race\"\nOperation: \"race\" actually means \"T2.race\" in schema\n\nCondition: When answering about a character's race and alignment\nOperation: join table \"superhero\" as T1 with table \"race\" as T2 on T1.race_id = T2.id and with table \"alignment\" as T3 on T1.alignment_id = T3.id.\n\nCondition: When the question mentions \"race\"\nOperation: select T2.race instead of a direct column from the main table.\n\nCondition: When the question mentions \"alignment\"\nOperation: select T3.alignment instead of a direct column from the main table.\n\nCondition: When the question mentions \"race\"\nOperation: \"race\" actually means \"T3.name in schema\"\n\nCondition: When the question mentions \"race\"\nOperation: \"race\" actually means \"T1.name in schema\"\n\nCondition: When the question mentions \"race\"\nOperation: \"race\" actually means \"T2.name in schema\"",
      "sql_with_sft_rules": "SELECT r.race, a.alignment FROM superhero s JOIN race r ON s.race_id = r.id JOIN alignment a ON s.alignment_id = a.id WHERE s.superhero_name = 'Cameron Hicks';",
      "sql_without_rules": "SELECT r.race, a.alignment FROM superhero s JOIN race r ON s.race_id = r.id JOIN alignment a ON s.alignment_id = a.id WHERE s.superhero_name = 'Cameron Hicks';",
      "sql_with_dataset_rules": "SELECT T2.race, T3.alignment FROM superhero AS T1 JOIN race AS T2 ON T1.race_id = T2.id JOIN alignment AS T3 ON T1.alignment_id = T3.id WHERE T1.superhero_name = 'Cameron Hicks';",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 60,
      "question": "List all the name of users that obtained the Organizer Badges.",
      "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.`Name` = 'Organizer'",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks for \"name of users\"\nOperation: use \"DisplayName\" from the \"users\" table instead of \"name\" from \"users\".\n\nRule 2:\nCondition: When the question asks for \"name of users\"\nOperation: use \"T2.DisplayName\" from the \"users\" table instead of \"name\" from the \"users\" table.",
      "dataset_rules": "Condition: When answering about \"users that obtained the Organizer Badges\"\nOperation: make sure to combine the users table (as T1) and badges table (as T2) by linking rows where T1.Id equals T2.UserId, keeping only matching pairs.\n\nCondition: When the question mentions \"name of users\"\nOperation: \"name\" actually means \"T1.DisplayName\" in the schema.",
      "sql_with_sft_rules": "SELECT u.DisplayName FROM users u JOIN badges b ON u.Id = b.UserId WHERE b.Name = 'Organizer';",
      "sql_without_rules": "SELECT DISTINCT u.DisplayName FROM users u JOIN badges b ON u.Id = b.UserId WHERE b.Name = 'Organizer';",
      "sql_with_dataset_rules": "SELECT T1.DisplayName FROM users AS T1 JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Organizer';",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 61,
      "question": "Is the molecule with the most double bonds carcinogenic?",
      "ground_truth": "SELECT T1.label FROM molecule AS T1 INNER JOIN ( SELECT T.molecule_id, COUNT(T.bond_type) FROM bond AS T WHERE T.bond_type = '=' GROUP BY T.molecule_id ORDER BY COUNT(T.bond_type) DESC LIMIT 1 ) AS T2 ON T1.molecule_id = T2.molecule_id",
      "db_id": "toxicology",
      "generated_rules": "Rule 1:\nCondition: When the question asks about carcinogenicity\nOperation: use the \"toxicity\" column from the \"properties\" table instead of \"carcinogenic\" from \"molecules\".",
      "dataset_rules": "Condition: When answering about \"the molecule with the most double bonds\"\nOperation: make sure the output order: T1.label\n\nCondition: When the question mentions \"double bonds\"\nOperation: \"double bonds\" actually means \"bond_type = '=' in schema\"\n\nCondition: When the question asks for \"most double bonds\"\nOperation: rank rows by COUNT(T.bond_type) in descending direction and keep the first 1 row.",
      "sql_with_sft_rules": "SELECT p.toxicity FROM molecule m JOIN bond b ON m.molecule_id = b.molecule_id JOIN properties p ON m.molecule_id = p.molecule_id WHERE b.bond_type = 'double' GROUP BY m.molecule_id ORDER BY COUNT(b.bond_id) DESC LIMIT 1;",
      "sql_without_rules": "SELECT m.label = 'carcinogenic' AS is_carcinogenic FROM molecule m JOIN ( SELECT molecule_id, COUNT(*) AS double_bond_count FROM bond WHERE bond_type = 'double' GROUP BY molecule_id ORDER BY double_bond_count DESC LIMIT 1 ) most_double_bonds ON m.molecule_id = most_double_bonds.molecule_id;",
      "sql_with_dataset_rules": "SELECT m.label FROM molecule m JOIN bond b ON m.molecule_id = b.molecule_id WHERE b.bond_type = '=' GROUP BY m.molecule_id, m.label ORDER BY COUNT(b.bond_type) DESC LIMIT 1;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 62,
      "question": "How often does account number 3 request an account statement to be released? What was the aim of debiting 3539 in total?",
      "ground_truth": "SELECT T1.frequency, T2.k_symbol FROM account AS T1 INNER JOIN (SELECT account_id, k_symbol, SUM(amount) AS total_amount FROM `order` GROUP BY account_id, k_symbol) AS T2 ON T1.account_id = T2.account_id WHERE T1.account_id = 3 AND T2.total_amount = 3539",
      "db_id": "financial",
      "generated_rules": "Rule 1:\nCondition: When the question asks about account statement frequency\nOperation: use \"T1.frequency\" from the \"account\" table instead of \"statement_frequency\" from \"accounts\".\n\nRule 2:\nCondition: When the question asks about debiting amounts\nOperation: use \"T2.amount\" from the \"trans\" table instead of \"debit_amount\" from \"account_operations\".",
      "dataset_rules": "Condition: When answering about account statement release frequency and transaction purpose\nOperation: make sure the output order: T1.frequency, T2.k_symbol\n\nCondition: When the question mentions \"account number 3\"\nOperation: \"account number 3\" actually means T1.account_id = 3 in schema\n\nCondition: When the question asks for \"how often\" account statements are released\nOperation: use T1.frequency column instead of counting statement releases\n\nCondition: When the question asks for \"aim of debiting 3539 in total\"\nOperation: use T2.k_symbol column to show the purpose instead of summing transaction amounts",
      "sql_with_sft_rules": "SELECT a.frequency, t.amount FROM account a JOIN trans t ON a.account_id = t.account_id WHERE a.account_id = 3 AND t.amount = 3539 AND t.operation = 'DEBIT';",
      "sql_without_rules": "SELECT COUNT(*) AS statement_request_count, (SELECT k_symbol FROM trans WHERE account_id = 3 AND amount = 3539 LIMIT 1) AS debit_purpose FROM trans WHERE account_id = 3 AND k_symbol = 'POJISTNE';",
      "sql_with_dataset_rules": "SELECT T1.frequency, T2.k_symbol FROM account T1 JOIN trans T2 ON T1.account_id = T2.account_id WHERE T1.account_id = 3 AND T2.amount = 3539;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 63,
      "question": "Please list the patient's ID if he or she has an abnormal level of red blood cell and is followed at the outpatient clinic.",
      "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.RBC <= 3.5 OR T2.RBC >= 6) AND T1.Admission = '-'",
      "db_id": "thrombosis_prediction",
      "generated_rules": "Rule 1:\nCondition: When the question asks for patient's ID\nOperation: use the exact identifier \"ID\" from table \"Patient\" instead of \"patient_id\".",
      "dataset_rules": "Condition: When referencing columns from joined tables\nOperation: use qualified references like T2.language instead of unqualified column names.\n\nCondition: When answering about patients with abnormal red blood cell levels\nOperation: use numeric range comparison (T2.RBC <= 3.5 OR T2.RBC >=",
      "sql_with_sft_rules": "SELECT DISTINCT p.ID FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE l.RBC NOT BETWEEN 4.0 AND 6.0 AND p.Admission = 'Outpatient';",
      "sql_without_rules": "SELECT DISTINCT p.ID FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE l.RBC NOT BETWEEN 4.0 AND 6.0 AND p.Admission = 'Outpatient';",
      "sql_with_dataset_rules": "SELECT DISTINCT T1.ID FROM Patient T1 JOIN Laboratory T2 ON T1.ID = T2.ID WHERE (T2.RBC <= 3.5 OR T2.RBC >= 5.5) AND T1.Admission = 'Outpatient';",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 64,
      "question": "What is the biggest amount of transaction that the client whose card was opened in 1996/10/21 made?",
      "ground_truth": "SELECT T4.amount FROM card AS T1 JOIN disp AS T2 ON T1.disp_id = T2.disp_id JOIN account AS T3 on T2.account_id = T3.account_id JOIN trans AS T4 on T3.account_id = T4.account_id WHERE T1.issued = '1996-10-21' ORDER BY T4.amount DESC LIMIT 1",
      "db_id": "financial",
      "generated_rules": "Rule 1:\nCondition: When the question asks about transactions for a client\nOperation: join client table as T1 with disp table as T2 using T1.client_id = T2.client_id to link client information with their accounts.",
      "dataset_rules": "No definitional rules found.",
      "sql_with_sft_rules": "SELECT MAX(t.amount) FROM client c JOIN disp d ON c.client_id = d.client_id JOIN account a ON d.account_id = a.account_id JOIN trans t ON a.account_id = t.account_id JOIN card cd ON d.disp_id = cd.disp_id WHERE cd.issued = '1996-10-21';",
      "sql_without_rules": "SELECT MAX(t.amount) FROM trans t JOIN account a ON t.account_id = a.account_id JOIN disp d ON a.account_id = d.account_id JOIN card c ON d.disp_id = c.disp_id WHERE c.issued = '1996-10-21';",
      "sql_with_dataset_rules": "SELECT MAX(t.amount) FROM trans t JOIN account a ON t.account_id = a.account_id JOIN disp d ON a.account_id = d.account_id JOIN card c ON d.disp_id = c.disp_id WHERE c.issued = '1996-10-21';",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 65,
      "question": "Who is the tallest superhero?",
      "ground_truth": "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1",
      "db_id": "superhero",
      "generated_rules": "Rule 1:\nCondition: When answering about \"tallest superhero\"\nOperation: make sure the output order: superhero_name only.\n\nRule 2:\nCondition: When the question mentions \"tallest\"\nOperation: \"tallest\" actually means \"maximum height_cm in superhero table\".",
      "dataset_rules": "Condition: When the question asks about superheroes\nOperation: use the exact column \"superhero_name\" from table \"superhero\" instead of \"name\" from \"superheroes\".\n\nCondition: When the question asks about superheroes\nOperation: use table \"superhero\" instead of \"superheroes\".\n\nCondition: When the question asks for a superhero's name\nOperation: use column \"superhero_name\" instead of \"name\".\n\nCondition: When the question asks about height\nOperation: use column \"height_cm\" instead of \"height\".",
      "sql_with_sft_rules": "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1;",
      "sql_without_rules": "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1;",
      "sql_with_dataset_rules": "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1;",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 66,
      "question": "What is the disease patient '30609' diagnosed with. List all the date of laboratory tests done for this patient.",
      "ground_truth": "SELECT T1.Diagnosis, T2.Date FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID = 30609",
      "db_id": "thrombosis_prediction",
      "generated_rules": "Rule 1:\nCondition: When the question asks about a patient's diagnosis and laboratory test dates\nOperation: select \"Diagnosis\" from the \"Examination\" table and \"Date\" from the \"Laboratory\" table.",
      "dataset_rules": "Condition: When the question asks for disease diagnosis and laboratory test dates for a specific patient\nOperation: select \"Diagnosis\" from table \"Patient\" and \"Date\" from table \"Laboratory\" as output columns.",
      "sql_with_sft_rules": "SELECT e.Diagnosis, l.Date FROM Examination e JOIN Laboratory l ON e.ID = l.ID WHERE e.ID = 30609;",
      "sql_without_rules": "SELECT l.Date, p.Diagnosis FROM Laboratory l JOIN Patient p ON l.ID = p.ID WHERE l.ID = 30609 ORDER BY l.Date;",
      "sql_with_dataset_rules": "SELECT p.Diagnosis, l.Date FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE p.ID = 30609;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 67,
      "question": "What was the fastest lap speed among all drivers in the 2009 Spanish Grand Prix?",
      "ground_truth": "SELECT T2.fastestLapSpeed FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.name = 'Spanish Grand Prix' AND T1.year = 2009 AND T2.fastestLapSpeed IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
      "db_id": "formula_1",
      "generated_rules": "Rule 1:\nCondition: When answering about fastest lap speed\nOperation: make sure the output order: MAX(T1.fastestLapSpeed).\n\nRule 2:\nCondition: When the question mentions \"2009 Spanish Grand Prix\"\nOperation: \"2009 Spanish Grand Prix\" actually means T2.name = 'Spanish Grand Prix' AND T2.year = 2009 in schema.",
      "dataset_rules": "Condition: When answering about fastest lap speed\nOperation: use column \"fastestLapSpeed\" from table \"results\" instead of \"lap_time\" from \"lap_times\".",
      "sql_with_sft_rules": "SELECT MAX(results.fastestLapSpeed) FROM results JOIN races ON results.raceId = races.raceId WHERE races.name = 'Spanish Grand Prix' AND races.year = 2009;",
      "sql_without_rules": "SELECT MAX(r.fastestLapSpeed) FROM results r JOIN races rc ON r.raceId = rc.raceId WHERE rc.year = 2009 AND rc.name = 'Spanish Grand Prix';",
      "sql_with_dataset_rules": "SELECT MAX(r.fastestLapSpeed) FROM results r JOIN races rc ON r.raceId = rc.raceId WHERE rc.year = 2009 AND rc.name = 'Spanish Grand Prix';",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 68,
      "question": "How many users are awarded with more than 5 badges?",
      "ground_truth": "SELECT COUNT(UserId) FROM ( SELECT UserId, COUNT(Name) AS num FROM badges GROUP BY UserId ) T WHERE T.num > 5",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks about \"users\"\nOperation: use table \"users\" with alias T1.\n\nRule 2:\nCondition: When the question asks about \"users\"\nOperation: use table \"users\" with alias T1 instead of \"users\".\n\nRule 3:\nCondition: When the question asks about \"users\"\nOperation: use table \"users\" with alias T1.\n\nRule 4:\nCondition: When the question asks about \"users\" and \"badges\"\nOperation: combine the \"users\" table (T1) and \"badges\" table (T2) by linking rows where T1.Id equals T2.UserId, keeping only matching pairs.\n\nRule 5:\nCondition: When the question asks about \"users\"\nOperation: use table \"users\" instead of \"user\" to match the correct schema table name.\n\nRule 6:\nCondition: When the question asks about \"users\"\nOperation: use the \"users\" table instead of \"user\" to reference the correct table name.",
      "dataset_rules": "No definitional rules found.",
      "sql_with_sft_rules": "SELECT COUNT(DISTINCT T1.Id) FROM users T1 JOIN badges T2 ON T1.Id = T2.UserId GROUP BY T1.Id HAVING COUNT(T2.Id) > 5;",
      "sql_without_rules": "SELECT COUNT(*) FROM ( SELECT UserId FROM badges GROUP BY UserId HAVING COUNT(*) > 5 );",
      "sql_with_dataset_rules": "SELECT COUNT(*) FROM ( SELECT UserId FROM badges GROUP BY UserId HAVING COUNT(*) > 5 ) AS badge_counts;",
      "result_with_sft_rules": 0,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 69,
      "question": "How many credit card withdrawals were recorded after 1995?",
      "ground_truth": "SELECT COUNT(account_id) FROM trans WHERE STRFTIME('%Y', date) > '1995' AND operation = 'VYBER KARTOU'",
      "db_id": "financial",
      "generated_rules": "Rule 1:\nCondition: When the question asks about \"credit card withdrawals\"\nOperation: use table \"trans\" instead of \"account\" and filter on \"type = 'Withdrawal'\" instead of \"type = 'withdrawal'\".",
      "dataset_rules": "Condition: When referencing the transactions table\nOperation: use table name \"trans\" instead of \"transactions\" to match the correct schema.",
      "sql_with_sft_rules": "SELECT COUNT(*) FROM trans WHERE type = 'Withdrawal' AND date > '1995-12-31' AND operation = 'Credit Card Withdrawal';",
      "sql_without_rules": "SELECT COUNT(*) FROM trans WHERE type = 'WITHDRAWAL' AND operation = 'CREDIT CARD WITHDRAWAL' AND date > '1995-12-31';",
      "sql_with_dataset_rules": "SELECT COUNT(*) FROM trans WHERE type = 'WITHDRAWAL' AND k_symbol = 'CREDIT CARD WITHDRAWAL' AND date > '1995-12-31';",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 70,
      "question": "What is the administrator's email address of the chartered school with the fewest students enrolled in grades 1 through 12?",
      "ground_truth": "SELECT T2.AdmEmail1 FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`Charter School (Y/N)` = 1 ORDER BY T1.`Enrollment (K-12)` ASC LIMIT 1",
      "db_id": "california_schools",
      "generated_rules": "Rule 1:\nCondition: When the question asks for administrator's email address\nOperation: select \"AdmEmail1\" from the \"schools\" table instead of \"email\" from \"administrators\".",
      "dataset_rules": "Condition: When answering about administrator email addresses\nOperation: select T2.AdmEmail1 instead of email from administrators table.",
      "sql_with_sft_rules": "SELECT s.AdmEmail1 FROM schools s JOIN frpm f ON s.CDSCode = f.CDSCode WHERE s.Charter = 1 ORDER BY f.\"Enrollment (K-12)\" ASC LIMIT 1;",
      "sql_without_rules": "SELECT s.AdmEmail1 FROM schools s JOIN frpm f ON s.CDSCode = f.CDSCode WHERE s.Charter = 1 AND f.`Enrollment (K-12)` IS NOT NULL ORDER BY f.`Enrollment (K-12)` ASC LIMIT 1;",
      "sql_with_dataset_rules": "SELECT s.AdmEmail1 FROM schools s JOIN frpm f ON s.CDSCode = f.CDSCode WHERE s.Charter = 1 AND f.`Enrollment (K-12)` IS NOT NULL ORDER BY f.`Enrollment (K-12)` ASC LIMIT 1;",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 71,
      "question": "Of the patients with an normal level of IGG, how many of them admitted to the hospital?",
      "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGG > 900 AND T2.IGG <2000 AND  T1.Admission = '+'",
      "db_id": "thrombosis_prediction",
      "generated_rules": "Rule 1:\nCondition: When the question asks about patients with normal IGG levels\nOperation: use the exact condition IGG = 'Normal' from the Laboratory table instead of numeric comparisons.",
      "dataset_rules": "No definitional rules found.",
      "sql_with_sft_rules": "SELECT COUNT(DISTINCT p.ID) FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE l.IGG = 'Normal' AND p.Admission IS NOT NULL;",
      "sql_without_rules": "SELECT COUNT(DISTINCT p.ID) FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE l.IGG IS NOT NULL AND l.IGG BETWEEN 870 AND 1700 AND p.Admission = 'yes';",
      "sql_with_dataset_rules": "SELECT COUNT(DISTINCT p.ID) FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE l.IGG IS NOT NULL AND l.IGG BETWEEN 870 AND 1700 AND p.Admission IS NOT NULL;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 72,
      "question": "Pick 3 cards with rarity of uncommon, list down name these cards according to ascending order of it's ruling date.",
      "ground_truth": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'uncommon' ORDER BY T2.date ASC LIMIT 3",
      "db_id": "card_games",
      "generated_rules": "Rule 1:\nCondition: When the question asks for card names\nOperation: select \"T2\".\"name\" from the \"cards\" table instead of \"card_name\" from a non-existent \"cards\" table.\n\nRule 2:\nCondition: When the question asks for card names\nOperation: select \"T2\".\"name\" from the \"cards\" table instead of \"card_name\" from a non-existent \"cards\" table.\n\nRule 3:\nCondition: When the question asks for card names\nOperation: select \"T1.name\" from the \"cards\" table instead of \"card_name\" from a non-existent \"cards\" table.\n\nRule 4:\nCondition: When the question asks for card names\nOperation: select \"T1.name\" from the \"cards\" table instead of \"card_name\" from a non-existent \"cards\" table.\n\nRule 5:\nCondition: When the question asks for card names\nOperation: select \"T3\".\"name\" from the \"cards\" table instead of \"card_name\" from a non-existent \"cards\" table.\n\nRule 6:\nCondition: When the question asks for card names\nOperation: select \"T3\".\"name\" from the \"cards\" table instead of \"card_name\" from a non",
      "dataset_rules": "Condition: When the question asks for cards with rarity of 'uncommon'\nOperation: filter rows where T1.rarity equals exactly 'uncommon'.\n\nCondition: When the question asks for distinct card names\nOperation: ensure only unique values of T1.name are returned.\n\nCondition: When the question requires ascending order of ruling date\nOperation: sort results by T2.date in ascending order.\n\nCondition: When the question asks for top 3 cards\nOperation: keep only the first 3 rows after sorting.",
      "sql_with_sft_rules": "SELECT c.name FROM cards c JOIN rulings r ON c.uuid = r.uuid WHERE c.rarity = 'uncommon' GROUP BY c.uuid ORDER BY MIN(r.date) ASC LIMIT 3;",
      "sql_without_rules": "SELECT c.name FROM cards c JOIN rulings r ON c.uuid = r.uuid WHERE c.rarity = 'uncommon' GROUP BY c.name ORDER BY MIN(r.date) ASC LIMIT 3;",
      "sql_with_dataset_rules": "SELECT DISTINCT T1.name FROM cards T1 JOIN rulings T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'uncommon' ORDER BY T2.date ASC LIMIT 3;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 73,
      "question": "Calculate the average height for each superhero.",
      "ground_truth": "SELECT CAST(SUM(height_cm) AS REAL) / COUNT(id) FROM superhero",
      "db_id": "superhero",
      "generated_rules": "No definitional rules found.",
      "dataset_rules": "Condition: When referencing the superhero table\nOperation: use the exact table name \"superhero\" instead of \"superheroes\".",
      "sql_with_sft_rules": "SELECT superhero_name, AVG(height_cm) AS average_height FROM superhero GROUP BY id;",
      "sql_without_rules": "SELECT superhero_name, height_cm FROM superhero;",
      "sql_with_dataset_rules": "SELECT superhero_name, AVG(height_cm) AS average_height FROM superhero GROUP BY id;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 74,
      "question": "What is the keyword found on card 'Angel of Mercy'?",
      "ground_truth": "SELECT DISTINCT keywords FROM cards WHERE name = 'Angel of Mercy'",
      "db_id": "card_games",
      "generated_rules": "Rule 1:\nCondition: When the question asks about a specific card by name\nOperation: use the exact literal 'Angel of Mercy' to filter on T1.name.",
      "dataset_rules": "Condition: When the question asks for \"keyword\" from a specific card\nOperation: use the exact column name \"keywords\" from the cards table instead of \"keyword\".",
      "sql_with_sft_rules": "SELECT keywords FROM cards WHERE name = 'Angel of Mercy';",
      "sql_without_rules": "SELECT keywords FROM cards WHERE name = 'Angel of Mercy';",
      "sql_with_dataset_rules": "SELECT keywords FROM cards WHERE name = 'Angel of Mercy';",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 75,
      "question": "What is the language of the \"Battlebond\" set?",
      "ground_truth": "SELECT language FROM set_translations WHERE id IN ( SELECT id FROM sets WHERE name = 'Battlebond' )",
      "db_id": "card_games",
      "generated_rules": "Rule 1:\nCondition: When the question asks about the language of a set\nOperation: use the \"language\" column from the \"sets\" table instead of any \"language\" column from the \"cards\" table.",
      "dataset_rules": "Condition: When answering about the language of a specific set\nOperation: query the \"set_translations\" table instead of the \"sets\" table.",
      "sql_with_sft_rules": "SELECT DISTINCT language FROM set_translations WHERE setCode = 'Battlebond';",
      "sql_without_rules": "SELECT DISTINCT st.language FROM set_translations st WHERE st.setCode = (SELECT code FROM sets WHERE name = 'Battlebond');",
      "sql_with_dataset_rules": "SELECT DISTINCT language FROM set_translations WHERE setCode = 'Battlebond';",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 76,
      "question": "What are the names of the superheroes with the power of death touch?",
      "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Death Touch'",
      "db_id": "superhero",
      "generated_rules": "Rule 1:\nCondition: When the question asks for superhero names\nOperation: use \"T1.superhero_name\" as the output column instead of \"name\".",
      "dataset_rules": "Condition: When the question mentions \"superheroes\"\nOperation: \"superheroes\" actually means \"superhero AS T1\" in schema.\n\nCondition: When the question mentions \"superheroes\"\nOperation: \"superheroes\" actually means \"T1.id in schema\" for counting purposes.\n\nCondition: When the question mentions \"superheroes\"\nOperation: \"superheroes\" actually means \"T1\" in schema.\n\nCondition: When answering about \"names of superheroes with the power of death touch\"\nOperation: make sure the output order: T1.superhero_name.\n\nCondition: When the question mentions \"superheroes\"\nOperation: use table \"superheroes\" as T1 with column \"superhero_name\" for names.\n\nCondition: When the question mentions \"power of death touch\"\nOperation: this actually means \"T3.power_name = 'Death Touch'\" in the schema with exact case sensitivity.\n\nCondition: When the question mentions \"superheroes\"\nOperation: \"superheroes\" actually means \"superhero\" table in schema.\n\nCondition: When the question mentions \"superheroes\"\nOperation: \"superheroes\" actually means \"superhero\" table as T1 and \"hero_attribute\" table as T2 in schema.",
      "sql_with_sft_rules": "SELECT T1.superhero_name FROM superhero T1 JOIN hero_power T2 ON T1.id = T2.hero_id JOIN superpower T3 ON T2.power_id = T3.id WHERE T3.power_name = 'death touch';",
      "sql_without_rules": "SELECT s.superhero_name FROM superhero s JOIN hero_power hp ON s.id = hp.hero_id JOIN superpower sp ON hp.power_id = sp.id WHERE sp.power_name = 'death touch';",
      "sql_with_dataset_rules": "SELECT T1.superhero_name FROM superhero AS T1 JOIN hero_power AS T2 ON T1.id = T2.hero_id JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Death Touch';",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 77,
      "question": "Please provide the National Center for Educational Statistics school district identification number for all schools with a School Ownership Code that are part of the State Special Schools.",
      "ground_truth": "SELECT NCESDist FROM schools WHERE SOC = 31",
      "db_id": "california_schools",
      "generated_rules": "Rule 1:\nCondition: When the question asks for \"National Center for Educational Statistics school district identification number\"\nOperation: use the exact column token \"NCESDist\" from the schools table.",
      "dataset_rules": "Condition: When the question asks for \"National Center for Educational Statistics school district identification number\"\nOperation: select the exact column \"NCESDist\" from the schools table.\n\nCondition: When the question mentions schools with a \"School Ownership Code\"\nOperation: filter using the exact literal value 31 for the SOC column (SOC = 31).",
      "sql_with_sft_rules": "SELECT NCESDist FROM schools WHERE SOC IS NOT NULL AND SOCType = 'State Special Schools';",
      "sql_without_rules": "SELECT DISTINCT s.NCESDist FROM schools s WHERE s.SOC IS NOT NULL AND s.DOC = 'State Special Schools';",
      "sql_with_dataset_rules": "SELECT NCESDist FROM schools WHERE SOC = '31';",
      "result_with_sft_rules": 1,
      "result_without_rules": 0,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 78,
      "question": "Calculate the percentage whereby Hamilton was not at the 1st track of the the f1 circuit since 2010.",
      "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.position <> 1 THEN T2.position END) AS REAL) * 100 / COUNT(T2.driverStandingsId) FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.surname = 'Hamilton' AND T1.year >= 2010",
      "db_id": "formula_1",
      "generated_rules": "No definitional rules found.",
      "dataset_rules": "No definitional rules found.",
      "sql_with_sft_rules": "SELECT (COUNT(*) - SUM(CASE WHEN r.position = 1 THEN 1 ELSE 0 END)) * 100.0 / COUNT(*) AS percentage_not_first FROM results r JOIN drivers d ON r.driverId = d.driverId JOIN races rc ON r.raceId = rc.raceId WHERE d.surname = 'Hamilton' AND rc.year >= 2010;",
      "sql_without_rules": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(DISTINCT year) FROM races WHERE year >= 2010)) AS percentage FROM races r WHERE r.year >= 2010 AND r.round = 1 AND r.raceId NOT IN ( SELECT DISTINCT r2.raceId FROM races r2 JOIN results res ON r2.raceId = res.raceId JOIN drivers d ON res.driverId = d.driverId WHERE r2.year >= 2010 AND r2.round = 1 AND d.surname = 'Hamilton' );",
      "sql_with_dataset_rules": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM races WHERE year >= 2010)) AS percentage_not_first_track FROM races r WHERE r.year >= 2010 AND r.raceId NOT IN ( SELECT r2.raceId FROM races r2 JOIN results res ON r2.raceId = res.raceId JOIN drivers d ON res.driverId = d.driverId WHERE d.surname = 'Hamilton' AND r2.year >= 2010 AND res.position = 1 );",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 79,
      "question": "What are the bond type for atoms with element Tin?",
      "ground_truth": "SELECT DISTINCT T3.bond_type FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T3.bond_id = T2.bond_id WHERE T1.element = 'sn'",
      "db_id": "toxicology",
      "generated_rules": "Rule 1:\nCondition: When the question asks for bond types for atoms with element Tin\nOperation: use \"T1.bond_type\" from the \"bond\" table instead of \"bond_type\" from the \"atom\" table.",
      "dataset_rules": "Condition: When the question asks for bond types for atoms with element Tin\nOperation: use the exact element symbol 'sn' instead of 'Tin' for filtering.",
      "sql_with_sft_rules": "SELECT DISTINCT bond.bond_type FROM atom JOIN connected ON atom.atom_id = connected.atom_id OR atom.atom_id = connected.atom_id2 JOIN bond ON connected.bond_id = bond.bond_id WHERE atom.element = 'Tin';",
      "sql_without_rules": "SELECT DISTINCT b.bond_type FROM atom a1 JOIN connected c ON a1.atom_id = c.atom_id OR a1.atom_id = c.atom_id2 JOIN bond b ON c.bond_id = b.bond_id WHERE a1.element = 'Tin';",
      "sql_with_dataset_rules": "SELECT DISTINCT b.bond_type FROM atom a1 JOIN connected c ON a1.atom_id = c.atom_id OR a1.atom_id = c.atom_id2 JOIN bond b ON c.bond_id = b.bond_id WHERE a1.element = 'sn';",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 80,
      "question": "Among the members who incurred expenses in more than one event, who paid the most amount?",
      "ground_truth": "SELECT T2.member_id FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN budget AS T3 ON T1.link_to_budget = T3.budget_id INNER JOIN event AS T4 ON T3.link_to_event = T4.event_id GROUP BY T2.member_id HAVING COUNT(DISTINCT T4.event_id) > 1 ORDER BY SUM(T1.cost) DESC LIMIT 1",
      "db_id": "student_club",
      "generated_rules": "Rule 1:\nCondition: When answering about members who incurred expenses in more than one event\nOperation: use a subquery to find member_id values where the count of distinct event_id from expense table is greater than 1.\n\nRule 2:\nCondition: When the question asks for who paid the most amount\nOperation: select only the member_id column instead of all columns.",
      "dataset_rules": "Condition: When combining tables for this question\nOperation: use INNER JOIN instead of implicit JOIN for clarity.\n\nCondition: When combining tables for this question\nOperation: join disp AS T1, card AS T2, and client AS T3 with INNER JOIN conditions instead of querying only the clients table.\n\nCondition: When combining tables for this question\nOperation: link postHistory as T1 with posts as T2 where T1.\"PostId\" = T2.\"Id\", and link posts as T2 with users as T3 where T2.\"LastEditorUserId\" = T3.\"Id\".\n\nCondition: When combining tables for this question\nOperation: use FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member to link expense, member, and attendance tables.\n\nCondition: When answering about members who incurred expenses in more than one event\nOperation: use expense as T1, member as T2, budget as T3, and event as T4 with the exact aliases shown in the amends.\n\nCondition: When answering about members who incurred expenses in more than one event\nOperation: use expense as T1, member as T2, budget as T3, and event as T4 with the exact aliases shown in the amends.\n\nCondition: When answering about members who incurred expenses in more than one event\nOperation: only include T2.member_id in the final output columns, not SUM(T1.cost).\n\nCondition: When answering about members who incurred expenses in more than one event\nOperation: only include T2.member_id in the final output columns, not SUM(T1.cost).\n\nCondition: When combining tables for this question\nOperation: use explicit INNER JOIN syntax instead of implicit JOIN syntax for clarity.\n\nCondition: When combining tables for this question\nOperation: link transactions as T1 with gasstations as T2 using T1.GasStationID = T2.GasStationID and with customers as T3 using T1.CustomerID = T3.CustomerID, keeping only matching pairs (inner match).",
      "sql_with_sft_rules": "SELECT link_to_member FROM expense WHERE link_to_member IN ( SELECT link_to_member FROM expense e JOIN budget b ON e.link_to_budget = b.budget_id GROUP BY link_to_member HAVING COUNT(DISTINCT b.link_to_event) > 1 ) GROUP BY link_to_member ORDER BY SUM(cost) DESC LIMIT 1;",
      "sql_without_rules": "SELECT m.member_id, m.first_name, m.last_name, SUM(e.cost) AS total_expense FROM member m JOIN expense e ON m.member_id = e.link_to_member JOIN budget b ON e.link_to_budget = b.budget_id WHERE m.member_id IN ( SELECT m2.member_id FROM member m2 JOIN expense e2 ON m2.member_id = e2.link_to_member JOIN budget b2 ON e2.link_to_budget = b2.budget_id GROUP BY m2.member_id HAVING COUNT(DISTINCT b2.link_to_event) > 1 ) GROUP BY m.member_id, m.first_name, m.last_name ORDER BY total_expense DESC LIMIT 1;",
      "sql_with_dataset_rules": "SELECT T2.member_id FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN budget AS T3 ON T1.link_to_budget = T3.budget_id INNER JOIN event AS T4 ON T3.link_to_event = T4.event_id GROUP BY T2.member_id HAVING COUNT(DISTINCT T4.event_id) > 1 ORDER BY SUM(T1.cost) DESC LIMIT 1;",
      "result_with_sft_rules": 1,
      "result_without_rules": 0,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 81,
      "question": "Please list the Formula_1 races that Lewis Hamilton participated.",
      "ground_truth": "SELECT T1.name FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'",
      "db_id": "formula_1",
      "generated_rules": "Rule 1:\nCondition: When answering about Formula_1 races that Lewis Hamilton participated\nOperation: make sure the output order: T2.name.\n\nRule 2:\nCondition: When the question mentions \"Lewis Hamilton\"\nOperation: \"Lewis Hamilton\" actually means T3.surname = 'Hamilton' AND T3.forename = 'Lewis' in schema.",
      "dataset_rules": "Condition: When the question mentions \"Lewis Hamilton\"\nOperation: filter by T3.forename = 'Lewis' AND T3.surname = 'Hamilton' instead of driver_name = 'Lewis Hamilton'.\n\nCondition: When the question mentions \"Lewis Hamilton\"\nOperation: \"Lewis Hamilton\" actually means \"T3.forename = 'Lewis' AND T3.surname = 'Hamilton'\" in schema.\n\nCondition: When the question mentions \"Lewis Hamilton\"\nOperation: \"Lewis Hamilton\" actually means \"T1.forename = 'Lewis' AND T1.surname = 'Hamilton' in schema\".\n\nCondition: When answering about \"Formula_1 races that Lewis Hamilton participated\"\nOperation: make sure the output order: T1.name.\n\nCondition: When the question mentions \"Lewis Hamilton\"\nOperation: \"Lewis Hamilton\" actually means \"T3.forename = 'Lewis' and T3.surname = 'Hamilton'\" in schema.\n\nCondition: When the question mentions \"Lewis Hamilton\"\nOperation: this corresponds to filtering drivers where forename = 'Lewis' AND surname = 'Hamilton' in the \"drivers\" table.\n\nCondition: When the question mentions \"Lewis Hamilton\"\nOperation: \"Lewis Hamilton\" actually means \"T3.forename = 'Lewis' AND T3.surname = 'Hamilton'\" in schema.\n\nCondition: When the question mentions \"Lewis Hamilton\"\nOperation: use T3.forename = 'Lewis' AND T3.surname = 'Hamilton' for filtering.\n\nCondition: When the question mentions \"Lewis Hamilton\"\nOperation: filter using both T1.forename = 'Lewis' and T1.surname = 'Hamilton' to match the driver's full name.\n\nCondition: When the question mentions \"Lewis Hamilton\"\nOperation: \"Lewis Hamilton\" actually means \"T2.forename = 'Lewis' AND T2.surname = 'Hamilton' in schema\".\n\nCondition: When the question mentions \"Lewis Hamilton\"\nOperation: \"Lewis Hamilton\" actually means \"T2.forename = 'Lewis' AND T2.surname = 'Hamilton'\" in schema.",
      "sql_with_sft_rules": "SELECT DISTINCT races.name FROM races JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE drivers.surname = 'Hamilton' AND drivers.forename = 'Lewis' ORDER BY races.name;",
      "sql_without_rules": "SELECT DISTINCT r.name FROM races r JOIN results res ON r.raceId = res.raceId JOIN drivers d ON res.driverId = d.driverId WHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';",
      "sql_with_dataset_rules": "SELECT DISTINCT races.name FROM races JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton' ORDER BY races.name;",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 82,
      "question": "What is Ajax's highest chance creation passing score and what is it classified as?",
      "ground_truth": "SELECT t2.chanceCreationPassing, t2.chanceCreationPassingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Ajax' ORDER BY t2.chanceCreationPassing DESC LIMIT 1",
      "db_id": "european_football_2",
      "generated_rules": "Rule 1:\nCondition: When the question asks about \"Ajax's highest chance creation passing score\"\nOperation: use the exact column token \"chanceCreationPassing\" from table Team_Attributes to find the maximum value.\n\nRule 2:\nCondition: When the question asks for what the highest score is classified as\nOperation: use the exact column token \"chanceCreationPassingClass\" from table Team_Attributes to get the classification.",
      "dataset_rules": "Condition: When the question asks about a team's highest chance creation passing score\nOperation: select t2.chanceCreationPassing and t2.chanceCreationPassingClass instead of using MAX aggregation on a different column.\n\nCondition: When the question mentions a team name like 'Ajax'\nOperation: filter on t1.team_long_name = 'Ajax' exactly as written, not on player_name.",
      "sql_with_sft_rules": "SELECT MAX(ta.chanceCreationPassing) AS highest_chance_creation_passing, ta.chanceCreationPassingClass FROM Team_Attributes ta JOIN Team t ON ta.team_api_id = t.team_api_id WHERE t.team_long_name = 'Ajax';",
      "sql_without_rules": "SELECT MAX(ta.chanceCreationPassing) AS highest_chance_creation_passing, ta.chanceCreationPassingClass FROM Team_Attributes ta JOIN Team t ON ta.team_api_id = t.team_api_id WHERE t.team_long_name = 'Ajax';",
      "sql_with_dataset_rules": "SELECT t2.chanceCreationPassing, t2.chanceCreationPassingClass FROM Team t1 JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Ajax' ORDER BY t2.chanceCreationPassing DESC LIMIT 1;",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 83,
      "question": "List all patients who were born in 1937 whose total cholesterol was beyond the normal range.",
      "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1937' AND T2.`T-CHO` >= 250",
      "db_id": "thrombosis_prediction",
      "generated_rules": "Rule 1:\nCondition: When the question asks about patients\nOperation: use the exact table name \"patient\" instead of \"patients\".\n\nRule 2:\nCondition: When the question asks about patients\nOperation: use the exact table name \"patient\" instead of \"patients\".\n\nRule 3:\nCondition: When the question asks about patients\nOperation: use the table \"patient\" instead of \"patients\" as the data source.\n\nRule 4:\nCondition: When the question asks about patients\nOperation: use the table \"patient\" instead of \"patients\" as the data source.\n\nRule 5:\nCondition: When the question asks about patients\nOperation: use the exact table name \"patient\" instead of \"patients\".\n\nRule 6:\nCondition: When the question asks about patients\nOperation: use the exact table name \"patient\" instead of \"patients\".\n\nRule 7:\nCondition: When the question asks about patients\nOperation: use the table \"patient\" instead of \"patients\" as the data source.\n\nRule 8:\nCondition: When the question asks about patients\nOperation: use the table \"patient\" instead of \"patients\" as the data source.\n\nRule 9:\nCondition: When the question asks about patients and their laboratory results\nOperation: combine",
      "dataset_rules": "Condition: When answering about patients born in a specific year\nOperation: use STRFTIME('%Y', T1.Birthday) = '1937' to filter by birth year with exact date formatting.\n\nCondition: When referring to tables\nOperation: use Patient AS T1 and Examination AS T2 instead of patients, tests, and diagnoses tables.",
      "sql_with_sft_rules": "SELECT DISTINCT p.ID FROM patient p JOIN Laboratory l ON p.ID = l.ID WHERE strftime('%Y', p.Birthday) = '1937' AND l.`T-CHO` IS NOT NULL AND (l.`T-CHO` < 150 OR l.`T-CHO` > 200);",
      "sql_without_rules": "SELECT DISTINCT p.ID FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE strftime('%Y', p.Birthday) = '1937' AND l.`T-CHO` IS NOT NULL AND (l.`T-CHO` < 150 OR l.`T-CHO` > 200);",
      "sql_with_dataset_rules": "SELECT DISTINCT T1.ID FROM Patient AS T1 JOIN Laboratory AS T3 ON T1.ID = T3.ID WHERE STRFTIME('%Y', T1.Birthday) = '1937' AND T3.`T-CHO` NOT BETWEEN 150 AND 200;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 84,
      "question": "Among the users who have more than 100 upvotes, how many of them have more then 1 downvotes?",
      "ground_truth": "SELECT COUNT(Id) FROM users WHERE Upvotes > 100 AND Downvotes > 1",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks about users with upvotes and downvotes\nOperation: use the \"users\" table instead of \"votes\" table to access the correct data.",
      "dataset_rules": "No definitional rules found.",
      "sql_with_sft_rules": "SELECT COUNT(*) FROM users WHERE UpVotes > 100 AND DownVotes > 1;",
      "sql_without_rules": "SELECT COUNT(*) FROM users WHERE UpVotes > 100 AND DownVotes > 1;",
      "sql_with_dataset_rules": "SELECT COUNT(*) FROM users WHERE UpVotes > 100 AND DownVotes > 1;",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 85,
      "question": "How many members have education major in the College of Education & Human Services?",
      "ground_truth": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.position = 'Member' AND T2.major_name LIKE '%Education%' AND T2.college = 'College of Education & Human Services'",
      "db_id": "student_club",
      "generated_rules": "Rule 1:\nCondition: When the question asks about members with education major\nOperation: use the exact literal 'education' for major_name comparison.",
      "dataset_rules": "No definitional rules found.",
      "sql_with_sft_rules": "SELECT COUNT(*) FROM member JOIN major ON member.link_to_major = major.major_id WHERE major.major_name = 'education' AND major.college = 'College of Education & Human Services';",
      "sql_without_rules": "SELECT COUNT(*) FROM member JOIN major ON member.link_to_major = major.major_id WHERE major.college = 'College of Education & Human Services';",
      "sql_with_dataset_rules": "SELECT COUNT(*) FROM member JOIN major ON member.link_to_major = major.major_id WHERE major.major_name = 'education' AND major.college = 'College of Education & Human Services';",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 86,
      "question": "What is the average time in seconds of champion for each year, before year 1975?",
      "ground_truth": "WITH time_in_seconds AS ( SELECT T2.year, T2.raceId, T1.positionOrder, CASE WHEN T1.positionOrder = 1 THEN (CAST(SUBSTR(T1.time, 1, 1) AS REAL) * 3600) + (CAST(SUBSTR(T1.time, 3, 2) AS REAL) * 60) + CAST(SUBSTR(T1.time, 6,2) AS REAL )   + CAST(SUBSTR(T1.time, 9) AS REAL)/1000 ELSE 0 END AS time_seconds FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T1.time IS NOT NULL ), champion_time AS ( SELECT year, raceId, time_seconds FROM time_in_seconds WHERE positionOrder = 1 ) SELECT year, AVG(time_seconds) FROM champion_time WHERE year < 1975 GROUP BY year HAVING AVG(time_seconds) IS NOT NULL",
      "db_id": "formula_1",
      "generated_rules": "Rule 1:\nCondition: When answering about average time in seconds of champion for each year before 1975\nOperation: make sure the output order: year, average time in seconds.\n\nRule 2:\nCondition: When the question mentions \"champion\"\nOperation: \"champion\" actually means \"position = 1 in results table\".\n\nRule 3:\nCondition: When the question asks for \"average time in seconds\"\nOperation: calculate the sum of milliseconds divided by the count of results for each year.\n\nRule 4:\nCondition: When the question specifies \"before year 1975\"\nOperation: filter results where year < 1975.\n\nRule 5:\nCondition: When the question asks for \"each year\"\nOperation: group by year and compute the average per year.\n\nRule 6:\nCondition: When the question asks for \"average time in seconds\"\nOperation: compute the average of milliseconds values from the results table.\n\nRule 7:\nCondition: When the question asks for \"average time in seconds\"\nOperation: compute the average of milliseconds values from the results table.\n\nRule 8:\nCondition: When the question asks for \"average time in seconds\"\nOperation: compute the average of milliseconds values from the results table.\n\nRule",
      "dataset_rules": "Condition: When answering about \"average time in seconds of champion for each year\"\nOperation: make sure the output order: year, average time in seconds.\n\nCondition: When the question mentions \"champion\"\nOperation: \"champion\" actually means \"positionOrder = 1\" in the schema.\n\nCondition: When the question mentions \"time in seconds\"\nOperation: calculate time conversion using CASE WHEN T1.positionOrder = 1 THEN with substring parsing instead of assuming pre-calculated time_seconds.\n\nCondition: When the question asks for \"before year 1975\"\nOperation: filter for year < 1975.\n\nCondition: When the question says \"for each year\"\nOperation: organize results by year and compute average time per year.\n\nCondition: When the question mentions \"champion\"\nOperation: \"champion\" actually means \"race winners identified by time format '_:%:__.___' in schema\"",
      "sql_with_sft_rules": "SELECT r.year, AVG(res.milliseconds) / 1000.0 AS average_time_seconds FROM results res JOIN races r ON res.raceId = r.raceId WHERE res.position = 1 AND r.year < 1975 GROUP BY r.year ORDER BY r.year;",
      "sql_without_rules": "SELECT r.year, AVG(r.milliseconds) / 1000.0 AS avg_champion_time_seconds FROM results r JOIN driverStandings ds ON r.raceId = ds.raceId AND r.driverId = ds.driverId JOIN races ra ON r.raceId = ra.raceId WHERE ra.year < 1975 AND ds.position = 1 AND r.milliseconds IS NOT NULL GROUP BY r.year;",
      "sql_with_dataset_rules": "SELECT r.year, AVG( CASE WHEN res.time LIKE '_:_:__.___' THEN (SUBSTR(res.time, 1, 1) * 3600) + (SUBSTR(res.time, 3, 1) * 60) + CAST(SUBSTR(res.time, 5, 2) AS REAL) + (CAST(SUBSTR(res.time, 8, 3) AS REAL) / 1000) WHEN res.time LIKE '__:_:__.___' THEN (SUBSTR(res.time, 1, 2) * 3600) + (SUBSTR(res.time, 4, 1) * 60) + CAST(SUBSTR(res.time, 6, 2) AS REAL) + (CAST(SUBSTR(res.time, 9, 3) AS REAL) / 1000) WHEN res.time LIKE '__:__:__.___' THEN (SUBSTR(res.time, 1, 2) * 3600) + (SUBSTR(res.time, 4, 2) * 60) + CAST(SUBSTR(res.time, 7, 2) AS REAL) + (CAST(SUBSTR(res.time, 10, 3) AS REAL) / 1000) ELSE res.milliseconds / 1000.0 END ) AS average_time_seconds FROM results res JOIN races r ON res.raceId = r.raceId WHERE res.positionOrder = 1 AND r.year < 1975 GROUP BY r.year ORDER BY r.year;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 87,
      "question": "Find the full name of members whose t-shirt size is extra large.",
      "ground_truth": "SELECT first_name, last_name FROM member WHERE t_shirt_size = 'X-Large'",
      "db_id": "student_club",
      "generated_rules": "Rule 1:\nCondition: When the question asks for members' full names\nOperation: select both \"first_name\" and \"last_name\" columns from table \"member\" instead of just \"first_name\".",
      "dataset_rules": "Condition: When the question asks for \"full name\"\nOperation: use the exact token T1.full_name from the schema\n\nCondition: When the question asks for \"full name\"\nOperation: use columns \"forename\" and \"surname\" from table drivers.\n\nCondition: When the question asks for \"full name\"\nOperation: use both \"forename\" and \"surname\" columns from table \"drivers\" to construct the full name.\n\nCondition: When referencing the member table\nOperation: use table name \"member\" instead of \"members\" to reference the correct table.\n\nCondition: When the question asks for \"full name\" of members\nOperation: include both \"first_name\" and \"last_name\" in the output.",
      "sql_with_sft_rules": "SELECT first_name, last_name FROM member WHERE t_shirt_size = 'extra large';",
      "sql_without_rules": "SELECT first_name, last_name FROM member WHERE t_shirt_size = 'extra large';",
      "sql_with_dataset_rules": "SELECT first_name, last_name FROM member WHERE t_shirt_size = 'extra large';",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 88,
      "question": "Among the comments with scores between 5 to 10, what is the percentage of the users with 0 up votes?",
      "ground_truth": "SELECT CAST(SUM(IIF(T1.UpVotes = 0, 1, 0)) AS REAL) * 100/ COUNT(T1.Id) AS per FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T2.Score BETWEEN 5 AND 10",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks for percentage of users with 0 up votes among comments with scores between 5 to 10\nOperation: use SUM(CASE WHEN UpVotes = 0 THEN 1 ELSE 0 END) for conditional counting instead of COUNT with CASE conditions.\n\nRule 2:\nCondition: When the question asks for percentage\nOperation: do not divide by 100.0 factor as the percentage calculation should return the decimal value directly.",
      "dataset_rules": "No definitional rules found.",
      "sql_with_sft_rules": "SELECT (SUM(CASE WHEN u.UpVotes = 0 THEN 1 ELSE 0 END) * 1.0 / COUNT(DISTINCT c.UserId)) FROM comments c JOIN users u ON c.UserId = u.Id WHERE c.Score BETWEEN 5 AND 10;",
      "sql_without_rules": "SELECT (COUNT(DISTINCT CASE WHEN u.UpVotes = 0 THEN c.UserId END) * 100.0 / COUNT(DISTINCT c.UserId)) AS percentage FROM comments c JOIN users u ON c.UserId = u.Id WHERE c.Score BETWEEN 5 AND 10;",
      "sql_with_dataset_rules": "SELECT (COUNT(DISTINCT CASE WHEN u.UpVotes = 0 THEN c.UserId END) * 100.0 / COUNT(DISTINCT c.UserId)) AS percentage FROM comments c JOIN users u ON c.UserId = u.Id WHERE c.Score BETWEEN 5 AND 10;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 89,
      "question": "List all carcinogenic molecules and their elements.",
      "ground_truth": "SELECT DISTINCT T2.molecule_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
      "db_id": "toxicology",
      "generated_rules": "Rule 1:\nCondition: When the question asks for elements of molecules\nOperation: use \"T1.element\" from the \"atom\" table instead of \"element\" from the \"molecule\" table.",
      "dataset_rules": "Condition: When the question mentions \"carcinogenic\"\nOperation: \"carcinogenic\" actually means \"T2.label = '+'\" in schema.\n\nCondition: When the question mentions \"carcinogenic\"\nOperation: use T2.label = '+' as the condition for carcinogenic molecules\n\nCondition: When the question mentions \"carcinogenic\"\nOperation: \"carcinogenic\" actually means \"molecule label = '+' in schema\".\n\nCondition: When answering about \"carcinogenic molecules and their elements\"\nOperation: make sure the output order: T2.molecule_id, T1.element\n\nCondition: When the question mentions \"carcinogenic\"\nOperation: \"carcinogenic\" actually means \"T2.label = '+' in schema\"\n\nCondition: When the question asks for \"distinct molecules\"\nOperation: compute the number of unique values of T2.molecule_id\n\nCondition: When the question mentions \"carcinogenic\"\nOperation: \"carcinogenic\" actually means \"label in schema\" with values like '+' and '-'.",
      "sql_with_sft_rules": "SELECT DISTINCT m.molecule_id, a.element FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id WHERE m.label = 'carcinogenic';",
      "sql_without_rules": "SELECT DISTINCT m.molecule_id, m.label, a.element FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id WHERE m.label = 'carcinogenic';",
      "sql_with_dataset_rules": "SELECT DISTINCT T2.molecule_id, T1.element FROM atom T1 JOIN molecule T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+';",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 90,
      "question": "For the school with the highest average score in Reading in the SAT test, what is its FRPM count for students aged 5-17?",
      "ground_truth": "SELECT T2.`FRPM Count (Ages 5-17)` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrRead DESC LIMIT 1",
      "db_id": "california_schools",
      "generated_rules": "Rule 1:\nCondition: When the question asks for the school with the highest average score in Reading\nOperation: use the \"AvgScrRead\" column from the \"satscores\" table to determine the highest score.",
      "dataset_rules": "Condition: When answering about \"school with the highest average score in Reading\"\nOperation: rank schools by T1.AvgScrRead in descending order and keep the first 1 row.\n\nCondition: When the question asks for \"FRPM count for students aged 5-17\"\nOperation: use the exact column T2.\"FRPM Count (Ages 5-17)\" instead of FRPM_5_17.",
      "sql_with_sft_rules": "SELECT frpm.`FRPM Count (Ages 5-17)` FROM frpm JOIN satscores ON frpm.CDSCode = satscores.cds WHERE satscores.AvgScrRead = (SELECT MAX(AvgScrRead) FROM satscores);",
      "sql_without_rules": "SELECT frpm.\"FRPM Count (Ages 5-17)\" FROM satscores JOIN frpm ON satscores.cds = frpm.CDSCode WHERE satscores.AvgScrRead = (SELECT MAX(AvgScrRead) FROM satscores) LIMIT 1;",
      "sql_with_dataset_rules": "SELECT T2.\"FRPM Count (Ages 5-17)\" FROM satscores T1 JOIN frpm T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrRead DESC LIMIT 1;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 91,
      "question": "Which country is the Belgium Jupiler League from?",
      "ground_truth": "SELECT t1.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t2.name = 'Belgium Jupiler League'",
      "db_id": "european_football_2",
      "generated_rules": "Rule 1:\nCondition: When the question asks about a league's country\nOperation: join the league table (T1) with the country table (T2) using T1.country_id = T2.id to establish the relationship between leagues and countries.\n\nRule 2:\nCondition: When referencing league names\nOperation: use T1.name instead of league.name to specify the table source.",
      "dataset_rules": "Condition: When answering about \"which country a league is from\"\nOperation: make sure the output order: t1.name\n\nCondition: When the question mentions \"Belgium Jupiler League\"\nOperation: \"Belgium Jupiler League\" actually means t2.name = 'Belgium Jupiler League' in schema",
      "sql_with_sft_rules": "SELECT T2.name FROM League AS T1 JOIN Country AS T2 ON T1.country_id = T2.id WHERE T1.name = 'Belgium Jupiler League';",
      "sql_without_rules": "SELECT c.name FROM Country c JOIN League l ON c.id = l.country_id WHERE l.name = 'Belgium Jupiler League';",
      "sql_with_dataset_rules": "SELECT c.name FROM League l JOIN Country c ON l.country_id = c.id WHERE l.name = 'Belgium Jupiler League';",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 92,
      "question": "What is the number of SAT test takers of the schools with the highest FRPM count for K-12 students?",
      "ground_truth": "SELECT NumTstTakr FROM satscores WHERE cds = ( SELECT CDSCode FROM frpm ORDER BY `FRPM Count (K-12)` DESC LIMIT 1 )",
      "db_id": "california_schools",
      "generated_rules": "Rule 1:\nCondition: When the question asks for \"number of SAT test takers\"\nOperation: use the exact column \"NumTstTakr\" from table satscores instead of counting rows.",
      "dataset_rules": "Condition: When answering about \"number of SAT test takers\"\nOperation: select \"NumTstTakr\" from table \"satscores\" instead of counting all rows.\n\nCondition: When the question mentions \"schools with the highest FRPM count\"\nOperation: find the school with maximum \"FRPM Count (K-12)\" value from table \"frpm\" and get its \"CDSCode\" using descending order with limit 1.\n\nCondition: When the question specifies \"K-12 students\"\nOperation: use the column \"FRPM Count (K-12)\" which already represents K-12 data, so no additional grade level filter is needed.",
      "sql_with_sft_rules": "SELECT s.NumTstTakr FROM satscores s JOIN frpm f ON s.cds = f.CDSCode WHERE f.`FRPM Count (K-12)` = (SELECT MAX(`FRPM Count (K-12)`) FROM frpm);",
      "sql_without_rules": "SELECT s.NumTstTakr FROM satscores s JOIN frpm f ON s.cds = f.CDSCode WHERE f.`FRPM Count (K-12)` = (SELECT MAX(`FRPM Count (K-12)`) FROM frpm);",
      "sql_with_dataset_rules": "SELECT satscores.NumTstTakr FROM satscores WHERE satscores.cds = ( SELECT frpm.CDSCode FROM frpm ORDER BY frpm.`FRPM Count (K-12)` DESC LIMIT 1 );",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 93,
      "question": "What is Abomination's superpower?",
      "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = 'Abomination'",
      "db_id": "superhero",
      "generated_rules": "Rule 1:\nCondition: When the question asks about a character's superpower\nOperation: use the exact character name literal 'Abomination' with correct case and spelling.",
      "dataset_rules": "Condition: When the question asks about a character's superpower\nOperation: use the \"superpower\" table (T3) to get power_name instead of the characters table.",
      "sql_with_sft_rules": "SELECT sp.power_name FROM superhero sh JOIN hero_power hp ON sh.id = hp.hero_id JOIN superpower sp ON hp.power_id = sp.id WHERE sh.superhero_name = 'Abomination';",
      "sql_without_rules": "SELECT sp.power_name FROM superhero sh JOIN hero_power hp ON sh.id = hp.hero_id JOIN superpower sp ON hp.power_id = sp.id WHERE sh.superhero_name = 'Abomination';",
      "sql_with_dataset_rules": "SELECT sp.power_name FROM superpower sp JOIN hero_power hp ON sp.id = hp.power_id JOIN superhero sh ON hp.hero_id = sh.id WHERE sh.superhero_name = 'Abomination';",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 94,
      "question": "Please list the exact dates on which a Formula_1 race took place on the Barcelona-Catalunya circuit.",
      "ground_truth": "SELECT T2.date FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Circuit de Barcelona-Catalunya'",
      "db_id": "formula_1",
      "generated_rules": "Rule 1:\nCondition: When the question asks for race dates\nOperation: select \"date\" from the \"races\" table instead of \"race_date\" from \"formula_1\".",
      "dataset_rules": "Condition: When answering about Formula 1 race dates on Barcelona-Catalunya circuit\nOperation: make sure the output order: T2.date\n\nCondition: When the question mentions \"Barcelona-Catalunya circuit\"\nOperation: \"Barcelona-Catalunya\" actually means \"T1.name = 'Circuit de Barcelona-Catalunya'\" in schema",
      "sql_with_sft_rules": "SELECT date FROM races WHERE circuitId = ( SELECT circuitId FROM circuits WHERE name = 'Barcelona-Catalunya' );",
      "sql_without_rules": "SELECT r.date FROM races r JOIN circuits c ON r.circuitId = c.circuitId WHERE c.name = 'Barcelona-Catalunya Circuit' ORDER BY r.date;",
      "sql_with_dataset_rules": "SELECT races.date FROM races JOIN circuits ON races.circuitId = circuits.circuitId WHERE circuits.name = 'Circuit de Barcelona-Catalunya' ORDER BY races.date;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 95,
      "question": "Give the user's reputation and up vote number of the user that commented \"fine, you win :)\".",
      "ground_truth": "SELECT T2.Reputation, T2.UpVotes FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Text = 'fine, you win :)'",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks for \"user's reputation\"\nOperation: use \"T2.Reputation\" from the \"users\" table.\n\nRule 2:\nCondition: When the question asks for \"up vote number\"\nOperation: use \"T2.UpVotes\" from the \"users\" table.\n\nRule 3:\nCondition: When the question mentions a comment \"fine, you win :)\"\nOperation: filter using \"T1.Text LIKE 'fine, you win :)' \" from the \"comments\" table.",
      "dataset_rules": "Condition: When the question asks for user attributes based on a specific comment text\nOperation: join comments table as T1 with users table as T2 using T1.UserId = T2.Id to connect comment authors to their user profiles.",
      "sql_with_sft_rules": "SELECT T2.Reputation, T2.UpVotes FROM comments T1 JOIN users T2 ON T1.UserId = T2.Id WHERE T1.Text LIKE 'fine, you win :)';",
      "sql_without_rules": "SELECT u.Reputation, u.UpVotes FROM users u JOIN comments c ON u.Id = c.UserId WHERE c.Text = 'fine, you win :)';",
      "sql_with_dataset_rules": "SELECT T2.Reputation, T2.UpVotes FROM comments AS T1 JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Text = 'fine, you win :)';",
      "result_with_sft_rules": 1,
      "result_without_rules": 1,
      "result_with_dataset_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 96,
      "question": "What is the total number of molecules with double bonded oxygen?",
      "ground_truth": "SELECT COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '=' AND T1.element = 'o'",
      "db_id": "toxicology",
      "generated_rules": "Rule 1:\nCondition: When the question asks about molecules with double bonded oxygen\nOperation: join the molecule table (T1) with the connected table (T2) using T1.molecule_id = T2.molecule_id to find bonds.",
      "dataset_rules": "No definitional rules found.",
      "sql_with_sft_rules": "SELECT COUNT(DISTINCT m.molecule_id) FROM molecule m JOIN connected c ON m.molecule_id = c.molecule_id JOIN bond b ON c.bond_id = b.bond_id JOIN atom a1 ON c.atom_id = a1.atom_id JOIN atom a2 ON c.atom_id2 = a2.atom_id WHERE b.bond_type = 'double' AND (a1.element = 'O' OR a2.element = 'O');",
      "sql_without_rules": "SELECT COUNT(DISTINCT m.molecule_id) FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id JOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2 JOIN bond b ON c.bond_id = b.bond_id WHERE a.element = 'O' AND b.bond_type = 'double';",
      "sql_with_dataset_rules": "SELECT COUNT(DISTINCT m.molecule_id) FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id JOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2 JOIN bond b ON c.bond_id = b.bond_id WHERE a.element = 'O' AND b.bond_type = 'double';",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 97,
      "question": "Which district has the most accounts with loan contracts finished with no problems?",
      "ground_truth": "SELECT T1.A2 FROM District AS T1 INNER JOIN Account AS T2 ON T1.District_id = T2.District_id INNER JOIN Loan AS T3 ON T2.Account_id = T3.Account_id WHERE T3.status = 'A' GROUP BY T1.District_id ORDER BY COUNT(T2.Account_id) DESC LIMIT 1",
      "db_id": "financial",
      "generated_rules": "Rule 1:\nCondition: When answering about \"district with the most accounts with loan contracts finished with no problems\"\nOperation: make sure the output order: district_id first, then the count.\n\nRule 2:\nCondition: When the question mentions \"loan contracts finished with no problems\"\nOperation: \"no problems\" actually means \"status = 'OK' in table loan\".\n\nRule 3:\nCondition: When the question asks for \"count of accounts\"\nOperation: compute the number of rows using T2.account_id as the counting key.\n\nRule 4:\nCondition: When the question asks for \"most accounts\"\nOperation: rank rows by count of T2.account_id in descending order and keep the first 1 row.\n\nRule 5:\nCondition: When the question asks for \"most accounts\"\nOperation: rank rows by count of T2.account_id in descending order and keep the first 1 row.\n\nRule 6:\nCondition: When the question asks for \"most accounts\"\nOperation: rank rows by count of T2.account_id in descending order and keep the first 1 row.\n\nRule 7:\nCondition: When the question asks for \"most accounts\"\nOperation: rank rows by count of T2.account_id in descending order and keep the first 1 row.",
      "dataset_rules": "Condition: When answering about districts with accounts and loan contracts\nOperation: use explicit table aliases T1 for district, T2 for Account, and T3 for Loan instead of direct table references.",
      "sql_with_sft_rules": "SELECT d.district_id, COUNT(DISTINCT l.account_id) AS account_count FROM loan l JOIN account a ON l.account_id = a.account_id JOIN district d ON a.district_id = d.district_id WHERE l.status = 'OK' GROUP BY d.district_id ORDER BY account_count DESC LIMIT 1;",
      "sql_without_rules": "SELECT d.A2 AS district_name FROM district d JOIN account a ON d.district_id = a.district_id JOIN loan l ON a.account_id = l.account_id WHERE l.status = 'A' GROUP BY d.district_id, d.A2 ORDER BY COUNT(*) DESC LIMIT 1;",
      "sql_with_dataset_rules": "SELECT T1.district_id FROM district T1 JOIN account T2 ON T1.district_id = T2.district_id JOIN loan T3 ON T2.account_id = T3.account_id WHERE T3.status = 'A' GROUP BY T1.district_id ORDER BY COUNT(DISTINCT T2.account_id) DESC LIMIT 1;",
      "result_with_sft_rules": 0,
      "result_without_rules": 1,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 98,
      "question": "Among the students majored in interior design, who have attended the Community Theater event?",
      "ground_truth": "SELECT T2.first_name, T2.last_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member INNER JOIN event AS T4 ON T3.link_to_event = T4.event_id WHERE T4.event_name = 'Community Theater' AND T1.major_name = 'Interior Design'",
      "db_id": "student_club",
      "generated_rules": "Rule 1:\nCondition: When the question asks about students\nOperation: use the \"student\" table instead of \"students\" to match the correct schema table name.\n\nRule 2:\nCondition: When the question asks about students\nOperation: use table \"student\" instead of \"students\" as the data source.",
      "dataset_rules": "Condition: When answering about students majored in interior design who attended Community Theater event\nOperation: use tables major, member, attendance, and event with aliases T1, T2, T3, T4 respectively.",
      "sql_with_sft_rules": "SELECT m.first_name, m.last_name FROM member m JOIN major maj ON m.link_to_major = maj.major_id JOIN attendance a ON m.member_id = a.link_to_member JOIN event e ON a.link_to_event = e.event_id WHERE maj.major_name = 'interior design' AND e.event_name = 'Community Theater';",
      "sql_without_rules": "SELECT m.first_name, m.last_name FROM member m JOIN major maj ON m.link_to_major = maj.major_id JOIN attendance a ON m.member_id = a.link_to_member JOIN event e ON a.link_to_event = e.event_id WHERE maj.major_name = 'interior design' AND e.event_name = 'Community Theater';",
      "sql_with_dataset_rules": "SELECT T2.first_name, T2.last_name FROM major T1, member T2, attendance T3, event T4 WHERE T1.major_name = 'interior design' AND T4.event_name = 'Community Theater' AND T1.major_id = T2.link_to_major AND T2.member_id = T3.link_to_member AND T3.link_to_event = T4.event_id;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 99,
      "question": "How many adults who obtained the badge Supporter?",
      "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Supporter' AND T1.Age BETWEEN 19 AND 65",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks about \"adults\"\nOperation: use the age condition \"Age > 18\" instead of \"age = 18\" to capture all adults.\n\nRule 2:\nCondition: When the question mentions \"obtained the badge Supporter\"\nOperation: filter on \"Name = 'Supporter'\" from the badges table instead of \"badge = 'Supporter'\".",
      "dataset_rules": "No definitional rules found.",
      "sql_with_sft_rules": "SELECT COUNT(DISTINCT u.Id) FROM users u JOIN badges b ON u.Id = b.UserId WHERE u.Age > 18 AND b.Name = 'Supporter';",
      "sql_without_rules": "SELECT COUNT(DISTINCT u.Id) FROM users u JOIN badges b ON u.Id = b.UserId WHERE u.Age >= 18 AND b.Name = 'Supporter';",
      "sql_with_dataset_rules": "SELECT COUNT(DISTINCT u.Id) FROM users u JOIN badges b ON u.Id = b.UserId WHERE b.Name = 'Supporter' AND u.Age >= 18;",
      "result_with_sft_rules": 0,
      "result_without_rules": 0,
      "result_with_dataset_rules": 0,
      "error_message": ""
    }
  ]
}