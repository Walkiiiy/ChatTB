{
  "test_config": {
    "base_model": "/home/ubuntu/walkiiiy/ChatTB/Process_model/models--Qwen3-8B",
    "adapter_path": "/home/ubuntu/walkiiiy/ChatTB/Process_model/models--globalAssumer_Qwen3_8b_Spider-Bird",
    "dataset": "/home/ubuntu/walkiiiy/ChatTB/Bird_dev/res.json",
    "num_samples": 100,
    "deepseek_model": "deepseek-coder",
    "generation_params": {
      "max_new_tokens": 256,
      "temperature": 0.1,
      "do_sample": true
    }
  },
  "statistics": {
    "total_questions": 100,
    "with_rules": {
      "correct_answers": 33,
      "failed_executions": 0,
      "accuracy": 0.33
    },
    "without_rules": {
      "correct_answers": 37,
      "failed_executions": 0,
      "accuracy": 0.37
    },
    "improvement": {
      "absolute": -0.03999999999999998,
      "relative": -3.9999999999999982,
      "description": "Rules provide -0.040 (-4.0%) accuracy improvement"
    }
  },
  "results": [
    {
      "sample_idx": 0,
      "question": "What was the fastest lap speed among all drivers in the 2009 Spanish Grand Prix?",
      "ground_truth": "SELECT T2.fastestLapSpeed FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.name = 'Spanish Grand Prix' AND T1.year = 2009 AND T2.fastestLapSpeed IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
      "db_id": "formula_1",
      "generated_rules": "Rule 1:\nCondition: When answering about fastest lap speed\nOperation: make sure the output order: MAX(T1.fastestLapSpeed).\n\nRule 2:\nCondition: When the question mentions \"2009 Spanish Grand Prix\"\nOperation: \"2009 Spanish Grand Prix\" actually means T2.name = 'Spanish Grand Prix' AND T2.year = 2009 in schema.",
      "sql_with_rules": "SELECT MAX(results.fastestLapSpeed) FROM results JOIN races ON results.raceId = races.raceId WHERE races.name = 'Spanish Grand Prix' AND races.year = 2009;",
      "sql_without_rules": "SELECT MAX(r.fastestLapSpeed) FROM results r JOIN races rc ON r.raceId = rc.raceId WHERE rc.year = 2009 AND rc.name = 'Spanish Grand Prix';",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 1,
      "question": "Among the patients who has a normal anti-scl70, how many of them are female and does not have any symptom?",
      "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE (T2.SC170 = 'negative' OR T2.SC170 = '0') AND T1.SEX = 'F' AND T3.Symptoms IS NULL",
      "db_id": "thrombosis_prediction",
      "generated_rules": "No definitional rules found.",
      "sql_with_rules": "SELECT COUNT(DISTINCT p.ID) FROM Patient p JOIN Laboratory l ON p.ID = l.ID LEFT JOIN Examination e ON p.ID = e.ID WHERE l.SC170 = 'normal' AND p.SEX = 'female' AND (e.Symptoms IS NULL OR e.Symptoms = '');",
      "sql_without_rules": "SELECT COUNT(DISTINCT p.ID) FROM Patient p JOIN Laboratory l ON p.ID = l.ID LEFT JOIN Examination e ON p.ID = e.ID WHERE l.SC170 = 'normal' AND p.SEX = 'female' AND (e.Symptoms IS NULL OR e.Symptoms = '');",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 2,
      "question": "What percentage of KAM customers pay in euros?",
      "ground_truth": "SELECT CAST(SUM(Currency = 'EUR') AS FLOAT) * 100 / COUNT(CustomerID) FROM customers WHERE Segment = 'KAM'",
      "db_id": "debit_card_specializing",
      "generated_rules": "Rule 1:\nCondition: When the question asks for percentage of customers with specific conditions\nOperation: use SUM(CASE WHEN condition THEN 1 ELSE 0 END) * 100 / COUNT(*) instead of COUNT(*) * 100 / COUNT(*) to properly calculate the ratio.\n\nRule 2:\nCondition: When the question asks for percentage\nOperation: do not divide by 100.0 factor as the percentage calculation should return the decimal value directly.",
      "sql_with_rules": "SELECT SUM(CASE WHEN c.Segment = 'KAM' AND c.Currency = 'EUR' THEN 1 ELSE 0 END) * 100.0 / COUNT(*) FROM customers c WHERE c.Segment = 'KAM';",
      "sql_without_rules": "SELECT (COUNT(DISTINCT CASE WHEN c.Currency = 'EUR' THEN c.CustomerID END) * 100.0 / COUNT(DISTINCT c.CustomerID)) AS Percentage FROM customers c WHERE c.Segment = 'KAM';",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 3,
      "question": "List the driver's ID of the top five driver, by descending order, the fastest time during the first lap of the race.",
      "ground_truth": "SELECT driverId FROM lapTimes WHERE lap = 1 ORDER BY time LIMIT 5",
      "db_id": "formula_1",
      "generated_rules": "Rule 1:\nCondition: When the question asks for \"driver's ID\"\nOperation: use the exact column token \"driverId\" from the drivers table.\n\nRule 2:\nCondition: When the question asks for \"top five driver by fastest time\"\nOperation: rank rows by \"milliseconds\" in ascending order and keep the first 5 rows.\n\nRule 3:\nCondition: When the question specifies \"during the first lap\"\nOperation: filter rows where \"lap\" equals 1 exactly.",
      "sql_with_rules": "SELECT driverId FROM lapTimes WHERE lap = 1 ORDER BY milliseconds ASC LIMIT 5;",
      "sql_without_rules": "SELECT driverId FROM lapTimes WHERE lap = 1 ORDER BY milliseconds ASC LIMIT 5;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 4,
      "question": "How many high-level credit cards have \"OWNER\" type of disposition?",
      "ground_truth": "SELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'gold' AND T2.type = 'OWNER'",
      "db_id": "financial",
      "generated_rules": "Rule 1:\nCondition: When the question asks about credit cards\nOperation: use table \"card\" instead of \"credit_cards\" and filter on type = 'CreditCard' instead of type = 'credit_card'.\n\nRule 2:\nCondition: When the question asks about disposition type 'OWNER'\nOperation: filter on T2.type = 'OWNER' exactly as specified.\n\nRule 3:\nCondition: When the question asks about credit cards\nOperation: filter for rows where T1.Type = 'CreditCard' exactly.",
      "sql_with_rules": "SELECT COUNT(*) FROM card AS T1 JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'CreditCard' AND T2.type = 'OWNER';",
      "sql_without_rules": "SELECT COUNT(*) FROM card c JOIN disp d ON c.disp_id = d.disp_id WHERE c.type = 'gold' AND d.type = 'OWNER';",
      "result_with_rules": 0,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 5,
      "question": "For the branch which located in the south Bohemia with biggest number of inhabitants, what is the percentage of the male clients?",
      "ground_truth": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'south Bohemia' GROUP BY T2.A4 ORDER BY T2.A4 DESC LIMIT 1",
      "db_id": "financial",
      "generated_rules": "Rule 1:\nCondition: When the question asks for percentage of male clients\nOperation: use SUM(CASE WHEN gender = 'Male' THEN 1 ELSE 0 END) for male count instead of COUNT with gender = 'Male'.",
      "sql_with_rules": "SELECT (SUM(CASE WHEN c.gender = 'Male' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS male_percentage FROM client c JOIN district d ON c.district_id = d.district_id WHERE d.A3 = 'south Bohemia' AND d.A4 = ( SELECT MAX(A4) FROM district WHERE A3 = 'south Bohemia' );",
      "sql_without_rules": "WITH south_bohemia_districts AS ( SELECT district_id FROM district WHERE A3 = 'south Bohemia' ORDER BY A4 DESC LIMIT 1 ), district_clients AS ( SELECT c.client_id, c.gender FROM client c JOIN south_bohemia_districts sbd ON c.district_id = sbd.district_id ) SELECT (COUNT(CASE WHEN gender = 'M' THEN 1 END) * 100.0 / COUNT(*)) AS male_percentage FROM district_clients;",
      "result_with_rules": 0,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 6,
      "question": "What was the potiential for Francesco Parravicini on 2010/8/30?",
      "ground_truth": "SELECT t2.potential FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2010-08-30' AND t1.player_name = 'Francesco Parravicini'",
      "db_id": "european_football_2",
      "generated_rules": "Rule 1:\nCondition: When the question asks about a player's potential\nOperation: select \"potential\" from the \"Player_Attributes\" table instead of \"name\" from the \"players\" table.",
      "sql_with_rules": "SELECT potential FROM Player_Attributes WHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Francesco Parravicini') AND date = '2010/8/30';",
      "sql_without_rules": "SELECT potential FROM Player_Attributes JOIN Player ON Player_Attributes.player_api_id = Player.player_api_id WHERE Player.player_name = 'Francesco Parravicini' AND Player_Attributes.date = '2010-08-30';",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 7,
      "question": "What percentage of cards with format commander and legal status do not have a content warning?",
      "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'commander' AND T2.status = 'Legal'",
      "db_id": "card_games",
      "generated_rules": "Rule 1:\nCondition: When the question asks for percentage of cards without content warning\nOperation: calculate (number of cards without content warning) divided by (total cards with commander legal status) multiplied by 100.0.\n\nRule 2:\nCondition: When the question asks for percentage\nOperation: do not divide by 100.0 factor as the percentage calculation should return the decimal value directly.",
      "sql_with_rules": "SELECT (COUNT(CASE WHEN c.hasContentWarning = 0 THEN 1 END) * 100.0 / COUNT(*)) FROM cards c JOIN legalities l ON c.uuid = l.uuid WHERE l.format = 'commander' AND l.status = 'legal';",
      "sql_without_rules": "SELECT (COUNT(CASE WHEN c.hasContentWarning = 0 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_without_warning FROM cards c JOIN legalities l ON c.uuid = l.uuid WHERE l.format = 'commander' AND l.status = 'legal';",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 8,
      "question": "List out of players whose preferred foot is left.",
      "ground_truth": "SELECT DISTINCT t1.id, t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.preferred_foot = 'left'",
      "db_id": "european_football_2",
      "generated_rules": "Rule 1:\nCondition: When the question asks for players with a specific preferred foot\nOperation: use the exact column name \"preferred_foot\" from the Player_Attributes table.",
      "sql_with_rules": "SELECT DISTINCT p.player_name FROM Player p JOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id WHERE pa.preferred_foot = 'left';",
      "sql_without_rules": "SELECT DISTINCT p.player_name FROM Player p JOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id WHERE pa.preferred_foot = 'left';",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 9,
      "question": "Provide ID, sex and age of patient who has blood glucose (GLU) not within normal range but with total cholesterol(T-CHO) within normal range.",
      "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX , STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GLU >= 180 AND T2.`T-CHO` < 250",
      "db_id": "thrombosis_prediction",
      "generated_rules": "Rule 1:\nCondition: When the question asks for \"ID, sex and age of patient\"\nOperation: select \"T2\".\"ID\", \"T2\".\"SEX\", and calculate age as \"CAST(JULIANDAY('now') - JULIANDAY(T2.Birthday) AS INTEGER)\" instead of using \"age\".\n\nRule 2:\nCondition: When the question mentions \"blood glucose (GLU) not within normal range\"\nOperation: use \"T1\".\"GLU\" with comparison operators \"NOT BETWEEN 60 AND 110\" instead of \"NOT BETWEEN 70 AND 100\".\n\nRule 3:\nCondition: When the question mentions \"total cholesterol(T-CHO) within normal range\"\nOperation: use \"T1\".\"T-CHO\" with comparison operators \"BETWEEN 150 AND 200\" instead of \"NOT BETWEEN 150 AND 200\".",
      "sql_with_rules": "SELECT T2.ID, T2.SEX, CAST(JULIANDAY('now') - JULIANDAY(T2.Birthday) AS INTEGER) AS Age FROM Laboratory T1 JOIN Patient T2 ON T1.ID = T2.ID WHERE T1.GLU NOT BETWEEN 60 AND 110 AND T1.\"T-CHO\" BETWEEN 150 AND 200;",
      "sql_without_rules": "SELECT p.ID, p.SEX, CAST(strftime('%Y', 'now') - strftime('%Y', p.Birthday) AS INTEGER) AS Age FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE l.GLU NOT BETWEEN 70 AND 140 AND l.`T-CHO` BETWEEN 150 AND 200;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 10,
      "question": "Please list player names which are higher than 180.",
      "ground_truth": "SELECT player_name FROM Player WHERE height > 180",
      "db_id": "european_football_2",
      "generated_rules": "Rule 1:\nCondition: When the question asks for player names\nOperation: use the exact column \"Player_Name\" from the \"Player\" table.\n\nRule 2:\nCondition: When the question asks for player names\nOperation: use the exact column token \"Player_Name\" from the Player table.\n\nRule 3:\nCondition: When the question asks for player names\nOperation: select \"Player_Name\" from table \"Player\" instead of \"name\" from \"players\".\n\nRule 4:\nCondition: When the question asks for player names\nOperation: use \"T2.Player_Name\" as the output column instead of \"name\".\n\nRule 5:\nCondition: When the question asks for player names\nOperation: select \"T1.Player_Name\" as the output column.\n\nRule 6:\nCondition: When the question asks for player names\nOperation: select \"firstName\" and \"lastName\" from the players table instead of a generic \"name\" column.\n\nRule 7:\nCondition: When the question asks for player names\nOperation: use DISTINCT T1.PlayerName instead of name without distinct to avoid duplicates.\n\nRule 8:\nCondition: When the question asks for player names\nOperation: use \"T1.PlayerName\" as the output column instead of generic name fields",
      "sql_with_rules": "SELECT Player_Name FROM Player WHERE height > 180;",
      "sql_without_rules": "SELECT DISTINCT player_name FROM Player WHERE height > 180;",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 11,
      "question": "For the patients with an abnormal anti-SM, please list the IDs of the three youngest ones.",
      "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SM NOT IN ('negative','0') ORDER BY T1.Birthday DESC LIMIT 3",
      "db_id": "thrombosis_prediction",
      "generated_rules": "Rule 1:\nCondition: When the question asks for patient IDs\nOperation: select \"T2\".\"patient\" instead of \"patient_id\" from the patients table.\n\nRule 2:\nCondition: When the question asks for patient IDs\nOperation: use the exact column token \"T1.ID\" from the patients table.",
      "sql_with_rules": "SELECT T1.ID FROM Patient T1 JOIN Laboratory T2 ON T1.ID = T2.ID WHERE T2.SM != 'normal' ORDER BY T1.Birthday DESC LIMIT 3;",
      "sql_without_rules": "SELECT p.ID FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE l.SM != 'normal' OR l.SM IS NULL ORDER BY p.Birthday DESC LIMIT 3;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 12,
      "question": "Which college is the vice president of the Student_Club from?",
      "ground_truth": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.position LIKE 'vice president'",
      "db_id": "student_club",
      "generated_rules": "Rule 1:\nCondition: When the question asks about a person's college affiliation\nOperation: use the pre-established relationship through the member-major table instead of direct college fields.",
      "sql_with_rules": "SELECT m.college FROM member JOIN major m ON member.link_to_major = m.major_id WHERE member.position = 'vice president';",
      "sql_without_rules": "SELECT m.college FROM member JOIN major m ON member.link_to_major = m.major_id WHERE member.position = 'vice president';",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 13,
      "question": "What does the person with the phone number \"809-555-3360\" major in?",
      "ground_truth": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.phone = '809-555-3360'",
      "db_id": "student_club",
      "generated_rules": "Rule 1:\nCondition: When the question asks about a person's major\nOperation: use the exact column \"major_name\" from the \"major\" table instead of \"major\" from \"people\".",
      "sql_with_rules": "SELECT m.major_name FROM member JOIN major m ON member.link_to_major = m.major_id WHERE member.phone = '809-555-3360';",
      "sql_without_rules": "SELECT m.major_name FROM member JOIN major m ON member.link_to_major = m.major_id WHERE member.phone = '809-555-3360';",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 14,
      "question": "For all the people who paid more than 29.00 per unit of product id No.5. Give their consumption status in the August of 2012.",
      "ground_truth": "SELECT T2.Consumption FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Price / T1.Amount > 29.00 AND T1.ProductID = 5 AND T2.Date = '201208'",
      "db_id": "debit_card_specializing",
      "generated_rules": "Rule 1:\nCondition: When the question asks about consumption status\nOperation: select \"T2\".\"Consumption\" instead of all columns.",
      "sql_with_rules": "SELECT T2.Consumption FROM transactions_1k T1 JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID WHERE T1.ProductID = 5 AND T1.Price > 29.00 AND T2.Date LIKE '2012-08%';",
      "sql_without_rules": "SELECT y.CustomerID, y.Date, y.Consumption FROM yearmonth y JOIN transactions_1k t ON y.CustomerID = t.CustomerID WHERE t.ProductID = 5 AND t.Price / t.Amount > 29.00 AND y.Date LIKE '2012-08%';",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 15,
      "question": "Give the name of the league had the most goals in the 2016 season?",
      "ground_truth": "SELECT t2.name FROM Match AS t1 INNER JOIN League AS t2 ON t1.league_id = t2.id WHERE t1.season = '2015/2016' GROUP BY t2.name ORDER BY SUM(t1.home_team_goal + t1.away_team_goal) DESC LIMIT 1",
      "db_id": "european_football_2",
      "generated_rules": "Rule 1:\nCondition: When the question asks for league names\nOperation: use \"T2.name\" from the \"League\" table instead of \"league_name\" from \"matches\".\n\nRule 2:\nCondition: When the question asks for league names\nOperation: use \"T2.name\" from the \"League\" table instead of \"league_name\" from \"matches\".\n\nRule 3:\nCondition: When the question asks for league names\nOperation: use \"T2.name\" from the \"League\" table instead of \"league_name\" from \"matches\".\n\nRule 4:\nCondition: When the question asks for league names\nOperation: use \"T2.name\" from the \"League\" table instead of \"league_name\" from \"matches\".\n\nRule 5:\nCondition: When the question asks for league names\nOperation: use \"T2.name\" from the \"League\" table instead of \"league_name\" from \"matches\".\n\nRule 6:\nCondition: When the question asks for league names\nOperation: use \"T2.name\" from the \"League\" table instead of \"league_name\" from \"matches\".\n\nRule 7:\nCondition: When the question asks for league names\nOperation: use \"T2.name\" from the \"League\" table",
      "sql_with_rules": "SELECT T2.name FROM Match AS T JOIN League AS T2 ON T.league_id = T2.id WHERE T.season = '2016' GROUP BY T.league_id ORDER BY SUM(T.home_team_goal + T.away_team_goal) DESC LIMIT 1;",
      "sql_without_rules": "SELECT l.name FROM League l JOIN Match m ON l.id = m.league_id WHERE m.season = '2016/2017' GROUP BY l.id, l.name ORDER BY SUM(m.home_team_goal + m.away_team_goal) DESC LIMIT 1;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 16,
      "question": "What is the sum that client number 4's account has following transaction 851? Who owns this account, a man or a woman?",
      "ground_truth": "SELECT T4.balance, T1.gender FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id =T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 4 AND T4.trans_id = 851",
      "db_id": "financial",
      "generated_rules": "Rule 1:\nCondition: When the question asks about a client's account balance\nOperation: retrieve the balance from the \"trans\" table (T2.balance) instead of summing transactions.",
      "sql_with_rules": "SELECT t.balance, c.gender FROM trans t JOIN account a ON t.account_id = a.account_id JOIN disp d ON a.account_id = d.account_id JOIN client c ON d.client_id = c.client_id WHERE c.client_id = 4 AND t.trans_id = 851 AND d.type = 'OWNER';",
      "sql_without_rules": "SELECT c.gender, t.balance FROM trans t JOIN account a ON t.account_id = a.account_id JOIN disp d ON a.account_id = d.account_id JOIN client c ON d.client_id = c.client_id WHERE c.client_id = 4 AND t.trans_id = 851;",
      "result_with_rules": 1,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 17,
      "question": "What percentage of carcinogenic-type molecules does not contain fluorine?",
      "ground_truth": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element <> 'f' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
      "db_id": "toxicology",
      "generated_rules": "Rule 1:\nCondition: When the question asks for percentage of molecules without fluorine\nOperation: calculate (number of molecules without fluorine) divided by (total molecules) multiplied by 100.0.\n\nRule 2:\nCondition: When the question asks for percentage\nOperation: do not divide by 100.0 factor as the percentage calculation should return the decimal value directly.",
      "sql_with_rules": "SELECT (COUNT(DISTINCT CASE WHEN NOT EXISTS (SELECT 1 FROM atom WHERE atom.molecule_id = molecule.molecule_id AND atom.element = 'F') THEN molecule.molecule_id END) * 100.0 / COUNT(DISTINCT molecule.molecule_id)) AS percentage FROM molecule WHERE molecule.label = 'carcinogenic';",
      "sql_without_rules": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM molecule WHERE label = 'carcinogenic')) FROM molecule m WHERE m.label = 'carcinogenic' AND NOT EXISTS ( SELECT 1 FROM atom a WHERE a.molecule_id = m.molecule_id AND a.element = 'F' );",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 18,
      "question": "Provide the ID, sex, birthday of all patients diagnosed with 'RA' that are within the UN normal index.",
      "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.UN < 30 AND T1.Diagnosis = 'RA'",
      "db_id": "thrombosis_prediction",
      "generated_rules": "Rule 1:\nCondition: When the question asks for patients diagnosed with 'RA'\nOperation: use the exact literal 'RA' for the Diagnosis column in the Patient table.",
      "sql_with_rules": "SELECT p.ID, p.SEX, p.Birthday FROM Patient p WHERE p.Diagnosis = 'RA' AND p.ID IN ( SELECT l.ID FROM Laboratory l WHERE l.UN BETWEEN 8 AND 20 );",
      "sql_without_rules": "SELECT p.ID, p.SEX, p.Birthday FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE l.RA = 'RA' AND l.UN BETWEEN 8 AND 20;",
      "result_with_rules": 1,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 19,
      "question": "What is the total number of superheroes without full name?",
      "ground_truth": "SELECT COUNT(id) FROM superhero WHERE full_name IS NULL",
      "db_id": "superhero",
      "generated_rules": "Rule 1:\nCondition: When the question asks for superheroes without full name\nOperation: filter rows where \"full_name\" equals the empty string '' instead of checking for NULL values.",
      "sql_with_rules": "SELECT COUNT(*) FROM superhero WHERE full_name = '';",
      "sql_without_rules": "SELECT COUNT(*) FROM superhero WHERE full_name IS NULL OR full_name = '';",
      "result_with_rules": 0,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 20,
      "question": "cards are not directly linked to language but through table 'set'. you need to add set in covered table & rephrase your question\nWhat are the languages available for the set that card 'Angel of Mercy' is in?",
      "ground_truth": "SELECT language FROM set_translations WHERE id IN ( SELECT id FROM cards WHERE name = 'Angel of Mercy' )",
      "db_id": "card_games",
      "generated_rules": "Rule 1:\nCondition: When the question asks about languages available for a card's set\nOperation: join the cards table (T1) with the sets table (T2) using T1.setCode = T2.code to link cards to their sets.",
      "sql_with_rules": "SELECT DISTINCT st.language FROM cards c JOIN sets s ON c.setCode = s.code JOIN set_translations st ON s.code = st.setCode WHERE c.name = 'Angel of Mercy';",
      "sql_without_rules": "SELECT DISTINCT fd.language FROM cards c JOIN sets s ON c.setCode = s.code JOIN foreign_data fd ON s.code = fd.uuid WHERE c.name = 'Angel of Mercy';",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 21,
      "question": "Which player has the highest overall rating? Indicate the player's api id.",
      "ground_truth": "SELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1",
      "db_id": "european_football_2",
      "generated_rules": "Rule 1:\nCondition: When the question asks for \"player's api id\"\nOperation: use the exact column token \"player_api_id\" from table \"Player\" instead of \"api_id\".",
      "sql_with_rules": "SELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1;",
      "sql_without_rules": "SELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1;",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 22,
      "question": "How many patients who were female got white blood cells that were below 3.5?",
      "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.WBC < 3.5 AND T1.SEX = 'F'",
      "db_id": "thrombosis_prediction",
      "generated_rules": "No definitional rules found.",
      "sql_with_rules": "SELECT COUNT(DISTINCT p.ID) FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE p.SEX = 'female' AND l.WBC < 3.5;",
      "sql_without_rules": "SELECT COUNT(DISTINCT p.ID) FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE p.SEX = 'female' AND l.WBC < 3.5;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 23,
      "question": "Please list the constructor names with 0 points at race 291.",
      "ground_truth": "SELECT T2.name FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.points = 0 AND T1.raceId = 291",
      "db_id": "formula_1",
      "generated_rules": "Rule 1:\nCondition: When the question asks for constructor names\nOperation: use \"T2.name\" from the \"constructors\" table instead of \"constructor_name\" from \"races\".",
      "sql_with_rules": "SELECT T2.name FROM constructorStandings JOIN constructors AS T2 ON constructorStandings.constructorId = T2.constructorId WHERE constructorStandings.raceId = 291 AND constructorStandings.points = 0;",
      "sql_without_rules": "SELECT c.name FROM constructors c JOIN constructorResults cr ON c.constructorId = cr.constructorId WHERE cr.raceId = 291 AND cr.points = 0;",
      "result_with_rules": 1,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 24,
      "question": "How many clients who choose statement of weekly issuance are Owner?",
      "ground_truth": "SELECT COUNT(T2.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T2.account_id = T1.account_id WHERE T1.frequency = 'POPLATEK TYDNE' AND T2.type = 'OWNER'",
      "db_id": "financial",
      "generated_rules": "Rule 1:\nCondition: When the question asks about clients\nOperation: use the exact table name \"client\" instead of \"clients\".\n\nRule 2:\nCondition: When the question asks about clients\nOperation: use table \"client\" instead of \"clients\" as the data source.",
      "sql_with_rules": "SELECT COUNT(DISTINCT c.client_id) FROM client c JOIN disp d ON c.client_id = d.client_id JOIN account a ON d.account_id = a.account_id WHERE a.frequency = 'WEEKLY ISSUANCE' AND d.type = 'OWNER';",
      "sql_without_rules": "SELECT COUNT(DISTINCT c.client_id) FROM client c JOIN disp d ON c.client_id = d.client_id JOIN account a ON d.account_id = a.account_id WHERE a.frequency = 'WEEKLY ISSUANCE' AND d.type = 'OWNER';",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 25,
      "question": "Provide the total number of the budget amount for \"September Speaker\" event.",
      "ground_truth": "SELECT SUM(T1.amount) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'September Speaker'",
      "db_id": "student_club",
      "generated_rules": "Rule 1:\nCondition: When the question asks for \"total number of the budget amount\"\nOperation: use SUM(amount) to calculate the total sum of amounts rather than counting rows.",
      "sql_with_rules": "SELECT SUM(amount) FROM budget WHERE link_to_event = (SELECT event_id FROM event WHERE event_name = 'September Speaker');",
      "sql_without_rules": "SELECT SUM(b.amount) FROM budget b JOIN event e ON b.link_to_event = e.event_id WHERE e.event_name = 'September Speaker';",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 26,
      "question": "Which SME customer consumed the least in June 2012?",
      "ground_truth": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201206' AND T1.Segment = 'SME' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
      "db_id": "debit_card_specializing",
      "generated_rules": "Rule 1:\nCondition: When the question asks about customer consumption\nOperation: use \"T1.Date\" for date filtering and \"T2.Consumption\" for consumption values.\n\nRule 2:\nCondition: When the question asks about customer consumption\nOperation: use the \"yearmonth\" table as T1 and join with \"customers\" table as T2 using T1.CustomerID = T2.CustomerID to link customer data with consumption records.",
      "sql_with_rules": "SELECT T2.CustomerID FROM yearmonth AS T1 JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Segment = 'SME' AND T1.Date LIKE '2012-06%' ORDER BY T1.Consumption ASC LIMIT 1;",
      "sql_without_rules": "SELECT c.CustomerID, MIN(ym.Consumption) AS MinConsumption FROM customers c JOIN yearmonth ym ON c.CustomerID = ym.CustomerID WHERE c.Segment = 'SME' AND ym.Date LIKE '2012-06%' GROUP BY c.CustomerID ORDER BY MinConsumption ASC LIMIT 1;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 27,
      "question": "Please list the name of the districts with accounts that made withdrawal transactions.",
      "ground_truth": "SELECT DISTINCT T1.A2 FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.type = 'VYDAJ'",
      "db_id": "financial",
      "generated_rules": "Rule 1:\nCondition: When the question asks for district names\nOperation: use \"T2.district_name\" as the output column instead of \"district_name\" from the district table.",
      "sql_with_rules": "SELECT DISTINCT T2.A2 AS district_name FROM district T2 JOIN account ON T2.district_id = account.district_id JOIN trans ON account.account_id = trans.account_id WHERE trans.type = 'VYDAJ';",
      "sql_without_rules": "SELECT DISTINCT d.A2 FROM district d JOIN account a ON d.district_id = a.district_id JOIN trans t ON a.account_id = t.account_id WHERE t.operation = 'VYBER' OR t.type = 'VYDAJ';",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 28,
      "question": "Calculate the percentage of cards in Spanish. List them by name.",
      "ground_truth": "SELECT ( SELECT CAST(SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM foreign_data ), name FROM foreign_data WHERE language = 'Spanish'",
      "db_id": "card_games",
      "generated_rules": "Rule 1:\nCondition: When the question asks for percentage\nOperation: do not divide by 100.0 factor as the percentage calculation should return the decimal value directly.\n\nRule 2:\nCondition: When the question asks for percentage of cards in Spanish\nOperation: use SUM(CASE WHEN T1.language = 'Spanish' THEN 1 ELSE 0 END) to count Spanish cards instead of COUNT(*) with a WHERE filter.\n\nRule 3:\nCondition: When the question asks for percentage of cards in Spanish\nOperation: use SUM(CASE WHEN T1.language = 'Spanish' THEN 1 ELSE 0 END) to count Spanish cards instead of COUNT(*) with a WHERE filter.\n\nRule 4:\nCondition: When the question asks for percentage of cards in Spanish\nOperation: calculate the ratio of Spanish cards to total cards using CAST(SUM(CASE WHEN T1.language = 'Spanish' THEN 1 ELSE 0 END) AS REAL) / COUNT(*)\n\nRule 5:\nCondition: When the question asks for percentage of cards in Spanish\nOperation: calculate the ratio of Spanish cards to total cards using CAST(SUM(CASE WHEN T1.language = 'Spanish' THEN 1 ELSE 0 END) AS REAL) / COUNT(*)\n\nRule",
      "sql_with_rules": "SELECT name, (CAST(SUM(CASE WHEN foreign_data.language = 'Spanish' THEN 1 ELSE 0 END) AS REAL) / COUNT(*)) AS percentage FROM cards JOIN foreign_data ON cards.uuid = foreign_data.uuid GROUP BY cards.name;",
      "sql_without_rules": "SELECT (COUNT(CASE WHEN fd.language = 'Spanish' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_spanish, c.name FROM cards c LEFT JOIN foreign_data fd ON c.uuid = fd.uuid AND fd.language = 'Spanish' GROUP BY c.name;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 29,
      "question": "How many seasons has Silverstone Circuit hosted the United Kindom grand prix?",
      "ground_truth": "SELECT COUNT(T2.circuitid) FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Silverstone Circuit' AND T2.name = 'British Grand Prix'",
      "db_id": "formula_1",
      "generated_rules": "Rule 1:\nCondition: When answering about seasons hosted by a specific circuit\nOperation: join circuits table as T1 with races table as T2 using T1.circuitId = T2.circuitId to link circuit information to race data.",
      "sql_with_rules": "SELECT COUNT(DISTINCT T2.year) FROM circuits AS T1 JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T1.name = 'Silverstone Circuit' AND T2.country = 'UK';",
      "sql_without_rules": "SELECT COUNT(DISTINCT r.year) FROM races r JOIN circuits c ON r.circuitId = c.circuitId WHERE c.name = 'Silverstone Circuit' AND r.country = 'UK';",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 30,
      "question": "What is the passing class of CLB team?",
      "ground_truth": "SELECT DISTINCT t2.buildUpPlayPassingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_short_name = 'CLB'",
      "db_id": "european_football_2",
      "generated_rules": "Rule 1:\nCondition: When the question asks about \"passing class\" of a team\nOperation: use the exact column token \"buildUpPlayPassingClass\" from the Team_Attributes table instead of \"passing_class\".",
      "sql_with_rules": "SELECT buildUpPlayPassingClass FROM Team_Attributes JOIN Team ON Team_Attributes.team_api_id = Team.team_api_id WHERE Team.team_long_name = 'CLB';",
      "sql_without_rules": "SELECT buildUpPlayPassingClass FROM Team_Attributes JOIN Team ON Team_Attributes.team_api_id = Team.team_api_id WHERE Team.team_short_name = 'CLB' ORDER BY Team_Attributes.date DESC LIMIT 1;",
      "result_with_rules": 0,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 31,
      "question": "Who finished second in the San Marino Grand Prix in 2006?",
      "ground_truth": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.year = 2006 AND T1.name = 'San Marino Grand Prix' AND T2.position = 2",
      "db_id": "formula_1",
      "generated_rules": "Rule 1:\nCondition: When the question asks about a specific race by name\nOperation: use the exact literal 'San Marino Grand Prix' for the race name filter.\n\nRule 2:\nCondition: When the question asks about a specific year\nOperation: use the exact literal 2006 for the year filter.\n\nRule 3:\nCondition: When the question asks about a specific race name\nOperation: use the exact literal 'Monaco Grand Prix' to filter the race name in the races table.",
      "sql_with_rules": "SELECT d.forename, d.surname FROM results r JOIN races rc ON r.raceId = rc.raceId JOIN drivers d ON r.driverId = d.driverId WHERE rc.name = 'San Marino Grand Prix' AND rc.year = 2006 AND r.position = 2;",
      "sql_without_rules": "SELECT d.forename, d.surname FROM results r JOIN races rc ON r.raceId = rc.raceId JOIN drivers d ON r.driverId = d.driverId WHERE rc.name = 'San Marino Grand Prix' AND rc.year = 2006 AND r.position = 2;",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 32,
      "question": "How many cards with unknown power that can't be found in foil is in duel deck A?",
      "ground_truth": "SELECT SUM(CASE WHEN power = '*' OR power IS NULL THEN 1 ELSE 0 END) FROM cards WHERE hasFoil = 0 AND duelDeck = 'a'",
      "db_id": "card_games",
      "generated_rules": "No definitional rules found.",
      "sql_with_rules": "SELECT COUNT(*) FROM cards WHERE power IS NULL AND hasFoil = 0 AND duelDeck = 'A';",
      "sql_without_rules": "SELECT COUNT(*) FROM cards WHERE duelDeck = 'a' AND power IS NULL AND hasFoil = 0;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 33,
      "question": "How many of the patients with the most serious thrombosis cases examined in 1997 are women?",
      "ground_truth": "SELECT  COUNT(*) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND STRFTIME('%Y', T2.`Examination Date`) = '1997' AND T2.Thrombosis = 1",
      "db_id": "thrombosis_prediction",
      "generated_rules": "No definitional rules found.",
      "sql_with_rules": "SELECT COUNT(DISTINCT p.ID) FROM Patient p JOIN Examination e ON p.ID = e.ID WHERE strftime('%Y', e.`Examination Date`) = '1997' AND p.SEX = 'F' AND e.Thrombosis = (SELECT MAX(Thrombosis) FROM Examination WHERE strftime('%Y', `Examination Date`) = '1997');",
      "sql_without_rules": "SELECT COUNT(DISTINCT p.ID) FROM Patient p JOIN Examination e ON p.ID = e.ID WHERE strftime('%Y', e.`Examination Date`) = '1997' AND e.Thrombosis = (SELECT MAX(Thrombosis) FROM Examination WHERE strftime('%Y', `Examination Date`) = '1997') AND p.SEX = 'F';",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 34,
      "question": "In February 2012, what percentage of customers consumed more than 528.3?",
      "ground_truth": "SELECT CAST(SUM(IIF(Consumption > 528.3, 1, 0)) AS FLOAT) * 100 / COUNT(CustomerID) FROM yearmonth WHERE Date = '201202'",
      "db_id": "debit_card_specializing",
      "generated_rules": "Rule 1:\nCondition: When the question asks for percentage of customers with consumption above a threshold\nOperation: use SUM(CASE WHEN Consumption > 528.3 THEN 1 ELSE 0 END) * 100 / COUNT(CustomerID) with explicit CAST to REAL instead of COUNT(*) with WHERE filter.\n\nRule 2:\nCondition: When the question asks for percentage\nOperation: do not divide by 100.0 factor as the percentage calculation should return the decimal value directly.",
      "sql_with_rules": "SELECT SUM(CASE WHEN Consumption > 528.3 THEN 1 ELSE 0 END) * 100.0 / COUNT(CustomerID) AS Percentage FROM yearmonth WHERE Date LIKE '2012-02%';",
      "sql_without_rules": "SELECT (COUNT(DISTINCT CASE WHEN y.Consumption > 528.3 THEN y.CustomerID END) * 100.0 / COUNT(DISTINCT y.CustomerID)) AS Percentage FROM yearmonth y WHERE y.Date LIKE '2012-02%';",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 35,
      "question": "For all patients who are older than 55 years old, what is the percentage of female who has abnormal prothrombin time (PT)?",
      "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.PT >= 14 AND T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 55",
      "db_id": "thrombosis_prediction",
      "generated_rules": "Rule 1:\nCondition: When the question asks for percentage\nOperation: do not divide by 100.0 factor as the percentage calculation should return the decimal value directly.\n\nRule 2:\nCondition: When the question asks for percentage of female patients with abnormal PT\nOperation: use SUM(CASE WHEN T1.SEX = 'Female' AND T2.PT = 'Abnormal' THEN 1 ELSE 0 END) for conditional counting instead of COUNT with CASE.\n\nRule 3:\nCondition: When the question asks for percentage of female patients with abnormal PT\nOperation: use SUM(CASE WHEN T1.SEX = 'Female' AND T2.PT = 'Abnormal' THEN 1 ELSE 0 END) for conditional counting instead of COUNT with CASE.\n\nRule 4:\nCondition: When the question asks for percentage of female patients with abnormal PT\nOperation: use SUM(CASE WHEN T1.SEX = 'Female' AND T2.PT = 'Abnormal' THEN 1 ELSE 0 END) * 100 / COUNT(T1.ID) instead of COUNT(*) with WHERE filters.\n\nRule 5:\nCondition: When the question asks for percentage of female patients with abnormal PT\nOperation: use SUM(CASE WHEN",
      "sql_with_rules": "SELECT (SUM(CASE WHEN T1.SEX = 'Female' AND T2.PT = 'Abnormal' THEN 1 ELSE 0 END) * 1.0 / COUNT(T1.ID)) AS percentage FROM Patient T1 JOIN Laboratory T2 ON T1.ID = T2.ID WHERE (julianday('now') - julianday(T1.Birthday)) / 365.25 > 55;",
      "sql_without_rules": "SELECT (COUNT(DISTINCT CASE WHEN p.SEX = 'F' AND l.PT IS NOT NULL AND l.PT <> (SELECT AVG(PT) FROM Laboratory WHERE PT IS NOT NULL) THEN p.ID END) * 100.0 / COUNT(DISTINCT CASE WHEN p.SEX = 'F' THEN p.ID END)) AS percentage FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE (julianday('now') - julianday(p.Birthday)) / 365.25 > 55;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 36,
      "question": "When did 'chl' cast its first vote in a post?",
      "ground_truth": "SELECT T2.CreationDate FROM users AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'chl' ORDER BY T2.CreationDate LIMIT 1",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks about a user's first vote\nOperation: use the \"votes\" table instead of \"posts\" table to access vote-related data.",
      "sql_with_rules": "SELECT MIN(v.CreationDate) FROM votes v JOIN users u ON v.UserId = u.Id WHERE u.DisplayName = 'chl';",
      "sql_without_rules": "SELECT MIN(v.CreationDate) FROM votes v JOIN users u ON v.UserId = u.Id WHERE u.DisplayName = 'chl';",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 37,
      "question": "How many unknown power cards contain info about the triggered ability",
      "ground_truth": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE (T1.power IS NULL OR T1.power = '*') AND T2.text LIKE '%triggered ability%'",
      "db_id": "card_games",
      "generated_rules": "Rule 1:\nCondition: When the question asks about \"unknown power cards\"\nOperation: use the condition \"power = '?' \" to identify cards with unknown power values.\n\nRule 2:\nCondition: When the question mentions \"triggered ability\"\nOperation: use the condition \"text LIKE '%trigger%' \" to find cards containing the word \"trigger\" in their text, indicating a triggered ability.",
      "sql_with_rules": "SELECT COUNT(*) FROM cards WHERE power = '?' AND text LIKE '%trigger%';",
      "sql_without_rules": "SELECT COUNT(*) FROM cards WHERE power IS NULL AND text LIKE '%when%' AND text LIKE '%trigger%';",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 38,
      "question": "Among all chemical compounds identified in the database, what percent of compounds form a triple-bond.",
      "ground_truth": "SELECT CAST(COUNT(CASE WHEN T.bond_type = '#' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id) FROM bond AS T",
      "db_id": "toxicology",
      "generated_rules": "Rule 1:\nCondition: When the question asks about chemical compounds forming triple bonds\nOperation: use the \"bond_type\" column from the \"bond\" table instead of \"bond_type\" from \"molecules\" table.",
      "sql_with_rules": "SELECT (COUNT(DISTINCT CASE WHEN b.bond_type = 'triple' THEN m.molecule_id END) * 100.0 / COUNT(DISTINCT m.molecule_id)) AS percent_triple_bond_compounds FROM molecule m JOIN bond b ON m.molecule_id = b.molecule_id;",
      "sql_without_rules": "SELECT (COUNT(DISTINCT CASE WHEN b.bond_type = 'triple' THEN m.molecule_id END) * 100.0 / COUNT(DISTINCT m.molecule_id)) AS percent_triple_bond_compounds FROM molecule m LEFT JOIN bond b ON m.molecule_id = b.molecule_id;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 39,
      "question": "What is the difference between players 6 and 23's jumping scores?",
      "ground_truth": "SELECT SUM(CASE WHEN t1.id = 6 THEN t1.jumping ELSE 0 END) - SUM(CASE WHEN t1.id = 23 THEN t1.jumping ELSE 0 END) FROM Player_Attributes AS t1",
      "db_id": "european_football_2",
      "generated_rules": "Rule 1:\nCondition: When the question asks for jumping scores\nOperation: use the exact column name \"jumping\" from the Player_Attributes table instead of \"jumping_score\".",
      "sql_with_rules": "SELECT (SELECT jumping FROM Player_Attributes WHERE player_api_id = 6 ORDER BY date DESC LIMIT 1) - (SELECT jumping FROM Player_Attributes WHERE player_api_id = 23 ORDER BY date DESC LIMIT 1) AS jumping_difference;",
      "sql_without_rules": "SELECT (SELECT jumping FROM Player_Attributes WHERE player_api_id = 6 ORDER BY date DESC LIMIT 1) - (SELECT jumping FROM Player_Attributes WHERE player_api_id = 23 ORDER BY date DESC LIMIT 1) AS jumping_difference;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 40,
      "question": "What was the gender of the first AORTITIS diagnosed patient?",
      "ground_truth": "SELECT SEX FROM Patient WHERE Diagnosis = 'AORTITIS' AND `First Date` IS NOT NULL ORDER BY `First Date` ASC LIMIT 1",
      "db_id": "thrombosis_prediction",
      "generated_rules": "Rule 1:\nCondition: When the question asks about gender\nOperation: use \"T1.gender\" from the \"gender_age\" table instead of \"sex\" from the \"patients\" table.\n\nRule 2:\nCondition: When the question asks about gender of a patient\nOperation: select \"SEX\" from the \"Patient\" table instead of \"gender\" from other tables.\n\nRule 3:\nCondition: When the question asks about gender\nOperation: use column \"gender\" from table \"gender_age\" (aliased as T1) instead of \"sex\" from \"patients\" table.",
      "sql_with_rules": "SELECT p.SEX FROM Patient p WHERE p.ID = ( SELECT e.ID FROM Examination e WHERE e.Diagnosis = 'AORTITIS' ORDER BY e.`Examination Date` LIMIT 1 );",
      "sql_without_rules": "SELECT p.SEX FROM Patient p WHERE p.Diagnosis = 'AORTITIS' ORDER BY p.`First Date` LIMIT 1;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 41,
      "question": "For the patient who was diagnosed SLE on 1997/1/27, what was his/her original diagnose when he/she came to the hospital for the first time?",
      "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.ID = ( SELECT ID FROM Examination WHERE `Examination Date` = '1997-01-27' AND Diagnosis = 'SLE' ) AND T2.`Examination Date` = T1.`First Date`",
      "db_id": "thrombosis_prediction",
      "generated_rules": "Rule 1:\nCondition: When the question asks about a patient's original diagnosis\nOperation: use the exact column token \"Diagnosis\" from the Patient table.",
      "sql_with_rules": "SELECT p.Diagnosis FROM Patient p JOIN Examination e ON p.ID = e.ID WHERE e.Diagnosis = 'SLE' AND e.\"Examination Date\" = '1997-01-27';",
      "sql_without_rules": "SELECT p.Diagnosis FROM Patient p JOIN Examination e ON p.ID = e.ID WHERE e.Diagnosis = 'SLE' AND e.\"Examination Date\" = '1997-01-27' LIMIT 1;",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 42,
      "question": "What are the name of badges that users who have the lowest reputation obtained?",
      "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.Reputation = (SELECT MIN(Reputation) FROM users)",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks for badge names\nOperation: select \"T2\".\"Name\" from the \"Badges\" table instead of \"badge_name\" from a \"users\" table.",
      "sql_with_rules": "SELECT DISTINCT b.Name FROM badges b JOIN users u ON b.UserId = u.Id WHERE u.Reputation = (SELECT MIN(Reputation) FROM users);",
      "sql_without_rules": "SELECT DISTINCT b.Name FROM badges b JOIN users u ON b.UserId = u.Id WHERE u.Reputation = (SELECT MIN(Reputation) FROM users);",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 43,
      "question": "Sum up the away team goal scored by both Daan Smith and Filipe Ferreira.",
      "ground_truth": "SELECT SUM(t2.away_team_goal) FROM Player AS t1 INNER JOIN match AS t2 ON t1.player_api_id = t2.away_player_5 WHERE t1.player_name IN ('Daan Smith', 'Filipe Ferreira')",
      "db_id": "european_football_2",
      "generated_rules": "Rule 1:\nCondition: When the question asks for goals scored by specific players\nOperation: use SUM(CASE WHEN T1.Player_Name = 'Daan Smith' THEN T2.Away_Goals ELSE 0 END) for Daan Smith and SUM(CASE WHEN T1.Player_Name = 'Filipe Ferreira' THEN T2.Away_Goals ELSE 0 END) for Filipe Ferreira instead of direct column references.",
      "sql_with_rules": "SELECT SUM(CASE WHEN p.player_name = 'Daan Smith' THEN m.away_team_goal ELSE 0 END) AS goals_daan_smith, SUM(CASE WHEN p.player_name = 'Filipe Ferreira' THEN m.away_team_goal ELSE 0 END) AS goals_filipe_ferreira FROM Match m JOIN Player p ON p.player_api_id IN ( m.away_player_1, m.away_player_2, m.away_player_3, m.away_player_4, m.away_player_5, m.away_player_6, m.away_player_7, m.away_player_8, m.away_player_9, m.away_player_10, m.away_player_11 ) WHERE p.player_name IN ('Daan Smith', 'Filipe Ferreira');",
      "sql_without_rules": "SELECT SUM(m.away_team_goal) FROM Match m JOIN Player p1 ON m.away_player_1 = p1.player_api_id OR m.away_player_2 = p1.player_api_id OR m.away_player_3 = p1.player_api_id OR m.away_player_4 = p1.player_api_id OR m.away_player_5 = p1.player_api_id OR m.away_player_6 = p1.player_api_id OR m.away_player_7 = p1.player_api_id OR m.away_player_8 = p1.player_api_id OR m.away_player_9 = p1.player_api_id OR m.away_player_10 = p1.player_api_id OR m.away_player_11 = p1.player_api_id JOIN Player p2 ON m.away_player_1 = p2.player_api_id OR m.away_player_2 = p2.player_api_id OR m.away_player_3 = p2.player_api_id OR m.away_player_4 = p2.player_api_id OR m.away_player_5 = p2.player_api_id OR m.away_player_6 = p2.player_api_id OR m.away_player_7 = p2.player_api_id OR m.away_player_8 = p2.player_api_id OR m.away_player_9 = p2.player_api_id OR m.away_player_10 = p2.player_api_id OR m.away_player_11 = p2.player_api_id WHERE p1.player_name = 'Daan Smith' AND p2.player_name = 'Filipe Ferreira';",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 44,
      "question": "Give the texts commented on the post about linear regression.",
      "ground_truth": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title LIKE '%linear regression%'",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks for \"texts commented on the post\"\nOperation: select \"T2.Text\" from the \"comments\" table instead of \"text\" from \"posts\".",
      "sql_with_rules": "SELECT c.Text FROM comments c JOIN posts p ON c.PostId = p.Id WHERE p.Title LIKE '%linear regression%' OR p.Tags LIKE '%linear-regression%' OR p.Body LIKE '%linear regression%';",
      "sql_without_rules": "SELECT c.Text FROM comments c JOIN posts p ON c.PostId = p.Id WHERE p.Title LIKE '%linear regression%' OR p.Tags LIKE '%linear-regression%' OR p.Body LIKE '%linear regression%';",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 45,
      "question": "Among the accounts who have approved loan date in 1997, list out the accounts that have the lowest approved amount and choose weekly issuance statement.",
      "ground_truth": "SELECT T2.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T1.date) = '1997' AND T2.frequency = 'POPLATEK TYDNE' ORDER BY T1.amount LIMIT 1",
      "db_id": "financial",
      "generated_rules": "Rule 1:\nCondition: When the question asks for accounts with approved loan date in 1997\nOperation: filter rows where T1.date LIKE '%/%/97' instead of using STRFTIME.\n\nRule 2:\nCondition: When the question asks for accounts with approved loan date in 1997\nOperation: filter rows where T1.date LIKE '%/%/97' instead of using STRFTIME.\n\nRule 3:\nCondition: When the question asks for accounts with approved loan date in 1997\nOperation: filter rows where T1.date LIKE '%/%/97' instead of using date functions.\n\nRule 4:\nCondition: When the question asks for accounts with approved loan date in 1997\nOperation: filter rows where T1.date LIKE '%/%/97' instead of using date functions.\n\nRule 5:\nCondition: When the question asks for accounts with approved loan date in 1997\nOperation: filter rows where T1.date matches the exact date format pattern '%/%/97'.\n\nRule 6:\nCondition: When the question asks for accounts with approved loan date in 1997\nOperation: filter rows where T1.date matches the exact date",
      "sql_with_rules": "SELECT a.account_id FROM account a JOIN loan l ON a.account_id = l.account_id WHERE l.date LIKE '%/%/97' AND l.status = 'A' AND l.amount = (SELECT MIN(amount) FROM loan WHERE date LIKE '%/%/97' AND status = 'A') AND a.frequency = 'WEEKLY ISSUANCE STATEMENT';",
      "sql_without_rules": "SELECT DISTINCT a.account_id FROM account a JOIN loan l ON a.account_id = l.account_id WHERE l.status = 'A' AND strftime('%Y', l.date) = '1997' AND l.amount = ( SELECT MIN(amount) FROM loan WHERE status = 'A' AND strftime('%Y', date) = '1997' ) AND a.frequency = 'WEEKLY ISSUANCE STATEMENT';",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 46,
      "question": "Which bond type accounted for the majority of the bonds found in molecule TR010 and state whether or not this molecule is carcinogenic?",
      "ground_truth": "SELECT T.bond_type FROM ( SELECT T1.bond_type, COUNT(T1.molecule_id) FROM bond AS T1  WHERE T1.molecule_id = 'TR010' GROUP BY T1.bond_type ORDER BY COUNT(T1.molecule_id) DESC LIMIT 1 ) AS T",
      "db_id": "toxicology",
      "generated_rules": "Rule 1:\nCondition: When the question asks about bond type in molecule TR010\nOperation: use the exact molecule identifier 'TR010' with proper case sensitivity.",
      "sql_with_rules": "SELECT b.bond_type, m.label = 'carcinogenic' AS is_carcinogenic FROM bond b JOIN molecule m ON b.molecule_id = m.molecule_id WHERE b.molecule_id = 'TR010' GROUP BY b.bond_type, m.label ORDER BY COUNT(*) DESC LIMIT 1;",
      "sql_without_rules": "SELECT b.bond_type, m.label = 'carcinogenic' AS is_carcinogenic FROM bond b JOIN molecule m ON b.molecule_id = m.molecule_id WHERE m.molecule_id = 'TR010' GROUP BY b.bond_type, m.label ORDER BY COUNT(*) DESC LIMIT 1;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 47,
      "question": "Name the foreign name of the card that has boros watermark? List out the type of this card.",
      "ground_truth": "SELECT DISTINCT T1.name, T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'boros'",
      "db_id": "card_games",
      "generated_rules": "Rule 1:\nCondition: When the question asks for foreign names and types of cards\nOperation: select T2.name and T1.type from the cards table as T1 and foreign_data table as T2.",
      "sql_with_rules": "SELECT T2.name, T1.type FROM cards AS T1 JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.watermark = 'boros';",
      "sql_without_rules": "SELECT fd.name AS foreign_name, c.type FROM cards c JOIN foreign_data fd ON c.uuid = fd.uuid WHERE c.watermark = 'boros' LIMIT 1;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 48,
      "question": "What is the most common sign of patients with SLE disease?",
      "ground_truth": "SELECT Symptoms FROM Examination WHERE Diagnosis = 'SLE' GROUP BY Symptoms ORDER BY COUNT(Symptoms) DESC LIMIT 1",
      "db_id": "thrombosis_prediction",
      "generated_rules": "Rule 1:\nCondition: When the question asks about signs of patients with SLE disease\nOperation: use the \"Symptoms\" column from the \"Examination\" table instead of any \"signs\" column.",
      "sql_with_rules": "SELECT Symptoms, COUNT(*) as frequency FROM Examination WHERE Diagnosis LIKE '%SLE%' GROUP BY Symptoms ORDER BY frequency DESC LIMIT 1;",
      "sql_without_rules": "SELECT Symptoms, COUNT(*) as frequency FROM Examination WHERE Diagnosis LIKE '%SLE%' GROUP BY Symptoms ORDER BY frequency DESC LIMIT 1;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 49,
      "question": "What is the display name of the user who acquired the highest amount of badges?",
      "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId GROUP BY T1.DisplayName ORDER BY COUNT(T1.Id) DESC LIMIT 1",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks for \"display name\"\nOperation: use the exact column token \"DisplayName\" from the users table.\n\nRule 2:\nCondition: When the question asks for \"display name\"\nOperation: use the exact column token \"DisplayName\" from the users table.\n\nRule 3:\nCondition: When the question asks for \"display name\"\nOperation: use the exact column token \"Name\" from the users table.\n\nRule 4:\nCondition: When the question asks for \"display name\"\nOperation: use the exact column token \"Name\" from the users table.\n\nRule 5:\nCondition: When the question asks for \"display name\"\nOperation: use the exact column token \"Name\" from the users table.\n\nRule 6:\nCondition: When the question asks for \"display name\"\nOperation: use the exact column token \"Name\" from the users table.\n\nRule 7:\nCondition: When the question asks for \"display name\"\nOperation: use the exact column token \"Name\" from the users table.\n\nRule 8:\nCondition: When the question asks for \"display name\"\nOperation: use the exact column token \"Name\" from the users table.",
      "sql_with_rules": "SELECT u.DisplayName FROM users u JOIN badges b ON u.Id = b.UserId GROUP BY u.Id, u.DisplayName ORDER BY COUNT(b.Id) DESC LIMIT 1;",
      "sql_without_rules": "SELECT u.DisplayName FROM users u JOIN badges b ON u.Id = b.UserId GROUP BY u.Id, u.DisplayName ORDER BY COUNT(b.Id) DESC LIMIT 1;",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 50,
      "question": "Which carcinogenic molecule have the highest number of atoms consisted in it?",
      "ground_truth": "SELECT T.molecule_id FROM ( SELECT T2.molecule_id, COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' GROUP BY T2.molecule_id ORDER BY COUNT(T1.atom_id) DESC LIMIT 1 ) t",
      "db_id": "toxicology",
      "generated_rules": "Rule 1:\nCondition: When answering about carcinogenic molecules\nOperation: join molecule table as T1 with atoms table as T2 using T1.molecule_id = T2.molecule_id to link molecules with their atoms.",
      "sql_with_rules": "SELECT m.molecule_id, m.label, COUNT(a.atom_id) AS atom_count FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id WHERE m.label = 'carcinogenic' GROUP BY m.molecule_id, m.label ORDER BY atom_count DESC LIMIT 1;",
      "sql_without_rules": "SELECT m.molecule_id, m.label, COUNT(a.atom_id) AS atom_count FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id WHERE m.label = 'carcinogenic' GROUP BY m.molecule_id, m.label ORDER BY atom_count DESC LIMIT 1;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 51,
      "question": "Among the members who incurred expenses in more than one event, who paid the most amount?",
      "ground_truth": "SELECT T2.member_id FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN budget AS T3 ON T1.link_to_budget = T3.budget_id INNER JOIN event AS T4 ON T3.link_to_event = T4.event_id GROUP BY T2.member_id HAVING COUNT(DISTINCT T4.event_id) > 1 ORDER BY SUM(T1.cost) DESC LIMIT 1",
      "db_id": "student_club",
      "generated_rules": "Rule 1:\nCondition: When answering about members who incurred expenses in more than one event\nOperation: use expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id as the data source.",
      "sql_with_rules": "SELECT T2.member_id, T2.first_name, T2.last_name, SUM(T1.cost) as total_expense FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T1.link_to_member IN ( SELECT link_to_member FROM expense GROUP BY link_to_member HAVING COUNT(DISTINCT link_to_budget) > 1 ) GROUP BY T2.member_id, T2.first_name, T2.last_name ORDER BY total_expense DESC LIMIT 1;",
      "sql_without_rules": "SELECT m.first_name, m.last_name, SUM(e.cost) AS total_expense FROM member m JOIN expense e ON m.member_id = e.link_to_member JOIN budget b ON e.link_to_budget = b.budget_id WHERE m.member_id IN ( SELECT e2.link_to_member FROM expense e2 JOIN budget b2 ON e2.link_to_budget = b2.budget_id GROUP BY e2.link_to_member HAVING COUNT(DISTINCT b2.link_to_event) > 1 ) GROUP BY m.member_id ORDER BY total_expense DESC LIMIT 1;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 52,
      "question": "List down the long name for slow speed class team.",
      "ground_truth": "SELECT DISTINCT t1.team_long_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlaySpeedClass = 'Slow'",
      "db_id": "european_football_2",
      "generated_rules": "Rule 1:\nCondition: When the question asks for \"long name\"\nOperation: use the exact column token \"long_name\" from the appropriate table.\n\nRule 2:\nCondition: When the question mentions \"slow speed class team\"\nOperation: filter using \"T1.speed = 'slow'\" where T1 is the Team table.\n\nRule 3:\nCondition: When the question asks for \"long name\"\nOperation: use the exact column token \"long_name\" from table \"country\" instead of \"short_name\".\n\nRule 4:\nCondition: When the question asks for \"long name\"\nOperation: select T1.long_name instead of long_name.",
      "sql_with_rules": "SELECT Team.team_long_name FROM Team JOIN Team_Attributes ON Team.team_api_id = Team_Attributes.team_api_id WHERE Team_Attributes.buildUpPlaySpeedClass = 'Slow';",
      "sql_without_rules": "SELECT DISTINCT t.team_long_name FROM Team t JOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id WHERE ta.buildUpPlaySpeedClass = 'Slow';",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 53,
      "question": "In comments with score between 1 to 5, list down the display names of the users with 0 down votes.",
      "ground_truth": "SELECT T2.DisplayName FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Score BETWEEN 1 AND 5 AND T2.DownVotes = 0",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks for user display names\nOperation: use \"T2.DisplayName\" from the \"users\" table instead of \"user_name\" from \"users\".\n\nRule 2:\nCondition: When the question asks for user display names\nOperation: use \"T1.DisplayName\" instead of \"user_name\" in the output.",
      "sql_with_rules": "SELECT DISTINCT T2.DisplayName FROM comments JOIN users T2 ON comments.UserId = T2.Id WHERE comments.Score BETWEEN 1 AND 5 AND T2.DownVotes = 0;",
      "sql_without_rules": "SELECT DISTINCT u.DisplayName FROM comments c JOIN users u ON c.UserId = u.Id WHERE c.Score BETWEEN 1 AND 5 AND u.DownVotes = 0;",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 54,
      "question": "Calculate the difference between Emil Blonsky's weight and Charles Chandler's weight.",
      "ground_truth": "SELECT ( SELECT weight_kg FROM superhero WHERE full_name LIKE 'Emil Blonsky' ) - ( SELECT weight_kg FROM superhero WHERE full_name LIKE 'Charles Chandler' ) AS CALCULATE",
      "db_id": "superhero",
      "generated_rules": "Rule 1:\nCondition: When the question asks for weight difference between specific characters\nOperation: use conditional aggregation with SUM to handle multiple characters instead of direct column references.",
      "sql_with_rules": "SELECT SUM(CASE WHEN s.superhero_name = 'Emil Blonsky' THEN s.weight_kg ELSE -s.weight_kg END) AS weight_difference FROM superhero s WHERE s.superhero_name IN ('Emil Blonsky', 'Charles Chandler');",
      "sql_without_rules": "SELECT ABS( (SELECT s1.weight_kg FROM superhero s1 WHERE s1.superhero_name = 'Emil Blonsky') - (SELECT s2.weight_kg FROM superhero s2 WHERE s2.superhero_name = 'Charles Chandler') ) AS weight_difference;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 55,
      "question": "Write down the ruling of Beacon of Immortality.",
      "ground_truth": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Beacon of Immortality'",
      "db_id": "card_games",
      "generated_rules": "Rule 1:\nCondition: When the question asks for a ruling about a specific card\nOperation: use the exact card name literal 'Beacon of Immortality' with proper case and spacing.",
      "sql_with_rules": "SELECT r.text FROM rulings r JOIN cards c ON r.uuid = c.uuid WHERE c.name = 'Beacon of Immortality';",
      "sql_without_rules": "SELECT r.text FROM rulings r JOIN cards c ON r.uuid = c.uuid WHERE c.name = 'Beacon of Immortality';",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 56,
      "question": "What is the label for bond ID TR001_10_11?",
      "ground_truth": "SELECT T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_id = 'TR001_10_11'",
      "db_id": "toxicology",
      "generated_rules": "Rule 1:\nCondition: When the question asks for \"label\" of a bond\nOperation: \"label\" actually means \"bond_type\" in the bond table.",
      "sql_with_rules": "SELECT bond_type FROM bond WHERE bond_id = 'TR001_10_11';",
      "sql_without_rules": "SELECT m.label FROM bond b JOIN molecule m ON b.molecule_id = m.molecule_id WHERE b.bond_id = 'TR001_10_11';",
      "result_with_rules": 0,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 57,
      "question": "Was each expense in October Meeting on October 8, 2019 approved?",
      "ground_truth": "SELECT T3.approved FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'October Meeting' AND T1.event_date LIKE '2019-10-08%'",
      "db_id": "student_club",
      "generated_rules": "Rule 1:\nCondition: When answering about expense approval status\nOperation: select only the \"approved\" column from the \"expense\" table instead of all columns.\n\nRule 2:\nCondition: When the question mentions \"October Meeting\"\nOperation: \"October Meeting\" actually means \"T1.event_name = 'October Meeting'\" in schema.\n\nRule 3:\nCondition: When the question mentions \"October 8, 2019\"\nOperation: \"October 8, 2019\" actually means \"T1.event_date = '2019-10-08'\" in schema.",
      "sql_with_rules": "SELECT expense.approved FROM expense JOIN budget ON expense.link_to_budget = budget.budget_id JOIN event ON budget.link_to_event = event.event_id WHERE event.event_name = 'October Meeting' AND event.event_date = '2019-10-08';",
      "sql_without_rules": "SELECT e.expense_description, e.approved FROM expense e JOIN budget b ON e.link_to_budget = b.budget_id JOIN event ev ON b.link_to_event = ev.event_id WHERE ev.event_name = 'October Meeting' AND ev.event_date = '2019-10-08';",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 58,
      "question": "How many matches in the 2008/2009 season were held in Belgium?",
      "ground_truth": "SELECT COUNT(t2.id) FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Belgium' AND t2.season = '2008/2009'",
      "db_id": "european_football_2",
      "generated_rules": "Rule 1:\nCondition: When answering about matches in a specific season and country\nOperation: join Match table (T1) with League table (T2) using T1.league_id = T2.id and with Country table (T3) using T2.country_id = T3.id instead of querying only the matches table.",
      "sql_with_rules": "SELECT COUNT(*) FROM Match T1 JOIN League T2 ON T1.league_id = T2.id JOIN Country T3 ON T2.country_id = T3.id WHERE T1.season = '2008/2009' AND T3.name = 'Belgium';",
      "sql_without_rules": "SELECT COUNT(*) FROM Match JOIN Country ON Match.country_id = Country.id WHERE Country.name = 'Belgium' AND Match.season = '2008/2009';",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 59,
      "question": "Please list the ID of the patient whose RF is normal and who is older than 60.",
      "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RF < 20 AND STRFTIME('%Y', DATE('now')) - STRFTIME('%Y', T1.Birthday) > 60",
      "db_id": "thrombosis_prediction",
      "generated_rules": "Rule 1:\nCondition: When the question asks about RF status\nOperation: use the exact column \"RF\" from the Laboratory table with the exact literal value 'Negative' instead of numeric comparisons.\n\nRule 2:\nCondition: When the question asks about patient age\nOperation: calculate age by subtracting birthday from '1990-01-01' instead of using a direct age column.",
      "sql_with_rules": "SELECT DISTINCT p.ID FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE l.RF = 'Negative' AND (julianday('1990-01-01') - julianday(p.Birthday)) / 365.25 > 60;",
      "sql_without_rules": "SELECT DISTINCT p.ID FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE l.RF = 'normal' AND (julianday('now') - julianday(p.Birthday)) / 365.25 > 60;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 60,
      "question": "Of all the schools with a mailing state address in California, how many are active in San Joaquin city?",
      "ground_truth": "SELECT COUNT(CDSCode) FROM schools WHERE City = 'San Joaquin' AND MailState = 'CA' AND StatusType = 'Active'",
      "db_id": "california_schools",
      "generated_rules": "No definitional rules found.",
      "sql_with_rules": "SELECT COUNT(*) FROM schools WHERE MailState = 'CA' AND City = 'San Joaquin' AND StatusType = 'Active';",
      "sql_without_rules": "SELECT COUNT(*) FROM schools WHERE MailState = 'CA' AND City = 'San Joaquin' AND StatusType = 'Active';",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 61,
      "question": "List the full name of the Student_Club members that grew up in Illinois state.",
      "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.state = 'Illinois'",
      "db_id": "student_club",
      "generated_rules": "Rule 1:\nCondition: When answering about \"Student_Club members\"\nOperation: filter members where \"position\" equals 'Student_Club' exactly.\n\nRule 2:\nCondition: When the question mentions \"grew up in Illinois state\"\nOperation: use \"state\" from zip_code table (T2) with exact value 'Illinois' instead of 'Illinois_state'.",
      "sql_with_rules": "SELECT m.first_name, m.last_name FROM member m JOIN zip_code z ON m.zip = z.zip_code WHERE m.position = 'Student_Club' AND z.state = 'Illinois';",
      "sql_without_rules": "SELECT m.first_name, m.last_name FROM member m JOIN zip_code z ON m.zip = z.zip_code WHERE z.state = 'Illinois';",
      "result_with_rules": 0,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 62,
      "question": "What is the average number of crimes committed in 1995 in regions where the number exceeds 4000 and the region has accounts that are opened starting from the year 1997?",
      "ground_truth": "SELECT AVG(T1.A15) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) >= '1997' AND T1.A15 > 4000",
      "db_id": "financial",
      "generated_rules": "Rule 1:\nCondition: When the question asks for average number of crimes\nOperation: compute the average of the exact token \"T2.crimes\" instead of counting rows.",
      "sql_with_rules": "SELECT AVG(T2.crimes) FROM district JOIN account ON district.district_id = account.district_id WHERE district.A15 > 4000 AND account.date >= '1997-01-01' AND district.A15 IS NOT NULL;",
      "sql_without_rules": "SELECT AVG(A16) FROM district WHERE A16 > 4000 AND district_id IN ( SELECT district_id FROM account WHERE strftime('%Y', date) >= '1997' );",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 63,
      "question": "What is the carcinogenic label for bond TR001_2_4?",
      "ground_truth": "SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_id = 'TR001_2_4'",
      "db_id": "toxicology",
      "generated_rules": "Rule 1:\nCondition: When the question asks about a bond's carcinogenic label\nOperation: join the bond table (T1) with the molecule table (T2) using T1.molecule_id = T2.molecule_id to access the label information.",
      "sql_with_rules": "SELECT T2.label FROM bond AS T1 JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_id = 'TR001_2_4';",
      "sql_without_rules": "SELECT m.label FROM molecule m JOIN bond b ON m.molecule_id = b.molecule_id WHERE b.bond_id = 'TR001_2_4';",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 64,
      "question": "What is reference name of Robert Kubica?",
      "ground_truth": "SELECT driverRef FROM drivers WHERE forename = 'Robert' AND surname = 'Kubica'",
      "db_id": "formula_1",
      "generated_rules": "Rule 1:\nCondition: When the question asks for a driver's reference name\nOperation: select \"T1.driverRef\" instead of \"driver_name\" from the drivers table.",
      "sql_with_rules": "SELECT driverRef FROM drivers WHERE forename = 'Robert' AND surname = 'Kubica';",
      "sql_without_rules": "SELECT driverRef FROM drivers WHERE forename = 'Robert' AND surname = 'Kubica';",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 65,
      "question": "List out the position of members who joined major of Business.",
      "ground_truth": "SELECT T2.position FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T1.major_name = 'Business'",
      "db_id": "student_club",
      "generated_rules": "Rule 1:\nCondition: When the question asks for \"position of members\"\nOperation: use the exact column token \"position\" from table \"member\" (aliased as T1).\n\nRule 2:\nCondition: When the question mentions \"joined major of Business\"\nOperation: filter using the exact literal 'Business' on column \"major_name\" from table \"major\" (aliased as T2).",
      "sql_with_rules": "SELECT DISTINCT T1.position FROM member T1 JOIN major T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Business';",
      "sql_without_rules": "SELECT DISTINCT m.position FROM member m JOIN major maj ON m.link_to_major = maj.major_id WHERE maj.major_name = 'Business';",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 66,
      "question": "Give the code of sets have expansion commander type?",
      "ground_truth": "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.type = 'commander'",
      "db_id": "card_games",
      "generated_rules": "Rule 1:\nCondition: When the question asks for \"code of sets\"\nOperation: select the exact column \"code\" from table \"sets\" instead of \"set_code\".\n\nRule 2:\nCondition: When the question mentions \"expansion commander type\"\nOperation: filter on the exact column \"type\" with the exact literal value 'expansion commander'.",
      "sql_with_rules": "SELECT code FROM sets WHERE type = 'expansion commander';",
      "sql_without_rules": "SELECT DISTINCT s.code FROM sets s WHERE s.type = 'expansion' AND s.code IN ( SELECT DISTINCT c.setCode FROM cards c WHERE c.types LIKE '%Commander%' );",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 67,
      "question": "Find the percentage of atoms with single bond.",
      "ground_truth": "SELECT CAST(COUNT(CASE WHEN T.bond_type = '-' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id) FROM bond t",
      "db_id": "toxicology",
      "generated_rules": "Rule 1:\nCondition: When the question asks for percentage of atoms with single bonds\nOperation: use SUM(CASE WHEN T2.bond_type = 'single' THEN 1 ELSE 0 END) to count single bonds instead of counting atoms.\n\nRule 2:\nCondition: When the question asks for percentage\nOperation: do not divide by 100.0 factor as the percentage calculation should return the decimal value directly.",
      "sql_with_rules": "SELECT (SUM(CASE WHEN b.bond_type = 'single' THEN 1 ELSE 0 END) * 1.0 / COUNT(*)) AS percentage FROM connected c JOIN bond b ON c.bond_id = b.bond_id;",
      "sql_without_rules": "SELECT (COUNT(DISTINCT CASE WHEN b.bond_type = 'single' THEN c.atom_id END) * 100.0 / COUNT(DISTINCT a.atom_id)) AS percentage FROM atom a LEFT JOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2 LEFT JOIN bond b ON c.bond_id = b.bond_id;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 68,
      "question": "List the title of posts which were edited by Vebjorn Ljosa.",
      "ground_truth": "SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Vebjorn Ljosa'",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks for posts edited by a specific user\nOperation: join the posts table (T1) with the Vote table (T2) using the condition T1.Id = T2.PostId to find related edits.",
      "sql_with_rules": "SELECT DISTINCT p.Title FROM posts p JOIN votes v ON p.Id = v.PostId JOIN users u ON v.UserId = u.Id WHERE u.DisplayName = 'Vebjorn Ljosa';",
      "sql_without_rules": "SELECT p.Title FROM posts p JOIN postHistory ph ON p.Id = ph.PostId JOIN users u ON ph.UserId = u.Id WHERE u.DisplayName = 'Vebjorn Ljosa' AND ph.PostHistoryTypeId = 5;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 69,
      "question": "How many patients with a normal level of complement 3 have a P pattern observed in the sheet of ANA examination?",
      "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.C3 > 35 AND T1.`ANA Pattern` = 'P'",
      "db_id": "thrombosis_prediction",
      "generated_rules": "Rule 1:\nCondition: When the question asks about patients with a normal level of complement 3\nOperation: use \"C3 = 'Normal'\" instead of numeric comparison to match the correct categorical value format.\n\nRule 2:\nCondition: When the question mentions a P pattern observed in ANA examination\nOperation: use \"ANA = 'P'\" instead of \"ANA Pattern = 'P'\" to reference the correct column name and value format.",
      "sql_with_rules": "SELECT COUNT(DISTINCT p.ID) FROM Patient p JOIN Laboratory l ON p.ID = l.ID JOIN Examination e ON p.ID = e.ID WHERE l.C3 = 'Normal' AND e.ANA = 'P';",
      "sql_without_rules": "SELECT COUNT(DISTINCT p.ID) FROM Patient p JOIN Examination e ON p.ID = e.ID JOIN Laboratory l ON p.ID = l.ID WHERE l.C3 BETWEEN 86 AND 160 AND e.`ANA Pattern` = 'P';",
      "result_with_rules": 0,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 70,
      "question": "How many translations of the name of the set \"Tenth Edition\"?",
      "ground_truth": "SELECT COUNT(DISTINCT T2.translation) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.name = 'Tenth Edition' AND T2.translation IS NOT NULL",
      "db_id": "card_games",
      "generated_rules": "Rule 1:\nCondition: When the question asks about translations of a set name\nOperation: use the \"set_translations\" table instead of the \"sets\" table.",
      "sql_with_rules": "SELECT COUNT(*) FROM set_translations WHERE setCode = (SELECT code FROM sets WHERE name = 'Tenth Edition');",
      "sql_without_rules": "SELECT COUNT(*) FROM set_translations WHERE setCode = (SELECT code FROM sets WHERE name = 'Tenth Edition');",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 71,
      "question": "Calculate the total atoms with triple-bond molecules containing the element phosphorus or bromine.",
      "ground_truth": "SELECT COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#' AND T1.element IN ('p', 'br')",
      "db_id": "toxicology",
      "generated_rules": "No definitional rules found.",
      "sql_with_rules": "SELECT COUNT(DISTINCT a.atom_id) FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id JOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2 JOIN bond b ON c.bond_id = b.bond_id WHERE b.bond_type = 'triple' AND (a.element = 'phosphorus' OR a.element = 'bromine');",
      "sql_without_rules": "SELECT COUNT(DISTINCT a.atom_id) FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id JOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2 JOIN bond b ON c.bond_id = b.bond_id WHERE b.bond_type = 'triple' AND (a.element = 'phosphorus' OR a.element = 'bromine');",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 72,
      "question": "What is the average score in writing for the schools that were opened after 1991 or closed before 2000? List the school names along with the score. Also, list the communication number of the schools if there is any.",
      "ground_truth": "SELECT T2.School, T1.AvgScrWrite, T2.Phone FROM schools AS T2 LEFT JOIN satscores AS T1 ON T2.CDSCode = T1.cds WHERE strftime('%Y', T2.OpenDate) > '1991' OR strftime('%Y', T2.ClosedDate) < '2000'",
      "db_id": "california_schools",
      "generated_rules": "Rule 1:\nCondition: When answering about average writing scores\nOperation: use AVG(T1.AvgScrWrite) instead of AVG(writing_score) and ensure proper table qualification.\n\nRule 2:\nCondition: When the question mentions \"communication number\"\nOperation: \"communication number\" actually means T2.telephone in the schema.\n\nRule 3:\nCondition: When the question asks for school names\nOperation: use \"T1.chronname\" instead of \"school_name\" as the exact identifier.\n\nRule 4:\nCondition: When the question asks for school names\nOperation: use \"T2.chronname\" instead of \"school_name\" as the exact identifier.\n\nRule 5:\nCondition: When the question asks for school names\nOperation: use \"T1.chronname\" instead of \"school_name\" as the exact identifier.\n\nRule 6:\nCondition: When the question asks for school names\nOperation: use \"T1.chronname\" instead of \"school_name\" to retrieve the correct school names from the schools table.\n\nRule 7:\nCondition: When the question asks for school names\nOperation: use \"T2.chronname\" instead of \"school_name\" as the exact identifier.\n\nRule 8:\nCondition: When the",
      "sql_with_rules": "SELECT T1.chronname, AVG(T1.AvgScrWrite), T2.telephone FROM satscores T1 JOIN schools T2 ON T1.cds = T2.CDSCode WHERE T2.OpenDate > '1991-12-31' OR T2.ClosedDate < '2000-01-01' GROUP BY T1.chronname, T2.telephone;",
      "sql_without_rules": "SELECT s.School, sat.AvgScrWrite, s.Phone FROM schools s JOIN satscores sat ON s.CDSCode = sat.cds WHERE (s.OpenDate > '1991-12-31' OR s.ClosedDate < '2000-01-01') AND sat.AvgScrWrite IS NOT NULL;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 73,
      "question": "How many percent of LAM customer consumed more than 46.73?",
      "ground_truth": "SELECT CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM'",
      "db_id": "debit_card_specializing",
      "generated_rules": "Rule 1:\nCondition: When the question asks for percentage of customers with consumption greater than a threshold\nOperation: use SUM(CASE WHEN Consumption > 46.73 THEN 1 ELSE 0 END) * 100 / COUNT(CustomerID) instead of COUNT(*) with a WHERE filter.",
      "sql_with_rules": "SELECT SUM(CASE WHEN Consumption > 46.73 THEN 1 ELSE 0 END) * 100.0 / COUNT(CustomerID) FROM yearmonth ym JOIN customers c ON ym.CustomerID = c.CustomerID WHERE c.Segment = 'LAM';",
      "sql_without_rules": "SELECT (COUNT(CASE WHEN y.Consumption > 46.73 THEN 1 END) * 100.0 / COUNT(*)) AS Percentage FROM yearmonth y JOIN customers c ON y.CustomerID = c.CustomerID WHERE c.Segment = 'LAM';",
      "result_with_rules": 0,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 74,
      "question": "What is the comment's rating score of the post which was created on 7/19/2010 7:19:56 PM",
      "ground_truth": "SELECT T1.Score FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.CreationDate = '2010-07-19 19:19:56.0'",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks for \"comment's rating score\"\nOperation: select the exact column \"Score\" from table \"comments\" (aliased as T2).\n\nRule 2:\nCondition: When the question mentions a post creation date \"7/19/2010 7:19:56 PM\"\nOperation: filter using the exact column \"CreationDate\" from table \"posts\" (aliased as T1) with the exact literal value '2010-07-19 19:19:56'.",
      "sql_with_rules": "SELECT T2.Score FROM posts T1 JOIN comments T2 ON T1.Id = T2.PostId WHERE T1.CreationDate = '2010-07-19 19:19:56';",
      "sql_without_rules": "SELECT c.Score FROM comments c JOIN posts p ON c.PostId = p.Id WHERE p.CreaionDate = '2010-07-19 19:19:56';",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 75,
      "question": "How many credit card withdrawals were recorded after 1995?",
      "ground_truth": "SELECT COUNT(account_id) FROM trans WHERE STRFTIME('%Y', date) > '1995' AND operation = 'VYBER KARTOU'",
      "db_id": "financial",
      "generated_rules": "Rule 1:\nCondition: When the question asks about \"credit card withdrawals\"\nOperation: use table \"trans\" instead of \"account\" and filter on \"type = 'Withdrawal'\" instead of \"type = 'withdrawal'\".",
      "sql_with_rules": "SELECT COUNT(*) FROM trans WHERE type = 'Withdrawal' AND date > '1995-12-31' AND operation = 'Credit Card Withdrawal';",
      "sql_without_rules": "SELECT COUNT(*) FROM trans WHERE type = 'WITHDRAWAL' AND k_symbol = 'CREDIT CARD WITHDRAWAL' AND date > '1995-12-31';",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 76,
      "question": "Was the patient with the number 57266's uric acid within a normal range?",
      "ground_truth": "SELECT CASE WHEN (T1.SEX = 'F' AND T2.UA > 6.5) OR (T1.SEX = 'M' AND T2.UA > 8.0) THEN true ELSE false END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID = 57266",
      "db_id": "thrombosis_prediction",
      "generated_rules": "Rule 1:\nCondition: When the question asks about uric acid levels\nOperation: use the exact column name \"UA\" from the Laboratory table, not \"uric_acid\".",
      "sql_with_rules": "SELECT UA FROM Laboratory WHERE ID = 57266 ORDER BY Date DESC LIMIT 1;",
      "sql_without_rules": "SELECT UA FROM Laboratory WHERE ID = 57266 ORDER BY Date DESC LIMIT 1;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 77,
      "question": "Give the full name and contact number of members who had to spend more than average on each expense.",
      "ground_truth": "SELECT DISTINCT T3.first_name, T3.last_name, T3.phone FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member WHERE T1.cost > ( SELECT AVG(T1.cost) FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member )",
      "db_id": "student_club",
      "generated_rules": "Rule 1:\nCondition: When answering about members who spent more than average on each expense\nOperation: make sure the output order: T1.first_name, T1.last_name, T1.phone.\n\nRule 2:\nCondition: When the question mentions \"members\"\nOperation: use table \"member\" with alias T1.\n\nRule 3:\nCondition: When the question mentions \"members\"\nOperation: \"members\" actually means \"member AS T1\" in schema.",
      "sql_with_rules": "SELECT T1.first_name, T1.last_name, T1.phone FROM member AS T1 JOIN expense ON T1.member_id = expense.link_to_member WHERE expense.cost > (SELECT AVG(cost) FROM expense);",
      "sql_without_rules": "SELECT m.first_name || ' ' || m.last_name AS full_name, m.phone FROM member m JOIN expense e ON m.member_id = e.link_to_member WHERE e.cost > (SELECT AVG(cost) FROM expense);",
      "result_with_rules": 1,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 78,
      "question": "Which are the cards that have incredibly powerful foils.",
      "ground_truth": "SELECT id FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL",
      "db_id": "card_games",
      "generated_rules": "Rule 1:\nCondition: When answering about \"cards that have incredibly powerful foils\"\nOperation: make sure the output order: T1.name.\n\nRule 2:\nCondition: When the question mentions \"incredibly powerful foils\"\nOperation: \"incredibly powerful foils\" actually means \"cards with foil = 'true' in table cards\".",
      "sql_with_rules": "SELECT cards.name FROM cards WHERE cards.hasFoil = 1 ORDER BY cards.name;",
      "sql_without_rules": "SELECT name, rarity, power, toughness, manaCost, text FROM cards WHERE hasFoil = 1 AND (power LIKE '%+%' OR power IN ('10', '11', '12', '13', '14', '15', '20', '99', '100') OR text LIKE '%double%' OR text LIKE '%triple%' OR text LIKE '%extra turn%' OR text LIKE '%win the game%' OR text LIKE '%emblem%' OR text LIKE '%infinite%') ORDER BY CAST(power AS REAL) DESC, name;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 79,
      "question": "When did the user known as 'IrishStat' create his or her account?",
      "ground_truth": "SELECT CreationDate FROM users WHERE DisplayName = 'IrishStat'",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks about account creation date for a user\nOperation: use the exact column token \"CreationDate\" from the \"users\" table.",
      "sql_with_rules": "SELECT CreationDate FROM users WHERE DisplayName = 'IrishStat';",
      "sql_without_rules": "SELECT CreationDate FROM users WHERE DisplayName = 'IrishStat';",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 80,
      "question": "List down atom id2 for atoms with element sulfur.",
      "ground_truth": "SELECT DISTINCT T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 's'",
      "db_id": "toxicology",
      "generated_rules": "Rule 1:\nCondition: When the question asks for \"atom id2\"\nOperation: use the exact column token \"atom_id2\" from the connected table.",
      "sql_with_rules": "SELECT DISTINCT c.atom_id2 FROM atom a JOIN connected c ON a.atom_id = c.atom_id WHERE a.element = 'sulfur';",
      "sql_without_rules": "SELECT DISTINCT c.atom_id2 FROM connected c JOIN atom a ON c.atom_id = a.atom_id WHERE a.element = 'sulfur';",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 81,
      "question": "How many adults who obtained the badge Supporter?",
      "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Supporter' AND T1.Age BETWEEN 19 AND 65",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks about \"adults\"\nOperation: use the age condition \"Age > 18\" instead of \"age = 18\" to capture all adults.\n\nRule 2:\nCondition: When the question mentions \"obtained the badge Supporter\"\nOperation: filter on \"Name = 'Supporter'\" from the badges table instead of \"badge = 'Supporter'\".",
      "sql_with_rules": "SELECT COUNT(DISTINCT u.Id) FROM users u JOIN badges b ON u.Id = b.UserId WHERE u.Age > 18 AND b.Name = 'Supporter';",
      "sql_without_rules": "SELECT COUNT(DISTINCT u.Id) FROM users u JOIN badges b ON u.Id = b.UserId WHERE u.Age >= 18 AND b.Name = 'Supporter';",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 82,
      "question": "From which post is the most popular tag excerpted from? Please give the body of the post.",
      "ground_truth": "SELECT Body FROM posts WHERE id = ( SELECT ExcerptPostId FROM tags ORDER BY Count DESC LIMIT 1 )",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks about \"most popular tag\"\nOperation: determine popularity by counting tag occurrences using COUNT(T2.Id) instead of using a pre-calculated popularity column.\n\nRule 2:\nCondition: When answering about \"the most popular tag excerpted from a post\"\nOperation: make sure the output order: T1.Body.\n\nRule 3:\nCondition: When the question mentions \"most popular tag\"\nOperation: \"most popular\" actually means \"highest count of tag occurrences in the tags table\".\n\nRule 4:\nCondition: When the question asks for \"the body of the post\"\nOperation: select T1.Body from the posts table.",
      "sql_with_rules": "SELECT p.Body FROM posts p JOIN tags t ON p.Id = t.ExcerptPostId WHERE t.Count = (SELECT MAX(Count) FROM tags);",
      "sql_without_rules": "SELECT p.Body FROM tags t JOIN posts p ON t.ExcerptPostId = p.Id WHERE t.Count = (SELECT MAX(Count) FROM tags);",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 83,
      "question": "Please list the diseases of the patients born after 1985-1-1 and have a normal Rhuematoid Factor.",
      "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.RA = '-' OR T2.RA = '+-') AND T1.Birthday > '1985-01-01'",
      "db_id": "thrombosis_prediction",
      "generated_rules": "Rule 1:\nCondition: When the question asks for diseases of patients\nOperation: select distinct values from the \"Diagnosis\" column instead of \"disease\" to avoid duplicates.",
      "sql_with_rules": "SELECT DISTINCT p.Diagnosis FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE p.Birthday > '1985-01-01' AND l.RF = 'normal';",
      "sql_without_rules": "SELECT DISTINCT p.Diagnosis FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE p.Birthday > '1985-01-01' AND l.RF = 'normal';",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 84,
      "question": "Please list the full names of all the superheroes with over 15 super powers.",
      "ground_truth": "SELECT DISTINCT T1.full_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.full_name HAVING COUNT(T2.power_id) > 15",
      "db_id": "superhero",
      "generated_rules": "Rule 1:\nCondition: When the question asks for \"full names\"\nOperation: select the exact columns \"first\", \"middle\", and \"last\" instead of \"first_name\" and \"last_name\".\n\nRule 2:\nCondition: When the question asks for \"full names\"\nOperation: use both \"f_name\" and \"l_name\" columns from table \"student\" instead of a single \"full_name\" column.\n\nRule 3:\nCondition: When the question asks for \"full names\"\nOperation: select \"official_full_name\" instead of separate first and last name fields.\n\nRule 4:\nCondition: When the question asks for \"full names\"\nOperation: use the exact column token \"official_full_name\" from table T2 instead of combining first_name and last_name.\n\nRule 5:\nCondition: When the question asks for \"full names\"\nOperation: select both \"First\" and \"Last\" columns from the customers table.\n\nRule 6:\nCondition: When the question asks for \"full names\"\nOperation: select both \"firstname\" and \"lastname\" columns from the employee table instead of a single \"full_name\" column.\n\nRule 7:\nCondition: When the question asks for \"full names\"\nOperation: select both \"first_name\" and \"",
      "sql_with_rules": "SELECT s.full_name FROM superhero s JOIN hero_power hp ON s.id = hp.hero_id GROUP BY s.id, s.full_name HAVING COUNT(hp.power_id) > 15;",
      "sql_without_rules": "SELECT s.full_name FROM superhero s JOIN hero_power hp ON s.id = hp.hero_id GROUP BY s.id, s.full_name HAVING COUNT(hp.power_id) > 15;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 85,
      "question": "Please list the names of the badges obtained by csgillespie.",
      "ground_truth": "SELECT T1.`Name` FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
      "db_id": "codebase_community",
      "generated_rules": "Rule 1:\nCondition: When the question asks for badge names\nOperation: select \"T2\".\"Name\" from the \"Badges\" table instead of \"badge_name\" from a \"badges\" table.",
      "sql_with_rules": "SELECT T2.Name FROM badges T2 JOIN users ON T2.UserId = users.Id WHERE users.DisplayName = 'csgillespie';",
      "sql_without_rules": "SELECT b.Name FROM badges b JOIN users u ON b.UserId = u.Id WHERE u.DisplayName = 'csgillespie';",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 86,
      "question": "In superheroes with height between 150 to 180, what is the percentage of heroes published by Marvel Comics?",
      "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.height_cm BETWEEN 150 AND 180",
      "db_id": "superhero",
      "generated_rules": "Rule 1:\nCondition: When the question asks for percentage\nOperation: do not divide by 100.0 factor as the percentage calculation should return the decimal value directly.\n\nRule 2:\nCondition: When the question asks for percentage of heroes published by Marvel Comics\nOperation: use publisher_name = 'Marvel Comics' instead of publisher_id = 1 to filter for the correct publisher.\n\nRule 3:\nCondition: When the question asks for percentage of heroes published by Marvel Comics\nOperation: use publisher_name = 'Marvel Comics' instead of publisher_id = 1 to filter for the correct publisher.\n\nRule 4:\nCondition: When the question asks for percentage of heroes published by Marvel Comics\nOperation: use publisher_name = 'Marvel Comics' instead of publisher_id = 1 to filter for the correct publisher.\n\nRule 5:\nCondition: When the question asks for percentage of heroes published by Marvel Comics\nOperation: use publisher_name = 'Marvel Comics' instead of publisher_id = 1 to filter for the correct publisher.\n\nRule 6:\nCondition: When the question asks for percentage of heroes published by Marvel Comics\nOperation: use publisher_name = 'Marvel Comics' instead of publisher_id = 1 to filter for the correct publisher.\n\nRule 7:",
      "sql_with_rules": "SELECT (COUNT(CASE WHEN p.publisher_name = 'Marvel Comics' THEN 1 END) * 1.0 / COUNT(*)) AS marvel_percentage FROM superhero s JOIN publisher p ON s.publisher_id = p.id WHERE s.height_cm BETWEEN 150 AND 180;",
      "sql_without_rules": "SELECT (COUNT(CASE WHEN p.publisher_name = 'Marvel Comics' THEN 1 END) * 100.0 / COUNT(*)) AS marvel_percentage FROM superhero s JOIN publisher p ON s.publisher_id = p.id WHERE s.height_cm BETWEEN 150 AND 180;",
      "result_with_rules": 0,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 87,
      "question": "How many accounts in Beroun were opened after 1996?",
      "ground_truth": "SELECT COUNT(account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T1.date) > '1996' AND T2.A2 = 'Beroun'",
      "db_id": "financial",
      "generated_rules": "Rule 1:\nCondition: When the question asks about accounts in a specific district\nOperation: join the account table (T1) with the district table (T2) using T1.district_id = T2.district_id to access district information.",
      "sql_with_rules": "SELECT COUNT(*) FROM account JOIN district ON account.district_id = district.district_id WHERE district.A2 = 'Beroun' AND account.date > '1996-12-31';",
      "sql_without_rules": "SELECT COUNT(*) FROM account JOIN district ON account.district_id = district.district_id WHERE district.A2 = 'Beroun' AND strftime('%Y', account.date) > '1996';",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 88,
      "question": "How many types of cards does the artist Aaron Boyd illustrated about card art?",
      "ground_truth": "SELECT COUNT(type) FROM cards WHERE artist = 'Aaron Boyd'",
      "db_id": "card_games",
      "generated_rules": "Rule 1:\nCondition: When the question asks about \"types of cards\" illustrated by an artist\nOperation: count distinct values of the \"type\" column from the \"cards\" table.",
      "sql_with_rules": "SELECT COUNT(DISTINCT type) FROM cards WHERE artist = 'Aaron Boyd';",
      "sql_without_rules": "SELECT COUNT(DISTINCT types) FROM cards WHERE artist = 'Aaron Boyd';",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 89,
      "question": "Provide all ID, sex and birthday of patients whose urea nitrogen (UN) just within the borderline of passing?",
      "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.UN = 29",
      "db_id": "thrombosis_prediction",
      "generated_rules": "Rule 1:\nCondition: When the question asks for patients with urea nitrogen (UN) just within the borderline of passing\nOperation: filter for patients where UN equals 25 instead of using a range between 20 and 30.",
      "sql_with_rules": "SELECT p.ID, p.SEX, p.Birthday FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE l.UN = 25;",
      "sql_without_rules": "SELECT DISTINCT p.ID, p.SEX, p.Birthday FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE l.UN BETWEEN 8 AND 20;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 90,
      "question": "Rank superheroes from Marvel Comics by their eye color popularity, starting with the most common color.",
      "ground_truth": "SELECT colour.colour AS EyeColor, COUNT(superhero.id) AS Count, RANK() OVER (ORDER BY COUNT(superhero.id) DESC) AS PopularityRank FROM superhero INNER JOIN colour ON superhero.eye_colour_id = colour.id INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics' GROUP BY colour.colour",
      "db_id": "superhero",
      "generated_rules": "Rule 1:\nCondition: When answering about \"Rank superheroes from Marvel Comics by their eye color popularity\"\nOperation: make sure the output order: T2.eye_color, COUNT(T2.eye_color)\n\nRule 2:\nCondition: When the question mentions \"Marvel Comics\"\nOperation: \"Marvel Comics\" actually means \"T1.publisher_name = 'Marvel Comics'\" in schema\n\nRule 3:\nCondition: When the question asks for \"eye color popularity\"\nOperation: organize results by T2.eye_color and compute count of T2.eye_color per group\n\nRule 4:\nCondition: When the question says \"starting with the most common color\"\nOperation: rank rows by count of T2.eye_color in descending order and keep the first 1 row",
      "sql_with_rules": "SELECT c.colour AS eye_color, COUNT(c.colour) AS count FROM superhero s JOIN publisher p ON s.publisher_id = p.id JOIN colour c ON s.eye_colour_id = c.id WHERE p.publisher_name = 'Marvel Comics' GROUP BY c.colour ORDER BY COUNT(c.colour) DESC LIMIT 1;",
      "sql_without_rules": "SELECT c.colour AS eye_color, COUNT(*) AS count FROM superhero s JOIN publisher p ON s.publisher_id = p.id JOIN colour c ON s.eye_colour_id = c.id WHERE p.publisher_name = 'Marvel Comics' GROUP BY c.colour ORDER BY count DESC;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 91,
      "question": "Please list the IDs of the patients who had the examination done after 1997/1/1 and had a normal anti-scl70.",
      "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SC170 IN ('negative','0') AND T2.Date > 1997-01-01",
      "db_id": "thrombosis_prediction",
      "generated_rules": "Rule 1:\nCondition: When the question asks for patient IDs\nOperation: use the exact column name \"patient\" instead of \"patient_id\" in the output.\n\nRule 2:\nCondition: When the question asks for patient ID\nOperation: use the exact column name \"ID\" from the Patient table instead of \"patient_id\".\n\nRule 3:\nCondition: When the question asks for patient IDs\nOperation: use the exact column name \"patient\" from the patients table instead of \"patient_id\".\n\nRule 4:\nCondition: When the question asks for patient IDs\nOperation: use the exact column name \"patient\" instead of \"patient_id\" in the output.\n\nRule 5:\nCondition: When the question asks for patient IDs\nOperation: use the exact column name \"patient\" from the patients table instead of \"patient_id\".\n\nRule 6:\nCondition: When the question asks for patient IDs from examination data\nOperation: use the \"ID\" column from the \"Examination\" table instead of \"patient_id\" from \"patients\".\n\nRule 7:\nCondition: When the question asks for patient IDs\nOperation: use the exact column name \"patient\" instead of \"patient_id\".",
      "sql_with_rules": "SELECT ID AS patient FROM Examination WHERE \"Examination Date\" > '1997-01-01' AND SC170 = 'normal';",
      "sql_without_rules": "SELECT DISTINCT e.ID FROM Examination e WHERE e.`Examination Date` > '1997-01-01' AND e.SC170 = 'normal';",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 92,
      "question": "For the first client who opened his/her account in Prague, what is his/her account ID?",
      "ground_truth": "SELECT T1.account_id FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'Prague' ORDER BY T1.date ASC LIMIT 1",
      "db_id": "financial",
      "generated_rules": "Rule 1:\nCondition: When the question asks for account ID\nOperation: select \"account_id\" from the \"account\" table (T1) instead of \"account_id\" from \"clients\".\n\nRule 2:\nCondition: When the question asks for account ID\nOperation: select \"T1\".\"account_id\" from the \"account\" table instead of \"account_id\" from the \"client\" table.",
      "sql_with_rules": "SELECT T1.account_id FROM account T1 JOIN district ON T1.district_id = district.district_id WHERE district.A3 = 'Prague' ORDER BY T1.date LIMIT 1;",
      "sql_without_rules": "SELECT a.account_id FROM account a JOIN district d ON a.district_id = d.district_id JOIN disp dp ON a.account_id = dp.account_id JOIN client c ON dp.client_id = c.client_id WHERE d.A3 = 'Prague' ORDER BY a.date ASC LIMIT 1;",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 93,
      "question": "Which website should I go to if I want to know more about Anthony Davidson?",
      "ground_truth": "SELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson'",
      "db_id": "formula_1",
      "generated_rules": "Rule 1:\nCondition: When the question asks about a person's website\nOperation: use the \"url\" column from the \"drivers\" table instead of \"website\" from other tables.",
      "sql_with_rules": "SELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson';",
      "sql_without_rules": "SELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson';",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 94,
      "question": "When was the set of cards with \"Ancestor's Chosen\" released?",
      "ground_truth": "SELECT DISTINCT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'",
      "db_id": "card_games",
      "generated_rules": "Rule 1:\nCondition: When the question asks about release date of a set\nOperation: select \"releaseDate\" from the \"sets\" table instead of \"release_date\" from \"cards\" table.",
      "sql_with_rules": "SELECT s.releaseDate FROM sets s JOIN cards c ON s.code = c.setCode WHERE c.name = 'Ancestor''s Chosen';",
      "sql_without_rules": "SELECT s.releaseDate FROM sets s JOIN cards c ON s.code = c.setCode WHERE c.name = 'Ancestor''s Chosen';",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 95,
      "question": "Which constructor scored most points from Monaco Grand Prix between 1980 and 2010? List the score, name and nationality of this team.",
      "ground_truth": "SELECT SUM(T1.points), T2.name, T2.nationality FROM constructorResults AS T1 INNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId INNER JOIN races AS T3 ON T3.raceid = T1.raceid WHERE T3.name = 'Monaco Grand Prix' AND T3.year BETWEEN 1980 AND 2010 GROUP BY T2.name ORDER BY SUM(T1.points) DESC LIMIT 1",
      "db_id": "formula_1",
      "generated_rules": "Rule 1:\nCondition: When answering about \"most points from Monaco Grand Prix\"\nOperation: make sure the output order: score, name, nationality.\n\nRule 2:\nCondition: When the question mentions \"Monaco Grand Prix\"\nOperation: \"Monaco Grand Prix\" actually means \"T1.name = 'Monaco Grand Prix'\" in schema.\n\nRule 3:\nCondition: When the question mentions \"between 1980 and 2010\"\nOperation: use T2.year BETWEEN 1980 AND 2010 for filtering.\n\nRule 4:\nCondition: When the question asks for \"most points\"\nOperation: rank rows by T2.points in descending order and keep the first 1 row.\n\nRule 5:\nCondition: When the question asks for \"most points\"\nOperation: rank rows by T2.points in descending order and keep the first 1 row.\n\nRule 6:\nCondition: When the question asks for \"most points\"\nOperation: rank rows by T1.Pts in descending direction and keep the first 1 row.\n\nRule 7:\nCondition: When the question asks for \"most points\"\nOperation: rank rows by T1.Pts in descending direction and keep the first 1 row.\n\nRule",
      "sql_with_rules": "SELECT SUM(r.points) AS score, c.name, c.nationality FROM results r JOIN races ra ON r.raceId = ra.raceId JOIN constructors c ON r.constructorId = c.constructorId WHERE ra.name = 'Monaco Grand Prix' AND ra.year BETWEEN 1980 AND 2010 GROUP BY r.constructorId ORDER BY score DESC LIMIT 1;",
      "sql_without_rules": "SELECT c.name, c.nationality, SUM(r.points) AS total_points FROM results r JOIN races rc ON r.raceId = rc.raceId JOIN constructors c ON r.constructorId = c.constructorId WHERE rc.name LIKE '%Monaco Grand Prix%' AND rc.year BETWEEN 1980 AND 2010 GROUP BY c.constructorId ORDER BY total_points DESC LIMIT 1;",
      "result_with_rules": 1,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 96,
      "question": "List all patients with their sex and date of birthday, whose AST glutamic oxaloacetic transaminase (GOT) index is within normal range for loboratory examination in 1994.",
      "ground_truth": "SELECT DISTINCT T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT < 60 AND STRFTIME('%Y', T2.Date) = '1994'",
      "db_id": "thrombosis_prediction",
      "generated_rules": "Rule 1:\nCondition: When the question asks for patients with AST index within normal range\nOperation: use Laboratory.GOT = 'Normal' instead of AST values and remove explicit table aliases like T1.",
      "sql_with_rules": "SELECT Patient.ID, Patient.SEX, Patient.Birthday FROM Patient JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE Laboratory.GOT = 'Normal' AND strftime('%Y', Laboratory.Date) = '1994';",
      "sql_without_rules": "SELECT DISTINCT p.ID, p.SEX, p.Birthday FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE l.Date BETWEEN '1994-01-01' AND '1994-12-31' AND l.GOT BETWEEN 10 AND 40;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 97,
      "question": "How many points did Lewis Hamilton get in total in all the Formula_1 races he participated?",
      "ground_truth": "SELECT SUM(T2.points) FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton'",
      "db_id": "formula_1",
      "generated_rules": "Rule 1:\nCondition: When answering about points for a specific driver\nOperation: join the results table (T1) with the drivers table (T2) using T1.driverId = T2.driverId to link race results to driver information.",
      "sql_with_rules": "SELECT SUM(results.points) FROM results JOIN drivers ON results.driverId = drivers.driverId WHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton';",
      "sql_without_rules": "SELECT SUM(r.points) FROM results r JOIN drivers d ON r.driverId = d.driverId WHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';",
      "result_with_rules": 1,
      "result_without_rules": 1,
      "error_message": ""
    },
    {
      "sample_idx": 98,
      "question": "Name the driver with the most winning. Mention his nationality and what is his maximum point scores.",
      "ground_truth": "SELECT T1.forename, T1.surname, T1.nationality, MAX(T2.points) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId WHERE T2.wins >= 1 GROUP BY T1.forename, T1.surname, T1.nationality ORDER BY COUNT(T2.wins) DESC LIMIT 1",
      "db_id": "formula_1",
      "generated_rules": "Rule 1:\nCondition: When answering about \"the driver with the most winning\"\nOperation: use the driver with the highest count of race wins instead of a direct column reference.\n\nRule 2:\nCondition: When the question asks for \"maximum point scores\"\nOperation: use the maximum points value from the results table rather than a direct column reference.",
      "sql_with_rules": "SELECT d.forename || ' ' || d.surname AS driver_name, d.nationality, MAX(r.points) AS max_points FROM drivers d JOIN results r ON d.driverId = r.driverId WHERE r.position = 1 GROUP BY d.driverId, d.forename, d.surname, d.nationality ORDER BY COUNT(r.position) DESC LIMIT 1;",
      "sql_without_rules": "SELECT d.forename || ' ' || d.surname AS driver_name, d.nationality, MAX(ds.points) AS max_points FROM drivers d JOIN driverStandings ds ON d.driverId = ds.driverId WHERE ds.wins = (SELECT MAX(wins) FROM driverStandings) GROUP BY d.driverId ORDER BY ds.wins DESC LIMIT 1;",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    },
    {
      "sample_idx": 99,
      "question": "Among the account opened, how many female customers who were born before 1950 and stayed in Sokolov?",
      "ground_truth": "SELECT COUNT(T2.client_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.gender = 'F' AND STRFTIME('%Y', T2.birth_date) < '1950' AND T1.A2 = 'Sokolov'",
      "db_id": "financial",
      "generated_rules": "No definitional rules found.",
      "sql_with_rules": "SELECT COUNT(DISTINCT a.account_id) FROM account a JOIN disp d ON a.account_id = d.account_id JOIN client c ON d.client_id = c.client_id JOIN district dist ON c.district_id = dist.district_id WHERE c.gender = 'F' AND c.birth_date < '1950-01-01' AND dist.A3 = 'Sokolov';",
      "sql_without_rules": "SELECT COUNT(DISTINCT c.client_id) FROM client c JOIN account a ON c.district_id = a.district_id JOIN district d ON c.district_id = d.district_id WHERE c.gender = 'F' AND c.birth_date < '1950-01-01' AND d.A3 = 'Sokolov';",
      "result_with_rules": 0,
      "result_without_rules": 0,
      "error_message": ""
    }
  ]
}