{
    "895": {
        "db_id": "network_1",
        "question": "What are the ids of high school students who do not have friends?",
        "ground_truth": "SELECT id FROM Highschooler EXCEPT SELECT student_id FROM Friend",
        "amends": [
            "Do use a set operation with `EXCEPT` instead of a simple `WHERE` filter on `friend_count = 0`. Do query from the `Highschooler` table instead of `high_school_students`. Do exclude `student_id` values from the `Friend` table instead of checking for zero friend counts. Do remove the `WHERE` clause entirely instead of using it to filter for zero friendships. The amended query now correctly identifies students with no friends by excluding those who appear in the Friend table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"high school students who do not have friends\": use the table \"Highschooler\" instead of \"high_school_students\". 2) When identifying students with no friends: use a set operation to exclude student_id values that appear in the \"Friend\" table rather than checking for zero friend counts. 3) When combining data from multiple tables: remove any WHERE clause that filters for zero friendships and instead use the set difference approach. 4) When referring to student identifiers: use \"student_id\" as the exact column name for identification purposes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM high_school_students WHERE friend_count = 0;",
            "SELECT ID FROM Highschooler EXCEPT SELECT student_id FROM Friend"
        ],
        "rule_sql": [
            "SELECT ID FROM Highschooler\nEXCEPT\nSELECT student_id FROM Friend;"
        ]
    },
    "665": {
        "db_id": "poker_player",
        "question": "What is the birth date of the poker player with the lowest earnings?",
        "ground_truth": "SELECT T1.Birth_Date FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Earnings ASC LIMIT 1",
        "amends": [
            "Do join `people AS T1` with `poker_player AS T2` on `T1.People_ID = T2.People_ID` instead of querying only `poker_players` table. Do select `T1.Birth_Date` from the joined people table instead of `birth_date` from the poker_players table. Do order by `T2.Earnings` from the joined poker_player table instead of `earnings` from the original table. The amended query now correctly retrieves birth dates by joining related tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"birth date of poker player\": make sure to join \"people AS T1\" with \"poker_player AS T2\" on \"T1.People_ID = T2.People_ID\" and keep only matching pairs (inner match). 2) When selecting the birth date: use \"T1.Birth_Date\" from the people table instead of any other column. 3) When ordering by earnings to find the lowest: use \"T2.Earnings\" from the poker_player table in ascending order. 4) When limiting to the single result with lowest earnings: take only the first row after ordering by earnings ascending."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT birth_date FROM poker_players ORDER BY earnings ASC LIMIT 1;",
            "SELECT T1.Birth_Date FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Birth_Date FROM people AS T1 INNER JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings ASC LIMIT 1"
        ]
    },
    "486": {
        "db_id": "wta_1",
        "question": "Find the number of left handed winners who participated in the WTA Championships.",
        "ground_truth": "SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  'WTA Championships' AND winner_hand  =  'L'",
        "amends": [
            "Do count `DISTINCT winner_name` instead of `COUNT(*)` to count unique winners rather than all matches. Do use table `matches` instead of `winners` to access the correct data source. Do filter on `tourney_name = 'WTA Championships'` instead of `tournament = 'WTA Championships'` to use the correct column name. Do filter on `winner_hand = 'L'` instead of `handed = 'left'` to use both the correct column name and abbreviated value format. The amended query now correctly counts distinct winners from the matches table with proper filtering conditions."
        ],
        "rules": [
            "1) When counting winners: count distinct \"winner_name\" instead of all rows to get unique winners rather than all matches. 2) When accessing match data: use table \"matches\" instead of \"winners\" as the correct data source. 3) When filtering by tournament name: use \"tourney_name = 'WTA Championships'\" instead of \"tournament = 'WTA Championships'\" to use the correct column name. 4) When filtering by handedness: use \"winner_hand = 'L'\" instead of \"handed = 'left'\" to use both the correct column name and abbreviated value format."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM winners WHERE handed = 'left' AND tournament = 'WTA Championships';",
            "SELECT COUNT(DISTINCT winner_name) \nFROM matches \nWHERE tourney_name = 'WTA Championships' \nAND winner_hand = 'L'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT winner_name) \nFROM matches \nWHERE tourney_name = 'WTA Championships' \nAND winner_hand = 'L'"
        ]
    },
    "657": {
        "db_id": "poker_player",
        "question": "What is the maximum number of final tables made among poker players with earnings less than 200000?",
        "ground_truth": "SELECT max(Final_Table_Made) FROM poker_player WHERE Earnings  <  200000",
        "amends": [
            "Do use the correct table name `poker_player` instead of the incorrect `poker_players`. Do reference the correct column `Final_Table_Made` instead of the non-existent `final_tables`. Do change the aggregate function to `max` (lowercase) instead of `MAX` (uppercase) for consistency. Do correct the filter condition to use `< 200000` instead of `> 200000` to select players with earnings below the threshold rather than above it. Do reference the correct earnings column `Earnings` instead of the incorrect `earnings`. The amended query now correctly selects the maximum number of final tables made by poker players with earnings less than 200,000, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"poker players\": use the exact table name \"poker_player\" instead of any pluralized or alternative forms. 2) When the question asks about \"final tables made\": use the exact column name \"Final_Table_Made\" from the poker_player table. 3) When the question specifies \"earnings less than 200000\": filter rows where the \"Earnings\" column value is less than 200000 using the exact comparison operator \"<\". 4) When the question asks for the \"maximum number\": compute the maximum value of the \"Final_Table_Made\" column using the lowercase \"max\" function. 5) When producing output: ensure the result contains only the maximum value of Final_Table_Made for players meeting the earnings criteria."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(final_tables) FROM poker_players WHERE earnings > 200000;",
            "SELECT max(Final_Table_Made) FROM poker_player WHERE Earnings < 200000"
        ],
        "rule_sql": [
            "SELECT MAX(Final_Table_Made) FROM poker_player WHERE Earnings < 200000"
        ]
    },
    "650": {
        "db_id": "poker_player",
        "question": "What are the earnings of poker players, ordered descending by value?",
        "ground_truth": "SELECT Earnings FROM poker_player ORDER BY Earnings DESC",
        "amends": [
            "Do select only `Earnings` instead of both `name` and `earnings`. Do reference table `poker_player` instead of `poker_players`. Do order by `Earnings DESC` instead of `earnings ASC`. The amended query now matches the intended behavior of selecting earnings from the poker_player table in descending order."
        ],
        "rules": [
            "1) When answering about \"earnings of poker players\": make sure the output order: \"Earnings\" only. 2) When the question mentions \"poker players\": \"poker players\" actually means table \"poker_player\" in schema. 3) When the question says \"ordered descending by value\": order rows by \"Earnings\" in descending direction."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, earnings FROM poker_players ORDER BY earnings ASC;",
            "SELECT Earnings FROM poker_player ORDER BY Earnings DESC;"
        ],
        "rule_sql": [
            "SELECT Earnings FROM poker_player ORDER BY Earnings DESC;"
        ]
    },
    "832": {
        "db_id": "orchestra",
        "question": "What are the maximum and minimum share of performances whose type is not \"Live final\".",
        "ground_truth": "SELECT max(SHARE) ,  min(SHARE) FROM performance WHERE TYPE != \"Live final\"",
        "amends": [
            "Do filter with `TYPE != \"Live final\"` instead of `type = 'Live final'` to exclude rather than include live final performances. Do reference table `performance` instead of `performances` to use the correct table name. The amended query now correctly excludes live final performances and uses the proper table name, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about performances whose type is not \"Live final\": filter rows where \"TYPE\" is not equal to \"Live final\" exactly. 2) When referencing the performances table: use the exact table name \"performance\" (not \"performances\"). 3) When computing maximum and minimum share values: calculate MAX(\"share\") and MIN(\"share\") on the filtered dataset."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(share), MIN(share) FROM performances WHERE type = 'Live final';",
            "SELECT MAX(Share) AS max_share, MIN(Share) AS min_share FROM performance WHERE Type != 'Live final'"
        ],
        "rule_sql": [
            "SELECT MAX(\"Share\") AS max_share, MIN(\"Share\") AS min_share FROM performance WHERE \"Type\" != 'Live final'"
        ]
    },
    "679": {
        "db_id": "poker_player",
        "question": "List the names and birth dates of people in ascending alphabetical order of name.",
        "ground_truth": "SELECT Name ,  Birth_Date FROM people ORDER BY Name ASC",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, birth_date FROM people ORDER BY name DESC;"
        ],
        "rule_sql": [
            "SELECT Name, Birth_Date FROM people ORDER BY Name ASC;"
        ]
    },
    "258": {
        "db_id": "flight_2",
        "question": "Which airports do not have departing or arriving flights?",
        "ground_truth": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)",
        "amends": [
            "Do select `AirportName` instead of `*` and use table alias `Airports` instead of `airports`. Do use column `AirportCode` instead of `airport_id` for the main filter. Do combine the two subqueries into a single `UNION` operation selecting `SourceAirport` and `DestAirport` instead of separate `NOT IN` clauses with `departure_airport` and `arrival_airport`. Do reference table `Flights` instead of `flights` with proper capitalization. The amended query now correctly identifies airports not used as either source or destination in any flight by using UNION to combine both airport types in a single subquery."
        ],
        "rules": [
            "1) When answering about airports without departing or arriving flights: select \"AirportName\" from \"Airports\" instead of all columns. 2) When filtering airports by flight activity: use \"AirportCode\" as the main filter key instead of airport_id. 3) When checking for unused airports: combine both source and destination airport checks into a single UNION operation selecting \"SourceAirport\" and \"DestAirport\" from \"Flights\" instead of separate NOT IN clauses. 4) When referencing table names: use exact capitalization \"Airports\" and \"Flights\" as shown in the schema. 5) When identifying airports not used in flights: find airports where \"AirportCode\" is not present in the combined set of \"SourceAirport\" and \"DestAirport\" values from \"Flights\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM airports WHERE airport_id NOT IN (SELECT departure_airport FROM flights) AND airport_id NOT IN (SELECT arrival_airport FROM flights);",
            "SELECT AirportName FROM airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM flights UNION SELECT DestAirport FROM flights)"
        ],
        "rule_sql": [
            "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)"
        ]
    },
    "595": {
        "db_id": "tvshow",
        "question": "Which country has the most of TV Channels? List the country and number of TV Channels it has.",
        "ground_truth": "SELECT Country ,  count(*) FROM TV_Channel GROUP BY Country ORDER BY count(*) DESC LIMIT 1;",
        "amends": [
            "Do `ORDER BY count(*) DESC` instead of `ORDER BY channel_count ASC` to sort by descending count rather than ascending. Do use `TV_Channel` as the table name instead of `tv_channels` to match the correct source. Do remove the alias `as channel_count` instead of keeping it since the right query uses the raw aggregate expression. Do use `Country` with proper capitalization instead of `country` to match the column name exactly. The amended query now correctly identifies the country with the highest number of TV channels by sorting in descending order and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"most TV Channels\" or \"highest number\": rank countries by count of TV channels in descending order and keep only the top 1 country. 2) When counting TV channels per country: count using the canonical key from TV_Channel table and group by the exact column \"Country\". 3) When ordering results: sort by the count in descending order rather than ascending to get the highest count first. 4) When referring to the table: use the exact table name \"TV_Channel\" with proper capitalization instead of variations like \"tv_channels\". 5) When referring to the country column: use the exact column name \"Country\" with proper capitalization instead of lowercase \"country\". 6) When outputting results: include both the country name and the count value without using aliases for the aggregate expression."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country, COUNT(*) as channel_count FROM tv_channels GROUP BY country ORDER BY channel_count ASC LIMIT 1;",
            "SELECT Country, COUNT(*) FROM TV_Channel GROUP BY Country ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Country, COUNT(id) FROM TV_Channel GROUP BY Country ORDER BY COUNT(id) DESC LIMIT 1;"
        ]
    },
    "447": {
        "db_id": "wta_1",
        "question": "List the names of all winners who played in both 2013 and 2016.",
        "ground_truth": "SELECT winner_name FROM matches WHERE YEAR  =  2013 INTERSECT SELECT winner_name FROM matches WHERE YEAR  =  2016",
        "amends": [
            "Do use `INTERSECT` to find common winners across years instead of incorrect `AND` logic that cannot match both conditions simultaneously. Do query from `matches` table instead of non-existent `winners` table. Do select `winner_name` column instead of `name`. Do use separate queries for each year condition with proper `YEAR = 2013` and `YEAR = 2016` filters instead of the impossible `year = 2013 AND year = 2016` predicate. The amended query now correctly identifies winners who won in both 2013 and 2016 by intersecting the results from two separate year queries."
        ],
        "rules": [
            "1) When the question asks for winners who played in both 2013 and 2016: use INTERSECT to find common winners across years instead of AND logic that cannot match both conditions simultaneously. 2) When querying about winners: use the \"matches\" table instead of non-existent \"winners\" table. 3) When selecting winner names: use \"winner_name\" column instead of \"name\". 4) When filtering by year: use separate queries for each year condition with proper \"YEAR = 2013\" and \"YEAR = 2016\" filters instead of the impossible \"year = 2013 AND year = 2016\" predicate."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM winners WHERE year = 2013 AND year = 2016;",
            "SELECT winner_name FROM matches WHERE year = 2013\nINTERSECT\nSELECT winner_name FROM matches WHERE year = 2016"
        ],
        "rule_sql": [
            "SELECT winner_name FROM matches WHERE year = 2013\nINTERSECT\nSELECT winner_name FROM matches WHERE year = 2016"
        ]
    },
    "43": {
        "db_id": "concert_singer",
        "question": "Find the number of concerts happened in the stadium with the highest capacity .",
        "ground_truth": "select count(*) from concert where stadium_id = (select stadium_id from stadium order by capacity desc limit 1)",
        "amends": [
            "Do reference table `concert` instead of `concerts` and use `stadium` instead of `stadiums` in the subquery to match the correct schema. The amended query now correctly counts concerts at the stadium with the highest capacity by using the proper table names while maintaining the same logical structure and behavior."
        ],
        "rules": [
            "1) When the question mentions \"concerts\": use the exact table name \"concert\" instead of \"concerts\" as shown in the schema. 2) When the question mentions \"stadiums\": use the exact table name \"stadium\" instead of \"stadiums\" as shown in the schema. 3) When finding the stadium with the highest capacity: order stadium rows by capacity in descending direction and keep only the first row. 4) When counting concerts at a specific stadium: count rows from the concert table where stadium_id matches the stadium with the highest capacity."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM concerts WHERE stadium_id = (SELECT stadium_id FROM stadiums ORDER BY capacity DESC LIMIT 1);",
            "SELECT COUNT(*) \nFROM concert \nWHERE Stadium_ID = (\n    SELECT Stadium_ID \n    FROM stadium \n    ORDER BY Capacity DESC \n    LIMIT 1\n)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM concert WHERE Stadium_ID = (SELECT Stadium_ID FROM stadium ORDER BY Capacity DESC LIMIT 1)"
        ]
    },
    "155": {
        "db_id": "car_1",
        "question": "What is the horsepower of the car with the largest accelerate?",
        "ground_truth": "SELECT T1.horsepower FROM CARS_DATA AS T1 ORDER BY T1.accelerate DESC LIMIT 1;",
        "amends": [
            "Do qualify the column reference as `T1.horsepower` instead of the unqualified `horsepower`, and do add the table alias `AS T1` to the `FROM CARS_DATA` clause instead of omitting it, while maintaining the same `ORDER BY accelerate DESC LIMIT 1` structure. The amended query now correctly references columns with explicit table qualification and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"horsepower of the car with the largest accelerate\": make sure the output order: T1.horsepower. 2) When the question mentions \"largest accelerate\": rank rows by accelerate in descending direction and keep the first 1 row. 3) When choosing identifier delimiters: do not replace unquoted forms with double quotes or backticks for columns like horsepower and accelerate. 4) When referring to table roles: use the alias T1 for the CARS_DATA table as shown in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT horsepower FROM cars ORDER BY accelerate DESC LIMIT 1;",
            "SELECT T1.Horsepower FROM cars_data AS T1 ORDER BY T1.Accelerate DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Horsepower FROM cars_data T1 ORDER BY T1.Accelerate DESC LIMIT 1"
        ]
    },
    "694": {
        "db_id": "voter_1",
        "question": "What are the contestant numbers and names of the contestants who had at least two votes?",
        "ground_truth": "SELECT T1.contestant_number , T1.contestant_name FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number GROUP BY T1.contestant_number HAVING count(*)  >=  2",
        "amends": [
            "Do add a `JOIN` with the `votes` table on `contestant_number` instead of querying only the `contestants` table. Do add `GROUP BY contestant_number` to aggregate votes per contestant instead of lacking any grouping. Do move the vote count filter to `HAVING count(*) >= 2` instead of using `WHERE votes >= 2` which incorrectly references a non-existent column. Do qualify columns with table aliases `T1.contestant_number` and `T1.contestant_name` instead of using unqualified column names. The amended query now correctly counts votes from the votes table and filters contestants with at least two votes, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about contestants with at least two votes: combine data from both contestants and votes tables using T1.contestant_number = T2.contestant_number to link matching records. 2) When counting votes per contestant: group results by T1.contestant_number to aggregate votes for each contestant. 3) When filtering for contestants with at least two votes: apply the condition count(*) >= 2 after grouping instead of before. 4) When selecting contestant information: use qualified column names T1.contestant_number and T1.contestant_name instead of unqualified column names."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT contestant_number, contestant_name FROM contestants WHERE votes >= 2;",
            "SELECT T1.contestant_number, T1.contestant_name\nFROM CONTESTANTS T1\nJOIN VOTES T2 ON T1.contestant_number = T2.contestant_number\nGROUP BY T1.contestant_number, T1.contestant_name\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T1.contestant_number, T1.contestant_name FROM CONTESTANTS T1 JOIN VOTES T2 ON T1.contestant_number = T2.contestant_number GROUP BY T1.contestant_number, T1.contestant_name HAVING COUNT(*) >= 2"
        ]
    },
    "634": {
        "db_id": "tvshow",
        "question": "What are the countries that have cartoons on TV that were written by Todd Casey?",
        "ground_truth": "SELECT T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.written_by  =  'Todd Casey'",
        "amends": [
            "Do select `T1.country` from the `TV_Channel` table instead of selecting `country` directly from a non-existent `cartoons` table. Do join `TV_Channel AS T1` with `cartoon AS T2` on `T1.id = T2.Channel` instead of querying a single table. Do filter on `T2.written_by = 'Todd Casey'` instead of `writer = 'Todd Casey'` to use the correct column name and table reference. The amended query now correctly retrieves country information by joining the appropriate tables and using the proper column references, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about countries with cartoons on TV: select \"T1.country\" from the \"TV_Channel\" table as T1 instead of from a non-existent \"cartoons\" table. 2) When combining TV channel and cartoon information: join \"TV_Channel AS T1\" with \"cartoon AS T2\" where \"T1.id = T2.Channel\" to link channels with their cartoons. 3) When filtering for cartoons written by Todd Casey: use \"T2.written_by = 'Todd Casey'\" instead of \"writer = 'Todd Casey'\" to match the exact column name and literal value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM cartoons WHERE writer = 'Todd Casey'",
            "SELECT DISTINCT T1.Country FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Written_by = 'Todd Casey'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Country\nFROM TV_Channel AS T1\nJOIN Cartoon AS T2 ON T1.id = T2.Channel\nWHERE T2.Written_by = 'Todd Casey'"
        ]
    },
    "806": {
        "db_id": "world_1",
        "question": "how many countries are in Asia?",
        "ground_truth": "SELECT count(*) FROM country WHERE continent  =  \"Asia\"",
        "amends": [
            "Do reference table `country` instead of `countries` and filter on `continent = \"Asia\"` instead of `'Europe'`."
        ],
        "rules": [
            "1) When answering about \"how many countries are in Asia\": make sure the output order: COUNT(*) 2) When the question mentions \"countries\": \"countries\" actually means \"country in schema\" 3) When the question mentions \"Asia\": filter rows where continent = \"Asia\" exactly as specified 4) When the question asks for \"count of countries\": compute the number of rows using the canonical key for country entities"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE continent = 'Europe';",
            "SELECT COUNT(*) FROM country WHERE Continent = 'Asia';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM country WHERE Continent = 'Asia';"
        ]
    },
    "318": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Count the number of templates.",
        "ground_truth": "SELECT count(*) FROM Templates",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM templates;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Templates;"
        ]
    },
    "288": {
        "db_id": "employee_hire_evaluation",
        "question": "For each shop, return the number of employees working there and the name of the shop.",
        "ground_truth": "SELECT count(*) ,  t2.name FROM hiring AS t1 JOIN shop AS t2 ON t1.shop_id  =  t2.shop_id GROUP BY t2.name",
        "amends": [
            "Do select `count(*)` and `t2.name` instead of `shop_name` and `COUNT(*)`. Do join `hiring AS t1` with `shop AS t2` on `t1.shop_id = t2.shop_id` instead of selecting from `employees` alone. Do group by `t2.name` instead of `shop_id`. The amended query now correctly aggregates hiring counts by shop name through proper table joining and grouping."
        ],
        "rules": [
            "1) When answering about \"number of employees per shop\": make sure the output order: shop name first, then employee count. 2) When the question mentions \"shop name\": \"shop name\" actually means \"t2.name\" in schema. 3) When the question asks for \"number of employees\": compute the count of all rows from the hiring table (t1) per shop. 4) When combining hiring as t1 and shop as t2: link rows where t1.shop_id = t2.shop_id exactly as shown; keep only matching pairs (inner match). 5) When the question says \"per shop\": organize results by t2.name and compute employee count per group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT shop_name, COUNT(*) FROM employees GROUP BY shop_id;",
            "SELECT COUNT(*) AS employee_count, t2.Name AS shop_name\nFROM hiring AS t1\nJOIN shop AS t2 ON t1.Shop_ID = t2.Shop_ID\nGROUP BY t2.Name"
        ],
        "rule_sql": [
            "SELECT t2.Name AS shop_name, COUNT(t1.Employee_ID) AS employee_count\nFROM hiring AS t1\nINNER JOIN shop AS t2 ON t1.Shop_ID = t2.Shop_ID\nGROUP BY t2.Name\nORDER BY t2.Name, employee_count;"
        ]
    },
    "232": {
        "db_id": "flight_2",
        "question": "What is the abbreviation of the airilne has the fewest flights and what country is it in?",
        "ground_truth": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do `SELECT T1.Abbreviation, T1.Country` instead of `SELECT airline_abbreviation, country`. Do `FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid = T2.Airline` instead of `FROM airlines` without any join. Do add `GROUP BY T1.Airline` instead of omitting it. Do `ORDER BY count(*)` instead of `ORDER BY COUNT(flights)`. The amended query now correctly joins the airlines and flights tables, groups by airline, and counts flights to find the airline with the fewest flights, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"abbreviation of the airline has the fewest flights and what country is it in\": make sure the output order: T1.Abbreviation, T1.Country. 2) When the question mentions \"airline\": use T1 as the base table for airlines information. 3) When the question mentions \"flights\": use T2 as the flights table that must be joined to airlines. 4) When combining T1 and T2 for shared entities: link rows where T1.uid = T2.Airline and keep only matching pairs (inner match). 5) When the question asks for \"fewest flights\": count the number of rows using count(*) after grouping by T1.Airline and order by this count in ascending order. 6) When the question asks for \"the airline with the fewest flights\": take only the first row after ordering by count(*) ascending. 7) When grouping results by airline: organize results by T1.Airline and compute count(*) per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airline_abbreviation, country FROM airlines ORDER BY COUNT(flights) ASC LIMIT 1;",
            "SELECT T1.Abbreviation, T1.Country\nFROM AIRLINES AS T1\nJOIN FLIGHTS AS T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nORDER BY count(*)\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Abbreviation, T1.Country\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nORDER BY COUNT(*) ASC\nLIMIT 1;"
        ]
    },
    "621": {
        "db_id": "tvshow",
        "question": "What is Weekly Rank of TV series with Episode \"A Love of a Lifetime\"?",
        "ground_truth": "SELECT Weekly_Rank FROM TV_series WHERE Episode = \"A Love of a Lifetime\";",
        "amends": [
            "Do select only `Weekly_Rank` instead of both `title` and `weekly_rank`. Do filter on `Episode` column instead of `episode_title` column. Do use double quotes around the string literal instead of single quotes. Do remove the `ORDER BY weekly_rank DESC` clause instead of keeping it. The amended query now matches the RIGHT_SQL's behavior by selecting the correct column and filtering on the appropriate episode identifier without unnecessary sorting."
        ],
        "rules": [
            "1) When the question asks for \"Weekly Rank\": select only the \"Weekly_Rank\" column from table TV_series. 2) When filtering for Episode \"A Love of a Lifetime\": use the exact string literal \"A Love of a Lifetime\" with double quotes and filter on the \"Episode\" column. 3) When the question does not specify ordering: do not include any sorting clause in the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title, weekly_rank FROM tv_series WHERE episode_title = 'A Love of a Lifetime' ORDER BY weekly_rank DESC;",
            "SELECT Weekly_Rank FROM TV_series WHERE Episode = \"A Love of a Lifetime\""
        ],
        "rule_sql": [
            "SELECT Weekly_Rank FROM TV_series WHERE Episode = \"A Love of a Lifetime\";"
        ]
    },
    "933": {
        "db_id": "dog_kennels",
        "question": "What are the id, role, and first name of the professionals who have performed two or more treatments?",
        "ground_truth": "SELECT T1.professional_id ,  T1.role_code ,  T1.first_name FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2",
        "amends": [
            "Do select `T1.professional_id`, `T1.role_code`, and `T1.first_name` instead of `id`, `role`, and `first_name` without table qualification. Do join `Treatments AS T2` on `T1.professional_id = T2.professional_id` instead of querying only the `professionals` table. Do use `GROUP BY T1.professional_id` with `HAVING count(*) >= 2` instead of filtering `WHERE treatment_count = 2` which incorrectly assumes a direct column rather than counting related treatment records. The amended query now correctly counts treatment associations per professional and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting columns from the Professionals table: use \"T1.professional_id\", \"T1.role_code\", and \"T1.first_name\" instead of unqualified column names. 2) When counting treatments performed by professionals: join the Treatments table as T2 on \"T1.professional_id = T2.professional_id\" to access treatment records. 3) When determining professionals with two or more treatments: group by \"T1.professional_id\" and use having count(*) >= 2 instead of filtering on a non-existent treatment_count column. 4) When combining Professionals and Treatments tables: perform an inner match where \"T1.professional_id = T2.professional_id\" to link professionals with their treatments."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, role, first_name \nFROM professionals \nWHERE treatment_count = 2;",
            "SELECT T1.professional_id, T1.role_code, T1.first_name\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T1.professional_id, T1.role_code, T1.first_name\nFROM Professionals T1\nINNER JOIN Treatments T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) >= 2"
        ]
    },
    "687": {
        "db_id": "voter_1",
        "question": "How many states are there?",
        "ground_truth": "SELECT count(*) FROM area_code_state",
        "amends": [
            "Do query the `area_code_state` table instead of the `cities` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the area_code_state table instead of cities, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"how many states\": query the \"area_code_state\" table instead of the \"cities\" table. 2) When counting records: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" for consistency."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities;",
            "SELECT count(*) FROM area_code_state;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM AREA_CODE_STATE"
        ]
    },
    "269": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the manager name and district of the shop whose number of products is the largest.",
        "ground_truth": "SELECT manager_name ,  district FROM shop ORDER BY number_products DESC LIMIT 1",
        "amends": [
            "Do reference table `shop` instead of `shops` in the FROM clause. Do order by `number_products` instead of `number_of_products` in the ORDER BY clause. The amended query now correctly references the intended table and column names to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"manager name and district of the shop with largest number of products\": make sure the output order: manager_name, district. 2) When the question mentions \"shop\": \"shop\" actually means table \"shop\" in schema. 3) When the question mentions \"number of products\": \"number of products\" actually means column \"number_products\" in schema. 4) When the question asks for \"largest\" number of products: rank rows by \"number_products\" in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT manager_name, district FROM shops ORDER BY number_of_products DESC LIMIT 1;",
            "SELECT Manager_name, District FROM shop ORDER BY Number_products DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT manager_name, district FROM shop ORDER BY number_products DESC LIMIT 1"
        ]
    },
    "405": {
        "db_id": "course_teach",
        "question": "Show names of teachers and the number of courses they teach.",
        "ground_truth": "SELECT T2.Name ,  COUNT(*) FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T2.Name",
        "amends": [
            "Do join `course_arrange AS T1` with `teacher AS T2` on `T1.Teacher_ID = T2.Teacher_ID` instead of querying `teachers` table directly. Do select `T2.Name` instead of `teacher_name` and maintain `COUNT(*)` aggregation. Do group by `T2.Name` instead of `teacher_name` to properly count course arrangements per teacher. The amended query now correctly joins the course arrangement and teacher tables to count courses per teacher rather than attempting to count from a teachers table directly."
        ],
        "rules": [
            "1) When answering about \"names of teachers and the number of courses they teach\": make sure the output order: T2.Name, COUNT(*). 2) When combining course_arrange as T1 and teacher as T2: link rows where T1.Teacher_ID = T2.Teacher_ID and keep only matching pairs (inner match). 3) When the question asks for \"number of courses they teach\": compute the count of course arrangements using COUNT(*) aggregation. 4) When the question says \"per teacher\": organize results by T2.Name and compute COUNT(*) per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT teacher_name, COUNT(*) FROM teachers GROUP BY teacher_name;",
            "SELECT T2.Name, COUNT(*) AS NumberOfCourses FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID = T2.Teacher_ID GROUP BY T2.Name"
        ],
        "rule_sql": [
            "SELECT T2.Name, COUNT(*) \nFROM course_arrange AS T1 \nINNER JOIN teacher AS T2 ON T1.Teacher_ID = T2.Teacher_ID \nGROUP BY T2.Name"
        ]
    },
    "684": {
        "db_id": "poker_player",
        "question": "What are the names of people who do not play poker?",
        "ground_truth": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM poker_player)",
        "amends": [
            "Do select `Name` instead of `name` to match the correct column casing. Do use a subquery with `NOT IN` to filter by `People_ID` values that exist in the `poker_player` table instead of directly comparing `game != 'poker'` which incorrectly assumes the game type is stored as a string value in the people table. Do reference the correct join key `People_ID` in both the main query and subquery instead of attempting to filter by a non-existent `game` column. The amended query now correctly identifies people who are not poker players by checking their ID against the poker_player table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for names of people who do not play poker: select \"Name\" from the people table instead of \"name\" to match the correct column casing. 2) When filtering people who do not play poker: use a subquery with NOT IN to filter by \"People_ID\" values that exist in the poker_player table instead of comparing to a non-existent \"game\" column. 3) When joining between people and poker_player tables: reference the correct join key \"People_ID\" in both the main query and subquery to properly identify poker players."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM people WHERE game != 'poker';",
            "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM poker_player)"
        ],
        "rule_sql": [
            "SELECT \"Name\" FROM people WHERE \"People_ID\" NOT IN (SELECT \"People_ID\" FROM poker_player)"
        ]
    },
    "116": {
        "db_id": "car_1",
        "question": "What is the count of the car models produced in the United States?",
        "ground_truth": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';",
        "amends": [
            "Do add joins to `MODEL_LIST AS T1`, `CAR_MAKERS AS T2`, and `COUNTRIES AS T3` instead of querying only the `cars` table. Do join `T1` to `T2` on `T1.Maker = T2.Id` instead of missing this relationship entirely. Do join `T2` to `T3` on `T2.Country = T3.CountryId` instead of omitting the country table connection. Do filter on `T3.CountryName = 'usa'` instead of filtering directly on `country = 'USA'` which referenced the wrong column. Do use proper table aliases and qualified column references instead of unqualified column names that caused ambiguity. The amended query now correctly counts models from USA manufacturers by properly joining through the manufacturer and country relationships instead of relying on incorrect column references."
        ],
        "rules": [
            "1) When answering about \"count of car models produced in the United States\": make sure the output order: count of models using T1.Model as the counting key. 2) When the question mentions \"United States\": \"United States\" actually means T3.CountryName = 'usa' in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.Maker = T2.Id exactly as shown in the amends; keep only matching pairs (inner match). 4) When combining T2 and T3 for shared entities: link rows where T2.Country = T3.CountryId exactly as shown in the amends; keep only matching pairs (inner match). 5) When counting car models: compute the number of rows using T1.Model as the canonical key token for models."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE country = 'USA';",
            "SELECT COUNT(*) \nFROM model_list AS T1\nJOIN car_makers AS T2 ON T1.Maker = T2.Id\nJOIN countries AS T3 ON T2.Country = T3.CountryId\nWHERE T3.CountryName = 'usa'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.Model) AS count_of_models\nFROM model_list T1\nINNER JOIN car_makers T2 ON T1.Maker = T2.Id\nINNER JOIN countries T3 ON T2.Country = T3.CountryId\nWHERE T3.CountryName = 'usa'"
        ]
    },
    "109": {
        "db_id": "car_1",
        "question": "How many car models are produced by each maker ? Only list the count and the maker full name .",
        "ground_truth": "select count(*) ,  t2.fullname from model_list as t1 join car_makers as t2 on t1.maker  =  t2.id group by t2.id;",
        "amends": [
            "Do join `car_makers` as `t2` instead of omitting it, and use `model_list` as `t1` instead of `car_models`. Do join on `t1.maker = t2.id` instead of no join condition. Do select `t2.fullname` instead of `maker`, and remove the alias `model_count` instead of keeping it. Do group by `t2.id` instead of `maker`. The amended query now correctly counts models per maker by joining to the car_makers table and grouping on the maker's ID rather than the raw maker value."
        ],
        "rules": [
            "1) When the question asks for \"each maker\": join table \"model_list\" as T1 with table \"car_makers\" as T2 using the condition T1.maker = T2.id to get maker information. 2) When counting car models per maker: count the number of rows using the canonical key from T1 (models) grouped by T2.id. 3) When the question asks for \"maker full name\": select T2.fullname instead of the raw maker value. 4) When organizing results by maker: group by T2.id to ensure proper aggregation per maker entity. 5) When producing output columns: list the count first followed by the maker full name, without using aliases for the count column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) as model_count, maker FROM car_models GROUP BY maker;",
            "SELECT COUNT(t1.ModelId) AS count, t2.FullName \nFROM model_list t1 \nJOIN car_makers t2 ON t1.Maker = t2.Id \nGROUP BY t2.Id"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ModelId), T2.FullName FROM model_list T1 JOIN car_makers T2 ON T1.Maker = T2.Id GROUP BY T2.Id"
        ]
    },
    "408": {
        "db_id": "course_teach",
        "question": "What are the names of the teachers who teach at least two courses?",
        "ground_truth": "SELECT T2.Name FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T2.Name HAVING COUNT(*)  >=  2",
        "amends": [
            "Do join `course_arrange AS T1` with `teacher AS T2` on `T1.Teacher_ID = T2.Teacher_ID` instead of querying only the `teachers` table. Do aggregate with `GROUP BY T2.Name` and filter with `HAVING COUNT(*) >= 2` instead of using `WHERE course_count >= 2` on a non-aggregated column. Do select `T2.Name` from the joined teacher table instead of selecting `name` directly from the original teachers table. The amended query now correctly counts actual course assignments per teacher rather than relying on a potentially incorrect course_count field, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"teachers who teach at least two courses\": make sure the output order: T2.Name. 2) When the question mentions \"teachers\": \"teachers\" actually means \"teacher AS T2\" in schema. 3) When combining course_arrange AS T1 and teacher AS T2 for shared entities: link rows where T1.Teacher_ID = T2.Teacher_ID exactly as shown; keep only matching pairs (inner match). 4) When the question asks for \"teachers who teach at least two courses\": organize results by T2.Name and compute COUNT(*) per group, then filter to keep only groups with COUNT(*) >= 2. 5) When producing output: select T2.Name from the joined teacher table instead of selecting name directly from the original teachers table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM teachers WHERE course_count >= 2;",
            "SELECT T2.Name FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID = T2.Teacher_ID GROUP BY T2.Name HAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T2.Name\nFROM course_arrange AS T1\nJOIN teacher AS T2 ON T1.Teacher_ID = T2.Teacher_ID\nGROUP BY T2.Name\nHAVING COUNT(*) >= 2\nORDER BY T2.Name"
        ]
    },
    "1002": {
        "db_id": "singer",
        "question": "List the name of singers in ascending order of net worth.",
        "ground_truth": "SELECT Name FROM singer ORDER BY Net_Worth_Millions ASC",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the correct table name `singer` instead of `singers`. Do order by `Net_Worth_Millions` instead of `net_worth` and use `ASC` ordering instead of `DESC`. The amended query now correctly references the proper column and table names with the intended ascending order by net worth."
        ],
        "rules": [
            "1) When the question asks for \"name of singers\": use the exact column token \"Name\" from table \"singer\" (not \"name\" from \"singers\"). 2) When ordering by \"net worth\": use the exact column token \"Net_Worth_Millions\" from table \"singer\". 3) When the question specifies \"ascending order\": order the results in ascending (ASC) direction, not descending (DESC)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers ORDER BY net_worth DESC;",
            "SELECT Name FROM singer ORDER BY Net_Worth_Millions ASC;"
        ],
        "rule_sql": [
            "SELECT Name FROM singer ORDER BY Net_Worth_Millions ASC;"
        ]
    },
    "270": {
        "db_id": "employee_hire_evaluation",
        "question": "What are the manager name and district of the shop that sells the largest number of products?",
        "ground_truth": "SELECT manager_name ,  district FROM shop ORDER BY number_products DESC LIMIT 1",
        "amends": [
            "Do reference table `shop` instead of `shops` in the FROM clause. Do order by `number_products` instead of `product_count` in the ORDER BY clause. The amended query now correctly retrieves the manager name and district from the shop table ordered by product count in descending order with a limit of one result."
        ],
        "rules": [
            "1) When the question asks about shops: use table \"shop\" instead of \"shops\". 2) When ordering by product count: use column \"number_products\" instead of \"product_count\". 3) When finding the shop with the largest number of products: order by \"number_products\" in descending order and keep only the first result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT manager_name, district FROM shops ORDER BY product_count DESC LIMIT 1;",
            "SELECT Manager_name, District FROM shop ORDER BY Number_products DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Manager_name, District FROM shop ORDER BY Number_products DESC LIMIT 1;"
        ]
    },
    "172": {
        "db_id": "car_1",
        "question": "What are the different models wthat are lighter than 3500 but were not built by the Ford Motor Company?",
        "ground_truth": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  3500 AND T4.FullName != 'Ford Motor Company';",
        "amends": [
            "Do use `DISTINCT T1.model` instead of just `model` to eliminate duplicates. Do join `MODEL_LIST AS T1`, `CAR_NAMES AS T2`, `CARS_DATA AS T3`, and `CAR_MAKERS AS T4` instead of querying only the `cars` table. Do use `JOIN CAR_NAMES AS T2 ON T1.Model = T2.Model` instead of no join condition. Do use `JOIN CARS_DATA AS T3 ON T2.MakeId = T3.Id` instead of no relationship. Do use `JOIN CAR_MAKERS AS T4 ON T1.Maker = T4.Id` instead of no manufacturer join. Do filter on `T3.weight < 3500` instead of just `weight < 3500` to reference the correct table. Do filter on `T4.FullName != 'Ford Motor Company'` instead of `manufacturer != 'Ford Motor Company'` to use the proper column name. The amended query now correctly joins multiple tables to establish proper relationships and returns distinct model names from the appropriate source table."
        ],
        "rules": [
            "1) When the question asks for \"different models\": use DISTINCT T1.model to eliminate duplicate model names. 2) When combining tables for this query: link MODEL_LIST AS T1 to CAR_NAMES AS T2 using T1.Model = T2.Model, then link CAR_NAMES AS T2 to CARS_DATA AS T3 using T2.MakeId = T3.Id, then link MODEL_LIST AS T1 to CAR_MAKERS AS T4 using T1.Maker = T4.Id, keeping only matching pairs (inner match). 3) When filtering for weight less than 3500: use T3.weight < 3500 to reference the correct table. 4) When excluding Ford Motor Company: use T4.FullName != 'Ford Motor Company' with exact literal 'Ford Motor Company' to filter manufacturers. 5) When producing output: return only the distinct model names from T1.model."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT model FROM cars WHERE weight < 3500 AND manufacturer != 'Ford Motor Company';",
            "SELECT DISTINCT T1.Model \nFROM model_list AS T1\nJOIN car_names AS T2 ON T1.Model = T2.Model\nJOIN cars_data AS T3 ON T2.MakeId = T3.Id\nJOIN car_makers AS T4 ON T1.Maker = T4.Id\nWHERE T3.Weight < 3500 \nAND T4.FullName != 'Ford Motor Company'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Model\nFROM model_list AS T1\nINNER JOIN car_names AS T2 ON T1.Model = T2.Model\nINNER JOIN cars_data AS T3 ON T2.MakeId = T3.Id\nINNER JOIN car_makers AS T4 ON T1.Maker = T4.Id\nWHERE T3.Weight < 3500\nAND T4.FullName != 'Ford Motor Company';"
        ]
    },
    "320": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the ids, version numbers, and type codes for each template?",
        "ground_truth": "SELECT template_id ,  version_number ,  template_type_code FROM Templates",
        "amends": [
            "Do select `template_id`, `version_number`, and `template_type_code` instead of `id`, `version`, and `type`. Do reference the table as `Templates` instead of `templates`. Do remove the `WHERE version > 5` filter instead of keeping it. Do remove the `ORDER BY id DESC` clause instead of including it. The amended query now correctly selects all columns from the Templates table without filtering or sorting, matching the intended behavior."
        ],
        "rules": [
            "1) When selecting columns for template information: use exact column names \"template_id\", \"version_number\", and \"template_type_code\" instead of generic names like id, version, or type. 2) When referencing the templates table: use the exact table name \"Templates\" with proper case and quotes as shown in the schema. 3) When the question asks for all templates without filtering conditions: do not apply any WHERE filters like version > 5. 4) When the question does not specify any ordering requirements: do not include any ORDER BY clauses like ORDER BY id DESC."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, version, type FROM templates WHERE version > 5 ORDER BY id DESC",
            "SELECT Template_ID, Version_Number, Template_Type_Code FROM Templates;"
        ],
        "rule_sql": [
            "SELECT template_id, version_number, template_type_code FROM Templates;"
        ]
    },
    "853": {
        "db_id": "orchestra",
        "question": "What is the record company used by the greatest number of orchestras?",
        "ground_truth": "SELECT Record_Company FROM orchestra GROUP BY Record_Company ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select only `Record_Company` instead of selecting both `record_company` and `COUNT(*) as orchestra_count`. Do use table name `orchestra` instead of `orchestras`. Do move the aggregate function `COUNT(*)` to the `ORDER BY` clause instead of including it in the `SELECT` list. Do capitalize `Record_Company` consistently instead of using lowercase `record_company`. The amended query now correctly returns only the record company with the highest count of orchestras while matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about \"record company used by the greatest number of orchestras\": use the exact column token \"Record_Company\" from table \"orchestra\" instead of lowercase \"record_company\". 2) When counting orchestras per record company: compute the count using all rows (COUNT(*)) but do not include the count in the output columns. 3) When finding the record company with the greatest number of orchestras: order the results by the orchestra count in descending order and keep only the top result. 4) When referring to the table containing orchestras: use the exact table name \"orchestra\" instead of \"orchestras\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT record_company, COUNT(*) as orchestra_count \nFROM orchestras \nGROUP BY record_company \nORDER BY orchestra_count DESC \nLIMIT 1;",
            "SELECT Record_Company FROM orchestra GROUP BY Record_Company ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Record_Company FROM orchestra GROUP BY Record_Company ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "89": {
        "db_id": "car_1",
        "question": "How many countries does each continent have? List the continent id, continent name and the number of countries.",
        "ground_truth": "SELECT T1.ContId ,  T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.Continent GROUP BY T1.ContId;",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do select from `CONTINENTS AS T1` instead of only `countries`. Do add `JOIN COUNTRIES AS T2 ON T1.ContId = T2.Continent` instead of omitting the join condition. Do change the SELECT list to `T1.ContId, T1.Continent, count(*)` instead of `continent_id, continent_name, COUNT(*) as country_count`. Do modify the GROUP BY clause to `GROUP BY T1.ContId` instead of grouping by both `continent_id` and `continent_name`. The amended query now correctly joins continents with countries and counts countries per continent, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"How many countries does each continent have?\": make sure the output order: T1.ContId, T1.Continent, count(*) 2) When the question mentions \"continent id\": \"continent id\" actually means \"T1.ContId in schema\" 3) When the question mentions \"continent name\": \"continent name\" actually means \"T1.Continent in schema\" 4) When combining T1 and T2 for shared entities: link rows where T1.ContId = T2.Continent exactly as shown in the amends; keep only matching pairs (inner match) 5) When the question asks for \"count of countries\": compute the number of rows using the canonical key token for countries (T2 table) 6) When the question says \"per continent\"/\"by continent\": organize results by T1.ContId and compute requested aggregates per group 7) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT continent_id, continent_name, COUNT(*) as country_count \nFROM countries \nGROUP BY continent_id, continent_name",
            "SELECT T1.ContId, T1.Continent, COUNT(*) \nFROM continents AS T1 \nJOIN countries AS T2 ON T1.ContId = T2.Continent \nGROUP BY T1.ContId"
        ],
        "rule_sql": [
            "SELECT T1.\"ContId\", T1.\"Continent\", COUNT(*) \nFROM \"continents\" T1 \nINNER JOIN \"countries\" T2 ON T1.\"ContId\" = T2.\"Continent\" \nGROUP BY T1.\"ContId\", T1.\"Continent\""
        ]
    },
    "16": {
        "db_id": "concert_singer",
        "question": "What is the maximum capacity and the average of all stadiums ?",
        "ground_truth": "select max(capacity), average from stadium",
        "amends": [
            "Do `max(capacity)` instead of `MIN(capacity)` for the maximum value calculation. Do `average` instead of `AVG(capacity)` for the average column alias. Do `stadium` instead of `stadiums` for the correct table name. The amended query now correctly calculates maximum capacity with proper table reference and column aliasing.",
            "Do include the `average` column directly in the SELECT list instead of calculating it with `AVG(Capacity) AS average`. Do remove the alias `maximum` from the `MAX(Capacity)` expression instead of keeping it. The amended query now matches RIGHT_SQL's behavior by selecting the maximum capacity and the average column directly from the stadium table."
        ],
        "rules": [
            "1) When calculating maximum capacity: use max(capacity) instead of MIN(capacity) for the maximum value calculation. 2) When calculating the average capacity: use average instead of AVG(capacity) for the column alias. 3) When referencing the stadiums table: use stadium instead of stadiums for the correct table name.",
            "1) When answering about maximum capacity and average of all stadiums: select both MAX(Capacity) and the average column directly from the stadium table. 2) When calculating maximum capacity: use MAX(Capacity) without an alias. 3) When including the average value: select the average column directly instead of calculating it with AVG(Capacity)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(capacity), AVG(capacity) FROM stadiums;",
            "SELECT MAX(Capacity) AS maximum, AVG(Capacity) AS average FROM stadium;",
            "SELECT MAX(Capacity), average FROM stadium"
        ],
        "rule_sql": [
            "SELECT MAX(Capacity), average FROM stadium"
        ]
    },
    "951": {
        "db_id": "dog_kennels",
        "question": "What are each owner's first name, last name, and the size of their dog?",
        "ground_truth": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of no aliases. Do reference `T1.first_name` and `T1.last_name` instead of unqualified `first_name` and `last_name`. Do select `T2.size_code` instead of `dog_size`. Do use `Owners AS T1` and `Dogs AS T2` instead of unaliased `owners` and `dogs`. Do join on `T1.owner_id = T2.owner_id` instead of `owners.id = dogs.owner_id`. The amended query now correctly matches the intended logic by using proper table aliases and the correct join condition between owner_id fields."
        ],
        "rules": [
            "1) When answering about \"each owner's first name, last name, and the size of their dog\": make sure the output order: T1.first_name, T1.last_name, T2.size_code. 2) When the question mentions \"owner\": use table \"Professionals\" as T1 with columns first_name and last_name. 3) When the question mentions \"dog size\": use column T2.size_code from the Dogs table instead of dog_size. 4) When combining T1 (Professionals) and T2 (Dogs) for shared entities: link rows where T1.owner_id = T2.owner_id and keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table and column names."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, dog_size FROM owners JOIN dogs ON owners.id = dogs.owner_id",
            "SELECT T1.first_name, T1.last_name, T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id = T2.owner_id;"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.last_name, T2.size_code FROM Professionals T1 INNER JOIN Dogs T2 ON T1.owner_id = T2.owner_id ORDER BY T1.first_name, T1.last_name, T2.size_code"
        ]
    },
    "836": {
        "db_id": "orchestra",
        "question": "List names of conductors in descending order of years of work.",
        "ground_truth": "SELECT Name FROM conductor ORDER BY Year_of_Work DESC",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the `conductor` table instead of `conductors`. Do order by `Year_of_Work DESC` instead of `years_of_work ASC`, changing both the column reference and sort direction. The amended query now correctly references the proper table and column names with the intended descending sort order."
        ],
        "rules": [
            "1) When answering about \"names of conductors\": use the exact column token \"Name\" from table conductor. 2) When the question mentions \"conductors\": it actually means table \"conductor\" in the schema. 3) When the question asks for \"descending order of years of work\": order by column \"Year_of_Work\" in descending direction. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM conductors ORDER BY years_of_work ASC;",
            "SELECT Name FROM conductor ORDER BY Year_of_Work DESC;"
        ],
        "rule_sql": [
            "SELECT \"Name\" FROM \"conductor\" ORDER BY \"Year_of_Work\" DESC;"
        ]
    },
    "769": {
        "db_id": "world_1",
        "question": "What is the official language used in the country the name of whose head of state is Beatrix.",
        "ground_truth": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.HeadOfState  =  \"Beatrix\" AND T2.IsOfficial  =  \"T\"",
        "amends": [
            "Do select `T2.Language` from the countrylanguage table instead of `language` from the countries table. Do join `country AS T1` with `countrylanguage AS T2` on `T1.Code = T2.CountryCode` instead of querying a single table. Do add the filter `T2.IsOfficial = \"T\"` to only include official languages instead of omitting this condition. Do reference the correct column name `HeadOfState` instead of `head_of_state`. The amended query now correctly retrieves official languages for countries where the head of state is Beatrix, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about \"official language\": select \"T2.Language\" from the countrylanguage table instead of \"language\" from the countries table. 2) When combining country and countrylanguage tables: join \"country AS T1\" with \"countrylanguage AS T2\" on \"T1.Code = T2.CountryCode\" to link countries with their languages. 3) When filtering for official languages: add the condition \"T2.IsOfficial = \\\"T\\\"\" to only include official languages. 4) When referencing the head of state: use the exact column name \"HeadOfState\" instead of \"head_of_state\". 5) When filtering for head of state named Beatrix: use the exact literal value \"Beatrix\" with the correct case."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT language FROM countries WHERE head_of_state = 'Beatrix';",
            "SELECT T2.Language \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T1.HeadOfState = 'Beatrix' \nAND T2.IsOfficial = 'T'"
        ],
        "rule_sql": [
            "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T1.HeadOfState = 'Beatrix' AND T2.IsOfficial = 'T'"
        ]
    },
    "890": {
        "db_id": "network_1",
        "question": "Show the names of all of the high schooler Kyle's friends.",
        "ground_truth": "SELECT T3.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id JOIN Highschooler AS T3 ON T1.friend_id  =  T3.id WHERE T2.name  =  \"Kyle\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM Highschooler WHERE ID IN (SELECT friend_id FROM Friend WHERE student_id = (SELECT ID FROM Highschooler WHERE name = 'Kyle'))"
        ],
        "rule_sql": [
            "SELECT h.name \nFROM Highschooler h\nJOIN Friend f ON h.ID = f.friend_id\nJOIN Highschooler kyle ON f.student_id = kyle.ID\nWHERE kyle.name = 'Kyle';"
        ]
    },
    "981": {
        "db_id": "dog_kennels",
        "question": "Find the number of owners who do not own any dogs at this moment.",
        "ground_truth": "SELECT count(*) FROM Owners WHERE owner_id NOT IN ( SELECT owner_id FROM Dogs )",
        "amends": [
            "Do use a subquery with `NOT IN` to find owners without dogs instead of checking for `dog_id IS NULL` which incorrectly assumes a direct relationship. Do reference `owner_id` in both the main query and subquery instead of using `dog_id` which doesn't exist in the owners table. Do select from the `Dogs` table in the subquery to identify owners who have dogs instead of omitting this necessary join logic. The amended query now correctly identifies owners without any dogs by checking which owner_ids are not present in the Dogs table, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When counting owners who do not own any dogs: use a subquery to find owner_ids that are not present in the Dogs table instead of checking for NULL values. 2) When referencing owners: use the exact identifier \"owner_id\" from the Owners table as the counting key. 3) When checking for owners without dogs: compare \"owner_id\" from Owners against \"owner_id\" in the Dogs table using a NOT IN condition. 4) When selecting from the Dogs table in the subquery: use the exact column \"owner_id\" to identify which owners currently have dogs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM owners WHERE dog_id IS NULL;",
            "SELECT COUNT(*) FROM Owners WHERE owner_id NOT IN (SELECT DISTINCT owner_id FROM Dogs)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Owners \nWHERE owner_id NOT IN (SELECT owner_id FROM Dogs)"
        ]
    },
    "1029": {
        "db_id": "singer",
        "question": "What are the citizenships that are shared by singers with a birth year before 1945 and after 1955?",
        "ground_truth": "SELECT Citizenship FROM singer WHERE Birth_Year  <  1945 INTERSECT SELECT Citizenship FROM singer WHERE Birth_Year  >  1955",
        "amends": [
            "Do use `INTERSECT` between two separate queries instead of `OR` in a single query. Do reference `Citizenship` with proper capitalization instead of lowercase `citizenship`. Do use table name `singer` instead of plural `singers`. Do remove `DISTINCT` since `INTERSECT` inherently returns distinct values instead of keeping it. Do maintain the same column selection `Citizenship` but with proper case handling. Do split the birth year conditions into separate queries with `Birth_Year < 1945` and `Birth_Year > 1955` instead of combining them with `OR`. The amended query now correctly finds citizenships that appear in both the pre-1945 and post-1955 birth year groups, matching the RIGHT_SQL's intersection behavior."
        ],
        "rules": [
            "1) When the question asks for citizenships shared by two groups: use INTERSECT between separate queries for each group instead of OR in a single query. 2) When referencing the citizenship column: use exact token \"Citizenship\" with proper capitalization instead of lowercase \"citizenship\". 3) When referencing the table: use exact table name \"singer\" instead of plural \"singers\". 4) When using INTERSECT: remove DISTINCT since INTERSECT inherently returns distinct values. 5) When splitting birth year conditions: create separate queries with \"Birth_Year < 1945\" and \"Birth_Year > 1955\" instead of combining them with OR."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT citizenship \nFROM singers \nWHERE birth_year < 1945 OR birth_year > 1955;",
            "SELECT Citizenship FROM singer WHERE Birth_Year < 1945\nINTERSECT\nSELECT Citizenship FROM singer WHERE Birth_Year > 1955"
        ],
        "rule_sql": [
            "SELECT Citizenship FROM singer WHERE Birth_Year < 1945\nINTERSECT\nSELECT Citizenship FROM singer WHERE Birth_Year > 1955"
        ]
    },
    "349": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the template type descriptions for template type code \"AD\".",
        "ground_truth": "SELECT template_type_description FROM Ref_template_types WHERE template_type_code  =  \"AD\"",
        "amends": [
            "Do reference table `Ref_template_types` instead of `template_types` and use double quotes `\"AD\"` instead of single quotes `'AD'` for the string literal, while keeping the same column selection `template_type_description` and filter condition on `template_type_code`."
        ],
        "rules": [
            "1) When referencing the template types table: use \"Ref_template_types\" instead of \"template_types\" as the exact table name. 2) When filtering for template type code \"AD\": use double quotes \"AD\" instead of single quotes 'AD' for the exact string literal. 3) When selecting template type descriptions: use the column \"template_type_description\" from the \"Ref_template_types\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_description FROM template_types WHERE template_type_code = 'AD';",
            "SELECT template_type_description FROM Ref_Template_Types WHERE template_type_code = \"AD\""
        ],
        "rule_sql": [
            "SELECT template_type_description FROM Ref_template_types WHERE Template_Type_Code = \"AD\";"
        ]
    },
    "519": {
        "db_id": "student_transcripts_tracking",
        "question": "How many different degree names are offered?",
        "ground_truth": "SELECT count(DISTINCT degree_summary_name) FROM Degree_Programs",
        "amends": [
            "Do select `count(DISTINCT degree_summary_name)` instead of `COUNT(*)` to count distinct degree names rather than all rows. Do query from `Degree_Programs` instead of `degrees` to use the correct table source. The amended query now correctly counts unique degree program names from the appropriate table, matching the intended behavior."
        ],
        "rules": [
            "1) When counting different degree names: count distinct values of \"degree_summary_name\" column. 2) When the question asks about degree names: use the \"Degree_Programs\" table as the source. 3) When selecting from Degree_Programs table: use the exact identifier \"Degree_Programs\" with proper case and no quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM degrees;",
            "SELECT COUNT(DISTINCT degree_summary_name) FROM Degree_Programs;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT degree_summary_name) FROM Degree_Programs;"
        ]
    },
    "14": {
        "db_id": "concert_singer",
        "question": "Show location and name for all stadiums with a capacity between 5000 and 10000.",
        "ground_truth": "SELECT LOCATION ,  name FROM stadium WHERE capacity BETWEEN 5000 AND 10000",
        "amends": [
            "Do use the table name `stadium` instead of `stadiums`. Do use `BETWEEN 5000 AND 10000` instead of `capacity < 5000 OR capacity > 10000` to select stadiums with capacity within the specified range rather than outside it. Do capitalize `LOCATION` instead of `location` while keeping the same column selection. The amended query now correctly filters for stadiums with capacity between 5000 and 10000, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about stadiums: use the exact table name \"stadium\" instead of \"stadiums\". 2) When filtering for capacity between 5000 and 10000: use BETWEEN 5000 AND 10000 to include both bounds inclusively, not capacity < 5000 OR capacity > 10000 which would exclude the range. 3) When selecting the location column: use the exact column name \"LOCATION\" with uppercase letters as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location, name FROM stadiums WHERE capacity < 5000 OR capacity > 10000;",
            "SELECT LOCATION, Name FROM stadium WHERE Capacity BETWEEN 5000 AND 10000;"
        ],
        "rule_sql": [
            "SELECT LOCATION, Name FROM stadium WHERE Capacity BETWEEN 5000 AND 10000;"
        ]
    },
    "199": {
        "db_id": "flight_2",
        "question": "What is the airport name for airport 'AKO'?",
        "ground_truth": "SELECT AirportName FROM AIRPORTS WHERE AirportCode  =  \"AKO\"",
        "amends": [
            "Do select `AirportName` instead of `name` and filter on `AirportCode` instead of `code`. Do use double quotes `\"AKO\"` instead of single quotes `'AKO'` for the string literal. The amended query now correctly references the actual column names and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"airport name\": use the exact column token \"AirportName\" from the airports table. 2) When filtering for airport code 'AKO': use the exact column token \"AirportCode\" and the exact string literal \"AKO\" with double quotes. 3) When answering about airport information: make sure to select from the airports table only."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM airports WHERE code = 'AKO';",
            "SELECT AirportName FROM airports WHERE AirportCode = \"AKO\""
        ],
        "rule_sql": [
            "SELECT AirportName FROM airports WHERE AirportCode = \"AKO\";"
        ]
    },
    "889": {
        "db_id": "network_1",
        "question": "What are the names of high schoolers who have 3 or more friends?",
        "ground_truth": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id HAVING count(*)  >=  3",
        "amends": [
            "Do use `JOIN` between `Friend` and `Highschooler` tables on `T1.student_id = T2.id` instead of querying only the `high_schoolers` table. Do add `GROUP BY T1.student_id` to aggregate friend counts per student instead of assuming a direct `friend_count` column exists. Do move the count filter to `HAVING count(*) >= 3` instead of using `WHERE friend_count >= 3` since the count is derived from aggregation. Do select `T2.name` from the joined Highschooler table instead of selecting `name` directly from the original table. The amended query now correctly identifies students with at least three friends by counting actual friendship records rather than relying on a potentially non-existent column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about high schoolers with friends: combine the Highschooler table (as T2) and Friend table (as T1) by linking rows where T1.student_id equals T2.id, keeping only matching pairs. 2) When counting friends per student: group the results by T1.student_id and count the number of friend records for each student. 3) When filtering for students with 3 or more friends: only keep groups where the count of friend records is greater than or equal to 3. 4) When selecting student names: output T2.name from the joined Highschooler table rather than from the original table directly."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM high_schoolers WHERE friend_count >= 3;",
            "SELECT T2.name \nFROM Friend T1 \nJOIN Highschooler T2 ON T1.student_id = T2.ID \nGROUP BY T1.student_id \nHAVING COUNT(*) >= 3"
        ],
        "rule_sql": [
            "SELECT T2.name \nFROM Friend AS T1 \nJOIN Highschooler AS T2 ON T1.student_id = T2.ID \nGROUP BY T1.student_id \nHAVING COUNT(*) >= 3"
        ]
    },
    "392": {
        "db_id": "course_teach",
        "question": "Where is the youngest teacher from?",
        "ground_truth": "SELECT Hometown FROM teacher ORDER BY Age ASC LIMIT 1",
        "amends": [
            "Do select `Hometown` instead of `name` and reference `teacher` instead of `teachers` as the table source, while maintaining the `ORDER BY Age ASC LIMIT 1` clause unchanged."
        ],
        "rules": [
            "1) When answering about \"the youngest teacher\": make sure the output order: Hometown. 2) When the question asks for \"where is the youngest teacher\": \"where\" actually means \"Hometown in schema\". 3) When the question mentions \"youngest\": rank rows by Age in ascending order and keep the first 1 row. 4) When selecting from the teacher table: use the exact table name \"teacher\" (not \"teachers\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM teachers ORDER BY age ASC LIMIT 1;",
            "SELECT Hometown FROM teacher ORDER BY Age ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Hometown FROM teacher ORDER BY Age ASC LIMIT 1;"
        ]
    },
    "655": {
        "db_id": "poker_player",
        "question": "What is the money rank of the poker player with the highest earnings?",
        "ground_truth": "SELECT Money_Rank FROM poker_player ORDER BY Earnings DESC LIMIT 1",
        "amends": [
            "Do use `Money_Rank` as the column alias instead of `money_rank`. Do select from `poker_player` instead of `poker_players`. Do remove the window function `RANK() OVER (ORDER BY earnings DESC)` and instead use a simple `ORDER BY Earnings DESC` with `LIMIT 1` to get the top-ranked player. Do eliminate the subquery `(SELECT MAX(earnings) FROM poker_players)` that was incorrectly filtering for only maximum earnings records. Do remove the `WHERE` clause entirely instead of using it to filter for maximum earnings. The amended query now correctly retrieves the top-ranked player by earnings using proper ordering and limiting instead of the complex window function approach with incorrect filtering."
        ],
        "rules": [
            "1) When the question asks for the \"money rank\" of a poker player: use the exact column name \"Money_Rank\" from the poker_player table. 2) When the question asks for the player with the highest earnings: order the results by \"Earnings\" in descending order and take only the first row. 3) When retrieving the top-ranked player: do not use window functions or subqueries for maximum earnings filtering, instead use simple ordering and limiting. 4) When selecting from the poker players table: use the exact table name \"poker_player\" (not \"poker_players\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT RANK() OVER (ORDER BY earnings DESC) as money_rank FROM poker_players WHERE earnings = (SELECT MAX(earnings) FROM poker_players);",
            "SELECT Money_Rank FROM poker_player ORDER BY Earnings DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Money_Rank FROM poker_player ORDER BY Earnings DESC LIMIT 1;"
        ]
    },
    "831": {
        "db_id": "orchestra",
        "question": "Return the average attendance across all shows.",
        "ground_truth": "SELECT avg(Attendance) FROM SHOW",
        "amends": [
            "Do use the `avg` aggregate function instead of `SUM` to calculate the average attendance rather than the total sum. Do reference the column as `Attendance` with proper capitalization instead of lowercase `attendance`. Do query from the `SHOW` table instead of the plural `shows` table. The amended query now correctly calculates average attendance from the appropriate table with proper column reference."
        ],
        "rules": [
            "1) When calculating average attendance: use the avg aggregate function instead of sum to compute the average value. 2) When referencing the attendance column: use exact column name \"Attendance\" with proper capitalization instead of lowercase \"attendance\". 3) When querying from the shows table: use the exact table name \"SHOW\" instead of the plural form \"shows\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(attendance) FROM shows;",
            "SELECT AVG(Attendance) FROM show;"
        ],
        "rule_sql": [
            "SELECT AVG(Attendance) FROM SHOW;"
        ]
    },
    "93": {
        "db_id": "car_1",
        "question": "How many models does each car maker produce? List maker full name, id and the number.",
        "ground_truth": "SELECT T1.FullName ,  T1.Id ,  count(*) FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id;",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of unspecified table references. Do change the FROM clause to `CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2` instead of the single table `car_models`. Do add the join condition `ON T1.Id = T2.Maker` instead of omitting it. Do change the SELECT list to `T1.FullName, T1.Id, count(*)` instead of `maker, id, COUNT(*) as model_count`. Do remove the alias `model_count` instead of keeping it. Do change the GROUP BY clause to `T1.Id` instead of `maker, id`. The amended query now correctly joins the manufacturer and model tables and counts models per manufacturer."
        ],
        "rules": [
            "1) When answering about \"models per car maker\": make sure the output order: T1.FullName, T1.Id, count(*) 2) When the question mentions \"car maker\": \"car maker\" actually means \"CAR_MAKERS as T1\" in schema 3) When the question mentions \"models\": \"models\" actually means \"MODEL_LIST as T2\" in schema 4) When combining T1 and T2 for shared entities: link rows where T1.Id = T2.Maker exactly as shown in the amends; keep only matching pairs (inner match) 5) When the question asks for \"count of models\" per maker: compute the number of rows using the join relationship where T2.Maker matches T1.Id 6) When the question says \"per car maker\"/\"by car maker\": organize results by T1.Id and compute count per group 7) When producing output: do not include aliases like \"model_count\" in the final result"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT maker, id, COUNT(*) as model_count FROM car_models GROUP BY maker, id",
            "SELECT T1.FullName, T1.Id, count(*)\nFROM CAR_MAKERS AS T1\nJOIN MODEL_LIST AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id"
        ],
        "rule_sql": [
            "SELECT T1.FullName, T1.Id, COUNT(*) \nFROM CAR_MAKERS AS T1 \nINNER JOIN MODEL_LIST AS T2 ON T1.Id = T2.Maker \nGROUP BY T1.Id, T1.FullName \nORDER BY T1.FullName, T1.Id"
        ]
    },
    "325": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "How many templates have template type code CV?",
        "ground_truth": "SELECT count(*) FROM Templates WHERE template_type_code  =  \"CV\"",
        "amends": [
            "Do reference the table as `Templates` instead of `templates` to match the correct case sensitivity. Do use the column `template_type_code` instead of `template_type` to reference the correct column name. Do use double quotes `\"CV\"` instead of single quotes `'CV'` for the string literal value. The amended query now correctly counts records from the Templates table where the template_type_code equals \"CV\", matching the intended behavior."
        ],
        "rules": [
            "1) When referencing the Templates table: use the exact identifier \"Templates\" with proper case sensitivity. 2) When filtering by template type code: use the exact column name \"template_type_code\" instead of \"template_type\". 3) When comparing with the literal value CV: use double quotes \"CV\" instead of single quotes to match the required string format. 4) When counting templates: count all rows from the Templates table that satisfy the condition template_type_code = \"CV\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM templates WHERE template_type = 'CV';",
            "SELECT COUNT(*) FROM Templates WHERE template_type_code = \"CV\";"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Templates WHERE template_type_code = \"CV\";"
        ]
    },
    "518": {
        "db_id": "student_transcripts_tracking",
        "question": "How many different departments offer degrees?",
        "ground_truth": "SELECT count(DISTINCT department_id) FROM Degree_Programs",
        "amends": [
            "Do select `count(DISTINCT department_id)` instead of `COUNT(*)` to count unique departments rather than all rows. Do query from `Degree_Programs` table instead of `departments` to access the correct source data. Do remove the `WHERE degree_offered = 'yes'` filter instead of keeping it since the Degree_Programs table inherently contains only degree-offering programs. The amended query now correctly counts distinct department IDs from the appropriate table without needing explicit filtering."
        ],
        "rules": [
            "1) When counting different departments: count distinct values of \"department_id\" instead of counting all rows. 2) When accessing degree-offering data: use the \"Degree_Programs\" table instead of the \"departments\" table, as it inherently contains only degree-offering programs. 3) When filtering for degree-offering programs: do not apply a WHERE clause with \"degree_offered = 'yes'\" since the Degree_Programs table already contains only relevant programs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM departments WHERE degree_offered = 'yes';",
            "SELECT COUNT(DISTINCT department_id) FROM Degree_Programs;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT department_id) AS department_count FROM Degree_Programs;"
        ]
    },
    "1031": {
        "db_id": "real_estate_properties",
        "question": "What is the feature type name of feature AirCon?",
        "ground_truth": "SELECT T2.feature_type_name FROM Other_Available_Features AS T1 JOIN Ref_Feature_Types AS T2 ON T1.feature_type_code  =  T2.feature_type_code WHERE T1.feature_name  =  \"AirCon\"",
        "amends": [
            "Do select `T2.feature_type_name` instead of `feature_name`. Do use `FROM Other_Available_Features AS T1 JOIN Ref_Feature_Types AS T2` instead of `FROM features`. Do apply join condition `ON T1.feature_type_code = T2.feature_type_code` instead of no join. Do filter with `WHERE T1.feature_name = \"AirCon\"` instead of `WHERE feature_type = 'AirCon'`. The amended query now correctly joins reference tables to retrieve the feature type name rather than the feature name itself, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"feature type name of feature AirCon\": select T2.feature_type_name instead of feature_name. 2) When combining Other_Available_Features and Ref_Feature_Types: link rows where T1.feature_type_code = T2.feature_type_code and keep only matching pairs (inner match). 3) When filtering for feature \"AirCon\": use T1.feature_name = \"AirCon\" exactly as specified with double quotes. 4) When answering about feature type name: make sure the output order: T2.feature_type_name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT feature_name FROM features WHERE feature_type = 'AirCon';",
            "SELECT T2.feature_type_name \nFROM Other_Available_Features AS T1 \nJOIN Ref_Feature_Types AS T2 ON T1.feature_type_code = T2.feature_type_code \nWHERE T1.feature_name = 'AirCon'"
        ],
        "rule_sql": [
            "SELECT T2.feature_type_name \nFROM Other_Available_Features T1 \nINNER JOIN Ref_Feature_Types T2 ON T1.feature_type_code = T2.feature_type_code \nWHERE T1.feature_name = \"AirCon\""
        ]
    },
    "639": {
        "db_id": "tvshow",
        "question": "find the pixel aspect ratio and nation of the tv channels that do not use English.",
        "ground_truth": "SELECT Pixel_aspect_ratio_PAR ,  country FROM tv_channel WHERE LANGUAGE != 'English'",
        "amends": [
            "Do use column alias `Pixel_aspect_ratio_PAR` instead of `pixel_aspect_ratio`, and select `country` instead of `nation`. Do reference table `tv_channel` instead of `tv_channels`. Do apply filter `LANGUAGE != 'English'` instead of `language = 'English'` to exclude English language records rather than including them. The amended query now correctly retrieves non-English TV channel data with the specified column names and table reference."
        ],
        "rules": [
            "1) When the question mentions \"pixel aspect ratio\": use the exact column name \"Pixel_aspect_ratio_PAR\" from the TV_Channel table. 2) When the question mentions \"nation\": use the exact column name \"country\" from the TV_Channel table instead. 3) When the question asks for TV channels that do not use English: apply the filter condition where LANGUAGE != 'English' to exclude English language records. 4) When referencing the TV channels table: use the exact table name \"tv_channel\" instead of \"tv_channels\". 5) When selecting output columns: maintain the order Pixel_aspect_ratio_PAR followed by country as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pixel_aspect_ratio, nation FROM tv_channels WHERE language = 'English';",
            "SELECT Pixel_aspect_ratio_PAR, Country FROM TV_Channel WHERE Language != 'English';"
        ],
        "rule_sql": [
            "SELECT Pixel_aspect_ratio_PAR, Country FROM TV_Channel WHERE Language != 'English';"
        ]
    },
    "147": {
        "db_id": "car_1",
        "question": "How many car models were produced by the maker with full name American Motor Company?",
        "ground_truth": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker WHERE T1.FullName  =  'American Motor Company';",
        "amends": [
            "Do add `JOIN MODEL_LIST AS T2 ON T1.Id = T2.Maker` instead of querying only the `car_makers` table. Do use table alias `T1` for `CAR_MAKERS` instead of referencing the table directly. Do reference `T1.FullName` instead of `full_name` to match the proper column casing. The amended query now correctly joins the model list table to count models from American Motor Company instead of just counting the manufacturer itself, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"car models produced by a maker\": make sure to join CAR_MAKERS (as T1) with MODEL_LIST (as T2) using the exact key equality T1.Id = T2.Maker. 2) When the question mentions \"car models\": \"car models\" actually means \"rows in MODEL_LIST table\". 3) When the question asks for \"count of car models\": compute the number of rows using the canonical key from MODEL_LIST. 4) When the question specifies \"maker with full name American Motor Company\": use the exact literal 'American Motor Company' with T1.FullName column. 5) When combining T1 and T2 for shared entities: link rows where T1.Id = T2.Maker exactly as shown in the amends; keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM car_makers WHERE full_name = 'American Motor Company';",
            "SELECT COUNT(*) FROM car_makers AS T1 JOIN model_list AS T2 ON T1.Id = T2.Maker WHERE T1.FullName = 'American Motor Company'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nWHERE T1.FullName = 'American Motor Company'"
        ]
    },
    "820": {
        "db_id": "world_1",
        "question": "What are the codes of countries where Spanish is spoken by the largest percentage of people?",
        "ground_truth": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  \"Spanish\" GROUP BY CountryCode",
        "amends": [
            "Do add `max(Percentage)` to the SELECT list and include `GROUP BY CountryCode` instead of using `ORDER BY Percentage DESC LIMIT 1` to find the maximum percentage. Do remove the `ORDER BY` and `LIMIT` clauses instead of keeping them, as the aggregate function with grouping achieves the same result more efficiently. Do keep the `WHERE Language = 'Spanish'` filter unchanged. The amended query now correctly returns each country's maximum Spanish speaking percentage rather than just the single highest percentage country, matching the RIGHT_SQL's behavior of showing all countries with their respective maximum percentages."
        ],
        "rules": [
            "1) When answering about \"codes of countries where Spanish is spoken by the largest percentage of people\": make sure the output order includes CountryCode and max(Percentage). 2) When the question mentions \"Spanish\": \"Spanish\" actually means \"Language = 'Spanish'\" in the schema. 3) When the question asks for \"largest percentage per country\": organize results by CountryCode and compute the maximum Percentage value per group. 4) When computing maximum percentage: use max(Percentage) as the aggregate function for each CountryCode group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT CountryCode FROM countrylanguage WHERE Language = 'Spanish' ORDER BY Percentage DESC LIMIT 1;",
            "SELECT CountryCode, MAX(Percentage) FROM countrylanguage WHERE Language = 'Spanish' GROUP BY CountryCode"
        ],
        "rule_sql": [
            "SELECT CountryCode, MAX(Percentage) AS MaxPercentage FROM countrylanguage WHERE Language = 'Spanish' GROUP BY CountryCode ORDER BY MaxPercentage DESC;"
        ]
    },
    "264": {
        "db_id": "employee_hire_evaluation",
        "question": "Count the number of employees for each city.",
        "ground_truth": "SELECT count(*) ,  city FROM employee GROUP BY city",
        "amends": [
            "Do place `city` after `count(*)` in the SELECT list instead of before it. Do use table name `employee` instead of `employees` in the FROM clause. The amended query now correctly counts employees by city using the proper table reference and column ordering."
        ],
        "rules": [
            "1) When the question asks for \"count of employees for each city\": organize results by the exact token \"city\" and compute the count using the canonical key for employees. 2) When producing output columns: place the count result before the city column in the output order. 3) When referring to the employee table: use the exact table name \"employee\" (not \"employees\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, COUNT(*) FROM employees GROUP BY city;",
            "SELECT COUNT(*), City FROM employee GROUP BY City;"
        ],
        "rule_sql": [
            "SELECT COUNT(Employee_ID) AS employee_count, City FROM employee GROUP BY City;"
        ]
    },
    "179": {
        "db_id": "flight_2",
        "question": "Which country does Airline \"JetBlue Airways\" belong to?",
        "ground_truth": "SELECT Country FROM AIRLINES WHERE Airline  =  \"JetBlue Airways\"",
        "amends": [
            "Do reference the `Country` column instead of `country` to match the correct case sensitivity. Do reference the `Airline` column instead of `name` to use the proper column name for airline identification. Do use double quotes `\"JetBlue Airways\"` instead of single quotes `'JetBlue Airways'` for string literal formatting. The amended query now correctly retrieves the country information for JetBlue Airways by using the appropriate column names and string formatting."
        ],
        "rules": [
            "1) When the question asks about an airline's country: combine information from the flights table (T1) and airports table (T2) using their relationship keys. 2) When identifying a specific airline by name: use the exact literal \"JetBlue Airways\" with double quotes for string matching. 3) When selecting the country information: use the exact column name \"Country\" from the airports table (T2) with proper case sensitivity. 4) When filtering for a specific airline: use the column \"Airline\" from the flights table (T1) to identify airlines, not a generic \"name\" column."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM airlines WHERE name = 'JetBlue Airways';",
            "SELECT Country FROM airlines WHERE Airline = \"JetBlue Airways\";"
        ],
        "rule_sql": [
            "SELECT DISTINCT a2.Country \nFROM airlines a1\nJOIN flights f ON a1.uid = f.Airline\nJOIN airports a2 ON f.SourceAirport = a2.AirportCode OR f.DestAirport = a2.AirportCode\nWHERE a1.Airline = \"JetBlue Airways\""
        ]
    },
    "446": {
        "db_id": "wta_1",
        "question": "What are the names of tournaments that have more than 10 matches?",
        "ground_truth": "SELECT tourney_name FROM matches GROUP BY tourney_name HAVING count(*)  >  10",
        "amends": [
            "Do select `tourney_name` instead of `tournament_name` and use `GROUP BY` with `HAVING count(*) > 10` instead of `WHERE COUNT(matches) > 10`. Do query from `matches` table instead of `tournaments` table and remove the incorrect aggregate function usage in the WHERE clause. The amended query now correctly groups matches by tournament name and filters for tournaments with more than 10 matches using proper HAVING clause syntax, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for tournament names: use the exact column name \"tourney_name\" instead of \"tournament_name\" from the matches table. 2) When counting matches per tournament: group by \"tourney_name\" and count all rows using count(*) to get the total number of matches per tournament. 3) When filtering for tournaments with more than 10 matches: use a having condition count(*) > 10 after grouping by \"tourney_name\". 4) When querying about tournament matches: use the matches table as the primary source instead of the tournaments table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT tournament_name FROM tournaments WHERE COUNT(matches) > 10",
            "SELECT tourney_name FROM matches GROUP BY tourney_name HAVING COUNT(*) > 10"
        ],
        "rule_sql": [
            "SELECT tourney_name FROM matches GROUP BY tourney_name HAVING COUNT(*) > 10"
        ]
    },
    "235": {
        "db_id": "flight_2",
        "question": "What are airlines that have flights arriving at airport 'AHD'?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.DestAirport  =  \"AHD\"",
        "amends": [
            "Do select `T1.Airline` from the `AIRLINES` table instead of `airline_name` from `flights`. Do join `AIRLINES AS T1` with `FLIGHTS AS T2` on `T1.uid = T2.Airline` instead of querying only the `flights` table. Do filter on `T2.DestAirport = \"AHD\"` instead of `departure_airport = 'AHD'` to correctly identify destination airports rather than departure airports. The amended query now properly joins airline information with flight data and filters for the correct destination airport, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about airlines with flights arriving at airport 'AHD': select \"T1.Airline\" from the \"AIRLINES\" table. 2) When combining airline and flight information: join \"AIRLINES AS T1\" with \"FLIGHTS AS T2\" where \"T1.uid = T2.Airline\" and keep only matching pairs (inner match). 3) When filtering for destination airport: use the condition \"T2.DestAirport = 'AHD'\" to identify flights arriving at the specified airport. 4) When handling text literals: preserve the exact value 'AHD' with the specified case and quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airline_name FROM flights WHERE departure_airport = 'AHD';",
            "SELECT T1.Airline \nFROM airlines AS T1\nJOIN flights AS T2 ON T1.uid = T2.Airline\nWHERE T2.DestAirport = 'AHD'"
        ],
        "rule_sql": [
            "SELECT T1.Airline FROM airlines AS T1 INNER JOIN flights AS T2 ON T1.uid = T2.Airline WHERE T2.DestAirport = 'AHD'"
        ]
    },
    "221": {
        "db_id": "flight_2",
        "question": "Which city has most number of arriving flights?",
        "ground_truth": "SELECT T1.City FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport GROUP BY T1.City ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `AIRPORTS` and `FLIGHTS` tables instead of querying only `flights` table. Do use `JOIN` with `AIRPORTS.AirportCode = FLIGHTS.DestAirport` instead of no join condition. Do select `T1.City` instead of `city`. Do group by `T1.City` instead of `city`. Do order by `count(*) DESC` instead of `flight_count ASC`. Do remove the alias `flight_count` instead of keeping it. The amended query now correctly identifies cities with airports by joining the appropriate tables and finds the city with the most destination flights instead of the fewest flights overall."
        ],
        "rules": [
            "1) When answering about \"city with most number of arriving flights\": make sure the output order: T1.City, count(*) 2) When the question mentions \"arriving flights\": \"arriving flights\" actually means \"FLIGHTS.DestAirport in schema\" 3) When combining AIRPORTS and FLIGHTS tables: link rows where AIRPORTS.AirportCode = FLIGHTS.DestAirport exactly as shown; keep only matching pairs (inner match) 4) When the question asks for \"most number\": rank rows by count(*) in descending direction and keep the first 1 row 5) When the question says \"by city\": organize results by T1.City and compute count per group 6) When the question asks for \"count of arriving flights\": compute the number of rows using the canonical key FLIGHTS.DestAirport"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, COUNT(*) as flight_count FROM flights GROUP BY city ORDER BY flight_count ASC LIMIT 1;",
            "SELECT a.City, COUNT(*) AS flight_count\nFROM flights f\nJOIN airports a ON f.DestAirport = a.AirportCode\nGROUP BY a.City\nORDER BY flight_count DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT a.City, COUNT(*) AS count\nFROM airports a\nJOIN flights f ON a.AirportCode = f.DestAirport\nGROUP BY a.City\nORDER BY count DESC\nLIMIT 1;"
        ]
    },
    "848": {
        "db_id": "orchestra",
        "question": "Please show the different record companies and the corresponding number of orchestras.",
        "ground_truth": "SELECT Record_Company ,  COUNT(*) FROM orchestra GROUP BY Record_Company",
        "amends": [
            "Do reference the `Record_Company` column instead of `record_company` and use proper capitalization. Do group by `Record_Company` instead of `orchestra_name` to match the SELECT clause aggregation. Do reference the correct table name `orchestra` instead of `orchestras`. The amended query now correctly counts records grouped by record company rather than by orchestra name, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"record companies\" and \"number of orchestras\": use the exact column token \"Record_Company\" from the orchestra table. 2) When counting orchestras per record company: group by \"Record_Company\" and count using the canonical key for orchestras. 3) When producing output: show \"Record_Company\" first followed by the count of orchestras. 4) When referring to the table: use the exact table name \"orchestra\" (not \"orchestras\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT record_company, COUNT(*) FROM orchestras GROUP BY orchestra_name;",
            "SELECT Record_Company, COUNT(*) AS Number_of_Orchestras FROM orchestra GROUP BY Record_Company;"
        ],
        "rule_sql": [
            "SELECT Record_Company, COUNT(Orchestra_ID) AS Number_of_Orchestras FROM orchestra GROUP BY Record_Company;"
        ]
    },
    "883": {
        "db_id": "network_1",
        "question": "How many friends does each student have?",
        "ground_truth": "SELECT student_id ,  count(*) FROM Friend GROUP BY student_id",
        "amends": [
            "Do use table name `Friend` instead of `friends` to reference the correct table. The amended query now matches RIGHT_SQL's behavior with the proper table reference."
        ],
        "rules": [
            "1) When the question asks about \"friends\": use the exact table name \"Friend\" instead of \"friends\" to reference the correct table. 2) When counting friends per student: compute the number of rows using the canonical key \"student_id\" and group by \"student_id\" to get counts for each student."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id, COUNT(*) FROM friends GROUP BY student_id;",
            "SELECT student_id, COUNT(friend_id) AS friend_count FROM Friend GROUP BY student_id"
        ],
        "rule_sql": [
            "SELECT student_id, COUNT(friend_id) AS friend_count FROM Friend GROUP BY student_id;"
        ]
    },
    "15": {
        "db_id": "concert_singer",
        "question": "What are the locations and names of all stations with capacity between 5000 and 10000?",
        "ground_truth": "SELECT LOCATION ,  name FROM stadium WHERE capacity BETWEEN 5000 AND 10000",
        "amends": [
            "Do reference table `stadium` instead of `stations` in the FROM clause. Do use `BETWEEN 5000 AND 10000` instead of `capacity > 10000 OR capacity < 5000` in the WHERE filter to select capacities within the range rather than outside it. Do capitalize `LOCATION` instead of `location` in the SELECT list while keeping the same column semantics. The amended query now correctly selects stadium locations and names within the specified capacity range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about \"stations\": use the table \"stadium\" instead of \"stations\" as the data source. 2) When filtering for capacity between 5000 and 10000: use the condition \"BETWEEN 5000 AND 10000\" to include both bounds (inclusive range) rather than excluding values outside this range. 3) When selecting location information: use the exact column name \"LOCATION\" (capitalized) instead of \"location\" while maintaining the same semantic meaning."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location, name FROM stations WHERE capacity > 10000 OR capacity < 5000;",
            "SELECT Location, Name FROM stadium WHERE Capacity BETWEEN 5000 AND 10000;"
        ],
        "rule_sql": [
            "SELECT LOCATION, Name FROM stadium WHERE Capacity BETWEEN 5000 AND 10000;"
        ]
    },
    "609": {
        "db_id": "tvshow",
        "question": "What is the TV Channel that shows the cartoon \"The Rise of the Blue Beetle!\"? List the TV Channel's series name.",
        "ground_truth": "SELECT T1.series_name FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Title = \"The Rise of the Blue Beetle!\";",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference `T2.Channel` instead of `cartoon.channel_id` in the join condition. Do reference `T2.Title` instead of `cartoon.title` in the WHERE filter. Do use double quotes around the string literal instead of single quotes. The amended query now correctly joins on the proper column names and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When joining tables tv_channel and cartoon: use table aliases T1 for tv_channel and T2 for cartoon instead of full table names. 2) When linking T1 and T2: match rows where T1.id = T2.Channel (not cartoon.channel_id). 3) When filtering for the cartoon title \"The Rise of the Blue Beetle!\": use T2.Title (not cartoon.title) with double quotes around the literal. 4) When outputting results: return T1.series_name as the TV Channel's series name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT tv_channel.series_name FROM tv_channel JOIN cartoon ON tv_channel.id = cartoon.channel_id WHERE cartoon.title = 'The Rise of the Blue Beetle!'",
            "SELECT T1.series_name FROM TV_Channel T1 JOIN Cartoon T2 ON T1.id = T2.Channel WHERE T2.Title = \"The Rise of the Blue Beetle!\""
        ],
        "rule_sql": [
            "SELECT T1.series_name FROM TV_Channel T1 JOIN Cartoon T2 ON T1.id = T2.Channel WHERE T2.Title = \"The Rise of the Blue Beetle!\""
        ]
    },
    "308": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Count the number of documents that use the PPT template type.",
        "ground_truth": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT'",
        "amends": [
            "Do join `Templates AS T2` on `T1.Template_ID = T2.Template_ID` instead of querying only the `documents` table. Do filter on `T2.Template_Type_Code = 'PPT'` instead of filtering on a non-existent `template_type` column in the documents table. The amended query now correctly counts documents by joining with the Templates table to access the template type code, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"documents that use the PPT template type\": join the documents table (T1) with the Templates table (T2) using the exact key equality T1.Template_ID = T2.Template_ID, keeping only matching pairs (inner match). 2) When filtering for PPT template type: filter on T2.Template_Type_Code = 'PPT' exactly as specified, preserving the exact literal value 'PPT'. 3) When counting documents: compute the number of rows using the canonical key from the documents table after applying the join and filter conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM documents WHERE template_type = 'PPT';",
            "SELECT COUNT(*) \nFROM Documents AS D\nJOIN Templates AS T ON D.Template_ID = T.Template_ID\nWHERE T.Template_Type_Code = 'PPT'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT D.Document_ID) \nFROM Documents D\nINNER JOIN Templates T ON D.Template_ID = T.Template_ID\nWHERE T.Template_Type_Code = 'PPT'"
        ]
    },
    "372": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the ids of documents that have 2 or more paragraphs?",
        "ground_truth": "SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*)  >=  2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id FROM paragraphs GROUP BY document_id HAVING COUNT(paragraph_id) >= 2"
        ],
        "rule_sql": [
            "SELECT Document_ID FROM Paragraphs GROUP BY Document_ID HAVING COUNT(Paragraph_ID) >= 2"
        ]
    },
    "716": {
        "db_id": "world_1",
        "question": "What are the region and population of Angola?",
        "ground_truth": "SELECT Population ,  Region FROM country WHERE Name  =  \"Angola\"",
        "amends": [
            "Do use table name `country` instead of `countries` and column names `Name`, `Population`, and `Region` instead of `name`, `population`, and `region` to match the correct schema. Do use double quotes `\"Angola\"` instead of single quotes `'Angola'` for the string literal in the WHERE filter. The amended query now correctly retrieves the population and region data for Angola from the proper table structure.",
            "Do maintain the same column selection `Region, Population` instead of changing the order, but do reverse the column order in the SELECT list to `Population, Region` instead of `Region, Population`. Do keep the same table source `country` and identical WHERE filter `Name = \"Angola\"` instead of making any changes to these elements. The amended query now correctly matches the RIGHT_SQL's behavior with the specified column ordering."
        ],
        "rules": [
            "1) When the question asks about a country's region and population: use table \"country\" with columns \"Name\", \"Population\", and \"Region\" 2) When filtering for a specific country name: use double quotes around the literal value exactly as shown (e.g., \"Angola\") 3) When selecting output columns: maintain the order of \"Region\" followed by \"Population\" as specified in the question",
            "1) When answering about \"region and population of Angola\": make sure the output order: Population, Region instead of Region, Population. 2) When the question mentions \"Angola\": \"Angola\" actually means \"Name = 'Angola'\" in the country table. 3) When selecting from the country table: use the exact table name \"country\" without quotes as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region, population FROM countries WHERE name = 'Angola';",
            "SELECT Region, Population FROM country WHERE Name = \"Angola\";",
            "SELECT Population, Region FROM country WHERE Name = \"Angola\""
        ],
        "rule_sql": [
            "SELECT Region, Population FROM country WHERE Name = 'Angola';"
        ]
    },
    "707": {
        "db_id": "world_1",
        "question": "How much surface area do the countires in the Carribean cover together?",
        "ground_truth": "SELECT sum(SurfaceArea) FROM country WHERE Region  =  \"Caribbean\"",
        "amends": [
            "Do reference the `SurfaceArea` column instead of `surface_area` to match the correct column name. Do reference the `country` table instead of `countries` to use the correct table name. Do use double quotes around 'Caribbean' instead of single quotes to match the correct string literal format. The amended query now correctly calculates the total surface area for Caribbean countries using the proper table and column references."
        ],
        "rules": [
            "1) When answering about \"surface area of countries in the Caribbean\": use the exact column name \"SurfaceArea\" from the country table. 2) When the question mentions \"Caribbean\": use the exact string literal \"Caribbean\" with double quotes. 3) When calculating total surface area: sum the \"SurfaceArea\" values for all matching rows. 4) When filtering by region: use the condition where region equals \"Caribbean\" to select Caribbean countries."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(surface_area) FROM countries WHERE region = 'Caribbean';",
            "SELECT SUM(SurfaceArea) FROM country WHERE Region = \"Caribbean\";"
        ],
        "rule_sql": [
            "SELECT SUM(SurfaceArea) FROM country WHERE Region = \"Caribbean\";"
        ]
    },
    "25": {
        "db_id": "concert_singer",
        "question": "What is the name and capacity of the stadium with the most concerts after 2013 ?",
        "ground_truth": "select t2.name ,  t2.capacity from concert as t1 join stadium as t2 on t1.stadium_id  =  t2.stadium_id where t1.year  >  2013 group by t2.stadium_id order by count(*) desc limit 1",
        "amends": [
            "Do select `t2.name` and `t2.capacity` from the `stadium` table instead of selecting `name` and `capacity` directly from `stadiums`. Do join `concert` as `t1` with `stadium` as `t2` on `t1.stadium_id = t2.stadium_id` instead of querying only the `stadiums` table. Do add a WHERE filter for `t1.year > 2013` instead of omitting any year condition. Do add GROUP BY on `t2.stadium_id` instead of not grouping. Do order by `count(*)` descending instead of ordering by `concerts_after_2013` descending. The amended query now correctly identifies the stadium with the most concerts after 2013 by joining concert data and counting events per stadium."
        ],
        "rules": [
            "1) When answering about stadium name and capacity: make sure the output order: t2.name, t2.capacity\n2) When the question mentions \"stadium with the most concerts after 2013\": join concert as t1 with stadium as t2 on t1.stadium_id = t2.stadium_id and keep only matching pairs (inner match)\n3) When filtering for concerts after 2013: add a WHERE condition for t1.year > 2013\n4) When counting concerts per stadium: group by t2.stadium_id and count using count(*)\n5) When finding the stadium with the most concerts: order by count(*) descending and keep only the first row"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, capacity FROM stadiums ORDER BY concerts_after_2013 DESC LIMIT 1;",
            "SELECT t2.Name, t2.Capacity\nFROM concert AS t1\nJOIN stadium AS t2 ON t1.Stadium_ID = t2.Stadium_ID\nWHERE t1.Year > '2013'\nGROUP BY t2.Stadium_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t2.Name, t2.Capacity\nFROM concert AS t1\nINNER JOIN stadium AS t2 ON t1.Stadium_ID = t2.Stadium_ID\nWHERE t1.Year > '2013'\nGROUP BY t2.Stadium_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "984": {
        "db_id": "dog_kennels",
        "question": "List the dog name, age and weight of the dogs who have been abandoned? 1 stands for yes, and 0 stands for no.",
        "ground_truth": "SELECT name ,  age ,  weight FROM Dogs WHERE abandoned_yn  =  1",
        "amends": [
            "Do use table name `Dogs` instead of `dogs` to match the correct schema. Do change the filter condition to `abandoned_yn = 1` instead of `abandoned = 0`, using the correct column name and value that properly identifies abandoned dogs. The amended query now correctly selects non-abandoned dogs by checking the abandoned_yn flag set to 1, matching the intended behavior of the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question mentions \"dogs\": use the exact table name \"Dogs\" with capital D as shown in the schema. 2) When identifying abandoned dogs: use the column \"abandoned_yn\" with value 1 (not 0) to properly identify abandoned status. 3) When selecting dog attributes: output the columns \"name\", \"age\", and \"weight\" in that exact order as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, age, weight FROM dogs WHERE abandoned = 0;",
            "SELECT name, age, weight FROM Dogs WHERE abandoned_yn = '1';"
        ],
        "rule_sql": [
            "SELECT name, age, weight FROM Dogs WHERE abandoned_yn = '1';"
        ]
    },
    "986": {
        "db_id": "dog_kennels",
        "question": "What is the average age of all the dogs?",
        "ground_truth": "SELECT avg(age) FROM Dogs",
        "amends": [
            "Do select `avg(age)` instead of `AVG(height)` to calculate the average age rather than height. Do reference the table as `Dogs` instead of `dogs` to match the correct case sensitivity. The amended query now correctly calculates the average age from the Dogs table."
        ],
        "rules": [
            "1) When the question asks for \"average age of all the dogs\": calculate the average of the \"age\" column instead of \"height\". 2) When referencing the table containing dog information: use the exact table name \"Dogs\" with proper case sensitivity as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(height) FROM dogs;",
            "SELECT AVG(age) FROM Dogs;"
        ],
        "rule_sql": [
            "SELECT AVG(age) AS average_age FROM Dogs;"
        ]
    },
    "859": {
        "db_id": "orchestra",
        "question": "Count the number of orchestras that have CD or DVD as their record format.",
        "ground_truth": "SELECT COUNT(*) FROM orchestra WHERE Major_Record_Format  =  \"CD\" OR Major_Record_Format  =  \"DVD\"",
        "amends": [
            "Do reference table `orchestra` instead of `orchestras` and use column `Major_Record_Format` instead of `record_format`. Do use double quotes `\"CD\"` and `\"DVD\"` instead of single quotes for string literals while maintaining the same OR logic for counting records in either format. The amended query now correctly counts records from the orchestra table where Major_Record_Format equals CD or DVD, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"orchestras\": use table \"orchestra\" instead of \"orchestras\". 2) When the question asks about \"record format\": use column \"Major_Record_Format\" instead of \"record_format\". 3) When comparing string literals \"CD\" or \"DVD\": use double quotes \"CD\" and \"DVD\" instead of single quotes. 4) When counting orchestras with CD or DVD format: count rows where \"Major_Record_Format\" equals \"CD\" OR \"Major_Record_Format\" equals \"DVD\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM orchestras WHERE record_format = 'CD' OR record_format = 'DVD';",
            "SELECT COUNT(*) FROM orchestra WHERE \"Major_Record_Format\" = \"CD\" OR \"Major_Record_Format\" = \"DVD\""
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM orchestra WHERE Major_Record_Format = \"CD\" OR Major_Record_Format = \"DVD\""
        ]
    },
    "768": {
        "db_id": "world_1",
        "question": "What is the official language spoken in the country whose head of state is Beatrix?",
        "ground_truth": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.HeadOfState  =  \"Beatrix\" AND T2.IsOfficial  =  \"T\"",
        "amends": [
            "Do select `T2.Language` from the joined table instead of `language` from a single table. Do join `country AS T1` with `countrylanguage AS T2` on `T1.Code = T2.CountryCode` instead of querying only the `countries` table. Do add the filter `T2.IsOfficial = \"T\"` to ensure only official languages are returned instead of omitting this condition. Do use the correct table aliases and column references throughout the query instead of the simplified single-table approach. The amended query now correctly retrieves official languages from the joined tables matching the specified head of state condition."
        ],
        "rules": [
            "1) When answering about \"official language spoken in a country\": make sure the output order: T2.Language. 2) When the question mentions \"head of state is Beatrix\": \"head of state\" actually means \"T1.HeadOfState = 'Beatrix'\" in schema. 3) When combining T1 (country) and T2 (countrylanguage) for shared entities: link rows where T1.Code = T2.CountryCode and keep only matching pairs (inner match). 4) When the question specifies \"official language\": add the filter T2.IsOfficial = \"T\" to ensure only official languages are returned."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT language FROM countries WHERE head_of_state = 'Beatrix';",
            "SELECT T2.Language \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T1.HeadOfState = 'Beatrix' \nAND T2.IsOfficial = 'T'"
        ],
        "rule_sql": [
            "SELECT T2.Language \nFROM country T1 \nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T1.HeadOfState = 'Beatrix' \nAND T2.IsOfficial = 'T'"
        ]
    },
    "208": {
        "db_id": "flight_2",
        "question": "Return the number of flights departing from Aberdeen.",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.SourceAirport  =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"",
        "amends": [
            "Do add `JOIN AIRPORTS AS T2 ON T1.SourceAirport = T2.AirportCode` instead of querying only the `flights` table. Do change the filter to `T2.City = \"Aberdeen\"` instead of `departure_city = 'Aberdeen'` since the city information is stored in the airports table rather than directly in flights. Do use table alias `T1` for flights and `T2` for airports instead of referencing tables without aliases. The amended query now correctly joins the flights and airports tables to count flights departing from Aberdeen by matching airport codes and filtering on the city name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"number of flights departing from Aberdeen\": make sure the output order: count of flights. 2) When the question mentions \"Aberdeen\": \"Aberdeen\" actually means \"T2.City = 'Aberdeen'\" in schema. 3) When combining T1 (flights) and T2 (airports) for shared entities: link rows where T1.SourceAirport = T2.AirportCode exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"count of flights\": compute the number of rows using the canonical key token for flights (T1.SourceAirport or appropriate flight identifier)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE departure_city = 'Aberdeen';",
            "SELECT COUNT(*) FROM flights AS T1 JOIN airports AS T2 ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM flights T1 INNER JOIN airports T2 ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ]
    },
    "300": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the ids, names, and descriptions for all documents?",
        "ground_truth": "SELECT document_id ,  document_name ,  document_description FROM Documents",
        "amends": [
            "Do select `document_id`, `document_name`, and `document_description` instead of `id` and `name`. Do reference the `Documents` table instead of `documents`. The amended query now correctly retrieves all three document fields from the proper table with accurate column names."
        ],
        "rules": [
            "1) When answering about \"ids, names, and descriptions for all documents\": make sure the output order: document_id, document_name, document_description. 2) When the question mentions \"ids\": \"ids\" actually means \"document_id in schema\". 3) When the question mentions \"names\": \"names\" actually means \"document_name in schema\". 4) When the question mentions \"descriptions\": \"descriptions\" actually means \"document_description in schema\". 5) When referring to the documents table: use the exact table name \"Documents\" with proper capitalization."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, name FROM documents;",
            "SELECT Document_ID, Document_Name, Document_Description FROM Documents;"
        ],
        "rule_sql": [
            "SELECT Document_ID, Document_Name, Document_Description FROM Documents ORDER BY Document_ID, Document_Name, Document_Description;"
        ]
    },
    "395": {
        "db_id": "course_teach",
        "question": "List the most common hometown of teachers.",
        "ground_truth": "SELECT Hometown FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do use the table name `teacher` instead of `teachers` and capitalize `Hometown` instead of lowercase `hometown` in both the SELECT list and GROUP BY clause. Do remove the alias `count` from the aggregate function and instead reference `COUNT(*)` directly in the ORDER BY clause instead of using the alias. Do maintain the same GROUP BY and ORDER BY logic but with corrected table name and column capitalization. The amended query now correctly references the actual table schema while preserving the intended behavior of finding the hometown with the highest count of teachers.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, as the query only needs to return the Hometown with the highest count rather than both the Hometown and its count value. The amended query now correctly returns just the Hometown column while maintaining the same GROUP BY, ORDER BY, and LIMIT logic to identify the hometown with the most teachers, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about \"teachers\": use the table name \"teacher\" exactly as specified in the schema. 2) When the question mentions \"hometown\": use the column name \"Hometown\" with exact capitalization as shown in the schema. 3) When counting teachers: count all rows using COUNT(*) and do not use aliases for the count in ORDER BY clauses. 4) When finding the most common value: group by the exact column \"Hometown\", count occurrences, order by the count in descending order, and take only the top result.",
            "1) When the question asks for \"most common hometown of teachers\": identify the hometown with the highest count of teachers. 2) When counting teachers per hometown: count the number of rows using the canonical key for teachers (implied by GROUP BY Hometown). 3) When ranking for \"most common\": order the groups by count in descending order. 4) When selecting only the top result: keep only the first row after ordering. 5) When the output should show only the hometown value: return only the Hometown column without the count value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT hometown, COUNT(*) as count FROM teachers GROUP BY hometown ORDER BY count DESC LIMIT 1;",
            "SELECT Hometown, COUNT(*) FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT Hometown FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Hometown FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "722": {
        "db_id": "world_1",
        "question": "What is the total population and maximum GNP in Asia?",
        "ground_truth": "SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  \"Asia\"",
        "amends": [
            "Do use table name `country` instead of `countries` in the FROM clause. Do remove the column aliases `TotalPopulation` and `MaxGNP` instead of keeping them. Do use lowercase function names `sum` and `max` instead of uppercase `SUM` and `MAX`. Do use double quotes `\"Asia\"` instead of single quotes `'Asia'` for the string literal in the WHERE filter. The amended query now correctly references the proper table and uses consistent function casing while maintaining the same aggregation logic and filtering behavior."
        ],
        "rules": [
            "1) When the question asks about countries: use the exact table name \"country\" instead of \"countries\". 2) When computing aggregates like total population and maximum GNP: use lowercase function names \"sum\" and \"max\" instead of uppercase versions. 3) When filtering for the continent Asia: use double quotes \"Asia\" instead of single quotes for the string literal. 4) When producing output columns: do not use column aliases like \"TotalPopulation\" and \"MaxGNP\" - return the raw aggregate expressions directly."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(Population) AS TotalPopulation, MAX(GNP) AS MaxGNP FROM countries WHERE Continent = 'Asia';",
            "SELECT sum(Population), max(GNP) FROM country WHERE Continent = \"Asia\""
        ],
        "rule_sql": [
            "SELECT sum(Population), max(GNP) FROM country WHERE Continent = \"Asia\""
        ]
    },
    "976": {
        "db_id": "dog_kennels",
        "question": "How much does the most recent treatment cost?",
        "ground_truth": "SELECT cost_of_treatment FROM Treatments ORDER BY date_of_treatment DESC LIMIT 1",
        "amends": [
            "Do select `cost_of_treatment` instead of using `MAX(cost)` aggregation. Do reference table `Treatments` instead of `treatments`. Do order by `date_of_treatment` instead of `date`. Do remove the unnecessary aggregation function and instead directly select the column value while maintaining the same ordering and limiting behavior to retrieve the most recent treatment cost."
        ],
        "rules": [
            "1) When the question asks for the cost of the most recent treatment: select \"cost_of_treatment\" from table \"Treatments\" instead of using MAX(cost) aggregation. 2) When ordering by treatment date to find the most recent: order by \"date_of_treatment\" in descending order instead of \"date\". 3) When retrieving the single most recent treatment: limit the result to 1 row after ordering by \"date_of_treatment\" descending."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(cost) FROM treatments ORDER BY date DESC LIMIT 1;",
            "SELECT cost_of_treatment FROM Treatments ORDER BY date_of_treatment DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT cost_of_treatment FROM Treatments ORDER BY date_of_treatment DESC LIMIT 1;"
        ]
    },
    "104": {
        "db_id": "car_1",
        "question": "What are the different models for the cards produced after 1980?",
        "ground_truth": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;",
        "amends": [
            "Do use `DISTINCT T1.model` instead of just `model` to eliminate duplicates. Do add `MODEL_LIST AS T1` as the main table instead of just `cards`. Do add `JOIN CAR_NAMES AS T2 ON T1.model = T2.model` instead of omitting this join. Do add `JOIN CARS_DATA AS T3 ON T2.MakeId = T3.id` instead of omitting this second join. Do use `T3.year > 1980` instead of `production_year > 1980` to filter on the correct year column from the joined table. The amended query now correctly joins multiple tables to retrieve distinct car models from the appropriate year filter."
        ],
        "rules": [
            "1) When answering about \"different models for the cards produced after 1980\": make sure the output order: T1.model 2) When the question mentions \"different models\": use DISTINCT T1.model to eliminate duplicate model values 3) When the question mentions \"cards produced after 1980\": use T3.year > 1980 to filter on the correct year column from the joined CARS_DATA table 4) When combining MODEL_LIST, CAR_NAMES, and CARS_DATA tables: link rows where T1.model = T2.model and T2.MakeId = T3.id, keeping only matching pairs (inner match) 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table names like MODEL_LIST, CAR_NAMES, and CARS_DATA"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT model FROM cards WHERE production_year > 1980",
            "SELECT DISTINCT T1.Model FROM model_list AS T1 JOIN car_names AS T2 ON T1.Model = T2.Model JOIN cars_data AS T3 ON T2.MakeId = T3.Id WHERE T3.Year > 1980"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Model FROM \"model_list\" T1 INNER JOIN \"car_names\" T2 ON T1.Model = T2.Model INNER JOIN \"cars_data\" T3 ON T2.MakeId = T3.Id WHERE T3.Year > 1980 ORDER BY T1.Model"
        ]
    },
    "536": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the first, middle, and last names for everybody enrolled in a Bachelors program?",
        "ground_truth": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do change the FROM clause to include `Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id = T3.degree_program_id` instead of just `students`. Do change the WHERE filter to `T3.degree_summary_name = 'Bachelor'` instead of `program = 'Bachelors'`. Do add table aliases `T1.` prefix to all columns instead of using unqualified column names. The amended query now correctly filters students enrolled in Bachelor programs through proper table relationships rather than relying on a potentially incorrect program field."
        ],
        "rules": [
            "1) When answering about \"everybody enrolled in a Bachelors program\": make sure the output order: T1.first_name, T1.middle_name, T1.last_name. 2) When the question mentions \"Bachelors program\": \"Bachelors\" actually means \"T3.degree_summary_name = 'Bachelor'\" in schema. 3) When combining tables for student enrollment information: link rows where T1.student_id = T2.student_id and T2.degree_program_id = T3.degree_program_id; keep only matching pairs (inner match). 4) When selecting names from multiple students: use DISTINCT to ensure each person appears only once in the results. 5) When referring to table columns: always use the exact table aliases T1. for Students table columns, T2. for Student_Enrolment table columns, and T3. for Degree_Programs table columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, middle_name, last_name FROM students WHERE program = 'Bachelors';",
            "SELECT DISTINCT T1.first_name, T1.middle_name, T1.last_name\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nJOIN Degree_Programs AS T3 ON T2.degree_program_id = T3.degree_program_id\nWHERE T3.degree_summary_name = 'Bachelor'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.first_name, T1.middle_name, T1.last_name\nFROM Students T1\nINNER JOIN Student_Enrolment T2 ON T1.student_id = T2.student_id\nINNER JOIN Degree_Programs T3 ON T2.degree_program_id = T3.degree_program_id\nWHERE T3.degree_summary_name = 'Bachelor'\nORDER BY T1.first_name, T1.middle_name, T1.last_name;"
        ]
    },
    "134": {
        "db_id": "car_1",
        "question": "What is the car model with the highest mpg ?",
        "ground_truth": "select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit 1;",
        "amends": [
            "Do select `t1.model` from `car_names as t1` instead of `car_model` from `cars`. Do join `cars_data as t2` on `t1.makeid = t2.id` instead of querying a single table without joins. Do order by `t2.mpg` instead of `mpg` to reference the joined table's column. The amended query now correctly joins the necessary tables to retrieve car model information with proper MPG data and matches the right SQL's behavior.",
            "Do remove the `CAST(t2.MPG AS REAL)` expression instead of keeping it, as the `MPG` column is already numeric and doesn't require casting for proper sorting. Do use direct `t2.mpg DESC` ordering instead of the unnecessary cast operation. The amended query now correctly sorts by the numeric MPG values in descending order and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"car model\": use \"t1.model\" from \"car_names as t1\" instead of \"car_model\" from \"cars\". 2) When combining car names with MPG data: join \"car_names as t1\" with \"cars_data as t2\" where \"t1.makeid = t2.id\" and keep only matching pairs (inner match). 3) When ordering by MPG to find the highest value: use \"t2.mpg\" from the joined \"cars_data\" table in descending order. 4) When answering about the highest MPG car model: make sure the output order shows only the top result.",
            "1) When the question asks for the car model with the highest MPG: sort by the numeric MPG column in descending order and keep the first row. 2) When handling the MPG column from the cars_data table: use the exact column name \"MPG\" without casting since it already contains numeric values. 3) When combining car_names and cars_data tables: link rows using the exact join condition t1.MakeId = t2.Id as shown in the schema. 4) When answering about car models: output the Model column from the car_names table as the result."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT car_model FROM cars ORDER BY mpg DESC LIMIT 1;",
            "SELECT t1.Model FROM car_names AS t1 JOIN cars_data AS t2 ON t1.MakeId = t2.Id ORDER BY CAST(t2.MPG AS REAL) DESC LIMIT 1;",
            "SELECT t1.Model FROM car_names AS t1 JOIN cars_data AS t2 ON t1.MakeId = t2.Id ORDER BY t2.MPG DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT t1.Model FROM car_names AS t1 INNER JOIN cars_data AS t2 ON t1.MakeId = t2.Id ORDER BY CAST(t2.MPG AS NUMERIC) DESC LIMIT 1;"
        ]
    },
    "1032": {
        "db_id": "real_estate_properties",
        "question": "Show the property type descriptions of properties belonging to that code.",
        "ground_truth": "SELECT T2.property_type_description FROM Properties AS T1 JOIN Ref_Property_Types AS T2 ON T1.property_type_code  =  T2.property_type_code GROUP BY T1.property_type_code",
        "amends": [
            "Do select `T2.property_type_description` from the joined table instead of directly selecting `property_type_description` from the base table. Do add a `JOIN` with `Ref_Property_Types AS T2` on `T1.property_type_code = T2.property_type_code` instead of querying only the `properties` table. Do use `GROUP BY T1.property_type_code` to aggregate results instead of filtering by `property_code = 'that code'`. Do remove the `WHERE` clause filter entirely instead of keeping the specific property code condition. The amended query now correctly retrieves property type descriptions by joining with the reference table and grouping by type code rather than filtering for a single specific property."
        ],
        "rules": [
            "1) When answering about \"property type descriptions of properties\": make sure the output order: T2.property_type_description 2) When combining T1 (properties) and T2 (Ref_Property_Types) for shared entities: link rows where T1.property_type_code = T2.property_type_code and keep only matching pairs (inner match) 3) When the question says \"per property type code\": organize results by T1.property_type_code and compute requested descriptions per group 4) When the question mentions \"that code\": do not filter by property_code = 'that code' as this is incorrect for grouping by property type"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT property_type_description FROM properties WHERE property_code = 'that code';",
            "SELECT T2.property_type_description \nFROM Properties AS T1\nJOIN Ref_Property_Types AS T2 ON T1.property_type_code = T2.property_type_code\nGROUP BY T1.property_type_code"
        ],
        "rule_sql": [
            "SELECT T2.property_type_description \nFROM Properties T1 \nINNER JOIN Ref_Property_Types T2 ON T1.property_type_code = T2.property_type_code \nGROUP BY T1.property_type_code \nORDER BY T2.property_type_description"
        ]
    },
    "191": {
        "db_id": "flight_2",
        "question": "How many flights do we have?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS",
        "amends": [
            "Do query the `FLIGHTS` table instead of the `passengers` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the FLIGHTS table instead of the passengers table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"how many flights\": make sure to query the \"FLIGHTS\" table instead of the \"passengers\" table. 2) When counting records: use lowercase \"count(*)\" for consistency with the schema requirements."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM passengers;",
            "SELECT count(*) FROM flights;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM flights;"
        ]
    },
    "995": {
        "db_id": "dog_kennels",
        "question": "What are the email, cell phone and home phone of each professional?",
        "ground_truth": "SELECT email_address ,  cell_number ,  home_phone FROM professionals",
        "amends": [
            "Do select `email_address`, `cell_number`, and `home_phone` instead of `email` and `cell_phone`, adding the `home_phone` column instead of omitting it. The amended query now matches the right SQL's behavior by including all three specified columns from the professionals table."
        ],
        "rules": [
            "1) When the question asks for \"email\": use the exact column name \"email_address\" from the Professionals table. 2) When the question asks for \"cell phone\": use the exact column name \"cell_number\" from the Professionals table. 3) When the question asks for \"home phone\": use the exact column name \"home_phone\" from the Professionals table. 4) When answering about \"email, cell phone and home phone of each professional\": make sure the output order: email_address, cell_number, home_phone."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT email, cell_phone FROM professionals;",
            "SELECT email_address, cell_number, home_phone FROM Professionals;"
        ],
        "rule_sql": [
            "SELECT email_address, cell_number, home_phone FROM Professionals;"
        ]
    },
    "360": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Count the number of paragraphs in the document named 'Summer Show'.",
        "ground_truth": "SELECT count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_ID  =  T2.document_ID WHERE T2.document_name  =  'Summer Show'",
        "amends": [
            "Do add a `JOIN` to `Documents AS T2` instead of querying only the `paragraphs` table. Do use the join condition `T1.document_ID = T2.document_ID` instead of missing the table relationship entirely. Do move the filter on `document_name = 'Summer Show'` to the `WHERE` clause applied to the joined `Documents` table instead of incorrectly applying it directly to the `paragraphs` table which lacks that column. The amended query now correctly counts paragraphs by joining to the Documents table to filter by document name, matching the intended behavior."
        ],
        "rules": [
            "1) When counting paragraphs for a specific document: join the paragraphs table (T1) with the Documents table (T2) using the condition T1.document_ID = T2.document_ID to establish the relationship between paragraphs and documents. 2) When filtering by document name 'Summer Show': apply the filter document_name = 'Summer Show' to the Documents table (T2) instead of the paragraphs table, since document_name is a column of Documents. 3) When counting paragraphs: count the number of rows in the paragraphs table (T1) that are linked to documents matching the specified name condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM paragraphs WHERE document_name = 'Summer Show';",
            "SELECT COUNT(*) \nFROM Paragraphs AS T1\nJOIN Documents AS T2 ON T1.Document_ID = T2.Document_ID\nWHERE T2.Document_Name = 'Summer Show'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Paragraphs T1\nJOIN Documents T2 ON T1.Document_ID = T2.Document_ID\nWHERE T2.Document_Name = 'Summer Show'"
        ]
    },
    "396": {
        "db_id": "course_teach",
        "question": "What is the most commmon hometowns for teachers?",
        "ground_truth": "SELECT Hometown FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do reference the table as `teacher` instead of `teachers` to match the correct schema. Do capitalize `Hometown` in both the SELECT list and GROUP BY clause instead of using lowercase `hometown` for consistency with the correct column name. Do remove the alias `count` from the COUNT(*) expression instead of keeping it, as the RIGHT_SQL does not include an alias. Do maintain the same aggregation logic with `COUNT(*)` in the ORDER BY clause instead of referencing the removed alias, ensuring the query correctly orders by the count of records per hometown. The amended query now correctly identifies the hometown with the highest count of teachers by using the proper table name and column casing while preserving the core aggregation and ordering logic.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, as the query only needs to return the Hometown with the highest count rather than both the Hometown and its count value. The amended query now matches RIGHT_SQL's behavior by returning just the single Hometown with the maximum occurrence count."
        ],
        "rules": [
            "1) When answering about \"most common hometowns for teachers\": make sure the output order: Hometown, COUNT(*) 2) When the question mentions \"teachers\": \"teachers\" actually means \"teacher\" in schema 3) When the question mentions \"hometowns\": \"hometowns\" actually means \"Hometown\" in schema 4) When the question asks for \"most common\": rank rows by COUNT(*) in descending direction and keep the first 1 row 5) When the question asks for \"count of teachers\": compute the number of rows using COUNT(*) per Hometown group",
            "1) When the question asks for the most common hometowns for teachers: return only the hometown value with the highest count, not both the hometown and its count. 2) When counting occurrences of hometowns: count the number of teacher records for each distinct hometown value. 3) When ranking by frequency to find the most common: order the results by count in descending order and take only the top result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT hometown, COUNT(*) as count FROM teachers GROUP BY hometown ORDER BY count DESC LIMIT 1;",
            "SELECT Hometown, COUNT(*) FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1",
            "SELECT Hometown FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Hometown FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "572": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the maximum number of times that a course shows up in different transcripts and what is that course's enrollment id?",
        "ground_truth": "SELECT count(*) ,  student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `count(*)` and `student_course_id` instead of `MAX(COUNT(*))` and `enrollment_id`. Do use table `Transcript_Contents` instead of `transcripts`. Do group by `student_course_id` instead of `course_id`. Do remove the incorrect `MAX` aggregation around the count instead of keeping it. The amended query now correctly counts records per student course and returns the highest count with its corresponding student course ID, matching the intended behavior."
        ],
        "rules": [
            "1) When counting occurrences of courses in transcripts: use table \"Transcript_Contents\" instead of \"transcripts\" and count records per \"student_course_id\" instead of \"course_id\". 2) When the question asks for the maximum number of times a course appears: count the number of records for each \"student_course_id\" and find the highest count value. 3) When selecting the enrollment identifier: use \"student_course_id\" instead of \"enrollment_id\" to identify the course enrollment. 4) When grouping for counting: group by \"student_course_id\" to count how many times each student course appears in transcripts. 5) When ordering results: order by the count in descending order to find the maximum occurrence first."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(COUNT(*)), enrollment_id \nFROM transcripts \nGROUP BY course_id \nORDER BY COUNT(*) DESC \nLIMIT 1;",
            "SELECT COUNT(*) AS count, student_course_id \nFROM Transcript_Contents \nGROUP BY student_course_id \nORDER BY count DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS max_count, student_course_id\nFROM Transcript_Contents\nGROUP BY student_course_id\nORDER BY max_count DESC\nLIMIT 1;"
        ]
    },
    "439": {
        "db_id": "wta_1",
        "question": "Find the highest rank of losers in all matches.",
        "ground_truth": "SELECT min(loser_rank) FROM matches",
        "amends": [
            "Do use the `min` aggregate function instead of `max` to calculate the minimum value. Do reference the `loser_rank` column instead of `winner_rank` to analyze the losing player's ranking rather than the winner's ranking. The amended query now correctly identifies the minimum loser rank from the matches table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for the \"highest rank of losers\": use the \"loser_rank\" column from the matches table instead of \"winner_rank\" to analyze losing players. 2) When finding the highest rank (which means the numerically smallest rank value): use the minimum aggregate function instead of maximum to calculate the smallest rank value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(winner_rank) FROM matches;",
            "SELECT MIN(loser_rank) AS highest_rank_of_losers FROM matches;"
        ],
        "rule_sql": [
            "SELECT MIN(loser_rank) AS highest_rank_of_losers FROM matches WHERE loser_rank IS NOT NULL;"
        ]
    },
    "423": {
        "db_id": "museum_visit",
        "question": "Find the name and age of the visitor who bought the most tickets at once.",
        "ground_truth": "SELECT t1.name ,  t1.age FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id ORDER BY t2.num_of_ticket DESC LIMIT 1",
        "amends": [
            "Do select `t1.name` and `t1.age` with explicit table aliases instead of just `name` and `age` without table qualification. Do add `FROM visitor AS t1 JOIN visit AS t2` with an explicit join instead of just `FROM visitors` as a single table. Do use join condition `ON t1.id = t2.visitor_id` to properly relate the tables instead of missing the join entirely. Do order by `t2.num_of_ticket DESC` from the joined visit table instead of `tickets_bought DESC` which doesn't exist in the schema. The amended query now correctly joins the visitor and visit tables to find the visitor with the most tickets purchased, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting columns from multiple tables: always qualify column names with explicit table aliases like t1.name and t1.age instead of unqualified names. 2) When combining visitor and visit information: join tables using visitor AS t1 JOIN visit AS t2 with the exact join condition t1.id = t2.visitor_id to properly relate the tables. 3) When finding the visitor who bought the most tickets: order by t2.num_of_ticket DESC from the visit table instead of using non-existent columns like tickets_bought. 4) When answering about the top visitor by ticket purchases: use LIMIT 1 to return only the single row with the highest number of tickets."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, age FROM visitors ORDER BY tickets_bought DESC LIMIT 1;",
            "SELECT t1.Name, t1.Age\nFROM visitor AS t1\nJOIN visit AS t2 ON t1.ID = t2.visitor_ID\nORDER BY t2.Num_of_Ticket DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t1.Name, t1.Age\nFROM visitor AS t1\nJOIN visit AS t2 ON t1.ID = t2.visitor_ID\nORDER BY t2.Num_of_Ticket DESC\nLIMIT 1;"
        ]
    },
    "750": {
        "db_id": "world_1",
        "question": "What is the number of distinct continents where Chinese is spoken?",
        "ground_truth": "SELECT COUNT( DISTINCT Continent) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"Chinese\"",
        "amends": [
            "Do add `COUNT(DISTINCT Continent)` instead of `COUNT(*)` to count distinct continents rather than all rows. Do add `FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode` instead of just `FROM countrylanguage` to join the country table and access continent data. Do keep `WHERE T2.Language = 'Chinese'` but move it to reference the joined table instead of the standalone table. Do remove the standalone countrylanguage table reference and instead use the joined relationship between country and countrylanguage tables. The amended query now correctly counts distinct continents where Chinese is spoken instead of counting all Chinese language records, matching the intended behavior."
        ],
        "rules": [
            "1) When counting distinct continents where Chinese is spoken: use COUNT(DISTINCT T1.Continent) instead of COUNT(*) to count unique continent values. 2) When accessing continent data from countrylanguage records: join country table as T1 with countrylanguage table as T2 using T1.Code = T2.CountryCode to link language records to their respective countries. 3) When filtering for Chinese language: use WHERE T2.Language = 'Chinese' with exact literal 'Chinese' to identify Chinese language records. 4) When combining country and countrylanguage tables: perform an inner join where T1.Code equals T2.CountryCode to ensure only matching country-language pairs are considered."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM countrylanguage WHERE language = 'Chinese';",
            "SELECT COUNT(DISTINCT T1.Continent) \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = 'Chinese'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.Continent) \nFROM country AS T1 \nINNER JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = 'Chinese'"
        ]
    },
    "422": {
        "db_id": "museum_visit",
        "question": "What is the name of the museum that had no visitor yet?",
        "ground_truth": "SELECT name FROM museum WHERE Museum_ID NOT IN (SELECT museum_id FROM visit)",
        "amends": [
            "Do reference table `museum` instead of `museums` in the FROM clause. Do use a subquery with `NOT IN` condition on `Museum_ID` instead of filtering by `visitor_count = 0`. Do check for absence of records in the `visit` table instead of relying on a potentially incorrect `visitor_count` column. The amended query now correctly identifies museums without any visits by checking the relationship table instead of using a direct count field that may not exist or be accurate."
        ],
        "rules": [
            "1) When the question asks about museums without visitors: use the table \"museum\" instead of \"museums\" in the FROM clause. 2) When checking for museums with no visits: use a subquery with NOT IN condition on Museum_ID to check for absence of records in the \"visit\" table. 3) When identifying museums without any visits: do not rely on a visitor_count column as it may not exist or be accurate; instead check the relationship table \"visit\" for missing Museum_ID references."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM museums WHERE visitor_count = 0;",
            "SELECT Name FROM museum WHERE Museum_ID NOT IN (SELECT Museum_ID FROM visit)"
        ],
        "rule_sql": [
            "SELECT Name FROM museum WHERE Museum_ID NOT IN (SELECT Museum_ID FROM visit)"
        ]
    },
    "706": {
        "db_id": "world_1",
        "question": "What is the total surface area of the countries in the Caribbean region?",
        "ground_truth": "SELECT sum(SurfaceArea) FROM country WHERE Region  =  \"Caribbean\"",
        "amends": [
            "Do reference the `SurfaceArea` column instead of `area` and use the correct table name `country` instead of `countries`. Do use the correct column name `Region` instead of `region` and maintain proper string literal syntax with double quotes instead of single quotes around 'Caribbean'. The amended query now correctly calculates the total surface area for Caribbean countries using the proper schema elements."
        ],
        "rules": [
            "1) When the question asks about \"surface area\": use the exact column name \"SurfaceArea\" from table \"country\" instead of \"area\". 2) When the question refers to \"countries\": use the exact table name \"country\" instead of \"countries\". 3) When the question mentions \"Caribbean region\": use the exact column name \"Region\" instead of \"region\" and the exact string literal 'Caribbean' with single quotes. 4) When calculating total surface area: sum the \"SurfaceArea\" values for rows where \"Region\" equals 'Caribbean'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(area) FROM countries WHERE region = 'Caribbean';",
            "SELECT SUM(SurfaceArea) FROM country WHERE Region = 'Caribbean';"
        ],
        "rule_sql": [
            "SELECT SUM(SurfaceArea) FROM country WHERE Region = 'Caribbean';"
        ]
    },
    "256": {
        "db_id": "flight_2",
        "question": "How many flights land in Aberdeen or Abilene?",
        "ground_truth": "SELECT count(*) FROM Flights AS T1 JOIN Airports AS T2 ON T1.DestAirport  =  T2.AirportCode WHERE T2.city  =  \"Aberdeen\" OR T2.city  =  \"Abilene\"",
        "amends": [
            "Do add `JOIN Airports AS T2 ON T1.DestAirport = T2.AirportCode` instead of querying only the `flights` table. Do change the filter to `T2.city = \"Aberdeen\" OR T2.city = \"Abilene\"` instead of the impossible condition `destination = 'Aberdeen' AND destination = 'Abilene'`. Do use table alias `T1` for `Flights` and `T2` for `Airports` instead of no aliases. The amended query now correctly joins flights with airports and filters by city names instead of attempting to match a single destination to two different values simultaneously, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"flights landing in Aberdeen or Abilene\": make sure to join Flights as T1 with Airports as T2 using T1.DestAirport = T2.AirportCode instead of querying only the flights table. 2) When the question mentions \"Aberdeen\" or \"Abilene\": these city names actually mean T2.city = \"Aberdeen\" OR T2.city = \"Abilene\" in the schema, not destination = 'Aberdeen' AND destination = 'Abilene'. 3) When combining T1 and T2 for shared entities: link rows where T1.DestAirport = T2.AirportCode exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"count of flights\": compute the number of rows using the canonical key for flights."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE destination = 'Aberdeen' AND destination = 'Abilene';",
            "SELECT COUNT(*) FROM flights AS T1 JOIN airports AS T2 ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen' OR T2.City = 'Abilene'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM flights AS T1 \nJOIN airports AS T2 ON T1.DestAirport = T2.AirportCode \nWHERE T2.City = 'Aberdeen' OR T2.City = 'Abilene'"
        ]
    },
    "260": {
        "db_id": "employee_hire_evaluation",
        "question": "Count the number of employees",
        "ground_truth": "SELECT count(*) FROM employee",
        "amends": [
            "Do reference the `employee` table instead of `employees` to match the correct table name. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency with the right SQL. Do remove the `WHERE department = 'Sales'` filter instead of keeping it since the right query counts all employees without department filtering. The amended query now matches the right SQL's behavior of counting all records in the employee table."
        ],
        "rules": [
            "1) When the question asks to count employees: use the table name \"employee\" exactly as specified in the schema, not \"employees\". 2) When counting all records in a table: do not apply any WHERE clause filters unless explicitly specified in the question. 3) When writing SQL functions: use lowercase \"count(*)\" for consistency with the correct SQL dialect shown in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE department = 'Sales';",
            "SELECT count(*) FROM employee"
        ],
        "rule_sql": [
            "SELECT count(*) FROM employee;"
        ]
    },
    "865": {
        "db_id": "network_1",
        "question": "What are the names and grades for each high schooler?",
        "ground_truth": "SELECT name ,  grade FROM Highschooler",
        "amends": [
            "Do reference the table as `Highschooler` instead of `high_schoolers` to match the correct table name. The amended query now correctly selects from the Highschooler table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about high schoolers: use the exact table name \"Highschooler\" instead of \"high_schoolers\". 2) When selecting from the Highschooler table: include all rows without filtering by grade, as the question asks for each high schooler without grade restrictions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, grade FROM high_schoolers WHERE grade > 12;",
            "SELECT name, grade FROM Highschooler;"
        ],
        "rule_sql": [
            "SELECT name, grade FROM Highschooler;"
        ]
    },
    "607": {
        "db_id": "tvshow",
        "question": "List each language and the number of TV Channels using it.",
        "ground_truth": "SELECT LANGUAGE ,  count(*) FROM TV_Channel GROUP BY LANGUAGE",
        "amends": [
            "Do use consistent case `LANGUAGE` instead of mixed case `language` for the column name. Do use consistent table name `TV_Channel` instead of `tv_channels` for the source table. The amended query now correctly counts records by language from the TV_Channel table with consistent naming conventions."
        ],
        "rules": [
            "1) When the question asks for languages and TV channel counts: use the exact column name \"LANGUAGE\" from the TV_Channel table. 2) When counting TV channels per language: count the number of records using the canonical key from the TV_Channel table. 3) When grouping results by language: organize the output by the \"LANGUAGE\" column and compute the count per group. 4) When referring to the source table: use the exact table name \"TV_Channel\" with consistent case as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT language, COUNT(*) FROM tv_channels GROUP BY language;",
            "SELECT LANGUAGE, COUNT(*) AS number_of_channels FROM TV_Channel GROUP BY LANGUAGE;"
        ],
        "rule_sql": [
            "SELECT LANGUAGE, COUNT(id) AS number_of_channels FROM TV_Channel GROUP BY LANGUAGE;"
        ]
    },
    "924": {
        "db_id": "dog_kennels",
        "question": "Which dogs have not cost their owner more than 1000 for treatment ? List the dog names .",
        "ground_truth": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )",
        "amends": [
            "Do use a subquery with `NOT IN` instead of a simple `WHERE` filter. Do add a correlated subquery that selects `dog_id` from the `treatments` table instead of omitting it. Do use `GROUP BY dog_id` and `HAVING sum(cost_of_treatment) > 1000` instead of filtering directly on `treatment_cost`. Do remove the direct column reference `treatment_cost` from the main query instead of keeping it, as the cost calculation now happens in the subquery. The amended query now correctly identifies dogs whose total treatment costs do not exceed 1000 by aggregating costs per dog in the treatments table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about dogs that have not cost more than a specific amount for treatment: use a subquery with NOT IN instead of a simple WHERE filter to identify dogs whose total treatment costs exceed the threshold. 2) When calculating total treatment costs per dog: use GROUP BY dog_id and HAVING sum(cost_of_treatment) > 1000 in the subquery instead of filtering directly on individual treatment costs. 3) When referencing the treatments table: select dog_id from the treatments table in the correlated subquery to properly aggregate costs by dog. 4) When producing the final result: remove direct column references to treatment_cost from the main query since cost calculation now happens in the subquery. 5) When identifying dogs by their canonical key: use dog_id as the counting and grouping key for aggregating treatment costs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM dogs WHERE treatment_cost <= 1000;",
            "SELECT name FROM Dogs WHERE dog_id NOT IN (SELECT dog_id FROM Treatments GROUP BY dog_id HAVING SUM(cost_of_treatment) > 1000)"
        ],
        "rule_sql": [
            "SELECT name \nFROM Dogs \nWHERE dog_id NOT IN (\n    SELECT dog_id \n    FROM Treatments \n    GROUP BY dog_id \n    HAVING SUM(cost_of_treatment) > 1000\n)"
        ]
    },
    "553": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the phone number of the man with the first name Timmothy and the last name Ward?",
        "ground_truth": "SELECT cell_mobile_number FROM Students WHERE first_name  =  'Timmothy' AND last_name  =  'Ward'",
        "amends": [
            "Do select `cell_mobile_number` instead of `phone_number` and query the `Students` table instead of `people`. Do keep the same filter conditions `first_name = 'Timmothy'` and `last_name = 'Ward'` unchanged. The amended query now correctly retrieves the mobile number from the Students table instead of attempting to find a phone number in a non-existent people table, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"phone number\": use the exact column \"cell_mobile_number\" from the Students table instead of \"phone_number\". 2) When querying for a person by name: use the \"Students\" table instead of \"people\" table. 3) When filtering for first name \"Timmothy\": use the exact literal 'Timmothy' with the correct spelling and case. 4) When filtering for last name \"Ward\": use the exact literal 'Ward' with the correct spelling and case."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT phone_number FROM people WHERE first_name = 'Timmothy' AND last_name = 'Ward';",
            "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward';"
        ],
        "rule_sql": [
            "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward';"
        ]
    },
    "118": {
        "db_id": "car_1",
        "question": "What is the average miles per gallon of all the cards with 4 cylinders?",
        "ground_truth": "SELECT avg(mpg) FROM CARS_DATA WHERE Cylinders  =  4;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` to use the correct table name. Do use lowercase `avg` function instead of uppercase `AVG` for consistent function naming. Do maintain the same filter condition `cylinders = 4` without changes. The amended query now correctly references the proper table while preserving the same aggregation logic and filtering behavior."
        ],
        "rules": [
            "1) When answering about \"average miles per gallon of cars with 4 cylinders\": make sure the output order: avg(mpg). 2) When the question mentions \"cars\": \"cars\" actually means \"CARS_DATA\" in schema. 3) When the question mentions \"4 cylinders\": use the exact literal value 4 for the cylinders column filter. 4) When computing averages: use the lowercase avg function for consistent naming."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(mpg) FROM cars WHERE cylinders = 4;",
            "SELECT avg(MPG) FROM cars_data WHERE Cylinders = 4"
        ],
        "rule_sql": [
            "SELECT AVG(MPG) FROM cars_data WHERE Cylinders = 4"
        ]
    },
    "124": {
        "db_id": "car_1",
        "question": "What are the names and ids of all countries with at least one car maker?",
        "ground_truth": "SELECT T1.CountryName ,  T1.CountryId FROM COUNTRIES AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country GROUP BY T1.CountryId HAVING count(*)  >=  1;",
        "amends": [
            "Do select `T1.CountryName` and `T1.CountryId` instead of `name` and `id`. Do add `JOIN CAR_MAKERS AS T2` instead of omitting the table. Do use `ON T1.CountryId = T2.Country` instead of the incorrect `car_makers > 0` filter. Do add `GROUP BY T1.CountryId` instead of omitting grouping. Do move the existence check to `HAVING count(*) >= 1` instead of using `WHERE car_makers > 0`. The amended query now correctly joins the tables and uses proper aggregation to find countries with car makers, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting country information: use T1.CountryName and T1.CountryId as the output columns instead of generic name and id. 2) When checking for countries with car makers: join the CAR_MAKERS table as T2 using the condition T1.CountryId = T2.Country. 3) When grouping results by country: use T1.CountryId as the grouping key. 4) When filtering for countries with at least one car maker: use HAVING count(*) >= 1 instead of a WHERE condition on car_makers."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, id FROM countries WHERE car_makers > 0;",
            "SELECT T1.CountryName, T1.CountryId \nFROM countries AS T1 \nJOIN car_makers AS T2 ON T1.CountryId = T2.Country \nGROUP BY T1.CountryId \nHAVING COUNT(*) >= 1"
        ],
        "rule_sql": [
            "SELECT T1.CountryName, T1.CountryId FROM countries T1 JOIN car_makers T2 ON T1.CountryId = T2.Country GROUP BY T1.CountryId HAVING COUNT(*) >= 1"
        ]
    },
    "597": {
        "db_id": "tvshow",
        "question": "List the number of different series names and contents in the TV Channel table.",
        "ground_truth": "SELECT count(DISTINCT series_name) ,  count(DISTINCT content) FROM TV_Channel;",
        "amends": [
            "Do use `count(DISTINCT series_name)` instead of `COUNT(series_name)` to count unique values rather than all non-null values. Do use `count(DISTINCT content)` instead of `COUNT(contents)` to count distinct values and reference the correct column name `content` instead of `contents`. The amended query now correctly counts distinct series names and distinct content values, matching the intended behavior of the RIGHT_SQL."
        ],
        "rules": [
            "1) When counting different series names: count the number of unique values in the \"series_name\" column using count(DISTINCT series_name). 2) When counting different contents: count the number of unique values in the \"content\" column using count(DISTINCT content) and ensure the exact column name \"content\" is used instead of \"contents\". 3) When answering about number of different series names and contents: make sure the output order shows count of distinct series names first, followed by count of distinct content values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(series_name), COUNT(contents) FROM TV_Channel",
            "SELECT COUNT(DISTINCT series_name), COUNT(DISTINCT content) FROM TV_Channel;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT series_name) AS distinct_series_names, COUNT(DISTINCT Content) AS distinct_contents FROM TV_Channel;"
        ]
    },
    "356": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the ids corresponding to templates with the description 'Presentation'.",
        "ground_truth": "SELECT T2.template_id FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code WHERE T1.template_type_description  =  \"Presentation\"",
        "amends": [
            "Do add `Ref_template_types AS T1` and `Templates AS T2` as joined tables instead of querying only `templates` alone. Do use `JOIN` with `ON T1.template_type_code = T2.template_type_code` instead of no join condition. Do select `T2.template_id` instead of `id`. Do filter on `T1.template_type_description = \"Presentation\"` instead of `description = 'Presentation'`. The amended query now correctly joins reference data to retrieve template IDs by type description instead of directly filtering templates by description."
        ],
        "rules": [
            "1) When answering about templates with description 'Presentation': make sure the output order: T2.template_id. 2) When the question mentions 'templates': use Templates AS T2 as the main entity table. 3) When the question mentions 'description': \"description\" actually means \"template_type_description in Ref_template_types table\". 4) When combining Ref_template_types AS T1 and Templates AS T2 for shared template types: link rows where T1.template_type_code = T2.template_type_code exactly; keep only matching pairs (inner match). 5) When filtering for 'Presentation': use exact literal \"Presentation\" with double quotes for T1.template_type_description."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM templates WHERE description = 'Presentation'",
            "SELECT T2.template_id \nFROM Ref_template_types AS T1 \nJOIN Templates AS T2 ON T1.template_type_code = T2.template_type_code \nWHERE T1.template_type_description = 'Presentation'"
        ],
        "rule_sql": [
            "SELECT T2.Template_ID\nFROM Templates AS T2\nINNER JOIN Ref_Template_Types AS T1 ON T1.Template_Type_Code = T2.Template_Type_Code\nWHERE T1.Template_Type_Description = \"Presentation\"\nORDER BY T2.Template_ID"
        ]
    },
    "416": {
        "db_id": "museum_visit",
        "question": "Find the average number of staff working for the museums that were open before 2009.",
        "ground_truth": "SELECT avg(num_of_staff) FROM museum WHERE open_year  <  2009",
        "amends": [
            "Do use table name `museum` instead of `museums` and column name `num_of_staff` instead of `staff_count` for the aggregate function. Do use column `open_year` instead of `year_opened` in the WHERE filter condition. Do use lowercase `avg` instead of uppercase `AVG` for the aggregate function. The amended query now correctly calculates the average number of staff from the museum table for institutions opened before 2009."
        ],
        "rules": [
            "1) When the question mentions \"museums\": use the exact table name \"museum\" instead of \"museums\". 2) When counting staff for museums: use the exact column name \"num_of_staff\" instead of \"staff_count\" for the aggregate function. 3) When filtering by opening year before 2009: use the exact column name \"open_year\" instead of \"year_opened\" in the filter condition. 4) When calculating the average: use lowercase \"avg\" instead of uppercase \"AVG\" for the aggregate function."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(staff_count) FROM museums WHERE year_opened < 2009;",
            "SELECT avg(Num_of_Staff) FROM museum WHERE Open_Year < '2009'"
        ],
        "rule_sql": [
            "SELECT AVG(Num_of_Staff) FROM museum WHERE Open_Year < '2009';"
        ]
    },
    "587": {
        "db_id": "tvshow",
        "question": "List all cartoon directed by \"Ben Jones\".",
        "ground_truth": "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\";",
        "amends": [
            "Do specify `Title` in the SELECT list instead of using `*` to select all columns. Do reference the table as `Cartoon` instead of `cartoons` in the FROM clause. Do use the column name `Directed_by` instead of `director` in the WHERE filter. Do use double quotes around the string literal \"Ben Jones\" instead of single quotes. The amended query now correctly retrieves only the Title column from the Cartoon table where Directed_by equals Ben Jones, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks to list cartoons: select only the \"Title\" column instead of all columns. 2) When referencing the cartoon table: use the exact table name \"Cartoon\" with proper casing. 3) When filtering by director: use the exact column name \"Directed_by\" instead of \"director\". 4) When matching the director name \"Ben Jones\": use double quotes around the literal \"Ben Jones\" instead of single quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM cartoons WHERE director = 'Ben Jones';",
            "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\";"
        ],
        "rule_sql": [
            "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\";"
        ]
    },
    "787": {
        "db_id": "world_1",
        "question": "Return the different names of cities that are in Asia and for which Chinese is the official language.",
        "ground_truth": "SELECT DISTINCT T3.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode JOIN city AS T3 ON T1.Code  =  T3.CountryCode WHERE T2.IsOfficial  =  'T' AND T2.Language  =  'Chinese' AND T1.Continent  =  \"Asia\"",
        "amends": [
            "Do select `DISTINCT T3.Name` instead of `city_name` to return unique city names. Do join three tables `country AS T1`, `countrylanguage AS T2`, and `city AS T3` instead of querying only `cities` table. Do use `JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode` with condition `T2.IsOfficial = 'T'` instead of filtering by `official_language = 'Chinese'` to properly identify official languages. Do add `JOIN city AS T3 ON T1.Code = T3.CountryCode` to connect cities to countries instead of assuming city table contains all necessary data. Do filter with `T1.Continent = 'Asia'` instead of `continent = 'Asia'` to use the correct table's continent field. Do add condition `T2.Language = 'Chinese'` to specifically filter for Chinese language instead of relying on a single language filter. The amended query now correctly identifies Asian cities where Chinese is an official language by properly joining country, language, and city tables with appropriate filtering conditions."
        ],
        "rules": [
            "1) When answering about cities in Asia with Chinese as official language: join three tables using country as T1, countrylanguage as T2, and city as T3. 2) When combining T1 and T2: link rows where T1.Code = T2.CountryCode and T2.IsOfficial = 'T' to identify official languages. 3) When combining T1 and T3: link rows where T1.Code = T3.CountryCode to connect cities to countries. 4) When filtering for Asian countries: use T1.Continent = 'Asia' to identify Asian countries. 5) When filtering for Chinese language: use T2.Language = 'Chinese' to specifically identify Chinese language. 6) When returning city names: select DISTINCT T3.Name to return unique city names instead of city_name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city_name FROM cities WHERE continent = 'Asia' AND official_language = 'Chinese';",
            "SELECT DISTINCT T3.Name \nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nJOIN city AS T3 ON T1.Code = T3.CountryCode\nWHERE T1.Continent = 'Asia' \nAND T2.Language = 'Chinese' \nAND T2.IsOfficial = 'T'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T3.Name\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode AND T2.IsOfficial = 'T'\nJOIN city AS T3 ON T1.Code = T3.CountryCode\nWHERE T1.Continent = 'Asia'\nAND T2.Language = 'Chinese'"
        ]
    },
    "728": {
        "db_id": "world_1",
        "question": "How many people live in Gelderland district?",
        "ground_truth": "SELECT sum(Population) FROM city WHERE District  =  \"Gelderland\"",
        "amends": [
            "Do use `sum(Population)` instead of `COUNT(*)` to aggregate population values rather than counting rows. Do reference table `city` instead of `people` as the data source. Do use double quotes `\"Gelderland\"` instead of single quotes for the district filter value. The amended query now correctly calculates the total population in the Gelderland district rather than counting records."
        ],
        "rules": [
            "1) When answering about population count: use sum(\"Population\") instead of COUNT(*) to aggregate population values. 2) When the question mentions \"people\": the data actually comes from table \"city\" instead of \"people\". 3) When filtering for district values: use double quotes \"Gelderland\" instead of single quotes for the exact literal value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM people WHERE district = 'Gelderland';",
            "SELECT SUM(Population) FROM city WHERE District = \"Gelderland\";"
        ],
        "rule_sql": [
            "SELECT SUM(\"Population\") FROM city WHERE District = \"Gelderland\";"
        ]
    },
    "794": {
        "db_id": "world_1",
        "question": "Find the number of cities in each district whose population is greater than the average population of cities?",
        "ground_truth": "SELECT count(*) ,  District FROM city WHERE Population  >  (SELECT avg(Population) FROM city) GROUP BY District",
        "amends": [
            "Do use `count(*)` without an alias instead of `COUNT(*) AS city_count`. Do capitalize `District` in the SELECT list instead of lowercase `district`. Do capitalize `Population` in the WHERE clause instead of lowercase `population`. Do capitalize `avg(Population)` in the subquery instead of `AVG(population)`. Do capitalize `District` in the GROUP BY clause instead of lowercase `district`. The amended query now correctly matches the RIGHT_SQL's behavior with proper column capitalization and alias handling.",
            "Do place `count(*)` before `District` in the SELECT list instead of having `District` first. Do use lowercase `avg(Population)` in the subquery instead of uppercase `AVG(Population)`. Do maintain the same WHERE filter using `Population >` with the subquery calculating the average population, and preserve the GROUP BY `District` clause. The amended query now correctly returns the count of cities by district where population exceeds the average, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"number of cities in each district\": organize results by the exact token \"District\" and compute the count of cities per group. 2) When the question mentions \"population is greater than the average population\": filter rows where the exact token \"Population\" is greater than the average value of \"Population\" across all cities. 3) When counting cities: use count(*) without an alias to count the number of rows. 4) When referring to column identifiers: capitalize \"District\" in both SELECT and GROUP BY clauses, and capitalize \"Population\" in both WHERE clause and subquery.",
            "1) When answering about \"number of cities in each district whose population is greater than average\": make sure the output order: count(*) first, then District. 2) When calculating average population: use lowercase avg(Population) instead of uppercase AVG(Population). 3) When filtering cities by population: use Population > (subquery calculating average population) to find cities with population greater than the average. 4) When grouping results by district: use GROUP BY District to organize counts per district."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT district, COUNT(*) AS city_count\nFROM city\nWHERE population > (SELECT AVG(population) FROM city)\nGROUP BY district;",
            "SELECT District, COUNT(*) FROM city WHERE Population > (SELECT AVG(Population) FROM city) GROUP BY District;",
            "SELECT count(*), District FROM city WHERE Population > (SELECT avg(Population) FROM city) GROUP BY District"
        ],
        "rule_sql": [
            "SELECT count(*), District FROM city WHERE Population > (SELECT avg(Population) FROM city) GROUP BY District"
        ]
    },
    "311": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the id and type code for the template used by the most documents?",
        "ground_truth": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `Documents` and `Templates` tables with an `INNER JOIN` on `template_id` instead of querying only the `templates` table. Do select `T1.template_id` and `T2.Template_Type_Code` instead of `template_id` and `type_code`. Do add `GROUP BY T1.template_id` instead of omitting grouping. Do use `count(*)` for ordering instead of `COUNT(document_id)`. The amended query now correctly aggregates document counts per template and retrieves the corresponding template type code, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"template used by the most documents\": make sure the output order: T1.template_id, T2.Template_Type_Code. 2) When the question mentions \"type code\": \"type code\" actually means \"Template_Type_Code in schema\". 3) When combining Documents (T1) and Templates (T2) tables: link rows where T1.template_id = T2.template_id and keep only matching pairs (inner match). 4) When the question asks for \"most documents\": rank rows by count(*) in descending direction and keep the first 1 row. 5) When the question asks for count of documents per template: compute the number of rows using count(*) per T1.template_id group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_id, type_code FROM templates ORDER BY COUNT(document_id) DESC LIMIT 1;",
            "SELECT T1.Template_ID, T2.Template_Type_Code\nFROM Documents T1\nINNER JOIN Templates T2 ON T1.Template_ID = T2.Template_ID\nGROUP BY T1.Template_ID\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Template_ID, T2.Template_Type_Code\nFROM Documents T1\nINNER JOIN Templates T2 ON T1.Template_ID = T2.Template_ID\nGROUP BY T1.Template_ID, T2.Template_Type_Code\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "499": {
        "db_id": "battle_death",
        "question": "What are the ids and names of the battles that led to more than 10 people killed in total.",
        "ground_truth": "SELECT T1.id ,  T1.name FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle JOIN death AS T3 ON T2.id  =  T3.caused_by_ship_id GROUP BY T1.id HAVING sum(T3.killed)  >  10",
        "amends": [
            "Do select `T1.id` and `T1.name` instead of `battle_id` and `battle_name`. Do use `FROM battle AS T1` with joins to `ship AS T2` and `death AS T3` instead of just `FROM battles`. Do add `JOIN ship AS T2 ON T1.id = T2.lost_in_battle` and `JOIN death AS T3 ON T2.id = T3.caused_by_ship_id` instead of no joins. Do add `GROUP BY T1.id` instead of omitting grouping. Do move the filter to `HAVING sum(T3.killed) > 10` instead of `WHERE killed > 10` to properly aggregate deaths per battle. The amended query now correctly calculates total deaths per battle by joining through ship relationships and aggregates the sum before filtering."
        ],
        "rules": [
            "1) When selecting battle identifiers and names: use \"T1.id\" and \"T1.name\" instead of \"battle_id\" and \"battle_name\". 2) When calculating total deaths per battle: join \"battle AS T1\" with \"ship AS T2\" using \"T1.id = T2.lost_in_battle\" and then join with \"death AS T3\" using \"T2.id = T3.caused_by_ship_id\" to establish the relationship chain. 3) When aggregating deaths across multiple ships: group the results by \"T1.id\" to get per-battle totals. 4) When filtering for battles with more than 10 total deaths: apply the condition \"sum(T3.killed) > 10\" after aggregation using HAVING instead of WHERE."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT battle_id, battle_name FROM battles WHERE killed > 10;",
            "SELECT T1.id, T1.name\nFROM battle AS T1\nJOIN ship AS T2 ON T1.id = T2.lost_in_battle\nJOIN death AS T3 ON T2.id = T3.caused_by_ship_id\nGROUP BY T1.id\nHAVING SUM(T3.killed) > 10"
        ],
        "rule_sql": [
            "SELECT T1.id, T1.name\nFROM battle AS T1\nJOIN ship AS T2 ON T1.id = T2.lost_in_battle\nJOIN death AS T3 ON T2.id = T3.caused_by_ship_id\nGROUP BY T1.id\nHAVING SUM(T3.killed) > 10"
        ]
    },
    "296": {
        "db_id": "employee_hire_evaluation",
        "question": "Count the number of distinct store locations.",
        "ground_truth": "SELECT count(DISTINCT LOCATION) FROM shop",
        "amends": [
            "Do count `DISTINCT LOCATION` instead of counting `store_id`. Do use table `shop` instead of table `stores`. Do remove the incorrect aggregate function that counted non-unique store identifiers instead of counting distinct location values. The amended query now correctly counts unique locations from the shop table instead of attempting to count store IDs from a non-existent stores table, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks to count distinct store locations: use the exact column token \"LOCATION\" from the shop table. 2) When counting distinct values: compute the number of unique values of the exact token \"LOCATION\". 3) When the schema specifies table \"shop\": use table \"shop\" instead of any other table name like \"stores\". 4) When answering about \"number of distinct store locations\": make sure the output order: count of distinct LOCATION values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(store_id) FROM stores;",
            "SELECT COUNT(DISTINCT Location) FROM shop;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Location) FROM shop;"
        ]
    },
    "534": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the first, middle, and last names, along with the ids, of all students who enrolled in 2 degree programs in one semester?",
        "ground_truth": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2",
        "amends": [
            "Do use `T1.student_id` instead of `s.id` in the SELECT list and GROUP BY clause. Do reference `Student_Enrolment AS T2` instead of `enrollments e` as the joined table. Do use `count(*) = 2` instead of `COUNT(DISTINCT e.degree_program_id) = 2` in the HAVING clause to count enrollment records rather than distinct degree programs. Do remove the `DISTINCT` modifier from the count aggregation instead of including it. The amended query now correctly counts the number of enrollment records per student rather than distinct degree programs, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about students who enrolled in 2 degree programs: use T1.student_id instead of s.id in both SELECT list and GROUP BY clause. 2) When joining with enrollment data: reference Student_Enrolment as T2 instead of enrollments e. 3) When counting enrollment records per student: use count(*) = 2 instead of COUNT(DISTINCT e.degree_program_id) = 2 to count enrollment records rather than distinct degree programs. 4) When aggregating enrollment counts: remove the DISTINCT modifier from the count aggregation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.first_name, s.middle_name, s.last_name, s.id\nFROM students s\nJOIN enrollments e ON s.id = e.student_id\nGROUP BY s.id\nHAVING COUNT(DISTINCT e.degree_program_id) = 2;",
            "SELECT s.first_name, s.middle_name, s.last_name, s.student_id\nFROM Students s\nJOIN Student_Enrolment T2 ON s.student_id = T2.student_id\nGROUP BY s.student_id, s.first_name, s.middle_name, s.last_name\nHAVING count(*) = 2"
        ],
        "rule_sql": [
            "SELECT s.first_name, s.middle_name, s.last_name, T1.student_id\nFROM Students s\nJOIN Student_Enrolment T1 ON s.student_id = T1.student_id\nGROUP BY T1.student_id\nHAVING count(*) = 2"
        ]
    },
    "586": {
        "db_id": "tvshow",
        "question": "What are the titles of the cartoons sorted alphabetically?",
        "ground_truth": "SELECT Title FROM Cartoon ORDER BY title",
        "amends": [
            "Do reference the table as `Cartoon` instead of `cartoons` and use the column name `Title` instead of `title` in the SELECT clause. Do remove the `DESC` modifier from the `ORDER BY title` clause instead of keeping descending order. The amended query now correctly references the proper table and column names while maintaining ascending order by default."
        ],
        "rules": [
            "1) When answering about \"titles of the cartoons sorted alphabetically\": make sure the output order: \"Title\" in ascending alphabetical order. 2) When the question mentions \"cartoons\": \"cartoons\" actually means table \"Cartoon\" in schema. 3) When the question mentions \"titles\": \"titles\" actually means column \"Title\" in table \"Cartoon\". 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table \"Cartoon\" and column \"Title\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM cartoons ORDER BY title DESC;",
            "SELECT Title FROM Cartoon ORDER BY Title;"
        ],
        "rule_sql": [
            "SELECT \"Title\" FROM \"Cartoon\" ORDER BY \"Title\" ASC;"
        ]
    },
    "1014": {
        "db_id": "singer",
        "question": "Please show the most common citizenship of singers.",
        "ground_truth": "SELECT Citizenship FROM singer GROUP BY Citizenship ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do use `Citizenship` instead of `citizenship` for the column name and change the table reference to `singer` instead of `singers`. Do order by `COUNT(*) DESC` instead of `count ASC` to find the most common citizenship rather than the least common. Do remove the alias `count` from the SELECT clause instead of keeping it since it's not needed in the final output. Do maintain the `GROUP BY Citizenship` and `LIMIT 1` structure to return the single most frequent citizenship value. The amended query now correctly identifies the most common citizenship among singers rather than the least common."
        ],
        "rules": [
            "1) When the question asks about \"citizenship\": use the exact column name \"Citizenship\" from the singer table. 2) When the question asks for \"most common\": order by the count in descending direction to find the highest frequency. 3) When grouping by citizenship: use \"GROUP BY Citizenship\" to organize results by citizenship values. 4) When limiting to the single most common result: use \"LIMIT 1\" to return only the top result. 5) When counting occurrences: use COUNT(*) to count all rows per citizenship group. 6) When producing output: return only the citizenship value without any count alias in the final output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT citizenship, COUNT(*) as count FROM singers GROUP BY citizenship ORDER BY count ASC LIMIT 1;",
            "SELECT Citizenship FROM singer GROUP BY Citizenship ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Citizenship FROM singer GROUP BY Citizenship ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "1012": {
        "db_id": "singer",
        "question": "Show different citizenship of singers and the number of singers of each citizenship.",
        "ground_truth": "SELECT Citizenship ,  COUNT(*) FROM singer GROUP BY Citizenship",
        "amends": [
            "Do reference the `Citizenship` column instead of `citizenship` to match the correct column name. Do group by `Citizenship` instead of `singer_id` to properly aggregate counts by citizenship rather than by individual singers. Do reference the `singer` table instead of `singers` to use the correct table name. The amended query now correctly counts singers grouped by their citizenship rather than producing counts per individual singer ID."
        ],
        "rules": [
            "1) When the question asks about \"citizenship\": use the exact column name \"Citizenship\" from the singer table. 2) When counting singers per citizenship: group by \"Citizenship\" and count using the canonical key for singers. 3) When the question asks for \"number of singers\": compute the count of singers grouped by their citizenship values. 4) When referencing the table containing singer information: use the exact table name \"singer\" (not \"singers\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT citizenship, COUNT(*) FROM singers GROUP BY singer_id;",
            "SELECT Citizenship, COUNT(*) AS Number_of_Singers FROM singer GROUP BY Citizenship;"
        ],
        "rule_sql": [
            "SELECT Citizenship, COUNT(Singer_ID) AS Number_of_Singers FROM singer GROUP BY Citizenship;"
        ]
    },
    "879": {
        "db_id": "network_1",
        "question": "Return the grade that has the greatest number of high schoolers.",
        "ground_truth": "SELECT grade FROM Highschooler GROUP BY grade ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use `GROUP BY grade` instead of omitting it, as aggregation requires grouping by non-aggregated columns. Do move the `COUNT(*)` aggregate to the `ORDER BY` clause instead of placing it in the `SELECT` list without grouping. Do maintain the `DESC` ordering and `LIMIT 1` to find the grade with the highest count of students. The amended query now correctly groups by grade before counting and ordering, matching the intended behavior of finding the most common grade level."
        ],
        "rules": [
            "1) When answering about \"the grade that has the greatest number of high schoolers\": organize results by the token for grade and compute the count of students per group. 2) When counting students: compute the number of rows using the canonical counting method (COUNT(*)). 3) When the question mentions \"greatest number\" or \"highest count\": rank rows by the count in descending order and keep only the first row (top result). 4) When producing output: make sure the output order includes only the grade column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT grade FROM high_schoolers ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT grade FROM Highschooler GROUP BY grade ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT grade FROM Highschooler GROUP BY grade ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "194": {
        "db_id": "flight_2",
        "question": "Give the airline with abbreviation 'UAL'.",
        "ground_truth": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  \"UAL\"",
        "amends": [
            "Do specify `Airline` column instead of `*` wildcard in the SELECT list. Do use table name `AIRLINES` instead of `airlines` with proper casing. Do use double quotes `\"UAL\"` instead of single quotes `'UAL'` for the string literal. Do maintain the same WHERE filter condition on `Abbreviation` column with proper casing instead of lowercase `abbreviation`. The amended query now correctly returns only the Airline column for United Airlines instead of all columns, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"airline with abbreviation 'UAL'\": make sure the output order: \"Airline\" column. 2) When the question mentions \"airline with abbreviation 'UAL'\": use table name \"AIRLINES\" with proper casing. 3) When filtering for abbreviation value: use double quotes \"UAL\" instead of single quotes for the string literal. 4) When filtering on abbreviation column: use column name \"Abbreviation\" with proper casing instead of lowercase. 5) When selecting columns: specify \"Airline\" column explicitly instead of using wildcard *."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM airlines WHERE abbreviation = 'UAL';",
            "SELECT Airline FROM AIRLINES WHERE Abbreviation = \"UAL\""
        ],
        "rule_sql": [
            "SELECT Airline FROM AIRLINES WHERE Abbreviation = \"UAL\""
        ]
    },
    "280": {
        "db_id": "employee_hire_evaluation",
        "question": "Which employee received the biggest bonus? Give me the employee name.",
        "ground_truth": "SELECT t1.name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID  =  t2.Employee_ID ORDER BY t2.bonus DESC LIMIT 1",
        "amends": [
            "Do select `t1.name` from the `employee` table instead of `employee_name` from `employees`. Do add a `JOIN` with the `evaluation` table on `t1.Employee_ID = t2.Employee_ID` instead of querying a single table. Do order by `t2.bonus` instead of just `bonus` to specify the table source. The amended query now correctly joins employee and evaluation tables to access bonus data and returns the expected result matching RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"which employee received the biggest bonus\": make sure the output order: t1.name. 2) When the question mentions \"employee name\": \"employee name\" actually means \"t1.name in schema\". 3) When the question mentions \"biggest bonus\": rank rows by t2.bonus in descending direction and keep the first 1 row. 4) When combining employee and evaluation tables for shared entities: link rows where t1.Employee_ID = t2.Employee_ID exactly as shown; keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT employee_name FROM employees ORDER BY bonus DESC LIMIT 1;",
            "SELECT t1.Name \nFROM employee t1\nJOIN evaluation t2 ON t1.Employee_ID = t2.Employee_ID\nORDER BY t2.Bonus DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t1.Name\nFROM employee t1\nINNER JOIN evaluation t2 ON t1.Employee_ID = t2.Employee_ID\nORDER BY t2.Bonus DESC\nLIMIT 1"
        ]
    },
    "331": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Which template type code has most number of templates?",
        "ground_truth": "SELECT template_type_code FROM Templates GROUP BY template_type_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `template_type_code` instead of including `COUNT(*) as template_count` in the SELECT list. Do order by `count(*) DESC` instead of `template_count ASC` to find the most frequent template type. Do remove the alias `template_count` from the ORDER BY clause since it's no longer selected. The amended query now correctly identifies the template type with the highest count by ordering in descending order by the count aggregation."
        ],
        "rules": [
            "1) When answering about \"which template type code has most number of templates\": make sure the output order includes only template_type_code. 2) When counting templates: compute the number of rows using the count(*) function. 3) When the question mentions \"most number\" or \"highest count\": rank rows by count(*) in descending order and keep the first 1 row. 4) When grouping by template_type_code: organize results by template_type_code and compute count(*) per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code, COUNT(*) as template_count FROM templates GROUP BY template_type_code ORDER BY template_count ASC LIMIT 1;",
            "SELECT Template_Type_Code\nFROM Templates\nGROUP BY Template_Type_Code\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Template_Type_Code\nFROM Templates\nGROUP BY Template_Type_Code\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "711": {
        "db_id": "world_1",
        "question": "What region is Kabul in?",
        "ground_truth": "SELECT Region FROM country AS T1 JOIN city AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Name  =  \"Kabul\"",
        "amends": [
            "Do select `Region` from table `country` instead of `region` from table `cities`. Do join table `city` with `country` using `ON T1.Code = T2.CountryCode` instead of querying only the `cities` table. Do filter on `T2.Name = \"Kabul\"` instead of `name = 'Kabul'`. Do use proper table aliases `T1` and `T2` instead of no aliases. The amended query now correctly retrieves the region from the country table by joining with the city table to find Kabul's corresponding country code."
        ],
        "rules": [
            "1) When the question asks about a city's region: retrieve the \"Region\" column from table \"country\" (T1) instead of from table \"cities\". 2) When joining tables for city-country relationships: link table \"city\" (T2) with table \"country\" (T1) using the condition T1.Code = T2.CountryCode. 3) When filtering for a specific city name: use the exact literal \"Kabul\" with the column T2.Name instead of 'Kabul' with name. 4) When using table aliases: assign T1 to table \"country\" and T2 to table \"city\" consistently throughout the query."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT region FROM cities WHERE name = 'Kabul';",
            "SELECT T1.Region FROM country T1 JOIN city T2 ON T1.Code = T2.CountryCode WHERE T2.Name = 'Kabul'"
        ],
        "rule_sql": [
            "SELECT T1.Region FROM country T1 JOIN city T2 ON T1.Code = T2.CountryCode WHERE T2.Name = 'Kabul';"
        ]
    },
    "869": {
        "db_id": "network_1",
        "question": "Return the grade for the high schooler named Kyle.",
        "ground_truth": "SELECT grade FROM Highschooler WHERE name  =  \"Kyle\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT grade FROM Highschooler WHERE name = 'Kyle';"
        ],
        "rule_sql": [
            "SELECT grade FROM Highschooler WHERE name = 'Kyle';"
        ]
    },
    "461": {
        "db_id": "wta_1",
        "question": "Find the year that has the most number of matches.",
        "ground_truth": "SELECT YEAR FROM matches GROUP BY YEAR ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `YEAR` instead of both `year` and `COUNT(*) as match_count`. Do order by `count(*) DESC` instead of `match_count ASC` to find the year with the most matches rather than the fewest. The amended query now correctly identifies the year with the highest match count by ordering in descending order and returns only the year column as specified."
        ],
        "rules": [
            "1) When answering about \"the year that has the most number of matches\": make sure the output order includes only the \"year\" column. 2) When the question asks for \"most number of matches\": rank rows by count of matches in descending order and keep the first 1 row. 3) When counting matches: compute the number of rows using the canonical key for matches (year)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, COUNT(*) as match_count FROM matches GROUP BY year ORDER BY match_count ASC LIMIT 1;",
            "SELECT year FROM matches GROUP BY year ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT year FROM matches GROUP BY year ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "735": {
        "db_id": "world_1",
        "question": "How many different forms of governments are there in Africa?",
        "ground_truth": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  \"Africa\"",
        "amends": [
            "Do use `count(DISTINCT GovernmentForm)` instead of `COUNT(*)` to count distinct government forms rather than all rows. Do reference table `country` instead of `countries` as the correct table name. Do use column `Continent` instead of `continent` with proper capitalization. Do use double quotes `\"Africa\"` instead of single quotes for the string literal. Do remove the unnecessary aggregation of all rows and instead count distinct government forms specifically for African countries."
        ],
        "rules": [
            "1) When answering about \"different forms of governments in Africa\": count distinct values of \"GovernmentForm\" instead of counting all rows. 2) When the question mentions \"Africa\": use the exact literal \"Africa\" with double quotes for comparison. 3) When referring to the table containing country data: use table name \"country\" instead of \"countries\". 4) When accessing the continent column: use exact column name \"Continent\" with proper capitalization. 5) When counting distinct government forms: apply the count to \"GovernmentForm\" column specifically for rows where \"Continent\" equals \"Africa\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE continent = 'Africa';",
            "SELECT COUNT(DISTINCT GovernmentForm) FROM country WHERE Continent = \"Africa\";"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT GovernmentForm) FROM country WHERE Continent = 'Africa';"
        ]
    },
    "967": {
        "db_id": "dog_kennels",
        "question": "Count the number of dogs that went through a treatment.",
        "ground_truth": "SELECT count(DISTINCT dog_id) FROM Treatments",
        "amends": [
            "Do count `DISTINCT dog_id` instead of `COUNT(*)` to count unique dogs rather than all treatment records. Do source from `Treatments` table instead of `dogs` table to access the correct treatment data. Do remove the `WHERE treatment = 'yes'` filter instead of keeping it since the count should include all treatments regardless of status. The amended query now correctly counts distinct dogs that have received treatments rather than counting all treatment records, matching the intended behavior."
        ],
        "rules": [
            "1) When counting the number of dogs that went through treatment: count distinct \"dog_id\" values from the \"Treatments\" table instead of counting all rows. 2) When accessing treatment data: use the \"Treatments\" table as the source instead of the \"dogs\" table. 3) When filtering treatment records: do not apply any status filter (remove WHERE treatment = 'yes') to include all treatments regardless of status."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM dogs WHERE treatment = 'yes';",
            "SELECT COUNT(DISTINCT dog_id) FROM Treatments;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT dog_id) FROM Treatments;"
        ]
    },
    "603": {
        "db_id": "tvshow",
        "question": "How many TV Channel using language English?",
        "ground_truth": "SELECT count(*) FROM TV_Channel WHERE LANGUAGE = \"English\";",
        "amends": [
            "Do use table name `TV_Channel` instead of `tv_channels` to reference the correct table. Do use double quotes `\"English\"` instead of single quotes `'English'` for the string literal, though this may be database-specific. The amended query now correctly counts records from the TV_Channel table where the language is English, matching the intended behavior."
        ],
        "rules": [
            "1) When referencing the TV Channel table: use the exact table name \"TV_Channel\" instead of \"tv_channels\". 2) When filtering for language \"English\": use the exact string literal \"English\" with double quotes instead of single quotes. 3) When counting TV channels using English language: count all records from the \"TV_Channel\" table where the \"language\" column equals \"English\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM tv_channels WHERE language = 'English';",
            "SELECT COUNT(*) FROM \"TV_Channel\" WHERE \"Language\" = \"English\";"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM \"TV_Channel\" WHERE \"Language\" = \"English\";"
        ]
    },
    "434": {
        "db_id": "wta_1",
        "question": "What are the first names and birth dates of players from the USA?",
        "ground_truth": "SELECT first_name ,  birth_date FROM players WHERE country_code  =  'USA'",
        "amends": [
            "Do use `country_code` instead of `country` in the WHERE filter. Do filter for `'USA'` instead of `'Canada'` as the country condition. The amended query now correctly filters by country_code for USA instead of using country for Canada."
        ],
        "rules": [
            "1) When the question mentions \"USA\": use the exact literal value 'USA' for filtering. 2) When filtering by country: use the column \"country_code\" instead of \"country\" from the players table. 3) When answering about players from the USA: make sure the output order: first_name, birth_date."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, birth_date FROM players WHERE country = 'Canada';",
            "SELECT first_name, birth_date FROM players WHERE country_code = 'USA';"
        ],
        "rule_sql": [
            "SELECT first_name, birth_date FROM players WHERE country_code = 'USA' ORDER BY first_name, birth_date;"
        ]
    },
    "143": {
        "db_id": "car_1",
        "question": "How many cars have more than 4 cylinders?",
        "ground_truth": "SELECT count(*) FROM CARS_DATA WHERE Cylinders  >  4;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` in the FROM clause. Do change the WHERE filter to `Cylinders > 4` instead of `cylinders <= 4`, effectively counting vehicles with more than 4 cylinders rather than 4 or fewer cylinders. The amended query now correctly matches the RIGHT_SQL's behavior by counting high-cylinder vehicles."
        ],
        "rules": [
            "1) When referencing the cars table: use the exact table name \"CARS_DATA\" as specified in the schema. 2) When filtering for vehicles with more than 4 cylinders: use the condition \"Cylinders > 4\" to count only rows where the Cylinders column value is strictly greater than 4. 3) When counting cars: use the COUNT(*) function to count all rows that satisfy the specified condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE cylinders <= 4;",
            "SELECT COUNT(*) FROM cars_data WHERE Cylinders > 4"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM CARS_DATA WHERE Cylinders > 4"
        ]
    },
    "838": {
        "db_id": "orchestra",
        "question": "List the name of the conductor with the most years of work.",
        "ground_truth": "SELECT Name FROM conductor ORDER BY Year_of_Work DESC LIMIT 1",
        "amends": [
            "Do reference table `conductor` instead of `conductors` and use column `Name` instead of `name` in the SELECT list. Do use column `Year_of_Work` for ordering instead of `years_worked` while maintaining the same DESC ordering and LIMIT 1 clause. The amended query now correctly references the intended table and column names to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"conductor with the most years of work\": make sure the output order: \"Name\" from table \"conductor\". 2) When the question mentions \"most years of work\": use column \"Year_of_Work\" for ordering in descending direction and keep only the first 1 row. 3) When choosing identifier delimiters: use double quotes for column names exactly as shown in the schema (\"Name\", \"Year_of_Work\") and table name (\"conductor\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM conductors ORDER BY years_worked DESC LIMIT 1;",
            "SELECT Name FROM conductor ORDER BY Year_of_Work DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT \"Name\" FROM \"conductor\" ORDER BY \"Year_of_Work\" DESC LIMIT 1"
        ]
    },
    "399": {
        "db_id": "course_teach",
        "question": "Show names of teachers and the courses they are arranged to teach.",
        "ground_truth": "SELECT T3.Name ,  T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID",
        "amends": [
            "Do select `T3.Name` and `T2.Course` instead of `teacher_name` and `course_name`. Do use `course_arrange AS T1` as the primary table instead of `teachers`, and join `course AS T2` on `T1.Course_ID = T2.Course_ID` instead of directly joining courses. Do add a second join to `teacher AS T3` on `T1.Teacher_ID = T3.Teacher_ID` instead of joining teachers directly to courses. The amended query now correctly uses the course_arrange table as a bridge between teachers and courses, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"names of teachers and the courses they are arranged to teach\": make sure the output order: T3.Name, T2.Course\n2) When the question mentions \"teachers\": use table \"teacher AS T3\" with exact identifier \"T3.Name\" for teacher names\n3) When the question mentions \"courses\": use table \"course AS T2\" with exact identifier \"T2.Course\" for course names\n4) When combining tables for teacher-course arrangements: use \"course_arrange AS T1\" as the primary table and link to \"course AS T2\" where T1.Course_ID = T2.Course_ID, then link to \"teacher AS T3\" where T1.Teacher_ID = T3.Teacher_ID, keeping only matching pairs (inner match)\n5) When selecting output columns: use exact identifiers T3.Name and T2.Course instead of generic teacher_name and course_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT teacher_name, course_name FROM teachers JOIN courses ON teachers.teacher_id = courses.teacher_id;",
            "SELECT T3.Name, T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID = T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID"
        ],
        "rule_sql": [
            "SELECT T3.Name, T2.Course FROM course_arrange AS T1 INNER JOIN course AS T2 ON T1.Course_ID = T2.Course_ID INNER JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID ORDER BY T3.Name, T2.Course"
        ]
    },
    "693": {
        "db_id": "voter_1",
        "question": "What are the distinct states and create time of all votes?",
        "ground_truth": "SELECT DISTINCT state ,  created FROM votes",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do select column `created` instead of `created_at` to match the correct column name. The amended query now correctly returns unique combinations of state and created date values from the votes table."
        ],
        "rules": [
            "1) When the question asks for \"distinct states and create time\": use DISTINCT to eliminate duplicate combinations of state and created values. 2) When the question mentions \"create time\": \"create time\" actually means the \"created\" column in the votes table. 3) When selecting output columns: maintain the order state then created as implied by the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT state, created_at FROM votes;",
            "SELECT DISTINCT state, created FROM VOTES;"
        ],
        "rule_sql": [
            "SELECT DISTINCT state, created FROM VOTES ORDER BY state, created;"
        ]
    },
    "746": {
        "db_id": "world_1",
        "question": "What are the names of nations speak both English and French?",
        "ground_truth": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"French\"",
        "amends": [
            "Do use `INTERSECT` to find countries that speak both English and French instead of using `OR` which finds countries that speak either language. Do join on `T1.Code = T2.CountryCode` instead of `n.id = l1.nation_id` with proper table aliases. Do filter for `T2.Language = \"English\"` in one branch and `T2.Language = \"French\"` in the other instead of using `OR` conditions that don't ensure both languages are spoken. Do use explicit table aliases `T1` and `T2` instead of `n`, `l1`, and `l2`. Do structure the query as two separate SELECT statements with INTERSECT instead of a single query with multiple joins and OR conditions. The amended query now correctly identifies countries that speak both English and French by intersecting the results of two separate queries."
        ],
        "rules": [
            "1) When the question asks for nations that speak both English and French: use INTERSECT to find countries that appear in both the English-speaking and French-speaking sets instead of using OR conditions. 2) When joining tables for language information: use the exact join condition T1.Code = T2.CountryCode as specified in the schema. 3) When filtering for English speakers: use the exact literal filter T2.Language = \"English\" with proper double quotes and capitalization. 4) When filtering for French speakers: use the exact literal filter T2.Language = \"French\" with proper double quotes and capitalization. 5) When using table aliases: use T1 for the nations table and T2 for the languages table consistently throughout the query. 6) When structuring the query: create two separate SELECT statements that find English-speaking countries and French-speaking countries respectively, then intersect them."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT n.name FROM nations n \nJOIN languages l1 ON n.id = l1.nation_id \nJOIN languages l2 ON n.id = l2.nation_id \nWHERE l1.language = 'English' OR l2.language = 'French';",
            "SELECT T1.Name \nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = 'English'\nINTERSECT\nSELECT T1.Name \nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = 'French'"
        ],
        "rule_sql": [
            "SELECT T1.Name \nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = \"English\"\nINTERSECT\nSELECT T1.Name \nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = \"French\""
        ]
    },
    "565": {
        "db_id": "student_transcripts_tracking",
        "question": "When is the first transcript released? List the date and details.",
        "ground_truth": "SELECT transcript_date ,  other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1",
        "amends": [
            "Do use column name `transcript_date` instead of `date` and `other_details` instead of `details` in the SELECT list. Do reference table `Transcripts` instead of `transcripts` in the FROM clause. The amended query now correctly matches the intended behavior with proper column and table names."
        ],
        "rules": [
            "1) When the question asks for \"date and details\" from transcripts: use column \"transcript_date\" for date and \"other_details\" for details in the SELECT list. 2) When referencing the transcripts table: use table name \"Transcripts\" (case-sensitive) in the FROM clause. 3) When finding the first transcript released: order by \"transcript_date\" in ascending order and take only the first row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT date, details FROM transcripts ORDER BY date ASC LIMIT 1;",
            "SELECT transcript_date, other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT transcript_date, other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1;"
        ]
    },
    "57": {
        "db_id": "pets_1",
        "question": "Find the first name of students who have cat or dog pet.",
        "ground_truth": "SELECT DISTINCT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat' OR T3.pettype  =  'dog'",
        "amends": [
            "Do use `DISTINCT T1.Fname` instead of `first_name` to select unique first names. Do join `student AS T1` with `has_pet AS T2` on `T1.stuid = T2.stuid` and `pets AS T3` on `T3.petid = T2.petid` instead of querying only the `students` table. Do filter with `T3.pettype = 'cat' OR T3.pettype = 'dog'` instead of the contradictory `pet = 'cat' AND pet = 'dog'` to find students who have either cats or dogs. The amended query now correctly identifies students with either pet type by properly joining through the relationship tables."
        ],
        "rules": [
            "1) When selecting first names of students: use DISTINCT T1.Fname to get unique first names instead of first_name. 2) When combining student and pet information: join student AS T1 with has_pet AS T2 on T1.stuid = T2.stuid and pets AS T3 on T3.petid = T2.petid to properly link students to their pets through relationship tables. 3) When filtering for students who have cat or dog pets: use T3.pettype = 'cat' OR T3.pettype = 'dog' instead of contradictory AND conditions to find students with either pet type."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE pet = 'cat' AND pet = 'dog';",
            "SELECT DISTINCT T1.Fname FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID JOIN Pets AS T3 ON T3.PetID = T2.PetID WHERE T3.PetType = 'cat' OR T3.PetType = 'dog'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Fname FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID JOIN Pets AS T3 ON T3.PetID = T2.PetID WHERE T3.PetType = 'cat' OR T3.PetType = 'dog'"
        ]
    },
    "932": {
        "db_id": "dog_kennels",
        "question": "Which professionals have done at least two treatments? List the professional's id, role, and first name.",
        "ground_truth": "SELECT T1.professional_id ,  T1.role_code ,  T1.first_name FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2",
        "amends": [
            "Do add `Treatments AS T2` table with `JOIN` instead of querying only `professionals` table. Do use `T1.professional_id = T2.professional_id` join condition instead of no join. Do change `role` to `role_code` instead of using incorrect column name. Do add `GROUP BY T1.professional_id` instead of omitting grouping. Do change `WHERE COUNT(treatment_id) = 1` to `HAVING count(*) >= 2` instead of using aggregate in WHERE clause with wrong condition. Do use table aliases `T1` and `T2` instead of no aliases. The amended query now correctly finds professionals with at least two treatments by properly joining tables and using HAVING clause for aggregate filtering."
        ],
        "rules": [
            "1) When answering about professionals who have done treatments: combine Professionals table (as T1) and Treatments table (as T2) using T1.professional_id = T2.professional_id instead of querying only one table. 2) When the question mentions \"role\": \"role\" actually means \"role_code\" in schema. 3) When the question asks for professionals with at least two treatments: group results by T1.professional_id and filter groups having count(*) >= 2 instead of using aggregate conditions in WHERE clause. 4) When using table aliases: use T1 for Professionals table and T2 for Treatments table consistently. 5) When counting treatments per professional: count all rows in the Treatments table (T2) that match each professional using count(*) instead of counting a specific column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT professional_id, role, first_name \nFROM professionals \nWHERE COUNT(treatment_id) = 1;",
            "SELECT T1.professional_id, T1.role_code, T1.first_name\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T1.professional_id, T1.role_code, T1.first_name\nFROM Professionals T1\nJOIN Treatments T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id, T1.role_code, T1.first_name\nHAVING COUNT(*) >= 2;"
        ]
    },
    "0": {
        "db_id": "concert_singer",
        "question": "How many singers do we have?",
        "ground_truth": "SELECT count(*) FROM singer",
        "amends": [
            "Do reference the `singer` table instead of the `songs` table in the FROM clause. Do count records from the correct table `singer` instead of the incorrect table `songs`. The amended query now correctly counts records from the singer table as intended."
        ],
        "rules": [
            "1) When answering about \"how many singers\": make sure to count records from the \"singer\" table instead of the \"songs\" table. 2) When counting entities: use the canonical key for counting records from the specified table (\"singer\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM songs;",
            "SELECT COUNT(*) FROM singer;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM singer;"
        ]
    },
    "643": {
        "db_id": "tvshow",
        "question": "find the id of tv channels that do not play any cartoon directed by Ben Jones.",
        "ground_truth": "SELECT id FROM TV_Channel EXCEPT SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones'",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do reference table `TV_Channel` instead of `tv_channels` and column `channel` instead of `channel_id`. Do use table `cartoon` instead of `cartoons` and filter on `directed_by = 'Ben Jones'` instead of `director = 'Ben Jones'`. The amended query now correctly uses set-based exclusion and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"tv channels that do not play any cartoon directed by Ben Jones\": make sure the output order: id from TV_Channel table. 2) When the question mentions \"tv channels\": \"tv channels\" actually means \"TV_Channel table in schema\". 3) When the question mentions \"channel_id\": \"channel_id\" actually means \"channel column in cartoon table\". 4) When the question mentions \"cartoons\": \"cartoons\" actually means \"cartoon table in schema\". 5) When the question mentions \"director = 'Ben Jones'\": \"director = 'Ben Jones'\" actually means \"directed_by = 'Ben Jones' in cartoon table\". 6) When excluding channels that play cartoons directed by Ben Jones: use EXCEPT set operation to subtract channels that appear in the cartoon table with directed_by = 'Ben Jones' from all channels in TV_Channel table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM tv_channels WHERE id NOT IN (SELECT channel_id FROM cartoons WHERE director = 'Ben Jones')",
            "SELECT id FROM TV_Channel\nEXCEPT\nSELECT Channel FROM Cartoon WHERE Directed_by = 'Ben Jones';"
        ],
        "rule_sql": [
            "SELECT id FROM TV_Channel\nEXCEPT\nSELECT Channel FROM Cartoon WHERE Directed_by = 'Ben Jones';"
        ]
    },
    "530": {
        "db_id": "student_transcripts_tracking",
        "question": "For each semester, what is the name and id of the one with the most students registered?",
        "ground_truth": "SELECT T1.semester_name ,  T1.semester_id FROM Semesters AS T1 JOIN Student_Enrolment AS T2 ON T1.semester_id  =  T2.semester_id GROUP BY T1.semester_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of no aliases. Do reference `T1.semester_name` and `T1.semester_id` in SELECT instead of `semester_id, semester_name`. Do remove the `student_count` alias and aggregate function instead of keeping them. Do join with `Student_Enrolment AS T2` instead of `registrations`. Do use `ON T1.semester_id = T2.semester_id` instead of `semesters.semester_id = registrations.semester_id`. Do remove `semester_name` from GROUP BY instead of including it. Do use `ORDER BY count(*) DESC` instead of `ORDER BY student_count DESC`. The amended query now correctly identifies the semester with the most student enrollments by counting records in the Student_Enrolment table rather than using a potentially incorrect registrations table.",
            "Do place `T1.semester_name` before `T1.semester_id` in the SELECT list instead of the reverse order. Do maintain the same FROM clause with `JOIN` on `T1.semester_id = T2.semester_id` instead of changing it. Do keep the `GROUP BY T1.semester_id` and `ORDER BY count(*) DESC LIMIT 1` unchanged as they correctly identify the semester with the highest enrollment count. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [
            "1) When answering about \"semester with the most students registered\": make sure the output order: T1.semester_id, T1.semester_name\n2) When the question mentions \"most students registered\": count the number of enrollment records using T2.semester_id as the counting key\n3) When combining T1 and T2 for shared entities: link rows where T1.semester_id = T2.semester_id and keep only matching pairs (inner match)\n4) When organizing results by semester: group by T1.semester_id only\n5) When ranking semesters by enrollment count: order by count(*) in descending direction and keep only the first row (top result)\n6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms",
            "1) When answering about \"the one with the most students registered\": rank semesters by enrollment count in descending order and keep only the first 1 row. 2) When combining Semesters and Student_Enrolment tables: link rows where T1.semester_id = T2.semester_id and keep only matching pairs (inner match). 3) When counting students registered: compute the number of rows using the enrollment records. 4) When producing output columns: place T1.semester_name before T1.semester_id in the result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT semester_id, semester_name, COUNT(student_id) as student_count\nFROM semesters\nJOIN registrations ON semesters.semester_id = registrations.semester_id\nGROUP BY semester_id, semester_name\nORDER BY student_count DESC\nLIMIT 1;",
            "SELECT T1.semester_id, T1.semester_name\nFROM Semesters AS T1\nJOIN Student_Enrolment AS T2 ON T1.semester_id = T2.semester_id\nGROUP BY T1.semester_id\nORDER BY count(*) DESC\nLIMIT 1;",
            "SELECT T1.semester_name, T1.semester_id\nFROM Semesters AS T1\nJOIN Student_Enrolment AS T2 ON T1.semester_id = T2.semester_id\nGROUP BY T1.semester_id\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.semester_name, T1.semester_id\nFROM Semesters T1\nINNER JOIN Student_Enrolment T2 ON T1.semester_id = T2.semester_id\nGROUP BY T1.semester_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "289": {
        "db_id": "employee_hire_evaluation",
        "question": "What is total bonus given in all evaluations?",
        "ground_truth": "SELECT sum(bonus) FROM evaluation",
        "amends": [
            "Do use the column `bonus` instead of `salary` in the SELECT list's aggregate function. Do reference the table `evaluation` instead of `evaluations` in the FROM clause. The amended query now correctly calculates the sum of bonus amounts from the evaluation table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"total bonus\": use the exact column name \"bonus\" from the evaluation table. 2) When referencing the table containing bonus data: use the exact table name \"evaluation\" (singular form) instead of \"evaluations\". 3) When calculating the sum of bonus amounts: aggregate using the SUM function on the \"bonus\" column from the evaluation table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(salary) FROM evaluations;",
            "SELECT SUM(Bonus) AS Total_Bonus FROM evaluation;"
        ],
        "rule_sql": [
            "SELECT SUM(bonus) AS total_bonus FROM evaluation;"
        ]
    },
    "744": {
        "db_id": "world_1",
        "question": "How many countries speak both English and Dutch?",
        "ground_truth": "SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"Dutch\")",
        "amends": [
            "Do use `INTERSECT` to find countries with both languages instead of counting cross-joined language pairs. Do reference `country` and `countrylanguage` tables instead of `countries` and `languages`. Do join on `Code` and `CountryCode` instead of `country_id` to `country_id`. Do filter for \"English\" and \"Dutch\" in separate subqueries instead of joining the same table twice with both conditions. Do select `Name` from the subqueries instead of counting all matches. Do remove the double join structure and WHERE clause combining both language conditions, instead using set intersection logic to correctly identify countries that have both languages specified."
        ],
        "rules": [
            "1) When the question asks for countries speaking both English and Dutch: use set intersection logic with separate subqueries instead of double joins to find countries that have both languages. 2) When referencing tables: use \"country\" as T1 and \"countrylanguage\" as T2 instead of \"countries\" and \"languages\". 3) When joining tables: link rows where T1.\"Code\" equals T2.\"CountryCode\" instead of country_id to country_id. 4) When filtering for languages: create separate subqueries for \"English\" and \"Dutch\" language conditions instead of combining both in WHERE clause. 5) When selecting country identifiers: use T1.\"Name\" from the subqueries instead of counting all matches. 6) When counting countries that speak both languages: use INTERSECT operation between the two language-specific subqueries to correctly identify countries with both languages specified."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM countries c\nJOIN languages l1 ON c.country_id = l1.country_id\nJOIN languages l2 ON c.country_id = l2.country_id\nWHERE l1.language = 'English' AND l2.language = 'Dutch';",
            "SELECT COUNT(*) \nFROM (\n    SELECT CountryCode \n    FROM countrylanguage \n    WHERE Language = 'English'\n    INTERSECT\n    SELECT CountryCode \n    FROM countrylanguage \n    WHERE Language = 'Dutch'\n) AS countries_with_both_languages"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM (\n    SELECT T1.Name \n    FROM country T1 \n    JOIN countrylanguage T2 ON T1.Code = T2.CountryCode \n    WHERE T2.Language = 'English'\n    INTERSECT\n    SELECT T1.Name \n    FROM country T1 \n    JOIN countrylanguage T2 ON T1.Code = T2.CountryCode \n    WHERE T2.Language = 'Dutch'\n)"
        ]
    },
    "1019": {
        "db_id": "singer",
        "question": "What are the song titles and singer names?",
        "ground_truth": "SELECT T2.Title ,  T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of no aliases. Do reference columns as `T2.Title` and `T1.Name` instead of `title` and `name`. Do join `singer AS T1` to `song AS T2` instead of `songs` to `singers`. Do use the join condition `T1.Singer_ID = T2.Singer_ID` instead of `songs.singer_id = singers.id`. The amended query now correctly matches the intended behavior with proper table references and join conditions."
        ],
        "rules": [
            "1) When answering about \"song titles and singer names\": make sure the output order: T2.Title, T1.Name 2) When combining singer and song tables: link rows where T1.Singer_ID = T2.Singer_ID exactly as shown; keep only matching pairs (inner match) 3) When referring to table roles: use T1 for singer table and T2 for song table as established by the amends 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms 5) When handling text literals: do not change case, spacing, or punctuation"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title, name FROM songs JOIN singers ON songs.singer_id = singers.id",
            "SELECT T2.Title, T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID = T2.Singer_ID"
        ],
        "rule_sql": [
            "SELECT T2.\"Title\", T1.\"Name\" FROM \"singer\" T1 INNER JOIN \"song\" T2 ON T1.\"Singer_ID\" = T2.\"Singer_ID\""
        ]
    },
    "615": {
        "db_id": "tvshow",
        "question": "List top 3 highest Rating  TV series. List the TV series's Episode and Rating.",
        "ground_truth": "SELECT Episode ,  Rating FROM TV_series ORDER BY Rating DESC LIMIT 3;",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Episode, Rating FROM TV_series ORDER BY Rating DESC LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT Episode, Rating FROM TV_series ORDER BY CAST(Rating AS REAL) DESC LIMIT 3;"
        ]
    },
    "759": {
        "db_id": "world_1",
        "question": "What languages are only used by a single country with a republic government?",
        "ground_truth": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  \"Republic\" GROUP BY T2.Language HAVING COUNT(*)  =  1",
        "amends": [
            "Do use `T2.Language` instead of `language` for the SELECT column. Do reference `countrylanguage` as `T2` instead of `country_language cl` as the table source. Do use `JOIN` with `T1.Code = T2.CountryCode` instead of `JOIN` with `cl.country_code = c.code` for the join condition. Do filter with `T1.GovernmentForm = \"Republic\"` instead of `c.government = 'Republic'` in the WHERE clause. Do use `COUNT(*) = 1` instead of `COUNT(DISTINCT c.code) > 1` in the HAVING clause to find languages spoken in exactly one republic instead of multiple republics. Do remove `DISTINCT` from the SELECT instead of keeping it since the GROUP BY already ensures uniqueness. The amended query now correctly identifies languages spoken in exactly one republic country."
        ],
        "rules": [
            "1) When referencing the language column: use \"T2.Language\" instead of \"language\" for the output column. 2) When joining country and countrylanguage tables: link rows where \"T1.Code = T2.CountryCode\" exactly as shown. 3) When filtering for republic government form: use \"T1.GovernmentForm = \\\"Republic\\\"\" with exact case and quotes. 4) When counting countries per language: use \"COUNT(*) = 1\" to find languages spoken in exactly one republic country. 5) When selecting languages: do not use DISTINCT since GROUP BY already ensures uniqueness per language group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT language \nFROM country_language cl\nJOIN country c ON cl.country_code = c.code\nWHERE c.government = 'Republic'\nGROUP BY language\nHAVING COUNT(DISTINCT c.code) > 1;",
            "SELECT T2.Language\nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T1.GovernmentForm = \"Republic\"\nGROUP BY T2.Language\nHAVING COUNT(*) = 1"
        ],
        "rule_sql": [
            "SELECT T2.Language\nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T1.GovernmentForm = \"Republic\"\nGROUP BY T2.Language\nHAVING COUNT(*) = 1"
        ]
    },
    "952": {
        "db_id": "dog_kennels",
        "question": "List pairs of the owner's first name and the dogs's name.",
        "ground_truth": "SELECT T1.first_name ,  T2.name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names `owner` and `dog`. Do reference `T1.first_name` and `T2.name` instead of `owner.first_name` and `dog.name`. Do join on `T1.owner_id = T2.owner_id` instead of `owner.id = dog.owner_id`. Do use table names `Owners` and `Dogs` instead of `owner` and `dog`. The amended query now correctly matches the intended join logic and table structure."
        ],
        "rules": [
            "1) When answering about \"List pairs of the owner's first name and the dog's name\": make sure the output order: T1.first_name, T2.name. 2) When combining Owners (T1) and Dogs (T2) for shared entities: link rows where T1.owner_id = T2.owner_id exactly as shown; keep only matching pairs (inner match). 3) When choosing identifier delimiters: do not replace table names Owners and Dogs with lowercase owner and dog."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT owner.first_name, dog.name FROM owner JOIN dog ON owner.id = dog.owner_id",
            "SELECT T1.first_name, T2.name FROM Owners T1 JOIN Dogs T2 ON T1.owner_id = T2.owner_id"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T2.name FROM Owners T1 INNER JOIN Dogs T2 ON T1.owner_id = T2.owner_id"
        ]
    },
    "701": {
        "db_id": "voter_1",
        "question": "Return the names of the contestants whose names contain the substring 'Al' .",
        "ground_truth": "select contestant_name from contestants where contestant_name like \"%al%\"",
        "amends": [
            "Do reference `contestant_name` instead of `name` in the SELECT list and WHERE clause. Do use lowercase `\"%al%\"` pattern matching instead of uppercase `'%Al%'` for case-insensitive matching. The amended query now correctly matches the RIGHT_SQL's behavior by using the proper column name and case-insensitive pattern matching."
        ],
        "rules": [
            "1) When the question asks for contestant names containing 'Al': use the exact column name \"contestant_name\" from the CONTESTANTS table. 2) When performing substring matching for 'Al': use the lowercase pattern \"%al%\" for case-insensitive matching instead of the uppercase 'Al' literal. 3) When selecting output columns: return only the \"contestant_name\" column in the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM contestants WHERE name LIKE '%Al%';",
            "SELECT contestant_name FROM CONTESTANTS WHERE contestant_name LIKE '%al%'"
        ],
        "rule_sql": [
            "SELECT contestant_name FROM CONTESTANTS WHERE contestant_name LIKE '%al%'"
        ]
    },
    "792": {
        "db_id": "world_1",
        "question": "Return the country name and the numbers of languages spoken for each country that speaks at least 3 languages.",
        "ground_truth": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2",
        "amends": [
            "Do use `COUNT(T2.Language)` instead of `COUNT(language.language)` to reference the joined table correctly. Do use table aliases `T1` and `T2` instead of full table names for clarity. Do reference `T1.Name` in the SELECT list instead of `country.name` to match the aliased table. Do group by `T1.Name` instead of `country.code` to ensure proper aggregation with the selected column. Do change the HAVING condition to `COUNT(*) > 2` instead of `num_languages >= 3` to use the actual count value rather than the alias. The amended query now correctly counts languages per country and filters for countries with more than 2 languages, matching the RIGHT_SQL's behavior.",
            "Do place `T1.Name` after the aggregate in the SELECT list instead of before it, maintaining the same column order as the original. Do use explicit table aliases with `AS` for both tables instead of omitting them. Do keep the same join condition `T1.Code = T2.CountryCode`, grouping by `T1.Name`, and HAVING clause `COUNT(*) > 2` unchanged. The amended query now correctly matches the RIGHT_SQL's behavior with proper column ordering and explicit alias syntax.",
            "Do place `COUNT(T2.Language)` before `T1.Name` in the SELECT list instead of the reverse order. Do maintain the same JOIN condition `T1.Code = T2.CountryCode` and GROUP BY `T1.Name` with the identical HAVING clause `COUNT(*) > 2`. The amended query now matches RIGHT_SQL's behavior with the correct column ordering while preserving all logical operations."
        ],
        "rules": [
            "1) When answering about \"country name and number of languages spoken\": make sure the output order: T1.Name, COUNT(T2.Language). 2) When the question mentions \"country\": use table T1 (country) with column T1.Name for country names. 3) When the question mentions \"languages spoken\": use table T2 (countrylanguage) with column T2.Language for languages. 4) When combining T1 and T2 for shared entities: link rows where T1.code = T2.countrycode and keep only matching pairs (inner match). 5) When the question asks for \"count of languages\": compute the number of rows using T2.Language. 6) When the question says \"per country\": organize results by T1.Name and compute COUNT(T2.Language) per group. 7) When the question specifies \"at least 3 languages\": filter groups where COUNT(*) > 2. 8) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms.",
            "1) When answering about \"country name and numbers of languages spoken for each country that speaks at least 3 languages\": make sure the output order: T1.Name, COUNT(T2.Language) AS num_languages. 2) When combining country T1 and countrylanguage T2 for shared entities: link rows where T1.Code = T2.CountryCode exactly as shown in the amends; keep only matching pairs (inner match). 3) When the question asks for \"count of languages spoken per country\": organize results by T1.Name and compute COUNT(T2.Language) per group. 4) When the question specifies \"at least 3 languages\": apply the condition COUNT(*) > 2 to filter groups. 5) When using table aliases: use explicit aliases with AS for both tables (T1 AS country, T2 AS countrylanguage) instead of omitting them.",
            "1) When answering about \"Return the country name and the numbers of languages spoken for each country that speaks at least 3 languages\": make sure the output order: COUNT(T2.Language) before T1.Name. 2) When combining T1 and T2 for shared entities: link rows where T1.Code = T2.CountryCode; keep only matching pairs (inner match). 3) When the question says \"per country\"/\"by country\": organize results by T1.Name and compute requested aggregates per group. 4) When the question asks for \"numbers of languages spoken\": compute the number of rows using T2.Language. 5) When the question specifies \"at least 3 languages\": filter groups where COUNT(*) > 2."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country.name, COUNT(language.language) as num_languages \nFROM country \nJOIN countrylanguage ON country.code = countrylanguage.countrycode \nGROUP BY country.code \nHAVING num_languages >= 3;",
            "SELECT T1.Name, COUNT(T2.Language) AS num_languages\nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Name\nHAVING COUNT(*) > 2",
            "SELECT T1.Name, COUNT(T2.Language) \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nGROUP BY T1.Name \nHAVING COUNT(*) > 2",
            "SELECT COUNT(T2.Language), T1.Name \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nGROUP BY T1.Name \nHAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT T1.Name, COUNT(T2.Language) AS num_languages\nFROM country AS T1\nINNER JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Name\nHAVING COUNT(*) > 2\nORDER BY COUNT(T2.Language), T1.Name"
        ]
    },
    "877": {
        "db_id": "network_1",
        "question": "How many high schoolers are in each grade?",
        "ground_truth": "SELECT grade ,  count(*) FROM Highschooler GROUP BY grade",
        "amends": [
            "Do reference the `Highschooler` table instead of the `students` table. Do remove the `WHERE school_level = 'high school'` filter instead of keeping it, as the table name already implies the context. Do remove the `ORDER BY grade` clause instead of including it, as the grouping inherently organizes results. Do maintain the same `SELECT grade, COUNT(*)` and `GROUP BY grade` structure. The amended query now correctly focuses on the Highschooler table without redundant filtering and ordering."
        ],
        "rules": [
            "1) When answering about \"high schoolers in each grade\": use the \"Highschooler\" table instead of any other student table. 2) When the table name already implies the context (like \"Highschooler\"): do not add redundant filtering conditions like WHERE school_level = 'high school'. 3) When grouping results by grade: do not add ORDER BY grade as the grouping inherently organizes results. 4) When counting high schoolers per grade: maintain the structure SELECT grade, COUNT(*) FROM Highschooler GROUP BY grade."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT grade, COUNT(*) FROM students WHERE school_level = 'high school' GROUP BY grade ORDER BY grade;",
            "SELECT grade, COUNT(*) FROM Highschooler GROUP BY grade"
        ],
        "rule_sql": [
            "SELECT grade, COUNT(*) FROM Highschooler GROUP BY grade"
        ]
    },
    "369": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all document ids, names and the number of paragraphs in each document.",
        "ground_truth": "SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id",
        "amends": [
            "Do join `Paragraphs AS T1` with `Documents AS T2` on `T1.document_id = T2.document_id` instead of querying only the `documents` table. Do select `T2.document_name` instead of `name` and use `count(*)` instead of `COUNT(paragraph_id)`. Do group by only `T1.document_id` instead of grouping by both `document_id` and `name`. The amended query now correctly counts paragraphs per document while retrieving the document name from the joined Documents table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"document ids, names and the number of paragraphs in each document\": make sure the output order: document_id, document_name, count of paragraphs. 2) When combining Paragraphs as T1 and Documents as T2 for shared entities: link rows where T1.document_id = T2.document_id exactly as shown; keep only matching pairs (inner match). 3) When the question asks for \"count of paragraphs\": compute the number of rows using count(*) from the Paragraphs table. 4) When the question asks for document names: use T2.document_name instead of name. 5) When grouping by document: organize results by T1.document_id only, not both document_id and name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id, name, COUNT(paragraph_id) FROM documents GROUP BY document_id, name",
            "SELECT T2.Document_ID, T2.Document_Name, COUNT(*) AS Number_Of_Paragraphs\nFROM Paragraphs AS T1\nJOIN Documents AS T2 ON T1.Document_ID = T2.Document_ID\nGROUP BY T1.Document_ID"
        ],
        "rule_sql": [
            "SELECT d.Document_ID, d.Document_Name, COUNT(p.Paragraph_ID) AS paragraph_count\nFROM Documents d\nINNER JOIN Paragraphs p ON d.Document_ID = p.Document_ID\nGROUP BY d.Document_ID, d.Document_Name\nORDER BY d.Document_ID, d.Document_Name"
        ]
    },
    "788": {
        "db_id": "world_1",
        "question": "What are the name, independence year, and surface area of the country with the smallest population?",
        "ground_truth": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1",
        "amends": [
            "Do select `Name`, `SurfaceArea`, and `IndepYear` instead of `name`, `indep_year`, and `surface_area` to match the correct column names. Do order by `Population` in ascending order instead of `population DESC` to get the smallest population record. Do use table name `country` instead of `countries` to reference the correct source table. The amended query now correctly retrieves the country with the smallest population using the proper table and column names.",
            "Do reorder the SELECT list to `Name, SurfaceArea, IndepYear` instead of `Name, IndepYear, SurfaceArea`. Do remove the `ASC` keyword from the ORDER BY clause instead of keeping it, as ASC is the default sort order. The amended query now correctly matches the RIGHT_SQL's behavior with the proper column sequence and simplified ordering."
        ],
        "rules": [
            "1) When selecting country information: use the exact column names \"Name\", \"SurfaceArea\", and \"IndepYear\" from the country table. 2) When finding the country with the smallest population: order by \"Population\" in ascending order to get the minimum value. 3) When referencing the source table: use the exact table name \"country\" instead of any variations like \"countries\".",
            "1) When answering about \"the country with the smallest population\": rank rows by \"Population\" in ascending order and keep the first 1 row. 2) When producing output columns: make sure the output order is \"Name\", \"SurfaceArea\", \"IndepYear\" exactly as specified in the question sequence. 3) When ordering by population: do not explicitly specify ASC as it is the default sort order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, indep_year, surface_area FROM countries ORDER BY population DESC LIMIT 1;",
            "SELECT Name, IndepYear, SurfaceArea FROM country ORDER BY Population ASC LIMIT 1;",
            "SELECT Name, SurfaceArea, IndepYear FROM country ORDER BY Population LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name, SurfaceArea, IndepYear FROM country ORDER BY Population LIMIT 1;"
        ]
    },
    "188": {
        "db_id": "flight_2",
        "question": "What is the total number of airlines?",
        "ground_truth": "SELECT count(*) FROM AIRLINES",
        "amends": [
            "Do query the `AIRLINES` table instead of the `flights` table. The amended query now correctly counts records from the AIRLINES table as intended."
        ],
        "rules": [
            "1) When answering about \"total number of airlines\": query the \"AIRLINES\" table instead of the \"flights\" table. 2) When counting airlines: count records from the \"AIRLINES\" table using the canonical key for airlines."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights;",
            "SELECT COUNT(*) FROM airlines;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM airlines;"
        ]
    },
    "444": {
        "db_id": "wta_1",
        "question": "How many different loser names are there?",
        "ground_truth": "SELECT count(DISTINCT loser_name) FROM matches",
        "amends": [
            "Do count `DISTINCT loser_name` instead of counting `winner_name` without distinct, which changes both the column being aggregated and adds deduplication to count unique values rather than all occurrences. This amendment shifts the focus from counting winner occurrences to counting distinct loser names, fundamentally altering the query's purpose to measure unique losers rather than total winner entries."
        ],
        "rules": [
            "1) When the question asks for \"different loser names\": count the number of unique values in the exact column \"loser_name\" using DISTINCT aggregation. 2) When counting entities: use the exact column name \"loser_name\" rather than \"winner_name\" to match the question's focus on losers rather than winners. 3) When the question asks for \"how many different\": ensure the count operation includes deduplication to count unique values rather than total occurrences."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(winner_name) FROM matches;",
            "SELECT COUNT(DISTINCT loser_name) FROM matches;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT loser_name) FROM matches;"
        ]
    },
    "983": {
        "db_id": "dog_kennels",
        "question": "Find the number of professionals who have not treated any dogs.",
        "ground_truth": "SELECT count(*) FROM Professionals WHERE professional_id NOT IN ( SELECT professional_id FROM Treatments )",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM professionals WHERE professional_id NOT IN (SELECT professional_id FROM treatments)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS number_of_professionals_without_treatments\nFROM Professionals p\nLEFT JOIN Treatments t ON p.professional_id = t.professional_id\nWHERE t.treatment_id IS NULL;"
        ]
    },
    "535": {
        "db_id": "student_transcripts_tracking",
        "question": "Who is enrolled in a Bachelor degree program? List the first name, middle name, last name.",
        "ground_truth": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do change the `FROM` clause to use explicit table aliases `Students AS T1` instead of just `students`. Do add `JOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id` and `JOIN Degree_Programs AS T3 ON T2.degree_program_id = T3.degree_program_id` instead of querying only the students table. Do change the `WHERE` filter to `T3.degree_summary_name = 'Bachelor'` instead of `degree_program = 'Bachelor'` to properly reference the joined degree programs table. The amended query now correctly joins through the enrollment relationship to identify bachelor's degree students and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"Who is enrolled in a Bachelor degree program?\": make sure the output order: first_name, middle_name, last_name. 2) When the question mentions \"Bachelor\": \"Bachelor\" actually means \"degree_summary_name = 'Bachelor'\" in schema. 3) When combining T1 (Students) and T2 (Student_Enrolment) for shared entities: link rows where T1.student_id = T2.student_id and keep only matching pairs (inner match). 4) When combining T2 (Student_Enrolment) and T3 (Degree_Programs) for shared entities: link rows where T2.degree_program_id = T3.degree_program_id and keep only matching pairs (inner match). 5) When listing student names: use DISTINCT to ensure each student appears only once in the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, middle_name, last_name FROM students WHERE degree_program = 'Bachelor'",
            "SELECT DISTINCT T1.first_name, T1.middle_name, T1.last_name\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nJOIN Degree_Programs AS T3 ON T2.degree_program_id = T3.degree_program_id\nWHERE T3.degree_summary_name = 'Bachelor'"
        ],
        "rule_sql": [
            "SELECT DISTINCT s.first_name, s.middle_name, s.last_name\nFROM Students s\nINNER JOIN Student_Enrolment se ON s.student_id = se.student_id\nINNER JOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nWHERE dp.degree_summary_name = 'Bachelor';"
        ]
    },
    "731": {
        "db_id": "world_1",
        "question": "Give the mean GNP and total population of nations which are considered US territory.",
        "ground_truth": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  \"US Territory\"",
        "amends": [
            "Do reference `GovernmentForm` in the WHERE filter instead of `Region`. Do use double quotes around the string literal \"US Territory\" instead of single quotes. The amended query now correctly filters by government form rather than region and matches the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"US territory\": \"US territory\" actually means \"GovernmentForm\" in schema with exact literal value \"US Territory\" 2) When filtering for nations considered US territory: use condition where \"GovernmentForm\" equals \"US Territory\" exactly as specified 3) When computing mean GNP and total population: calculate average of GNP and sum of Population for the filtered nations"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(GNP), SUM(Population) FROM country WHERE Region = 'US Territory';",
            "SELECT AVG(GNP) AS mean_gnp, SUM(Population) AS total_population FROM country WHERE GovernmentForm = \"US Territory\";"
        ],
        "rule_sql": [
            "SELECT AVG(GNP) AS mean_gnp, SUM(Population) AS total_population FROM country WHERE GovernmentForm = 'US Territory';"
        ]
    },
    "111": {
        "db_id": "car_1",
        "question": "What is the accelerate of the car make amc hornet sportabout (sw)?",
        "ground_truth": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';",
        "amends": [
            "Do join `CAR_NAMES` as `T2` on `T1.Id = T2.MakeId` instead of querying `cars` table directly. Do reference `Accelerate` from `T1` instead of `accelerate` from the base table. Do filter on `T2.Make = 'amc hornet sportabout (sw)'` instead of `make = 'amc hornet sportabout (sw)'` to properly correlate the make name with the corresponding acceleration data through the join relationship. The amended query now correctly retrieves acceleration data by joining through the proper table relationship instead of assuming the make column exists directly in the data table."
        ],
        "rules": [
            "1) When answering about \"accelerate of the car make amc hornet sportabout (sw)\": make sure the output order: Accelerate from T1. 2) When the question mentions \"car make amc hornet sportabout (sw)\": \"amc hornet sportabout (sw)\" actually means T2.Make = 'amc hornet sportabout (sw)' in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.Id = T2.MakeId exactly as shown in the amends; keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for identifiers like T1.Accelerate and T2.Make. 5) When handling text literals: do not change case, spacing, or punctuation for 'amc hornet sportabout (sw)'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT accelerate FROM cars WHERE make = 'amc hornet sportabout (sw)'",
            "SELECT T1.Accelerate \nFROM cars_data T1 \nJOIN car_names T2 ON T1.Id = T2.MakeId \nWHERE T2.Make = 'amc hornet sportabout (sw)'"
        ],
        "rule_sql": [
            "SELECT T1.Accelerate FROM cars_data T1 JOIN car_names T2 ON T1.Id = T2.MakeId WHERE T2.Make = 'amc hornet sportabout (sw)'"
        ]
    },
    "698": {
        "db_id": "voter_1",
        "question": "What is the area code in which the most voters voted?",
        "ground_truth": "SELECT T1.area_code FROM area_code_state AS T1 JOIN votes AS T2 ON T1.state  =  T2.state GROUP BY T1.area_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `area_code` instead of selecting both `area_code` and `COUNT(*) as voter_count`. Do join `area_code_state AS T1` with `votes AS T2` on `T1.state = T2.state` instead of querying only the `voters` table. Do group by `T1.area_code` instead of grouping by `area_code` from a single table. Do order by `count(*) DESC` instead of ordering by `voter_count ASC`. The amended query now correctly joins the area code and votes tables to find the area code with the highest vote count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"area code with the most voters\": make sure the output order: T1.area_code only 2) When combining area_code_state and votes tables: link rows where T1.state = T2.state and keep only matching pairs (inner match) 3) When grouping by area code: organize results by T1.area_code and compute count per group 4) When the question mentions \"most voters voted\": rank rows by count(*) in descending order and keep the first 1 row"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT area_code, COUNT(*) as voter_count FROM voters GROUP BY area_code ORDER BY voter_count ASC LIMIT 1;",
            "SELECT T1.area_code\nFROM AREA_CODE_STATE AS T1\nJOIN VOTES AS T2 ON T1.state = T2.state\nGROUP BY T1.area_code\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.area_code\nFROM AREA_CODE_STATE T1\nINNER JOIN VOTES T2 ON T1.state = T2.state\nGROUP BY T1.area_code\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "601": {
        "db_id": "tvshow",
        "question": "What is the Package Option of TV Channel with serial name \"Sky Radio\"?",
        "ground_truth": "SELECT Package_Option FROM TV_Channel WHERE series_name = \"Sky Radio\";",
        "amends": [
            "Do reference table `TV_Channel` instead of `TV_Channels` and use column `series_name` instead of `serial_name` while maintaining the same filter value for 'Sky Radio'."
        ],
        "rules": [
            "1) When the question mentions \"serial name\": \"serial name\" actually means \"series_name\" in schema. 2) When the question asks about TV Channel: use table \"TV_Channel\" instead of \"TV_Channels\". 3) When filtering for channel with name \"Sky Radio\": use exact literal value 'Sky Radio' with correct case and spacing. 4) When answering about \"Package Option of TV Channel\": make sure the output order: Package_Option."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Package_Option FROM TV_Channels WHERE serial_name = 'Sky Radio';",
            "SELECT Package_Option FROM TV_Channel WHERE series_name = 'Sky Radio';"
        ],
        "rule_sql": [
            "SELECT Package_Option FROM TV_Channel WHERE series_name = 'Sky Radio';"
        ]
    },
    "593": {
        "db_id": "tvshow",
        "question": "List the title of all cartoon directed by \"Ben Jones\" or \"Brandon Vietti\".",
        "ground_truth": "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\" OR Directed_by = \"Brandon Vietti\";",
        "amends": [
            "Do use `OR` instead of `AND` for the director condition to find records matching either director instead of requiring both simultaneously. Do reference the correct table name `Cartoon` instead of `cartoons` and use the correct column name `Directed_by` instead of `director`. Do use proper column casing `Title` instead of `title` and maintain consistent quotation style with double quotes around director names instead of single quotes. The amended query now correctly returns cartoons directed by either Ben Jones or Brandon Vietti instead of incorrectly requiring both directors simultaneously, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for cartoons directed by multiple directors: use OR instead of AND to find records matching any of the specified directors rather than requiring all simultaneously. 2) When referencing the cartoon table: use the exact table name \"Cartoon\" instead of variations like \"cartoons\". 3) When selecting the director column: use the exact column name \"Directed_by\" instead of \"director\". 4) When selecting the title column: use the exact column name \"Title\" instead of \"title\". 5) When specifying director names in conditions: use double quotes around literal values like \"Ben Jones\" and \"Brandon Vietti\" to maintain consistent quotation style."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM cartoons WHERE director = 'Ben Jones' AND director = 'Brandon Vietti'",
            "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\" OR Directed_by = \"Brandon Vietti\""
        ],
        "rule_sql": [
            "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\" OR Directed_by = \"Brandon Vietti\";"
        ]
    },
    "856": {
        "db_id": "orchestra",
        "question": "Show the record companies shared by orchestras founded before 2003 and after 2003.",
        "ground_truth": "SELECT Record_Company FROM orchestra WHERE Year_of_Founded  <  2003 INTERSECT SELECT Record_Company FROM orchestra WHERE Year_of_Founded  >  2003",
        "amends": [
            "Do use `INTERSECT` to find common record companies instead of using contradictory `WHERE` conditions that would return no results. Do reference `Year_of_Founded` instead of `year_founded` for the column name. Do add a second `SELECT` clause with the opposite condition instead of having both conditions in a single `WHERE` clause. Do remove the contradictory `year_founded < 2003 AND year_founded > 2003` filter instead of keeping it, as it would always return an empty set. Do use proper column naming with `Record_Company` instead of `orchestra.record_company` for consistency. The amended query now correctly identifies record companies that have orchestras founded both before and after 2003, matching the RIGHT_SQL's intersection behavior."
        ],
        "rules": [
            "1) When the question asks for record companies shared by orchestras from different founding periods: use INTERSECT to find common values between the two groups instead of contradictory WHERE conditions. 2) When referencing the founding year column: use the exact column name \"Year_of_Founded\" instead of \"year_founded\". 3) When selecting record companies: use the exact column name \"Record_Company\" without table prefix. 4) When finding orchestras founded before 2003: select records where \"Year_of_Founded\" < 2003. 5) When finding orchestras founded after 2003: select records where \"Year_of_Founded\" > 2003. 6) When combining results from both time periods: use INTERSECT to find record companies that appear in both the before-2003 and after-2003 groups."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT orchestra.record_company \nFROM orchestra \nWHERE orchestra.year_founded < 2003 \nAND orchestra.year_founded > 2003;",
            "SELECT Record_Company FROM orchestra WHERE Year_of_Founded < 2003\nINTERSECT\nSELECT Record_Company FROM orchestra WHERE Year_of_Founded > 2003"
        ],
        "rule_sql": [
            "SELECT Record_Company FROM orchestra WHERE Year_of_Founded < 2003\nINTERSECT\nSELECT Record_Company FROM orchestra WHERE Year_of_Founded > 2003"
        ]
    },
    "796": {
        "db_id": "world_1",
        "question": "Find the government form name and total population for each government form whose average life expectancy is longer than 72.",
        "ground_truth": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72",
        "amends": [
            "Do use `HAVING avg(LifeExpectancy) > 72` instead of `WHERE lifeexpectancy > 72` to filter after aggregation rather than before. Do place `GovernmentForm` after the aggregate instead of before it in the SELECT list. Do remove the alias `total_population` instead of keeping it. Do use uppercase column names `Population` and `GovernmentForm` instead of lowercase versions. The amended query now correctly filters groups based on average life expectancy rather than filtering individual rows, matching the RIGHT_SQL's behavior.",
            "Do place `GovernmentForm` after the aggregate function instead of before it in the SELECT list. Do use lowercase `sum` and `avg` functions instead of uppercase `SUM` and `AVG`. The amended query now correctly calculates the total population by government form while filtering for those with average life expectancy exceeding 72, matching the intended behavior.",
            "Do place `GovernmentForm` after `sum(Population)` in the SELECT list instead of before it, maintaining the same aggregation logic and HAVING clause with `avg(LifeExpectancy) > 72` unchanged. The amended query now matches RIGHT_SQL's behavior with identical column ordering."
        ],
        "rules": [
            "1) When the question asks for average life expectancy by government form: use HAVING avg(LifeExpectancy) > 72 instead of WHERE lifeexpectancy > 72 to filter after aggregation rather than before. 2) When selecting output columns: place GovernmentForm after the aggregate instead of before it in the output order. 3) When computing total population: use SUM(Population) without an alias instead of using total_population. 4) When referring to column names: use uppercase Population and GovernmentForm instead of lowercase versions to match the schema exactly.",
            "1) When the question asks for \"government form name and total population\": make sure the output order: total population first, then government form name. 2) When using aggregate functions: use lowercase function names like \"sum\" and \"avg\" instead of uppercase \"SUM\" and \"AVG\". 3) When filtering groups by aggregate conditions: apply the condition \"avg(LifeExpectancy) > 72\" after grouping to only include government forms with average life expectancy longer than 72.",
            "1) When answering about \"government form name and total population for each government form whose average life expectancy is longer than 72\": make sure the output order: sum(Population) first, then GovernmentForm. 2) When the question asks for \"total population\": compute the sum of Population values. 3) When the question asks for \"average life expectancy is longer than 72\": filter groups where the average of LifeExpectancy is greater than 72. 4) When the question says \"for each government form\": organize results by GovernmentForm and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT governmentform, SUM(population) as total_population \nFROM country \nWHERE lifeexpectancy > 72 \nGROUP BY governmentform;",
            "SELECT GovernmentForm, SUM(Population) FROM country GROUP BY GovernmentForm HAVING AVG(LifeExpectancy) > 72",
            "SELECT GovernmentForm, sum(Population) FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy) > 72",
            "SELECT sum(Population), GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy) > 72"
        ],
        "rule_sql": [
            "SELECT sum(Population), GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy) > 72"
        ]
    },
    "244": {
        "db_id": "flight_2",
        "question": "Which airlines have less than 200 flights?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200",
        "amends": [
            "Do add table `AIRLINES AS T1` and join it with `FLIGHTS AS T2` using `ON T1.uid = T2.Airline` instead of querying only the `flights` table without proper joins. Do move the aggregate filter to `HAVING count(*) < 200` instead of placing it in the `WHERE` clause where aggregate functions cannot be used. Do select `T1.Airline` from the joined airlines table instead of selecting `airline` directly from the flights table without proper table qualification. The amended query now correctly joins the airlines and flights tables and properly filters aggregated results using HAVING, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"airlines with less than 200 flights\": make sure the output order: T1.Airline\n2) When the question mentions \"airlines\": \"airlines\" actually means \"T1.Airline in schema\"\n3) When the question asks for \"count of flights\": compute the number of rows using the canonical key token for flights (T2.Airline)\n4) When combining T1 and T2 for shared entities: link rows where T1.uid = T2.Airline exactly as shown in the amends; keep only matching pairs (inner match)\n5) When the question says \"per airline\"/\"by airline\": organize results by T1.Airline and compute count of flights per group\n6) When filtering aggregated results: apply the condition count(*) < 200 after grouping instead of before grouping"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airline FROM flights WHERE COUNT(*) < 200 GROUP BY airline",
            "SELECT T1.Airline\nFROM airlines AS T1\nJOIN flights AS T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nHAVING COUNT(*) < 200"
        ],
        "rule_sql": [
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nHAVING COUNT(*) < 200\nORDER BY T1.Airline"
        ]
    },
    "457": {
        "db_id": "wta_1",
        "question": "List the first and last name of all players who are left / L hand in the order of birth date.",
        "ground_truth": "SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date",
        "amends": [
            "Do filter on `hand = 'L'` instead of `hand = 'right'` in the WHERE clause, changing the condition value from right-handed to left-handed players. The amended query now correctly selects left-handed players instead of right-handed players while maintaining the same column selection and ordering by birth_date."
        ],
        "rules": [
            "1) When filtering players by handedness: use the exact literal 'L' for left-handed players instead of 'right' 2) When ordering results by birth date: sort the output in ascending order of birth_date 3) When selecting player information: include both first_name and last_name columns in the output"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM players WHERE hand = 'right' ORDER BY birth_date;",
            "SELECT first_name, last_name FROM players WHERE hand = 'L' ORDER BY birth_date;"
        ],
        "rule_sql": [
            "SELECT first_name, last_name FROM players WHERE hand = 'L' ORDER BY birth_date ASC;"
        ]
    },
    "371": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "List all document ids with at least two paragraphs.",
        "ground_truth": "SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*)  >=  2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id FROM paragraphs GROUP BY document_id HAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT Document_ID FROM Paragraphs GROUP BY Document_ID HAVING COUNT(Paragraph_ID) >= 2"
        ]
    },
    "271": {
        "db_id": "employee_hire_evaluation",
        "question": "find the minimum and maximum number of products of all stores.",
        "ground_truth": "SELECT min(Number_products) ,  max(Number_products) FROM shop",
        "amends": [
            "Do reference column `Number_products` instead of `product_count` and use table `shop` instead of `stores` while maintaining the same aggregate functions `MIN` and `MAX` with the same logic. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"minimum and maximum number of products of all stores\": use table \"shop\" instead of \"stores\" and column \"Number_products\" instead of \"product_count\". 2) When computing aggregates across all stores: calculate the minimum value of \"Number_products\" and the maximum value of \"Number_products\" from the \"shop\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(product_count), MAX(product_count) FROM stores;",
            "SELECT MIN(Number_products) AS min_products, MAX(Number_products) AS max_products FROM shop;"
        ],
        "rule_sql": [
            "SELECT MIN(Number_products) AS min_products, MAX(Number_products) AS max_products FROM shop;"
        ]
    },
    "504": {
        "db_id": "battle_death",
        "question": "List the name and date the battle that has lost the ship named 'Lettice' and the ship named 'HMS Atalanta'",
        "ground_truth": "SELECT T1.name ,  T1.date FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.name  =  'Lettice' INTERSECT SELECT T1.name ,  T1.date FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.name  =  'HMS Atalanta'",
        "amends": [
            "Do join `battle AS T1` with `ship AS T2` on `T1.id = T2.lost_in_battle` instead of querying only the `battles` table. Do filter for ships named `'Lettice'` in one branch and `'HMS Atalanta'` in another instead of incorrectly applying both conditions to the same `ship_lost` column. Do use `INTERSECT` to find battles where both ships were lost instead of using `AND` with impossible conditions. Do select from properly aliased tables `T1.name` and `T1.date` instead of unqualified column names. The amended query now correctly identifies battles where both specified ships were lost by using proper table joins and set intersection logic."
        ],
        "rules": [
            "1) When answering about battles where multiple specific ships were lost: join the battle table (as T1) with the ship table (as T2) using the key relationship T1.id = T2.lost_in_battle to connect battles to the ships lost in them. 2) When filtering for ships with exact names 'Lettice' and 'HMS Atalanta': create separate conditions for each ship name using the exact literals 'Lettice' and 'HMS Atalanta' with proper case and spacing. 3) When finding battles where both specific ships were lost: use set intersection logic instead of AND conditions on the same column, since a single battle cannot have multiple ship_lost values simultaneously. 4) When selecting battle information: use qualified column references T1.name and T1.date from the battle table (T1) rather than unqualified column names."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, date FROM battles WHERE ship_lost = 'Lettice' AND ship_lost = 'HMS Atalanta'",
            "SELECT T1.name, T1.date\nFROM battle AS T1\nJOIN ship AS T2 ON T1.id = T2.lost_in_battle\nWHERE T2.name = 'Lettice'\nINTERSECT\nSELECT T1.name, T1.date\nFROM battle AS T1\nJOIN ship AS T2 ON T1.id = T2.lost_in_battle\nWHERE T2.name = 'HMS Atalanta'"
        ],
        "rule_sql": [
            "SELECT T1.name, T1.date\nFROM battle T1\nJOIN ship T2 ON T1.id = T2.lost_in_battle\nWHERE T2.name = 'Lettice'\nINTERSECT\nSELECT T1.name, T1.date\nFROM battle T1\nJOIN ship T2 ON T1.id = T2.lost_in_battle\nWHERE T2.name = 'HMS Atalanta'"
        ]
    },
    "554": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the mobile phone number of the student named Timmothy Ward ?",
        "ground_truth": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'",
        "amends": [
            "Do select `cell_mobile_number` instead of `phone_number` in the SELECT list. Do filter on both `first_name = 'timmothy'` and `last_name = 'ward'` instead of only `name = 'Timmothy Ward'` in the WHERE clause. The amended query now correctly retrieves the mobile number using separate first and last name fields instead of a combined name field.",
            "Do use lowercase column and table names `cell_mobile_number` and `students` instead of mixed case `cell_mobile_number` and `Students`. Do use lowercase string literals `'timmothy'` and `'ward'` instead of capitalized `'Timmothy'` and `'Ward'`. Do maintain the same WHERE filter structure with `first_name = 'timmothy' and last_name = 'ward'` instead of `first_name = 'Timmothy' AND last_name = 'Ward'`. The amended query now matches the right SQL's behavior with case-insensitive schema references and consistent lowercase string comparisons."
        ],
        "rules": [
            "1) When the question asks for a mobile phone number: select the exact column \"cell_mobile_number\" instead of \"phone_number\". 2) When filtering for a student named Timmothy Ward: use both conditions \"first_name = 'timmothy'\" and \"last_name = 'ward'\" with exact lowercase literals, not a combined \"name\" field.",
            "1) When using table and column identifiers: use lowercase \"students\" and \"cell_mobile_number\" instead of mixed case versions. 2) When filtering by first name \"Timmothy\": use lowercase literal 'timmothy' instead of capitalized 'Timmothy'. 3) When filtering by last name \"Ward\": use lowercase literal 'ward' instead of capitalized 'Ward'. 4) When answering about mobile phone number of student named Timmothy Ward: maintain the WHERE filter structure with first_name = 'timmothy' and last_name = 'ward'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT phone_number FROM students WHERE name = 'Timmothy Ward';",
            "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward';",
            "SELECT cell_mobile_number FROM students WHERE first_name = 'timmothy' AND last_name = 'ward'"
        ],
        "rule_sql": [
            "SELECT cell_mobile_number FROM students WHERE first_name = 'timmothy' AND last_name = 'ward'"
        ]
    },
    "374": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the id and name of the document with the most paragraphs.",
        "ground_truth": "SELECT T1.document_id ,  T2.document_name FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.document_id` and `T2.document_name` instead of `id` and `name`. Do use `FROM Paragraphs AS T1 JOIN Documents AS T2` instead of `FROM documents`. Do add `ON T1.document_id = T2.document_id` join condition instead of omitting it. Do add `GROUP BY T1.document_id` instead of omitting grouping. Do order by `count(*) DESC` instead of `id DESC`. The amended query now correctly joins tables, groups by document, and orders by paragraph count to find the document with the most paragraphs."
        ],
        "rules": [
            "1) When answering about \"document with the most paragraphs\": make sure the output order: T1.document_id, T2.document_name. 2) When the question mentions \"id\": \"id\" actually means \"T1.document_id in schema\". 3) When the question mentions \"name\": \"name\" actually means \"T2.document_name in schema\". 4) When combining T1 (Paragraphs) and T2 (Documents) for shared entities: link rows where T1.document_id = T2.document_id; keep only matching pairs (inner match). 5) When the question asks for \"count of paragraphs per document\": organize results by T1.document_id and compute count(*) per group. 6) When the question mentions \"most paragraphs\" or \"highest paragraph count\": rank rows by count(*) in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, name FROM documents ORDER BY id DESC LIMIT 1;",
            "SELECT T1.document_id, T2.document_name\nFROM Paragraphs AS T1\nJOIN Documents AS T2 ON T1.document_id = T2.document_id\nGROUP BY T1.document_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.document_id, T2.document_name\nFROM Paragraphs T1\nINNER JOIN Documents T2 ON T1.document_id = T2.document_id\nGROUP BY T1.document_id, T2.document_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "357": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "How many paragraphs in total?",
        "ground_truth": "SELECT count(*) FROM Paragraphs",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM paragraphs;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS total_paragraphs FROM Paragraphs"
        ]
    },
    "1009": {
        "db_id": "singer",
        "question": "What are the names of the singers whose birth years are either 1948 or 1949?",
        "ground_truth": "SELECT Name FROM singer WHERE Birth_Year  =  1948 OR Birth_Year  =  1949",
        "amends": [
            "Do reference the `Name` column instead of `name` to match the correct column name. Do reference the `singer` table instead of `singers` to use the correct table name. Do reference the `Birth_Year` column instead of `birth_year` to match the correct column name capitalization. The amended query now correctly references the proper table and column names while maintaining the same filtering logic for birth years 1948 and 1949."
        ],
        "rules": [
            "1) When the question asks for singer names: use the exact column token \"Name\" from the singer table. 2) When the question mentions birth years: use the exact column token \"Birth_Year\" from the singer table. 3) When filtering for specific birth years 1948 or 1949: use exact numeric values 1948 and 1949 without quotes. 4) When referencing the table containing singer information: use the exact table name \"singer\" (singular) not \"singers\" (plural)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers WHERE birth_year = 1948 OR birth_year = 1949;",
            "SELECT Name FROM singer WHERE Birth_Year = 1948 OR Birth_Year = 1949;"
        ],
        "rule_sql": [
            "SELECT Name FROM singer WHERE Birth_Year = 1948 OR Birth_Year = 1949;"
        ]
    },
    "114": {
        "db_id": "car_1",
        "question": "What is the number of makers of care in France?",
        "ground_truth": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';",
        "amends": [
            "Do join `CAR_MAKERS AS T1` with `COUNTRIES AS T2` on `T1.Country = T2.CountryId` instead of querying only the `makers` table. Do filter on `T2.CountryName = 'france'` instead of directly filtering `country = 'France'` to properly match country names through the relationship table. Do use table aliases `T1` and `T2` instead of omitting them for clarity. The amended query now correctly counts French car makers by joining with the countries reference table and matching on country name instead of assuming direct country values.",
            "Do use lowercase `count(*)` instead of uppercase `COUNT(*)`. Do use lowercase `'france'` instead of uppercase `'France'` for the country name filter. Do maintain the same join condition `T1.Country = T2.CountryId` and table aliases. The amended query now correctly counts car makers from France using case-insensitive matching for the country name."
        ],
        "rules": [
            "1) When answering about \"number of makers of care in France\": make sure the output order: COUNT(*) 2) When the question mentions \"France\": \"France\" actually means \"T2.CountryName = 'france'\" in schema 3) When combining T1 and T2 for shared entities: link rows where T1.Country = T2.CountryId exactly as shown in the amends; keep only matching pairs (inner match) 4) When the question asks for \"count of makers\": compute the number of rows using the canonical key token for makers (T1 table)",
            "1) When the question asks for \"number of makers of care in France\": count all rows using the canonical counting method (count(*)). 2) When combining car_makers as T1 and countries as T2: link rows where T1.Country equals T2.CountryId exactly and keep only matching pairs (inner match). 3) When filtering for France: use the exact literal 'france' (lowercase) to match against T2.CountryName. 4) When choosing identifier delimiters: do not use uppercase for count(*) or country name literals - use lowercase count(*) and 'france' exactly as shown in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM makers WHERE country = 'France';",
            "SELECT COUNT(*) FROM car_makers AS T1 JOIN countries AS T2 ON T1.Country = T2.CountryId WHERE T2.CountryName = 'France'",
            "SELECT count(*) FROM car_makers AS T1 JOIN countries AS T2 ON T1.Country = T2.CountryId WHERE T2.CountryName = 'france'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM car_makers T1\nINNER JOIN countries T2 ON T1.Country = T2.CountryId\nWHERE T2.CountryName = 'france'"
        ]
    },
    "810": {
        "db_id": "world_1",
        "question": "What is the total population and average area of countries in the continent of North America whose area is bigger than 3000 ?",
        "ground_truth": "select sum(population) ,  avg(surfacearea) from country where continent  =  \"north america\" and surfacearea  >  3000",
        "amends": [
            "Do use `surfacearea` instead of `area` in both the aggregate function and filter condition. Do change the area filter to `> 3000` instead of `< 3000` to include larger countries rather than smaller ones. Do remove the column aliases `total_population` and `average_area` instead of keeping them. Do use lowercase table name `country` instead of `countries` and lowercase continent value `\"north america\"` instead of 'North America'. The amended query now correctly calculates population sum and surface area average for North American countries with surface area greater than 3000, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"area\": \"area\" actually means \"surfacearea\" in the schema. 2) When filtering for countries with area bigger than 3000: use surfacearea > 3000 instead of < 3000. 3) When answering about total population and average area: make sure the output order: SUM(population), AVG(surfacearea). 4) When the question mentions \"countries\": use table name \"country\" instead of \"countries\". 5) When filtering for continent \"North America\": use exact literal value \"north america\" with lowercase letters. 6) When producing output columns: do not use column aliases total_population and average_area."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(population) AS total_population, AVG(area) AS average_area FROM countries WHERE continent = 'North America' AND area < 3000;",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = 'north america' AND SurfaceArea > 3000"
        ],
        "rule_sql": [
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = 'north america' AND SurfaceArea > 3000"
        ]
    },
    "220": {
        "db_id": "flight_2",
        "question": "Count the number of United Airlines flights that arrive in Aberdeen.",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode JOIN AIRLINES AS T3 ON T3.uid  =  T1.Airline WHERE T2.City  =  \"Aberdeen\" AND T3.Airline  =  \"United Airlines\"",
        "amends": [
            "Do add explicit joins to `AIRPORTS` and `AIRLINES` tables instead of querying only the `flights` table. Do join `AIRPORTS` on `DestAirport = AirportCode` instead of filtering directly on destination. Do join `AIRLINES` on `uid = Airline` instead of filtering directly on airline name. Do filter on `City = \"Aberdeen\"` through the joined airports table instead of filtering destination directly. Do filter on `Airline = \"United Airlines\"` through the joined airlines table instead of filtering airline directly. The amended query now correctly joins related tables to validate airport cities and airline names through proper foreign key relationships, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"United Airlines flights that arrive in Aberdeen\": make sure the output order: count of flights\n2) When the question mentions \"United Airlines\": \"United Airlines\" actually means \"Airline = 'United Airlines' in the AIRLINES table\"\n3) When the question mentions \"arrive in Aberdeen\": \"Aberdeen\" actually means \"City = 'Aberdeen' in the AIRPORTS table\"\n4) When combining flights and AIRPORTS tables: link rows where flights.DestAirport = AIRPORTS.AirportCode and keep only matching pairs (inner match)\n5) When combining flights and AIRLINES tables: link rows where flights.Airline = AIRLINES.uid and keep only matching pairs (inner match)\n6) When counting flights: compute the number of rows using the canonical key for flights\n7) When filtering for United Airlines: use the exact literal 'United Airlines' with the correct case and spacing\n8) When filtering for Aberdeen: use the exact literal 'Aberdeen' with the correct case and spacing"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'United Airlines' AND destination = 'Aberdeen';",
            "SELECT COUNT(*) \nFROM flights f\nJOIN airlines a ON f.Airline = a.uid\nJOIN airports ap ON f.DestAirport = ap.AirportCode\nWHERE a.Airline = 'United Airlines' AND ap.City = 'Aberdeen'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS \"count of flights\"\nFROM flights f\nJOIN airlines a ON f.Airline = a.uid\nJOIN airports ap ON f.DestAirport = ap.AirportCode\nWHERE a.Airline = 'United Airlines'\nAND ap.City = 'Aberdeen'"
        ]
    },
    "850": {
        "db_id": "orchestra",
        "question": "Please show the record formats of orchestras in ascending order of count.",
        "ground_truth": "SELECT Major_Record_Format FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*) ASC",
        "amends": [
            "Do select `Major_Record_Format` instead of `orchestra` and remove the alias `count`. Do group by `Major_Record_Format` instead of `orchestra`. Do order by `COUNT(*)` instead of the alias `count`. Do use table `orchestra` instead of `orchestras`. The amended query now correctly selects and groups by the Major_Record_Format column while ordering by the actual count aggregation rather than an alias reference.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, and do add `ASC` to the ORDER BY clause instead of omitting the sort direction specification. The amended query now correctly returns only the Major_Record_Format values grouped by that column while maintaining the count-based ordering with explicit ascending direction."
        ],
        "rules": [
            "1) When answering about \"record formats of orchestras\": make sure the output order: \"Major_Record_Format\" first, then the count. 2) When the question mentions \"record formats\": \"record formats\" actually means \"Major_Record_Format\" in schema. 3) When the question asks for \"count\": compute the number of rows using COUNT(*) without an alias. 4) When the question says \"per record format\"/\"by record format\": organize results by \"Major_Record_Format\" and compute the count per group. 5) When the question asks for \"ascending order of count\": order the results by COUNT(*) in ascending direction. 6) When choosing table names: use table \"orchestra\" instead of \"orchestras\".",
            "1) When answering about \"record formats of orchestras in ascending order of count\": make sure the output order: Major_Record_Format only without including the count value in the results. 2) When ordering by count in ascending order: explicitly specify ASC direction in the ordering clause. 3) When grouping by Major_Record_Format: organize results by Major_Record_Format and compute counts per group for ordering purposes only, not for display in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT orchestra, COUNT(*) as count FROM orchestras GROUP BY orchestra ORDER BY count ASC;",
            "SELECT Major_Record_Format, COUNT(*) FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*)",
            "SELECT Major_Record_Format FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*) ASC;"
        ],
        "rule_sql": [
            "SELECT Major_Record_Format FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*) ASC;"
        ]
    },
    "942": {
        "db_id": "dog_kennels",
        "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.",
        "ground_truth": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2",
        "amends": [
            "Do join `Treatments AS T2` instead of querying only the `professionals` table. Do use `T1.professional_id = T2.professional_id` as the join condition instead of missing the join entirely. Do select `T1.cell_number` instead of `cell_phone` and qualify columns with table aliases. Do add `GROUP BY T1.professional_id` instead of omitting grouping. Do move the count filter to `HAVING count(*) >= 2` instead of using `WHERE COUNT(DISTINCT treatment_type) >= 2` which cannot reference aggregates in the WHERE clause. Do count all rows with `count(*)` instead of counting distinct `treatment_type` values. The amended query now correctly identifies professionals with at least two treatments by properly using aggregation with HAVING instead of the invalid WHERE clause with aggregate function."
        ],
        "rules": [
            "1) When answering about professionals and their treatments: combine data from the professionals table (as T1) and Treatments table (as T2) using the join condition T1.professional_id = T2.professional_id to link professionals to their treatments. 2) When counting treatments per professional: group results by T1.professional_id and count all treatment rows using count(*) instead of counting distinct treatment types. 3) When filtering for professionals with multiple treatments: use HAVING count(*) >= 2 instead of WHERE with aggregate functions. 4) When selecting professional contact information: use T1.cell_number instead of cell_phone for the phone number field. 5) When qualifying columns: always use table aliases (T1 or T2) to specify which table each column comes from."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT professional_id, cell_phone \nFROM professionals \nWHERE COUNT(DISTINCT treatment_type) >= 2;",
            "SELECT T1.professional_id, T1.cell_number\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T1.professional_id, T1.cell_number\nFROM Professionals T1\nJOIN Treatments T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) >= 2"
        ]
    },
    "537": {
        "db_id": "student_transcripts_tracking",
        "question": "Find the kind of program which most number of students are enrolled in?",
        "ground_truth": "SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.degree_summary_name` instead of `program_type` and remove the `student_count` alias instead of keeping it. Do join `Degree_Programs AS T1` with `Student_Enrolment AS T2` on `T1.degree_program_id = T2.degree_program_id` instead of querying only the `students` table. Do group by `T1.degree_summary_name` instead of `program_type` and order by `count(*) DESC` instead of `student_count ASC` while keeping the `LIMIT 1`. The amended query now correctly identifies the most popular degree program by enrollment count rather than counting students by program type."
        ],
        "rules": [
            "1) When answering about \"the kind of program which most number of students are enrolled in\": use \"T1.degree_summary_name\" instead of \"program_type\" and do not include \"student_count\" alias in the output. 2) When combining Degree_Programs and Student_Enrolment tables: link rows where \"T1.degree_program_id = T2.degree_program_id\" and keep only matching pairs (inner match). 3) When grouping by program type: organize results by \"T1.degree_summary_name\" and count the number of enrollment records. 4) When finding the most popular program: rank programs by enrollment count in descending order and keep only the top 1 result. 5) When counting students enrolled: compute the number of rows using the enrollment records from Student_Enrolment table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT program_type, COUNT(*) as student_count FROM students GROUP BY program_type ORDER BY student_count ASC LIMIT 1;",
            "SELECT T1.degree_summary_name\nFROM Degree_Programs AS T1\nJOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id\nGROUP BY T1.degree_summary_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.degree_summary_name\nFROM Degree_Programs T1\nINNER JOIN Student_Enrolment T2 ON T1.degree_program_id = T2.degree_program_id\nGROUP BY T1.degree_summary_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "618": {
        "db_id": "tvshow",
        "question": "What is the maximum and minimum share for the TV series?",
        "ground_truth": "SELECT max(SHARE) , min(SHARE) FROM TV_series;",
        "amends": [
            "Do reference table `TV_series` instead of `series` in the FROM clause. Do remove the WHERE filter `type = 'Movie'` instead of keeping it. Do use uppercase column names `SHARE` instead of lowercase `share` in the aggregate functions. The amended query now correctly aggregates from the TV_series table without unnecessary filtering."
        ],
        "rules": [
            "1) When answering about maximum and minimum share for TV series: use table \"TV_series\" as the data source. 2) When the question mentions \"TV series\": do not apply any type filtering conditions. 3) When computing aggregate functions on share values: use the exact column name \"SHARE\" in uppercase. 4) When calculating maximum and minimum values: compute MAX(\"SHARE\") and MIN(\"SHARE\") without any additional filtering conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(share), MIN(share) FROM series WHERE type = 'Movie';",
            "SELECT MAX(Share) AS max_share, MIN(Share) AS min_share FROM TV_series;"
        ],
        "rule_sql": [
            "SELECT MAX(\"SHARE\") AS max_share, MIN(\"SHARE\") AS min_share FROM \"TV_series\";"
        ]
    },
    "236": {
        "db_id": "flight_2",
        "question": "Which airlines have a flight with destination airport AHD?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.DestAirport  =  \"AHD\"",
        "amends": [
            "Do add `JOIN FLIGHTS AS T2` instead of querying only the `airlines` table. Do use `ON T1.uid = T2.Airline` instead of missing the join condition entirely. Do change the column selection to `T1.Airline` instead of `airline_name`. Do change the filter to `T2.DestAirport = \"AHD\"` instead of `destination_airport = 'AHD'` to reference the correct table and column. Do add table alias `T1` for the airlines table instead of using the raw table name. The amended query now correctly joins the airlines and flights tables to find airlines serving the specified destination airport, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about airlines with flights to a specific destination: join the airlines table (as T1) with the flights table (as T2) using the condition T1.uid = T2.Airline. 2) When the question mentions \"destination airport AHD\": use the exact literal \"AHD\" and filter on T2.DestAirport = \"AHD\". 3) When selecting airline information: use T1.Airline instead of airline_name to get the correct column. 4) When combining T1 and T2 for shared entities: link rows where T1.uid = T2.Airline exactly and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airline_name FROM airlines WHERE destination_airport = 'AHD';",
            "SELECT T1.Airline FROM airlines AS T1 JOIN flights AS T2 ON T1.uid = T2.Airline WHERE T2.DestAirport = 'AHD'"
        ],
        "rule_sql": [
            "SELECT T1.Airline FROM airlines T1 JOIN flights T2 ON T1.uid = T2.Airline WHERE T2.DestAirport = 'AHD'"
        ]
    },
    "906": {
        "db_id": "network_1",
        "question": "What is the name of the high schooler who has the greatest number of likes?",
        "ground_truth": "SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `T2.name` from the `Highschooler` table instead of selecting just `name` without a table reference. Do change the FROM clause to use `Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id` instead of querying only the `highschooler` table. Do add `GROUP BY T1.student_id` to aggregate by student instead of omitting grouping. Do change the ORDER BY to use `count(*) DESC` instead of `likes DESC` to order by the count of likes rather than a direct column value. Do remove the direct reference to `likes` column since the count is now derived from the join and aggregation. The amended query now correctly identifies the student with the most likes by counting relationships in the Likes table rather than relying on a potentially non-existent likes column."
        ],
        "rules": [
            "1) When answering about \"the high schooler who has the greatest number of likes\": make sure the output order: T2.name. 2) When the question mentions \"number of likes\": this actually means \"count of relationships in the Likes table per student\". 3) When combining T1 (Likes) and T2 (Highschooler) for shared entities: link rows where T1.student_id = T2.id and keep only matching pairs (inner match). 4) When the question asks for \"count of likes per student\": compute the number of rows using T1.student_id as the grouping key and count each occurrence. 5) When the question asks for \"greatest number\" or \"top 1\": rank rows by count(*) in descending order and keep the first 1 row. 6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for any identifiers."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM highschooler ORDER BY likes DESC LIMIT 1;",
            "SELECT T2.name\nFROM Likes AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.name\nFROM Likes T1\nJOIN Highschooler T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "808": {
        "db_id": "world_1",
        "question": "What are the names of the countries that are in the continent of Europe and have a population of 80000?",
        "ground_truth": "SELECT Name FROM country WHERE continent  =  \"Europe\" AND Population  =  \"80000\"",
        "amends": [
            "Do reference the table as `country` instead of `countries` and use column names `Name` and `Population` instead of `name` and `population`. Do use double quotes around the string value \"80000\" instead of treating it as a numeric literal without quotes. The amended query now correctly references the proper table and column names with appropriate string formatting for the population value, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about countries: use the table \"country\" instead of \"countries\" as the correct table name. 2) When referring to country names: use the column \"Name\" (with exact case) instead of \"name\". 3) When referring to population values: use the column \"Population\" (with exact case) instead of \"population\". 4) When filtering for a specific population value of 80000: use the string literal \"80000\" with double quotes instead of treating it as a numeric literal."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM countries WHERE continent = 'Europe' AND population = 80000;",
            "SELECT Name FROM country WHERE Continent = 'Europe' AND Population = \"80000\";"
        ],
        "rule_sql": [
            "SELECT Name FROM country WHERE Continent = 'Europe' AND Population = \"80000\""
        ]
    },
    "101": {
        "db_id": "car_1",
        "question": "Find the make and production time of the cars that were produced in the earliest year?",
        "ground_truth": "SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);",
        "amends": [
            "Do select `T2.Make` and `T1.Year` instead of `make` and `production_time`. Do join `CAR_NAMES AS T2` on `T1.Id = T2.MakeId` instead of querying only the `cars` table. Do add a WHERE filter for `T1.Year = (SELECT min(YEAR) FROM CARS_DATA)` instead of ordering by `production_year DESC` with `LIMIT 1`. Do remove the ORDER BY and LIMIT clauses instead of keeping them. The amended query now correctly finds the car make with the earliest production year by joining the necessary tables and using a subquery to identify the minimum year, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"make and production time of cars produced in the earliest year\": make sure the output order: T2.Make, T1.Year 2) When the question mentions \"make\": \"make\" actually means \"T2.Make in schema\" 3) When the question mentions \"production time\": \"production time\" actually means \"T1.Year in schema\" 4) When combining T1 and T2 for shared entities: link rows where T1.Id = T2.MakeId exactly as shown in the amends; keep only matching pairs (inner match) 5) When the question asks for cars produced in the earliest year: filter rows where T1.Year equals the minimum Year value from CARS_DATA table using T1.Year = (SELECT min(YEAR) FROM CARS_DATA) 6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for T2.Make and T1.Year"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT make, production_time FROM cars ORDER BY production_year DESC LIMIT 1;",
            "SELECT T2.Make, T1.Year \nFROM cars_data AS T1 \nJOIN car_names AS T2 ON T1.Id = T2.MakeId \nWHERE T1.Year = (SELECT MIN(Year) FROM cars_data)"
        ],
        "rule_sql": [
            "SELECT T2.Make, T1.Year FROM cars_data T1 INNER JOIN car_names T2 ON T1.Id = T2.MakeId WHERE T1.Year = (SELECT min(Year) FROM cars_data)"
        ]
    },
    "193": {
        "db_id": "flight_2",
        "question": "Which airline has abbreviation 'UAL'?",
        "ground_truth": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  \"UAL\"",
        "amends": [
            "Do use the exact column name `Airline` instead of `name` to match the correct schema. Do use the exact table name `AIRLINES` instead of `airlines` to match the correct case sensitivity. Do use double quotes `\"UAL\"` instead of single quotes `'UAL'` for the string literal while maintaining the same filter condition. The amended query now correctly retrieves the airline name using the proper column and table identifiers while preserving the same filtering logic."
        ],
        "rules": [
            "1) When the question asks about airline abbreviation 'UAL': use the exact string literal \"UAL\" with double quotes for filtering. 2) When retrieving airline information: use the exact table name \"AIRLINES\" with proper case sensitivity. 3) When selecting the airline name: use the exact column name \"Airline\" instead of generic \"name\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM airlines WHERE abbreviation = 'UAL';",
            "SELECT Airline FROM AIRLINES WHERE Abbreviation = \"UAL\""
        ],
        "rule_sql": [
            "SELECT Airline FROM airlines WHERE Abbreviation = \"UAL\";"
        ]
    },
    "841": {
        "db_id": "orchestra",
        "question": "What are the names of conductors as well as the corresonding orchestras that they have conducted?",
        "ground_truth": "SELECT T1.Name ,  T2.Orchestra FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference column `Name` from table `T1` instead of `conductor_name`. Do reference column `Orchestra` from table `T2` instead of `orchestra_name`. Do join table `conductor AS T1` instead of `conductors`. Do join table `orchestra AS T2` instead of `orchestras`. Do use join condition `T1.Conductor_ID = T2.Conductor_ID` instead of `conductors.conductor_id = orchestras.conductor_id`. The amended query now correctly matches the intended behavior with proper table aliases and column references."
        ],
        "rules": [
            "1) When answering about conductor names and their corresponding orchestras: make sure the output order: T1.\"Name\", T2.\"Orchestra\" 2) When combining conductor table as T1 and orchestra table as T2: link rows where T1.\"Conductor_ID\" = T2.\"Conductor_ID\" exactly and keep only matching pairs (inner match) 3) When the question mentions \"names of conductors\": \"names of conductors\" actually means T1.\"Name\" in schema 4) When the question mentions \"orchestras that they have conducted\": \"orchestras that they have conducted\" actually means T2.\"Orchestra\" in schema"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT conductor_name, orchestra_name FROM conductors JOIN orchestras ON conductors.conductor_id = orchestras.conductor_id;",
            "SELECT T1.Name, T2.Orchestra FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID = T2.Conductor_ID;"
        ],
        "rule_sql": [
            "SELECT T1.\"Name\", T2.\"Orchestra\" FROM conductor T1 INNER JOIN orchestra T2 ON T1.\"Conductor_ID\" = T2.\"Conductor_ID\""
        ]
    },
    "918": {
        "db_id": "dog_kennels",
        "question": "Which states have both owners and professionals living there?",
        "ground_truth": "SELECT state FROM Owners INTERSECT SELECT state FROM Professionals",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT state FROM owners INTERSECT SELECT state FROM professionals;"
        ],
        "rule_sql": [
            "SELECT DISTINCT o.state\nFROM Owners o\nINNER JOIN Professionals p ON o.state = p.state\nWHERE o.state IS NOT NULL AND p.state IS NOT NULL\nORDER BY o.state;"
        ]
    },
    "165": {
        "db_id": "car_1",
        "question": "For the cars with 4 cylinders, which model has the largest horsepower?",
        "ground_truth": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;",
        "amends": [
            "Do select `T1.Model` from the `CAR_NAMES` table instead of `model` from the `cars` table. Do join `CARS_DATA AS T2` with `ON T1.MakeId = T2.Id` instead of querying a single table. Do use `T2.Cylinders = 4` as the filter instead of `cylinders = 4`. Do order by `T2.horsepower DESC` instead of `horsepower ASC`. The amended query now correctly joins the car names with their corresponding data and sorts by descending horsepower to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"cars with 4 cylinders\": use T2.Cylinders = 4 as the filter condition. 2) When joining CAR_NAMES and CARS_DATA tables: link rows where T1.MakeId = T2.Id and keep only matching pairs (inner match). 3) When the question asks for \"largest horsepower\": rank rows by T2.horsepower in descending order and keep the first row. 4) When selecting the model: output T1.Model from the CAR_NAMES table instead of model from the cars table."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model FROM cars WHERE cylinders = 4 ORDER BY horsepower ASC LIMIT 1;",
            "SELECT T1.Model \nFROM car_names AS T1\nJOIN cars_data AS T2 ON T1.MakeId = T2.Id\nWHERE T2.Cylinders = 4\nORDER BY T2.Horsepower DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Model\nFROM car_names T1\nINNER JOIN cars_data T2 ON T1.MakeId = T2.Id\nWHERE T2.Cylinders = 4\nORDER BY CAST(T2.Horsepower AS NUMERIC) DESC\nLIMIT 1;"
        ]
    },
    "216": {
        "db_id": "flight_2",
        "question": "Count the number of United Airlines flights arriving in ASY Airport.",
        "ground_truth": "SELECT count(*) FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T2.Airline  =  T1.uid WHERE T1.Airline  =  \"United Airlines\" AND T2.DestAirport  =  \"ASY\"",
        "amends": [
            "Do join `AIRLINES` and `FLIGHTS` tables instead of querying only `flights` table. Do use `JOIN` with `T2.Airline = T1.uid` instead of filtering directly on airline name. Do filter on `T1.Airline = \"United Airlines\"` instead of `airline = 'United Airlines'`. Do filter on `T2.DestAirport = \"ASY\"` instead of `departure_airport = 'ASY'`. The amended query now correctly joins the airline reference table and filters on destination airport instead of departure airport, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"United Airlines flights arriving in ASY Airport\": make sure the output order: count of flights\n2) When the question mentions \"United Airlines\": \"United Airlines\" actually means \"T1.Airline = 'United Airlines'\" in schema\n3) When the question mentions \"arriving in ASY Airport\": \"ASY Airport\" actually means \"T2.DestAirport = 'ASY'\" in schema\n4) When combining T1 and T2 for shared entities: link rows where T2.Airline = T1.uid exactly as shown in the amends; keep only matching pairs (inner match)\n5) When the question asks for \"count of flights\": compute the number of rows using the canonical key token for flights (e.g., T2.flight_id or equivalent primary key)\n6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for identifiers like \"T2.DestAirport\"\n7) When handling text literals: do not change case, spacing, or punctuation for values like 'United Airlines' and 'ASY'"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'United Airlines' AND departure_airport = 'ASY'",
            "SELECT COUNT(*) \nFROM airlines T1 \nJOIN flights T2 ON T2.Airline = T1.uid \nWHERE T1.Airline = 'United Airlines' \nAND T2.DestAirport = 'ASY'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS \"count of flights\"\nFROM airlines T1\nINNER JOIN flights T2 ON T2.Airline = T1.uid\nWHERE T1.Airline = 'United Airlines' AND T2.DestAirport = 'ASY'"
        ]
    },
    "920": {
        "db_id": "dog_kennels",
        "question": "What is the average age of the dogs who have gone through any treatments?",
        "ground_truth": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )",
        "amends": [
            "Do use `avg(age)` with lowercase function instead of `AVG(age)` with uppercase function. Do filter with `dog_id IN (subquery)` instead of `treatment_id IS NOT NULL`. Do reference the `Dogs` table with proper capitalization instead of `dogs` lowercase. Do add a correlated subquery `SELECT dog_id FROM Treatments` to properly identify dogs that have received treatments instead of checking for non-null treatment_id directly in the dogs table. The amended query now correctly identifies dogs that have treatment records by checking against the Treatments table rather than relying on a potentially incorrect treatment_id field in the dogs table, ensuring the query matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"average age of dogs who have gone through treatments\": make sure the output order: avg(age). 2) When the question mentions \"dogs who have gone through any treatments\": use a subquery to select dog_id from the Treatments table instead of checking treatment_id IS NOT NULL. 3) When computing the average age: use lowercase avg(age) function instead of uppercase AVG(age). 4) When referencing the Dogs table: use proper capitalization \"Dogs\" instead of lowercase \"dogs\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age) FROM dogs WHERE treatment_id IS NOT NULL;",
            "SELECT avg(age) FROM Dogs WHERE dog_id IN (SELECT dog_id FROM Treatments)"
        ],
        "rule_sql": [
            "SELECT avg(age) FROM Dogs WHERE dog_id IN (SELECT dog_id FROM Treatments);"
        ]
    },
    "246": {
        "db_id": "flight_2",
        "question": "Which flight numbers correspond to United Airlines flights?",
        "ground_truth": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  \"United Airlines\"",
        "amends": [
            "Do join `AIRLINES` as `T2` on `T2.uid = T1.Airline` instead of querying only the `flights` table. Do filter on `T2.Airline = \"United Airlines\"` instead of `airline = 'Delta Airlines'`. Do select `T1.FlightNo` instead of `flight_number`. The amended query now correctly joins the airlines table to filter by airline name using the proper relationship and returns the appropriate flight number column."
        ],
        "rules": [
            "1) When answering about flight numbers for United Airlines flights: make sure the output order: T1.FlightNo. 2) When the question mentions \"United Airlines\": \"United Airlines\" actually means T2.Airline = \"United Airlines\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T2.uid = T1.Airline exactly as shown in the amends; keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE airline = 'Delta Airlines';",
            "SELECT T1.FlightNo \nFROM flights T1 \nJOIN airlines T2 ON T2.uid = T1.Airline \nWHERE T2.Airline = 'United Airlines'"
        ],
        "rule_sql": [
            "SELECT T1.FlightNo FROM flights T1 INNER JOIN airlines T2 ON T2.uid = T1.Airline WHERE T2.Airline = \"United Airlines\""
        ]
    },
    "50": {
        "db_id": "pets_1",
        "question": "List the maximum weight and type for each type of pet.",
        "ground_truth": "SELECT max(weight) ,  petType FROM pets GROUP BY petType",
        "amends": [
            "Do use `petType` instead of `type` as the grouping column. Do place `max(weight)` before `petType` in the SELECT list instead of after it. Do use `petType` as the column alias in the GROUP BY clause instead of `type`. The amended query now correctly groups by the petType column and returns the maximum weight for each pet type, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"maximum weight and type for each type of pet\": use \"petType\" as the grouping column instead of \"type\". 2) When organizing results by pet type: place \"max(weight)\" before \"petType\" in the output order. 3) When grouping by pet type: use \"petType\" as the column alias in the grouping clause."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type, MAX(weight) FROM pets GROUP BY type;",
            "SELECT MAX(weight) AS max_weight, PetType FROM Pets GROUP BY PetType;"
        ],
        "rule_sql": [
            "SELECT MAX(weight) AS max_weight, PetType FROM Pets GROUP BY PetType ORDER BY PetType;"
        ]
    },
    "945": {
        "db_id": "dog_kennels",
        "question": "Which professionals have operated a treatment that costs less than the average? Give me theor first names and last names.",
        "ground_truth": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to remove duplicate professional records. Do reference columns with table aliases `T1.first_name` and `T1.last_name` instead of unqualified `first_name` and `last_name`. Do join `Professionals AS T1` with `Treatments AS T2` instead of querying only the `professionals` table. Do use column name `cost_of_treatment` instead of `treatment_cost` in both the main filter and subquery. Do reference the correct table `Treatments` in the subquery instead of `treatments`. The amended query now correctly joins professionals with their treatments and filters based on the average treatment cost.",
            "Do remove the `ON T1.professional_id = T2.professional_id` join condition instead of including it, and do remove the table alias `T2.` from `cost_of_treatment` in the WHERE clause instead of keeping it. The amended query now matches RIGHT_SQL's behavior.",
            "Do remove the `ON T1.professional_id = T2.professional_id` join condition instead of including it, as the RIGHT_SQL uses a cross join without explicit join predicates. Do keep the `DISTINCT` modifier, `T1.first_name` and `T1.last_name` column selections, `Professionals AS T1` and `Treatments AS T2` table sources, and the `cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments)` filter condition unchanged, as these elements match between both queries. The amended query now matches RIGHT_SQL's behavior with a Cartesian product between Professionals and Treatments tables filtered by the cost comparison."
        ],
        "rules": [
            "1) When answering about professionals operating treatments: join Professionals AS T1 with Treatments AS T2 instead of querying only the Professionals table. 2) When filtering by treatment cost: use column name \"cost_of_treatment\" instead of \"treatment_cost\" in both the main filter and subquery. 3) When computing average treatment cost: reference the correct table \"Treatments\" in the subquery instead of \"treatments\". 4) When selecting professional names: use table aliases T1.first_name and T1.last_name instead of unqualified column names. 5) When returning professional records: use DISTINCT instead of omitting it to remove duplicate professional records.",
            "1) When joining Professionals and Treatments tables: do not use any join condition between T1.professional_id and T2.professional_id, instead perform a cartesian product of all rows from both tables. 2) When comparing treatment cost to average cost: reference cost_of_treatment without any table alias prefix in the WHERE clause instead of using T2.cost_of_treatment. 3) When answering about professionals operating treatments costing less than average: output first_name and last_name columns from the Professionals table (T1).",
            "1) When combining Professionals and Treatments tables: do not use any join condition and create a Cartesian product between all rows of both tables. 2) When filtering by cost of treatment: keep only rows where T2.cost_of_treatment is less than the average cost_of_treatment from all Treatments. 3) When selecting distinct professionals: return unique combinations of T1.first_name and T1.last_name from the filtered results. 4) When handling output columns: maintain the exact order of T1.first_name followed by T1.last_name in the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM professionals WHERE treatment_cost < (SELECT AVG(treatment_cost) FROM treatments);",
            "SELECT DISTINCT T1.first_name, T1.last_name\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nWHERE T2.cost_of_treatment < (\n    SELECT AVG(cost_of_treatment)\n    FROM Treatments\n)",
            "SELECT DISTINCT T1.first_name, T1.last_name\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nWHERE cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments)",
            "SELECT DISTINCT T1.first_name, T1.last_name\nFROM Professionals AS T1, Treatments AS T2\nWHERE T2.cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments)"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.first_name, T1.last_name\nFROM Professionals AS T1, Treatments AS T2\nWHERE T2.cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments);"
        ]
    },
    "818": {
        "db_id": "world_1",
        "question": "What is the total number of countries where Spanish is spoken by the largest percentage of people?",
        "ground_truth": "SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  \"Spanish\" GROUP BY CountryCode",
        "amends": [
            "Do use `count(*)` and `max(Percentage)` in the SELECT list instead of just `COUNT(*)` with a subquery. Do reference table `countrylanguage` instead of `countries` and column `LANGUAGE` instead of `language`. Do add `GROUP BY CountryCode` instead of filtering with a subquery comparison. Do use double quotes around \"Spanish\" instead of single quotes. The amended query now correctly groups by country code to count Spanish-speaking countries and find the maximum percentage, matching the intended behavior.",
            "Do remove the HAVING clause with its correlated subquery that was incorrectly filtering for maximum percentage values instead of keeping the simple aggregate query. Do change the SELECT list to include both `count(*)` and `max(Percentage)` instead of only `count(*)`. Do maintain the `WHERE Language = \"Spanish\"` filter and `GROUP BY CountryCode` grouping without the unnecessary subquery logic. The amended query now correctly counts Spanish-speaking countries while also showing their maximum percentage values, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"countries where Spanish is spoken by the largest percentage\": make sure the output order: count of countries\n2) When the question mentions \"countries\": \"countries\" actually means \"CountryCode in countrylanguage table\"\n3) When the question mentions \"Spanish\": use the exact literal \"Spanish\" with double quotes\n4) When the question asks for \"total number of countries where Spanish is spoken by the largest percentage\": group by CountryCode and count the number of groups\n5) When computing the maximum percentage per country: use max(Percentage) for each CountryCode group\n6) When choosing identifier delimiters: use double quotes around \"Spanish\" and use exact column names LANGUAGE and Percentage as shown in the schema\n7) When referring to table roles: use countrylanguage as the base table (T1) for language data",
            "1) When answering about \"total number of countries where Spanish is spoken by the largest percentage of people\": make sure the output order: count of countries and maximum percentage values. 2) When the question mentions \"Spanish\": \"Spanish\" actually means \"Language = 'Spanish'\" in schema. 3) When the question asks for \"total number of countries\": compute the number of rows using the canonical key token for countries (CountryCode). 4) When the question mentions \"largest percentage\": include the maximum percentage value for each country in the output. 5) When the question says \"per country\"/\"by country\": organize results by CountryCode and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE language = 'Spanish' AND percentage = (SELECT MAX(percentage) FROM countries WHERE language = 'Spanish');",
            "SELECT COUNT(*) \nFROM countrylanguage \nWHERE Language = \"Spanish\" \nGROUP BY CountryCode \nHAVING MAX(Percentage) = (SELECT MAX(Percentage) FROM countrylanguage cl2 WHERE cl2.CountryCode = countrylanguage.CountryCode)",
            "SELECT COUNT(*), MAX(Percentage) FROM countrylanguage WHERE Language = \"Spanish\" GROUP BY CountryCode;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS count_of_countries\nFROM (\n    SELECT CountryCode, MAX(Percentage) AS max_percentage\n    FROM countrylanguage\n    WHERE Language = 'Spanish'\n    GROUP BY CountryCode\n) AS spanish_max_percentage"
        ]
    },
    "429": {
        "db_id": "wta_1",
        "question": "Find the total number of players.",
        "ground_truth": "SELECT count(*) FROM players",
        "amends": [
            "Do use lowercase `count(*)` instead of uppercase `COUNT(*)` to maintain consistent function casing. The amended query now matches RIGHT_SQL's behavior with identical functionality."
        ],
        "rules": [
            "1) When counting entities: use lowercase function names like count(*) instead of uppercase COUNT(*) to maintain consistent function casing."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE team = 'Lakers';",
            "SELECT count(*) FROM players;"
        ],
        "rule_sql": [
            "select count(*) from players"
        ]
    },
    "207": {
        "db_id": "flight_2",
        "question": "How many flights depart from City Aberdeen?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.SourceAirport  =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"",
        "amends": [
            "Do add `JOIN AIRPORTS AS T2 ON T1.SourceAirport = T2.AirportCode` instead of querying only the `flights` table. Do change the filter to `T2.City = \"Aberdeen\"` instead of `departure_city = 'Aberdeen'` since the city information is stored in the airports table rather than directly in flights. Do use proper table aliases `T1` and `T2` instead of referencing tables directly without aliases. The amended query now correctly joins the flights and airports tables to find flights departing from Aberdeen by matching airport codes rather than relying on a non-existent departure_city column, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"flights depart from City Aberdeen\": make sure to join the flights table (T1) with the airports table (T2) using T1.SourceAirport = T2.AirportCode. 2) When the question mentions \"City Aberdeen\": \"Aberdeen\" actually means T2.City = \"Aberdeen\" in the airports table. 3) When counting flights: compute the number of rows using the canonical key from the flights table. 4) When combining T1 and T2 for shared entities: link rows where T1.SourceAirport = T2.AirportCode exactly as shown in the amends; keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE departure_city = 'Aberdeen';",
            "SELECT COUNT(*) FROM flights AS T1 JOIN airports AS T2 ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM flights T1\nINNER JOIN airports T2 ON T1.SourceAirport = T2.AirportCode\nWHERE T2.City = 'Aberdeen'"
        ]
    },
    "894": {
        "db_id": "network_1",
        "question": "Show ids of all students who do not have any friends.",
        "ground_truth": "SELECT id FROM Highschooler EXCEPT SELECT student_id FROM Friend",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do reference table `Highschooler` instead of `students` and table `Friend` instead of `friends`. Do remove the `WHERE` clause entirely instead of keeping the `NOT IN` predicate. The amended query now correctly uses set-based exclusion to find IDs in Highschooler that are not present in Friend, matching the RIGHT_SQL's behavior.",
            "Do select `id` instead of `ID` to match the correct column name. Do remove the second `UNION` clause with `SELECT friend_id FROM Friend` instead of including it, as the right query only needs to find students who are not in the Friend table at all rather than those who might appear as either student_id or friend_id. Do use proper case sensitivity for column names to ensure accurate data retrieval. The amended query now correctly identifies students who have no friends by excluding only those who appear as student_id in the Friend table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"students who do not have any friends\": use table \"Highschooler\" instead of \"students\" and table \"Friend\" instead of \"friends\". 2) When finding IDs that are not present in another table: use EXCEPT set operation instead of NOT IN with a subquery. 3) When selecting IDs from Highschooler that are not in Friend: remove the WHERE clause entirely and use set-based exclusion. 4) When referencing the student identifier: use the exact column \"ID\" from table \"Highschooler\" as the canonical key.",
            "1) When selecting student identifiers: use exact column name \"id\" instead of \"ID\" to match the correct case-sensitive column name in the Highschooler table. 2) When finding students without friends: exclude only students who appear as \"student_id\" in the Friend table, not those who appear as \"friend_id\". 3) When the question asks for students who do not have any friends: identify students who are completely absent from the Friend table's student_id column rather than considering both student_id and friend_id roles."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM students WHERE id NOT IN (SELECT student_id FROM friends)",
            "SELECT ID FROM Highschooler\nEXCEPT\nSELECT student_id FROM Friend\nUNION\nSELECT friend_id FROM Friend",
            "SELECT id FROM Highschooler\nEXCEPT\nSELECT student_id FROM Friend"
        ],
        "rule_sql": [
            "SELECT id FROM Highschooler EXCEPT SELECT student_id FROM Friend"
        ]
    },
    "46": {
        "db_id": "pets_1",
        "question": "How many pets have a greater weight than 10?",
        "ground_truth": "SELECT count(*) FROM pets WHERE weight  >  10",
        "amends": [
            "Do use the comparison operator `>` instead of `<` in the WHERE filter, changing the condition from `weight < 10` to `weight > 10` to count pets weighing more than 10 units instead of less than 10 units. The amended query now correctly matches the intended behavior of counting records where weight exceeds the threshold value."
        ],
        "rules": [
            "1) When the question asks for pets with weight greater than 10: use the comparison operator > instead of < in the filter condition. 2) When counting pets that meet a weight condition: count all rows where the weight column value is greater than 10."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM pets WHERE weight < 10;",
            "SELECT COUNT(*) FROM Pets WHERE weight > 10;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Pets WHERE weight > 10;"
        ]
    },
    "37": {
        "db_id": "concert_singer",
        "question": "List all singer names in concerts in year 2014.",
        "ground_truth": "SELECT T2.name FROM singer_in_concert AS T1 JOIN singer AS T2 ON T1.singer_id  =  T2.singer_id JOIN concert AS T3 ON T1.concert_id  =  T3.concert_id WHERE T3.year  =  2014",
        "amends": [
            "Do select `T2.name` from the `singer` table instead of `singer_name` from a non-existent source. Do join `singer_in_concert AS T1` to `singer AS T2` on `T1.singer_id = T2.singer_id` instead of missing this relationship entirely. Do add a second join to `concert AS T3` on `T1.concert_id = T3.concert_id` instead of omitting the concert table. Do filter on `T3.year = 2014` instead of filtering on a non-existent `year` column in the wrong table. The amended query now correctly retrieves singer names for concerts in 2014 by properly joining through the relationship tables."
        ],
        "rules": [
            "1) When the question asks for \"singer names\": use \"T2.name\" from the \"singer\" table instead of \"singer_name\" from a non-existent source. 2) When combining data about singers in concerts: join \"singer_in_concert AS T1\" to \"singer AS T2\" on \"T1.singer_id = T2.singer_id\" to establish the relationship. 3) When needing concert year information: join \"concert AS T3\" on \"T1.concert_id = T3.concert_id\" to access concert details. 4) When filtering for concerts in year 2014: use \"T3.year = 2014\" instead of filtering on a non-existent \"year\" column in the wrong table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT singer_name FROM concerts WHERE year = 2014;",
            "SELECT T2.Name \nFROM singer_in_concert AS T1\nJOIN singer AS T2 ON T1.Singer_ID = T2.Singer_ID\nJOIN concert AS T3 ON T1.concert_ID = T3.concert_ID\nWHERE T3.Year = '2014'"
        ],
        "rule_sql": [
            "SELECT T2.Name \nFROM singer_in_concert AS T1\nJOIN singer AS T2 ON T1.Singer_ID = T2.Singer_ID\nJOIN concert AS T3 ON T1.concert_ID = T3.concert_ID\nWHERE T3.Year = '2014'"
        ]
    },
    "540": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the program id and the summary of the degree that has the most students enrolled?",
        "ground_truth": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.degree_program_id` and `T1.degree_summary_name` instead of `program_id` and `summary`. Do join `Degree_Programs AS T1` with `Student_Enrolment AS T2` on `T1.degree_program_id = T2.degree_program_id` instead of querying only the `degrees` table. Do add `GROUP BY T1.degree_program_id` to aggregate by program instead of omitting grouping. Do order by `count(*) DESC` to sort by actual student count instead of `enrolled_students DESC`. The amended query now correctly identifies the program with the most enrolled students by counting actual enrollment records rather than relying on a potentially incorrect stored count value."
        ],
        "rules": [
            "1) When answering about \"program id and summary of the degree with most students enrolled\": make sure the output order: T1.degree_program_id, T1.degree_summary_name. 2) When the question mentions \"program id\": \"program id\" actually means \"T1.degree_program_id\" in schema. 3) When the question mentions \"summary\": \"summary\" actually means \"T1.degree_summary_name\" in schema. 4) When combining Degree_Programs AS T1 and Student_Enrolment AS T2 for shared entities: link rows where T1.degree_program_id = T2.degree_program_id; keep only matching pairs (inner match). 5) When the question asks for \"most students enrolled\" and implies grouping by program: organize results by T1.degree_program_id and compute count(*) per group. 6) When the question asks for \"the most students enrolled\": rank rows by count(*) in descending direction and keep the first 1 row. 7) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT program_id, summary FROM degrees ORDER BY enrolled_students DESC LIMIT 1;",
            "SELECT T1.degree_program_id, T1.degree_summary_name\nFROM Degree_Programs AS T1\nJOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id\nGROUP BY T1.degree_program_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.degree_program_id, T1.degree_summary_name\nFROM Degree_Programs AS T1\nINNER JOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id\nGROUP BY T1.degree_program_id, T1.degree_summary_name\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "882": {
        "db_id": "network_1",
        "question": "Show the student IDs and numbers of friends corresponding to each.",
        "ground_truth": "SELECT student_id ,  count(*) FROM Friend GROUP BY student_id",
        "amends": [
            "Do use table name `Friend` instead of `friends` to reference the correct table. The amended query now matches RIGHT_SQL's behavior with the proper table reference."
        ],
        "rules": [
            "1) When referencing the table containing friend relationships: use the exact table name \"Friend\" instead of \"friends\" to match the schema definition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id, COUNT(*) FROM friends GROUP BY student_id;",
            "SELECT student_id, COUNT(friend_id) AS number_of_friends FROM Friend GROUP BY student_id;"
        ],
        "rule_sql": [
            "SELECT student_id, COUNT(friend_id) AS number_of_friends FROM Friend GROUP BY student_id;"
        ]
    },
    "262": {
        "db_id": "employee_hire_evaluation",
        "question": "List the names of employees and sort in ascending order of age.",
        "ground_truth": "SELECT name FROM employee ORDER BY age",
        "amends": [
            "Do reference table `employee` instead of `employees` in the FROM clause. Do use ascending ORDER BY `age` instead of descending ORDER BY `age DESC`. The amended query now correctly references the single employee table and sorts by age in ascending order instead of descending order."
        ],
        "rules": [
            "1) When the question asks for employee names: use the exact table name \"employee\" instead of \"employees\" as shown in the schema. 2) When the question specifies sorting in ascending order of age: use ascending order for the \"age\" column instead of descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM employees ORDER BY age DESC;",
            "SELECT Name FROM employee ORDER BY Age ASC;"
        ],
        "rule_sql": [
            "SELECT Name FROM employee ORDER BY Age ASC;"
        ]
    },
    "157": {
        "db_id": "car_1",
        "question": "For model volvo, how many cylinders does the car with the least accelerate have?",
        "ground_truth": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;",
        "amends": [
            "Do add `CAR_NAMES AS T2` table with `JOIN` instead of querying only `cars` table. Do use `ON T1.Id = T2.MakeId` join condition instead of no join. Do reference `T2.Model` in the WHERE filter instead of `model`. Do qualify columns with table aliases `T1.cylinders` and `T1.accelerate` instead of unqualified column names. The amended query now correctly joins the necessary tables to access the model information and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"model volvo\": use \"T2.Model\" = 'volvo' instead of \"model\" for filtering. 2) When combining cars and CAR_NAMES tables: link rows where T1.Id = T2.MakeId and keep only matching pairs (inner match). 3) When the question asks for \"car with the least accelerate\": rank rows by T1.accelerate in ascending order and keep the first 1 row. 4) When producing output: include T1.cylinders as the result column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT cylinders FROM cars WHERE model = 'volvo' ORDER BY accelerate ASC LIMIT 1;",
            "SELECT T1.Cylinders \nFROM cars_data AS T1\nJOIN car_names AS T2 ON T1.Id = T2.MakeId\nWHERE T2.Model = 'volvo'\nORDER BY T1.Accelerate ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Cylinders \nFROM cars_data T1\nINNER JOIN car_names T2 ON T1.Id = T2.MakeId\nINNER JOIN model_list T3 ON T2.Model = T3.Model\nWHERE T3.Model = 'volvo'\nORDER BY T1.Accelerate ASC\nLIMIT 1"
        ]
    },
    "551": {
        "db_id": "student_transcripts_tracking",
        "question": "Show the date and id of the transcript with at least 2 course results.",
        "ground_truth": "SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id HAVING count(*)  >=  2",
        "amends": [
            "Do select `T2.transcript_date` and `T1.transcript_id` instead of `date` and `id`. Do join `Transcript_Contents AS T1` and `Transcripts AS T2` with `ON T1.transcript_id = T2.transcript_id` instead of querying only `transcript` table. Do add `GROUP BY T1.transcript_id` instead of omitting grouping. Do move the count condition to `HAVING count(*) >= 2` instead of placing it in `WHERE COUNT(course_result) >= 2`. Do use `count(*)` instead of `COUNT(course_result)` for proper aggregation. The amended query now correctly aggregates transcript contents and filters groups with multiple entries, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"transcript with at least 2 course results\": make sure the output order: T2.transcript_date, T1.transcript_id. 2) When combining Transcript_Contents as T1 and Transcripts as T2: link rows where T1.transcript_id = T2.transcript_id and keep only matching pairs (inner match). 3) When the question asks for transcripts with at least 2 course results: organize results by T1.transcript_id and compute count(*) per group, then keep only groups where count(*) >= 2. 4) When counting course results for transcripts: use count(*) to count all rows in the Transcript_Contents table per transcript_id group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT date, id FROM transcript WHERE COUNT(course_result) >= 2",
            "SELECT T2.transcript_date, T1.transcript_id\nFROM Transcript_Contents AS T1\nJOIN Transcripts AS T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nHAVING count(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T2.transcript_date, T1.transcript_id\nFROM Transcript_Contents T1\nINNER JOIN Transcripts T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nHAVING COUNT(*) >= 2\nORDER BY T2.transcript_date, T1.transcript_id"
        ]
    },
    "955": {
        "db_id": "dog_kennels",
        "question": "Which dogs are of the rarest breed? Show their names and treatment dates.",
        "ground_truth": "SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT 1 )",
        "amends": [
            "Do use `T1.name` and `T2.date_of_treatment` instead of `d.name` and `t.treatment_date` for column aliases. Do reference `Dogs AS T1` and `Treatments AS T2` instead of `dogs d` and `treatments t` for table aliases. Do join on `T1.dog_id = T2.dog_id` instead of `d.dog_id = t.dog_id` for the join condition. Do filter on `T1.breed_code` instead of `d.breed` for the breed column reference. Do use `breed_code` instead of `breed` in the subquery's SELECT and GROUP BY clauses. The amended query now correctly matches the RIGHT_SQL's behavior with proper column and table references."
        ],
        "rules": [
            "1) When answering about \"rarest breed\": find the breed_code with the lowest count of dogs in T1 (Dogs table) and use that breed_code for filtering. 2) When the question mentions \"breed\": use T1.breed_code instead of breed as the column reference. 3) When showing dog names and treatment dates: output T1.name and T2.date_of_treatment as the result columns. 4) When combining Dogs and Treatments tables: link rows where T1.dog_id = T2.dog_id using an inner join. 5) When ordering results: sort by T2.date_of_treatment in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.name, t.treatment_date \nFROM dogs d \nJOIN treatments t ON d.dog_id = t.dog_id \nWHERE d.breed = (SELECT breed FROM dogs GROUP BY breed ORDER BY COUNT(*) ASC LIMIT 1)\nORDER BY t.treatment_date DESC;",
            "SELECT T1.name, T2.date_of_treatment\nFROM Dogs AS T1\nJOIN Treatments AS T2 ON T1.dog_id = T2.dog_id\nWHERE T1.breed_code = (\n    SELECT breed_code\n    FROM Dogs\n    GROUP BY breed_code\n    ORDER BY COUNT(*) ASC\n    LIMIT 1\n)"
        ],
        "rule_sql": [
            "SELECT T1.name, T2.date_of_treatment\nFROM Dogs T1\nINNER JOIN Treatments T2 ON T1.dog_id = T2.dog_id\nWHERE T1.breed_code = (\n    SELECT breed_code\n    FROM Dogs\n    GROUP BY breed_code\n    ORDER BY COUNT(*) ASC\n    LIMIT 1\n)\nORDER BY T2.date_of_treatment DESC;"
        ]
    },
    "985": {
        "db_id": "dog_kennels",
        "question": "What are the dog name, age and weight of the dogs that were abandoned? Note that 1 stands for yes, and 0 stands for no in the tables.",
        "ground_truth": "SELECT name ,  age ,  weight FROM Dogs WHERE abandoned_yn  =  1",
        "amends": [
            "Do reference table `Dogs` instead of `dogs` to match the correct table name. Do change the filter condition to `abandoned_yn = 1` instead of `abandoned = 0` to use the correct column name and value for identifying abandoned dogs. The amended query now correctly selects non-abandoned dogs from the Dogs table."
        ],
        "rules": [
            "1) When the question mentions \"dogs\": use the exact table name \"Dogs\" with proper case. 2) When identifying abandoned dogs: use the column \"abandoned_yn\" and the value 1 (not 0) to match the schema's representation where 1 means yes/abandoned. 3) When selecting dog attributes: output the columns \"name\", \"age\", and \"weight\" in that order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, age, weight FROM dogs WHERE abandoned = 0;",
            "SELECT name, age, weight FROM Dogs WHERE abandoned_yn = '1';"
        ],
        "rule_sql": [
            "SELECT name, age, weight FROM Dogs WHERE abandoned_yn = '1';"
        ]
    },
    "840": {
        "db_id": "orchestra",
        "question": "Show the names of conductors and the orchestras they have conducted.",
        "ground_truth": "SELECT T1.Name ,  T2.Orchestra FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference column `Name` from table `T1` instead of `conductor_name`. Do reference column `Orchestra` from table `T2` instead of `orchestra_name`. Do use table name `conductor` instead of `conductors`. Do use table name `orchestra` instead of `orchestras`. Do use column name `Conductor_ID` instead of `conductor_id` in both join conditions. The amended query now correctly matches the intended behavior with proper table and column references."
        ],
        "rules": [
            "1) When answering about \"names of conductors and the orchestras they have conducted\": make sure the output order: T1.Name, T2.Orchestra. 2) When the question mentions \"conductors\": use table \"conductor\" with alias T1 and column \"Name\" for conductor names. 3) When the question mentions \"orchestras\": use table \"orchestra\" with alias T2 and column \"Orchestra\" for orchestra names. 4) When combining T1 and T2 for shared entities: link rows where T1.Conductor_ID = T2.Conductor_ID; keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for column names like \"Name\" and \"Orchestra\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT conductor_name, orchestra_name FROM conductors JOIN orchestras ON conductors.conductor_id = orchestras.conductor_id;",
            "SELECT T1.Name, T2.Orchestra FROM conductor T1 JOIN orchestra T2 ON T1.Conductor_ID = T2.Conductor_ID"
        ],
        "rule_sql": [
            "SELECT T1.\"Name\", T2.\"Orchestra\" FROM conductor T1 INNER JOIN orchestra T2 ON T1.\"Conductor_ID\" = T2.\"Conductor_ID\""
        ]
    },
    "692": {
        "db_id": "voter_1",
        "question": "What are the names of the contestants whose names are not 'Jessie Alloway'",
        "ground_truth": "SELECT contestant_name FROM contestants WHERE contestant_name != 'Jessie Alloway'",
        "amends": [
            "Do reference `contestant_name` instead of `name` in the SELECT list and WHERE clause. Do use inequality filter `!= 'Jessie Alloway'` instead of equality filter `= 'Jessie Alloway'` to exclude rather than include that specific record. The amended query now correctly selects all contestants except Jessie Alloway instead of only selecting Jessie Alloway, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for contestant names excluding 'Jessie Alloway': use inequality filter != 'Jessie Alloway' instead of equality filter = 'Jessie Alloway' to exclude rather than include that specific record. 2) When selecting contestant names: use the exact column token \"contestant_name\" instead of \"name\" in both the SELECT list and WHERE clause. 3) When handling the literal value 'Jessie Alloway': preserve the exact case, spacing, and punctuation as shown in the question and amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM contestants WHERE name = 'Jessie Alloway';",
            "SELECT contestant_name FROM CONTESTANTS WHERE contestant_name != 'Jessie Alloway'"
        ],
        "rule_sql": [
            "SELECT contestant_name FROM CONTESTANTS WHERE contestant_name != 'Jessie Alloway'"
        ]
    },
    "384": {
        "db_id": "course_teach",
        "question": "What are the names of the teachers ordered by ascending age?",
        "ground_truth": "SELECT Name FROM teacher ORDER BY Age ASC",
        "amends": [
            "Do reference the table as `teacher` instead of `teachers` to match the correct schema. Do select the column `Name` instead of `name` to use proper case sensitivity. Do order by `Age` in `ASC` order instead of `DESC` to sort in ascending rather than descending sequence. The amended query now correctly retrieves teacher names sorted by age in ascending order."
        ],
        "rules": [
            "1) When the question asks about teachers: use the table \"teacher\" instead of \"teachers\" to match the schema exactly. 2) When selecting teacher names: use the column \"Name\" with exact case sensitivity as shown in the schema. 3) When ordering by age: use the column \"Age\" and sort in ascending (ASC) order instead of descending to match the question requirement."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM teachers ORDER BY age DESC;",
            "SELECT Name FROM teacher ORDER BY Age ASC;"
        ],
        "rule_sql": [
            "SELECT Name FROM teacher ORDER BY Age ASC;"
        ]
    },
    "717": {
        "db_id": "world_1",
        "question": "What region does Angola belong to and what is its population?",
        "ground_truth": "SELECT Population ,  Region FROM country WHERE Name  =  \"Angola\"",
        "amends": [
            "Do use table name `country` instead of `countries` and column names `Name`, `Population`, and `Region` instead of `name`, `population`, and `region` to match the correct schema. Do use double quotes `\"Angola\"` instead of single quotes `'Angola'` for the string literal in the WHERE filter. The amended query now correctly retrieves the population and region data for Angola from the proper table structure.",
            "Do reverse the column order to `Population, Region` instead of `Region, Population` while maintaining the same `WHERE Name = \"Angola\"` filter. The amended query now matches RIGHT_SQL's behavior by preserving all logical elements while adjusting the presentation order of columns in the SELECT list."
        ],
        "rules": [
            "1) When the question asks about a country's region and population: use table \"country\" with columns \"Name\", \"Population\", and \"Region\" 2) When filtering for a specific country name: use exact string literal \"Angola\" with double quotes for the WHERE condition 3) When selecting output columns: maintain the order of \"Region\" first then \"Population\" as implied by the question",
            "1) When the question asks about a country's region and population: make sure the output order is Population first, then Region. 2) When filtering for a specific country name: use the exact literal \"Angola\" with double quotes and match case exactly. 3) When selecting columns from the country table: use the exact column names Region and Population as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region, population FROM countries WHERE name = 'Angola';",
            "SELECT Region, Population FROM country WHERE Name = \"Angola\";",
            "SELECT Population, Region FROM country WHERE Name = \"Angola\";"
        ],
        "rule_sql": [
            "SELECT Region, Population FROM country WHERE Name = \"Angola\";"
        ]
    },
    "370": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the ids and names of each document, as well as the number of paragraphs in each?",
        "ground_truth": "SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id",
        "amends": [
            "Do use `JOIN` instead of `LEFT JOIN` to exclude documents without paragraphs. Do reference `T1.document_id` and `T2.document_name` instead of `d.id` and `d.name` with different aliases. Do use `count(*)` instead of `COUNT(p.id)` to count all rows rather than non-null paragraph IDs. Do group by `T1.document_id` only instead of both `d.id` and `d.name` since document_name is functionally dependent. Do remove the unnecessary alias `paragraph_count` instead of keeping it. The amended query now correctly counts paragraphs per document while excluding documents with no paragraphs."
        ],
        "rules": [
            "1) When combining documents and paragraphs tables: link rows where T1.document_id equals T2.document_id and keep only matching pairs (inner match). 2) When counting paragraphs per document: count all rows using count(*) rather than counting specific column values. 3) When grouping by document identifier: group by T1.document_id only since document_name is functionally dependent on document_id. 4) When selecting output columns: include T1.document_id, T2.document_name, and the count of paragraphs. 5) When the question asks for \"number of paragraphs in each\": do not include an alias for the count column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.id, d.name, COUNT(p.id) AS paragraph_count FROM documents d LEFT JOIN paragraphs p ON d.id = p.document_id GROUP BY d.id, d.name",
            "SELECT d.Document_ID, d.Document_Name, COUNT(*) \nFROM Documents d\nJOIN Paragraphs p ON d.Document_ID = p.Document_ID\nGROUP BY d.Document_ID"
        ],
        "rule_sql": [
            "SELECT d.Document_ID, d.Document_Name, COUNT(*) \nFROM Documents d \nINNER JOIN Paragraphs p ON d.Document_ID = p.Document_ID \nGROUP BY d.Document_ID"
        ]
    },
    "483": {
        "db_id": "wta_1",
        "question": "Find the name and rank of the 3 youngest winners across all matches.",
        "ground_truth": "SELECT DISTINCT winner_name ,  winner_rank FROM matches ORDER BY winner_age LIMIT 3",
        "amends": [
            "Do `SELECT DISTINCT winner_name, winner_rank` instead of `SELECT name, rank` to use the correct column names and add distinct filtering. Do `FROM matches` instead of the omitted table reference to specify the correct source table. Do `ORDER BY winner_age` instead of `ORDER BY age` to use the properly named age column. Do maintain `LIMIT 3` as it remains unchanged. The amended query now correctly retrieves distinct winner names and ranks from the matches table ordered by winner age."
        ],
        "rules": [
            "1) When the question asks for \"name and rank of winners\": use columns \"winner_name\" and \"winner_rank\" from table \"matches\". 2) When the question asks for \"youngest winners\": order results by \"winner_age\" in ascending order. 3) When the question asks for \"3 youngest winners\": limit results to the first 3 rows after ordering by \"winner_age\". 4) When retrieving results from the \"matches\" table: ensure distinct values are returned for winner_name and winner_rank to avoid duplicates."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, rank FROM winners ORDER BY age ASC LIMIT 3;",
            "SELECT DISTINCT winner_name, winner_rank FROM matches ORDER BY winner_age LIMIT 3"
        ],
        "rule_sql": [
            "SELECT DISTINCT winner_name, winner_rank FROM matches ORDER BY winner_age ASC LIMIT 3;"
        ]
    },
    "254": {
        "db_id": "flight_2",
        "question": "Give the flight numbers of flights arriving in Aberdeen.",
        "ground_truth": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport   =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"",
        "amends": [
            "Do add `JOIN AIRPORTS AS T2 ON T1.DestAirport = T2.AirportCode` instead of querying only the `flights` table. Do change the column reference to `T1.FlightNo` instead of `flight_number`. Do move the filter condition to `T2.City = \"Aberdeen\"` instead of `departure_city = 'Aberdeen'` to correctly filter by destination city rather than departure city. The amended query now properly joins the flights and airports tables to find flights destined for Aberdeen, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about flights arriving in a city: join the flights table (T1) with the airports table (T2) using T1.DestAirport = T2.AirportCode to match destination airports. 2) When the question mentions \"flight numbers\": use the exact column T1.FlightNo instead of flight_number. 3) When filtering for flights arriving in Aberdeen: use the exact literal \"Aberdeen\" with T2.City = \"Aberdeen\" to filter by destination city rather than departure city."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_city = 'Aberdeen';",
            "SELECT T1.FlightNo \nFROM flights AS T1 \nJOIN airports AS T2 ON T1.DestAirport = T2.AirportCode \nWHERE T2.City = 'Aberdeen'"
        ],
        "rule_sql": [
            "SELECT T1.FlightNo \nFROM flights T1 \nJOIN airports T2 ON T1.DestAirport = T2.AirportCode \nWHERE T2.City = 'Aberdeen'"
        ]
    },
    "158": {
        "db_id": "car_1",
        "question": "For a volvo model, how many cylinders does the version with least accelerate have?",
        "ground_truth": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;",
        "amends": [
            "Do join `CAR_NAMES AS T2` on `T1.Id = T2.MakeId` instead of querying only the `cars` table. Do filter on `T2.Model = 'volvo'` instead of `make = 'Volvo'`. Do reference `T1.cylinders` and `T1.accelerate` with table aliases instead of unqualified column names. The amended query now correctly joins the necessary tables and filters on the appropriate column to match the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"volvo model\": filter on T2.Model = 'volvo' exactly as specified (case-sensitive). 2) When combining cars and CAR_NAMES tables: link rows where T1.Id = T2.MakeId exactly as shown and keep only matching pairs (inner match). 3) When the question asks for the version with least accelerate: order rows by T1.accelerate in ascending order and keep only the first row. 4) When answering about cylinders for a specific car: output T1.cylinders as the result column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT cylinders FROM cars WHERE make = 'Volvo' ORDER BY accelerate ASC LIMIT 1;",
            "SELECT T1.Cylinders \nFROM cars_data AS T1\nJOIN car_names AS T2 ON T1.Id = T2.MakeId\nWHERE T2.Model = 'volvo'\nORDER BY T1.Accelerate ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Cylinders \nFROM cars_data T1 \nINNER JOIN car_names T2 ON T1.Id = T2.MakeId \nWHERE T2.Model = 'volvo' \nORDER BY T1.Accelerate ASC \nLIMIT 1"
        ]
    },
    "52": {
        "db_id": "pets_1",
        "question": "How many pets are owned by students that have an age greater than 20?",
        "ground_truth": "SELECT count(*) FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid WHERE T1.age  >  20",
        "amends": [
            "Do add `JOIN has_pet AS T2 ON T1.stuid = T2.stuid` instead of querying only the `pets` table. Do change the table reference to `student AS T1` instead of `pets` as the primary source. Do use `T1.age > 20` instead of `student_age > 20` to filter on the correct table's column. Do remove the incorrect `pets` table reference and replace it with the proper join structure between student and has_pet tables. The amended query now correctly counts students over age 20 who have pets by joining the appropriate tables with the proper relationship."
        ],
        "rules": [
            "1) When answering about \"pets owned by students with age greater than 20\": make sure the output order: count of students\n2) When the question mentions \"students\": use table \"student AS T1\" as the primary source instead of \"pets\" table\n3) When combining T1 (student) and T2 (has_pet) for shared entities: link rows where T1.stuid = T2.stuid exactly as shown; keep only matching pairs (inner match)\n4) When filtering by student age: use T1.age > 20 instead of student_age > 20 to filter on the correct table's column\n5) When counting students who have pets: compute the number of rows using the canonical key T1.stuid for counting students"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM pets WHERE student_age > 20;",
            "SELECT COUNT(*) \nFROM Student AS T1\nJOIN Has_Pet AS T2 ON T1.StuID = T2.StuID\nWHERE T1.Age > 20"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.StuID) \nFROM Student AS T1 \nINNER JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID \nWHERE T1.Age > 20"
        ]
    },
    "121": {
        "db_id": "car_1",
        "question": "What are all the makers and models?",
        "ground_truth": "SELECT Maker ,  Model FROM MODEL_LIST;",
        "amends": [
            "Do reference the `MODEL_LIST` table instead of the `products` table. Do remove the `WHERE model IS NULL` filter instead of keeping it. The amended query now correctly selects all makers and models from the appropriate table without unnecessary filtering.",
            "Do select only `Maker` and `Model` columns instead of including the table prefix `cm.` and `ml.` qualifiers. Do use a single table `MODEL_LIST` as the source instead of joining `car_makers` with `model_list` on `cm.Id = ml.Maker`. Do remove the unnecessary join condition entirely instead of maintaining the relationship between the tables. The amended query now correctly retrieves only the maker and model information directly from the MODEL_LIST table without the redundant join operation."
        ],
        "rules": [
            "1) When answering about \"all the makers and models\": use the MODEL_LIST table instead of the products table. 2) When selecting all records: do not apply any WHERE filter conditions like model IS NULL. 3) When the question asks for \"makers and models\": select both the Maker and Model columns from the MODEL_LIST table.",
            "1) When answering about \"all the makers and models\": make sure the output order: Maker, Model. 2) When the question asks for makers and models: use the exact column tokens \"Maker\" and \"Model\" without table prefixes. 3) When retrieving maker and model information: use only the MODEL_LIST table as the source instead of joining with other tables. 4) When selecting from MODEL_LIST: do not include any join conditions with car_makers table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT maker, model FROM products WHERE model IS NULL;",
            "SELECT cm.Maker, ml.Model FROM car_makers cm JOIN model_list ml ON cm.Id = ml.Maker;",
            "SELECT Maker, Model FROM model_list"
        ],
        "rule_sql": [
            "SELECT Maker, Model FROM model_list"
        ]
    },
    "335": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What the smallest version number and its template type code?",
        "ground_truth": "SELECT min(Version_Number) ,  template_type_code FROM Templates",
        "amends": [
            "Do use `MIN(version_number)` instead of `MAX(version_number)` to find the smallest version number. Do keep `template_type_code` in the SELECT list instead of removing it. Do maintain `ORDER BY version_number ASC` instead of changing the ordering. Do preserve `LIMIT 1` instead of modifying the row limitation. The amended query now correctly retrieves the minimum version number with its corresponding template type code, matching the intended behavior."
        ],
        "rules": [
            "1) When finding the smallest version number: use MIN(\"version_number\") instead of MAX(\"version_number\"). 2) When retrieving the template type code associated with the smallest version number: include \"template_type_code\" in the output columns. 3) When ordering results to find the smallest version number: sort by \"version_number\" in ascending order. 4) When limiting results to only the smallest version number: keep only the first row using LIMIT 1."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(version_number), template_type_code FROM templates ORDER BY version_number ASC LIMIT 1;",
            "SELECT MIN(Version_Number) AS smallest_version, Template_Type_Code FROM Templates ORDER BY Version_Number ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT MIN(Version_Number) AS smallest_version_number, Template_Type_Code FROM Templates ORDER BY Version_Number ASC LIMIT 1;"
        ]
    },
    "377": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the document id with 1 to 2 paragraphs?",
        "ground_truth": "SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*) BETWEEN 1 AND 2",
        "amends": [
            "Do query from the `Paragraphs` table instead of the `documents` table. Do use `GROUP BY document_id` with a `HAVING count(*) BETWEEN 1 AND 2` clause instead of filtering `paragraph_count = 1 OR paragraph_count = 2` in the WHERE clause. Do aggregate paragraph counts using `count(*)` instead of relying on a pre-calculated `paragraph_count` column. The amended query now correctly counts paragraphs per document and filters for documents with exactly 1 or 2 paragraphs, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"document id with 1 to 2 paragraphs\": make sure the output order: document_id. 2) When counting paragraphs per document: compute the number of paragraphs using count(*) grouped by document_id. 3) When filtering for documents with exactly 1 or 2 paragraphs: use a condition that keeps only groups where the paragraph count is between 1 and 2 inclusive. 4) When the question mentions \"paragraphs\": use the Paragraphs table instead of the documents table to count actual paragraph entities."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id FROM documents WHERE paragraph_count = 1 OR paragraph_count = 2;",
            "SELECT document_id FROM Paragraphs GROUP BY document_id HAVING COUNT(*) BETWEEN 1 AND 2"
        ],
        "rule_sql": [
            "SELECT Document_ID FROM Paragraphs GROUP BY Document_ID HAVING COUNT(*) BETWEEN 1 AND 2 ORDER BY Document_ID;"
        ]
    },
    "477": {
        "db_id": "wta_1",
        "question": "Find the codes of countries that have more than 50 players.",
        "ground_truth": "SELECT country_code FROM players GROUP BY country_code HAVING count(*)  >  50",
        "amends": [
            "Do add `GROUP BY country_code` and move the aggregate filter to `HAVING count(*) > 50` instead of incorrectly placing `COUNT(*) > 50` in the `WHERE` clause where aggregate functions cannot be used. This properly groups the results by country code and applies the count condition after grouping rather than attempting to filter individual rows with an aggregate function, which would cause a syntax error. The amended query now correctly returns only those country codes that have more than 50 players, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"codes of countries that have more than 50 players\": group rows by \"country_code\" and count the number of players per group. 2) When counting players per country: use the count of all rows in each group to determine the number of players. 3) When filtering for groups with more than 50 players: apply the condition \"count(*) > 50\" after grouping rather than before grouping. 4) When answering about country codes with player counts: make sure the output order includes only \"country_code\" for groups that satisfy the count condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country_code FROM players WHERE COUNT(*) > 50",
            "SELECT country_code FROM players GROUP BY country_code HAVING COUNT(*) > 50"
        ],
        "rule_sql": [
            "SELECT country_code FROM players GROUP BY country_code HAVING COUNT(*) > 50"
        ]
    },
    "180": {
        "db_id": "flight_2",
        "question": "What country is Jetblue Airways affiliated with?",
        "ground_truth": "SELECT Country FROM AIRLINES WHERE Airline  =  \"JetBlue Airways\"",
        "amends": [
            "Do reference the column `Country` instead of `country` to match the correct case sensitivity. Do reference the column `Airline` instead of `name` to use the proper column name for airline identification. Do use the exact string value `\"JetBlue Airways\"` instead of `'Jetblue Airways'` to match the correct capitalization and spelling. Do reference the table `AIRLINES` instead of `airlines` to maintain consistent uppercase table naming convention. The amended query now correctly retrieves the country for the specified airline with proper column references and exact string matching."
        ],
        "rules": [
            "1) When the question asks about airline affiliation with a country: use the exact table name \"AIRLINES\" with uppercase letters as shown in the schema. 2) When identifying an airline by name: use the exact column name \"Airline\" instead of \"name\" to reference the proper airline identification column. 3) When matching airline names: use the exact string literal \"JetBlue Airways\" with proper capitalization and spelling instead of \"Jetblue Airways\". 4) When retrieving country information: use the exact column name \"Country\" with proper case sensitivity instead of \"country\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM airlines WHERE name = 'Jetblue Airways';",
            "SELECT Country FROM AIRLINES WHERE Airline = 'JetBlue Airways';"
        ],
        "rule_sql": [
            "SELECT Country FROM AIRLINES WHERE Airline = 'JetBlue Airways';"
        ]
    },
    "239": {
        "db_id": "flight_2",
        "question": "Find all airlines that have flights from airport 'CVO' but not from 'APG'.",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\" EXCEPT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\"",
        "amends": [
            "Do use `T1.uid = T2.Airline` for the join condition instead of `a.Airline_ID = f.Airline_ID`. Do use `T2.SourceAirport = \"CVO\"` instead of `f.Source_Airport = 'CVO'` with proper column naming and quote style. Do remove the contradictory `AND f.Source_Airport != 'APG'` filter instead of keeping it, as this logic is handled through the EXCEPT operation. Do add an EXCEPT clause to exclude airlines that also serve APG instead of using a single query with conflicting conditions. Do use table aliases `T1` and `T2` consistently instead of `a` and `f`. The amended query now correctly identifies airlines that serve CVO but not APG by using set operations instead of contradictory WHERE conditions, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When joining Airlines and Flights tables: use T1.uid = T2.Airline as the join condition instead of Airline_ID matching. 2) When filtering for flights from airport CVO: use T2.SourceAirport = \"CVO\" with double quotes around the column name and exact literal value. 3) When finding airlines that serve CVO but not APG: use an EXCEPT operation to exclude airlines that also serve APG instead of using contradictory WHERE conditions. 4) When using table aliases: consistently use T1 for Airlines table and T2 for Flights table throughout the query. 5) When handling airport codes: preserve the exact literal values 'CVO' and 'APG' with single quotes as shown in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT a.Airline FROM Airlines a JOIN Flights f ON a.Airline_ID = f.Airline_ID WHERE f.Source_Airport = 'CVO' AND f.Source_Airport != 'APG';",
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'CVO'\nEXCEPT\nSELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'APG'"
        ],
        "rule_sql": [
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = \"CVO\"\nEXCEPT\nSELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = \"APG\""
        ]
    },
    "676": {
        "db_id": "poker_player",
        "question": "Give the nationality that is most common across all people.",
        "ground_truth": "SELECT Nationality FROM people GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do reference the column as `Nationality` (case-sensitive) instead of `nationality` in both the SELECT list and GROUP BY clause. Do order by the aggregate expression `COUNT(*)` directly instead of referencing the alias `count`. Do remove the alias `count` from the SELECT list instead of including it. Do maintain the same GROUP BY and LIMIT logic while correcting the column reference case and ordering approach. The amended query now correctly identifies the most common nationality by counting occurrences directly in the ORDER BY clause without an intermediate alias."
        ],
        "rules": [
            "1) When the question asks for nationality: use the exact column token \"Nationality\" with proper case sensitivity from the schema. 2) When counting occurrences of nationality: count all rows using COUNT(*) and group by \"Nationality\". 3) When finding the most common value: order the results by the count in descending order and take only the first result. 4) When ordering by aggregate results: order directly by the aggregate expression COUNT(*) instead of using an alias. 5) When selecting output columns: include only \"Nationality\" in the SELECT list, not the count alias."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT nationality, COUNT(*) as count FROM people GROUP BY nationality ORDER BY count DESC LIMIT 1;",
            "SELECT Nationality FROM people GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Nationality FROM people GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "406": {
        "db_id": "course_teach",
        "question": "What are the names of the teachers and how many courses do they teach?",
        "ground_truth": "SELECT T2.Name ,  COUNT(*) FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T2.Name",
        "amends": [
            "Do join `course_arrange AS T1` with `teacher AS T2` on `T1.Teacher_ID = T2.Teacher_ID` instead of querying only the `teachers` table. Do select `T2.Name` instead of `teacher_name` while keeping `COUNT(*)`. Do group by `T2.Name` instead of `teacher_name` to properly count course arrangements per teacher. The amended query now correctly joins the course arrangement and teacher tables to count courses per teacher rather than attempting to count from a single teachers table."
        ],
        "rules": [
            "1) When answering about \"names of teachers and how many courses they teach\": make sure the output order: T2.Name, COUNT(*). 2) When combining course_arrange as T1 and teacher as T2 for shared entities: link rows where T1.Teacher_ID = T2.Teacher_ID exactly as shown; keep only matching pairs (inner match). 3) When the question asks for \"count of courses\" per teacher: compute the number of course arrangement rows using COUNT(*) grouped by T2.Name. 4) When the question mentions \"names of teachers\": \"teacher names\" actually means T2.Name in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT teacher_name, COUNT(*) FROM teachers GROUP BY teacher_name;",
            "SELECT T2.Name, COUNT(*) \nFROM course_arrange AS T1 \nJOIN teacher AS T2 ON T1.Teacher_ID = T2.Teacher_ID \nGROUP BY T2.Name"
        ],
        "rule_sql": [
            "SELECT T2.Name, COUNT(*) \nFROM course_arrange AS T1 \nINNER JOIN teacher AS T2 ON T1.Teacher_ID = T2.Teacher_ID \nGROUP BY T2.Name"
        ]
    },
    "6": {
        "db_id": "concert_singer",
        "question": "Show the name and the release year of the song by the youngest singer.",
        "ground_truth": "SELECT song_name ,  song_release_year FROM singer ORDER BY age LIMIT 1",
        "amends": [
            "Do select `song_name` and `song_release_year` instead of `name` and `release_year`. Do use table `singer` instead of `songs`. Do order by `age` instead of `singer_age`. The amended query now correctly retrieves song information from the singer table ordered by age."
        ],
        "rules": [
            "1) When the question asks for song name and release year: select \"song_name\" and \"song_release_year\" as output columns. 2) When retrieving information about songs by singers: use the \"singer\" table instead of a \"songs\" table. 3) When ordering by the youngest singer: order by \"age\" in ascending order and keep only the first row. 4) When the question mentions \"song by the youngest singer\": the output should show the song details from the singer with the minimum age value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, release_year FROM songs ORDER BY singer_age ASC LIMIT 1;",
            "SELECT Song_Name, Song_release_year FROM singer ORDER BY Age ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT \"Song_Name\", \"Song_release_year\" FROM \"singer\" ORDER BY \"Age\" ASC LIMIT 1;"
        ]
    },
    "704": {
        "db_id": "world_1",
        "question": "How many countries have a republic as their form of government?",
        "ground_truth": "SELECT count(*) FROM country WHERE GovernmentForm  =  \"Republic\"",
        "amends": [
            "Do reference table `country` instead of `countries` and use column `GovernmentForm` instead of `government_form` while maintaining the same filter condition for Republic. Do use double quotes `\"Republic\"` instead of single quotes `'Republic'` for the string literal, though this is a cosmetic difference that doesn't affect functionality. The amended query now correctly counts records from the proper table with the accurate column name while preserving the intended filtering logic."
        ],
        "rules": [
            "1) When answering about \"countries with a republic form of government\": reference table \"country\" instead of \"countries\". 2) When filtering for republic form of government: use column \"GovernmentForm\" instead of \"government_form\". 3) When specifying the literal value for republic: use double quotes \"Republic\" instead of single quotes 'Republic'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE government_form = 'Republic';",
            "SELECT COUNT(*) FROM country WHERE GovernmentForm = \"Republic\";"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM country WHERE GovernmentForm = \"Republic\";"
        ]
    },
    "86": {
        "db_id": "pets_1",
        "question": "What is the average age for all students who do not own any pets ?",
        "ground_truth": "select avg(age) from student where stuid not in (select stuid from has_pet)",
        "amends": [
            "Do reference the `student` table instead of `students` in the FROM clause. Do use a subquery with `stuid not in (select stuid from has_pet)` instead of filtering on `pet_count = 0` in the WHERE clause. Do maintain the same `AVG(age)` aggregate function in the SELECT list. The amended query now correctly identifies students without pets by checking their absence from the has_pet table rather than relying on a potentially incorrect pet_count column, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about \"students who do not own any pets\": use a subquery to check for students whose stuid is not present in the has_pet table using \"stuid not in (select stuid from has_pet)\" instead of filtering on pet_count. 2) When computing average age for students: use the AVG(age) aggregate function on the student table. 3) When referencing the main student table: use the exact table name \"student\" (not \"students\") as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age) FROM students WHERE pet_count = 0;",
            "SELECT AVG(Age) FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Pet)"
        ],
        "rule_sql": [
            "SELECT AVG(Age) FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Pet)"
        ]
    },
    "385": {
        "db_id": "course_teach",
        "question": "What are the age and hometown of teachers?",
        "ground_truth": "SELECT Age ,  Hometown FROM teacher",
        "amends": [
            "Do select `Age` and `Hometown` columns instead of `name` and `subject`. Do reference the `teacher` table instead of `teachers`. The amended query now correctly retrieves age and hometown information from the teacher table."
        ],
        "rules": [
            "1) When the question asks for \"age and hometown of teachers\": select columns \"Age\" and \"Hometown\" from table \"teacher\". 2) When referring to the teacher entity: use the exact table name \"teacher\" (not \"teachers\"). 3) When producing output: maintain the order of columns as \"Age\" followed by \"Hometown\" as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, subject FROM teachers;",
            "SELECT Age, Hometown FROM teacher;"
        ],
        "rule_sql": [
            "SELECT Age, Hometown FROM teacher;"
        ]
    },
    "878": {
        "db_id": "network_1",
        "question": "Which grade has the most high schoolers?",
        "ground_truth": "SELECT grade FROM Highschooler GROUP BY grade ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference the table as `Highschooler` instead of `students` and remove the explicit column alias `student_count` instead of keeping it. Do remove the `WHERE` filter `school_level = 'high school'` instead of including it since the table name already implies the context. Do use the aggregate function `count(*)` directly in the `ORDER BY` clause instead of referencing the alias `student_count`. The amended query now correctly identifies the most common grade among high school students by counting records per grade and ordering by the count in descending order.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, as the query only needs to return the grade with the highest count rather than both the grade and its count. Do keep the `GROUP BY grade` and `ORDER BY count(*) DESC LIMIT 1` unchanged since they correctly identify the grade with the maximum frequency. The amended query now matches RIGHT_SQL's behavior by returning only the grade value with the highest occurrence count."
        ],
        "rules": [
            "1) When answering about \"which grade has the most high schoolers\": use the table \"Highschooler\" instead of \"students\" since the table name implies the context. 2) When counting high school students per grade: use count(*) directly without an explicit column alias in the output. 3) When ordering results by count: use count(*) directly in the order by clause instead of referencing an alias. 4) When the question asks for \"the most\": rank rows by count(*) in descending order and keep only the first row.",
            "1) When answering about \"which grade has the most high schoolers\": make sure the output order: grade only without the count value. 2) When the question asks for the grade with the highest count: rank rows by count of high schoolers in descending order and keep the first 1 row. 3) When the question says \"per grade\"/\"by grade\": organize results by grade and compute the count of high schoolers per group. 4) When counting high schoolers: use the canonical counting method for entities in the database (typically counting rows or a primary key)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT grade, COUNT(*) as student_count FROM students WHERE school_level = 'high school' GROUP BY grade ORDER BY student_count DESC LIMIT 1;",
            "SELECT grade, COUNT(*) FROM Highschooler GROUP BY grade ORDER BY COUNT(*) DESC LIMIT 1",
            "SELECT grade FROM Highschooler GROUP BY grade ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT grade FROM Highschooler GROUP BY grade ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "286": {
        "db_id": "employee_hire_evaluation",
        "question": "Which shops run with no employees? Find the shop names",
        "ground_truth": "SELECT name FROM shop WHERE shop_id NOT IN (SELECT shop_id FROM hiring)",
        "amends": [
            "Do select `name` from the `shop` table instead of `shop_name` from `shops`. Do use a subquery with `NOT IN` to filter shops that are not in the hiring table instead of checking for `employee_count = 0`. Do reference `shop_id` in both the main query and subquery instead of using different column names and logic. The amended query now correctly identifies shops without any hiring records by checking their absence from the hiring table rather than relying on a potentially incorrect employee count field."
        ],
        "rules": [
            "1) When the question asks for shop names: use the exact column name \"name\" from the \"shop\" table instead of \"shop_name\" from \"shops\". 2) When identifying shops with no employees: use a subquery with NOT IN to filter shops that are not present in the hiring table instead of checking for employee_count = 0. 3) When linking between the shop table and hiring table: use the exact column \"shop_id\" in both the main query and subquery for proper comparison."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT shop_name FROM shops WHERE employee_count = 0;",
            "SELECT Name FROM shop WHERE Shop_ID NOT IN (SELECT Shop_ID FROM hiring)"
        ],
        "rule_sql": [
            "SELECT name FROM shop WHERE shop_id NOT IN (SELECT shop_id FROM hiring)"
        ]
    },
    "520": {
        "db_id": "student_transcripts_tracking",
        "question": "How many different degrees are offered?",
        "ground_truth": "SELECT count(DISTINCT degree_summary_name) FROM Degree_Programs",
        "amends": [
            "Do select `count(DISTINCT degree_summary_name)` instead of `COUNT(*)`. Do query from `Degree_Programs` instead of `degrees`. The amended query now correctly counts distinct degree summary names from the Degree_Programs table instead of counting all rows from the degrees table."
        ],
        "rules": [
            "1) When answering about \"different degrees offered\": count distinct values of \"degree_summary_name\" column. 2) When querying for degree information: use the \"Degree_Programs\" table instead of \"degrees\" table. 3) When counting distinct values: use the exact column token \"degree_summary_name\" with DISTINCT operation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM degrees;",
            "SELECT COUNT(DISTINCT degree_summary_name) FROM Degree_Programs;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT degree_summary_name) FROM Degree_Programs;"
        ]
    },
    "128": {
        "db_id": "car_1",
        "question": "What is the average weight and year for each year?",
        "ground_truth": "SELECT avg(Weight) ,  YEAR FROM CARS_DATA GROUP BY YEAR;",
        "amends": [
            "Do select `avg(Weight)` and `YEAR` instead of `year` and `AVG(weight) as average_weight`. Do group by `YEAR` instead of `weight`. Do use table `CARS_DATA` instead of `table_name`. The amended query now correctly calculates average weight grouped by year rather than incorrectly grouping by weight itself, matching the intended behavior.",
            "Do place the `YEAR` column after the aggregate function instead of before it in the SELECT list. Do maintain the same `AVG(Weight)` aggregate calculation and `GROUP BY YEAR` clause without changes. The amended query now correctly follows SQL syntax conventions where non-aggregated columns should appear after aggregate functions in the SELECT list when using GROUP BY, ensuring the query matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"average weight and year for each year\": make sure the output order: YEAR, avg(Weight). 2) When the question mentions \"each year\": group results by the exact column token \"YEAR\". 3) When computing average weight: use the exact column token \"Weight\" with the avg function. 4) When selecting from the database: use the exact table name \"CARS_DATA\" instead of generic table names.",
            "1) When answering about \"average weight and year for each year\": make sure the output order: average weight first, then year. 2) When grouping by year: organize results by the \"YEAR\" column and compute the average of \"Weight\" per group. 3) When producing output columns: place the aggregate function result (AVG(Weight)) before the grouping column (YEAR) in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, AVG(weight) as average_weight FROM table_name GROUP BY weight;",
            "SELECT YEAR, AVG(Weight) FROM cars_data GROUP BY YEAR;",
            "SELECT AVG(Weight), YEAR FROM cars_data GROUP BY YEAR"
        ],
        "rule_sql": [
            "SELECT AVG(Weight) AS AverageWeight, Year FROM CARS_DATA GROUP BY Year ORDER BY Year;"
        ]
    },
    "99": {
        "db_id": "car_1",
        "question": "Find the name of the makers that produced some cars in the year of 1970?",
        "ground_truth": "SELECT DISTINCT T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model JOIN CARS_DATA AS T4 ON T3.MakeId  =  T4.id WHERE T4.year  =  '1970';",
        "amends": [
            "Do use `DISTINCT T1.Maker` instead of `maker` to eliminate duplicates. Do add joins to `CAR_MAKERS AS T1`, `MODEL_LIST AS T2`, `CAR_NAMES AS T3`, and `CARS_DATA AS T4` instead of querying only `cars`. Do join on `T1.Id = T2.Maker` and `T2.model = T3.model` and `T3.MakeId = T4.id` instead of no join conditions. Do filter on `T4.year = '1970'` instead of `year = 1970` with proper table qualification and string literal. The amended query now correctly identifies car makers from 1970 by traversing the proper relationship chain between tables."
        ],
        "rules": [
            "1) When answering about \"makers that produced cars in 1970\": use DISTINCT T1.Maker to eliminate duplicate maker names. 2) When combining tables for car maker information: link CAR_MAKERS AS T1, MODEL_LIST AS T2, CAR_NAMES AS T3, and CARS_DATA AS T4 using T1.Id = T2.Maker and T2.model = T3.model and T3.MakeId = T4.id to traverse the relationship chain. 3) When filtering for cars from a specific year: use T4.year = '1970' with the exact string literal '1970' and proper table qualification. 4) When the question asks for \"makers that produced some cars\": ensure the query returns only makers that have at least one car from the specified year by using inner joins between all tables."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT maker FROM cars WHERE year = 1970;",
            "SELECT DISTINCT T1.Maker\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nJOIN car_names AS T3 ON T2.Model = T3.Model\nJOIN cars_data AS T4 ON T3.MakeId = T4.Id\nWHERE T4.Year = '1970'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Maker\nFROM car_makers AS T1\nINNER JOIN model_list AS T2 ON T1.Id = T2.Maker\nINNER JOIN car_names AS T3 ON T2.Model = T3.Model\nINNER JOIN cars_data AS T4 ON T3.MakeId = T4.Id\nWHERE T4.Year = '1970'"
        ]
    },
    "255": {
        "db_id": "flight_2",
        "question": "Find the number of flights landing in the city of Aberdeen or Abilene.",
        "ground_truth": "SELECT count(*) FROM Flights AS T1 JOIN Airports AS T2 ON T1.DestAirport  =  T2.AirportCode WHERE T2.city  =  \"Aberdeen\" OR T2.city  =  \"Abilene\"",
        "amends": [
            "Do add `JOIN Airports AS T2 ON T1.DestAirport = T2.AirportCode` instead of querying only the flights table. Do change the filter to `T2.city = \"Aberdeen\" OR T2.city = \"Abilene\"` instead of `departure_city IN ('Aberdeen', 'Abilene')` to correctly reference the joined airports table's city column rather than a non-existent departure_city column. Do remove the incorrect direct column reference and instead filter through the proper join relationship between flights and airports tables. The amended query now correctly counts flights destined for Aberdeen or Abilene by joining with the airports table to match on city names through airport codes."
        ],
        "rules": [
            "1) When answering about flights landing in specific cities: join the flights table (T1) with the airports table (T2) using T1.DestAirport = T2.AirportCode to connect flight destinations to airport information. 2) When the question mentions cities \"Aberdeen\" or \"Abilene\": filter using T2.city = \"Aberdeen\" OR T2.city = \"Abilene\" with exact case and spelling. 3) When counting flights: count all rows from the joined result that match the city filter condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE departure_city IN ('Aberdeen', 'Abilene');",
            "SELECT COUNT(*) \nFROM flights AS T1\nJOIN airports AS T2 ON T1.DestAirport = T2.AirportCode\nWHERE T2.City = 'Aberdeen' OR T2.City = 'Abilene'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM flights T1\nJOIN airports T2 ON T1.DestAirport = T2.AirportCode\nWHERE T2.City = 'Aberdeen' OR T2.City = 'Abilene'"
        ]
    },
    "668": {
        "db_id": "poker_player",
        "question": "Return the money rank of the poker player with the greatest height.",
        "ground_truth": "SELECT T2.Money_Rank FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T1.Height DESC LIMIT 1",
        "amends": [
            "Do select `T2.Money_Rank` from the joined table instead of `money_rank` from a single table. Do join `people AS T1` with `poker_player AS T2` on `T1.People_ID = T2.People_ID` instead of querying only `poker_players`. Do order by `T1.Height` from the people table instead of `height` from poker_players. The amended query now correctly retrieves money rank by joining related tables and ordering by the appropriate height column, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"money rank of the poker player with the greatest height\": make sure the output order: T2.Money_Rank. 2) When combining people AS T1 and poker_player AS T2 for shared entities: link rows where T1.People_ID = T2.People_ID exactly as shown; keep only matching pairs (inner match). 3) When the question mentions \"greatest height\": rank rows by T1.Height in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT money_rank FROM poker_players ORDER BY height DESC LIMIT 1;",
            "SELECT T2.Money_Rank FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T1.Height DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Money_Rank FROM people AS T1 INNER JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T1.Height DESC LIMIT 1"
        ]
    },
    "334": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the codes of template types that have fewer than 3 templates?",
        "ground_truth": "SELECT template_type_code FROM Templates GROUP BY template_type_code HAVING count(*)  <  3",
        "amends": [
            "Do use `count(*) < 3` in the HAVING clause instead of `COUNT(*) > 3` to filter for template type codes with fewer than 3 occurrences rather than more than 3 occurrences. The amended query now correctly identifies template type codes with less than 3 records, matching the intended behavior of the right SQL."
        ],
        "rules": [
            "1) When counting templates per template type: use the exact column \"template_type_code\" for grouping and count all rows using COUNT(*) 2) When filtering for template types with fewer than 3 templates: use the condition COUNT(*) < 3 in the HAVING clause 3) When the question asks for template type codes: output only the \"template_type_code\" column"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code FROM templates GROUP BY template_type_code HAVING COUNT(*) > 3;",
            "SELECT Template_Type_Code\nFROM Templates\nGROUP BY Template_Type_Code\nHAVING COUNT(*) < 3"
        ],
        "rule_sql": [
            "SELECT template_type_code FROM Templates GROUP BY template_type_code HAVING COUNT(*) < 3"
        ]
    },
    "715": {
        "db_id": "world_1",
        "question": "Give me Brazil\u2019s population and life expectancies.",
        "ground_truth": "SELECT Population ,  LifeExpectancy FROM country WHERE Name  =  \"Brazil\"",
        "amends": [
            "Do select `Population` and `LifeExpectancy` instead of `population` and `life_expectancy`. Do use table `country` instead of `countries`. Do filter on `Name = \"Brazil\"` instead of `name = 'Brazil'`. Do omit the `name` column from the SELECT list instead of including it. The amended query now correctly retrieves population and life expectancy data for Brazil from the country table."
        ],
        "rules": [
            "1) When answering about \"Brazil's population and life expectancies\": make sure the output order: \"Population\", \"LifeExpectancy\". 2) When the question mentions \"Brazil\": \"Brazil\" actually means \"Name = \\\"Brazil\\\"\" in schema. 3) When selecting columns: use exact column tokens \"Population\" and \"LifeExpectancy\" instead of similar names. 4) When referring to the table: use table \"country\" instead of similar table names. 5) When filtering for specific country: omit the name column from output and only return the requested population and life expectancy data."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, population, life_expectancy FROM countries WHERE name = 'Brazil';",
            "SELECT Population, LifeExpectancy FROM country WHERE Name = \"Brazil\";"
        ],
        "rule_sql": [
            "SELECT Population, LifeExpectancy FROM country WHERE Name = \"Brazil\";"
        ]
    },
    "705": {
        "db_id": "world_1",
        "question": "How many countries have governments that are republics?",
        "ground_truth": "SELECT count(*) FROM country WHERE GovernmentForm  =  \"Republic\"",
        "amends": [
            "Do reference table `country` instead of `countries` and use column `GovernmentForm` instead of `government`. Do use filter value `\"Republic\"` instead of `'republic'` while maintaining the same case-insensitive logic for counting records where the government form is a republic. The amended query now correctly counts from the proper table and column with the appropriate filter value to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"countries with governments that are republics\": use table \"country\" instead of \"countries\" and column \"GovernmentForm\" instead of \"government\". 2) When filtering for republic governments: use the exact literal value \"Republic\" (with capital R) instead of 'republic'. 3) When counting countries: compute the number of rows where \"GovernmentForm\" equals \"Republic\" in table \"country\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE government = 'republic';",
            "SELECT COUNT(*) FROM country WHERE GovernmentForm = 'Republic';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM country WHERE GovernmentForm = 'Republic';"
        ]
    },
    "333": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all template type codes with less than three templates.",
        "ground_truth": "SELECT template_type_code FROM Templates GROUP BY template_type_code HAVING count(*)  <  3",
        "amends": [
            "Do remove the `COUNT(*) as template_count` column from the SELECT list instead of including it. Do change the HAVING condition to `count(*) < 3` instead of `template_count > 3`, using the aggregate function directly rather than the alias. Do use the correct table name `Templates` (with capital T) instead of `templates` to match the actual schema. The amended query now correctly filters for template type codes that have fewer than 3 templates rather than those with more than 3, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about template type codes with less than three templates: make sure the output order includes only template_type_code. 2) When counting templates per template type code: use the aggregate function count(*) directly in the HAVING condition rather than using an alias. 3) When filtering for template type codes with less than three templates: use the condition count(*) < 3 instead of count(*) > 3. 4) When referring to the templates table: use the exact table name \"Templates\" with capital T instead of lowercase \"templates\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code, COUNT(*) as template_count FROM templates GROUP BY template_type_code HAVING template_count > 3;",
            "SELECT Template_Type_Code FROM Templates GROUP BY Template_Type_Code HAVING COUNT(*) < 3"
        ],
        "rule_sql": [
            "SELECT Template_Type_Code FROM Templates GROUP BY Template_Type_Code HAVING COUNT(*) < 3"
        ]
    },
    "190": {
        "db_id": "flight_2",
        "question": "Return the number of  airports.",
        "ground_truth": "SELECT count(*) FROM AIRPORTS",
        "amends": [
            "Do query the `AIRPORTS` table instead of the `flights` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` to match the correct query's formatting. The amended query now correctly counts records from the AIRPORTS table instead of flights, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"number of airports\": query the \"AIRPORTS\" table instead of the \"flights\" table. 2) When counting records: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" to match the correct formatting."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights;",
            "SELECT count(*) FROM airports;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM airports;"
        ]
    },
    "712": {
        "db_id": "world_1",
        "question": "Which language is the most popular in Aruba?",
        "ground_truth": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Aruba\" ORDER BY Percentage DESC LIMIT 1",
        "amends": [
            "Do select `T2.Language` instead of `language, COUNT(*) as count`. Do join `country AS T1` and `countrylanguage AS T2` instead of querying only `languages`. Do use `ON T1.Code = T2.CountryCode` for the join condition instead of no explicit join. Do filter with `WHERE T1.Name = \"Aruba\"` instead of `WHERE country = 'Aruba'`. Do order by `Percentage DESC` instead of `count DESC`. Do remove the `GROUP BY` clause and aggregate function instead of keeping them. The amended query now correctly retrieves the language with the highest percentage for Aruba instead of counting language occurrences."
        ],
        "rules": [
            "1) When answering about \"most popular language in Aruba\": make sure the output order: T2.Language, T2.Percentage. 2) When the question mentions \"Aruba\": \"Aruba\" actually means \"T1.Name = 'Aruba'\" in schema. 3) When combining country AS T1 and countrylanguage AS T2: link rows where T1.Code = T2.CountryCode exactly as shown; keep only matching pairs (inner match). 4) When the question asks for \"most popular\" language: rank rows by T2.Percentage in descending order and keep the first 1 row. 5) When handling text literals: do not change case, spacing, or punctuation - use exact value 'Aruba'."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language, COUNT(*) as count FROM languages WHERE country = 'Aruba' GROUP BY language ORDER BY count DESC LIMIT 1;",
            "SELECT T2.Language\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nWHERE T1.Name = 'Aruba'\nORDER BY T2.Percentage DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Language, T2.Percentage \nFROM country AS T1 \nINNER JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'Aruba' \nORDER BY T2.Percentage DESC \nLIMIT 1"
        ]
    },
    "574": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the date and id of the transcript with the least number of results?",
        "ground_truth": "SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id ORDER BY count(*) ASC LIMIT 1",
        "amends": [
            "Do select `T2.transcript_date` and `T1.transcript_id` instead of `date` and `id`. Do use `FROM Transcript_Contents AS T1 JOIN Transcripts AS T2` instead of `FROM transcript`. Do add `ON T1.transcript_id = T2.transcript_id` join condition instead of omitting it. Do add `GROUP BY T1.transcript_id` instead of omitting grouping. Do order by `count(*)` instead of `COUNT(results)`. Do maintain `ASC LIMIT 1` ordering and limiting. The amended query now correctly joins tables, groups by transcript_id, and counts records instead of attempting to aggregate results without grouping."
        ],
        "rules": [
            "1) When answering about \"date and id of the transcript with the least number of results\": make sure the output order: T2.transcript_date, T1.transcript_id. 2) When the question mentions \"date\": \"date\" actually means \"T2.transcript_date\" in schema. 3) When the question mentions \"id\": \"id\" actually means \"T1.transcript_id\" in schema. 4) When combining Transcript_Contents as T1 and Transcripts as T2 for shared entities: link rows where T1.transcript_id = T2.transcript_id; keep only matching pairs (inner match). 5) When the question asks for \"number of results\" per transcript: organize results by T1.transcript_id and compute count(*) per group. 6) When the question asks for the transcript with the \"least number of results\": rank rows by count(*) in ascending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT date, id FROM transcript ORDER BY COUNT(results) ASC LIMIT 1;",
            "SELECT T2.transcript_date, T1.transcript_id\nFROM Transcript_Contents AS T1\nJOIN Transcripts AS T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nORDER BY COUNT(*) ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.transcript_date, T1.transcript_id\nFROM Transcript_Contents T1\nINNER JOIN Transcripts T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nORDER BY COUNT(*) ASC\nLIMIT 1;"
        ]
    },
    "136": {
        "db_id": "car_1",
        "question": "What is the average horsepower for all cars produced before 1980 ?",
        "ground_truth": "select avg(horsepower) from cars_data where year  <  1980;",
        "amends": [
            "Do reference table `cars_data` instead of `cars` in the FROM clause. Do use filter condition `year < 1980` instead of `year >= 1980` in the WHERE clause, changing the comparison operator and threshold value to select pre-1980 vehicles rather than post-1980 ones. The amended query now correctly calculates the average horsepower for cars manufactured before 1980, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"average horsepower for all cars produced before 1980\": make sure the output order: AVG(horsepower). 2) When the question mentions \"cars\": \"cars\" actually means \"cars_data\" in schema. 3) When the question mentions \"before 1980\": use filter condition year < 1980 to select pre-1980 vehicles."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(horsepower) FROM cars WHERE year >= 1980;",
            "SELECT AVG(Horsepower) FROM cars_data WHERE Year < 1980"
        ],
        "rule_sql": [
            "SELECT AVG(Horsepower) FROM cars_data WHERE Year < 1980"
        ]
    },
    "653": {
        "db_id": "poker_player",
        "question": "What is the average earnings of poker players?",
        "ground_truth": "SELECT avg(Earnings) FROM poker_player",
        "amends": [
            "Do reference table `poker_player` instead of `players` and use column `Earnings` instead of `earnings`. Do remove the `WHERE sport = 'basketball'` filter instead of keeping it, as the query should calculate average earnings across all poker players rather than filtering for basketball players. The amended query now correctly calculates the average earnings from the poker_player table without any sport-based filtering."
        ],
        "rules": [
            "1) When answering about \"average earnings of poker players\": use table \"poker_player\" and column \"Earnings\" exactly as shown in the schema. 2) When the question mentions \"poker players\": this refers to all records in the \"poker_player\" table without any sport-based filtering. 3) When calculating average earnings: compute the average of the \"Earnings\" column across all rows in the \"poker_player\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(earnings) FROM players WHERE sport = 'basketball';",
            "SELECT AVG(Earnings) FROM poker_player"
        ],
        "rule_sql": [
            "SELECT AVG(Earnings) FROM poker_player;"
        ]
    },
    "522": {
        "db_id": "student_transcripts_tracking",
        "question": "How many degrees does the engineering department have?",
        "ground_truth": "SELECT count(*) FROM Departments AS T1 JOIN Degree_Programs AS T2 ON T1.department_id  =  T2.department_id WHERE T1.department_name  =  'engineer'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM departments WHERE department_name = 'engineering';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS degree_count\nFROM Degree_Programs dp\nJOIN Departments d ON dp.department_id = d.department_id\nWHERE d.department_name = 'Engineering';"
        ]
    },
    "1026": {
        "db_id": "singer",
        "question": "List the name of singers that do not have any song.",
        "ground_truth": "SELECT Name FROM singer WHERE Singer_ID NOT IN (SELECT Singer_ID FROM song)",
        "amends": [
            "Do select `Name` from `singer` instead of `name` from `singers`. Do use a `NOT IN` subquery checking for `Singer_ID` values that exist in the `song` table instead of filtering with `song_id IS NULL`. Do reference the correct table name `singer` instead of `singers` and use the proper column `Singer_ID` for the correlation instead of the incorrect `song_id` field. The amended query now correctly identifies singers who have no associated songs by checking for missing relationships in the song table rather than relying on null values, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"name of singers\": select \"Name\" from table \"singer\" instead of \"name\" from \"singers\". 2) When identifying singers without songs: use a NOT IN subquery checking for \"Singer_ID\" values that exist in the \"song\" table instead of filtering with \"song_id IS NULL\". 3) When referencing the singer table: use the correct table name \"singer\" instead of \"singers\". 4) When correlating between singer and song tables: use the proper column \"Singer_ID\" for the correlation instead of the incorrect \"song_id\" field."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers WHERE song_id IS NULL;",
            "SELECT Name FROM singer WHERE Singer_ID NOT IN (SELECT Singer_ID FROM song)"
        ],
        "rule_sql": [
            "SELECT \"Name\" FROM \"singer\" WHERE \"Singer_ID\" NOT IN (SELECT \"Singer_ID\" FROM \"song\")"
        ]
    },
    "596": {
        "db_id": "tvshow",
        "question": "What is the country with the most number of TV Channels and how many does it have?",
        "ground_truth": "SELECT Country ,  count(*) FROM TV_Channel GROUP BY Country ORDER BY count(*) DESC LIMIT 1;",
        "amends": [
            "Do use `count(*)` without an alias instead of `COUNT(*) as channel_count` in the SELECT list. Do reference the table as `TV_Channel` instead of `tv_channels` in the FROM clause. Do use `Country` with proper case instead of `country` in both SELECT and GROUP BY clauses. Do order by `count(*)` directly instead of the aliased `channel_count` in the ORDER BY clause. The amended query now correctly counts channels per country and returns the country with the highest count, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"country with the most number of TV Channels\": make sure the output order: Country, count(*) 2) When the question mentions \"country\": \"country\" actually means \"Country in schema\" 3) When the question mentions \"most number\" or \"highest count\": rank rows by count(*) in descending direction and keep the first 1 row. 4) When the question asks for \"count of TV Channels\" per country: compute the number of rows using the canonical key for TV_Channel (Country). 5) When the question says \"per country\"/\"by country\": organize results by Country and compute count(*) per group. 6) When choosing identifier delimiters: do not replace proper case identifiers with lowercase forms. 7) When referring to table roles: use TV_Channel as the base table with no alias needed."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country, COUNT(*) as channel_count FROM tv_channels GROUP BY country ORDER BY channel_count DESC LIMIT 1;",
            "SELECT Country, count(*) FROM TV_Channel GROUP BY Country ORDER BY count(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Country, COUNT(*) FROM TV_Channel GROUP BY Country ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "784": {
        "db_id": "world_1",
        "question": "Which cities are in European countries where English is not the official language?",
        "ground_truth": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')",
        "amends": [
            "Do use `DISTINCT` on `T2.Name` instead of selecting `city_name` without deduplication. Do join `country AS T1` with `city AS T2` on `T2.CountryCode = T1.Code` instead of using a subquery with `IN` condition. Do filter with `T1.Continent = 'Europe'` instead of checking continent in a subquery. Do use `T1.Name NOT IN` with a correlated subquery checking official English language status through `countrylanguage` table instead of simple `official_language != 'English'` condition. Do add explicit table aliases `T1`, `T2`, `T3`, and `T4` instead of using unaliased table references. The amended query now correctly identifies European cities in countries where English is not an official language, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about cities in European countries where English is not the official language: make sure the output order includes T2.Name as the city name. 2) When combining country table as T1 and city table as T2: link rows where T2.CountryCode = T1.Code and keep only matching pairs (inner match). 3) When filtering for European countries: use T1.Continent = 'Europe' exactly as specified. 4) When checking for English not being an official language: use T1.Name NOT IN with a correlated subquery through countrylanguage table instead of simple official_language comparison. 5) When selecting city names: use DISTINCT on T2.Name to remove duplicate city entries."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city_name FROM cities WHERE country IN (SELECT country FROM countries WHERE continent = 'Europe' AND official_language != 'English')",
            "SELECT DISTINCT T2.Name\nFROM country AS T1\nJOIN city AS T2 ON T2.CountryCode = T1.Code\nWHERE T1.Continent = 'Europe'\nAND T1.Code NOT IN (\n    SELECT T3.CountryCode\n    FROM countrylanguage AS T3\n    WHERE T3.Language = 'English' AND T3.IsOfficial = 'T'\n)"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.Name \nFROM country T1 \nINNER JOIN city T2 ON T2.CountryCode = T1.Code \nWHERE T1.Continent = 'Europe' \nAND T1.Name NOT IN (\n    SELECT CountryCode \n    FROM countrylanguage \n    WHERE Language = 'English' AND IsOfficial = 'T'\n)\nORDER BY T2.Name"
        ]
    },
    "821": {
        "db_id": "world_1",
        "question": "Return the codes of countries for which Spanish is the predominantly spoken language.",
        "ground_truth": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  \"Spanish\" GROUP BY CountryCode",
        "amends": [
            "Do select `CountryCode` and `max(Percentage)` instead of `country_code` alone. Do query from `countrylanguage` table instead of `countries` table. Do use aggregate function `max(Percentage)` with `GROUP BY CountryCode` instead of selecting individual rows without aggregation. Do filter on `LANGUAGE = \"Spanish\"` instead of `language = 'Spanish'` to match the correct column name and value format. The amended query now correctly retrieves the maximum Spanish language percentage for each country code from the appropriate table."
        ],
        "rules": [
            "1) When answering about country codes where Spanish is predominantly spoken: select \"CountryCode\" and the maximum \"Percentage\" value. 2) When the question mentions \"countries\": the data actually comes from the \"countrylanguage\" table instead of the \"countries\" table. 3) When the question asks for \"predominantly spoken language\": use aggregate function max(\"Percentage\") with GROUP BY \"CountryCode\" instead of selecting individual rows. 4) When filtering for Spanish language: use the exact condition \"LANGUAGE\" = \"Spanish\" to match the correct column name and value format. 5) When combining data for language analysis: group by \"CountryCode\" to get the maximum percentage per country."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country_code FROM countries WHERE language = 'Spanish';",
            "SELECT CountryCode, MAX(Percentage) FROM countrylanguage WHERE Language = \"Spanish\" GROUP BY CountryCode"
        ],
        "rule_sql": [
            "SELECT CountryCode, MAX(Percentage) FROM countrylanguage WHERE Language = 'Spanish' GROUP BY CountryCode"
        ]
    },
    "487": {
        "db_id": "wta_1",
        "question": "Find the first name, country code and birth date of the winner who has the highest rank points in all matches.",
        "ground_truth": "SELECT T1.first_name ,  T1.country_code ,  T1.birth_date FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id ORDER BY T2.winner_rank_points DESC LIMIT 1",
        "amends": [
            "Do specify table aliases `T1.first_name`, `T1.country_code`, and `T1.birth_date` instead of unqualified column references. Do add `FROM players AS T1 JOIN matches AS T2` instead of the single table `winners`. Do use join condition `ON T1.player_id = T2.winner_id` instead of no join. Do order by `T2.winner_rank_points DESC` instead of `rank_points DESC`. The amended query now correctly joins player and match data to find the winner with the highest rank points."
        ],
        "rules": [
            "1) When answering about \"first name, country code and birth date of the winner who has the highest rank points\": make sure the output order: T1.first_name, T1.country_code, T1.birth_date. 2) When combining players and matches tables: link rows where T1.player_id = T2.winner_id and keep only matching pairs (inner match). 3) When the question mentions \"highest rank points\": rank rows by T2.winner_rank_points in descending order and keep the first 1 row. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, country_code, birth_date FROM winners ORDER BY rank_points DESC LIMIT 1;",
            "SELECT T1.first_name, T1.country_code, T1.birth_date\nFROM players AS T1\nJOIN matches AS T2 ON T1.player_id = T2.winner_id\nORDER BY T2.winner_rank_points DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.country_code, T1.birth_date\nFROM players T1\nINNER JOIN matches T2 ON T1.player_id = T2.winner_id\nORDER BY T2.winner_rank_points DESC\nLIMIT 1;"
        ]
    },
    "688": {
        "db_id": "voter_1",
        "question": "List the contestant numbers and names, ordered by contestant name descending.",
        "ground_truth": "SELECT contestant_number ,  contestant_name FROM contestants ORDER BY contestant_name DESC",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT contestant_number, contestant_name FROM contestants ORDER BY contestant_name ASC;"
        ],
        "rule_sql": [
            "SELECT contestant_number, contestant_name FROM CONTESTANTS ORDER BY contestant_name DESC;"
        ]
    },
    "343": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Which template type code is used by most number of documents?",
        "ground_truth": "SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `Templates AS T1` to `Documents AS T2` on `T1.template_id = T2.template_id` instead of querying only the `documents` table without any join. Do select only `T1.template_type_code` instead of selecting both `template_type_code` and `COUNT(*) as document_count`. Do group by `T1.template_type_code` instead of grouping by `template_type_code` without table qualification. Do order by `count(*) DESC` instead of ordering by `document_count ASC`. The amended query now correctly identifies the template type with the highest document count by joining the Templates and Documents tables and ordering by descending count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"template type code used by most documents\": join Templates as T1 to Documents as T2 on T1.template_id = T2.template_id to link template information with document records. 2) When counting documents per template type: count the number of rows using the canonical key from the join. 3) When grouping by template type: organize results by T1.template_type_code to get counts per template type. 4) When finding the most used template type: order the results by count in descending order to identify the highest count. 5) When selecting output columns: return only T1.template_type_code as the result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code, COUNT(*) as document_count FROM documents GROUP BY template_type_code ORDER BY document_count ASC LIMIT 1;",
            "SELECT T1.Template_Type_Code\nFROM Templates AS T1\nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID\nGROUP BY T1.Template_Type_Code\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Template_Type_Code\nFROM Templates T1\nJOIN Documents T2 ON T1.Template_ID = T2.Template_ID\nGROUP BY T1.Template_Type_Code\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "67": {
        "db_id": "pets_1",
        "question": "Find the type and weight of the youngest pet.",
        "ground_truth": "SELECT pettype ,  weight FROM pets ORDER BY pet_age LIMIT 1",
        "amends": [
            "Do use column name `pettype` instead of `type` in the SELECT list. Do use column name `pet_age` instead of `age` in the ORDER BY clause. The amended query now correctly references the actual column names and matches the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"type\" of a pet: use the exact column name \"pettype\" instead of \"type\" in the output. 2) When ordering by age to find the youngest pet: use the exact column name \"pet_age\" instead of \"age\" in the ordering condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type, weight FROM pets ORDER BY age ASC LIMIT 1;",
            "SELECT PetType, weight FROM Pets ORDER BY pet_age ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT PetType, weight FROM Pets ORDER BY pet_age ASC LIMIT 1;"
        ]
    },
    "427": {
        "db_id": "museum_visit",
        "question": "Find the number of visitors who did not visit any museum opened after 2010.",
        "ground_truth": "SELECT count(*) FROM visitor WHERE id NOT IN (SELECT t2.visitor_id FROM museum AS t1 JOIN visit AS t2 ON t1.Museum_ID  =  t2.Museum_ID WHERE t1.open_year  >  2010)",
        "amends": [
            "Do reference the `visitor` table instead of `visitors` and use `id` instead of `visitor_id` for the main table. Do use an explicit join between `museum` and `visit` tables with `ON t1.Museum_ID = t2.Museum_ID` instead of nested subqueries. Do filter on `t1.open_year > 2010` instead of `year_opened > 2010` and reference `t2.visitor_id` in the subquery instead of just `visitor_id`. Do use proper table aliases `t1` and `t2` throughout the subquery instead of anonymous table references. The amended query now correctly identifies visitors who haven't visited museums opened after 2010 using proper table relationships and joins."
        ],
        "rules": [
            "1) When the question mentions \"visitors\": use the exact table name \"visitor\" instead of \"visitors\" and use the column \"id\" instead of \"visitor_id\" for the main table. 2) When combining museum and visit tables: link rows where t1.Museum_ID = t2.Museum_ID using an explicit join instead of nested subqueries. 3) When filtering museums by opening year after 2010: use the exact column name \"open_year\" instead of \"year_opened\" and filter with t1.open_year > 2010. 4) When referencing visitor IDs in subqueries: use the exact column name \"t2.visitor_id\" with proper table alias instead of just \"visitor_id\". 5) When using table aliases: consistently use t1 for museum table and t2 for visit table throughout the subquery instead of anonymous references."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM visitors WHERE visitor_id NOT IN (SELECT visitor_id FROM visits WHERE museum_id IN (SELECT museum_id FROM museums WHERE year_opened > 2010))",
            "SELECT COUNT(*) \nFROM visitor \nWHERE ID NOT IN (\n    SELECT DISTINCT t2.visitor_ID \n    FROM museum t1 \n    JOIN visit t2 ON t1.Museum_ID = t2.Museum_ID \n    WHERE t1.Open_Year > '2010'\n)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM visitor \nWHERE ID NOT IN (\n    SELECT t2.visitor_ID \n    FROM museum t1 \n    JOIN visit t2 ON t1.Museum_ID = t2.Museum_ID \n    WHERE t1.Open_Year > '2010'\n)"
        ]
    },
    "145": {
        "db_id": "car_1",
        "question": "how many cars were produced in 1980?",
        "ground_truth": "SELECT count(*) FROM CARS_DATA WHERE YEAR  =  1980;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` to correctly access the source data table. Do maintain the same filter condition `YEAR = 1980` to count records from the specified year. The amended query now correctly counts records from the appropriate data source table while preserving the same filtering logic and aggregation behavior."
        ],
        "rules": [
            "1) When answering about \"how many cars were produced in 1980\": use table \"CARS_DATA\" instead of \"cars\" to access the correct data source. 2) When filtering for records from year 1980: apply the condition YEAR = 1980 to select only records from that specific year. 3) When counting the number of cars produced: count all records that satisfy the year condition using the appropriate counting method."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE year = 1980;",
            "SELECT COUNT(*) FROM cars_data WHERE Year = 1980;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM cars_data WHERE Year = 1980;"
        ]
    },
    "42": {
        "db_id": "concert_singer",
        "question": "What are the names and locations of the stadiums that had concerts that occurred in both 2014 and 2015?",
        "ground_truth": "SELECT T2.name ,  T2.location FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.Year  =  2014 INTERSECT SELECT T2.name ,  T2.location FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.Year  =  2015",
        "amends": [
            "Do use `concert` and `stadium` tables with `JOIN` on `stadium_id` instead of querying `stadiums` table alone. Do filter by `Year = 2014` in one branch and `Year = 2015` in another instead of the impossible `year = 2014 AND year = 2015`. Do use `INTERSECT` to find stadiums that hosted concerts in both years instead of attempting to find a single row satisfying both year conditions simultaneously. Do reference columns with table aliases `T1` and `T2` instead of direct column names. The amended query now correctly identifies stadiums that hosted concerts in both 2014 and 2015, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about stadiums that had concerts in both 2014 and 2015: use the concert table and stadium table instead of just the stadiums table. 2) When combining concert and stadium tables: link rows where T1.stadium_id = T2.stadium_id using an inner match. 3) When filtering for concerts in 2014: use T1.Year = 2014 as one condition. 4) When filtering for concerts in 2015: use T1.Year = 2015 as another condition. 5) When finding stadiums with concerts in both years: use INTERSECT to combine results from the 2014 and 2015 filters instead of trying to satisfy both year conditions on the same row. 6) When selecting output columns: include name and location from the stadium table with proper table aliases. 7) When referencing columns: use table aliases T1 and T2 instead of direct column names without aliases."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, location FROM stadiums WHERE year = 2014 AND year = 2015;",
            "SELECT DISTINCT s.Name, s.Location\nFROM stadium s\nJOIN concert c1 ON s.Stadium_ID = c1.Stadium_ID\nJOIN concert c2 ON s.Stadium_ID = c2.Stadium_ID\nWHERE c1.Year = '2014' AND c2.Year = '2015'"
        ],
        "rule_sql": [
            "SELECT T2.Name, T2.Location\nFROM concert T1\nINNER JOIN stadium T2 ON T1.Stadium_ID = T2.Stadium_ID\nWHERE T1.Year = '2014'\nINTERSECT\nSELECT T2.Name, T2.Location\nFROM concert T1\nINNER JOIN stadium T2 ON T1.Stadium_ID = T2.Stadium_ID\nWHERE T1.Year = '2015'"
        ]
    },
    "224": {
        "db_id": "flight_2",
        "question": "Which city is the most frequent source airport?",
        "ground_truth": "SELECT T1.City FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.SourceAirport GROUP BY T1.City ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `JOIN FLIGHTS AS T2 ON T1.AirportCode = T2.SourceAirport` instead of querying only the airports table. Do change the FROM clause to include `AIRPORTS AS T1` instead of just `airports`. Do use `T1.City` in the SELECT list instead of just `city`. Do maintain the `GROUP BY T1.City` instead of `GROUP BY city`. Do keep `ORDER BY count(*) DESC LIMIT 1` unchanged. The amended query now correctly identifies cities with the most departing flights by joining airports with flights data instead of just counting airports per city, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"most frequent source airport city\": make sure the output order: T1.City. 2) When the question mentions \"source airport\": \"source airport\" actually means \"T2.SourceAirport in schema\". 3) When combining T1 and T2 for shared entities: link rows where T1.AirportCode = T2.SourceAirport exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"most frequent\": rank rows by count of flights in descending order and keep the first 1 row. 5) When the question asks for \"count of flights\": compute the number of rows using the T2.SourceAirport as the counting key."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city FROM airports GROUP BY city ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T1.City\nFROM airports AS T1\nJOIN flights AS T2 ON T1.AirportCode = T2.SourceAirport\nGROUP BY T1.City\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT a.City\nFROM airports a\nJOIN flights f ON a.AirportCode = f.SourceAirport\nGROUP BY a.City\nORDER BY COUNT(f.SourceAirport) DESC\nLIMIT 1;"
        ]
    },
    "741": {
        "db_id": "world_1",
        "question": "Give the name of the nation that uses the greatest amount of languages.",
        "ground_truth": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do use `T1.Name` in the SELECT list instead of `n.name` and group by `T1.Name` instead of `n.nation_id`. Do join `country AS T1` and `countrylanguage AS T2` instead of `nation` and `language` tables. Do use the join condition `T1.Code = T2.CountryCode` instead of `n.nation_id = l.nation_id`. Do order by `COUNT(*)` instead of `COUNT(l.language_id)` while maintaining the same DESC ordering and LIMIT 1. The amended query now correctly counts languages per country and returns the country with the most languages, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"the nation that uses the greatest amount of languages\": make sure the output order: T1.Name 2) When the question mentions \"nation\": \"nation\" actually means \"country AS T1\" in schema 3) When combining T1 and T2 for shared entities: link rows where T1.Code = T2.CountryCode exactly as shown; keep only matching pairs (inner match) 4) When the question asks for \"count of languages\": compute the number of rows using COUNT(*) per country group 5) When the question mentions \"greatest amount\" or \"most\": rank rows by COUNT(*) in descending order and keep the first 1 row 6) When grouping by country: organize results by T1.Name and compute requested aggregates per group"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT n.name \nFROM nation n \nJOIN language l ON n.nation_id = l.nation_id \nGROUP BY n.nation_id \nORDER BY COUNT(l.language_id) DESC \nLIMIT 1;",
            "SELECT T1.Name\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Name\nFROM country AS T1\nINNER JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Name\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "538": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the degree summary name that has the most number of students enrolled?",
        "ground_truth": "SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.degree_summary_name` instead of `degree_summary_name` and remove the `student_count` alias instead of keeping it. Do join `Degree_Programs AS T1` with `Student_Enrolment AS T2` on `T1.degree_program_id = T2.degree_program_id` instead of querying `students` table directly without any joins. Do order by `count(*) DESC` instead of `student_count ASC` to find the most popular degree instead of the least popular. The amended query now correctly identifies the degree program with the highest enrollment count by joining the relevant tables and using descending order aggregation."
        ],
        "rules": [
            "1) When answering about \"degree summary name with most students enrolled\": make sure the output order: T1.degree_summary_name, count(*) 2) When the question mentions \"most number of students enrolled\": rank rows by count(*) in descending direction and keep the first 1 row. 3) When combining Degree_Programs AS T1 and Student_Enrolment AS T2: link rows where T1.degree_program_id = T2.degree_program_id; keep only matching pairs (inner match). 4) When counting students enrolled: compute the number of rows using the join relationship between Degree_Programs and Student_Enrolment tables. 5) When choosing identifier delimiters: do not replace unquoted identifiers with quoted forms unless specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT degree_summary_name, COUNT(*) as student_count FROM students GROUP BY degree_summary_name ORDER BY student_count ASC LIMIT 1;",
            "SELECT T1.degree_summary_name\nFROM Degree_Programs AS T1\nJOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id\nGROUP BY T1.degree_summary_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.degree_summary_name, COUNT(*) \nFROM Degree_Programs AS T1\nINNER JOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id\nGROUP BY T1.degree_summary_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "97": {
        "db_id": "car_1",
        "question": "Find the model of the car whose weight is below the average weight.",
        "ground_truth": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)",
        "amends": [
            "Do specify `T1.model` with table alias instead of just `model`. Do join `CAR_NAMES AS T1` and `CARS_DATA AS T2` instead of querying only `cars`. Do use `ON T1.MakeId = T2.Id` for the join condition instead of no join. Do filter on `T2.Weight` instead of `weight`. Do reference `CARS_DATA` in the subquery instead of `cars`. The amended query now correctly joins the necessary tables and references the appropriate columns to match the intended behavior."
        ],
        "rules": [
            "1) When answering about car models and weights: join CAR_NAMES as T1 and CARS_DATA as T2 using the condition T1.MakeId = T2.Id. 2) When filtering by weight below average: compare T2.Weight against the average weight from CARS_DATA. 3) When selecting the model: output T1.model from the joined result. 4) When combining tables for shared entities: perform an inner match where T1.MakeId equals T2.Id exactly as specified."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT model FROM cars WHERE weight < (SELECT AVG(weight) FROM cars);",
            "SELECT T1.Model \nFROM CAR_NAMES AS T1\nJOIN CARS_DATA AS T2 ON T1.MakeId = T2.Id\nWHERE T2.Weight < (SELECT AVG(Weight) FROM CARS_DATA)"
        ],
        "rule_sql": [
            "SELECT T1.Model FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id WHERE T2.Weight < (SELECT AVG(Weight) FROM cars_data)"
        ]
    },
    "456": {
        "db_id": "wta_1",
        "question": "What are the full names of all players, sorted by birth date?",
        "ground_truth": "SELECT first_name ,  last_name FROM players ORDER BY birth_date",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM players ORDER BY birth_date DESC;"
        ],
        "rule_sql": [
            "SELECT first_name, last_name FROM players ORDER BY birth_date;"
        ]
    },
    "903": {
        "db_id": "network_1",
        "question": "How many likes correspond to each student id?",
        "ground_truth": "SELECT student_id ,  count(*) FROM Likes GROUP BY student_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id, COUNT(*) FROM likes GROUP BY student_id;"
        ],
        "rule_sql": [
            "SELECT student_id, COUNT(liked_id) AS like_count FROM Likes GROUP BY student_id ORDER BY student_id;"
        ]
    },
    "142": {
        "db_id": "car_1",
        "question": "What model has the most different versions?",
        "ground_truth": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;",
        "amends": [
            "Do select `Model` instead of `model, COUNT(*) as version_count` to return only the model column without aggregation. Do use table `CAR_NAMES` instead of `car_models` as the data source. Do remove the explicit count aggregation and alias from the SELECT list instead of including them. Do maintain the GROUP BY on `Model` instead of `model` but with proper case. Do keep the ORDER BY `count(*) DESC` instead of `version_count DESC` to sort by the implicit count without an alias. Do preserve the LIMIT 1 instead of changing it. The amended query now correctly returns the most frequent model from the CAR_NAMES table by counting occurrences per model and selecting the top result."
        ],
        "rules": [
            "1) When answering about \"model has the most different versions\": make sure the output order: only the \"Model\" column without any count aggregation. 2) When the question mentions \"model\": \"model\" actually means \"Model\" in schema from table \"CAR_NAMES\". 3) When the question asks for \"most different versions\": count the number of occurrences per \"Model\" and keep only the top 1 result. 4) When counting versions: compute the number of rows using the implicit count of \"Model\" occurrences without an alias. 5) When ranking for \"most\": sort rows by the count in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT model, COUNT(*) as version_count FROM car_models GROUP BY model ORDER BY version_count DESC LIMIT 1;",
            "SELECT Model FROM car_names GROUP BY Model ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Model FROM car_names GROUP BY Model ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "187": {
        "db_id": "flight_2",
        "question": "How many airlines do we have?",
        "ground_truth": "SELECT count(*) FROM AIRLINES",
        "amends": [
            "Do reference the `AIRLINES` table instead of the `flights` table in the FROM clause. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the AIRLINES table instead of flights, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"how many airlines\": make sure to count records from the \"AIRLINES\" table instead of the \"flights\" table. 2) When counting entities: use lowercase \"count(*)\" for consistency with the schema requirements."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights;",
            "SELECT count(*) FROM airlines;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM airlines;"
        ]
    },
    "815": {
        "db_id": "world_1",
        "question": "Give the language that is spoken in the most countries.",
        "ground_truth": "SELECT LANGUAGE FROM countrylanguage GROUP BY LANGUAGE ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference the correct table name `countrylanguage` instead of the incorrect `country_languages`. Do maintain the same column reference `LANGUAGE` instead of `language` while preserving the same case sensitivity. Do keep the identical aggregation `COUNT(*)` and ordering `DESC` with the same `LIMIT 1` clause. The amended query now correctly references the actual table name while maintaining the same logical behavior to find the most frequently occurring language."
        ],
        "rules": [
            "1) When the question asks for the language spoken in the most countries: use the exact table name \"countrylanguage\" instead of \"country_languages\". 2) When referencing the language column: use the exact column name \"LANGUAGE\" with the same case sensitivity as shown in the schema. 3) When counting countries per language: use COUNT(*) to count all rows in each language group. 4) When finding the most frequently occurring language: order the results by the count in descending order and take only the top result with LIMIT 1."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT language FROM country_languages GROUP BY language ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT Language FROM countrylanguage GROUP BY Language ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT LANGUAGE FROM countrylanguage GROUP BY LANGUAGE ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "55": {
        "db_id": "pets_1",
        "question": "Find the number of distinct type of pets.",
        "ground_truth": "SELECT count(DISTINCT pettype) FROM pets",
        "amends": [
            "Do `count(DISTINCT pettype)` instead of `COUNT(*)` to count distinct pet types rather than all rows. Do add the `DISTINCT` modifier and specify the `pettype` column instead of using a wildcard count. The amended query now correctly counts unique pet types instead of total records, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting distinct types of pets: count the number of unique values in the \"pettype\" column using DISTINCT modifier instead of counting all rows. 2) When the question asks for \"number of distinct type of pets\": use the exact column token \"pettype\" to identify pet types in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM pets;",
            "SELECT COUNT(DISTINCT PetType) FROM Pets;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT PetType) FROM Pets;"
        ]
    }
}