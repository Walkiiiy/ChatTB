{
    "79": {
        "db_id": "pets_1",
        "question": "Find the number of pets for each student who has any pet and student id.",
        "ground_truth": "SELECT count(*) ,  T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid GROUP BY T1.stuid",
        "amends": [
            "Do select `count(*)` and `T1.stuid` instead of `student_id` and `COUNT(*)`. Do use `FROM student AS T1 JOIN has_pet AS T2` instead of `FROM pets`. Do add join condition `ON T1.stuid = T2.stuid` instead of omitting it. Do group by `T1.stuid` instead of `student_id`. The amended query now correctly counts pets per student by joining the student and has_pet tables instead of querying a non-existent pets table directly, matching the intended behavior.",
            "Do place `count(*)` first in the SELECT list instead of `T1.StuID`. Do use lowercase `stuid` for the column reference instead of `StuID`. Do remove the alias `T1.StuID` from the SELECT list instead of including it, as it's redundant when grouping by the same column. The amended query now correctly returns only the count of pets per student without duplicating the student ID in the output, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"number of pets for each student\": count the number of pets using the join between student table as T1 and has_pet table as T2. 2) When combining student and has_pet tables: link rows where T1.stuid = T2.stuid and keep only matching pairs (inner match). 3) When grouping by student: organize results by T1.stuid instead of student_id. 4) When selecting output columns: use T1.stuid for student identification and count(*) for the number of pets. 5) When the question mentions \"student id\": use the exact column token T1.stuid from the schema.",
            "1) When the question asks for \"number of pets for each student\": count the number of pets using the canonical key from the Has_Pet table and group by the exact student identifier token. 2) When selecting output columns: place the count first in the output order and do not include the grouping column in the select list when it's redundant. 3) When referring to the student identifier column: use the exact lowercase token \"stuid\" as shown in the schema and amends. 4) When combining Student and Has_Pet tables: link rows where Student.stuid equals Has_Pet.stuid using an inner match to find students who have pets."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_id, COUNT(*) FROM pets GROUP BY student_id",
            "SELECT T1.StuID, COUNT(*) \nFROM Student AS T1 \nJOIN Has_Pet AS T2 ON T1.StuID = T2.StuID \nGROUP BY T1.StuID",
            "SELECT count(*), T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid = T2.stuid GROUP BY T1.stuid"
        ],
        "rule_sql": [
            "SELECT T1.stuid, COUNT(*) AS number_of_pets FROM Student AS T1 INNER JOIN Has_Pet AS T2 ON T1.stuid = T2.stuid GROUP BY T1.stuid"
        ]
    },
    "305": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "How many different templates do all document use?",
        "ground_truth": "SELECT count(DISTINCT template_id) FROM Documents",
        "amends": [
            "Do count `DISTINCT template_id` instead of counting all rows with `COUNT(*)`. Do reference the table as `Documents` instead of `documents` (case sensitivity). The amended query now correctly counts distinct template IDs rather than total document count, matching the intended behavior."
        ],
        "rules": [
            "1) When counting different templates used by documents: count distinct values of \"template_id\" from the \"Documents\" table. 2) When referring to the documents table: use the exact identifier \"Documents\" with proper case sensitivity as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM documents;",
            "SELECT COUNT(DISTINCT Template_ID) FROM Documents;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Template_ID) FROM Documents"
        ]
    },
    "1003": {
        "db_id": "singer",
        "question": "What are the names of singers ordered by ascending net worth?",
        "ground_truth": "SELECT Name FROM singer ORDER BY Net_Worth_Millions ASC",
        "amends": [
            "Do reference the `Name` column instead of `name` to match the correct case sensitivity. Do reference the `singer` table instead of `singers` to use the correct table name. Do order by `Net_Worth_Millions` instead of `net_worth` to use the correct column name for ordering. The amended query now correctly selects from the proper table with accurate column references and ordering criteria."
        ],
        "rules": [
            "1) When the question asks for singer names: use the exact column \"Name\" from table \"singer\" (not \"name\" or \"singers\"). 2) When ordering singers by net worth: use the exact column \"Net_Worth_Millions\" for ordering in ascending direction. 3) When selecting from the singer table: use the exact table name \"singer\" (not \"singers\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers ORDER BY net_worth ASC;",
            "SELECT Name FROM singer ORDER BY Net_Worth_Millions ASC;"
        ],
        "rule_sql": [
            "SELECT Name FROM singer ORDER BY Net_Worth_Millions ASC;"
        ]
    },
    "990": {
        "db_id": "dog_kennels",
        "question": "How much does each charge type costs? List both charge type and amount.",
        "ground_truth": "SELECT charge_type ,  charge_amount FROM Charges",
        "amends": [
            "Do select `charge_amount` instead of using `SUM(amount)` aggregate function. Do remove the `GROUP BY charge_type` clause instead of keeping it, as the right query retrieves individual records rather than aggregated totals. The amended query now directly selects the charge_amount column from the Charges table without aggregation, matching the right SQL's behavior of returning individual charge records."
        ],
        "rules": [
            "1) When the question asks for charge type costs and lists both charge type and amount: select individual charge records with exact column names \"charge_type\" and \"charge_amount\" instead of using aggregate functions. 2) When retrieving individual charge records: do not use GROUP BY clauses or aggregation functions like SUM(). 3) When selecting charge amounts: use the exact column name \"charge_amount\" as specified in the schema, not generic names like \"amount\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT charge_type, SUM(amount) FROM charges GROUP BY charge_type;",
            "SELECT charge_type, charge_amount FROM Charges;"
        ],
        "rule_sql": [
            "SELECT charge_type, charge_amount FROM Charges;"
        ]
    },
    "49": {
        "db_id": "pets_1",
        "question": "Find the maximum weight for each type of pet. List the maximum weight and pet type.",
        "ground_truth": "SELECT max(weight) ,  petType FROM pets GROUP BY petType",
        "amends": [
            "Do use `max(weight)` instead of `AVG(weight) as max_weight` to correctly calculate maximum weight rather than average weight. Do use `petType` instead of `pet_type` to match the correct column name. Do remove the alias `max_weight` instead of keeping it since the aggregate function name clearly indicates the calculation. Do maintain the `GROUP BY petType` clause instead of `GROUP BY pet_type` to ensure proper grouping by the correct column name. The amended query now correctly calculates maximum weight per pet type instead of incorrectly calculating average weight.",
            "Do place `max(weight)` first in the SELECT list instead of `PetType` first. Do use lowercase `petType` instead of uppercase `PetType` for the column reference. Do use lowercase `pets` instead of uppercase `Pets` for the table name. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [
            "1) When the question asks for maximum weight per pet type: use max(weight) instead of AVG(weight) to calculate the maximum value. 2) When referring to pet type in the schema: use the exact column name \"petType\" instead of \"pet_type\". 3) When calculating aggregates per group: maintain grouping by \"petType\" to ensure results are organized by each pet type. 4) When the question asks for maximum weight: do not use aliases like \"max_weight\" since the aggregate function name clearly indicates the calculation.",
            "1) When the question asks for maximum weight for each type of pet: organize results by the exact token \"petType\" and compute the maximum of \"weight\" per group. 2) When producing output columns: place the maximum weight calculation first in the output order, followed by the pet type. 3) When referring to table and column identifiers: use lowercase \"pets\" for the table name and lowercase \"petType\" for the column reference exactly as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pet_type, AVG(weight) as max_weight FROM pets GROUP BY pet_type;",
            "SELECT PetType, MAX(weight) FROM Pets GROUP BY PetType;",
            "SELECT max(weight), petType FROM pets GROUP BY petType"
        ],
        "rule_sql": [
            "SELECT MAX(weight), petType FROM pets GROUP BY petType;"
        ]
    },
    "724": {
        "db_id": "world_1",
        "question": "What is the average life expectancy in African countries that are republics?",
        "ground_truth": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  \"Africa\" AND GovernmentForm  =  \"Republic\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(LifeExpectancy) FROM country WHERE Continent = 'Africa' AND GovernmentForm = 'Republic';"
        ],
        "rule_sql": [
            "SELECT AVG(LifeExpectancy) AS AverageLifeExpectancy FROM country WHERE Continent = 'Africa' AND GovernmentForm LIKE '%Republic%'"
        ]
    },
    "545": {
        "db_id": "student_transcripts_tracking",
        "question": "What are all the course names of the courses which ever have students enrolled in?",
        "ground_truth": "SELECT DISTINCT T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id",
        "amends": [
            "Do use `DISTINCT` on `T1.course_name` instead of omitting it. Do join `Courses AS T1` with `Student_Enrolment_Courses AS T2` on `T1.course_id = T2.course_id` instead of querying `courses` alone. Do remove the `WHERE student_id IS NULL` filter instead of keeping it, as the correct logic requires finding courses that have enrollments rather than those with null student IDs. The amended query now correctly identifies distinct courses that have student enrollments by joining the relevant tables."
        ],
        "rules": [
            "1) When answering about \"course names of courses which ever have students enrolled in\": make sure the output order: T1.course_name. 2) When the question asks for distinct course names: compute the number of unique values of T1.course_name. 3) When combining Courses as T1 and Student_Enrolment_Courses as T2: link rows where T1.course_id = T2.course_id exactly as shown; keep only matching pairs (inner match). 4) When the question implies finding courses with enrollments: do not filter for student_id IS NULL, instead include all courses that have matching enrollment records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_name FROM courses WHERE student_id IS NULL;",
            "SELECT DISTINCT T1.course_name\nFROM Courses AS T1\nJOIN Student_Enrolment_Courses AS T2 ON T1.course_id = T2.course_id"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.course_name\nFROM Courses AS T1\nINNER JOIN Student_Enrolment_Courses AS T2 ON T1.course_id = T2.course_id\nORDER BY T1.course_name;"
        ]
    },
    "306": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Count the number of different templates used for documents.",
        "ground_truth": "SELECT count(DISTINCT template_id) FROM Documents",
        "amends": [
            "Do use `count(DISTINCT template_id)` instead of `COUNT(*)` to count distinct template IDs rather than all rows. Do reference the table as `Documents` instead of `documents` to match the correct case. The amended query now correctly counts distinct template IDs from the Documents table instead of counting all rows, matching the intended behavior."
        ],
        "rules": [
            "1) When counting the number of different templates used for documents: count distinct values of template_id from the Documents table instead of counting all rows. 2) When referencing the Documents table: use the exact identifier \"Documents\" with proper case instead of \"documents\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM documents;",
            "SELECT COUNT(DISTINCT Template_ID) FROM Documents;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Template_ID) FROM Documents WHERE Template_ID IS NOT NULL"
        ]
    },
    "409": {
        "db_id": "course_teach",
        "question": "List the names of teachers who have not been arranged to teach courses.",
        "ground_truth": "SELECT Name FROM teacher WHERE Teacher_id NOT IN (SELECT Teacher_id FROM course_arrange)",
        "amends": [
            "Do reference the `teacher` table instead of `teachers` and use column `Teacher_id` instead of `teacher_id` in the main query. Do reference the `course_arrange` table instead of `courses` in the subquery and use column `Teacher_id` instead of `teacher_id` in the subquery's SELECT clause. Do use column `Name` instead of `name` in the SELECT list to match the correct schema. The amended query now correctly identifies teachers not assigned to any courses by using the proper table and column names from the schema."
        ],
        "rules": [
            "1) When the question asks about teachers who have not been arranged to teach courses: use table \"teacher\" as T1 and table \"course_arrange\" as T2. 2) When selecting teacher names: use column \"Name\" from table \"teacher\" as the output column. 3) When checking for unassigned teachers: ensure the condition uses \"Teacher_id\" from \"teacher\" table not existing in \"Teacher_id\" values from \"course_arrange\" table. 4) When combining teacher and course arrangement information: use the exact column token \"Teacher_id\" for both tables to establish the relationship between teachers and their course assignments."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM teachers WHERE teacher_id NOT IN (SELECT teacher_id FROM courses)",
            "SELECT Name FROM teacher WHERE Teacher_ID NOT IN (SELECT Teacher_ID FROM course_arrange)"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM teacher AS T1 WHERE T1.Teacher_id NOT IN (SELECT T2.Teacher_id FROM course_arrange AS T2)"
        ]
    },
    "767": {
        "db_id": "world_1",
        "question": "How many people live in countries that do not speak English?",
        "ground_truth": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\")",
        "amends": [
            "Do use `sum(Population)` instead of `COUNT(*)` to aggregate population data rather than counting rows. Do query from `country` table instead of joining `people`, `countries`, and `languages` tables. Do use a `WHERE Name NOT IN` subquery filter instead of a direct join condition with `l.name != 'English'`. Do implement a correlated subquery with `country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode` instead of the three-table join structure. Do filter for `T2.Language = \"English\"` in the subquery instead of excluding English language directly. Do remove the explicit table aliases `p`, `c`, and `l` since they are no longer needed in the simplified structure. The amended query now correctly calculates total population of countries where English is not spoken, matching the intended behavior."
        ],
        "rules": [
            "1) When calculating population counts: use sum(\"Population\") instead of counting rows to aggregate population data. 2) When answering about countries that do not speak English: use a correlated subquery with WHERE \"Name\" NOT IN instead of direct join conditions with != 'English'. 3) When combining country and countrylanguage tables: link rows where T1.\"Code\" = T2.\"CountryCode\" exactly as shown and keep only matching pairs (inner match). 4) When filtering for English language: use the exact literal \"English\" with correct case and quotes in the condition T2.\"Language\" = \"English\". 5) When the question asks for population of countries: use the \"Population\" column from the country table as the aggregation source."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM people p \nJOIN countries c ON p.country_id = c.id \nJOIN languages l ON c.language_id = l.id \nWHERE l.name != 'English';",
            "SELECT SUM(Population) \nFROM country \nWHERE Name NOT IN (\n    SELECT T1.Name \n    FROM country AS T1 \n    JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \n    WHERE T2.Language = 'English'\n)"
        ],
        "rule_sql": [
            "SELECT SUM(\"Population\") \nFROM country \nWHERE \"Name\" NOT IN (\n    SELECT c.\"Name\" \n    FROM country c \n    JOIN countrylanguage cl ON c.\"Code\" = cl.\"CountryCode\" \n    WHERE cl.\"Language\" = \"English\"\n)"
        ]
    },
    "682": {
        "db_id": "poker_player",
        "question": "What are the names of people who are not from Russia?",
        "ground_truth": "SELECT Name FROM people WHERE Nationality != \"Russia\"",
        "amends": [
            "Do select `Name` instead of `name` to match the correct column casing. Do use `!=` operator with `Nationality` column instead of `=` operator with `country` column to filter for non-Russian nationalities rather than Russian countries. Do use double quotes around `Russia` instead of single quotes for consistent string literal formatting. The amended query now correctly filters for people whose nationality is not Russia, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"names of people\": select the exact column token \"Name\" from the people table. 2) When filtering for people who are \"not from Russia\": use the exact column token \"Nationality\" with the != operator and the exact string literal \"Russia\" (with double quotes). 3) When the question mentions \"people\": use the table \"people\" as the base table T1."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM people WHERE country = 'Russia';",
            "SELECT Name FROM people WHERE Nationality != \"Russia\""
        ],
        "rule_sql": [
            "SELECT Name FROM people WHERE Nationality != \"Russia\""
        ]
    },
    "612": {
        "db_id": "tvshow",
        "question": "What is the title of all the cartools that are on the TV Channel with the series name \"Sky Radio\"?",
        "ground_truth": "SELECT T2.Title FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T1.series_name = \"Sky Radio\";",
        "amends": [
            "Do select `T2.Title` instead of `title` and specify the table alias. Do use `FROM TV_Channel AS T1 JOIN Cartoon AS T2` instead of `FROM cartools` to reference the correct tables with proper aliases. Do add the join condition `ON T1.id = T2.Channel` instead of omitting any join relationship. Do apply the filter `T1.series_name = \"Sky Radio\"` on the TV_Channel table instead of applying it directly to a non-existent table. The amended query now correctly joins the TV_Channel and Cartoon tables to retrieve titles from the appropriate source based on the channel relationship."
        ],
        "rules": [
            "1) When answering about \"cartools that are on the TV Channel with the series name 'Sky Radio'\": make sure the output order: T2.Title. 2) When the question mentions \"cartools\": \"cartools\" actually means \"Cartoon in schema\" and should be referenced as T2. 3) When the question mentions \"TV Channel\": \"TV Channel\" actually means \"TV_Channel in schema\" and should be referenced as T1. 4) When combining T1 and T2 for shared entities: link rows where T1.id = T2.Channel exactly as shown in the amends; keep only matching pairs (inner match). 5) When filtering for series name \"Sky Radio\": apply the condition T1.series_name = \"Sky Radio\" exactly as specified with double quotes and proper case."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM cartools WHERE series_name = 'Sky Radio';",
            "SELECT T2.Title FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio'"
        ],
        "rule_sql": [
            "SELECT T2.Title FROM TV_Channel T1 INNER JOIN Cartoon T2 ON T1.id = T2.Channel WHERE T1.series_name = \"Sky Radio\" ORDER BY T2.Title;"
        ]
    },
    "922": {
        "db_id": "dog_kennels",
        "question": "Which professionals live in the state of Indiana or have done treatment on more than 2 treatments? List his or her id, last name and cell phone.",
        "ground_truth": "SELECT professional_id ,  last_name ,  cell_number FROM Professionals WHERE state  =  'Indiana' UNION SELECT T1.professional_id ,  T1.last_name ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >  2",
        "amends": [
            "Do use `professional_id` instead of `id` in the SELECT list and change `cell_phone` to `cell_number` instead of keeping the original column name. Do add a UNION operation instead of using a single query with OR logic. Do change the first part to select from `Professionals` instead of `professionals` with proper table name casing. Do add a second query that performs a `JOIN` with `Treatments` table on `professional_id` instead of omitting this table entirely. Do move the count condition to `HAVING count(*) > 2` instead of using `treatment_count > 2` in the WHERE clause. Do use proper table aliasing with `AS T1` and `AS T2` instead of no aliases. Do include `GROUP BY T1.professional_id` instead of omitting grouping. The amended query now correctly handles the union of Indiana professionals and those with more than two treatments through proper table joining and aggregation."
        ],
        "rules": [
            "1) When selecting professional identifiers: use \"professional_id\" instead of \"id\" in the output columns. 2) When selecting phone numbers: use \"cell_number\" instead of \"cell_phone\" as the column name. 3) When querying the professionals table: use exact table name \"Professionals\" with proper casing instead of lowercase \"professionals\". 4) When finding professionals who have done more than 2 treatments: join \"Professionals\" (as T1) with \"Treatments\" (as T2) on T1.professional_id = T2.professional_id instead of using a single table. 5) When counting treatments per professional: group by T1.professional_id and use HAVING count(*) > 2 instead of checking treatment_count > 2 in WHERE clause. 6) When combining results for Indiana professionals and those with many treatments: use UNION operation instead of OR logic in a single query. 7) When outputting results: maintain the column order as professional_id, last_name, cell_number."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, last_name, cell_phone FROM professionals WHERE state = 'Indiana' OR treatment_count > 2;",
            "SELECT professional_id, last_name, cell_number FROM Professionals WHERE state = 'Indiana'\nUNION\nSELECT T1.professional_id, T1.last_name, T1.cell_number \nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT professional_id, last_name, cell_number\nFROM Professionals\nWHERE state = 'Indiana'\nUNION\nSELECT T1.professional_id, T1.last_name, T1.cell_number\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) > 2\nORDER BY professional_id;"
        ]
    },
    "38": {
        "db_id": "concert_singer",
        "question": "What are the names of the singers who performed in a concert in 2014?",
        "ground_truth": "SELECT T2.name FROM singer_in_concert AS T1 JOIN singer AS T2 ON T1.singer_id  =  T2.singer_id JOIN concert AS T3 ON T1.concert_id  =  T3.concert_id WHERE T3.year  =  2014",
        "amends": [
            "Do select `T2.name` from the `singer` table instead of `name` from the `singers` table. Do add joins to `singer_in_concert AS T1` and `concert AS T3` instead of querying only the `singers` table. Do use `LEFT JOIN` on `T1.singer_id = T2.singer_id` and `LEFT JOIN` on `T1.concert_id = T3.concert_id` instead of no joins. Do filter on `T3.year = 2014` instead of `concert_year = 2014` since the year column exists in the concert table rather than the singers table. The amended query now correctly joins through the association table to find singers who performed in concerts during 2014."
        ],
        "rules": [
            "1) When answering about singers who performed in concerts: use T2.name from the singer table instead of name from singers table. 2) When combining singer and concert information: join through singer_in_concert as T1 using LEFT JOIN on T1.singer_id = T2.singer_id and LEFT JOIN on T1.concert_id = T3.concert_id. 3) When filtering for concerts in 2014: use T3.year = 2014 instead of concert_year since year exists in the concert table rather than singers table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers WHERE concert_year = 2014;",
            "SELECT T2.Name \nFROM singer AS T2\nLEFT JOIN singer_in_concert AS T1 ON T1.Singer_ID = T2.Singer_ID\nLEFT JOIN concert AS T3 ON T1.concert_ID = T3.concert_ID\nWHERE T3.Year = '2014'"
        ],
        "rule_sql": [
            "SELECT T2.Name \nFROM singer T2\nLEFT JOIN singer_in_concert T1 ON T1.Singer_ID = T2.Singer_ID\nLEFT JOIN concert T3 ON T1.concert_ID = T3.concert_ID\nWHERE T3.Year = '2014'\nGROUP BY T2.Singer_ID"
        ]
    },
    "819": {
        "db_id": "world_1",
        "question": "Count the number of countries for which Spanish is the predominantly spoken language.",
        "ground_truth": "SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  \"Spanish\" GROUP BY CountryCode",
        "amends": [
            "Do select both `count(*)` and `max(Percentage)` instead of only `COUNT(*)`. Do query from `countrylanguage` table instead of `countries` table. Do use `LANGUAGE = \"Spanish\"` filter instead of `language = 'Spanish'`. Do add `GROUP BY CountryCode` clause instead of omitting grouping. Do use double quotes around \"Spanish\" instead of single quotes for the string literal."
        ],
        "rules": [
            "1) When querying about language data: use the \"countrylanguage\" table instead of the \"countries\" table. 2) When filtering for Spanish language: use the exact literal \"Spanish\" with double quotes instead of single quotes. 3) When counting countries by language: group results by \"CountryCode\" to get counts per country. 4) When determining predominant language: include both count and maximum percentage in the selection to identify the primary language per country."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE language = 'Spanish';",
            "SELECT COUNT(*), MAX(Percentage) FROM countrylanguage WHERE Language = \"Spanish\" GROUP BY CountryCode"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS country_count\nFROM (\n    SELECT CountryCode\n    FROM countrylanguage\n    GROUP BY CountryCode\n    HAVING MAX(Percentage) = (\n        SELECT MAX(Percentage)\n        FROM countrylanguage cl2\n        WHERE cl2.CountryCode = countrylanguage.CountryCode\n    )\n    AND (\n        SELECT Language\n        FROM countrylanguage cl3\n        WHERE cl3.CountryCode = countrylanguage.CountryCode\n        AND cl3.Percentage = (\n            SELECT MAX(Percentage)\n            FROM countrylanguage cl4\n            WHERE cl4.CountryCode = countrylanguage.CountryCode\n        )\n    ) = \"Spanish\"\n)"
        ]
    },
    "202": {
        "db_id": "flight_2",
        "question": "What are the names of airports in Aberdeen?",
        "ground_truth": "SELECT AirportName FROM AIRPORTS WHERE City = \"Aberdeen\"",
        "amends": [
            "Do reference the column as `AirportName` instead of `name` and use double quotes around the string literal `\"Aberdeen\"` instead of single quotes, while also changing the table reference to uppercase `AIRPORTS` and the column reference to `City` instead of `city`. The amended query now correctly matches the RIGHT_SQL's behavior with proper column naming and string literal formatting."
        ],
        "rules": [
            "1) When the question asks for airport names: use the exact column token \"AirportName\" from the airports table. 2) When filtering by city name \"Aberdeen\": use the exact string literal \"Aberdeen\" with double quotes as shown in the schema. 3) When referencing the airports table: use the uppercase identifier \"AIRPORTS\" as specified in the amends. 4) When filtering by city: use the exact column token \"City\" from the airports table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM airports WHERE city = 'Aberdeen';",
            "SELECT AirportName FROM AIRPORTS WHERE City = \"Aberdeen\";"
        ],
        "rule_sql": [
            "SELECT AirportName FROM AIRPORTS WHERE City = \"Aberdeen\""
        ]
    },
    "941": {
        "db_id": "dog_kennels",
        "question": "Find the owner id and zip code of the owner who spent the most money in total for his or her dogs.",
        "ground_truth": "SELECT T1.owner_id ,  T1.zip_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY sum(T3.cost_of_treatment) DESC LIMIT 1",
        "amends": [
            "Do select only `owner_id` and `zip_code` instead of including `SUM(amount)` and aliasing it as `total_spent`. Do join `Treatments` table as `T3` instead of `purchases` table. Do use `T2.dog_id = T3.dog_id` join condition instead of `d.dog_id = p.dog_id`. Do group by only `owner_id` instead of both `owner_id` and `zip_code`. Do order by `sum(T3.cost_of_treatment)` in descending order instead of `total_spent` in ascending order. The amended query now correctly calculates the highest treatment cost per owner rather than purchase amounts, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"owner who spent the most money in total for his or her dogs\": make sure the output order: owner_id, zip_code. 2) When the question mentions \"spent the most money\": this actually means sum of \"cost_of_treatment\" in the Treatments table. 3) When combining Owners (T1), Dogs (T2), and Treatments (T3) tables: link rows where T1.owner_id = T2.owner_id and T2.dog_id = T3.dog_id using exact key equality; keep only matching pairs (inner match). 4) When grouping by owner: organize results by owner_id only, not by both owner_id and zip_code. 5) When ranking for \"the most money\": rank rows by sum(T3.cost_of_treatment) in descending order and keep only the first 1 row. 6) When producing output: select only owner_id and zip_code columns, do not include the sum amount in the final output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT owner_id, zip_code, SUM(amount) as total_spent\nFROM owners o\nJOIN dogs d ON o.owner_id = d.owner_id\nJOIN purchases p ON d.dog_id = p.dog_id\nGROUP BY owner_id, zip_code\nORDER BY total_spent ASC\nLIMIT 1;",
            "SELECT o.owner_id, o.zip_code\nFROM Owners o\nJOIN Dogs d ON o.owner_id = d.owner_id\nJOIN Treatments T3 ON d.dog_id = T3.dog_id\nGROUP BY o.owner_id\nORDER BY SUM(T3.cost_of_treatment) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT o.owner_id, o.zip_code\nFROM Owners o\nJOIN Dogs d ON o.owner_id = d.owner_id\nJOIN Treatments t ON d.dog_id = t.dog_id\nGROUP BY o.owner_id\nORDER BY SUM(t.cost_of_treatment) DESC\nLIMIT 1;"
        ]
    },
    "901": {
        "db_id": "network_1",
        "question": "What are the names of high schoolers who both have friends and are liked?",
        "ground_truth": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id INTERSECT SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.liked_id  =  T2.id",
        "amends": [
            "Do use explicit `JOIN` syntax with table aliases instead of subqueries with `IN` clauses. Do reference `Friend.student_id` and `Likes.liked_id` instead of generic `id1` and `id2` columns. Do use `INTERSECT` to find the intersection of friends and liked students instead of multiple `IN` conditions. Do specify table aliases `T1` and `T2` for clarity instead of direct table references. Do join `Highschooler` on the appropriate foreign key columns (`student_id` and `liked_id`) instead of assuming generic `id` matches. The amended query now correctly identifies high schoolers who are both friends with someone and liked by someone using proper join semantics and set intersection."
        ],
        "rules": [
            "1) When combining tables for shared entities: link Highschooler rows with Friend rows where T1.ID = T2.student_id and keep only matching pairs (inner match). 2) When combining tables for shared entities: link Highschooler rows with Likes rows where T1.ID = T3.liked_id and keep only matching pairs (inner match). 3) When finding students who satisfy multiple conditions: use set intersection to find students who appear in both Friend and Likes relationships. 4) When answering about \"names of high schoolers who both have friends and are liked\": make sure the output order: name from Highschooler table. 5) When the question mentions \"have friends\": this means students who appear in the Friend.student_id column. 6) When the question mentions \"are liked\": this means students who appear in the Likes.liked_id column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM highschooler WHERE id IN (SELECT id1 FROM friend) AND id IN (SELECT id2 FROM likes)",
            "SELECT T1.name\nFROM Highschooler T1\nJOIN Friend F ON T1.ID = F.student_id\nINTERSECT\nSELECT T2.name\nFROM Highschooler T2\nJOIN Likes L ON T2.ID = L.liked_id"
        ],
        "rule_sql": [
            "SELECT DISTINCT h.name\nFROM Highschooler h\nWHERE h.ID IN (\n    SELECT student_id FROM Friend\n) \nAND h.ID IN (\n    SELECT liked_id FROM Likes\n)\nORDER BY h.name;"
        ]
    },
    "462": {
        "db_id": "wta_1",
        "question": "Which year had the most matches?",
        "ground_truth": "SELECT YEAR FROM matches GROUP BY YEAR ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `YEAR` instead of selecting both `year` and `COUNT(*) as match_count`. Do order by `count(*) DESC` instead of `match_count ASC` to find the year with the most matches rather than the fewest. Do remove the alias `match_count` from the ORDER BY clause since it's no longer selected. The amended query now correctly identifies the year with the highest number of matches by using descending order on the count aggregation."
        ],
        "rules": [
            "1) When answering about \"which year had the most matches\": make sure the output order: YEAR. 2) When counting matches: compute the number of rows using the canonical key for matches (year). 3) When the question asks for \"most matches\": rank years by count of matches in descending order and keep the first 1 row. 4) When handling text literals: do not change case, spacing, or punctuation for column names like \"year\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, COUNT(*) as match_count FROM matches GROUP BY year ORDER BY match_count ASC LIMIT 1;",
            "SELECT year FROM matches GROUP BY year ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT year FROM matches GROUP BY year ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "261": {
        "db_id": "employee_hire_evaluation",
        "question": "Sort employee names by their age in ascending order.",
        "ground_truth": "SELECT name FROM employee ORDER BY age",
        "amends": [
            "Do reference table `employee` instead of `employees` in the FROM clause. Do use ascending ORDER BY `age` instead of descending ORDER BY `age DESC`. The amended query now correctly references the single employee table and sorts by age in ascending order instead of descending order."
        ],
        "rules": [
            "1) When the question asks to sort employee names by age in ascending order: use ORDER BY age ASC instead of DESC. 2) When referencing the employee table: use the exact table name \"employee\" instead of \"employees\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM employees ORDER BY age DESC;",
            "SELECT Name FROM employee ORDER BY Age ASC;"
        ],
        "rule_sql": [
            "SELECT Name FROM employee ORDER BY Age ASC;"
        ]
    },
    "352": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the type code of the template type with the description \"Book\".",
        "ground_truth": "SELECT template_type_code FROM Ref_template_types WHERE template_type_description  =  \"Book\"",
        "amends": [
            "Do reference `template_type_code` instead of `type_code` and select from `Ref_template_types` instead of `template_types`. Do filter on `template_type_description = \"Book\"` instead of `description = 'Book'`, using double quotes instead of single quotes for the string literal. The amended query now correctly references the proper table and column names to match the intended schema structure."
        ],
        "rules": [
            "1) When answering about \"Return the type code of the template type with the description 'Book'\": make sure the output order: template_type_code. 2) When the question mentions \"type code\": \"type code\" actually means \"template_type_code in schema\". 3) When the question mentions \"template type\": \"template type\" actually means \"Ref_template_types in schema\". 4) When the question mentions \"description\": \"description\" actually means \"template_type_description in schema\". 5) When filtering for the literal \"Book\": use exact string literal \"Book\" with double quotes as shown in the schema. 6) When selecting from the template types table: use table name Ref_template_types instead of template_types."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type_code FROM template_types WHERE description = 'Book';",
            "SELECT Template_Type_Code FROM Ref_Template_Types WHERE Template_Type_Description = \"Book\";"
        ],
        "rule_sql": [
            "SELECT template_type_code FROM Ref_Template_Types WHERE template_type_description = \"Book\";"
        ]
    },
    "662": {
        "db_id": "poker_player",
        "question": "Give the names of poker players who have earnings above 300000.",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID WHERE T2.Earnings  >  300000",
        "amends": [
            "Do reference the `Name` column from the `people` table instead of `name` from `poker_players`. Do join `people AS T1` with `poker_player AS T2` using `T1.People_ID = T2.People_ID` instead of querying a single `poker_players` table. Do filter on `T2.Earnings > 300000` instead of `earnings > 300000` to correctly reference the joined table's column. The amended query now properly relates player information from the people table with earnings data from the poker_player table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about poker players' names: make sure the output order: T1.\"Name\" 2) When the question mentions \"poker players\": \"poker players\" actually means \"people in schema\" 3) When combining T1 and T2 for shared entities: link rows where T1.People_ID = T2.People_ID exactly as shown in the amends; keep only matching pairs (inner match) 4) When filtering on earnings above 300000: use T2.Earnings > 300000 to correctly reference the joined table's column"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM poker_players WHERE earnings > 300000",
            "SELECT T1.Name \nFROM people AS T1 \nJOIN poker_player AS T2 ON T1.People_ID = T2.People_ID \nWHERE T2.Earnings > 300000"
        ],
        "rule_sql": [
            "SELECT T1.Name \nFROM people T1 \nINNER JOIN poker_player T2 ON T1.People_ID = T2.People_ID \nWHERE T2.Earnings > 300000 \nORDER BY T1.Name"
        ]
    },
    "891": {
        "db_id": "network_1",
        "question": "Return the names of friends of the high school student Kyle.",
        "ground_truth": "SELECT T3.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id JOIN Highschooler AS T3 ON T1.friend_id  =  T3.id WHERE T2.name  =  \"Kyle\"",
        "amends": [
            "Do use explicit table aliases `T3.name` instead of ambiguous `name`. Do add `FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id JOIN Highschooler AS T3 ON T1.friend_id = T3.id` instead of simple `FROM friends`. Do filter on `T2.name = 'Kyle'` instead of `student_name = 'Kyle'` to properly reference the student's name from the Highschooler table. The amended query now correctly joins through the relationship tables to find friends of the specified student."
        ],
        "rules": [
            "1) When answering about \"friends of the high school student Kyle\": make sure the output order: T3.name. 2) When the question mentions \"Kyle\": \"Kyle\" actually means T2.name = 'Kyle' in schema. 3) When combining tables for shared entities: link rows where T1.student_id = T2.id and T1.friend_id = T3.id; keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace explicit table aliases T3.name with ambiguous name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM friends WHERE student_name = 'Kyle';",
            "SELECT T3.name \nFROM Friend AS T1 \nJOIN Highschooler AS T2 ON T1.student_id = T2.ID \nJOIN Highschooler AS T3 ON T1.friend_id = T3.ID \nWHERE T2.name = 'Kyle'"
        ],
        "rule_sql": [
            "SELECT T3.name\nFROM Friend T1\nJOIN Highschooler T2 ON T1.student_id = T2.ID\nJOIN Highschooler T3 ON T1.friend_id = T3.ID\nWHERE T2.name = 'Kyle';"
        ]
    },
    "81": {
        "db_id": "pets_1",
        "question": "Find the first name and gender of student who have more than one pet.",
        "ground_truth": "SELECT T1.fname ,  T1.sex FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid GROUP BY T1.stuid HAVING count(*)  >  1",
        "amends": [
            "Do select `fname` and `sex` instead of `first_name` and `gender`. Do use table alias `T1` for the `student` table instead of directly referencing `students`. Do add a `JOIN` with `has_pet AS T2` on `T1.stuid = T2.stuid` instead of omitting this table relationship. Do add `GROUP BY T1.stuid` instead of grouping by the entire table. Do move the count filter to `HAVING count(*) > 1` instead of using `WHERE pet_count > 1`. The amended query now correctly counts pets per student and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"first name\" and \"gender\": use the exact column tokens \"fname\" and \"sex\" from table T1 instead of \"first_name\" and \"gender\". 2) When counting pets per student: join table \"has_pet\" as T2 with T1 using the exact key equality T1.stuid = T2.stuid and keep only matching pairs (inner match). 3) When grouping by student: organize results by T1.stuid instead of grouping by the entire table. 4) When filtering for students with more than one pet: count the number of pets using count(*) and apply the condition count(*) > 1 in the HAVING clause instead of using a WHERE condition on a pet_count column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, gender FROM students WHERE pet_count > 1;",
            "SELECT T1.Fname, T1.Sex FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID GROUP BY T1.StuID HAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T1.fname, T1.sex FROM Student AS T1 INNER JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID GROUP BY T1.StuID HAVING COUNT(*) > 1"
        ]
    },
    "789": {
        "db_id": "world_1",
        "question": "Give the name, year of independence, and surface area of the country that has the lowest population.",
        "ground_truth": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1",
        "amends": [
            "Do use column names `Name`, `SurfaceArea`, and `IndepYear` instead of `name`, `surfacearea`, and `indepyear` to match the correct case sensitivity. Do order by `Population` in ascending order instead of `population DESC` to get the smallest population instead of the largest. The amended query now correctly retrieves the country with the smallest population while maintaining the same column selection and limit behavior.",
            "Do reorder the SELECT list to `Name, SurfaceArea, IndepYear` instead of `Name, IndepYear, SurfaceArea`. Do remove the explicit `ASC` direction from `ORDER BY Population` instead of keeping it, as ASC is the default ordering. The amended query now correctly matches the RIGHT_SQL's behavior with the proper column sequence and simplified ordering syntax."
        ],
        "rules": [
            "1) When choosing column names: use exact case-sensitive identifiers \"Name\", \"IndepYear\", and \"SurfaceArea\" instead of lowercase versions. 2) When ordering by population to find the lowest value: sort by \"Population\" in ascending order instead of descending order. 3) When retrieving the country with the smallest population: maintain the limit of 1 row to get only the single result with the minimum population value.",
            "1) When answering about \"name, year of independence, and surface area\": make sure the output order: Name, SurfaceArea, IndepYear. 2) When the question asks for the country with the lowest population: rank rows by Population in ascending order and keep the first 1 row. 3) When ordering by Population: do not specify ASC direction explicitly as it is the default ordering."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, indepyear, surfacearea FROM country ORDER BY population DESC LIMIT 1;",
            "SELECT Name, IndepYear, SurfaceArea FROM country ORDER BY Population ASC LIMIT 1;",
            "SELECT Name, SurfaceArea, IndepYear FROM country ORDER BY Population LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name, SurfaceArea, IndepYear FROM country ORDER BY Population LIMIT 1;"
        ]
    },
    "663": {
        "db_id": "poker_player",
        "question": "List the names of poker players ordered by the final tables made in ascending order.",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Final_Table_Made",
        "amends": [
            "Do join `people AS T1` with `poker_player AS T2` on `T1.People_ID = T2.People_ID` instead of querying only `poker_players` without any join. Do select `T1.Name` instead of just `name` to specify the table source. Do order by `T2.Final_Table_Made` instead of `final_tables` to use the correct column name from the joined table. The amended query now correctly retrieves player names from the people table joined with poker player data and orders by the appropriate final tables column."
        ],
        "rules": [
            "1) When answering about poker players' names ordered by final tables: make sure the output order is T1.Name. 2) When combining people and poker_player tables: link rows where T1.People_ID = T2.People_ID and keep only matching pairs (inner match). 3) When ordering by final tables made: use T2.Final_Table_Made column in ascending order instead of descending. 4) When selecting player names: use T1.Name from the people table instead of just name to specify the table source."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM poker_players ORDER BY final_tables DESC;",
            "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Final_Table_Made ASC"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM people T1 INNER JOIN poker_player T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Final_Table_Made ASC"
        ]
    },
    "373": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the document id and name with greatest number of paragraphs?",
        "ground_truth": "SELECT T1.document_id ,  T2.document_name FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.document_id` and `T2.document_name` instead of `document_id` and `name`. Do use `FROM Paragraphs AS T1 JOIN Documents AS T2` instead of `FROM documents`. Do add `ON T1.document_id = T2.document_id` join condition instead of omitting it. Do add `GROUP BY T1.document_id` instead of omitting grouping. Do order by `count(*) DESC` instead of `paragraph_count DESC`. The amended query now correctly joins tables and counts paragraphs per document to find the document with the most paragraphs."
        ],
        "rules": [
            "1) When selecting document identifiers and names: use T1.document_id and T2.document_name instead of document_id and name. 2) When combining Paragraphs and Documents tables: use FROM Paragraphs AS T1 JOIN Documents AS T2 with join condition ON T1.document_id = T2.document_id to link matching rows. 3) When counting paragraphs per document: add GROUP BY T1.document_id to organize results by document. 4) When ordering by paragraph count: use count(*) DESC instead of paragraph_count DESC to rank documents by actual paragraph count. 5) When finding the document with greatest number of paragraphs: take only the top ranked document after ordering by paragraph count in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id, name FROM documents ORDER BY paragraph_count DESC LIMIT 1;",
            "SELECT T1.document_id, T2.document_name\nFROM Paragraphs AS T1\nJOIN Documents AS T2 ON T1.document_id = T2.document_id\nGROUP BY T1.document_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.document_id, T2.document_name\nFROM Paragraphs AS T1\nJOIN Documents AS T2 ON T1.document_id = T2.document_id\nGROUP BY T1.document_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "733": {
        "db_id": "world_1",
        "question": "What is the number of distinct languages used around the world?",
        "ground_truth": "SELECT count(DISTINCT LANGUAGE) FROM countrylanguage",
        "amends": [
            "Do select `count(DISTINCT LANGUAGE)` instead of `COUNT(*)`. Do query from `countrylanguage` table instead of `languages` table. The amended query now correctly counts distinct languages from the appropriate table, matching the intended behavior."
        ],
        "rules": [
            "1) When counting distinct languages: use the exact column token \"LANGUAGE\" from the countrylanguage table. 2) When the question asks for \"distinct languages\": compute the number of unique values in the \"LANGUAGE\" column. 3) When querying language data: use the \"countrylanguage\" table instead of any other table name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM languages;",
            "SELECT COUNT(DISTINCT Language) FROM countrylanguage;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Language) FROM countrylanguage;"
        ]
    },
    "39": {
        "db_id": "concert_singer",
        "question": "what is the name and nation of the singer who have a song having 'Hey' in its name?",
        "ground_truth": "SELECT name ,  country FROM singer WHERE song_name LIKE '%Hey%'",
        "amends": [
            "Do use column alias `country` instead of `nation` in the SELECT list while keeping the same `name` column and maintaining the identical WHERE filter `song_name LIKE '%Hey%'` without any changes to table sources, join conditions, grouping, ordering, or other clauses. The amended query now correctly retrieves the country information using the proper column name while preserving all other query logic and behavior."
        ],
        "rules": [
            "1) When the question mentions \"nation\": use the exact column token \"country\" instead of \"nation\" in the output. 2) When filtering for songs containing 'Hey' in their name: apply the exact filter condition song_name LIKE '%Hey%' without changing the pattern. 3) When selecting output columns: maintain the order name followed by country as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, nation FROM singer WHERE song_name LIKE '%Hey%'",
            "SELECT name, country FROM singer WHERE song_name LIKE '%Hey%'"
        ],
        "rule_sql": [
            "SELECT Name, Country FROM singer WHERE Song_Name LIKE '%Hey%';"
        ]
    },
    "641": {
        "db_id": "tvshow",
        "question": "find id of the tv channels that from the countries where have more than two tv channels.",
        "ground_truth": "SELECT id FROM tv_channel GROUP BY country HAVING count(*)  >  2",
        "amends": [
            "Do use `GROUP BY country` with `HAVING count(*) > 2` instead of the subquery approach with `WHERE country IN (SELECT country FROM tv_channels GROUP BY country HAVING COUNT(*) > 2)`. Do remove the redundant subquery structure and instead apply the grouping and filtering directly in the main query. Do change the table reference from `tv_channels` to `tv_channel` to match the correct schema. The amended query now correctly identifies channels from countries with more than two channels by using direct grouping and filtering instead of the inefficient subquery approach."
        ],
        "rules": [
            "1) When the question asks for TV channels from countries with more than two channels: use the table name \"tv_channel\" instead of \"tv_channels\" to match the schema. 2) When filtering for countries with more than two channels: group by the \"country\" column and apply a condition to count all rows greater than 2. 3) When using grouping and filtering: apply the grouping and filtering directly in the main query instead of using a subquery structure for efficiency."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM tv_channels WHERE country IN (SELECT country FROM tv_channels GROUP BY country HAVING COUNT(*) > 2);",
            "SELECT id FROM TV_Channel GROUP BY Country HAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT id FROM TV_Channel GROUP BY Country HAVING COUNT(*) > 2"
        ]
    },
    "393": {
        "db_id": "course_teach",
        "question": "Show different hometown of teachers and the number of teachers from each hometown.",
        "ground_truth": "SELECT Hometown ,  COUNT(*) FROM teacher GROUP BY Hometown",
        "amends": [
            "Do reference the `teacher` table instead of `teachers` in the FROM clause. Do group by `Hometown` instead of `teacher_id` to correctly count teachers by their hometown rather than counting each teacher individually. Do capitalize `Hometown` in the SELECT list instead of lowercase `hometown` for consistency. The amended query now correctly counts teachers grouped by their hometown locations rather than producing incorrect per-teacher counts."
        ],
        "rules": [
            "1) When the question asks about teachers' hometowns: use the table \"teacher\" (not \"teachers\") as the base table T1. 2) When counting teachers per hometown: group by the exact column \"Hometown\" (capitalized) from table T1. 3) When showing the number of teachers from each hometown: count using the canonical key for teachers (implied by grouping on hometown) rather than counting individual teacher records. 4) When producing output: show \"Hometown\" first followed by the count of teachers, maintaining this column order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT hometown, COUNT(*) FROM teachers GROUP BY teacher_id;",
            "SELECT Hometown, COUNT(*) AS Number_of_Teachers FROM teacher GROUP BY Hometown;"
        ],
        "rule_sql": [
            "SELECT Hometown, COUNT(Teacher_ID) AS NumberOfTeachers FROM teacher GROUP BY Hometown;"
        ]
    },
    "502": {
        "db_id": "battle_death",
        "question": "How many different results are there for the battles?",
        "ground_truth": "SELECT count(DISTINCT RESULT) FROM battle",
        "amends": [
            "Do `count(DISTINCT RESULT)` instead of `COUNT(*)` to count distinct result values rather than all rows. Do reference table `battle` instead of `battles` to use the correct table name. The amended query now correctly counts distinct battle results from the proper table."
        ],
        "rules": [
            "1) When the question asks for \"different results\" or \"distinct results\": count the number of unique values in the \"RESULT\" column. 2) When counting distinct values: use the exact column name \"RESULT\" as shown in the schema. 3) When referencing the table containing battle information: use the exact table name \"battle\" (not \"battles\") as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM battles;",
            "SELECT COUNT(DISTINCT result) FROM battle;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT result) FROM battle;"
        ]
    },
    "855": {
        "db_id": "orchestra",
        "question": "What are the orchestras that do not have any performances?",
        "ground_truth": "SELECT Orchestra FROM orchestra WHERE Orchestra_ID NOT IN (SELECT Orchestra_ID FROM performance)",
        "amends": [
            "Do select `Orchestra` instead of `name` and use table `orchestra` instead of `orchestras`. Do use a `NOT IN` subquery checking for `Orchestra_ID` values that exist in the `performance` table instead of checking `performance_id IS NULL`. Do remove the direct NULL check condition and instead implement the exclusion logic through the correlated subquery approach. The amended query now correctly identifies orchestras that have no associated performances by checking for Orchestra_ID values not present in the performance table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about orchestras without performances: select \"Orchestra\" from table \"orchestra\" (T1) instead of \"name\" from \"orchestras\". 2) When checking for orchestras without performances: use a NOT IN subquery that checks for \"Orchestra_ID\" values that exist in the \"performance\" table instead of checking for NULL values. 3) When implementing exclusion logic: use a correlated subquery approach to identify orchestras whose \"Orchestra_ID\" values are not present in the \"performance\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM orchestras WHERE performance_id IS NULL;",
            "SELECT Orchestra FROM orchestra WHERE Orchestra_ID NOT IN (SELECT Orchestra_ID FROM performance)"
        ],
        "rule_sql": [
            "SELECT Orchestra FROM orchestra WHERE Orchestra_ID NOT IN (SELECT DISTINCT Orchestra_ID FROM performance);"
        ]
    },
    "772": {
        "db_id": "world_1",
        "question": "What are the countries that have greater surface area than any country in Europe?",
        "ground_truth": "SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  \"Europe\")",
        "amends": [
            "Do use `Name` instead of `name` for the column selection to match the correct case. Do use `SurfaceArea` instead of `surface_area` for the column reference in both the main query and subquery. Do use `Continent` instead of `continent` for the column reference in the subquery filter. Do use double quotes `\"Europe\"` instead of single quotes `'Europe'` for the string literal. Do use `MIN(SurfaceArea)` instead of `MAX(SurfaceArea)` in the subquery to find the minimum surface area instead of the maximum. The amended query now correctly identifies countries with surface area greater than the minimum surface area of European countries instead of the maximum, matching the intended behavior."
        ],
        "rules": [
            "1) When selecting country names: use \"Name\" instead of \"name\" to match the correct case. 2) When referencing surface area: use \"SurfaceArea\" instead of \"surface_area\" for column references. 3) When filtering by continent: use \"Continent\" instead of \"continent\" for column references. 4) When using string literals for continents: use double quotes \"Europe\" instead of single quotes 'Europe'. 5) When comparing surface areas to European countries: use MIN(SurfaceArea) instead of MAX(SurfaceArea) to find countries with surface area greater than the minimum surface area of European countries."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM country WHERE surface_area > (SELECT MAX(surface_area) FROM country WHERE continent = 'Europe')",
            "SELECT Name FROM country WHERE SurfaceArea > (SELECT MIN(SurfaceArea) FROM country WHERE Continent = \"Europe\")"
        ],
        "rule_sql": [
            "SELECT Name FROM country WHERE SurfaceArea > (SELECT MIN(SurfaceArea) FROM country WHERE Continent = \"Europe\")"
        ]
    },
    "907": {
        "db_id": "network_1",
        "question": "Give the name of the student with the most likes.",
        "ground_truth": "SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.name` from the `Highschooler` table instead of `name` from the `students` table. Do join `Likes AS T1` with `Highschooler AS T2` on `T1.student_id = T2.id` instead of querying a single table. Do add `GROUP BY T1.student_id` to aggregate likes per student instead of ordering individual records. Do order by `count(*) DESC` to rank by total like count instead of `likes DESC` which would sort by a single like value. Do remove the direct `ORDER BY likes` clause and instead use aggregate counting through grouping. The amended query now correctly identifies the student with the most likes by joining the Likes table with student information and counting occurrences per student."
        ],
        "rules": [
            "1) When answering about \"student with the most likes\": make sure the output order: T2.name 2) When the question mentions \"student\": \"student\" actually means \"Highschooler\" in schema 3) When combining T1 and T2 for shared entities: link rows where T1.student_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match) 4) When the question asks for \"count of likes per student\": organize results by T1.student_id and compute count(*) per group 5) When the question mentions \"most likes\" or \"highest\": rank rows by count(*) in descending direction and keep the first 1 row"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM students ORDER BY likes DESC LIMIT 1;",
            "SELECT T2.name\nFROM Likes AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.name\nFROM Likes T1\nINNER JOIN Highschooler T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "782": {
        "db_id": "world_1",
        "question": "What are the codes of the countries that do not speak English and whose government forms are not Republic?",
        "ground_truth": "SELECT Code FROM country WHERE GovernmentForm != \"Republic\" EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  \"English\"",
        "amends": [
            "Do select `Code` from `country` instead of `CountryCode` from `CountryLanguage`. Do use `EXCEPT` to exclude countries with English language instead of filtering with `Language != 'English'`. Do move the `GovernmentForm != 'Republic'` filter to the first SELECT clause instead of including it in the WHERE clause of a single query. Do remove the incorrect join logic between country and countrylanguage tables instead of attempting to query them together without proper joins. Do add proper table separation with EXCEPT instead of combining filters in a single WHERE clause that creates incorrect semantics. The amended query now correctly identifies countries that are not republics and exclude those where English is spoken, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about country codes: select \"Code\" from the \"country\" table instead of \"CountryCode\" from \"countrylanguage\". 2) When excluding countries that speak English: use EXCEPT to remove countries where English is spoken rather than filtering with Language != 'English'. 3) When filtering for non-republic government forms: apply GovernmentForm != 'Republic' directly in the first SELECT clause. 4) When combining country and countrylanguage data: use proper table separation with EXCEPT instead of incorrect join logic between tables. 5) When handling text literals: preserve exact case and spelling for 'English' and 'Republic'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT CountryCode FROM CountryLanguage WHERE Language != 'English' AND GovernmentForm != 'Republic';",
            "SELECT Code FROM country WHERE GovernmentForm != 'Republic'\nEXCEPT\nSELECT CountryCode FROM countrylanguage WHERE Language = 'English'"
        ],
        "rule_sql": [
            "SELECT Code FROM country WHERE GovernmentForm != 'Republic'\nEXCEPT\nSELECT CountryCode FROM countrylanguage WHERE Language = 'English'"
        ]
    },
    "842": {
        "db_id": "orchestra",
        "question": "Show the names of conductors that have conducted more than one orchestras.",
        "ground_truth": "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID GROUP BY T2.Conductor_ID HAVING COUNT(*)  >  1",
        "amends": [
            "Do select `T1.Name` with table alias qualification instead of unqualified `name`. Do use `JOIN` between `conductor AS T1` and `orchestra AS T2` with join condition `T1.Conductor_ID = T2.Conductor_ID` instead of querying only `conductors` table. Do add `GROUP BY T2.Conductor_ID` to group by the conductor identifier instead of no grouping. Do move the count filter to `HAVING COUNT(*) > 1` instead of using `WHERE orchestra_count > 1` with a direct column filter. The amended query now correctly identifies conductors who lead multiple orchestras by counting orchestra associations rather than relying on a pre-calculated count column."
        ],
        "rules": [
            "1) When answering about \"conductors that have conducted more than one orchestras\": make sure the output order: T1.Name 2) When combining conductor table (T1) and orchestra table (T2) for shared entities: link rows where T1.Conductor_ID = T2.Conductor_ID; keep only matching pairs (inner match). 3) When the question asks for conductors by orchestra count: organize results by T2.Conductor_ID and compute COUNT(*) per group. 4) When filtering for conductors with more than one orchestra: apply the condition COUNT(*) > 1 in the grouping filter instead of using a direct column filter. 5) When selecting conductor names: use qualified identifier T1.Name instead of unqualified name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM conductors WHERE orchestra_count > 1;",
            "SELECT T1.Name \nFROM conductor AS T1 \nJOIN orchestra AS T2 ON T1.Conductor_ID = T2.Conductor_ID \nGROUP BY T2.Conductor_ID \nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM conductor T1 INNER JOIN orchestra T2 ON T1.Conductor_ID = T2.Conductor_ID GROUP BY T2.Conductor_ID HAVING COUNT(*) > 1 ORDER BY T1.Name;"
        ]
    },
    "197": {
        "db_id": "flight_2",
        "question": "Which city and country is the Alton airport at?",
        "ground_truth": "SELECT City ,  Country FROM AIRPORTS WHERE AirportName  =  \"Alton\"",
        "amends": [
            "Do use column aliases `City` and `Country` instead of the original column names `city` and `country`. Do reference the correct column name `AirportName` in the WHERE filter instead of `name`. Do use double quotes for the string literal \"Alton\" instead of single quotes. The amended query now correctly filters for airports with the specific name \"Alton\" and returns the properly aliased city and country columns, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about airport location details: use the exact column names \"City\" and \"Country\" from the airports table. 2) When filtering for a specific airport by name: use the exact column name \"AirportName\" and match the literal value \"Alton\" exactly with double quotes. 3) When producing output columns: maintain the order City then Country as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, country FROM airports WHERE name = 'Alton';",
            "SELECT City AS City, Country AS Country FROM airports WHERE AirportName = \"Alton\""
        ],
        "rule_sql": [
            "SELECT City, Country FROM airports WHERE AirportName = \"Alton\";"
        ]
    },
    "921": {
        "db_id": "dog_kennels",
        "question": "Find the average age of the dogs who went through treatments.",
        "ground_truth": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )",
        "amends": [
            "Do use `avg(age)` with lowercase function instead of `AVG(age)` with uppercase. Do filter using `dog_id IN (subquery)` instead of `treatment_id IS NOT NULL`. Do reference table as `Dogs` instead of `dogs`. Do add a correlated subquery `SELECT dog_id FROM Treatments` to properly identify dogs that have treatments instead of checking for non-null treatment_id values. The amended query now correctly calculates average age only for dogs that have corresponding treatment records, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"average age of dogs who went through treatments\": make sure the output order: avg(age). 2) When the question mentions \"dogs who went through treatments\": use a subquery to select dog_id from Treatments table instead of checking for non-null treatment_id values. 3) When computing average age: use lowercase avg(age) function instead of uppercase AVG(age). 4) When referencing the dogs table: use exact identifier \"Dogs\" with proper casing instead of lowercase \"dogs\". 5) When filtering dogs with treatments: use dog_id IN (SELECT dog_id FROM Treatments) to properly identify dogs that have corresponding treatment records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age) FROM dogs WHERE treatment_id IS NOT NULL;",
            "SELECT avg(age) FROM Dogs WHERE dog_id IN (SELECT dog_id FROM Treatments)"
        ],
        "rule_sql": [
            "SELECT avg(age) FROM Dogs WHERE dog_id IN (SELECT dog_id FROM Treatments)"
        ]
    },
    "661": {
        "db_id": "poker_player",
        "question": "What are the names of poker players whose earnings is higher than 300000?",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID WHERE T2.Earnings  >  300000",
        "amends": [
            "Do reference the `people` table as `T1` and select `T1.Name` instead of selecting `name` from a non-existent `poker_players` table. Do add a `JOIN` with `poker_player` as `T2` on the predicate `T1.People_ID = T2.People_ID` instead of querying a single table. Do filter on `T2.Earnings > 300000` instead of filtering on a non-existent `earnings` column from the wrong table. The amended query now correctly joins the people and poker_player tables to find players with earnings exceeding 300000, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about poker players' names: select \"T1.Name\" from the \"people\" table as T1 instead of selecting \"name\" from a non-existent table. 2) When combining information about poker players and their earnings: join \"people\" as T1 with \"poker_player\" as T2 using the condition \"T1.People_ID = T2.People_ID\" to link player identities. 3) When filtering for earnings higher than 300000: apply the filter \"T2.Earnings > 300000\" using the exact column from the poker_player table instead of a non-existent earnings column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM poker_players WHERE earnings > 300000",
            "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID WHERE T2.Earnings > 300000"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID WHERE T2.Earnings > 300000"
        ]
    },
    "756": {
        "db_id": "world_1",
        "question": "Which language is the most popular on the Asian continent?",
        "ground_truth": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Continent  =  \"Asia\" GROUP BY T2.Language ORDER BY COUNT (*) DESC LIMIT 1",
        "amends": [
            "Do use `T2.Language` in the SELECT list instead of `language` and remove the `count` alias. Do join `country AS T1` with `countrylanguage AS T2` on `T1.Code = T2.CountryCode` instead of querying a single `countries` table. Do filter on `T1.Continent = \"Asia\"` instead of `continent = 'Asia'`. Do group by `T2.Language` instead of `language`. Do order by `COUNT(*) DESC` instead of `count DESC`. The amended query now correctly joins the country and countrylanguage tables to find the most spoken language in Asia."
        ],
        "rules": [
            "1) When answering about \"most popular language on the Asian continent\": make sure the output order: T2.Language, COUNT(*). 2) When the question mentions \"Asian continent\": \"Asia\" actually means T1.Continent = \"Asia\" in schema. 3) When combining T1 (country) and T2 (countrylanguage) for shared entities: link rows where T1.Code = T2.CountryCode; keep only matching pairs (inner match). 4) When the question asks for \"most popular language\": rank rows by COUNT(*) in descending direction and keep the first 1 row. 5) When the question asks for \"count of languages per language group\": compute the number of rows using T2.Language as the grouping key and count all matching rows per group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language, COUNT(*) as count FROM countries WHERE continent = 'Asia' GROUP BY language ORDER BY count DESC LIMIT 1;",
            "SELECT T2.Language\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nWHERE T1.Continent = 'Asia'\nGROUP BY T2.Language\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Language, COUNT(*) \nFROM country T1 \nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T1.Continent = 'Asia' \nGROUP BY T2.Language \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ]
    },
    "313": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show ids for all templates that are used by more than one document.",
        "ground_truth": "SELECT template_id FROM Documents GROUP BY template_id HAVING count(*)  >  1",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_id FROM documents GROUP BY template_id HAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT t.Template_ID\nFROM Templates t\nJOIN Documents d ON t.Template_ID = d.Template_ID\nGROUP BY t.Template_ID\nHAVING COUNT(d.Document_ID) > 1;"
        ]
    },
    "689": {
        "db_id": "voter_1",
        "question": "List the vote ids, phone numbers and states of all votes.",
        "ground_truth": "SELECT vote_id ,  phone_number ,  state FROM votes",
        "amends": [
            "Do add `state` to the SELECT list instead of omitting it. The amended query now matches the right SQL's behavior by including all required columns."
        ],
        "rules": [
            "1) When the question asks to list vote ids, phone numbers and states: include all three columns \"vote_id\", \"phone_number\", and \"state\" in the output in the order specified by the question. 2) When the schema shows column \"state\" as a varchar(2) in table VOTES: use the exact column name \"state\" with the correct data type and format. 3) When the question specifies output columns: maintain the exact column order of vote id, phone number, then state as requested."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT vote_id, phone_number FROM votes;",
            "SELECT vote_id, phone_number, state FROM VOTES;"
        ],
        "rule_sql": [
            "SELECT vote_id, phone_number, state FROM VOTES;"
        ]
    },
    "29": {
        "db_id": "concert_singer",
        "question": "What are the names of the stadiums without any concerts?",
        "ground_truth": "SELECT name FROM stadium WHERE stadium_id NOT IN (SELECT stadium_id FROM concert)",
        "amends": [
            "Do reference the correct table name `stadium` instead of the incorrect plural `stadiums`. Do use a subquery with `NOT IN` to filter stadiums not associated with any concerts instead of checking for `IS NULL` on a non-existent `concert_id` column. Do filter by `stadium_id NOT IN (SELECT stadium_id FROM concert)` instead of the incorrect `concert_id IS NULL` condition. The amended query now correctly identifies stadiums without concerts by checking the absence of stadium IDs in the concert table rather than relying on a missing column."
        ],
        "rules": [
            "1) When the question asks about stadiums without concerts: use the exact table name \"stadium\" instead of plural forms. 2) When filtering for stadiums not associated with concerts: use a subquery with NOT IN condition checking stadium_id NOT IN (SELECT stadium_id FROM concert) instead of checking for NULL values on non-existent columns. 3) When combining stadium and concert tables: use stadium_id as the linking key between the tables to identify which stadiums have concerts."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM stadiums WHERE concert_id IS NULL;",
            "SELECT Name FROM stadium WHERE Stadium_ID NOT IN (SELECT Stadium_ID FROM concert);"
        ],
        "rule_sql": [
            "SELECT Name FROM stadium WHERE Stadium_ID NOT IN (SELECT Stadium_ID FROM concert)"
        ]
    },
    "493": {
        "db_id": "battle_death",
        "question": "List the name, date and result of each battle.",
        "ground_truth": "SELECT name ,  date FROM battle",
        "amends": [
            "Do reference the table as `battle` instead of `battles` to ensure the query targets the correct database table. The amended query now correctly retrieves data from the intended table structure.",
            "Do remove `result` from the SELECT list instead of including it, which eliminates an unnecessary column from the output. The amended query now matches RIGHT_SQL's behavior by selecting only the required columns."
        ],
        "rules": [
            "1) When the question asks for \"name, date and result of each battle\": include the exact column \"result\" from table \"battle\" in the output. 2) When referencing the table containing battle information: use the exact table name \"battle\" instead of \"battles\". 3) When answering about battle details: make sure the output order includes name, date, and result columns.",
            "1) When the question asks for specific columns \"name\", \"date\", and \"result\": include only those exact columns in the output. 2) When the amends specify to remove a column from the SELECT list: eliminate that unnecessary column from the output to match the required behavior."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, date FROM battles;",
            "SELECT name, date, result FROM battle;",
            "SELECT name, date FROM battle;"
        ],
        "rule_sql": [
            "SELECT name, date, result FROM battle;"
        ]
    },
    "620": {
        "db_id": "tvshow",
        "question": "When did the episode \"A Love of a Lifetime\" air?",
        "ground_truth": "SELECT Air_Date FROM TV_series WHERE Episode = \"A Love of a Lifetime\";",
        "amends": [
            "Do select `Air_Date` instead of `episode_name` and do query from `TV_series` instead of `episodes`. Do filter on `Episode` column with value \"A Love of a Lifetime\" instead of filtering on `air_date` column with value 'A Love of a Lifetime'. The amended query now correctly retrieves the air date for the specified episode rather than incorrectly trying to find episode names matching a date value."
        ],
        "rules": [
            "1) When the question asks about when an episode aired: select the \"Air_Date\" column instead of episode names. 2) When querying for episode information: use the \"TV_series\" table instead of an \"episodes\" table. 3) When filtering for a specific episode title: filter on the \"Episode\" column with the exact literal value \"A Love of a Lifetime\" instead of filtering on date columns with episode titles."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT episode_name FROM episodes WHERE air_date = 'A Love of a Lifetime';",
            "SELECT Air_Date FROM TV_series WHERE Episode = 'A Love of a Lifetime';"
        ],
        "rule_sql": [
            "SELECT Air_Date FROM TV_series WHERE Episode = 'A Love of a Lifetime';"
        ]
    },
    "186": {
        "db_id": "flight_2",
        "question": "Give the airport code and airport name corresonding to the city Anthony.",
        "ground_truth": "SELECT AirportCode ,  AirportName FROM AIRPORTS WHERE city  =  \"Anthony\"",
        "amends": [
            "Do use `AirportCode` and `AirportName` column names instead of `airport_code` and `airport_name` to match the actual schema. Do use double quotes `\"Anthony\"` for the string literal instead of single quotes `'Anthony'` to maintain proper string formatting. The amended query now correctly retrieves airport information for the specified city while using the proper column names and string syntax."
        ],
        "rules": [
            "1) When the question asks for airport code and airport name: use the exact column names \"AirportCode\" and \"AirportName\" from the airports table. 2) When filtering by city name \"Anthony\": use double quotes around the literal value as \"Anthony\" to maintain proper string formatting. 3) When answering about airport information for a specific city: retrieve data from the airports table where the city column matches the exact specified value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airport_code, airport_name FROM airports WHERE city = 'Anthony';",
            "SELECT AirportCode, AirportName FROM airports WHERE City = \"Anthony\";"
        ],
        "rule_sql": [
            "SELECT AirportCode, AirportName FROM airports WHERE City = \"Anthony\";"
        ]
    },
    "327": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the version number and template type code for the template with version number later than 5?",
        "ground_truth": "SELECT version_number ,  template_type_code FROM Templates WHERE version_number  >  5",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT version_number, template_type_code FROM templates WHERE version_number > 5;"
        ],
        "rule_sql": [
            "SELECT Version_Number, Template_Type_Code FROM Templates WHERE Version_Number > 5"
        ]
    },
    "74": {
        "db_id": "pets_1",
        "question": "What is the average weight for each type of pet?",
        "ground_truth": "SELECT avg(weight) ,  pettype FROM pets GROUP BY pettype",
        "amends": [
            "Do select `avg(weight)` and `pettype` instead of `AVG(age)` as `average_weight` and `type`. Do group by `pettype` instead of `type`. The amended query now correctly calculates average weight grouped by pet type instead of incorrectly attempting to average age while mislabeling it as weight.",
            "Do use lowercase `avg(weight)` instead of uppercase `AVG(weight)` and place it first in the SELECT list instead of second. Do use lowercase `pettype` instead of uppercase `PetType` and place it second in the SELECT list instead of first. Do remove the alias `AS average_weight` instead of keeping it. Do use lowercase `pets` instead of uppercase `Pets` in the FROM clause. Do use lowercase `pettype` instead of uppercase `PetType` in the GROUP BY clause. The amended query now correctly calculates average weight by pet type without unnecessary aliasing and with consistent lowercase naming."
        ],
        "rules": [
            "1) When the question asks for \"average weight for each type of pet\": compute the average of the \"weight\" column instead of \"age\". 2) When grouping by pet type: use the exact column name \"pettype\" for grouping instead of \"type\". 3) When selecting output columns: include \"pettype\" and the average weight calculation with the exact column name \"weight\".",
            "1) When the question asks for average weight per pet type: compute the average of the \"weight\" column for each group. 2) When organizing results by pet type: group by the \"pettype\" column. 3) When selecting output columns: place the average weight calculation first in the output order, followed by the pet type. 4) When referring to table and column names: use lowercase identifiers \"pets\", \"pettype\", and \"weight\" exactly as specified. 5) When computing aggregates: do not include unnecessary aliases like \"AS average_weight\" in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type, AVG(age) as average_weight FROM pets GROUP BY type;",
            "SELECT PetType, AVG(weight) AS average_weight FROM Pets GROUP BY PetType;",
            "SELECT avg(weight), pettype FROM pets GROUP BY pettype"
        ],
        "rule_sql": [
            "SELECT AVG(weight), pettype FROM pets GROUP BY pettype"
        ]
    },
    "962": {
        "db_id": "dog_kennels",
        "question": "List the emails of the professionals who live in the state of Hawaii or the state of Wisconsin.",
        "ground_truth": "SELECT email_address FROM Professionals WHERE state  =  'Hawaii' OR state  =  'Wisconsin'",
        "amends": [
            "Do reference the `email_address` column instead of `email` and use `OR` between state conditions instead of `AND` to properly select professionals from either Hawaii or Wisconsin, instead of incorrectly requiring both states simultaneously which would never match any records."
        ],
        "rules": [
            "1) When the question asks for emails of professionals: use the exact column name \"email_address\" from the Professionals table instead of \"email\". 2) When the question asks for professionals in Hawaii OR Wisconsin: use OR between state conditions instead of AND to select professionals from either state, not both simultaneously. 3) When specifying state values: use the exact literals 'Hawaii' and 'Wisconsin' with proper capitalization and spelling."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT email FROM professionals WHERE state = 'Hawaii' AND state = 'Wisconsin';",
            "SELECT email_address FROM Professionals WHERE state = 'Hawaii' OR state = 'Wisconsin'"
        ],
        "rule_sql": [
            "SELECT email_address FROM Professionals WHERE state = 'Hawaii' OR state = 'Wisconsin'"
        ]
    },
    "303": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the document id, template id and description for document named \"Robbin CV\"?",
        "ground_truth": "SELECT document_id ,  template_id ,  Document_Description FROM Documents WHERE document_name  =  \"Robbin CV\"",
        "amends": [
            "Do use `Document_Description` instead of `description` in the SELECT list to match the correct column name. Do reference the table as `Documents` instead of `documents` to maintain proper case sensitivity. Do use double quotes `\"Robbin CV\"` instead of single quotes `'Robbin CV'` for the string literal in the WHERE clause. The amended query now correctly retrieves data from the proper column and table with the appropriate string formatting, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"description\": use the exact column name \"Document_Description\" instead of \"description\" to match the schema. 2) When referencing the documents table: use the exact table name \"Documents\" with proper case sensitivity. 3) When filtering for document named \"Robbin CV\": use double quotes \"Robbin CV\" for the string literal to match the required formatting."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id, template_id, description FROM documents WHERE document_name = 'Robbin CV';",
            "SELECT Document_ID, Template_ID, Document_Description FROM Documents WHERE Document_Name = \"Robbin CV\""
        ],
        "rule_sql": [
            "SELECT Document_ID, Template_ID, Document_Description FROM Documents WHERE Document_Name = \"Robbin CV\""
        ]
    },
    "943": {
        "db_id": "dog_kennels",
        "question": "Find the id and cell phone of the professionals who operate two or more types of treatments.",
        "ground_truth": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2",
        "amends": [
            "Do select `T1.professional_id` and `T1.cell_number` instead of `id` and `cell_phone`. Do join `Treatments AS T2` on `T1.professional_id = T2.professional_id` instead of querying only the `professionals` table. Do use `GROUP BY T1.professional_id` with `HAVING count(*) >= 2` instead of `WHERE COUNT(DISTINCT treatment_type) >= 2` to properly aggregate and filter professionals with multiple treatments. The amended query now correctly identifies professionals who have provided at least two treatments by joining the relevant tables and using appropriate aggregation."
        ],
        "rules": [
            "1) When selecting professional identifiers and contact information: use \"T1.professional_id\" and \"T1.cell_number\" instead of \"id\" and \"cell_phone\". 2) When finding professionals who operate multiple treatment types: join \"Treatments AS T2\" with \"T1\" where \"T1.professional_id = T2.professional_id\" to access treatment records. 3) When counting treatment types per professional: group by \"T1.professional_id\" and use \"count(*) >= 2\" to filter for professionals with at least two treatments. 4) When the question asks about \"two or more types of treatments\": this means counting the number of treatment records (not distinct treatment types) per professional and requiring at least two records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, cell_phone FROM professionals WHERE COUNT(DISTINCT treatment_type) >= 2;",
            "SELECT T1.professional_id, T1.cell_number\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T1.professional_id, T1.cell_number\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) >= 2"
        ]
    },
    "908": {
        "db_id": "network_1",
        "question": "Show the names of students who have at least 2 likes.",
        "ground_truth": "SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id HAVING count(*)  >=  2",
        "amends": [
            "Do select `T2.name` from the joined table instead of `name` from a single table. Do use `FROM Likes AS T1 JOIN Highschooler AS T2` with an explicit join instead of querying only `FROM students`. Do add the join condition `ON T1.student_id = T2.id` instead of missing the table relationship. Do add `GROUP BY T1.student_id` to aggregate by student instead of no grouping. Do move the count filter to `HAVING count(*) >= 2` instead of using `WHERE likes >= 2` on a non-aggregated column. The amended query now correctly counts likes per student and filters those with at least two likes, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"students who have at least 2 likes\": make sure the output order: T2.name\n2) When the question mentions \"students\": \"students\" actually means \"Highschooler AS T2\" in schema\n3) When the question mentions \"likes\": \"likes\" actually means \"Likes AS T1\" in schema\n4) When combining T1 and T2 for shared entities: link rows where T1.student_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match)\n5) When the question asks for \"count of likes per student\": compute the number of rows using T1.student_id as the grouping key and count occurrences per student\n6) When filtering for \"at least 2 likes\": apply the condition count(*) >= 2 after grouping instead of on individual rows"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM students WHERE likes >= 2;",
            "SELECT T2.name \nFROM Likes AS T1 \nJOIN Highschooler AS T2 ON T1.student_id = T2.ID \nGROUP BY T1.student_id \nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T2.name\nFROM Likes AS T1\nINNER JOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nHAVING COUNT(*) >= 2\nORDER BY T2.name"
        ]
    },
    "433": {
        "db_id": "wta_1",
        "question": "List the first name and birth date of all players from the country with code USA.",
        "ground_truth": "SELECT first_name ,  birth_date FROM players WHERE country_code  =  'USA'",
        "amends": [
            "Do use `'USA'` as the country code filter instead of `'CANADA'` in the WHERE clause. The amended query now correctly filters for players from the USA instead of Canada, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for players from the country with code USA: use the exact literal 'USA' (not 'CANADA') for the country_code filter. 2) When selecting player information: include both first_name and birth_date columns in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, birth_date FROM players WHERE country_code = 'CANADA';",
            "SELECT first_name, birth_date FROM players WHERE country_code = 'USA';"
        ],
        "rule_sql": [
            "SELECT first_name, birth_date FROM players WHERE country_code = 'USA';"
        ]
    },
    "675": {
        "db_id": "poker_player",
        "question": "What is the most common nationality of people?",
        "ground_truth": "SELECT Nationality FROM people GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do use `Nationality` instead of `nationality` for the column name in both the SELECT list and GROUP BY clause. Do order by `COUNT(*) DESC` instead of `ASC` to get the nationality with the highest count instead of the lowest. Do remove the `count` alias from the SELECT list instead of keeping it since it's not needed in the ORDER BY clause. The amended query now correctly identifies the most common nationality by counting occurrences in descending order.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, as the query only needs to return the Nationality with the highest count rather than both the Nationality and its count value. The amended query now correctly returns just the Nationality column while maintaining the same grouping, ordering, and limiting logic to identify the most frequent nationality."
        ],
        "rules": [
            "1) When the question asks for the most common nationality: use the exact column name \"Nationality\" from the people table. 2) When counting occurrences of nationality: count all rows using COUNT(*) and group by \"Nationality\". 3) When ordering to find the most common: order the results by the count in descending order to get the highest count first. 4) When the question asks for the most common nationality: return only the top result (limit 1).",
            "1) When the question asks for the most common nationality of people: identify the nationality with the highest count of occurrences. 2) When counting occurrences of nationalities: count the number of rows for each distinct Nationality value. 3) When determining the most common value: rank nationalities by their count in descending order and take the first result. 4) When the question asks for only the nationality value (not the count): return only the Nationality column in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT nationality, COUNT(*) as count FROM people GROUP BY nationality ORDER BY count ASC LIMIT 1;",
            "SELECT Nationality, COUNT(*) FROM people GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT Nationality FROM people GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Nationality FROM people GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "174": {
        "db_id": "car_1",
        "question": "What are the names of the countries with no car makers?",
        "ground_truth": "SELECT CountryName FROM countries EXCEPT SELECT T1.CountryName FROM countries AS T1 JOIN CAR_MAKERS AS T2 ON T1.countryId  =  T2.Country;",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do reference `CountryName` instead of `name` in the SELECT list. Do add an explicit table alias `T1` for the countries table instead of using it without alias. Do include a `JOIN` between `countries AS T1` and `CAR_MAKERS AS T2` with the predicate `ON T1.countryId = T2.Country` instead of the subquery correlation. Do remove the `WHERE` clause with subquery entirely instead of keeping it. The amended query now correctly uses set semantics to find countries without car makers, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"countries with no car makers\": use EXCEPT set operation instead of NOT IN with a subquery. 2) When selecting country names: use \"CountryName\" instead of \"name\" as the output column. 3) When referencing the countries table: use explicit alias \"T1\" for the countries table. 4) When combining countries and car makers tables: link rows where T1.countryId = T2.Country to find matching pairs. 5) When finding countries without car makers: use set semantics to exclude countries that have car makers from the full set of countries."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM countries WHERE country_id NOT IN (SELECT country_id FROM car_makers);",
            "SELECT T1.CountryName\nFROM countries AS T1\nLEFT JOIN car_makers AS T2 ON T1.CountryId = T2.Country\nWHERE T2.Country IS NULL"
        ],
        "rule_sql": [
            "SELECT T1.CountryName FROM countries T1\nEXCEPT\nSELECT T1.CountryName FROM countries T1\nJOIN car_makers T2 ON T1.CountryId = T2.Country"
        ]
    },
    "274": {
        "db_id": "employee_hire_evaluation",
        "question": "Sort all the shops by number products in descending order, and return the name, location and district of each shop.",
        "ground_truth": "SELECT name ,  LOCATION ,  district FROM shop ORDER BY number_products DESC",
        "amends": [
            "Do reference the correct table name `shop` instead of `shops` in the FROM clause. Do order by the column `number_products` instead of the aggregate function `COUNT(products)` in the ORDER BY clause, as aggregates cannot be used directly in ORDER BY without being in the SELECT list or a GROUP BY clause. The amended query now correctly retrieves data from the intended table and sorts results based on the existing product count column rather than attempting to perform an invalid aggregation in the ORDER BY clause."
        ],
        "rules": [
            "1) When the question refers to \"shops\": use the exact table name \"shop\" instead of \"shops\". 2) When ordering by number of products: use the existing column \"number_products\" directly rather than attempting to count products through aggregation. 3) When the question asks to sort in descending order: order by \"number_products\" in descending direction. 4) When returning shop information: output the columns \"name\", \"location\", and \"district\" in that order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, location, district FROM shops ORDER BY COUNT(products) DESC;",
            "SELECT Name, Location, District FROM shop ORDER BY Number_products DESC;"
        ],
        "rule_sql": [
            "SELECT name, location, district FROM shop ORDER BY number_products DESC;"
        ]
    },
    "501": {
        "db_id": "battle_death",
        "question": "What are the distinct battle names which are between bulgarian commander 'Kaloyan' and latin commander 'Baldwin I'?",
        "ground_truth": "SELECT name FROM battle WHERE bulgarian_commander  =  'Kaloyan' AND latin_commander  =  'Baldwin I'",
        "amends": [
            "Do select `name` from the `battle` table instead of `battle_name` from `battles`. Do use filter conditions `bulgarian_commander = 'Kaloyan'` and `latin_commander = 'Baldwin I'` instead of `commander1 = 'Kaloyan'` and `commander2 = 'Baldwin I'`. Do remove `DISTINCT` instead of keeping it since the query now correctly references the proper table structure and column names. The amended query now matches the intended behavior of filtering battles by specific commanders from different factions."
        ],
        "rules": [
            "1) When the question asks for battle names: use the column \"name\" from the \"battle\" table instead of \"battle_name\" from \"battles\". 2) When filtering for bulgarian commander 'Kaloyan': use the condition \"bulgarian_commander = 'Kaloyan'\" exactly as specified. 3) When filtering for latin commander 'Baldwin I': use the condition \"latin_commander = 'Baldwin I'\" exactly as specified. 4) When the question asks for distinct battle names: do not use DISTINCT since the query correctly references the proper table structure and column names without needing deduplication."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT battle_name FROM battles WHERE commander1 = 'Kaloyan' AND commander2 = 'Baldwin I';",
            "SELECT name FROM battle WHERE bulgarian_commander = 'Kaloyan' AND latin_commander = 'Baldwin I'"
        ],
        "rule_sql": [
            "SELECT name FROM battle WHERE bulgarian_commander = 'Kaloyan' AND latin_commander = 'Baldwin I'"
        ]
    },
    "388": {
        "db_id": "course_teach",
        "question": "What are the names of the teachers whose hometown is not `` Little Lever Urban District '' ?",
        "ground_truth": "select name from teacher where hometown != \"little lever urban district\"",
        "amends": [
            "Do reference table `teacher` instead of `teachers` in the FROM clause. Do use inequality filter `!= \"little lever urban district\"` instead of equality filter `= 'Little Lever Urban District'` in the WHERE clause. The amended query now correctly filters for teachers not from Little Lever Urban District instead of those from it, matching the intended behavior.",
            "Do use lowercase `select` instead of uppercase `SELECT`, lowercase `from` instead of uppercase `FROM`, lowercase `where` instead of uppercase `WHERE`, and lowercase `name` instead of uppercase `Name` to maintain consistent casing throughout the query. Do use lowercase `hometown` instead of uppercase `Hometown` and lowercase `little lever urban district` instead of capitalized `Little Lever Urban District` for case consistency in both column reference and string comparison. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [
            "1) When the question asks about teachers: use table \"teacher\" instead of \"teachers\" as the data source. 2) When filtering for teachers whose hometown is not \"Little Lever Urban District\": use inequality comparison != \"little lever urban district\" instead of equality comparison. 3) When handling text literals: preserve the exact case and spacing as \"little lever urban district\" (all lowercase) as shown in the amends, not the mixed case from the question.",
            "1) When choosing SQL keywords: use lowercase 'select', 'from', and 'where' instead of uppercase versions to maintain consistent casing throughout the query. 2) When referring to column names: use lowercase 'name' instead of uppercase 'Name' and lowercase 'hometown' instead of uppercase 'Hometown' to match the schema's column naming convention. 3) When comparing string literals: use lowercase 'little lever urban district' instead of capitalized 'Little Lever Urban District' for case consistency in string comparison."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM teachers WHERE hometown = 'Little Lever Urban District';",
            "SELECT Name FROM teacher WHERE Hometown != \"Little Lever Urban District\"",
            "select name from teacher where hometown != \"little lever urban district\""
        ],
        "rule_sql": [
            "select name from teacher where hometown != 'little lever urban district'"
        ]
    },
    "858": {
        "db_id": "orchestra",
        "question": "Find the number of orchestras whose record format is \"CD\" or \"DVD\".",
        "ground_truth": "SELECT COUNT(*) FROM orchestra WHERE Major_Record_Format  =  \"CD\" OR Major_Record_Format  =  \"DVD\"",
        "amends": [
            "Do reference table `orchestra` instead of `orchestras`. Do use column `Major_Record_Format` instead of `record_format`. Do apply OR condition between `Major_Record_Format = \"CD\"` and `Major_Record_Format = \"DVD\"` instead of AND condition between `record_format = 'CD'` and `record_format = 'DVD'`. Do use double quotes around string literals \"CD\" and \"DVD\" instead of single quotes. The amended query now correctly counts records where the major record format is either CD or DVD, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"orchestras\": use the exact table name \"orchestra\" instead. 2) When the question mentions \"record format\": use the exact column name \"Major_Record_Format\" instead. 3) When the question asks for records where format is \"CD\" or \"DVD\": use OR condition between \"Major_Record_Format = \\\"CD\\\"\" and \"Major_Record_Format = \\\"DVD\\\"\" instead of AND. 4) When using string literals \"CD\" and \"DVD\": wrap them in double quotes exactly as shown in the schema. 5) When counting orchestras: count the number of rows in table \"orchestra\" where the condition is satisfied."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM orchestras WHERE record_format = 'CD' AND record_format = 'DVD';",
            "SELECT COUNT(*) FROM orchestra WHERE Major_Record_Format = \"CD\" OR Major_Record_Format = \"DVD\""
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM orchestra WHERE Major_Record_Format = \"CD\" OR Major_Record_Format = \"DVD\""
        ]
    },
    "940": {
        "db_id": "dog_kennels",
        "question": "Which owner has paid the largest amount of money in total for their dogs? Show the owner id and zip code.",
        "ground_truth": "SELECT T1.owner_id ,  T1.zip_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY sum(T3.cost_of_treatment) DESC LIMIT 1",
        "amends": [
            "Do change the SELECT list to `T1.owner_id, T1.zip_code` instead of `owner_id, zip_code, SUM(amount) as total_paid`. Do change the FROM clause to join `Owners AS T1` with `Dogs AS T2` on `T1.owner_id = T2.owner_id` and then join `Treatments AS T3` on `T2.dog_id = T3.dog_id` instead of using a single `payments` table. Do remove the `zip_code` from GROUP BY and use only `T1.owner_id` instead of grouping by both `owner_id, zip_code`. Do change the ORDER BY to `sum(T3.cost_of_treatment) DESC` instead of `total_paid ASC`. Do remove the alias `total_paid` and reference the aggregate function directly in ORDER BY. The amended query now correctly identifies the owner with the highest total treatment costs across their dogs instead of summarizing payments by zip code."
        ],
        "rules": [
            "1) When answering about \"owner has paid the largest amount of money in total for their dogs\": make sure the output order: T1.owner_id, T1.zip_code\n2) When combining Owners as T1 and Dogs as T2 for shared entities: link rows where T1.owner_id = T2.owner_id and keep only matching pairs (inner match)\n3) When combining Dogs as T2 and Treatments as T3 for shared entities: link rows where T2.dog_id = T3.dog_id and keep only matching pairs (inner match)\n4) When the question asks for \"total amount paid for dogs\": compute the sum of T3.cost_of_treatment per owner\n5) When the question mentions \"largest amount\": rank owners by sum(T3.cost_of_treatment) in descending order and keep the first 1 row\n6) When grouping by owner: organize results by T1.owner_id only, not by zip_code\n7) When producing output: include T1.owner_id and T1.zip_code in the results"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT owner_id, zip_code, SUM(amount) as total_paid\nFROM payments\nGROUP BY owner_id, zip_code\nORDER BY total_paid ASC\nLIMIT 1;",
            "SELECT T1.owner_id, T1.zip_code\nFROM Owners AS T1\nJOIN Dogs AS T2 ON T1.owner_id = T2.owner_id\nJOIN Treatments AS T3 ON T2.dog_id = T3.dog_id\nGROUP BY T1.owner_id\nORDER BY SUM(T3.cost_of_treatment) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.owner_id, T1.zip_code\nFROM Owners AS T1\nINNER JOIN Dogs AS T2 ON T1.owner_id = T2.owner_id\nINNER JOIN Treatments AS T3 ON T2.dog_id = T3.dog_id\nGROUP BY T1.owner_id\nORDER BY SUM(T3.cost_of_treatment) DESC\nLIMIT 1;"
        ]
    },
    "513": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the zip code of the address in the city Port Chelsea?",
        "ground_truth": "SELECT zip_postcode FROM Addresses WHERE city  =  'Port Chelsea'",
        "amends": [
            "Do reference column `zip_postcode` instead of `zip_code` and table `Addresses` instead of `addresses` while maintaining the same filter condition `city = 'Port Chelsea'` without any changes to the WHERE clause, join logic, or other query components, confirming the amended query now correctly retrieves postal codes from the Addresses table."
        ],
        "rules": [
            "1) When the question asks for \"zip code\": use the exact column token \"zip_postcode\" from the Addresses table instead of \"zip_code\". 2) When referencing the table containing address information: use the exact table name \"Addresses\" (with capital A) instead of \"addresses\". 3) When filtering for the city \"Port Chelsea\": maintain the exact literal value 'Port Chelsea' with the same case and spacing in the condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT zip_code FROM addresses WHERE city = 'Port Chelsea';",
            "SELECT zip_postcode FROM Addresses WHERE city = 'Port Chelsea';"
        ],
        "rule_sql": [
            "SELECT zip_postcode FROM Addresses WHERE city = 'Port Chelsea';"
        ]
    },
    "730": {
        "db_id": "world_1",
        "question": "What is the average GNP and total population in all nations whose government is US territory?",
        "ground_truth": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  \"US Territory\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(GNP), SUM(Population) FROM country WHERE GovernmentForm = 'US Territory';"
        ],
        "rule_sql": [
            "SELECT AVG(GNP) as AverageGNP, SUM(Population) as TotalPopulation FROM country WHERE GovernmentForm = 'US Territory';"
        ]
    },
    "1010": {
        "db_id": "singer",
        "question": "What is the name of the singer with the largest net worth?",
        "ground_truth": "SELECT Name FROM singer ORDER BY Net_Worth_Millions DESC LIMIT 1",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the correct table name `singer` instead of `singers`. Do order by `Net_Worth_Millions DESC` instead of `net_worth ASC` to sort by the correct column name in descending order rather than ascending. The amended query now correctly retrieves the singer with the highest net worth from the proper table structure."
        ],
        "rules": [
            "1) When the question asks about \"singer\": use the exact table name \"singer\" instead of \"singers\". 2) When the question asks for \"name\": use the exact column name \"Name\" instead of \"name\". 3) When the question asks for the \"largest net worth\": use the exact column name \"Net_Worth_Millions\" and sort in descending order instead of ascending order. 4) When answering about \"the singer with the largest net worth\": make sure the output order: \"Name\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers ORDER BY net_worth ASC LIMIT 1;",
            "SELECT Name FROM singer ORDER BY Net_Worth_Millions DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name FROM singer ORDER BY Net_Worth_Millions DESC LIMIT 1;"
        ]
    },
    "212": {
        "db_id": "flight_2",
        "question": "How many flights fly from Aberdeen to Ashley?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode JOIN AIRPORTS AS T3 ON T1.SourceAirport  =  T3.AirportCode WHERE T2.City  =  \"Ashley\" AND T3.City  =  \"Aberdeen\"",
        "amends": [
            "Do join `AIRPORTS AS T2` on `T1.DestAirport = T2.AirportCode` and `AIRPORTS AS T3` on `T1.SourceAirport = T3.AirportCode` instead of querying `flights` directly without joins. Do filter on `T2.City = \"Ashley\"` and `T3.City = \"Aberdeen\"` instead of filtering `departure_city = 'Aberdeen'` and `arrival_city = 'Ashley'` directly on the flights table. The amended query now correctly joins through the airports table to validate city names against airport codes, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about flights between cities: join AIRPORTS AS T2 on T1.DestAirport = T2.AirportCode and AIRPORTS AS T3 on T1.SourceAirport = T3.AirportCode to validate city names against airport codes. 2) When the question mentions \"from Aberdeen\": filter on T3.City = \"Aberdeen\" instead of filtering departure_city directly on the flights table. 3) When the question mentions \"to Ashley\": filter on T2.City = \"Ashley\" instead of filtering arrival_city directly on the flights table. 4) When combining tables for shared entities: link rows where T1.DestAirport = T2.AirportCode and T1.SourceAirport = T3.AirportCode; keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE departure_city = 'Aberdeen' AND arrival_city = 'Ashley';",
            "SELECT COUNT(*) \nFROM flights AS T1\nJOIN airports AS T2 ON T1.DestAirport = T2.AirportCode\nJOIN airports AS T3 ON T1.SourceAirport = T3.AirportCode\nWHERE T3.City = 'Aberdeen' AND T2.City = 'Ashley'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM flights AS T1\nJOIN airports AS T2 ON T1.DestAirport = T2.AirportCode\nJOIN airports AS T3 ON T1.SourceAirport = T3.AirportCode\nWHERE T3.City = 'Aberdeen' AND T2.City = 'Ashley'"
        ]
    },
    "977": {
        "db_id": "dog_kennels",
        "question": "Show me the cost of the most recently performed treatment.",
        "ground_truth": "SELECT cost_of_treatment FROM Treatments ORDER BY date_of_treatment DESC LIMIT 1",
        "amends": [
            "Do reference the column `cost_of_treatment` instead of `cost` in the SELECT list. Do reference the column `date_of_treatment` instead of `treatment_date` in the ORDER BY clause. The amended query now correctly retrieves the most recent treatment cost using the proper column names from the Treatments table."
        ],
        "rules": [
            "1) When the question asks for \"cost of treatment\": use the exact column name \"cost_of_treatment\" from the Treatments table. 2) When ordering by treatment date to find the most recent treatment: use the exact column name \"date_of_treatment\" from the Treatments table and sort in descending order. 3) When retrieving the single most recent treatment: take only the first row after ordering by date_of_treatment in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT cost FROM treatments ORDER BY treatment_date DESC LIMIT 1;",
            "SELECT cost_of_treatment FROM Treatments ORDER BY date_of_treatment DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT cost_of_treatment FROM Treatments ORDER BY date_of_treatment DESC LIMIT 1;"
        ]
    },
    "28": {
        "db_id": "concert_singer",
        "question": "Show the stadium names without any concert.",
        "ground_truth": "SELECT name FROM stadium WHERE stadium_id NOT IN (SELECT stadium_id FROM concert)",
        "amends": [
            "Do select `name` instead of `stadium_name` and use a subquery with `NOT IN` instead of checking `IS NULL` on `concert_id`. Do reference table `stadium` instead of `stadiums` and use `stadium_id` as the correlation key instead of `concert_id`. Do remove the direct null check filter and instead implement a subquery that identifies stadiums not present in the concert table, which correctly handles the case where stadiums may have no associated concerts. The amended query now matches the right SQL's behavior by properly identifying stadiums without any concerts through a correlated subquery approach."
        ],
        "rules": [
            "1) When the question asks for stadium names: use the exact column token \"name\" from the stadium table instead of \"stadium_name\". 2) When identifying stadiums without concerts: use a subquery approach with NOT IN instead of checking for NULL values on concert_id. 3) When referencing the stadium table: use the exact table name \"stadium\" instead of \"stadiums\". 4) When correlating between stadium and concert tables: use \"stadium_id\" as the correlation key instead of \"concert_id\". 5) When checking for stadiums without concerts: implement a subquery that identifies stadiums not present in the concert table to properly handle cases where stadiums may have no associated concerts."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT stadium_name FROM stadiums WHERE concert_id IS NULL;",
            "SELECT Name FROM stadium WHERE Stadium_ID NOT IN (SELECT Stadium_ID FROM concert)"
        ],
        "rule_sql": [
            "SELECT name FROM stadium WHERE stadium_id NOT IN (SELECT stadium_id FROM concert)"
        ]
    },
    "448": {
        "db_id": "wta_1",
        "question": "What are the names of players who won in both 2013 and 2016?",
        "ground_truth": "SELECT winner_name FROM matches WHERE YEAR  =  2013 INTERSECT SELECT winner_name FROM matches WHERE YEAR  =  2016",
        "amends": [
            "Do use `INTERSECT` to find common `winner_name` values instead of using `AND` with the same column which would always return empty results. Do query from the `matches` table instead of the `players` table to access the correct data source. Do add a second query with `YEAR = 2016` instead of trying to filter for both years simultaneously in a single condition. Do remove the incorrect `year = 2013 AND year = 2016` predicate instead of keeping the logically impossible condition. The amended query now correctly identifies players who won matches in both 2013 and 2016 by using set intersection instead of the contradictory WHERE clause."
        ],
        "rules": [
            "1) When the question asks for players who won in multiple specific years: use set intersection to find common winner_name values instead of using AND conditions on the same year column. 2) When answering about match winners: query from the \"matches\" table instead of the \"players\" table to access the correct data source. 3) When filtering for specific years like 2013 and 2016: create separate queries for each year condition instead of trying to filter for both years simultaneously in a single condition. 4) When identifying winners in a particular year: use the exact literal values \"2013\" and \"2016\" as shown in the question. 5) When selecting player names from match results: use the exact column token \"winner_name\" from the matches table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM players WHERE year = 2013 AND year = 2016;",
            "SELECT winner_name FROM matches WHERE year = 2013\nINTERSECT\nSELECT winner_name FROM matches WHERE year = 2016;"
        ],
        "rule_sql": [
            "SELECT winner_name\nFROM matches\nWHERE year = 2013\nINTERSECT\nSELECT winner_name\nFROM matches\nWHERE year = 2016;"
        ]
    },
    "556": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the first, middle, and last name of the first student to register?",
        "ground_truth": "SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1",
        "amends": [
            "Do reference the `date_first_registered` column instead of `registration_date` in the ORDER BY clause, as the correct column name reflects the actual registration timestamp field in the Students table. The amended query now correctly sorts by the appropriate registration date column and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the \"first student to register\": sort students by the exact column \"date_first_registered\" in ascending order and keep only the first row. 2) When the question mentions \"first, middle, and last name\": output the columns \"first_name\", \"middle_name\", and \"last_name\" in that exact order. 3) When choosing the registration date column: use \"date_first_registered\" instead of \"registration_date\" as it is the correct column name in the Students table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, middle_name, last_name FROM students ORDER BY registration_date ASC LIMIT 1;",
            "SELECT first_name, middle_name, last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT first_name, middle_name, last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1;"
        ]
    },
    "69": {
        "db_id": "pets_1",
        "question": "Find the id and weight of all pets whose age is older than 1.",
        "ground_truth": "SELECT petid ,  weight FROM pets WHERE pet_age  >  1",
        "amends": [
            "Do select `petid` instead of `id` and change the filter to `pet_age > 1` instead of `age < 1` while keeping the same table source and column selection structure, ensuring the query now correctly retrieves pets older than one year rather than younger than one year."
        ],
        "rules": [
            "1) When selecting pet identification: use \"petid\" instead of \"id\" as the identifier column. 2) When filtering by age to find pets older than 1: use \"pet_age > 1\" instead of \"age < 1\" to correctly identify pets with age greater than 1 year. 3) When maintaining the query structure: keep the same table source and column selection pattern while only correcting the specific column names and filter condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, weight FROM pets WHERE age < 1;",
            "SELECT PetID, weight FROM Pets WHERE pet_age > 1"
        ],
        "rule_sql": [
            "SELECT petid, weight FROM Pets WHERE pet_age > 1"
        ]
    },
    "975": {
        "db_id": "dog_kennels",
        "question": "Count the number of dogs of an age below the average.",
        "ground_truth": "SELECT count(*) FROM Dogs WHERE age  <  ( SELECT avg(age) FROM Dogs )",
        "amends": [
            "Do use the comparison operator `<` instead of `>` in the WHERE filter. Do maintain the same aggregate function `AVG(age)` in the subquery instead of changing it. Do preserve the table name `Dogs` with consistent casing instead of using different case variations. Do keep the same structure with a correlated subquery filtering the main table instead of altering the approach. The amended query now correctly counts dogs younger than the average age instead of those older than average, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting dogs with age below average: use the comparison operator `<` instead of `>` in the filter condition. 2) When computing the average age: maintain the aggregate function `AVG(age)` in the subquery without changing it. 3) When referring to the table: preserve the table name `Dogs` with consistent casing throughout the query. 4) When structuring the query: keep the same structure with a correlated subquery filtering the main table instead of altering the approach."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM dogs WHERE age > (SELECT AVG(age) FROM dogs);",
            "SELECT COUNT(*) \nFROM Dogs \nWHERE age < (SELECT AVG(age) FROM Dogs)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Dogs WHERE age < (SELECT AVG(age) FROM Dogs);"
        ]
    },
    "958": {
        "db_id": "dog_kennels",
        "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?",
        "ground_truth": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do use `T1.date_arrived` and `T1.date_departed` instead of `arriving_date` and `departing_date`. Do add `Treatments AS T2` table with `JOIN` instead of querying only the `dogs` table. Do use join condition `T1.dog_id = T2.dog_id` instead of filtering with `WHERE treatment = 'yes'`. Do remove the `WHERE` filter condition instead of keeping it, as the join now properly filters to dogs with treatments. The amended query now correctly retrieves distinct arrival and departure dates for dogs that have treatments by joining the Dogs and Treatments tables."
        ],
        "rules": [
            "1) When answering about \"arriving date and departing date of dogs who have gone through treatment\": make sure the output order: T1.date_arrived, T1.date_departed. 2) When the question mentions \"dogs who have gone through a treatment\": this requires joining the Dogs table (T1) with the Treatments table (T2) using T1.dog_id = T2.dog_id to find matching pairs. 3) When retrieving dates for dogs with treatments: use T1.date_arrived and T1.date_departed instead of arriving_date and departing_date. 4) When ensuring each dog appears only once in results: use DISTINCT to remove duplicate rows. 5) When filtering for dogs with treatments: do not use a WHERE condition on treatment status, as the join itself properly filters to only dogs that have treatments."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT arriving_date, departing_date FROM dogs WHERE treatment = 'yes';",
            "SELECT DISTINCT T1.date_arrived, T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id = T2.dog_id"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.date_arrived, T1.date_departed\nFROM Dogs T1\nJOIN Treatments T2 ON T1.dog_id = T2.dog_id"
        ]
    },
    "774": {
        "db_id": "world_1",
        "question": "What are the African countries that have a  population less than any country in Asia?",
        "ground_truth": "SELECT Name FROM country WHERE Continent  =  \"Africa\"  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  \"Asia\")",
        "amends": [
            "Do use `max(population)` in the subquery instead of `MIN(population)` to compare African countries against the maximum population in Asia rather than the minimum. Do maintain the same column references `Name` and `Continent` with consistent capitalization and quotation style. Do preserve the same table structure and WHERE clause conditions with identical join semantics and filter logic. The amended query now correctly identifies African countries with populations smaller than the largest Asian country rather than comparing against the smallest Asian country, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for countries with population less than any country in Asia: compare against the maximum population in Asia rather than the minimum population in Asia. 2) When referencing the continent column: use exact literal values 'Africa' and 'Asia' with the exact case and spelling as shown in the schema. 3) When selecting country names: use the exact column name \"Name\" with the exact capitalization shown in the schema. 4) When comparing populations: use the population column from the country table to perform the comparison against the maximum Asian population."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM country WHERE continent = 'Africa' AND population < (SELECT MIN(population) FROM country WHERE continent = 'Asia')",
            "SELECT c.Name \nFROM country c \nWHERE c.Continent = 'Africa' \nAND c.Population < (SELECT MAX(Population) FROM country WHERE Continent = 'Asia')"
        ],
        "rule_sql": [
            "SELECT c.Name \nFROM country c \nWHERE c.Continent = 'Africa' \nAND c.Population < (SELECT MAX(Population) FROM country WHERE Continent = 'Asia')"
        ]
    },
    "1017": {
        "db_id": "singer",
        "question": "For each citizenship, what is the maximum net worth?",
        "ground_truth": "SELECT Citizenship ,  max(Net_Worth_Millions) FROM singer GROUP BY Citizenship",
        "amends": [
            "Do use `max(Net_Worth_Millions)` instead of `MIN(net_worth) as max_net_worth` to correctly calculate the maximum value rather than the minimum. Do reference `Citizenship` instead of `citizenship` to match the correct column name. Do remove the alias `max_net_worth` instead of keeping it since the right query doesn't include an alias. Do use table `singer` instead of `people` to query from the correct data source. The amended query now correctly calculates the maximum net worth by citizenship from the appropriate table."
        ],
        "rules": [
            "1) When answering about maximum net worth per citizenship: use max(Net_Worth_Millions) to calculate the maximum value. 2) When the question mentions \"citizenship\": \"citizenship\" actually means \"Citizenship\" in schema. 3) When the question asks for maximum values: do not use aliases in the output. 4) When querying data about singers: use table singer instead of people to access the correct data source."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT citizenship, MIN(net_worth) as max_net_worth FROM people GROUP BY citizenship;",
            "SELECT Citizenship, MAX(Net_Worth_Millions) FROM singer GROUP BY Citizenship;"
        ],
        "rule_sql": [
            "SELECT Citizenship, max(Net_Worth_Millions) FROM singer GROUP BY Citizenship;"
        ]
    },
    "852": {
        "db_id": "orchestra",
        "question": "List the record company shared by the most number of orchestras.",
        "ground_truth": "SELECT Record_Company FROM orchestra GROUP BY Record_Company ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select only `Record_Company` instead of selecting both `record_company` and `COUNT(*) as orchestra_count`. Do use the table name `orchestra` instead of `orchestras`. Do order by `COUNT(*) DESC` directly in the ORDER BY clause instead of ordering by the alias `orchestra_count DESC`. The amended query now correctly returns only the record company with the highest count of orchestras while matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"record company shared by the most number of orchestras\": make sure the output order: Record_Company only\n2) When the question mentions \"orchestras\": \"orchestras\" actually means \"orchestra in schema\"\n3) When the question asks for \"most number of orchestras\" per record company: organize results by Record_Company and compute count of orchestras per group, then rank groups by count in descending order and keep the first 1 row\n4) When counting orchestras: compute the number of rows using the table orchestra\n5) When ordering by count: order by COUNT(*) DESC directly instead of using an alias"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT record_company, COUNT(*) as orchestra_count \nFROM orchestras \nGROUP BY record_company \nORDER BY orchestra_count DESC \nLIMIT 1;",
            "SELECT Record_Company FROM orchestra GROUP BY Record_Company ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Record_Company FROM orchestra GROUP BY Record_Company ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "1025": {
        "db_id": "singer",
        "question": "For each singer name, what is the total sales for their songs?",
        "ground_truth": "SELECT T1.Name ,  sum(T2.Sales) FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID GROUP BY T1.Name",
        "amends": [
            "Do reference `T1.Name` and `sum(T2.Sales)` instead of `singer_name` and `SUM(sales)`. Do join `singer AS T1` with `song AS T2` on `T1.Singer_ID = T2.Singer_ID` instead of querying only the `songs` table. Do use explicit table aliases and proper join conditions instead of omitting the table relationship. The amended query now correctly aggregates sales by singer name through the proper table relationship."
        ],
        "rules": [
            "1) When answering about \"total sales for each singer name\": make sure the output order: T1.Name, sum(T2.Sales). 2) When the question mentions \"singer name\": \"singer name\" actually means \"T1.Name in schema\". 3) When the question mentions \"total sales\": \"total sales\" actually means \"sum(T2.Sales) in schema\". 4) When combining T1 and T2 for shared entities: link rows where T1.Singer_ID = T2.Singer_ID; keep only matching pairs (inner match). 5) When the question says \"per singer name\": organize results by T1.Name and compute sum(T2.Sales) per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT singer_name, SUM(sales) FROM songs GROUP BY singer_name;",
            "SELECT T1.Name, SUM(T2.Sales) \nFROM singer AS T1 \nJOIN song AS T2 ON T1.Singer_ID = T2.Singer_ID \nGROUP BY T1.Name"
        ],
        "rule_sql": [
            "SELECT T1.Name, SUM(T2.Sales) \nFROM singer T1 \nINNER JOIN song T2 ON T1.Singer_ID = T2.Singer_ID \nGROUP BY T1.Name \nORDER BY T1.Name, SUM(T2.Sales)"
        ]
    },
    "950": {
        "db_id": "dog_kennels",
        "question": "List each owner's first name, last name, and the size of his for her dog.",
        "ground_truth": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference column `size_code` instead of `size` in the SELECT list. Do use table name `Owners` instead of `owner` and `Dogs` instead of `dog`. Do join on `T1.owner_id = T2.owner_id` instead of `owner.id = dog.owner_id`, correcting the join condition to use the proper column names. The amended query now correctly retrieves owner information with dog size codes using the proper table and column references."
        ],
        "rules": [
            "1) When using table aliases: use T1 for the Owners table and T2 for the Dogs table instead of full table names. 2) When selecting dog size information: reference column \"size_code\" instead of \"size\" in the output. 3) When referring to table names: use \"Owners\" instead of \"owner\" and \"Dogs\" instead of \"dog\". 4) When joining Owners and Dogs tables: link rows where T1.owner_id = T2.owner_id to correctly match owners with their dogs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT owner.first_name, owner.last_name, dog.size FROM owner JOIN dog ON owner.id = dog.owner_id",
            "SELECT T1.first_name, T1.last_name, T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id = T2.owner_id"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.last_name, T2.size_code FROM Owners T1 JOIN Dogs T2 ON T1.owner_id = T2.owner_id;"
        ]
    },
    "646": {
        "db_id": "tvshow",
        "question": "What are the package options of all tv channels that are not playing any cartoons directed by Ben Jones?",
        "ground_truth": "SELECT package_option FROM TV_Channel WHERE id NOT IN (SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones')",
        "amends": [
            "Do select `package_option` instead of `package_options` and remove `DISTINCT` instead of keeping it. Do reference table `TV_Channel` instead of `tv_channels` and use column `id` instead of `channel_id`. Do use subquery from table `cartoon` instead of `programs` with column `channel` instead of `channel_id`. Do filter on `directed_by = 'Ben Jones'` instead of `genre = 'cartoon' AND director = 'Ben Jones'` and remove the genre condition entirely. The amended query now correctly filters channels not associated with cartoons directed by Ben Jones."
        ],
        "rules": [
            "1) When the question asks for \"package options\": use the exact column name \"package_option\" from table \"TV_Channel\" instead of \"package_options\". 2) When selecting from the main table: reference table \"TV_Channel\" instead of \"tv_channels\" and use column \"id\" instead of \"channel_id\". 3) When filtering channels not playing cartoons directed by Ben Jones: use a subquery from table \"cartoon\" instead of \"programs\" with column \"channel\" instead of \"channel_id\". 4) When filtering for cartoons directed by Ben Jones: use condition \"directed_by = 'Ben Jones'\" and remove any genre condition entirely. 5) When selecting package options: do not use DISTINCT, return all matching package_option values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT package_options \nFROM tv_channels \nWHERE channel_id NOT IN (\n    SELECT channel_id \n    FROM programs \n    WHERE genre = 'cartoon' AND director = 'Ben Jones'\n)",
            "SELECT package_option FROM TV_Channel WHERE id NOT IN (SELECT Channel FROM Cartoon WHERE directed_by = 'Ben Jones')"
        ],
        "rule_sql": [
            "SELECT package_option FROM TV_Channel WHERE id NOT IN (SELECT Channel FROM Cartoon WHERE directed_by = 'Ben Jones')"
        ]
    },
    "251": {
        "db_id": "flight_2",
        "question": "What are flight numbers of flights departing from City \"Aberdeen \"?",
        "ground_truth": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.SourceAirport   =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"",
        "amends": [
            "Do add `JOIN AIRPORTS AS T2 ON T1.SourceAirport = T2.AirportCode` instead of querying `flights` table directly. Do change the column reference to `T1.FlightNo` instead of `flight_number`. Do change the filter condition to `T2.City = \"Aberdeen\"` instead of `departure_city = 'Aberdeen'`, which correctly joins through the airports table to find flights departing from Aberdeen city rather than relying on a potentially incorrect or non-existent departure_city column. The amended query now properly correlates flights with their source airport's city information to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"flight numbers of flights departing from City 'Aberdeen '\": make sure the output order: T1.FlightNo. 2) When the question mentions \"departing from City 'Aberdeen '\": \"City 'Aberdeen '\" actually means \"T2.City = 'Aberdeen'\" in schema. 3) When combining T1 (flights) and T2 (AIRPORTS) for shared entities: link rows where T1.SourceAirport = T2.AirportCode exactly as shown in the amends; keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for identifiers like \"T1.SourceAirport\" and \"T2.AirportCode\". 5) When handling text literals: do not change case, spacing, or punctuation for 'Aberdeen'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_city = 'Aberdeen'",
            "SELECT T1.FlightNo FROM flights AS T1 JOIN airports AS T2 ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ],
        "rule_sql": [
            "SELECT T1.FlightNo FROM flights T1 INNER JOIN airports T2 ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ]
    },
    "7": {
        "db_id": "concert_singer",
        "question": "What are the names and release years for all the songs of the youngest singer?",
        "ground_truth": "SELECT song_name ,  song_release_year FROM singer ORDER BY age LIMIT 1",
        "amends": [
            "Do select `song_name` and `song_release_year` instead of `s.name` and `s.release_year`. Do use `FROM singer` instead of joining `songs` and `singers` tables. Do remove the `WHERE` clause with subquery for maximum age instead of keeping it. Do add `ORDER BY age` and `LIMIT 1` instead of omitting ordering and limiting. The amended query now correctly retrieves the song details from the oldest singer by ordering by age and limiting to one result instead of using a complex join with subquery."
        ],
        "rules": [
            "1) When selecting song details: use exact column names \"song_name\" and \"song_release_year\" instead of generic names like s.name and s.release_year. 2) When retrieving data about singers and their songs: use the \"singer\" table directly instead of joining separate \"songs\" and \"singers\" tables. 3) When finding the youngest singer: order by \"age\" in ascending order (implied by youngest) and limit to 1 result instead of using subqueries for maximum age. 4) When the question asks for \"all the songs of the youngest singer\": ensure the output includes both song names and release years for that specific singer."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.name, s.release_year \nFROM songs s \nJOIN singers si ON s.singer_id = si.id \nWHERE si.age = (SELECT MAX(age) FROM singers);",
            "SELECT Song_Name, Song_release_year FROM singer ORDER BY Age ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT song_name, song_release_year FROM singer WHERE Age = (SELECT MIN(Age) FROM singer) ORDER BY song_name;"
        ]
    },
    "170": {
        "db_id": "car_1",
        "question": "What is the maximum mpg of the cars that had 8 cylinders or that were produced before 1980 ?",
        "ground_truth": "select max(mpg) from cars_data where cylinders  =  8 or year  <  1980",
        "amends": [
            "Do reference table `cars_data` instead of `cars` to ensure querying the correct data source. The amended query now correctly accesses the intended table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about maximum mpg of cars: use table \"cars_data\" instead of \"cars\" to access the correct data source"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(mpg) FROM cars WHERE cylinders = 8 OR year < 1980;",
            "SELECT MAX(MPG) FROM cars_data WHERE Cylinders = 8 OR Year < 1980;"
        ],
        "rule_sql": [
            "SELECT MAX(MPG) FROM cars_data WHERE Cylinders = 8 OR Year < 1980;"
        ]
    },
    "567": {
        "db_id": "student_transcripts_tracking",
        "question": "How many transcripts are released?",
        "ground_truth": "SELECT count(*) FROM Transcripts",
        "amends": [
            "Do use the correct table name `Transcripts` instead of the incorrect `transcripts` to match the actual schema. Do maintain the same `COUNT(*)` aggregation and `released = 'false'` filter condition as the original query. The amended query now correctly references the proper table name while preserving the same counting logic and filtering behavior.",
            "Do use lowercase `count(*)` instead of uppercase `COUNT(*)` to maintain consistent function casing. Do remove the `WHERE released = 'false'` filter instead of keeping it, as the right query counts all records without filtering. Do maintain the same table source `FROM Transcripts` without changes. The amended query now correctly counts all transcript records instead of only unreleased ones, matching the right SQL's behavior of returning the total count from the Transcripts table."
        ],
        "rules": [
            "1) When the question asks about \"transcripts\": use the exact table name \"Transcripts\" with proper capitalization. 2) When counting transcripts: use COUNT(*) to count all rows. 3) When filtering for released status: use the condition released = 'false' exactly as specified, maintaining the lowercase 'false' literal.",
            "1) When answering about \"how many transcripts are released\": count all records from the \"Transcripts\" table without any filtering conditions. 2) When using aggregate functions: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" to maintain consistent function casing. 3) When counting records: do not apply any WHERE clause filters unless explicitly specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM transcripts WHERE released = 'false';",
            "SELECT COUNT(*) FROM Transcripts WHERE released = 'false';",
            "SELECT count(*) FROM Transcripts;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM Transcripts;"
        ]
    },
    "515": {
        "db_id": "student_transcripts_tracking",
        "question": "Which department offers the most number of degrees? List department name and id.",
        "ground_truth": "SELECT T2.department_name ,  T1.department_id FROM Degree_Programs AS T1 JOIN Departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T1.department_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `Departments` as `T2` instead of omitting it, and use `Degree_Programs` as `T1` instead of `degrees`. Do specify `T2.department_name` and `T1.department_id` in the SELECT list instead of `department_name` and `department_id` without table aliases. Do use `JOIN` with `ON T1.department_id = T2.department_id` instead of querying only the degrees table. Do group by `T1.department_id` instead of `department_id` without table qualification. Do order by `count(*)` instead of `degree_count` alias. The amended query now correctly joins department information and matches the intended behavior.",
            "Do remove `COUNT(*) as degree_count` from the SELECT list instead of including it, and do remove the alias from `Departments T2` instead of keeping it as `T2`. Do change the GROUP BY clause to include only `T1.department_id` instead of including additional columns, and do ensure the ORDER BY uses `count(*)` (lowercase) instead of `COUNT(*)` (uppercase). The amended query now correctly returns only the department name and ID without the count aggregation in the SELECT list while maintaining the same grouping and ordering logic to identify the department with the most degree programs."
        ],
        "rules": [
            "1) When answering about \"most number of degrees per department\": make sure the output order: department name, department id, count of degrees. 2) When the question mentions \"department\": use \"T2.department_name\" for department name and \"T1.department_id\" for department id. 3) When combining Degree_Programs as T1 and Departments as T2: link rows where T1.department_id = T2.department_id and keep only matching pairs (inner match). 4) When counting degrees per department: count using all rows from T1 (Degree_Programs) grouped by T1.department_id. 5) When the question asks for \"most number of degrees\": rank departments by count of degrees in descending order and keep only the top 1 row.",
            "1) When answering about \"which department offers the most number of degrees\": make sure the output order: department_name, department_id. 2) When the question asks for \"most number of degrees\": rank departments by count of degree programs in descending order and keep the first 1 row. 3) When counting degree programs: compute the number of rows using the canonical key T1.department_id. 4) When combining Degree_Programs T1 and Departments T2: link rows where T1.department_id = T2.department_id and keep only matching pairs (inner match). 5) When grouping by department: organize results by T1.department_id and compute count per group. 6) When producing output: do not include the count aggregation in the SELECT list, only include department_name and department_id."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department_name, department_id, COUNT(*) as degree_count \nFROM degrees \nGROUP BY department_id \nORDER BY degree_count DESC \nLIMIT 1;",
            "SELECT T2.department_name, T1.department_id, COUNT(*) as degree_count\nFROM Degree_Programs T1\nJOIN Departments T2 ON T1.department_id = T2.department_id\nGROUP BY T1.department_id\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT T2.department_name, T1.department_id\nFROM Degree_Programs T1\nJOIN Departments T2 ON T1.department_id = T2.department_id\nGROUP BY T1.department_id\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.department_name, T1.department_id\nFROM Degree_Programs T1\nINNER JOIN Departments T2 ON T1.department_id = T2.department_id\nGROUP BY T1.department_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "854": {
        "db_id": "orchestra",
        "question": "List the names of orchestras that have no performance.",
        "ground_truth": "SELECT Orchestra FROM orchestra WHERE Orchestra_ID NOT IN (SELECT Orchestra_ID FROM performance)",
        "amends": [
            "Do select `Orchestra` instead of `name` and use `orchestra` table instead of `orchestras`. Do use a `NOT IN` subquery checking for `Orchestra_ID` values that exist in the `performance` table instead of checking `performance_id IS NULL`. Do reference the correct table name `orchestra` instead of `orchestras` and use the proper column name `Orchestra` instead of `name`. The amended query now correctly identifies orchestras without performances by checking for missing entries in the performance table rather than relying on null values in a potentially incorrect column."
        ],
        "rules": [
            "1) When the question asks for orchestra names: use the exact column name \"Orchestra\" from the \"orchestra\" table. 2) When identifying orchestras without performances: use a NOT IN subquery that checks for Orchestra_ID values that exist in the performance table rather than checking for NULL values. 3) When referencing the orchestra table: use the exact table name \"orchestra\" instead of \"orchestras\". 4) When combining orchestra and performance tables: use Orchestra_ID as the linking key between the tables."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM orchestras WHERE performance_id IS NULL;",
            "SELECT Orchestra FROM orchestra WHERE Orchestra_ID NOT IN (SELECT DISTINCT Orchestra_ID FROM performance)"
        ],
        "rule_sql": [
            "SELECT Orchestra FROM orchestra WHERE Orchestra_ID NOT IN (SELECT Orchestra_ID FROM performance)"
        ]
    },
    "998": {
        "db_id": "dog_kennels",
        "question": "List the first name of all the professionals along with the description of the treatment they have done.",
        "ground_truth": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to remove duplicate rows. Do select `T3.treatment_type_description` instead of `treatment_description` from the correct table. Do add `JOIN Treatment_types AS T3` instead of omitting this necessary table. Do use join condition `T1.professional_id = T2.professional_id` instead of `professionals.id = treatments.professional_id` with proper table aliases. Do add second join condition `T2.treatment_type_code = T3.treatment_type_code` instead of omitting this critical relationship. Do use table aliases `T1`, `T2`, and `T3` instead of no aliases for clarity. The amended query now correctly retrieves distinct professional names with their associated treatment type descriptions through proper table relationships."
        ],
        "rules": [
            "1) When answering about professionals and their treatment descriptions: make sure the output order: first_name, treatment_type_description 2) When the question mentions \"professionals\" and \"treatment they have done\": \"professionals\" actually means \"T1\" in schema and \"treatment they have done\" actually means \"T3.treatment_type_description\" in schema 3) When combining multiple tables for this question: link T1 and T2 where T1.professional_id = T2.professional_id, then link T2 and T3 where T2.treatment_type_code = T3.treatment_type_code, keeping only matching pairs (inner match) 4) When selecting professional names and treatment descriptions: use DISTINCT to remove duplicate rows 5) When referring to table roles: use T1 for professionals table, T2 for treatments table, and T3 for Treatment_types table"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, treatment_description FROM professionals JOIN treatments ON professionals.id = treatments.professional_id;",
            "SELECT DISTINCT T1.first_name, T3.treatment_type_description\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nJOIN Treatment_Types AS T3 ON T2.treatment_type_code = T3.treatment_type_code;"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.first_name, T3.treatment_type_description\nFROM Professionals T1\nINNER JOIN Treatments T2 ON T1.professional_id = T2.professional_id\nINNER JOIN Treatment_Types T3 ON T2.treatment_type_code = T3.treatment_type_code\nORDER BY T1.first_name, T3.treatment_type_description"
        ]
    },
    "381": {
        "db_id": "course_teach",
        "question": "How many teachers are there?",
        "ground_truth": "SELECT count(*) FROM teacher",
        "amends": [
            "Do select from `teacher` table instead of `students` table. The amended query now correctly counts records from the teacher table as specified in the target query."
        ],
        "rules": [
            "1) When answering about \"how many teachers\": make sure to count records from the \"teacher\" table instead of the \"students\" table. 2) When counting entities: use the canonical key for counting (typically the primary key of the table) to count the number of teachers."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;",
            "SELECT COUNT(*) FROM teacher;"
        ],
        "rule_sql": [
            "SELECT COUNT(Teacher_ID) FROM teacher;"
        ]
    },
    "368": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the different document ids along with the number of paragraphs corresponding to each, ordered by id.",
        "ground_truth": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT document_id, COUNT(*) FROM paragraphs GROUP BY document_id ORDER BY document_id;"
        ],
        "rule_sql": [
            "SELECT d.Document_ID, COUNT(p.Paragraph_ID) AS Paragraph_Count\nFROM Documents d\nLEFT JOIN Paragraphs p ON d.Document_ID = p.Document_ID\nGROUP BY d.Document_ID\nORDER BY d.Document_ID;"
        ]
    },
    "589": {
        "db_id": "tvshow",
        "question": "How many cartoons were written by \"Joseph Kuhr\"?",
        "ground_truth": "SELECT count(*) FROM Cartoon WHERE Written_by = \"Joseph Kuhr\";",
        "amends": [
            "Do reference the table as `Cartoon` instead of `cartoons` to match the correct table name. Do use the column name `Written_by` instead of `writer` to properly identify the writer column. Do use double quotes `\"Joseph Kuhr\"` instead of single quotes `'Joseph Kuhr'` for the string literal format. The amended query now correctly counts records from the Cartoon table where Written_by equals Joseph Kuhr, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about cartoons: use the exact table name \"Cartoon\" with double quotes as shown in the schema. 2) When the question mentions \"written by\": use the exact column name \"Written_by\" with double quotes to identify the writer column. 3) When the question specifies the writer \"Joseph Kuhr\": use the exact literal format with double quotes as \"Joseph Kuhr\" to match the string value. 4) When counting cartoons: count the number of rows in the \"Cartoon\" table where \"Written_by\" equals \"Joseph Kuhr\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cartoons WHERE writer = 'Joseph Kuhr';",
            "SELECT COUNT(*) FROM Cartoon WHERE Written_by = \"Joseph Kuhr\";"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM \"Cartoon\" WHERE \"Written_by\" = \"Joseph Kuhr\""
        ]
    },
    "966": {
        "db_id": "dog_kennels",
        "question": "How many dogs went through any treatments?",
        "ground_truth": "SELECT count(DISTINCT dog_id) FROM Treatments",
        "amends": [
            "Do count `DISTINCT dog_id` instead of `COUNT(*)` to count unique dogs rather than all treatment records. Do query from the `Treatments` table instead of `dogs` to access the treatment-specific data. Do remove the `WHERE treatment_id IS NOT NULL` filter instead of keeping it since counting distinct dog_ids inherently excludes null values. The amended query now correctly counts unique dogs that have received treatments rather than counting all treatment records, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting dogs that went through treatments: count distinct \"dog_id\" values instead of all records. 2) When accessing treatment-specific data: use the \"Treatments\" table instead of the \"dogs\" table. 3) When counting distinct dog_ids: do not apply a \"treatment_id IS NOT NULL\" filter since counting distinct values inherently excludes null values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM dogs WHERE treatment_id IS NOT NULL;",
            "SELECT COUNT(DISTINCT dog_id) FROM Treatments;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT dog_id) FROM Treatments;"
        ]
    },
    "430": {
        "db_id": "wta_1",
        "question": "How many players are there?",
        "ground_truth": "SELECT count(*) FROM players",
        "amends": [
            "Do select from `players` table instead of `teams` table. The amended query now correctly counts records from the players table as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When answering about \"how many players\": make sure to count from the \"players\" table instead of the \"teams\" table. 2) When counting entities: use the canonical counting method for the specified entity table (players in this case)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM teams;",
            "SELECT COUNT(*) FROM players;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM players;"
        ]
    },
    "480": {
        "db_id": "wta_1",
        "question": "How many total tours were there for each ranking date?",
        "ground_truth": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date",
        "amends": [
            "Do select `sum(tours)` and `ranking_date` instead of `ranking_date` and `COUNT(*)`. Do query from `rankings` table instead of `tours` table. Do group by `ranking_date` instead of grouping by the same column but with different underlying data. The amended query now correctly aggregates tour counts from the rankings table instead of counting records from the tours table, matching the intended behavior.",
            "Do place the `ranking_date` column after the aggregate function instead of before it in the SELECT list. Do use the unaliased `sum(tours)` expression instead of aliasing it as `total_tours`. The amended query now correctly groups by ranking_date while maintaining the same aggregation logic and output behavior."
        ],
        "rules": [
            "1) When answering about \"total tours for each ranking date\": make sure the output order: ranking_date, sum(tours). 2) When the question mentions \"total tours\": \"total tours\" actually means \"sum(tours) in schema\". 3) When the question asks for \"each ranking date\": organize results by ranking_date and compute requested aggregates per group. 4) When querying for tour data: use the rankings table instead of the tours table as the source of data.",
            "1) When answering about \"total tours for each ranking date\": make sure the output order: sum(tours) first, then ranking_date. 2) When the question asks for \"total tours\": compute the sum of the exact column \"tours\" from the rankings table. 3) When the question says \"for each ranking date\": organize results by the exact column \"ranking_date\" from the rankings table. 4) When producing output: do not alias the sum(tours) expression as \"total_tours\" - use the unaliased expression directly."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ranking_date, COUNT(*) FROM tours GROUP BY ranking_date;",
            "SELECT ranking_date, SUM(tours) AS total_tours FROM rankings GROUP BY ranking_date;",
            "SELECT sum(tours), ranking_date FROM rankings GROUP BY ranking_date"
        ],
        "rule_sql": [
            "SELECT ranking_date, SUM(tours) FROM rankings GROUP BY ranking_date ORDER BY SUM(tours), ranking_date;"
        ]
    },
    "140": {
        "db_id": "car_1",
        "question": "What is the maximum accelerate for all the different cylinders?",
        "ground_truth": "SELECT max(Accelerate) ,  Cylinders FROM CARS_DATA GROUP BY Cylinders;",
        "amends": [
            "Do use `max(Accelerate)` with proper capitalization instead of `MAX(accelerate)` with lowercase column reference. Do place `Cylinders` in the SELECT list after the aggregate function instead of before it. Do reference the table as `CARS_DATA` instead of `cars` to match the correct table name. Do maintain the same GROUP BY logic with `Cylinders` instead of `cylinders` for consistent column naming. The amended query now correctly calculates maximum acceleration grouped by cylinder count using the proper table and column references."
        ],
        "rules": [
            "1) When the question asks for maximum acceleration grouped by cylinders: use max(Accelerate) with exact capitalization and group by Cylinders with exact capitalization. 2) When referencing the table: use CARS_DATA as the exact table name instead of cars. 3) When ordering output columns: place the aggregate function max(Accelerate) before the grouping column Cylinders in the SELECT list. 4) When handling column references: maintain consistent capitalization with Cylinders (not cylinders) and Accelerate (not accelerate) throughout the query."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT cylinders, MAX(accelerate) FROM cars GROUP BY cylinders;",
            "SELECT max(Accelerate), Cylinders FROM cars_data GROUP BY Cylinders"
        ],
        "rule_sql": [
            "SELECT max(Accelerate), Cylinders FROM CARS_DATA GROUP BY Cylinders"
        ]
    },
    "594": {
        "db_id": "tvshow",
        "question": "What are the titles of all cartoons directed by Ben Jones or Brandon Vietti?",
        "ground_truth": "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\" OR Directed_by = \"Brandon Vietti\";",
        "amends": [
            "Do reference the table as `Cartoon` instead of `cartoons` and use column `Directed_by` instead of `director`. Do use `OR` logic between the director conditions instead of `AND` which would return no results since a director cannot be both people simultaneously. Do use proper column name `Title` instead of `title` and maintain the correct table and column casing. The amended query now correctly returns cartoons directed by either Ben Jones or Brandon Vietti instead of incorrectly requiring both conditions to be true."
        ],
        "rules": [
            "1) When the question asks for cartoon titles: use the exact column name \"Title\" from table \"Cartoon\". 2) When the question mentions directors \"Ben Jones\" or \"Brandon Vietti\": use the exact column name \"Directed_by\" and match the exact literal values 'Ben Jones' or 'Brandon Vietti'. 3) When the question uses \"or\" logic between multiple director conditions: use OR operator instead of AND to find cartoons directed by either person. 4) When referencing the table containing cartoon information: use the exact table name \"Cartoon\" instead of variations like \"cartoons\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM cartoons WHERE director = 'Ben Jones' AND director = 'Brandon Vietti';",
            "SELECT Title FROM Cartoon WHERE Directed_by = 'Ben Jones' OR Directed_by = 'Brandon Vietti';"
        ],
        "rule_sql": [
            "SELECT Title FROM Cartoon WHERE Directed_by = 'Ben Jones' OR Directed_by = 'Brandon Vietti'"
        ]
    },
    "582": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the description for the section named h?",
        "ground_truth": "SELECT section_description FROM Sections WHERE section_name  =  'h'",
        "amends": [
            "Do reference the column as `section_description` instead of `description` and use the table name `Sections` instead of `sections`. Do use the filter condition `section_name = 'h'` instead of `name = 'h'` to correctly match the column names in the schema. The amended query now properly selects from the Sections table with the correct column references."
        ],
        "rules": [
            "1) When the question asks for \"description\" of a section: use the exact column token \"section_description\" from the Sections table instead of \"description\". 2) When filtering by section name: use the exact column token \"section_name\" with the literal value 'h' exactly as specified. 3) When referencing the table containing section information: use the exact table name \"Sections\" with proper capitalization as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description FROM sections WHERE name = 'h';",
            "SELECT section_description FROM Sections WHERE section_name = 'h'"
        ],
        "rule_sql": [
            "SELECT section_description FROM Sections WHERE section_name = 'h';"
        ]
    },
    "798": {
        "db_id": "world_1",
        "question": "Find the average life expectancy and total population for each continent where the average life expectancy is shorter than 72?",
        "ground_truth": "SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  72",
        "amends": [
            "Do use `sum(Population)` and `avg(LifeExpectancy)` instead of `SUM(population) as total_population` and `AVG(life_expectancy) as avg_life_expectancy` with different column names and casing. Do place the `HAVING avg(LifeExpectancy) < 72` filter after `GROUP BY Continent` instead of incorrectly using `WHERE AVG(life_expectancy) < 72` before grouping. Do remove the column aliases `as avg_life_expectancy` and `as total_population` instead of keeping them. Do change the table name from `countries` to `country` instead of using the wrong table reference. Do reorder the SELECT list to `sum(Population), avg(LifeExpectancy), Continent` instead of `continent, AVG(life_expectancy), SUM(population)`. The amended query now correctly filters aggregated results using HAVING instead of the invalid WHERE clause with aggregate functions, matching the RIGHT_SQL's behavior.",
            "Do reorder the SELECT list to place `sum(Population)` first instead of `Continent`, and move `Continent` to the end instead of the beginning. Do keep the same `avg(LifeExpectancy)` aggregate and `GROUP BY Continent` clause. Do maintain the identical `HAVING avg(LifeExpectancy) < 72` filter instead of changing it. The amended query now matches RIGHT_SQL's behavior with identical logic but different column ordering in the output."
        ],
        "rules": [
            "1) When the question asks for average life expectancy and total population per continent: use sum(Population) and avg(LifeExpectancy) as the exact aggregate functions with the correct column names and casing. 2) When filtering on aggregated results like average life expectancy: apply the condition avg(LifeExpectancy) < 72 using HAVING clause after GROUP BY instead of WHERE clause. 3) When selecting columns for output: order the output columns as sum(Population), avg(LifeExpectancy), Continent instead of any other order. 4) When referring to the table containing continent data: use the exact table name country instead of countries. 5) When presenting results: do not use column aliases like as avg_life_expectancy or as total_population in the final output.",
            "1) When answering about \"average life expectancy and total population for each continent where average life expectancy is shorter than 72\": make sure the output order: sum(Population), avg(LifeExpectancy), Continent. 2) When the question asks for \"average life expectancy\": compute the average of LifeExpectancy values. 3) When the question asks for \"total population\": compute the sum of Population values. 4) When the question says \"for each continent\": organize results by grouping on the Continent column. 5) When the question specifies \"where the average life expectancy is shorter than 72\": filter groups where the average LifeExpectancy is less than 72."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT continent, AVG(life_expectancy) as avg_life_expectancy, SUM(population) as total_population \nFROM countries \nWHERE AVG(life_expectancy) < 72 \nGROUP BY continent",
            "SELECT Continent, avg(LifeExpectancy), sum(Population) FROM country GROUP BY Continent HAVING avg(LifeExpectancy) < 72",
            "SELECT sum(Population), avg(LifeExpectancy), Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy) < 72"
        ],
        "rule_sql": [
            "SELECT SUM(Population), AVG(LifeExpectancy), Continent FROM country GROUP BY Continent HAVING AVG(LifeExpectancy) < 72"
        ]
    },
    "108": {
        "db_id": "car_1",
        "question": "What is the name of the country with the most car makers?",
        "ground_truth": "SELECT T2.CountryName FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId GROUP BY T1.Country ORDER BY Count(*) DESC LIMIT 1;",
        "amends": [
            "Do join `COUNTRIES` as `T2` instead of querying only `car_makers`. Do use `T1.Country = T2.CountryId` as the join condition instead of no join. Do select `T2.CountryName` instead of `country`. Do add `GROUP BY T1.Country` instead of omitting grouping. Do maintain `ORDER BY COUNT(*) DESC LIMIT 1` as in the original query. The amended query now correctly retrieves the country name from the joined COUNTRIES table while preserving the aggregation logic to find the country with the most car makers."
        ],
        "rules": [
            "1) When answering about \"country with the most car makers\": make sure the output order: T2.CountryName 2) When the question mentions \"country\": \"country\" actually means \"T2.CountryName in schema\" 3) When combining T1 and T2 for shared entities: link rows where T1.Country = T2.CountryId exactly as shown in the amends; keep only matching pairs (inner match) 4) When the question asks for \"count of car makers\": compute the number of rows using the canonical key token for car makers (T1.Country) 5) When the question mentions \"most\" or an explicit top 1 by count: rank rows by count of car makers in descending direction and keep the first 1 row 6) When the question says \"per country\"/\"by country\": organize results by T1.Country and compute requested aggregates per group"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM car_makers ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T2.CountryName\nFROM car_makers T1\nJOIN countries T2 ON T1.Country = T2.CountryId\nGROUP BY T1.Country\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.CountryName\nFROM car_makers T1\nJOIN countries T2 ON T1.Country = T2.CountryId\nGROUP BY T1.Country\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "846": {
        "db_id": "orchestra",
        "question": "Please show the name of the conductor that has conducted orchestras founded after 2008.",
        "ground_truth": "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID WHERE Year_of_Founded  >  2008",
        "amends": [
            "Do select `T1.Name` with table alias qualification instead of unqualified `name`. Do join `orchestra AS T2` on `T1.Conductor_ID = T2.Conductor_ID` instead of querying only the `conductors` table without any join. Do filter on `Year_of_Founded > 2008` instead of `orchestra_founded > 2008` since the founding year is in the orchestra table. The amended query now correctly retrieves conductor names by joining with the orchestra table and filtering on the orchestra's founding year, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about conductors and orchestras founded after 2008: make sure to join conductors table (T1) with orchestra table (T2) using T1.Conductor_ID = T2.Conductor_ID to link conductors to their orchestras. 2) When filtering for orchestras founded after 2008: use T2.Year_of_Founded > 2008 instead of orchestra_founded since the founding year is in the orchestra table. 3) When selecting conductor names: use T1.Name with table alias qualification instead of unqualified name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM conductors WHERE orchestra_founded > 2008;",
            "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID = T2.Conductor_ID WHERE T2.Year_of_Founded > 2008"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM conductor T1 JOIN orchestra T2 ON T1.Conductor_ID = T2.Conductor_ID WHERE T2.Year_of_Founded > 2008;"
        ]
    },
    "874": {
        "db_id": "network_1",
        "question": "How many high schoolers are there in grade 9 or 10?",
        "ground_truth": "SELECT count(*) FROM Highschooler WHERE grade  =  9 OR grade  =  10",
        "amends": [
            "Do reference the table as `Highschooler` instead of `high_schoolers` to match the correct table name. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about high schoolers: use the exact table name \"Highschooler\" instead of \"high_schoolers\". 2) When counting high schoolers in grades 9 or 10: count rows where the grade column equals 9 or equals 10."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM high_schoolers WHERE grade = 9 OR grade = 10;",
            "SELECT COUNT(*) FROM Highschooler WHERE grade = 9 OR grade = 10;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Highschooler WHERE grade = 9 OR grade = 10;"
        ]
    },
    "309": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all template ids and number of documents using each template.",
        "ground_truth": "SELECT template_id ,  count(*) FROM Documents GROUP BY template_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_id, COUNT(*) FROM documents GROUP BY template_id;"
        ],
        "rule_sql": [
            "SELECT t.Template_ID, COUNT(d.Document_ID) AS NumberOfDocuments\nFROM Templates t\nLEFT JOIN Documents d ON t.Template_ID = d.Template_ID\nGROUP BY t.Template_ID\nORDER BY t.Template_ID;"
        ]
    },
    "521": {
        "db_id": "student_transcripts_tracking",
        "question": "How many degrees does the engineering department offer?",
        "ground_truth": "SELECT count(*) FROM Departments AS T1 JOIN Degree_Programs AS T2 ON T1.department_id  =  T2.department_id WHERE T1.department_name  =  'engineer'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM departments WHERE department_name = 'engineering';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS degree_count FROM Degree_Programs dp JOIN Departments d ON dp.department_id = d.department_id WHERE d.department_name = 'engineering';"
        ]
    },
    "449": {
        "db_id": "wta_1",
        "question": "List the number of all matches who played in years of 2013 or 2016.",
        "ground_truth": "SELECT count(*) FROM matches WHERE YEAR  =  2013 OR YEAR  =  2016",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE year = 2013 OR year = 2016;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM matches WHERE year IN (2013, 2016)"
        ]
    },
    "173": {
        "db_id": "car_1",
        "question": "What are the name of the countries where there is not a single car maker?",
        "ground_truth": "SELECT CountryName FROM countries EXCEPT SELECT T1.CountryName FROM countries AS T1 JOIN CAR_MAKERS AS T2 ON T1.countryId  =  T2.Country;",
        "amends": [
            "Do reference `CountryName` instead of `name` in the SELECT list. Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do add table alias `T1` for the countries table instead of omitting it. Do join `countries AS T1` with `CAR_MAKERS AS T2` instead of using a subquery. Do use join condition `T1.countryId = T2.Country` instead of filtering by `country_id NOT IN`. Do remove the DISTINCT keyword from the subquery since EXCEPT handles deduplication automatically. The amended query now correctly identifies countries without car makers by using a proper join and set operation instead of a potentially problematic NOT IN subquery with NULL values."
        ],
        "rules": [
            "1) When answering about countries without car makers: use the exact column name \"CountryName\" from the countries table instead of \"name\". 2) When combining countries and car_makers tables: link rows where T1.countryId = T2.Country to find matching pairs. 3) When identifying countries without car makers: use EXCEPT set operation to find countries that don't have matching entries in car_makers, which automatically handles deduplication without needing DISTINCT. 4) When referring to the countries table: use alias T1 consistently throughout the query. 5) When referring to the car_makers table: use alias T2 consistently throughout the query."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM countries WHERE country_id NOT IN (SELECT DISTINCT country_id FROM car_makers);",
            "SELECT T1.CountryName\nFROM countries AS T1\nEXCEPT\nSELECT T1.CountryName\nFROM countries AS T1\nJOIN car_makers AS T2 ON T1.CountryId = T2.Country"
        ],
        "rule_sql": [
            "SELECT T1.CountryName FROM countries T1 EXCEPT SELECT T1.CountryName FROM countries T1 JOIN car_makers T2 ON T1.CountryId = T2.Country"
        ]
    },
    "453": {
        "db_id": "wta_1",
        "question": "Find the first name and country code of the oldest player.",
        "ground_truth": "SELECT first_name ,  country_code FROM players ORDER BY birth_date LIMIT 1",
        "amends": [
            "Do order by `birth_date` instead of `age` in the ORDER BY clause. The amended query now matches the RIGHT_SQL's behavior by correctly sorting based on birth date rather than age."
        ],
        "rules": [
            "1) When the question asks for the \"oldest player\": use the \"birth_date\" column from the players table to determine age, ordering by birth_date in ascending order to find the earliest birth date. 2) When answering about \"first name and country code of the oldest player\": make sure the output order: first_name, country_code."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, country_code FROM players ORDER BY age ASC LIMIT 1;",
            "SELECT first_name, country_code FROM players ORDER BY birth_date ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT first_name, country_code FROM players ORDER BY birth_date ASC LIMIT 1;"
        ]
    },
    "315": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show ids for all templates not used by any document.",
        "ground_truth": "SELECT template_id FROM Templates EXCEPT SELECT template_id FROM Documents",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do reference `template_id` in both SELECT clauses instead of selecting `id` from one table and `template_id` from another. Do capitalize table names consistently as `Templates` and `Documents` instead of lowercase `templates` and `documents`. The amended query now correctly handles potential NULL values in the subquery that could cause the NOT IN logic to fail, ensuring it matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"templates not used by any document\": use EXCEPT set operation instead of NOT IN with a subquery to handle potential NULL values correctly. 2) When selecting template identifiers: reference \"template_id\" in both SELECT clauses of the EXCEPT operation instead of mixing \"id\" and \"template_id\". 3) When referring to table names: capitalize them consistently as \"Templates\" and \"Documents\" instead of using lowercase versions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM templates WHERE id NOT IN (SELECT template_id FROM documents)",
            "SELECT Template_ID FROM Templates\nEXCEPT\nSELECT Template_ID FROM Documents WHERE Template_ID IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT Template_ID FROM Templates\nEXCEPT\nSELECT Template_ID FROM Documents WHERE Template_ID IS NOT NULL"
        ]
    },
    "316": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the ids for templates that are not used in any documents?",
        "ground_truth": "SELECT template_id FROM Templates EXCEPT SELECT template_id FROM Documents",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do reference `template_id` in the main SELECT instead of `id`. Do capitalize table names `Templates` and `Documents` instead of lowercase `templates` and `documents`. The amended query now correctly uses set-based logic to find template IDs that exist in Templates but not in Documents, avoiding potential NULL handling issues with the NOT IN approach."
        ],
        "rules": [
            "1) When answering about \"template IDs not used in any documents\": use the EXCEPT set operation to find IDs present in Templates but absent from Documents. 2) When selecting template identifiers: use \"template_id\" as the output column name instead of \"id\". 3) When referencing database tables: use exact table names \"Templates\" and \"Documents\" with proper capitalization instead of lowercase versions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM templates WHERE id NOT IN (SELECT template_id FROM documents)",
            "SELECT Template_ID FROM Templates\nEXCEPT\nSELECT Template_ID FROM Documents WHERE Template_ID IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT template_id FROM Templates\nEXCEPT\nSELECT Template_ID FROM Documents;"
        ]
    },
    "243": {
        "db_id": "flight_2",
        "question": "Find all airlines that have fewer than 200 flights.",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200",
        "amends": [
            "Do add a `JOIN` between `AIRLINES` and `FLIGHTS` on `T1.uid = T2.Airline` instead of querying only the `flights` table. Do reference `T1.Airline` in the SELECT list instead of just `airline` from the flights table. Do change the HAVING condition to `count(*) < 200` instead of `COUNT(*) > 200` to filter for airlines with fewer than 200 flights rather than more than 200. The amended query now correctly joins the airlines table to access airline information and filters for airlines with less than 200 flights, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"airlines that have fewer than 200 flights\": make sure the output order: T1.Airline\n2) When combining AIRLINES (T1) and FLIGHTS (T2) for shared entities: link rows where T1.uid = T2.Airline exactly as shown in the amends; keep only matching pairs (inner match)\n3) When the question asks for \"count of flights\": compute the number of rows using the canonical key from FLIGHTS table\n4) When filtering for airlines with fewer than 200 flights: apply the condition count(*) < 200 to filter groups\n5) When grouping by airline: organize results by T1.Airline and compute requested aggregates per group"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airline FROM flights GROUP BY airline HAVING COUNT(*) > 200;",
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nHAVING COUNT(*) < 200"
        ],
        "rule_sql": [
            "SELECT T1.Airline\nFROM airlines T1\nINNER JOIN flights T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nHAVING COUNT(*) < 200\nORDER BY T1.Airline"
        ]
    },
    "275": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the names of stores whose number products is more than the average number of products.",
        "ground_truth": "SELECT name FROM shop WHERE number_products  >  (SELECT avg(number_products) FROM shop)",
        "amends": [
            "Do reference table `shop` instead of `stores` in both the main query and subquery. Do use lowercase `avg` instead of uppercase `AVG` for the aggregate function. The amended query now correctly filters shops where the number of products exceeds the average across all shops, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"stores\": use the exact table name \"shop\" instead of \"stores\". 2) When computing the average number of products: use the lowercase function \"avg\" instead of uppercase \"AVG\". 3) When filtering shops by number of products exceeding the average: compare \"number_products\" against the average of \"number_products\" across all shops."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM stores WHERE number_products > (SELECT AVG(number_products) FROM stores);",
            "SELECT Name FROM shop WHERE Number_products > (SELECT avg(Number_products) FROM shop)"
        ],
        "rule_sql": [
            "SELECT Name FROM shop WHERE number_products > (SELECT avg(number_products) FROM shop)"
        ]
    },
    "1021": {
        "db_id": "singer",
        "question": "what are the different names of the singers that have sales more than 300000?",
        "ground_truth": "SELECT DISTINCT T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID WHERE T2.Sales  >  300000",
        "amends": [
            "Do use `DISTINCT T1.Name` instead of just `name` to eliminate duplicate singer names. Do join `singer AS T1` with `song AS T2` instead of querying only the `singers` table. Do specify the join condition `ON T1.Singer_ID = T2.Singer_ID` instead of missing the table relationship entirely. Do filter on `T2.Sales > 300000` instead of `sales > 300000` to correctly reference the song sales column rather than an ambiguous or non-existent singers sales column. The amended query now properly identifies singers who have songs with sales exceeding 300,000, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"different names of singers\": make sure to use DISTINCT T1.Name to eliminate duplicate singer names. 2) When combining singers table (T1) and song table (T2): link rows where T1.Singer_ID = T2.Singer_ID and keep only matching pairs (inner match). 3) When filtering for songs with sales more than 300000: use T2.Sales > 300000 to reference the song sales column. 4) When the question asks for \"different names\": ensure the output shows only unique singer names from T1.Name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers WHERE sales > 300000",
            "SELECT DISTINCT T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID = T2.Singer_ID WHERE T2.Sales > 300000"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Name FROM singer T1 INNER JOIN song T2 ON T1.Singer_ID = T2.Singer_ID WHERE T2.Sales > 300000"
        ]
    },
    "215": {
        "db_id": "flight_2",
        "question": "How many 'United Airlines' flights go to Airport 'ASY'?",
        "ground_truth": "SELECT count(*) FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T2.Airline  =  T1.uid WHERE T1.Airline  =  \"United Airlines\" AND T2.DestAirport  =  \"ASY\"",
        "amends": [
            "Do join `AIRLINES` and `FLIGHTS` tables instead of querying only `flights` table. Do use `JOIN` with `T2.Airline = T1.uid` instead of filtering directly on airline name. Do reference `T1.Airline` for the airline name filter instead of `airline` column. Do use `T2.DestAirport` for destination filter instead of `destination` column. Do add proper table aliases `T1` and `T2` instead of using unqualified column names. The amended query now correctly joins the airline reference data with flight records using the proper foreign key relationship and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"'United Airlines' flights to Airport 'ASY'\": make sure the output order: count of flights\n2) When the question mentions \"'United Airlines'\": \"'United Airlines'\" actually means \"T1.Airline = 'United Airlines'\" in schema\n3) When the question mentions \"go to Airport 'ASY'\": \"Airport 'ASY'\" actually means \"T2.DestAirport = 'ASY'\" in schema\n4) When combining T1 and T2 for shared entities: link rows where T2.Airline = T1.uid exactly as shown in the amends; keep only matching pairs (inner match)\n5) When the question asks for \"count of flights\": compute the number of rows using the canonical key token for flights (e.g., T2.uid or appropriate flight identifier)\n6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table names like \"AIRLINES\" and \"FLIGHTS\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'United Airlines' AND destination = 'ASY';",
            "SELECT COUNT(*) \nFROM airlines T1 \nJOIN flights T2 ON T2.Airline = T1.uid \nWHERE T1.Airline = 'United Airlines' AND T2.DestAirport = 'ASY'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM airlines T1 \nJOIN flights T2 ON T2.Airline = T1.uid \nWHERE T1.Airline = 'United Airlines' AND T2.DestAirport = 'ASY'"
        ]
    },
    "337": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the template type code of the template used by document with the name \"Data base\"?",
        "ground_truth": "SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T2.document_name  =  \"Data base\"",
        "amends": [
            "Do select `T1.template_type_code` from the `Templates` table instead of `template_type_code` from the `documents` table. Do join `Templates AS T1` with `Documents AS T2` using `ON T1.template_id = T2.template_id` instead of querying only the `documents` table. Do filter on `T2.document_name = \"Data base\"` instead of `name = 'Data base'`. The amended query now correctly retrieves template type codes by joining the Templates and Documents tables and filtering by document name, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about template type code for a document: select T1.template_type_code from the Templates table instead of from the documents table. 2) When combining Templates and Documents tables: join Templates AS T1 with Documents AS T2 using ON T1.template_id = T2.template_id to link template information to documents. 3) When filtering by document name: use T2.document_name = \"Data base\" instead of name = 'Data base' to match the exact document name literal with correct column reference."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code FROM documents WHERE name = 'Data base';",
            "SELECT T1.Template_Type_Code \nFROM Templates AS T1 \nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID \nWHERE T2.Document_Name = 'Data base'"
        ],
        "rule_sql": [
            "SELECT T1.Template_Type_Code \nFROM Templates AS T1 \nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID \nWHERE T2.Document_Name = 'Data base'"
        ]
    },
    "115": {
        "db_id": "car_1",
        "question": "How many car models are produced in the usa?",
        "ground_truth": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';",
        "amends": [
            "Do add explicit table joins with `MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker = T2.Id JOIN COUNTRIES AS T3 ON T2.Country = T3.CountryId` instead of querying a single `cars` table. Do filter on `T3.CountryName = 'usa'` instead of `country = 'USA'` to properly reference the joined countries table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly joins multiple tables to count models from the specified country and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about car models produced in the usa: make sure to join MODEL_LIST as T1 with CAR_MAKERS as T2 using T1.Maker = T2.Id, then join with COUNTRIES as T3 using T2.Country = T3.CountryId. 2) When filtering for country: use T3.CountryName = 'usa' (lowercase) instead of 'USA'. 3) When counting car models: use count(*) to count all rows after proper joins and filtering. 4) When combining tables: perform inner matches using the exact key equalities T1.Maker = T2.Id and T2.Country = T3.CountryId, keeping only matching pairs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE country = 'USA';",
            "SELECT count(*) FROM model_list AS T1 JOIN car_makers AS T2 ON T1.Maker = T2.Id JOIN countries AS T3 ON T2.Country = T3.CountryId WHERE T3.CountryName = 'usa'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM model_list AS T1\nINNER JOIN car_makers AS T2 ON T1.Maker = T2.Id\nINNER JOIN countries AS T3 ON T2.Country = T3.CountryId\nWHERE T3.CountryName = 'usa'"
        ]
    },
    "41": {
        "db_id": "concert_singer",
        "question": "Find the name and location of the stadiums which some concerts happened in the years of both 2014 and 2015.",
        "ground_truth": "SELECT T2.name ,  T2.location FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.Year  =  2014 INTERSECT SELECT T2.name ,  T2.location FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.Year  =  2015",
        "amends": [
            "Do use `concert` and `stadium` tables with `JOIN` on `stadium_id` instead of querying only `stadiums` table. Do filter by `Year = 2014` in one branch and `Year = 2015` in another instead of the impossible `year = 2014 AND year = 2015`. Do use `INTERSECT` to find stadiums that hosted concerts in both years instead of attempting to find a single row satisfying both year conditions simultaneously. Do reference columns with table aliases `T2.name` and `T2.location` instead of unqualified `name` and `location`. The amended query now correctly identifies stadiums that hosted concerts in both 2014 and 2015 by using intersection logic instead of the contradictory WHERE clause."
        ],
        "rules": [
            "1) When answering about stadiums that hosted concerts in both 2014 and 2015: use the concert and stadium tables instead of only the stadiums table. 2) When combining concert and stadium tables: link rows where T1.stadium_id = T2.stadium_id and keep only matching pairs (inner match). 3) When filtering for concerts in 2014: include only rows where T1.Year = 2014. 4) When filtering for concerts in 2015: include only rows where T1.Year = 2015. 5) When finding stadiums with concerts in both years: use INTERSECT logic to combine results from the 2014 and 2015 filters. 6) When selecting stadium information: output T2.name and T2.location instead of unqualified name and location columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, location FROM stadiums WHERE year = 2014 AND year = 2015;",
            "SELECT T2.Name, T2.Location\nFROM concert T1\nJOIN stadium T2 ON T1.Stadium_ID = T2.Stadium_ID\nWHERE T1.Year = '2014'\nINTERSECT\nSELECT T2.Name, T2.Location\nFROM concert T1\nJOIN stadium T2 ON T1.Stadium_ID = T2.Stadium_ID\nWHERE T1.Year = '2015'"
        ],
        "rule_sql": [
            "SELECT T2.Name, T2.Location\nFROM concert T1\nINNER JOIN stadium T2 ON T1.Stadium_ID = T2.Stadium_ID\nWHERE T1.Year = '2014'\nINTERSECT\nSELECT T2.Name, T2.Location\nFROM concert T1\nINNER JOIN stadium T2 ON T1.Stadium_ID = T2.Stadium_ID\nWHERE T1.Year = '2015'"
        ]
    },
    "673": {
        "db_id": "poker_player",
        "question": "What are different nationalities of people and the corresponding number of people from each nation?",
        "ground_truth": "SELECT Nationality ,  COUNT(*) FROM people GROUP BY Nationality",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT nationality, COUNT(*) FROM people GROUP BY nationality ORDER BY COUNT(*) DESC;"
        ],
        "rule_sql": [
            "SELECT Nationality, COUNT(*) AS Number_of_People FROM people GROUP BY Nationality ORDER BY Number_of_People DESC;"
        ]
    },
    "13": {
        "db_id": "concert_singer",
        "question": "What are all the song names by singers who are older than average?",
        "ground_truth": "SELECT song_name FROM singer WHERE age  >  (SELECT avg(age) FROM singer)",
        "amends": [
            "Do reference table `singer` instead of `songs` in the FROM clause. Do use column `age` instead of `singer_age` for the comparison. Do reference table `singer` instead of `singers` in the subquery. Do use column `age` instead of `singer_age` in the subquery's AVG function. The amended query now correctly filters songs based on singers whose age exceeds the average age of all singers, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"song names by singers who are older than average\": make sure the output order: song_name. 2) When the question mentions \"singers\": \"singers\" actually means table \"singer\" in schema. 3) When the question mentions \"older than average\": compute the average of column \"age\" from table \"singer\" and filter for rows where \"age\" is greater than that average value. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT song_name FROM songs WHERE singer_age > (SELECT AVG(singer_age) FROM singers);",
            "SELECT s.Song_Name FROM singer s WHERE s.Age > (SELECT AVG(age) FROM singer)"
        ],
        "rule_sql": [
            "SELECT \"Song_Name\" FROM \"singer\" WHERE \"Age\" > (SELECT AVG(\"Age\") FROM \"singer\") ORDER BY \"Song_Name\""
        ]
    },
    "484": {
        "db_id": "wta_1",
        "question": "What are the names and ranks of the three youngest winners across all matches?",
        "ground_truth": "SELECT DISTINCT winner_name ,  winner_rank FROM matches ORDER BY winner_age LIMIT 3",
        "amends": [
            "Do `SELECT DISTINCT winner_name, winner_rank` instead of `SELECT name, rank` to use the correct column names and add distinctness. Do `FROM matches` instead of `FROM winners` to query from the appropriate table. Do `ORDER BY winner_age` instead of `ORDER BY age` to use the correct age column name while maintaining the ascending sort order. The amended query now correctly retrieves distinct winner names and ranks from the matches table ordered by winner age with a limit of 3, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"names and ranks of winners\": use the exact column tokens \"winner_name\" and \"winner_rank\" from the matches table. 2) When the question asks for \"three youngest winners\": order rows by \"winner_age\" in ascending order and keep the first 3 rows. 3) When retrieving winner information: ensure distinct values are returned for winner_name and winner_rank to avoid duplicates. 4) When querying about winners: use the \"matches\" table as the source table, not a \"winners\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, rank FROM winners ORDER BY age ASC LIMIT 3;",
            "SELECT DISTINCT winner_name, winner_rank FROM matches ORDER BY winner_age ASC LIMIT 3"
        ],
        "rule_sql": [
            "SELECT DISTINCT winner_name, winner_rank FROM matches ORDER BY winner_age ASC LIMIT 3"
        ]
    },
    "326": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Count the number of templates of the type CV.",
        "ground_truth": "SELECT count(*) FROM Templates WHERE template_type_code  =  \"CV\"",
        "amends": [
            "Do reference the table as `Templates` instead of `templates` to match the correct case sensitivity. Do use the column `template_type_code` instead of `type` to reference the appropriate column name. Do use double quotes `\"CV\"` instead of single quotes `'CV'` for the string literal value. The amended query now correctly counts records from the Templates table where the template_type_code equals \"CV\", matching the intended behavior."
        ],
        "rules": [
            "1) When referencing the templates table: use the exact identifier \"Templates\" with proper case sensitivity. 2) When filtering by template type: use the column \"template_type_code\" instead of \"type\". 3) When comparing against the literal value CV: use double quotes \"CV\" instead of single quotes. 4) When counting templates: count all rows from the Templates table where template_type_code equals \"CV\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM templates WHERE type = 'CV';",
            "SELECT COUNT(*) FROM Templates WHERE template_type_code = \"CV\";"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Templates WHERE template_type_code = \"CV\";"
        ]
    },
    "125": {
        "db_id": "car_1",
        "question": "What is the number of the cars with horsepower more than 150?",
        "ground_truth": "SELECT count(*) FROM CARS_DATA WHERE horsepower  >  150;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` in the FROM clause. Do use filter `horsepower > 150` instead of `horsepower < 150` in the WHERE clause, changing the comparison operator from less than to greater than. The amended query now correctly counts records where horsepower exceeds 150 rather than those below 150, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"number of cars with horsepower more than 150\": make sure the output order: count of cars with horsepower > 150. 2) When the question mentions \"cars\": \"cars\" actually means \"CARS_DATA\" in schema. 3) When the question asks for \"number of cars with horsepower more than 150\": compute the count of rows from CARS_DATA where horsepower > 150. 4) When handling text literals: do not change case, spacing, or punctuation for numeric values like 150. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table names like CARS_DATA."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE horsepower < 150;",
            "SELECT COUNT(*) FROM cars_data WHERE horsepower > 150"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM \"cars_data\" WHERE CAST(\"Horsepower\" AS REAL) > 150;"
        ]
    },
    "824": {
        "db_id": "orchestra",
        "question": "List the names of conductors in ascending order of age.",
        "ground_truth": "SELECT Name FROM conductor ORDER BY Age ASC",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the `conductor` table instead of `conductors`. Do order by `Age` in ascending order instead of descending order. The amended query now correctly references the proper table and column names with the intended sort direction."
        ],
        "rules": [
            "1) When the question asks for conductor names: use the exact column token \"Name\" from table \"conductor\". 2) When ordering by age in ascending order: use the exact column token \"Age\" from table \"conductor\" and sort from lowest to highest values. 3) When referencing the conductor table: use the exact table name \"conductor\" (not \"conductors\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM conductors ORDER BY age DESC;",
            "SELECT Name FROM conductor ORDER BY Age ASC;"
        ],
        "rule_sql": [
            "SELECT Name FROM conductor ORDER BY Age ASC;"
        ]
    },
    "616": {
        "db_id": "tvshow",
        "question": "What are 3 most highly rated episodes in the TV series table and what were those ratings?",
        "ground_truth": "SELECT Episode ,  Rating FROM TV_series ORDER BY Rating DESC LIMIT 3;",
        "amends": [
            "Do use column name `Episode` instead of `title` in the SELECT list. Do use column name `Rating` instead of `rating` in both the SELECT list and ORDER BY clause. The amended query now correctly selects and orders by the intended columns, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"most highly rated episodes\": rank rows by \"Rating\" in descending order and keep the first 3 rows. 2) When the question mentions \"episodes\": \"episodes\" actually means \"Episode\" in schema. 3) When the question mentions \"ratings\": \"ratings\" actually means \"Rating\" in schema. 4) When answering about \"3 most highly rated episodes and their ratings\": make sure the output order: Episode, Rating."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title, rating FROM tv_series ORDER BY rating DESC LIMIT 3;",
            "SELECT Episode, Rating FROM TV_series ORDER BY Rating DESC LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT Episode, Rating FROM TV_series ORDER BY Rating DESC LIMIT 3"
        ]
    },
    "413": {
        "db_id": "museum_visit",
        "question": "What is the average age of the visitors whose membership level is not higher than 4?",
        "ground_truth": "SELECT avg(age) FROM visitor WHERE Level_of_membership  <=  4",
        "amends": [
            "Do use table name `visitor` instead of `visitors`. Do change the filter condition to `Level_of_membership <= 4` instead of `membership_level > 4`, which reverses the logic to include members with lower membership levels rather than excluding them. Do use lowercase `avg(age)` instead of uppercase `AVG(age)` for the aggregate function, though this is a cosmetic change that doesn't affect functionality. The amended query now correctly calculates the average age for visitors with membership level 4 or below instead of those above level 4, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"visitors\": use the exact table name \"visitor\" instead of \"visitors\". 2) When filtering for membership level \"not higher than 4\": use the condition Level_of_membership <= 4 to include levels 4 and below, not membership_level > 4. 3) When computing average age: use the aggregate function avg(age) with lowercase syntax."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age) FROM visitors WHERE membership_level > 4;",
            "SELECT avg(age) FROM visitor WHERE Level_of_membership <= 4"
        ],
        "rule_sql": [
            "SELECT AVG(Age) FROM visitor WHERE Level_of_membership <= 4"
        ]
    },
    "654": {
        "db_id": "poker_player",
        "question": "Return the average earnings across all poker players.",
        "ground_truth": "SELECT avg(Earnings) FROM poker_player",
        "amends": [
            "Do reference the table as `poker_player` instead of `poker_players` to match the correct table name. Do use the column name `Earnings` with proper capitalization instead of lowercase `earnings` to match the actual column definition. Do remove the `WHERE earnings > 1000000` filter instead of keeping it, as the correct query calculates the overall average without filtering. The amended query now correctly calculates the average earnings across all poker players without unnecessary filtering."
        ],
        "rules": [
            "1) When the question asks for average earnings across all poker players: use the table name \"poker_player\" exactly as specified in the schema. 2) When referring to the earnings column: use the exact column name \"Earnings\" with proper capitalization as shown in the schema. 3) When calculating overall average without filtering: do not apply any WHERE clause conditions like earnings > 1000000, as the question requires including all records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(earnings) FROM poker_players WHERE earnings > 1000000;",
            "SELECT AVG(Earnings) FROM poker_player"
        ],
        "rule_sql": [
            "SELECT AVG(Earnings) FROM poker_player"
        ]
    },
    "415": {
        "db_id": "museum_visit",
        "question": "Find the id and name of the museum that has the most staff members?",
        "ground_truth": "SELECT museum_id ,  name FROM museum ORDER BY num_of_staff DESC LIMIT 1",
        "amends": [
            "Do use column name `museum_id` instead of `id` and table name `museum` instead of `museums`. Do use column `num_of_staff` for ordering instead of `staff_count`. The amended query now correctly references the museum table structure and ordering column to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for museum id and name: use column \"museum_id\" for id and column \"name\" for name from table \"museum\". 2) When the question asks for the museum with the most staff members: order rows by column \"num_of_staff\" in descending order and keep only the first row. 3) When choosing identifier names: use exact column name \"museum_id\" instead of \"id\" and exact table name \"museum\" instead of \"museums\". 4) When ordering by staff count: use exact column name \"num_of_staff\" instead of \"staff_count\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, name FROM museums ORDER BY staff_count DESC LIMIT 1;",
            "SELECT Museum_ID, Name FROM museum ORDER BY Num_of_Staff DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT museum_id, name FROM museum ORDER BY num_of_staff DESC LIMIT 1;"
        ]
    },
    "163": {
        "db_id": "car_1",
        "question": "How many cars has over 6 cylinders?",
        "ground_truth": "SELECT COUNT(*) FROM CARS_DATA WHERE Cylinders  >  6;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` and do filter on `Cylinders > 6` instead of `cylinders <= 6`, changing both the table name and the filter condition to count vehicles with more than six cylinders rather than those with six or fewer. The amended query now correctly counts records from the CARS_DATA table where the Cylinders value exceeds six, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"cars with over 6 cylinders\": use table \"CARS_DATA\" instead of \"cars\". 2) When filtering for vehicles with more than six cylinders: use condition \"Cylinders > 6\" instead of \"cylinders <= 6\". 3) When counting records from the CARS_DATA table: count all rows where the Cylinders value exceeds six."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE cylinders <= 6;",
            "SELECT COUNT(*) FROM cars_data WHERE Cylinders > 6"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM cars_data WHERE Cylinders > 6"
        ]
    },
    "195": {
        "db_id": "flight_2",
        "question": "How many airlines are from USA?",
        "ground_truth": "SELECT count(*) FROM AIRLINES WHERE Country  =  \"USA\"",
        "amends": [
            "Do use `count(*)` instead of `COUNT(*)` for consistent lowercase function naming. Do reference table `AIRLINES` instead of `airlines` to match the correct table name case. Do filter on `Country = \"USA\"` instead of `country = 'United States'` to use the correct column name case and proper country code value with double quotes instead of single quotes. The amended query now correctly counts airlines from the United States using the standardized country code."
        ],
        "rules": [
            "1) When referencing the airlines table: use exact table name \"AIRLINES\" with uppercase letters. 2) When counting airlines: use lowercase function \"count(*)\" instead of uppercase \"COUNT(*)\". 3) When filtering airlines by country: use column name \"Country\" with exact case and value \"USA\" with double quotes instead of 'United States'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM airlines WHERE country = 'United States';",
            "SELECT count(*) FROM AIRLINES WHERE Country = \"USA\""
        ],
        "rule_sql": [
            "SELECT count(*) FROM AIRLINES WHERE Country = \"USA\""
        ]
    },
    "48": {
        "db_id": "pets_1",
        "question": "How much does the youngest dog weigh?",
        "ground_truth": "SELECT weight FROM pets ORDER BY pet_age LIMIT 1",
        "amends": [
            "Do select `weight` instead of `MAX(weight)` and change the source table from `dogs` to `pets`. Do remove the WHERE filter with subquery that found `age = (SELECT MIN(age) FROM dogs)` instead of keeping it. Do add `ORDER BY pet_age LIMIT 1` instead of omitting ordering and limiting, which now correctly retrieves the weight of the youngest pet by sorting by age and taking the first result. The amended query now matches RIGHT_SQL's behavior by directly fetching the weight of the youngest pet rather than finding the maximum weight among dogs of minimum age."
        ],
        "rules": [
            "1) When answering about \"the youngest dog\": use the table \"pets\" instead of \"dogs\" and select the column \"weight\" directly rather than using MAX(weight). 2) When finding the youngest entity: order by \"pet_age\" in ascending order and take only the first result using LIMIT 1. 3) When the question mentions \"dog\": the relevant table is actually \"pets\" in the schema, not \"dogs\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(weight) FROM dogs WHERE age = (SELECT MIN(age) FROM dogs);",
            "SELECT weight FROM Pets WHERE PetType = 'dog' ORDER BY pet_age LIMIT 1"
        ],
        "rule_sql": [
            "SELECT weight FROM Pets WHERE PetType = 'dog' ORDER BY pet_age ASC LIMIT 1;"
        ]
    },
    "1007": {
        "db_id": "singer",
        "question": "What are the names of the singers who are not French citizens?",
        "ground_truth": "SELECT Name FROM singer WHERE Citizenship != \"France\"",
        "amends": [
            "Do reference the `Name` column instead of `name` and use table `singer` instead of `singers`. Do filter with `Citizenship != \"France\"` instead of `nationality != 'French'` to match the correct column name and country value format. The amended query now correctly selects from the appropriate table with the proper column references and filter condition."
        ],
        "rules": [
            "1) When answering about \"names of singers who are not French citizens\": make sure the output order: Name from table singer. 2) When the question mentions \"singers\": \"singers\" actually means \"singer\" in schema. 3) When the question mentions \"not French citizens\": \"French citizens\" actually means \"Citizenship = 'France'\" in schema, so filter for Citizenship != \"France\". 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for column names like \"Citizenship\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers WHERE nationality != 'French';",
            "SELECT Name FROM singer WHERE Citizenship != \"France\";"
        ],
        "rule_sql": [
            "SELECT \"Name\" FROM \"singer\" WHERE \"Citizenship\" != 'France' ORDER BY \"Name\""
        ]
    },
    "156": {
        "db_id": "car_1",
        "question": "What is the horsepower of the car with the greatest accelerate?",
        "ground_truth": "SELECT T1.horsepower FROM CARS_DATA AS T1 ORDER BY T1.accelerate DESC LIMIT 1;",
        "amends": [
            "Do qualify the column reference as `T1.horsepower` instead of the unqualified `horsepower`, and do add the table alias `T1` in the `FROM` clause instead of omitting it, specifying `CARS_DATA AS T1` instead of just `cars`."
        ],
        "rules": [
            "1) When answering about \"horsepower of the car with the greatest accelerate\": make sure the output order: T1.horsepower. 2) When the question mentions \"cars\": \"cars\" actually means \"CARS_DATA in schema\". 3) When the question mentions \"greatest accelerate\": rank rows by accelerate in descending direction and keep the first 1 row. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 5) When referring to table roles: do not rename or swap the alias T1 once set for this schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT horsepower FROM cars ORDER BY accelerate DESC LIMIT 1;",
            "SELECT T1.horsepower FROM cars_data AS T1 ORDER BY T1.Accelerate DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT \"Horsepower\" FROM \"cars_data\" ORDER BY \"Accelerate\" DESC LIMIT 1"
        ]
    },
    "278": {
        "db_id": "employee_hire_evaluation",
        "question": "Which employee received the most awards in evaluations? Give me the employee name.",
        "ground_truth": "SELECT t1.name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID  =  t2.Employee_ID GROUP BY t2.Employee_ID ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `t1.name` from the `employee` table instead of `employee_name` from `evaluations`. Do join `evaluation AS t2` with an `INNER JOIN` on `t1.Employee_ID = t2.Employee_ID` instead of querying only the `evaluations` table. Do add `GROUP BY t2.Employee_ID` to aggregate by employee instead of omitting grouping. Do order by `count(*) DESC` to rank by evaluation count instead of `awards DESC`. The amended query now correctly identifies the employee with the most evaluations by joining employee data with evaluation records and counting occurrences per employee."
        ],
        "rules": [
            "1) When answering about \"employee who received the most awards in evaluations\": make sure the output order: t1.name. 2) When the question mentions \"employee name\": \"employee name\" actually means \"t1.name in schema\". 3) When combining employee and evaluation tables for shared entities: link rows where t1.Employee_ID = t2.Employee_ID; keep only matching pairs (inner match). 4) When the question asks for \"most awards\" (highest count): rank rows by count(*) in descending direction and keep the first 1 row. 5) When the question says \"per employee\"/\"by employee\": organize results by t2.Employee_ID and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT employee_name FROM evaluations ORDER BY awards DESC LIMIT 1;",
            "SELECT t1.Name\nFROM employee AS t1\nINNER JOIN evaluation AS t2 ON t1.Employee_ID = t2.Employee_ID\nGROUP BY t2.Employee_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t1.Name\nFROM employee t1\nINNER JOIN evaluation t2 ON t1.Employee_ID = t2.Employee_ID\nGROUP BY t2.Employee_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "812": {
        "db_id": "world_1",
        "question": "What are the cities whose population is between 160000 and 900000?",
        "ground_truth": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000",
        "amends": [
            "Do select `name` instead of `city` from the `city` table instead of `cities`. Do use `BETWEEN 160000 AND 900000` instead of separate `population > 160000 AND population < 900000` conditions to include both boundary values. The amended query now correctly retrieves city names within the specified population range using proper inclusive bounds."
        ],
        "rules": [
            "1) When the question asks for cities: select the \"name\" column from the \"city\" table instead of a \"city\" column. 2) When filtering for population between 160000 and 900000: use inclusive bounds with BETWEEN 160000 AND 900000 to include both boundary values, not separate greater-than and less-than conditions. 3) When answering about cities with population ranges: make sure the output order shows city names that meet the population criteria."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city FROM cities WHERE population > 160000 AND population < 900000;",
            "SELECT Name FROM city WHERE Population BETWEEN 160000 AND 900000"
        ],
        "rule_sql": [
            "SELECT Name FROM city WHERE Population BETWEEN 160000 AND 900000 ORDER BY Name;"
        ]
    },
    "697": {
        "db_id": "voter_1",
        "question": "How many contestants did not get voted?",
        "ground_truth": "SELECT count(*) FROM contestants WHERE contestant_number NOT IN ( SELECT contestant_number FROM votes )",
        "amends": [
            "Do filter with `contestant_number NOT IN` subquery instead of checking `votes IS NULL`. Do remove the direct column check `votes IS NULL` instead of keeping it, and do add a correlated subquery against the `votes` table instead of omitting it. The amended query now correctly identifies contestants without any votes by checking their absence in the votes table rather than relying on a potentially incorrect NULL check in the contestants table."
        ],
        "rules": [
            "1) When counting contestants who did not get voted: use contestant_number as the counting key instead of checking for NULL values in a votes column. 2) When identifying contestants without votes: check for contestants whose contestant_number does not appear in the votes table rather than checking for NULL values. 3) When filtering contestants without votes: use a NOT IN subquery against the votes table to find contestants with no corresponding vote records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM contestants WHERE votes IS NULL;",
            "SELECT COUNT(*) \nFROM CONTESTANTS c \nWHERE c.contestant_number NOT IN (SELECT DISTINCT contestant_number FROM VOTES)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM CONTESTANTS \nWHERE contestant_number NOT IN (SELECT DISTINCT contestant_number FROM VOTES)"
        ]
    },
    "980": {
        "db_id": "dog_kennels",
        "question": "How many owners temporarily do not have any dogs?",
        "ground_truth": "SELECT count(*) FROM Owners WHERE owner_id NOT IN ( SELECT owner_id FROM Dogs )",
        "amends": [
            "Do use a subquery with `NOT IN` filtering on `owner_id` instead of checking for `dog_id IS NULL`. Do reference the `Owners` table (capitalized) instead of `owners`. Do count all rows from the filtered result set instead of counting rows where a non-existent `dog_id` column would be null. The amended query now correctly identifies owners who do not have any dogs by checking for `owner_id` values that are not present in the Dogs table, rather than relying on a potentially non-existent or incorrectly named column."
        ],
        "rules": [
            "1) When the question asks about owners without dogs: use the \"Owners\" table (capitalized) instead of \"owners\". 2) When identifying owners who temporarily do not have any dogs: find owner_id values from Owners that are not present in the Dogs table's owner_id column. 3) When counting owners without dogs: count all rows from the filtered result set where owner_id is not in the Dogs table's owner_id values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM owners WHERE dog_id IS NULL;",
            "SELECT COUNT(*) FROM Owners WHERE owner_id NOT IN (SELECT DISTINCT owner_id FROM Dogs)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Owners WHERE owner_id NOT IN (SELECT owner_id FROM Dogs)"
        ]
    },
    "126": {
        "db_id": "car_1",
        "question": "What is the number of cars with a horsepower greater than 150?",
        "ground_truth": "SELECT count(*) FROM CARS_DATA WHERE horsepower  >  150;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` and use filter `horsepower > 150` instead of `horsepower < 150` to count records with higher horsepower values rather than lower ones. The amended query now correctly counts vehicles exceeding 150 horsepower, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"number of cars with horsepower greater than 150\": use table \"CARS_DATA\" instead of \"cars\" and filter where \"horsepower\" > 150 instead of < 150. 2) When counting records: count all rows from \"CARS_DATA\" where the condition \"horsepower > 150\" is true."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE horsepower < 150;",
            "SELECT COUNT(*) FROM cars_data WHERE horsepower > 150"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM cars_data WHERE CAST(Horsepower AS REAL) > 150;"
        ]
    },
    "88": {
        "db_id": "car_1",
        "question": "What is the number of continents?",
        "ground_truth": "SELECT count(*) FROM CONTINENTS;",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM continents;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS NumberOfContinents FROM continents;"
        ]
    },
    "606": {
        "db_id": "tvshow",
        "question": "What are the languages used by the least number of TV Channels and how many channels use it?",
        "ground_truth": "SELECT LANGUAGE ,  count(*) FROM TV_Channel GROUP BY LANGUAGE ORDER BY count(*) ASC LIMIT 1;",
        "amends": [
            "Do use `count(*)` without an alias instead of `COUNT(*) as channel_count`. Do order by `count(*) ASC` instead of `channel_count DESC`. Do reference table `TV_Channel` instead of `tv_channels`. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for languages used by the least number of TV Channels: order the results by count in ascending order instead of descending. 2) When counting TV Channels: use count(*) without an alias instead of COUNT(*) as channel_count. 3) When referencing the TV Channels table: use the exact table name TV_Channel instead of tv_channels."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language, COUNT(*) as channel_count FROM tv_channels GROUP BY language ORDER BY channel_count DESC LIMIT 1;",
            "SELECT Language, COUNT(*) FROM TV_Channel GROUP BY Language ORDER BY COUNT(*) ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Language, count(*) FROM TV_Channel GROUP BY Language ORDER BY count(*) ASC;"
        ]
    },
    "397": {
        "db_id": "course_teach",
        "question": "Show the hometowns shared by at least two teachers.",
        "ground_truth": "SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*)  >=  2",
        "amends": [
            "Do use `COUNT(*) >= 2` instead of `COUNT(*) = 1` in the HAVING clause to find hometowns with at least two teachers rather than exactly one. Do reference the table as `teacher` instead of `teachers` and use the correct column name `Hometown` instead of `hometown` to match the actual schema. The amended query now correctly identifies hometowns with multiple teachers and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for hometowns shared by at least two teachers: use COUNT(*) >= 2 instead of COUNT(*) = 1 to find groups with at least two members. 2) When referencing the teacher table: use the exact table name \"teacher\" instead of \"teachers\". 3) When referencing the hometown column: use the exact column name \"Hometown\" instead of \"hometown\" to match the schema. 4) When grouping by hometown: organize results by the \"Hometown\" column and count the number of teachers per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT hometown FROM teachers GROUP BY hometown HAVING COUNT(*) = 1",
            "SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*) >= 2"
        ]
    },
    "249": {
        "db_id": "flight_2",
        "question": "What are flight numbers of flights arriving at Airport \"APG\"?",
        "ground_truth": "SELECT FlightNo FROM FLIGHTS WHERE DestAirport  =  \"APG\"",
        "amends": [
            "Do reference column `FlightNo` instead of `flight_number` in the SELECT list. Do reference table `FLIGHTS` instead of `flights` in the FROM clause. Do use filter condition `DestAirport = \"APG\"` instead of `departure_airport = 'APG'` in the WHERE clause, changing the column reference from departure airport to destination airport. The amended query now correctly filters for flights with destination airport APG instead of departure airport APG, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for flight numbers: use the exact column token \"FlightNo\" from the FLIGHTS table. 2) When the question mentions flights arriving at an airport: filter using the destination airport column \"DestAirport\" instead of departure airport. 3) When filtering for airport \"APG\": use the exact literal value \"APG\" with double quotes as shown in the schema. 4) When referencing the flights table: use the exact table name \"FLIGHTS\" with uppercase letters as specified in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_airport = 'APG';",
            "SELECT FlightNo FROM FLIGHTS WHERE DestAirport = \"APG\""
        ],
        "rule_sql": [
            "SELECT FlightNo FROM FLIGHTS WHERE DestAirport = \"APG\""
        ]
    },
    "571": {
        "db_id": "student_transcripts_tracking",
        "question": "How many times at most can a course enrollment result show in different transcripts? Also show the course enrollment id.",
        "ground_truth": "SELECT count(*) ,  student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `count(*)` without an alias instead of aliasing as `max_count`, and do select `student_course_id` instead of `course_enrollment_id`. Do query from `Transcript_Contents` instead of `transcripts`. Do group by `student_course_id` instead of `course_enrollment_id`. Do order by `count(*)` instead of `max_count`. The amended query now correctly identifies the student course with the highest content count from the appropriate table.",
            "Do place `count(*)` before `student_course_id` in the SELECT list instead of listing `student_course_id` first, and do add a space after the comma in the SELECT list instead of omitting it. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about \"course enrollment\": use the exact identifier \"student_course_id\" instead of \"course_enrollment_id\" as shown in the schema. 2) When counting occurrences in different transcripts: query from the \"Transcript_Contents\" table instead of \"transcripts\". 3) When grouping by course enrollment: group by \"student_course_id\" to count occurrences per enrollment. 4) When finding the maximum count: order by the count value in descending order and take the first result. 5) When selecting output columns: include both \"student_course_id\" and the count value without aliasing the count.",
            "1) When answering about \"How many times at most can a course enrollment result show in different transcripts? Also show the course enrollment id\": make sure the output order: count(*) first, then student_course_id. 2) When the question asks for \"course enrollment id\": \"course enrollment id\" actually means \"student_course_id in schema\". 3) When the question asks for \"how many times at most\": rank rows by count(*) in descending order and keep the first 1 row. 4) When counting occurrences of course enrollment results: compute the number of rows using the canonical key student_course_id."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_enrollment_id, COUNT(*) as max_count \nFROM transcripts \nGROUP BY course_enrollment_id \nORDER BY max_count DESC \nLIMIT 1;",
            "SELECT student_course_id, COUNT(*) \nFROM Transcript_Contents \nGROUP BY student_course_id \nORDER BY COUNT(*) DESC \nLIMIT 1",
            "SELECT count(*), student_course_id \nFROM Transcript_Contents \nGROUP BY student_course_id \nORDER BY count(*) DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS count, student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count DESC LIMIT 1;"
        ]
    },
    "75": {
        "db_id": "pets_1",
        "question": "Find the first name and age of students who have a pet.",
        "ground_truth": "SELECT DISTINCT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid",
        "amends": [
            "Do use `DISTINCT` instead of omitting it, and select `fname` instead of `first_name` from the `student` table instead of `students`. Do add a `JOIN` with `has_pet` table on `stuid = stuid` instead of no join, and move the filter to check for pet existence through the join condition instead of using `WHERE pet IS NULL`. Do reference tables with aliases `T1` and `T2` instead of no aliases. The amended query now correctly identifies students who have pets by joining with the has_pet table rather than incorrectly checking for a NULL pet column in the students table."
        ],
        "rules": [
            "1) When the question asks for \"first name\" of students: use the exact column token \"fname\" from the student table instead of \"first_name\". 2) When the question asks about students who have a pet: join the student table (T1) with the has_pet table (T2) using the exact key equality T1.stuid = T2.stuid to identify students with pets, instead of checking for NULL values. 3) When selecting from multiple tables: use table aliases T1 for the student table and T2 for the has_pet table as specified. 4) When the question asks for distinct results: include DISTINCT to ensure each student appears only once in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, age FROM students WHERE pet IS NULL;",
            "SELECT DISTINCT T1.Fname, T1.Age FROM Student T1 JOIN Has_Pet T2 ON T1.StuID = T2.StuID"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.fname, T1.Age FROM Student T1 JOIN Has_Pet T2 ON T1.StuID = T2.StuID"
        ]
    },
    "753": {
        "db_id": "world_1",
        "question": "Which regions speak Dutch or English?",
        "ground_truth": "SELECT DISTINCT T1.Region FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" OR T2.Language  =  \"Dutch\"",
        "amends": [
            "Do use `DISTINCT T1.Region` instead of `region` without distinct. Do join `country AS T1` and `countrylanguage AS T2` instead of querying only `countries`. Do specify `ON T1.Code = T2.CountryCode` instead of missing the join condition. Do filter on `T2.Language = \"English\" OR T2.Language = \"Dutch\"` instead of filtering on a single table's `language` column. The amended query now correctly retrieves distinct regions from joined tables where the language condition is properly applied through the relationship between country and countrylanguage tables."
        ],
        "rules": [
            "1) When answering about \"regions that speak Dutch or English\": make sure the output order: T1.Region. 2) When the question asks for distinct regions: compute unique values of T1.Region. 3) When combining country as T1 and countrylanguage as T2: link rows where T1.Code = T2.CountryCode and keep only matching pairs (inner match). 4) When filtering for languages: use exact literals T2.Language = \"English\" OR T2.Language = \"Dutch\" with exact case and punctuation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT region FROM countries WHERE language = 'Dutch' OR language = 'English';",
            "SELECT DISTINCT T1.Region FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' OR T2.Language = 'Dutch'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Region \nFROM country AS T1 \nINNER JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = \"English\" OR T2.Language = \"Dutch\" \nORDER BY T1.Region"
        ]
    },
    "91": {
        "db_id": "car_1",
        "question": "How many countries are listed?",
        "ground_truth": "SELECT count(*) FROM COUNTRIES;",
        "amends": [
            "Do reference table `COUNTRIES` instead of `cities` to count records from the correct data source. The amended query now correctly counts records from the COUNTRIES table instead of cities, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"how many countries are listed\": make sure to count records from the \"COUNTRIES\" table instead of any other table. 2) When counting entities: use the canonical counting method that counts all rows in the specified table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities;",
            "SELECT COUNT(*) FROM countries;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM countries;"
        ]
    },
    "683": {
        "db_id": "poker_player",
        "question": "List the names of people that are not poker players.",
        "ground_truth": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM poker_player)",
        "amends": [
            "Do select `Name` instead of `name` to match the correct column case. Do use a subquery with `NOT IN` to filter out poker players instead of the incorrect direct filter `poker_player = 1`. Do reference `People_ID` in both the main query and subquery instead of the non-existent `poker_player` column. The amended query now correctly identifies non-poker players by excluding those whose IDs exist in the poker_player table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"names of people\": select the exact column \"Name\" from the people table. 2) When filtering for people who are not poker players: exclude people whose \"People_ID\" exists in the poker_player table using a NOT IN subquery. 3) When comparing identifiers between tables: use the exact column \"People_ID\" for matching between the main query and subquery."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM people WHERE poker_player = 1;",
            "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM poker_player)"
        ],
        "rule_sql": [
            "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM poker_player)"
        ]
    },
    "498": {
        "db_id": "battle_death",
        "question": "What are the different ids and names of the battles that lost any 'Brig' type shipes?",
        "ground_truth": "SELECT DISTINCT T1.id ,  T1.name FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.ship_type  =  'Brig'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate battle records. Do select `T1.id` and `T1.name` instead of `battle_id` and `name` with explicit table aliases. Do join `ship AS T2` instead of querying only the `battles` table to access ship information. Do use `ON T1.id = T2.lost_in_battle` instead of filtering directly on `battles` to properly relate ships to battles they were lost in. Do filter on `T2.ship_type = 'Brig'` instead of `ship_type = 'Brig'` to correctly reference the ship table's column. Do remove the `result = 'lost'` filter instead of keeping it since the ship's presence in lost_in_battle already indicates the loss. The amended query now correctly identifies battles where Brig-type ships were lost by properly joining the relevant tables."
        ],
        "rules": [
            "1) When answering about battles that lost ships: join table battles as T1 with table ship as T2 using T1.id = T2.lost_in_battle to properly relate ships to battles they were lost in. 2) When the question asks for \"different ids and names\": use DISTINCT to eliminate duplicate battle records. 3) When selecting battle information: select T1.id and T1.name instead of generic battle_id and name with explicit table aliases. 4) When filtering for 'Brig' type ships: filter on T2.ship_type = 'Brig' to correctly reference the ship table's column. 5) When determining lost ships: do not use result = 'lost' filter since the ship's presence in lost_in_battle already indicates the loss."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT battle_id, name FROM battles WHERE ship_type = 'Brig' AND result = 'lost';",
            "SELECT DISTINCT T1.id, T1.name\nFROM battle AS T1\nJOIN ship AS T2 ON T1.id = T2.lost_in_battle\nWHERE T2.ship_type = 'Brig'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.id, T1.name\nFROM battle AS T1\nJOIN ship AS T2 ON T1.id = T2.lost_in_battle\nWHERE T2.ship_type = 'Brig'"
        ]
    },
    "44": {
        "db_id": "concert_singer",
        "question": "What are the number of concerts that occurred in the stadium with the largest capacity ?",
        "ground_truth": "select count(*) from concert where stadium_id = (select stadium_id from stadium order by capacity desc limit 1)",
        "amends": [
            "Do reference table `concert` instead of `concerts` and use `stadium` instead of `stadiums` in the subquery to match the correct schema. The amended query now correctly counts concerts at the stadium with the highest capacity by fixing the table names while preserving the same logical structure and behavior."
        ],
        "rules": [
            "1) When the question asks about \"concerts\": use the exact table name \"concert\" instead of \"concerts\" as shown in the schema. 2) When the question asks about \"stadiums\": use the exact table name \"stadium\" instead of \"stadiums\" as shown in the schema. 3) When finding the stadium with the largest capacity: order stadium rows by capacity in descending order and take the first row. 4) When counting concerts for a specific stadium: count rows from the concert table where stadium_id matches the stadium_id of the stadium with largest capacity."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM concerts WHERE stadium_id = (SELECT stadium_id FROM stadiums ORDER BY capacity DESC LIMIT 1);",
            "SELECT COUNT(*) \nFROM concert \nWHERE Stadium_ID IN (\n    SELECT Stadium_ID \n    FROM stadium \n    WHERE Capacity = (SELECT MAX(Capacity) FROM stadium)\n)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM concert \nWHERE Stadium_ID = (\n    SELECT Stadium_ID \n    FROM stadium \n    ORDER BY Capacity DESC \n    LIMIT 1\n)"
        ]
    },
    "775": {
        "db_id": "world_1",
        "question": "Which African countries have a smaller population than that of any country in Asia?",
        "ground_truth": "SELECT Name FROM country WHERE Continent  =  \"Africa\"  AND population  <  (SELECT min(population) FROM country WHERE Continent  =  \"Asia\")",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c1.name \nFROM country c1 \nWHERE c1.continent = 'Africa' \nAND c1.population < (SELECT MIN(population) FROM country WHERE continent = 'Asia')"
        ],
        "rule_sql": [
            "SELECT c.Name \nFROM country c \nWHERE c.Continent = 'Africa' \nAND c.Population < (\n    SELECT MIN(Population) \n    FROM country \n    WHERE Continent = 'Asia'\n)"
        ]
    },
    "56": {
        "db_id": "pets_1",
        "question": "How many different types of pet are there?",
        "ground_truth": "SELECT count(DISTINCT pettype) FROM pets",
        "amends": [
            "Do `count(DISTINCT pettype)` instead of `COUNT(*)` to count distinct pet types rather than all rows. Do add the `DISTINCT` modifier and specify the `pettype` column instead of using a wildcard count. The amended query now correctly counts unique pet types and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting different types of pet: count the number of unique values in the \"pettype\" column instead of counting all rows. 2) When the question asks for \"different types\" or \"distinct types\": use the DISTINCT modifier on the \"pettype\" column to ensure only unique values are counted."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM pets;",
            "SELECT COUNT(DISTINCT PetType) FROM Pets;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT PetType) FROM Pets;"
        ]
    },
    "725": {
        "db_id": "world_1",
        "question": "Give the average life expectancy for countries in Africa which are republics?",
        "ground_truth": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  \"Africa\" AND GovernmentForm  =  \"Republic\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(lifeexpectancy) FROM country WHERE continent = 'Africa' AND governmentform = 'Republic';"
        ],
        "rule_sql": [
            "SELECT AVG(LifeExpectancy) AS AverageLifeExpectancy FROM country WHERE Continent = 'Africa' AND GovernmentForm LIKE '%Republic%';"
        ]
    },
    "928": {
        "db_id": "dog_kennels",
        "question": "Which professional did not operate any treatment on dogs? List the professional's id, role and email.",
        "ground_truth": "SELECT professional_id ,  role_code ,  email_address FROM Professionals EXCEPT SELECT T1.professional_id ,  T1.role_code ,  T1.email_address FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id",
        "amends": [
            "Do use `EXCEPT` set operation instead of a `LEFT JOIN` with `IS NULL` filter. Do select `professional_id`, `role_code`, and `email_address` instead of `id`, `role`, and `email`. Do reference the `Professionals` table with proper casing instead of lowercase. Do join `Treatments` with an `INNER JOIN` on `professional_id` instead of a filtered `LEFT JOIN`. Do remove the `animal_type = 'Dog'` filter condition instead of including it. Do use table aliases `T1` and `T2` instead of single letters. The amended query now correctly identifies professionals who have never performed any treatments by using set difference rather than null checking, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about professionals who did not operate any treatment on dogs: use EXCEPT set operation instead of LEFT JOIN with IS NULL filter. 2) When selecting professional information: select \"professional_id\", \"role_code\", and \"email_address\" instead of \"id\", \"role\", and \"email\". 3) When referencing the Professionals table: use proper casing \"Professionals\" instead of lowercase. 4) When combining Professionals and Treatments tables: use INNER JOIN on \"professional_id\" instead of filtered LEFT JOIN. 5) When filtering for treatments on dogs: remove the \"animal_type = 'Dog'\" filter condition instead of including it. 6) When using table aliases: use \"T1\" for Professionals and \"T2\" for Treatments instead of single letters."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.id, p.role, p.email \nFROM professionals p\nLEFT JOIN treatments t ON p.id = t.professional_id AND t.animal_type = 'Dog'\nWHERE t.professional_id IS NULL;",
            "SELECT professional_id, role_code, email_address FROM Professionals\nEXCEPT\nSELECT T1.professional_id, T1.role_code, T1.email_address \nFROM Professionals T1\nINNER JOIN Treatments T2 ON T1.professional_id = T2.professional_id"
        ],
        "rule_sql": [
            "SELECT professional_id, role_code, email_address FROM Professionals\nEXCEPT\nSELECT T1.professional_id, T1.role_code, T1.email_address\nFROM Professionals T1\nINNER JOIN Treatments T2 ON T1.professional_id = T2.professional_id"
        ]
    },
    "298": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Count the number of documents.",
        "ground_truth": "SELECT count(*) FROM Documents",
        "amends": [
            "Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency with the right SQL. Do reference table `Documents` with proper case instead of lowercase `documents` to match the correct table name. The amended query now matches RIGHT_SQL's behavior with identical functionality."
        ],
        "rules": [
            "1) When counting documents: use the exact table name \"Documents\" with proper case instead of lowercase \"documents\". 2) When using the count function: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" for consistency with the correct SQL dialect."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM documents WHERE id = 1;",
            "SELECT count(*) FROM Documents;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM Documents;"
        ]
    },
    "605": {
        "db_id": "tvshow",
        "question": "List the language used least number of TV Channel. List language and number of TV Channel.",
        "ground_truth": "SELECT LANGUAGE ,  count(*) FROM TV_Channel GROUP BY LANGUAGE ORDER BY count(*) ASC LIMIT 1;",
        "amends": [
            "Do use `count(*)` without an alias instead of `COUNT(*) as channel_count` in the SELECT list. Do change the ORDER BY to `count(*) ASC` instead of `channel_count DESC`. Do remove the alias reference in ORDER BY and change the sort direction to ascending instead of descending. The amended query now correctly orders by the actual count in ascending order instead of using an aliased column reference with descending order."
        ],
        "rules": [
            "1) When counting TV Channels: use count(*) without an alias instead of COUNT(*) as channel_count. 2) When ordering by the count of TV Channels: order by count(*) in ascending order instead of descending order. 3) When finding the language used least number of TV Channels: use ascending order on the count to get the minimum count value."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language, COUNT(*) as channel_count FROM TV_Channel GROUP BY language ORDER BY channel_count DESC LIMIT 1;",
            "SELECT Language, count(*) FROM TV_Channel GROUP BY Language ORDER BY count(*) ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Language, count(*) FROM TV_Channel GROUP BY Language ORDER BY count(*) ASC;"
        ]
    },
    "695": {
        "db_id": "voter_1",
        "question": "Of all the contestants who got voted, what is the contestant number and name of the contestant who got least votes?",
        "ground_truth": "SELECT T1.contestant_number , T1.contestant_name FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number GROUP BY T1.contestant_number ORDER BY count(*) ASC LIMIT 1",
        "amends": [
            "Do add `JOIN votes AS T2 ON T1.contestant_number = T2.contestant_number` instead of querying only the contestants table. Do add `GROUP BY T1.contestant_number` instead of omitting grouping. Do change `ORDER BY count(*) ASC` instead of `ORDER BY votes DESC` to sort by vote count ascending rather than descending. Do remove the direct reference to `votes` column instead of including it since votes are now aggregated. The amended query now correctly joins with the votes table, groups by contestant, and orders by the count of votes to find the contestant with the fewest votes, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about contestants who got voted: combine contestants table (T1) with votes table (T2) by linking rows where T1.contestant_number equals T2.contestant_number and keep only matching pairs (inner match). 2) When counting votes per contestant: organize results by T1.contestant_number and compute the number of votes using count(*) per group. 3) When finding the contestant with least votes: rank rows by the vote count in ascending order and keep the first 1 row. 4) When producing output: return contestant_number and contestant_name from T1 in that order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT contestant_number, contestant_name FROM contestants ORDER BY votes DESC LIMIT 1;",
            "SELECT T1.contestant_number, T1.contestant_name\nFROM CONTESTANTS AS T1\nJOIN VOTES AS T2 ON T1.contestant_number = T2.contestant_number\nGROUP BY T1.contestant_number\nORDER BY COUNT(*) ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.contestant_number, T1.contestant_name\nFROM CONTESTANTS T1\nINNER JOIN VOTES T2 ON T1.contestant_number = T2.contestant_number\nGROUP BY T1.contestant_number, T1.contestant_name\nORDER BY COUNT(*) ASC\nLIMIT 1;"
        ]
    },
    "580": {
        "db_id": "student_transcripts_tracking",
        "question": "What other details can you tell me about students in reverse alphabetical order?",
        "ground_truth": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC",
        "amends": [
            "Do select `other_student_details` instead of `*` to return only specific columns instead of all columns. Do order by `other_student_details DESC` instead of `name ASC` to sort by a different column in descending order instead of ascending order. The amended query now correctly returns only the other_student_details column sorted in descending order, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"other details\" about students: select only the \"other_student_details\" column instead of all columns. 2) When ordering results in reverse alphabetical order: sort by \"other_student_details\" in descending order instead of ascending order. 3) When the question specifies reverse alphabetical order: use descending order on the text column rather than ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM students ORDER BY name ASC;",
            "SELECT other_student_details FROM Students ORDER BY other_student_details DESC;"
        ],
        "rule_sql": [
            "SELECT other_student_details FROM Students ORDER BY other_student_details DESC;"
        ]
    },
    "633": {
        "db_id": "tvshow",
        "question": "which countries' tv channels are playing some cartoon written by Todd Casey?",
        "ground_truth": "SELECT T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.written_by  =  'Todd Casey'",
        "amends": [
            "Do select `T1.country` instead of `country` and remove `DISTINCT` instead of keeping it. Do add `cartoon AS T2` table instead of omitting it and use `JOIN` on `T1.id = T2.Channel` instead of querying only `tv_channels`. Do move the filter to `T2.written_by = 'Todd Casey'` instead of `cartoon_writer = 'Todd Casey'` and remove the `WHERE` clause entirely. The amended query now correctly joins tables and filters on the cartoon writer attribute, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about countries' tv channels playing cartoons: combine tv_channels as T1 and cartoon as T2 tables using T1.id = T2.Channel to find matching pairs. 2) When the question mentions \"cartoon written by Todd Casey\": filter for rows where T2.written_by = 'Todd Casey' exactly. 3) When selecting countries from tv_channels: output T1.country without using DISTINCT. 4) When combining T1 and T2: perform an inner match where T1.id equals T2.Channel to keep only channels that have cartoons."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT country FROM tv_channels WHERE cartoon_writer = 'Todd Casey';",
            "SELECT T1.Country FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Written_by = 'Todd Casey'"
        ],
        "rule_sql": [
            "SELECT T1.Country FROM TV_Channel AS T1 INNER JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Written_by = 'Todd Casey'"
        ]
    },
    "478": {
        "db_id": "wta_1",
        "question": "What are the codes of countries with more than 50 players?",
        "ground_truth": "SELECT country_code FROM players GROUP BY country_code HAVING count(*)  >  50",
        "amends": [
            "Do add `GROUP BY country_code` and move the aggregate filter to `HAVING count(*) > 50` instead of incorrectly placing `COUNT(*) > 50` in the `WHERE` clause where aggregate functions are not allowed. Do use the correct aggregate function syntax `count(*)` instead of `COUNT(*)` for consistency with the right query's style. The amended query now correctly groups by country code and filters groups with more than 50 players, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"codes of countries with more than 50 players\": group results by country_code and count players per group. 2) When filtering on aggregate counts like \"more than 50 players\": apply the count(*) > 50 condition in a HAVING clause after grouping, not in a WHERE clause. 3) When counting players: use count(*) to count all rows in each country group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country_code FROM players WHERE COUNT(*) > 50",
            "SELECT country_code FROM players GROUP BY country_code HAVING count(*) > 50"
        ],
        "rule_sql": [
            "SELECT country_code FROM players GROUP BY country_code HAVING COUNT(*) > 50"
        ]
    },
    "965": {
        "db_id": "dog_kennels",
        "question": "List the arrival date and the departure date for all the dogs.",
        "ground_truth": "SELECT date_arrived ,  date_departed FROM Dogs",
        "amends": [
            "Do reference table `Dogs` instead of `cats` in the FROM clause. Do select columns `date_arrived` and `date_departed` instead of `arrival_date` and `departure_date` in the SELECT list. The amended query now correctly retrieves arrival and departure dates from the Dogs table instead of the cats table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"arrival date and departure date for all the dogs\": make sure the output order: date_arrived, date_departed. 2) When the question mentions \"dogs\": \"dogs\" actually means table \"Dogs\" in schema. 3) When the question mentions \"arrival date\": \"arrival date\" actually means column \"date_arrived\" in table \"Dogs\". 4) When the question mentions \"departure date\": \"departure date\" actually means column \"date_departed\" in table \"Dogs\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT arrival_date, departure_date FROM cats",
            "SELECT date_arrived, date_departed FROM Dogs;"
        ],
        "rule_sql": [
            "SELECT date_arrived, date_departed FROM Dogs;"
        ]
    },
    "549": {
        "db_id": "student_transcripts_tracking",
        "question": "Find the last name of the students who currently live in the state of North Carolina but have not registered in any degree program.",
        "ground_truth": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id",
        "amends": [
            "Do add `JOIN Addresses AS T2 ON T1.current_address_id = T2.address_id` instead of querying only the `students` table. Do change the state filter to `T2.state_province_county = 'NorthCarolina'` instead of `state = 'NorthCarolina'` since the state information now comes from the joined Addresses table. Do remove the `degree_program IS NOT NULL` filter instead of keeping it, as the right query uses a different exclusion logic. Do add `EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id = T4.student_id` instead of omitting this exclusion clause, which removes students who are enrolled in programs. Do use table aliases `T1`, `T2`, `T3`, and `T4` instead of direct table references for clarity and to handle multiple table instances. The amended query now correctly identifies students from North Carolina who are not currently enrolled in any programs, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about students who live in North Carolina: join the students table (T1) with the Addresses table (T2) using T1.current_address_id = T2.address_id to get address information. 2) When filtering for students in North Carolina: use T2.state_province_county = 'NorthCarolina' (exact literal) instead of the students table's state column. 3) When excluding students registered in degree programs: use EXCEPT with a subquery that joins Students (T3) with Student_Enrolment (T4) on T3.student_id = T4.student_id to find enrolled students and remove them from results. 4) When selecting output columns: return only last_name from the students table. 5) When using table aliases: maintain T1 for the main students table, T2 for Addresses, T3 for the Students table in the exclusion subquery, and T4 for Student_Enrolment table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM students WHERE state = 'North Carolina' AND degree_program IS NOT NULL;",
            "SELECT DISTINCT T1.last_name \nFROM Students AS T1 \nJOIN Addresses AS T2 ON T1.current_address_id = T2.address_id \nWHERE T2.state_province_county = 'NorthCarolina'\nEXCEPT \nSELECT DISTINCT T3.last_name \nFROM Students AS T3 \nJOIN Student_Enrolment AS T4 ON T3.student_id = T4.student_id"
        ],
        "rule_sql": [
            "SELECT T1.last_name\nFROM Students T1\nJOIN Addresses T2 ON T1.current_address_id = T2.address_id\nWHERE T2.state_province_county = 'NorthCarolina'\nEXCEPT\nSELECT T3.last_name\nFROM Students T3\nJOIN Student_Enrolment T4 ON T3.student_id = T4.student_id"
        ]
    },
    "590": {
        "db_id": "tvshow",
        "question": "What is the number of cartoones written by Joseph Kuhr?",
        "ground_truth": "SELECT count(*) FROM Cartoon WHERE Written_by = \"Joseph Kuhr\";",
        "amends": [
            "Do reference the table as `Cartoon` instead of `cartoons` and use the column name `Written_by` instead of `writer` for the filter condition, while maintaining the same aggregate `count(*)` functionality. The amended query now correctly matches the RIGHT_SQL's behavior by using the proper table and column names from the schema."
        ],
        "rules": [
            "1) When the question mentions \"cartoons\": the exact table name is \"Cartoon\" with double quotes. 2) When the question mentions \"written by Joseph Kuhr\": the exact column name is \"Written_by\" with double quotes and the exact literal value is 'Joseph Kuhr'. 3) When counting entities from table \"Cartoon\": use the canonical key \"Written_by\" for counting operations."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cartoons WHERE writer = 'Joseph Kuhr';",
            "SELECT COUNT(*) FROM Cartoon WHERE Written_by = 'Joseph Kuhr'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM \"Cartoon\" WHERE \"Written_by\" = 'Joseph Kuhr';"
        ]
    },
    "779": {
        "db_id": "world_1",
        "question": "Return the country codes for countries that do not speak English.",
        "ground_truth": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  \"English\"",
        "amends": [
            "Do use `EXCEPT` to exclude countries where English is spoken instead of selecting countries where English is spoken. Do reference `CountryCode` with proper case instead of `countrycode` with lowercase. Do use double quotes for string literal `\"English\"` instead of single quotes. Do remove the `WHERE` clause filtering for English language instead of keeping it, as the logic now excludes rather than includes English-speaking countries. The amended query correctly identifies countries where English is not spoken by excluding those where it is spoken, matching the intended behavior.",
            "Do select `CountryCode` from `countrylanguage` instead of `Code` from `country` in the first query. Do remove the incorrect table reference to `country` and instead use `countrylanguage` as the source table for the initial selection. Do maintain the `EXCEPT` operation with the subquery that filters for `Language = \"English\"` from the same `countrylanguage` table instead of mixing different tables. The amended query now correctly identifies countries that don't speak English by comparing within the same dataset rather than across unrelated tables, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about countries that do not speak English: use EXCEPT to exclude countries where English is spoken instead of selecting countries where English is spoken. 2) When referring to the country code column: use \"CountryCode\" with proper case instead of lowercase \"countrycode\". 3) When handling the English language literal: use double quotes for \"English\" instead of single quotes. 4) When excluding English-speaking countries: remove the WHERE clause filtering for English language as the logic now excludes rather than includes English-speaking countries.",
            "1) When answering about countries that do not speak English: select \"CountryCode\" from \"countrylanguage\" table. 2) When filtering for countries that don't speak English: use EXCEPT operation with a subquery that filters for \"Language\" = \"English\" from the same \"countrylanguage\" table. 3) When comparing country codes: ensure both parts of the EXCEPT operation use the same \"CountryCode\" column from the \"countrylanguage\" table rather than mixing different tables. 4) When handling text literals: use exact literal \"English\" with proper case and double quotes for the language comparison."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT countrycode FROM countrylanguage WHERE language = 'English';",
            "SELECT Code FROM country EXCEPT SELECT CountryCode FROM countrylanguage WHERE Language = \"English\"",
            "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE Language = \"English\""
        ],
        "rule_sql": [
            "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE Language = \"English\""
        ]
    },
    "636": {
        "db_id": "tvshow",
        "question": "What are the countries that are not playing cartoons written by Todd Casey?",
        "ground_truth": "SELECT country FROM TV_Channel EXCEPT SELECT T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.written_by  =  'Todd Casey'",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do query from `TV_Channel` table instead of `countries` table. Do join `cartoon` table on `T1.id = T2.Channel` instead of joining multiple tables through `movies` and `writers`. Do filter on `T2.written_by = 'Todd Casey'` instead of checking `m.genre = 'Cartoon' AND p.name = 'Todd Casey'`. Do remove `DISTINCT` from the main query since `EXCEPT` inherently eliminates duplicates. Do remove the subquery structure entirely in favor of the set operation approach. The amended query now correctly identifies countries from TV_Channel that don't have cartoons written by Todd Casey, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about countries not playing cartoons written by Todd Casey: query from the \"TV_Channel\" table instead of \"countries\" table. 2) When combining TV_Channel and cartoon tables: link rows where T1.id = T2.Channel and keep only matching pairs (inner match). 3) When filtering for cartoons written by Todd Casey: use the exact literal 'Todd Casey' for T2.written_by. 4) When using set operations to find countries not in a set: use EXCEPT operation instead of NOT IN with subqueries. 5) When eliminating duplicates in set operations: do not use DISTINCT since EXCEPT inherently eliminates duplicates. 6) When producing output: return the country column from TV_Channel table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT country \nFROM countries \nWHERE country NOT IN (\n    SELECT DISTINCT c.country \n    FROM countries c\n    JOIN movies m ON c.movie_id = m.id\n    JOIN writers w ON m.id = w.movie_id\n    JOIN people p ON w.person_id = p.id\n    WHERE m.genre = 'Cartoon' AND p.name = 'Todd Casey'\n)",
            "SELECT Country FROM TV_Channel\nEXCEPT\nSELECT T1.Country FROM TV_Channel T1\nJOIN Cartoon T2 ON T1.id = T2.Channel\nWHERE T2.Written_by = 'Todd Casey'"
        ],
        "rule_sql": [
            "SELECT Country FROM TV_Channel\nEXCEPT\nSELECT T1.Country\nFROM TV_Channel T1\nINNER JOIN Cartoon T2 ON T1.id = T2.Channel\nWHERE T2.Written_by = 'Todd Casey'"
        ]
    },
    "754": {
        "db_id": "world_1",
        "question": "What are the countries where either English or Dutch is the official language ?",
        "ground_truth": "select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  \"english\" and isofficial  =  \"t\" union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  \"dutch\" and isofficial  =  \"t\"",
        "amends": [
            "Do select `t1.name` from `country` instead of `country` from `languages`. Do use `JOIN` with `countrylanguage` on `t1.code = t2.countrycode` instead of querying a single table. Do filter for `language = \"english\"` and `isofficial = \"t\"` in separate UNION branches instead of impossible `language = 'English' AND language = 'Dutch'` condition. Do add `UNION` to combine results for English and Dutch official languages instead of attempting to find both languages in one row. Do remove the incorrect table reference and impossible WHERE condition instead of keeping them. The amended query now correctly finds countries with English or Dutch as official languages through proper table joins and union operation.",
            "Do use double quotes `\"english\"` and `\"dutch\"` instead of single quotes `'English'` and `'Dutch'` for string literals. Do reference `isofficial` directly instead of qualifying it with `t2.` as `t2.IsOfficial`. Do add explicit `AS` keyword for table aliases as `country AS t1` instead of omitting it. Do use consistent lowercase for column names like `name` and `code` instead of mixed case. The amended query now correctly matches the RIGHT_SQL's behavior with proper string quoting and unqualified column reference."
        ],
        "rules": [
            "1) When answering about countries where English or Dutch is the official language: select \"t1\".\"name\" from the \"country\" table instead of \"country\" from \"languages\". 2) When combining country and language information: use JOIN with \"countrylanguage\" table on \"t1\".\"code\" = \"t2\".\"countrycode\" to link countries with their languages. 3) When filtering for official languages: check for \"language\" = \"english\" and \"isofficial\" = \"t\" in separate UNION branches instead of trying to find both languages in one row. 4) When the question asks for countries with either English or Dutch as official language: use UNION to combine results for both language conditions instead of using AND between different language values. 5) When handling text literals: use exact values \"english\" (lowercase) and \"t\" for the official status indicator as shown in the schema.",
            "1) When the question mentions \"English\" or \"Dutch\" as languages: use exact string literals \"english\" and \"dutch\" in lowercase with double quotes. 2) When checking if a language is official: reference the column \"isofficial\" directly without table qualification. 3) When joining tables: use explicit AS keyword for table aliases as \"country AS t1\" instead of omitting it. 4) When referencing column names: use consistent lowercase for columns like \"name\" and \"code\" instead of mixed case."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM languages WHERE language = 'English' AND language = 'Dutch';",
            "SELECT t1.Name \nFROM country t1\nJOIN countrylanguage t2 ON t1.Code = t2.CountryCode\nWHERE t2.Language = 'English' AND t2.IsOfficial = 'T'\nUNION\nSELECT t1.Name \nFROM country t1\nJOIN countrylanguage t2 ON t1.Code = t2.CountryCode\nWHERE t2.Language = 'Dutch' AND t2.IsOfficial = 'T'",
            "SELECT t1.name \nFROM country AS t1 \nJOIN countrylanguage AS t2 ON t1.code = t2.countrycode \nWHERE t2.language = \"english\" AND t2.isofficial = \"T\"\nUNION\nSELECT t1.name \nFROM country AS t1 \nJOIN countrylanguage AS t2 ON t1.code = t2.countrycode \nWHERE t2.language = \"dutch\" AND t2.isofficial = \"T\""
        ],
        "rule_sql": [
            "SELECT t1.name \nFROM country AS t1 \nJOIN countrylanguage AS t2 ON t1.code = t2.countrycode \nWHERE t2.language = \"english\" AND t2.isofficial = \"t\"\nUNION\nSELECT t1.name \nFROM country AS t1 \nJOIN countrylanguage AS t2 ON t1.code = t2.countrycode \nWHERE t2.language = \"dutch\" AND t2.isofficial = \"t\""
        ]
    },
    "988": {
        "db_id": "dog_kennels",
        "question": "What is the age of the oldest dog?",
        "ground_truth": "SELECT max(age) FROM Dogs",
        "amends": [
            "Do use `max(age)` instead of `MIN(age)` to find the maximum age instead of the minimum age. Do capitalize `Dogs` instead of `dogs` to match the correct table name case. The amended query now correctly returns the maximum age from the Dogs table instead of the minimum age."
        ],
        "rules": [
            "1) When the question asks for the \"oldest\" dog: use max(age) instead of min(age) to find the maximum age. 2) When referring to the table containing dog information: use the exact table name \"Dogs\" with capital D, not \"dogs\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(age) FROM dogs;",
            "SELECT MAX(age) FROM Dogs;"
        ],
        "rule_sql": [
            "SELECT MAX(age) AS oldest_age FROM Dogs;"
        ]
    },
    "167": {
        "db_id": "car_1",
        "question": "Among the cars with more than lowest horsepower, which ones do not have more than 3 cylinders? List the car makeid and make name.",
        "ground_truth": "SELECT T2.MakeId ,  T2.Make FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Horsepower  >  (SELECT min(Horsepower) FROM CARS_DATA) AND T1.Cylinders  <=  3;",
        "amends": [
            "Do join `CAR_NAMES AS T2` on `T1.Id = T2.MakeId` instead of querying only the `cars` table. Do reference columns with table aliases `T1.Horsepower` and `T1.Cylinders` instead of unqualified column names. Do use the correct table name `CARS_DATA AS T1` instead of `cars`. Do include the `Make` column instead of `make_name`. The amended query now correctly joins the data and names tables with proper column references, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When querying about car makes: join table \"CARS_DATA AS T1\" with table \"CAR_NAMES AS T2\" where T1.Id equals T2.MakeId to get complete car information. 2) When filtering cars by horsepower: compare T1.Horsepower to be greater than the minimum horsepower from all cars. 3) When filtering by cylinder count: ensure T1.Cylinders is not more than 3 cylinders. 4) When selecting output columns: include both T1.makeid and T2.Make (not make_name) in the results. 5) When referencing columns: always use table aliases T1 for CARS_DATA columns and T2 for CAR_NAMES columns with proper qualification."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT makeid, make_name \nFROM cars \nWHERE horsepower > (SELECT MIN(horsepower) FROM cars) \nAND cylinders <= 3;",
            "SELECT T2.MakeId, T2.Make \nFROM CARS_DATA AS T1 \nJOIN CAR_NAMES AS T2 ON T1.Id = T2.MakeId \nWHERE T1.Horsepower > (SELECT MIN(Horsepower) FROM CARS_DATA) \nAND T1.Cylinders <= 3"
        ],
        "rule_sql": [
            "SELECT T1.Id AS makeid, T2.Make \nFROM CARS_DATA AS T1 \nJOIN CAR_NAMES AS T2 ON T1.Id = T2.MakeId \nWHERE T1.Horsepower > (SELECT MIN(Horsepower) FROM CARS_DATA) \nAND T1.Cylinders <= 3"
        ]
    },
    "500": {
        "db_id": "battle_death",
        "question": "What is the ship id and name that caused most total injuries?",
        "ground_truth": "SELECT T2.id ,  T2.name FROM death AS T1 JOIN ship AS t2 ON T1.caused_by_ship_id  =  T2.id GROUP BY T2.id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.id` and `T2.name` instead of `ship_id` and `name`. Do use `FROM death AS T1 JOIN ship AS t2` instead of `FROM ships`. Do add `ON T1.caused_by_ship_id = T2.id` join condition instead of omitting it. Do add `GROUP BY T2.id` instead of omitting grouping. Do order by `count(*) DESC` instead of `total_injuries DESC`. The amended query now correctly identifies the ship with the most deaths by joining death records to ship data and counting occurrences, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"ship id and name that caused most total injuries\": make sure the output order: T2.id, T2.name. 2) When the question mentions \"ship id\" and \"name\": \"ship id\" actually means \"T2.id in schema\" and \"name\" actually means \"T2.name in schema\". 3) When combining death AS T1 and ship AS T2 for shared entities: link rows where T1.caused_by_ship_id = T2.id exactly as shown; keep only matching pairs (inner match). 4) When the question asks for \"most total injuries\" (which means deaths): organize results by T2.id and compute count(*) per group. 5) When the question mentions \"most\" or \"highest\": rank rows by count(*) in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ship_id, name FROM ships ORDER BY total_injuries DESC LIMIT 1;",
            "SELECT T2.id, T2.name\nFROM death AS T1\nJOIN ship AS T2 ON T1.caused_by_ship_id = T2.id\nGROUP BY T2.id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.id, T2.name\nFROM death AS T1\nINNER JOIN ship AS T2 ON T1.caused_by_ship_id = T2.id\nGROUP BY T2.id, T2.name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "843": {
        "db_id": "orchestra",
        "question": "What are the names of conductors who have conducted at more than one orchestra?",
        "ground_truth": "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID GROUP BY T2.Conductor_ID HAVING COUNT(*)  >  1",
        "amends": [
            "Do select `T1.Name` with table alias qualification instead of just `name` without source specification. Do join `conductor AS T1` with `orchestra AS T2` on `T1.Conductor_ID = T2.Conductor_ID` instead of querying only the `conductors` table without any join. Do add `GROUP BY T2.Conductor_ID` to group by the conductor identifier instead of missing aggregation grouping. Do move the count filter to `HAVING COUNT(*) > 1` instead of using `WHERE orchestra_count > 1` which incorrectly references a non-existent column. The amended query now correctly counts orchestra associations per conductor and filters for those conducting multiple orchestras, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"names of conductors who have conducted at more than one orchestra\": make sure the output order: T1.Name. 2) When combining T1 and T2 for shared entities: link rows where T1.Conductor_ID = T2.Conductor_ID exactly as shown; keep only matching pairs (inner match). 3) When the question asks for \"count of orchestra associations per conductor\": compute the number of orchestras using COUNT(*) grouped by T2.Conductor_ID. 4) When filtering for conductors with more than one orchestra: apply the condition COUNT(*) > 1 in the HAVING clause instead of WHERE. 5) When selecting conductor names: use T1.Name with table alias qualification instead of unqualified name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM conductors WHERE orchestra_count > 1;",
            "SELECT T1.Name\nFROM conductor AS T1\nJOIN orchestra AS T2 ON T1.Conductor_ID = T2.Conductor_ID\nGROUP BY T1.Conductor_ID\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T1.Name\nFROM conductor T1\nINNER JOIN orchestra T2 ON T1.Conductor_ID = T2.Conductor_ID\nGROUP BY T1.Conductor_ID\nHAVING COUNT(*) > 1\nORDER BY T1.Name"
        ]
    },
    "557": {
        "db_id": "student_transcripts_tracking",
        "question": "Who is the earliest graduate of the school? List the first name, middle name and last name.",
        "ground_truth": "SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_left ASC LIMIT 1",
        "amends": [
            "Do query the `Students` table instead of the `graduates` table. Do order by `date_left` instead of `graduation_date`. The amended query now correctly retrieves student records from the appropriate table using the correct date field for ordering."
        ],
        "rules": [
            "1) When answering about \"earliest graduate\": use the \"Students\" table instead of \"graduates\" table. 2) When ordering by graduation date to find the earliest graduate: order by \"date_left\" column in ascending order instead of \"graduation_date\". 3) When listing student names: include \"first_name\", \"middle_name\", and \"last_name\" columns from the \"Students\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, middle_name, last_name FROM graduates ORDER BY graduation_date ASC LIMIT 1;",
            "SELECT first_name, middle_name, last_name FROM Students WHERE date_left IS NOT NULL ORDER BY date_left ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT first_name, middle_name, last_name FROM Students WHERE date_left IS NOT NULL ORDER BY date_left ASC LIMIT 1;"
        ]
    },
    "1006": {
        "db_id": "singer",
        "question": "List the name of singers whose citizenship is not \"France\".",
        "ground_truth": "SELECT Name FROM singer WHERE Citizenship != \"France\"",
        "amends": [
            "Do reference the table as `singer` instead of `singers` and use the column name `Name` instead of `name`. Do use the inequality filter `!= \"France\"` instead of the equality filter `= 'France'` and reference the column as `Citizenship` instead of `citizenship`. The amended query now correctly selects names of singers who are not French citizens instead of those who are French citizens."
        ],
        "rules": [
            "1) When the question asks about singers: use the table name \"singer\" exactly as shown in the schema. 2) When the question mentions \"name\": use the column \"Name\" from the \"singer\" table. 3) When the question mentions \"citizenship\": use the column \"Citizenship\" from the \"singer\" table. 4) When filtering for singers whose citizenship is not \"France\": use the inequality condition != \"France\" (exact case and quotes) instead of equality."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers WHERE citizenship = 'France';",
            "SELECT Name FROM singer WHERE Citizenship != \"France\";"
        ],
        "rule_sql": [
            "SELECT Name FROM singer WHERE Citizenship != \"France\";"
        ]
    },
    "4": {
        "db_id": "concert_singer",
        "question": "What is the average, minimum, and maximum age of all singers from France?",
        "ground_truth": "SELECT avg(age) ,  min(age) ,  max(age) FROM singer WHERE country  =  'France'",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause. Do maintain the same aggregate functions `AVG(age)`, `MIN(age)`, and `MAX(age)` with identical column references. Do preserve the WHERE filter `country = 'France'` without changes. The amended query now correctly references the intended table while maintaining the same aggregation logic and filtering criteria, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"average, minimum, and maximum age of all singers from France\": make sure the output order: AVG(age), MIN(age), MAX(age). 2) When the question mentions \"singers\": \"singers\" actually means \"singer\" in schema. 3) When the question mentions \"from France\": use the exact literal value 'France' for the country filter. 4) When computing aggregates on age: use the exact column name \"age\" from the singer table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age), MIN(age), MAX(age) FROM singers WHERE country = 'France';",
            "SELECT AVG(Age) AS average_age, MIN(Age) AS minimum_age, MAX(Age) AS maximum_age FROM singer WHERE Country = 'France';"
        ],
        "rule_sql": [
            "SELECT AVG(age), MIN(age), MAX(age) FROM singer WHERE Country = 'France';"
        ]
    },
    "310": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are all different template ids used for documents, and how many times were each of them used?",
        "ground_truth": "SELECT template_id ,  count(*) FROM Documents GROUP BY template_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_id, COUNT(*) FROM documents GROUP BY template_id;"
        ],
        "rule_sql": [
            "SELECT Template_ID, COUNT(*) AS Usage_Count FROM Documents WHERE Template_ID IS NOT NULL GROUP BY Template_ID ORDER BY Template_ID;"
        ]
    },
    "95": {
        "db_id": "car_1",
        "question": "Which model of the car has the minimum horsepower?",
        "ground_truth": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;",
        "amends": [
            "Do join `CAR_NAMES AS T1` and `CARS_DATA AS T2` on `T1.MakeId = T2.Id` instead of querying only the `cars` table. Do select `T1.Model` instead of `model` to reference the correct table. Do order by `T2.horsepower ASC` instead of `horsepower DESC` to get the minimum horsepower instead of maximum. The amended query now correctly retrieves the car model with the lowest horsepower by properly joining the car names and data tables."
        ],
        "rules": [
            "1) When answering about \"which model of the car has the minimum horsepower\": make sure the output order: T1.Model. 2) When combining CAR_NAMES as T1 and CARS_DATA as T2: link rows where T1.MakeId = T2.Id and keep only matching pairs (inner match). 3) When the question asks for minimum horsepower: order rows by T2.horsepower in ascending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model FROM cars ORDER BY horsepower DESC LIMIT 1;",
            "SELECT T1.Model FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id ORDER BY T2.Horsepower ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Model FROM car_names AS T1 INNER JOIN cars_data AS T2 ON T1.MakeId = T2.Id ORDER BY CAST(T2.Horsepower AS NUMERIC) ASC LIMIT 1"
        ]
    },
    "949": {
        "db_id": "dog_kennels",
        "question": "What are the cost and treatment type description of each treatment?",
        "ground_truth": "SELECT T1.cost_of_treatment ,  T2.treatment_type_description FROM Treatments AS T1 JOIN treatment_types AS T2 ON T1.treatment_type_code  =  T2.treatment_type_code",
        "amends": [
            "Do specify table aliases `T1.cost_of_treatment` and `T2.treatment_type_description` instead of unqualified `cost` and `treatment_type`. Do add `JOIN treatment_types AS T2` instead of querying only the `treatments` table. Do include the join condition `ON T1.treatment_type_code = T2.treatment_type_code` instead of omitting the necessary table relationship. The amended query now correctly joins the two related tables to retrieve the complete treatment information."
        ],
        "rules": [
            "1) When answering about \"cost and treatment type description of each treatment\": make sure the output order: T1.cost_of_treatment, T2.treatment_type_description. 2) When the question mentions \"cost\": \"cost\" actually means \"T1.cost_of_treatment\" in schema. 3) When the question mentions \"treatment type description\": \"treatment type description\" actually means \"T2.treatment_type_description\" in schema. 4) When combining T1 (treatments) and T2 (treatment_types) for shared entities: link rows where T1.treatment_type_code = T2.treatment_type_code exactly as shown in the amends; keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT cost, treatment_type FROM treatments;",
            "SELECT T1.cost_of_treatment, T2.treatment_type_description FROM Treatments AS T1 JOIN Treatment_Types AS T2 ON T1.treatment_type_code = T2.treatment_type_code"
        ],
        "rule_sql": [
            "SELECT T1.cost_of_treatment, T2.treatment_type_description\nFROM Treatments T1\nINNER JOIN Treatment_Types T2 ON T1.treatment_type_code = T2.treatment_type_code\nORDER BY T1.cost_of_treatment, T2.treatment_type_description;"
        ]
    },
    "800": {
        "db_id": "world_1",
        "question": "What are the names and areas of countries with the top 5 largest area?",
        "ground_truth": "SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5",
        "amends": [
            "Do use column name `Name` instead of `name` and `SurfaceArea` instead of `area` in the SELECT list. Do reference table `country` instead of `countries` in the FROM clause. The amended query now correctly references the proper column names and table to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"names and areas of countries with the top 5 largest area\": make sure the output order: Name, SurfaceArea. 2) When the question mentions \"countries\": \"countries\" actually means \"country\" in schema. 3) When the question mentions \"name\": \"name\" actually means \"Name\" in schema. 4) When the question mentions \"area\": \"area\" actually means \"SurfaceArea\" in schema. 5) When the question mentions \"top 5 largest area\": rank rows by SurfaceArea in descending order and keep the first 5 rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, area FROM countries ORDER BY area DESC LIMIT 5;",
            "SELECT Name, SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5"
        ],
        "rule_sql": [
            "SELECT Name, SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5"
        ]
    },
    "324": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the ids of templates that have the code PP or PPT.",
        "ground_truth": "SELECT template_id FROM Templates WHERE template_type_code  =  \"PP\" OR template_type_code  =  \"PPT\"",
        "amends": [
            "Do select `template_id` instead of `id` and use table name `Templates` instead of `templates`. Do filter on column `template_type_code` with values `\"PP\"` and `\"PPT\"` instead of column `code` with values `'PP'` and `'PPT'`. The amended query now correctly references the appropriate column names and table while maintaining the same filtering logic for template type codes."
        ],
        "rules": [
            "1) When the question asks for template ids: use the exact column name \"template_id\" from the Templates table. 2) When the question mentions templates: use the exact table name \"Templates\" with proper casing. 3) When the question asks for templates with code PP or PPT: filter on column \"template_type_code\" with exact values \"PP\" and \"PPT\" using double quotes. 4) When answering about template ids: make sure the output order: template_id."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM templates WHERE code = 'PP' OR code = 'PPT';",
            "SELECT Template_ID FROM Templates WHERE Template_Type_Code IN ('PP', 'PPT')"
        ],
        "rule_sql": [
            "SELECT template_id FROM Templates WHERE template_type_code = \"PP\" OR template_type_code = \"PPT\" ORDER BY template_id;"
        ]
    },
    "563": {
        "db_id": "student_transcripts_tracking",
        "question": "On average, when were the transcripts printed?",
        "ground_truth": "SELECT avg(transcript_date) FROM Transcripts",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(transcript_date) FROM transcripts;"
        ],
        "rule_sql": [
            "SELECT AVG(transcript_date) AS average_transcript_date FROM Transcripts;"
        ]
    },
    "291": {
        "db_id": "employee_hire_evaluation",
        "question": "Give me all the information about hiring.",
        "ground_truth": "SELECT * FROM hiring",
        "amends": [
            "Do query the `hiring` table instead of the `employees` table. Do remove the `WHERE hire_date IS NULL` filter instead of keeping it. The amended query now matches RIGHT_SQL's behavior by selecting all records from the correct table without any filtering conditions."
        ],
        "rules": [
            "1) When answering about \"hiring\": query the \"hiring\" table instead of the \"employees\" table. 2) When the question asks for \"all the information about hiring\": select all columns from the \"hiring\" table without any filtering conditions. 3) When the question does not specify any filtering criteria: do not apply any WHERE clause filters to the query."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM employees WHERE hire_date IS NULL;",
            "SELECT * FROM hiring;"
        ],
        "rule_sql": [
            "SELECT * FROM hiring;"
        ]
    },
    "229": {
        "db_id": "flight_2",
        "question": "Which airline has most number of flights?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `AIRLINES` and `FLIGHTS` tables with `JOIN` on `T1.uid = T2.Airline` instead of querying only `flights` without any table join. Do select `T1.Airline` instead of `airline` to reference the joined table explicitly. Do use `ORDER BY count(*) DESC` instead of `ORDER BY flight_count ASC` to sort by descending count rather than ascending. Do remove the alias `flight_count` from the SELECT clause instead of keeping it, as it's not needed in the ORDER BY. The amended query now correctly identifies airlines with their flight counts through proper table joining and returns the airline with the highest count rather than the lowest, matching the RIGHT_SQL's behavior.",
            "Do select only `T1.Airline` instead of selecting both `T1.Airline` and `COUNT(*)` in the SELECT list. Do maintain the same `JOIN` on `T1.uid=T2.Airline` without changing the join type or predicate. Do keep the `GROUP BY T1.Airline` and `ORDER BY count(*) DESC LIMIT 1` unchanged. The amended query now correctly returns only the airline name with the highest flight count instead of both the airline and count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"which airline has most number of flights\": make sure to join tables \"AIRLINES\" as T1 and \"FLIGHTS\" as T2 where T1.uid = T2.Airline. 2) When selecting the airline name: use T1.Airline instead of just airline. 3) When counting flights: count all rows from T2 using count(*). 4) When ordering results to find the highest count: sort by count(*) in descending order. 5) When limiting results to get the top result: take only the first row after descending ordering.",
            "1) When answering about \"which airline has most number of flights\": make sure the output order contains only the airline name column. 2) When combining airlines table T1 and flights table T2: link rows where T1.uid = T2.Airline exactly as shown and keep only matching pairs (inner match). 3) When counting flights per airline: compute the number of rows using the join relationship between T1 and T2. 4) When the question asks for the airline with the most flights: rank airlines by flight count in descending order and keep only the first row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airline, COUNT(*) as flight_count FROM flights GROUP BY airline ORDER BY flight_count ASC LIMIT 1;",
            "SELECT T1.Airline, COUNT(*) \nFROM airlines T1 \nJOIN flights T2 ON T1.uid = T2.Airline \nGROUP BY T1.Airline \nORDER BY COUNT(*) DESC \nLIMIT 1",
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Airline FROM airlines T1 JOIN flights T2 ON T1.uid = T2.Airline GROUP BY T1.Airline ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "543": {
        "db_id": "student_transcripts_tracking",
        "question": "Which semesters do not have any student enrolled? List the semester name.",
        "ground_truth": "SELECT semester_name FROM Semesters WHERE semester_id NOT IN( SELECT semester_id FROM Student_Enrolment )",
        "amends": [
            "Do use a subquery with `NOT IN` to filter `semester_id` values that don't exist in the `Student_Enrolment` table instead of checking for `student_count = 0`, which may not accurately reflect enrollment status. Do reference the correct table name `Semesters` (with capital S) instead of `semesters` to match the schema. The amended query now correctly identifies semesters with no student enrollments by checking for the absence of related records in the enrollment table rather than relying on a potentially incorrect count field."
        ],
        "rules": [
            "1) When the question asks about semesters without enrolled students: use a NOT IN condition with semester_id values from the Student_Enrolment table instead of checking student_count = 0. 2) When referencing the Semesters table: use the exact table name \"Semesters\" (with capital S) instead of \"semesters\". 3) When identifying semesters with no enrollments: check for absence of related records in Student_Enrolment table using semester_id as the linking key."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT semester_name FROM semesters WHERE student_count = 0;",
            "SELECT semester_name FROM Semesters WHERE semester_id NOT IN (SELECT DISTINCT semester_id FROM Student_Enrolment)"
        ],
        "rule_sql": [
            "SELECT semester_name FROM Semesters WHERE semester_id NOT IN (SELECT DISTINCT semester_id FROM Student_Enrolment)"
        ]
    },
    "292": {
        "db_id": "employee_hire_evaluation",
        "question": "What is all the information about hiring?",
        "ground_truth": "SELECT * FROM hiring",
        "amends": [
            "Do query the `hiring` table instead of the `employees` table. Do remove the `WHERE hire_date IS NULL` filter instead of keeping it. The amended query now matches RIGHT_SQL's behavior by selecting all records from the correct table without any filtering conditions."
        ],
        "rules": [
            "1) When answering about \"all the information about hiring\": query the \"hiring\" table instead of the \"employees\" table. 2) When the question asks for \"all the information\": select all columns from the table without any filtering conditions. 3) When the question mentions \"hiring\": \"hiring\" refers to the \"hiring\" table in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM employees WHERE hire_date IS NULL;",
            "SELECT * FROM hiring;"
        ],
        "rule_sql": [
            "SELECT * FROM hiring;"
        ]
    },
    "584": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the first names of the students who live in Haiti permanently or have the cell phone number 09700166582 ?",
        "ground_truth": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  'haiti' or t1.cell_mobile_number  =  '09700166582'",
        "amends": [
            "Do select `t1.first_name` from the `students` table with alias `t1` instead of `first_name` from `students` without an alias. Do add a `JOIN` with the `addresses` table as `t2` on `t1.permanent_address_id = t2.address_id` instead of querying only the `students` table. Do filter on `t2.country = 'haiti'` instead of `country = 'Haiti'` to reference the joined table's column with correct case. Do filter on `t1.cell_mobile_number = '09700166582'` instead of `phone_number = '09700166582'` to use the correct column name from the students table. The amended query now correctly joins address data and uses proper column references to match the intended logic."
        ],
        "rules": [
            "1) When selecting student first names: use t1.first_name from the students table with alias t1. 2) When the question mentions students who live in Haiti permanently: join the addresses table as t2 on t1.permanent_address_id = t2.address_id and filter on t2.country = 'haiti' (lowercase). 3) When the question mentions students with cell phone number 09700166582: filter on t1.cell_mobile_number = '09700166582' from the students table. 4) When combining both conditions: use OR logic between the permanent address condition and cell phone number condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE country = 'Haiti' OR phone_number = '09700166582';",
            "SELECT t1.first_name FROM Students t1 JOIN Addresses t2 ON t1.permanent_address_id = t2.address_id WHERE t2.country = 'haiti' OR t1.cell_mobile_number = '09700166582'"
        ],
        "rule_sql": [
            "SELECT t1.first_name\nFROM Students t1\nLEFT JOIN Addresses t2 ON t1.permanent_address_id = t2.address_id\nWHERE (t2.country = 'haiti') OR (t1.cell_mobile_number = '09700166582')"
        ]
    },
    "708": {
        "db_id": "world_1",
        "question": "Which continent is Anguilla in?",
        "ground_truth": "SELECT Continent FROM country WHERE Name  =  \"Anguilla\"",
        "amends": [
            "Do reference table `country` instead of `countries` in the FROM clause. Do use column `Continent` instead of `continent` in the SELECT list. Do use column `Name` instead of `name` in the WHERE filter. Do use double quotes `\"Anguilla\"` instead of single quotes for the string literal. The amended query now correctly references the proper table and column names to match the intended schema."
        ],
        "rules": [
            "1) When answering about \"which continent is Anguilla in\": make sure the output order: \"Continent\". 2) When the question mentions \"Anguilla\": \"Anguilla\" actually means \"Name\" in schema and must be matched exactly as \"Anguilla\". 3) When selecting from the country table: use double quotes for column names \"Name\" and \"Continent\" exactly as shown in the schema. 4) When filtering for a specific country name: use the exact string literal \"Anguilla\" with double quotes as specified in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT continent FROM countries WHERE name = 'Anguilla';",
            "SELECT Continent FROM country WHERE Name = \"Anguilla\";"
        ],
        "rule_sql": [
            "SELECT \"Continent\" FROM country WHERE \"Name\" = \"Anguilla\";"
        ]
    },
    "149": {
        "db_id": "car_1",
        "question": "Which makers designed more than 3 car models? List full name and the id.",
        "ground_truth": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;",
        "amends": [
            "Do join `MODEL_LIST` as `T2` on `T1.Id = T2.Maker` instead of querying only `car_makers` without any join. Do use `T1.FullName` and `T1.Id` instead of `maker_name` and `maker_id`. Do move the count filter to `HAVING count(*) > 3` instead of incorrectly placing `COUNT(model_id) > 3` in the `WHERE` clause. Do add proper table aliases with `AS T1` and `AS T2` instead of omitting them. The amended query now correctly counts models per maker and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"makers designed more than 3 car models\": make sure the output order: T1.FullName, T1.Id\n2) When combining car_makers (T1) and MODEL_LIST (T2) for shared entities: link rows where T1.Id = T2.Maker exactly as shown in the amends; keep only matching pairs (inner match)\n3) When the question asks for \"count of car models per maker\": compute the number of rows using the grouping by T1.Id and count models per group\n4) When filtering for makers with more than 3 models: apply the count filter after grouping using count(*) > 3 instead of in the WHERE clause\n5) When selecting maker information: use T1.FullName and T1.Id instead of maker_name and maker_id as these are the exact column tokens from the schema"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT maker_name, maker_id FROM car_makers WHERE COUNT(model_id) > 3 GROUP BY maker_id;",
            "SELECT T1.FullName, T1.Id\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id, T1.FullName\nHAVING COUNT(*) > 3"
        ],
        "rule_sql": [
            "SELECT T1.FullName, T1.Id\nFROM car_makers T1\nINNER JOIN model_list T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id, T1.FullName\nHAVING COUNT(*) > 3\nORDER BY T1.FullName, T1.Id"
        ]
    },
    "576": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the id of the semester that had both Masters and Bachelors students enrolled?",
        "ground_truth": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'",
        "amends": [
            "Do use `DISTINCT T2.semester_id` instead of `semester_id` without distinct. Do change the FROM clause to join `Degree_Programs AS T1` with `Student_Enrolment AS T2` on `T1.degree_program_id = T2.degree_program_id` instead of querying only `enrollments`. Do replace the WHERE condition with `degree_summary_name = 'Master'` in one branch and `degree_summary_name = 'Bachelor'` in another instead of the impossible `student_type = 'Masters' AND student_type = 'Bachelors'`. Do use `INTERSECT` between two queries to find common semester_ids instead of attempting to find rows that satisfy both conditions simultaneously. Do remove the incorrect table reference `enrollments` and add the correct tables `Degree_Programs` and `Student_Enrolment` with proper join conditions. The amended query now correctly finds semester IDs that have both Master's and Bachelor's students by intersecting results from two separate queries targeting each degree type."
        ],
        "rules": [
            "1) When answering about semesters with both Masters and Bachelors students: use DISTINCT T2.semester_id to avoid duplicate semester IDs in the output. 2) When combining Degree_Programs and Student_Enrolment tables: link rows where T1.degree_program_id = T2.degree_program_id and keep only matching pairs (inner join). 3) When filtering for Master's degree students: use condition degree_summary_name = 'Master' with exact case and spelling. 4) When filtering for Bachelor's degree students: use condition degree_summary_name = 'Bachelor' with exact case and spelling. 5) When finding semesters with both degree types: use INTERSECT between two separate queries to find common semester_ids that satisfy both conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT semester_id FROM enrollments WHERE student_type = 'Masters' AND student_type = 'Bachelors';",
            "SELECT DISTINCT T2.semester_id\nFROM Degree_Programs AS T1\nJOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id\nWHERE T1.degree_summary_name = 'Master'\nINTERSECT\nSELECT DISTINCT T2.semester_id\nFROM Degree_Programs AS T1\nJOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id\nWHERE T1.degree_summary_name = 'Bachelor'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.semester_id\nFROM Degree_Programs T1\nINNER JOIN Student_Enrolment T2 ON T1.degree_program_id = T2.degree_program_id\nWHERE T1.degree_summary_name = 'Master'\nINTERSECT\nSELECT DISTINCT T2.semester_id\nFROM Degree_Programs T1\nINNER JOIN Student_Enrolment T2 ON T1.degree_program_id = T2.degree_program_id\nWHERE T1.degree_summary_name = 'Bachelor'"
        ]
    },
    "991": {
        "db_id": "dog_kennels",
        "question": "List each charge type and its amount.",
        "ground_truth": "SELECT charge_type ,  charge_amount FROM Charges",
        "amends": [
            "Do select the `charge_amount` column directly instead of using `SUM(amount)` aggregation. Do reference the table as `Charges` instead of `charges` with proper case sensitivity. Do remove the `GROUP BY charge_type` clause instead of keeping it since no aggregation is needed. The amended query now correctly retrieves individual charge records with their type and amount values rather than attempting to sum amounts by type."
        ],
        "rules": [
            "1) When the question asks to list charge types and amounts: select the exact column \"charge_amount\" from table \"Charges\" without any aggregation. 2) When referencing the table name: use exact case-sensitive identifier \"Charges\" instead of lowercase \"charges\". 3) When no aggregation is requested: do not use GROUP BY clauses or aggregate functions like SUM(). 4) When retrieving individual records: return each charge record with its type and amount values directly from the table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT charge_type, SUM(amount) FROM charges GROUP BY charge_type",
            "SELECT charge_type, charge_amount FROM Charges;"
        ],
        "rule_sql": [
            "SELECT charge_type, charge_amount FROM Charges;"
        ]
    },
    "164": {
        "db_id": "car_1",
        "question": "What is the number of carsw ith over 6 cylinders?",
        "ground_truth": "SELECT COUNT(*) FROM CARS_DATA WHERE Cylinders  >  6;",
        "amends": [
            "Do reference the `CARS_DATA` table instead of the `cars` table. Do use the correct column name `Cylinders` instead of `cylinders`. The amended query now correctly counts records from the CARS_DATA table where the Cylinders value exceeds 6, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"number of cars with over 6 cylinders\": make sure the output order: count of cars. 2) When the question mentions \"cars\": \"cars\" actually means \"CARS_DATA\" in schema. 3) When the question mentions \"cylinders\": \"cylinders\" actually means \"Cylinders\" in schema. 4) When counting cars: compute the number of rows using the canonical key for cars (CARS_DATA table records). 5) When filtering for \"over 6 cylinders\": select records where Cylinders > 6."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE cylinders > 6;",
            "SELECT COUNT(*) FROM cars_data WHERE Cylinders > 6"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM cars_data WHERE Cylinders > 6"
        ]
    },
    "827": {
        "db_id": "orchestra",
        "question": "Return the names of conductors that do not have the nationality \"USA\".",
        "ground_truth": "SELECT Name FROM conductor WHERE Nationality != 'USA'",
        "amends": [
            "Do reference table `conductor` instead of `conductors` and use column `Name` instead of `name`. Do use filter condition `Nationality != 'USA'` instead of `nationality = 'USA'` to select non-US conductors instead of US conductors. The amended query now correctly references the proper table and column names while fixing the filter logic to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks about conductors: use table \"conductor\" instead of \"conductors\" and column \"Name\" instead of \"name\". 2) When the question asks for conductors that do not have USA nationality: use filter condition \"Nationality != 'USA'\" instead of \"nationality = 'USA'\". 3) When producing output: return only the \"Name\" column from the \"conductor\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM conductors WHERE nationality = 'USA';",
            "SELECT Name FROM conductor WHERE Nationality != 'USA';"
        ],
        "rule_sql": [
            "SELECT Name FROM conductor WHERE Nationality != 'USA';"
        ]
    },
    "218": {
        "db_id": "flight_2",
        "question": "Return the number of United Airlines flights leaving from AHD Airport.",
        "ground_truth": "SELECT count(*) FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T2.Airline  =  T1.uid WHERE T1.Airline  =  \"United Airlines\" AND T2.SourceAirport  =  \"AHD\"",
        "amends": [
            "Do join `AIRLINES` and `FLIGHTS` tables with an `INNER JOIN` on `T2.Airline = T1.uid` instead of querying only the `flights` table. Do filter on `T1.Airline = \"United Airlines\"` instead of `airline = 'United Airlines'` to reference the correct table and column. Do filter on `T2.SourceAirport = \"AHD\"` instead of `departure_airport = 'AHD'` to use the proper column name and table reference. Do use double quotes for string literals instead of single quotes to match the database's expected format. The amended query now correctly joins the airline and flight data and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"number of United Airlines flights leaving from AHD Airport\": make sure the output order: count of flights\n2) When the question mentions \"United Airlines\": \"United Airlines\" actually means \"T1.Airline = \\\"United Airlines\\\"\" in schema\n3) When the question mentions \"leaving from AHD Airport\": \"AHD Airport\" actually means \"T2.SourceAirport = \\\"AHD\\\"\" in schema\n4) When combining T1 and T2 for shared entities: link rows where T2.Airline = T1.uid exactly as shown in the amends; keep only matching pairs (inner match)\n5) When the question asks for \"count of flights\": compute the number of rows using the canonical key token for flights\n6) When handling text literals: do not change case, spacing, or punctuation - use exact literals \\\"United Airlines\\\" and \\\"AHD\\\"\n7) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms - use double quotes for identifiers and literals"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'United Airlines' AND departure_airport = 'AHD'",
            "SELECT COUNT(*) \nFROM airlines T1 \nINNER JOIN flights T2 ON T2.Airline = T1.uid \nWHERE T1.Airline = \"United Airlines\" AND T2.SourceAirport = \"AHD\""
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS \"count of flights\"\nFROM flights T2\nJOIN airlines T1 ON T2.Airline = T1.uid\nWHERE T1.Airline = \"United Airlines\" AND T2.SourceAirport = \"AHD\""
        ]
    },
    "648": {
        "db_id": "poker_player",
        "question": "Count the number of poker players.",
        "ground_truth": "SELECT count(*) FROM poker_player",
        "amends": [
            "Do reference the `poker_player` table instead of the `players` table. Do remove the `WHERE game_type = 'blackjack'` filter instead of keeping it. The amended query now correctly counts all records from the poker_player table without any filtering conditions."
        ],
        "rules": [
            "1) When counting poker players: use the \"poker_player\" table instead of the \"players\" table. 2) When counting all poker players: do not apply any filtering conditions like \"game_type = 'blackjack'\". 3) When counting entities: count all records from the specified table without any restrictions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE game_type = 'blackjack';",
            "SELECT COUNT(*) FROM poker_player;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM poker_player;"
        ]
    },
    "578": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the different addresses that have students living there?",
        "ground_truth": "SELECT count(DISTINCT current_address_id) FROM Students",
        "amends": [
            "Do use `count(DISTINCT current_address_id)` instead of `SELECT DISTINCT address` to count unique addresses rather than listing them. Do reference `current_address_id` instead of `address` to use the correct column identifier. Do remove the `WHERE student_id IS NOT NULL` filter instead of keeping it since the count should include all students regardless of student_id status. Do change from selecting distinct values to counting distinct values to return a single aggregate result instead of a list of individual addresses."
        ],
        "rules": [
            "1) When the question asks for \"different addresses that have students living there\": use count(DISTINCT current_address_id) instead of SELECT DISTINCT address to count unique addresses rather than listing them. 2) When referencing addresses in the Students table: use current_address_id instead of address as the correct column identifier. 3) When counting addresses with students: remove any WHERE student_id IS NOT NULL filter since the count should include all students regardless of student_id status. 4) When the question asks for a count of distinct addresses: change from selecting distinct values to counting distinct values to return a single aggregate result instead of a list of individual addresses."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT address FROM students WHERE student_id IS NOT NULL",
            "SELECT COUNT(DISTINCT current_address_id) FROM Students;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT current_address_id) FROM Students;"
        ]
    },
    "273": {
        "db_id": "employee_hire_evaluation",
        "question": "Return the name, location and district of all shops in descending order of number of products.",
        "ground_truth": "SELECT name ,  LOCATION ,  district FROM shop ORDER BY number_products DESC",
        "amends": [
            "Do reference the correct table name `shop` instead of `shops` in the FROM clause. Do order by the column `number_products` instead of the aggregate function `COUNT(products)` which cannot be used in ORDER BY without GROUP BY. Do maintain the same column selection of `name`, `location`, and `district` without changes. The amended query now correctly references the existing table and orders by the appropriate product count column instead of attempting to use an aggregate function improperly."
        ],
        "rules": [
            "1) When the question mentions \"shops\": use the exact table name \"shop\" instead of \"shops\". 2) When ordering by number of products in descending order: use the column \"number_products\" directly instead of attempting to count products. 3) When selecting output columns: maintain the exact column order \"name\", \"location\", and \"district\" as specified in the question. 4) When producing the result set: sort all rows by \"number_products\" in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, location, district FROM shops ORDER BY COUNT(products) DESC;",
            "SELECT Name, Location, District FROM shop ORDER BY Number_products DESC;"
        ],
        "rule_sql": [
            "SELECT name, location, district FROM shop ORDER BY number_products DESC;"
        ]
    },
    "642": {
        "db_id": "tvshow",
        "question": "What are the ids of all tv channels that have more than 2 TV channels?",
        "ground_truth": "SELECT id FROM tv_channel GROUP BY country HAVING count(*)  >  2",
        "amends": [
            "Do select `id` from `tv_channel` instead of `tv_channels`. Do add `GROUP BY country` and `HAVING count(*) > 2` instead of using `WHERE id > 2`. Do remove the incorrect table name `tv_channels` and replace it with `tv_channel`. The amended query now correctly aggregates by country and filters groups with more than 2 records instead of filtering individual records by ID value, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"ids of all tv channels that have more than 2 TV channels\": group results by \"country\" and count the number of records per group. 2) When counting TV channels per country: use the count of all records in each group. 3) When filtering groups: only include groups where the count is greater than 2. 4) When selecting output: return the \"id\" column from the \"tv_channel\" table. 5) When referring to table names: use exact identifier \"tv_channel\" instead of \"tv_channels\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM tv_channels WHERE id > 2;",
            "SELECT id FROM TV_Channel GROUP BY Country HAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT id FROM tv_channel GROUP BY Country HAVING COUNT(*) > 2"
        ]
    },
    "604": {
        "db_id": "tvshow",
        "question": "How many TV Channels use the English language?",
        "ground_truth": "SELECT count(*) FROM TV_Channel WHERE LANGUAGE = \"English\";",
        "amends": [
            "Do reference table `TV_Channel` instead of `channels` while keeping the same count aggregation and English language filter, maintaining identical query behavior with the amended table name."
        ],
        "rules": [
            "1) When answering about \"TV Channels\": use table \"TV_Channel\" instead of \"channels\". 2) When the question mentions \"English language\": filter for rows where \"language\" equals exactly 'English'. 3) When the question asks for \"how many TV Channels\": count the number of rows in \"TV_Channel\" that satisfy the language condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM channels WHERE language = 'English';",
            "SELECT COUNT(*) FROM TV_Channel WHERE Language = 'English';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM TV_Channel WHERE Language = 'English';"
        ]
    },
    "1022": {
        "db_id": "singer",
        "question": "Show the names of singers that have more than one song.",
        "ground_truth": "SELECT T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID GROUP BY T1.Name HAVING COUNT(*)  >  1",
        "amends": [
            "Do add table `song` with a `JOIN` on `singer.Singer_ID = song.Singer_ID` instead of querying only the `singers` table. Do change the source to `singer AS T1` instead of `singers`. Do use `GROUP BY T1.Name` with `HAVING COUNT(*) > 1` instead of filtering `song_count > 1` in the `WHERE` clause. Do select `T1.Name` with proper table qualification instead of just `name`. The amended query now correctly counts songs per singer and filters for those with more than one song, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"singers that have more than one song\": make sure the output order: T1.Name\n2) When the question mentions \"singers\": \"singers\" actually means \"singer AS T1\" in schema\n3) When the question mentions \"more than one song\": count songs using COUNT(*) per singer and filter for COUNT(*) > 1\n4) When combining T1 and song for shared entities: link rows where T1.Singer_ID = song.Singer_ID; keep only matching pairs (inner match)\n5) When the question asks for \"names of singers\": select T1.Name with proper table qualification instead of just name\n6) When the question says \"per singer\"/\"by singer\": organize results by T1.Name and compute requested aggregates per group"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers WHERE song_count > 1;",
            "SELECT T1.Name FROM singer AS T1 JOIN song ON T1.Singer_ID = song.Singer_ID GROUP BY T1.Name HAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T1.Name\nFROM singer AS T1\nINNER JOIN song ON T1.Singer_ID = song.Singer_ID\nGROUP BY T1.Name\nHAVING COUNT(*) > 1\nORDER BY T1.Name"
        ]
    },
    "375": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the document id with least number of paragraphs?",
        "ground_truth": "SELECT document_id FROM Paragraphs GROUP BY document_id ORDER BY count(*) ASC LIMIT 1",
        "amends": [
            "Do use `GROUP BY document_id` instead of omitting it, which enables proper aggregation. Do use `count(*)` instead of `COUNT(paragraph_id)` in the ORDER BY clause to count all rows per group rather than non-null paragraph_id values. Do move the aggregate function from the ORDER BY clause to operate on grouped results instead of attempting to use COUNT directly without grouping. The amended query now correctly groups by document_id and orders by the count of paragraphs per document to find the document with the fewest paragraphs, matching the intended behavior.",
            "Do remove `paragraph_count` alias from the SELECT list instead of including it, and do reference the aggregate function directly in ORDER BY as `count(*)` instead of using the alias `paragraph_count`. Do omit the explicit column alias in the SELECT clause instead of defining it, since the RIGHT_SQL does not include this alias in the output. The amended query now matches RIGHT_SQL's behavior by returning only document_id values ordered by the actual count of paragraphs without an intermediate alias."
        ],
        "rules": [
            "1) When answering about \"document id with least number of paragraphs\": make sure the output order: document_id. 2) When the question asks for \"least number of paragraphs\" per document: organize results by document_id and compute count of paragraphs per group. 3) When counting paragraphs per document: compute the number of rows using count(*) for each document_id group. 4) When finding the document with the minimum paragraph count: rank rows by paragraph count in ascending order and keep the first 1 row.",
            "1) When counting paragraphs per document: count the number of rows using the canonical key for paragraphs (count(*)) instead of using an alias. 2) When ordering by paragraph count: reference the aggregate function count(*) directly in the ORDER BY clause instead of using an alias. 3) When selecting output columns: include only document_id in the SELECT list and omit any alias for the count. 4) When finding the document with the least number of paragraphs: order by count(*) in ascending order and keep only the first result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id FROM paragraphs ORDER BY COUNT(paragraph_id) ASC LIMIT 1;",
            "SELECT document_id, COUNT(*) as paragraph_count FROM Paragraphs GROUP BY document_id ORDER BY paragraph_count ASC LIMIT 1;",
            "SELECT document_id FROM Paragraphs GROUP BY document_id ORDER BY count(*) ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT document_id FROM Paragraphs GROUP BY document_id ORDER BY COUNT(*) ASC LIMIT 1;"
        ]
    },
    "467": {
        "db_id": "wta_1",
        "question": "find the names of loser and winner who played in the match with greatest number of minutes.",
        "ground_truth": "SELECT winner_name ,  loser_name FROM matches ORDER BY minutes DESC LIMIT 1",
        "amends": [
            "Do select `winner_name` and `loser_name` columns instead of `loser` and `winner`. The amended query now correctly retrieves the specified name columns while maintaining the same ordering and limiting behavior."
        ],
        "rules": [
            "1) When the question asks for \"names of loser and winner\": use the exact column tokens \"loser_name\" and \"winner_name\" from the matches table instead of \"loser\" and \"winner\". 2) When the question asks for the match with the \"greatest number of minutes\": order the results by the \"minutes\" column in descending order and take only the first row."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT loser, winner FROM matches ORDER BY minutes DESC LIMIT 1;",
            "SELECT winner_name, loser_name FROM matches ORDER BY minutes DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT loser_name, winner_name FROM matches ORDER BY minutes DESC LIMIT 1;"
        ]
    },
    "897": {
        "db_id": "network_1",
        "question": "What are the names of students who have no friends?",
        "ground_truth": "SELECT name FROM Highschooler EXCEPT SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id",
        "amends": [
            "Do use `EXCEPT` to find students without friends instead of filtering for `friend_count = 0`. Do add a subquery with `JOIN` between `Friend` and `Highschooler` tables on `T1.student_id = T2.id` instead of omitting this relationship entirely. Do reference the correct table `Highschooler` instead of the non-existent `students` table. Do remove the incorrect `WHERE friend_count = 0` filter instead of keeping it, as the right approach identifies students without entries in the Friend table rather than relying on a potentially missing or incorrect friend_count column. The amended query now correctly identifies students with no friends by excluding those who appear in the Friend relationship table.",
            "Do use `EXCEPT` with a join-based subquery instead of `NOT IN` with a union of two columns. Do reference `T2.name` from the joined `Highschooler` table instead of directly selecting from the main table. Do join `Friend AS T1` with `Highschooler AS T2` on `T1.student_id = T2.id` instead of using a union subquery that combines both sides of the friendship relationship. Do remove the union operation that was incorrectly treating both sides of the friendship symmetrically. The amended query now correctly identifies students who have no friends by excluding those who appear as either side in the Friend table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for students with no friends: use an EXCEPT operation to find students who are not present in the Friend relationship table instead of filtering on a friend_count column. 2) When combining Highschooler and Friend tables: link rows where T1.student_id = T2.id to identify friendship relationships. 3) When referencing student information: use the Highschooler table instead of a non-existent students table. 4) When identifying students without friends: exclude those who appear in the Friend table rather than relying on a potentially missing or incorrect friend_count column.",
            "1) When answering about \"students who have no friends\": make sure the output order: T2.name 2) When combining Friend table as T1 and Highschooler table as T2: link rows where T1.student_id = T2.id and keep only matching pairs (inner match) 3) When identifying students with no friends: exclude students who appear in either T1.student_id or T1.friend_id from the Friend table using EXCEPT operation 4) When selecting student names: reference T2.name from the joined Highschooler table instead of directly from the main table"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM students WHERE friend_count = 0;",
            "SELECT name FROM Highschooler WHERE ID NOT IN (SELECT student_id FROM Friend UNION SELECT friend_id FROM Friend)",
            "SELECT name FROM Highschooler\nEXCEPT\nSELECT T2.name \nFROM Friend AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID"
        ],
        "rule_sql": [
            "SELECT name FROM Highschooler\nEXCEPT\nSELECT T2.name \nFROM Friend AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.id"
        ]
    },
    "474": {
        "db_id": "wta_1",
        "question": "How many players are from each country?",
        "ground_truth": "SELECT count(*) ,  country_code FROM players GROUP BY country_code",
        "amends": [
            "Do use `country_code` instead of `country` in both the SELECT list and GROUP BY clause. Do place the aggregate function `count(*)` first in the SELECT list instead of second. The amended query now correctly groups by and selects the country_code field, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"players from each country\": use \"country_code\" instead of \"country\" in both the output and grouping. 2) When counting players per country: place the count result first in the output order before the country_code. 3) When grouping by country: use the exact token \"country_code\" for grouping and output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country, COUNT(*) FROM players GROUP BY country;",
            "SELECT count(*) as player_count, country_code FROM players GROUP BY country_code;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS player_count, country_code FROM players GROUP BY country_code ORDER BY player_count DESC;"
        ]
    },
    "793": {
        "db_id": "world_1",
        "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?",
        "ground_truth": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2",
        "amends": [
            "Do use `COUNT(T2.Language)` instead of `COUNT(language.language)` to reference the correct table alias. Do use table aliases `T1` and `T2` instead of full table names throughout the query. Do reference `T1.Name` in the SELECT list instead of `country.name` for consistency with aliases. Do specify `T1.Code = T2.CountryCode` in the JOIN condition instead of `country.code = countrylanguage.countrycode` using proper aliases. Do use `COUNT(*) > 2` in the HAVING clause instead of `language_count > 2` to directly reference the aggregate function rather than the column alias. The amended query now correctly counts languages per country using proper table aliases and direct aggregate references in the HAVING clause.",
            "Do place `COUNT(T2.Language)` before `T1.Name` in the SELECT list instead of the reverse order. Do remove the `AS language_count` alias instead of keeping it. Do remove the `ORDER BY language_count DESC` clause instead of including it. The amended query now matches RIGHT_SQL's behavior by maintaining the same logical grouping and filtering while removing the ordering and column alias.",
            "Do place `COUNT(T2.Language)` first in the SELECT list instead of `T1.Name` first. Do use `COUNT(*)` in the HAVING clause instead of `COUNT(T2.Language)` to count all rows rather than non-null language values specifically. The amended query now correctly counts all country-language relationships and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"names of countries that speak more than 2 languages\": make sure the output order: T1.Name, COUNT(T2.Language) 2) When combining T1 and T2 for shared entities: link rows where T1.Code = T2.CountryCode; keep only matching pairs (inner match) 3) When the question asks for \"how many languages they speak\": compute the number of rows using COUNT(T2.Language) 4) When the question says \"per country\"/\"by country\": organize results by T1.Name and compute COUNT(T2.Language) per group 5) When filtering for countries that speak more than 2 languages: apply the condition COUNT(*) > 2 after grouping",
            "1) When answering about \"names of countries that speak more than 2 languages, as well as how many languages they speak\": make sure the output order: COUNT(T2.Language) first, then T1.Name. 2) When the question asks for \"how many languages they speak\": compute the count of T2.Language without using an alias. 3) When the question asks for results without ordering: do not include any ORDER BY clause in the output.",
            "1) When answering about \"names of countries that speak more than 2 languages, as well as how many languages they speak\": make sure the output order: COUNT(T2.Language) first, then T1.Name. 2) When counting languages spoken by countries: use COUNT(*) in the HAVING clause instead of COUNT(T2.Language) to count all rows rather than non-null language values specifically."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country.name, COUNT(language.language) as language_count \nFROM country \nJOIN countrylanguage ON country.code = countrylanguage.countrycode \nGROUP BY country.name \nHAVING language_count > 2;",
            "SELECT T1.Name, COUNT(T2.Language) AS language_count\nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Name\nHAVING COUNT(*) > 2\nORDER BY language_count DESC;",
            "SELECT T1.Name, COUNT(T2.Language) \nFROM country T1 \nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nGROUP BY T1.Name \nHAVING COUNT(T2.Language) > 2",
            "SELECT COUNT(T2.Language), T1.Name \nFROM country T1 \nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nGROUP BY T1.Code \nHAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT COUNT(*), country.Name FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode GROUP BY country.Name HAVING COUNT(*) > 2"
        ]
    },
    "802": {
        "db_id": "world_1",
        "question": "What are names of countries with the top 3 largest population?",
        "ground_truth": "SELECT Name FROM country ORDER BY Population DESC LIMIT 3",
        "amends": [
            "Do select `Name` instead of `name` to match the correct column case. Do order by `Population DESC` instead of `population ASC` to sort by descending population rather than ascending. Do use table `country` instead of `countries` to reference the correct table name. The amended query now correctly returns the top 3 countries by population in descending order."
        ],
        "rules": [
            "1) When the question asks for country names: use column \"Name\" from table \"country\" instead of \"name\" from other tables. 2) When the question asks for \"top 3 largest population\": order by column \"Population\" in descending order to get the highest values first. 3) When the question asks for top K results: limit the output to exactly 3 rows after proper ordering."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM countries ORDER BY population ASC LIMIT 3;",
            "SELECT Name FROM country ORDER BY Population DESC LIMIT 3"
        ],
        "rule_sql": [
            "SELECT Name FROM country ORDER BY Population DESC LIMIT 3"
        ]
    },
    "485": {
        "db_id": "wta_1",
        "question": "How many different winners both participated in the WTA Championships and were left handed?",
        "ground_truth": "SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  'WTA Championships' AND winner_hand  =  'L'",
        "amends": [
            "Do count `DISTINCT winner_name` instead of `COUNT(*)` to count unique winners rather than all records. Do select from `matches` table instead of joining `players` and `championships` tables to use the correct data source. Do filter on `tourney_name = 'WTA Championships'` instead of `c.tournament = 'WTA Championships'` to use the proper tournament column name. Do filter on `winner_hand = 'L'` instead of `p.handedness = 'left'` to use the correct hand designation column and value. The amended query now correctly counts distinct left-handed winners of the WTA Championships tournament."
        ],
        "rules": [
            "1) When counting different winners: count distinct \"winner_name\" values instead of counting all records. 2) When answering about WTA Championships participants: use the \"matches\" table as the data source instead of joining \"players\" and \"championships\" tables. 3) When filtering for WTA Championships tournament: use \"tourney_name = 'WTA Championships'\" as the filter condition. 4) When filtering for left-handed players: use \"winner_hand = 'L'\" as the filter condition instead of 'left'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM players p\nJOIN championships c ON p.player_id = c.player_id\nWHERE p.handedness = 'left' AND c.tournament = 'WTA Championships';",
            "SELECT COUNT(DISTINCT winner_name) \nFROM matches \nWHERE tourney_name = 'WTA Championships' \nAND winner_hand = 'L'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT winner_name) \nFROM matches \nWHERE tourney_name = 'WTA Championships' \nAND winner_hand = 'L'"
        ]
    },
    "454": {
        "db_id": "wta_1",
        "question": "What is the first name and country code of the oldest player?",
        "ground_truth": "SELECT first_name ,  country_code FROM players ORDER BY birth_date LIMIT 1",
        "amends": [
            "Do order by `birth_date` instead of `age` in the ORDER BY clause, as the correct logic requires sorting by birth date rather than age to achieve the intended result. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the \"oldest player\": sort players by birth_date in ascending order (earliest birth date first) to find the oldest player. 2) When ordering results to find the oldest player: use the \"birth_date\" column instead of \"age\" for accurate chronological ordering. 3) When selecting output columns for player information: include \"first_name\" and \"country_code\" as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, country_code FROM players ORDER BY age ASC LIMIT 1;",
            "SELECT first_name, country_code FROM players ORDER BY birth_date ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT first_name, country_code FROM players ORDER BY birth_date ASC LIMIT 1;"
        ]
    },
    "771": {
        "db_id": "world_1",
        "question": "For the countries founded before 1930, what is the total number of distinct official languages?",
        "ground_truth": "SELECT count(DISTINCT T2.Language) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE  IndepYear  <  1930 AND T2.IsOfficial  =  \"T\"",
        "amends": [
            "Do join `country` and `countrylanguage` tables with `INNER JOIN` on `T1.Code = T2.CountryCode` instead of querying only the `countries` table. Do filter on `IndepYear < 1930` instead of `year_founded < 1930` and add the condition `T2.IsOfficial = \"T\"` instead of omitting it. Do select `count(DISTINCT T2.Language)` from the joined table structure instead of `COUNT(DISTINCT language)` from a single table. The amended query now correctly counts distinct official languages for countries founded before 1930 by properly joining the relevant tables and applying the official language filter."
        ],
        "rules": [
            "1) When answering about \"countries founded before 1930\": use the condition \"T1.IndepYear < 1930\" instead of \"year_founded < 1930\". 2) When counting distinct official languages: join \"country\" table as T1 and \"countrylanguage\" table as T2 using \"T1.Code = T2.CountryCode\" with inner match. 3) When filtering for official languages: add the condition \"T2.IsOfficial = \\\"T\\\"\" to only count languages marked as official. 4) When counting distinct languages: use \"count(DISTINCT T2.Language)\" from the joined table structure."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT language) FROM countries WHERE year_founded < 1930;",
            "SELECT COUNT(DISTINCT T2.Language) \nFROM country T1 \nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T1.IndepYear < 1930 \nAND T2.IsOfficial = 'T'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T2.Language) \nFROM country T1 \nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T1.IndepYear < 1930 \nAND T2.IsOfficial = \"T\""
        ]
    },
    "857": {
        "db_id": "orchestra",
        "question": "What are the record companies that are used by both orchestras founded before 2003 and those founded after 2003?",
        "ground_truth": "SELECT Record_Company FROM orchestra WHERE Year_of_Founded  <  2003 INTERSECT SELECT Record_Company FROM orchestra WHERE Year_of_Founded  >  2003",
        "amends": [
            "Do use `INTERSECT` to find common record companies instead of a self-join with distinct. Do reference `Year_of_Founded` instead of `founded_year` for the column name. Do filter with separate conditions in each branch instead of combining them in a single WHERE clause. Do use the table name `orchestra` instead of `orchestras`. Do remove the table aliases `o1` and `o2` instead of keeping them. Do select from the same table twice with different filters instead of joining on record_company. The amended query now correctly identifies record companies that have orchestras founded both before and after 2003 by finding the intersection between the two sets."
        ],
        "rules": [
            "1) When the question asks for record companies used by both orchestras founded before 2003 and after 2003: use INTERSECT to find common values between two sets instead of a self-join with DISTINCT. 2) When referencing the founding year column: use the exact column name \"Year_of_Founded\" instead of \"founded_year\". 3) When filtering orchestras by founding year: apply separate conditions in each branch of the INTERSECT operation instead of combining them in a single WHERE clause. 4) When selecting from the orchestra table: use the exact table name \"orchestra\" instead of \"orchestras\". 5) When constructing the query: do not use table aliases o1 and o2, instead select from the same table twice with different filters."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT r1.record_company\nFROM orchestras o1\nJOIN orchestras o2 ON o1.record_company = o2.record_company\nWHERE o1.founded_year < 2003 AND o2.founded_year > 2003;",
            "SELECT Record_Company FROM orchestra WHERE Year_of_Founded < 2003\nINTERSECT\nSELECT Record_Company FROM orchestra WHERE Year_of_Founded > 2003"
        ],
        "rule_sql": [
            "SELECT Record_Company FROM orchestra WHERE Year_of_Founded < 2003\nINTERSECT\nSELECT Record_Company FROM orchestra WHERE Year_of_Founded > 2003"
        ]
    },
    "31": {
        "db_id": "concert_singer",
        "question": "Show names for all stadiums except for stadiums having a concert in year 2014.",
        "ground_truth": "SELECT name FROM stadium EXCEPT SELECT T2.name FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.year  =  2014",
        "amends": [
            "Do use `EXCEPT` to filter out stadiums with concerts in 2014 instead of a simple inequality filter on year. Do add a join between `concert` and `stadium` tables on `stadium_id` instead of querying only the `stadiums` table. Do include the condition `T1.year = 2014` to specifically exclude stadiums hosting concerts in that year instead of filtering stadiums by their own year attribute. Do reference the correct table name `stadium` instead of `stadiums` throughout the query. The amended query now correctly identifies stadiums that did not host any concerts in 2014, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks to exclude stadiums having concerts in a specific year: use EXCEPT to filter out stadiums that match the exclusion condition instead of simple inequality filtering. 2) When combining stadium and concert information: link rows where T1.stadium_id = T2.stadium_id to connect concerts to their stadiums. 3) When excluding stadiums with concerts in 2014: specifically exclude stadiums where T1.year = 2014 to target concerts from that exact year. 4) When referring to the stadium table: use the exact table name \"stadium\" instead of \"stadiums\" throughout the query. 5) When producing output: return only the \"name\" column from the stadium table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM stadiums WHERE year != 2014;",
            "SELECT Name FROM stadium EXCEPT SELECT s.Name FROM stadium s JOIN concert c ON s.Stadium_ID = c.Stadium_ID WHERE c.Year = '2014'"
        ],
        "rule_sql": [
            "SELECT Name FROM stadium EXCEPT SELECT s.Name FROM stadium s JOIN concert c ON s.Stadium_ID = c.Stadium_ID WHERE c.Year = '2014'"
        ]
    },
    "974": {
        "db_id": "dog_kennels",
        "question": "How many dogs have an age below the average?",
        "ground_truth": "SELECT count(*) FROM Dogs WHERE age  <  ( SELECT avg(age) FROM Dogs )",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM dogs WHERE age < (SELECT AVG(age) FROM dogs WHERE age IS NOT NULL);"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS count_dogs_below_avg_age\nFROM Dogs\nWHERE CAST(age AS REAL) < (SELECT AVG(CAST(age AS REAL)) FROM Dogs WHERE age IS NOT NULL AND age != '');"
        ]
    },
    "656": {
        "db_id": "poker_player",
        "question": "Return the money rank of the player with the greatest earnings.",
        "ground_truth": "SELECT Money_Rank FROM poker_player ORDER BY Earnings DESC LIMIT 1",
        "amends": [
            "Do select `Money_Rank` directly instead of using `MAX(money_rank)` aggregation. Do query from `poker_player` table instead of `players` table. Do remove the WHERE clause with subquery that finds maximum earnings instead of keeping it. Do add `ORDER BY Earnings DESC` to sort by highest earnings instead of omitting ordering. Do add `LIMIT 1` to return only the top row instead of using aggregation and subquery. The amended query now correctly retrieves the money rank of the player with the highest earnings by sorting and limiting rather than using complex aggregation with subqueries."
        ],
        "rules": [
            "1) When answering about \"money rank of the player with the greatest earnings\": make sure the output order: Money_Rank. 2) When the question mentions \"players\": \"players\" actually means \"poker_player\" in schema. 3) When the question asks for the player with \"greatest earnings\": sort rows by Earnings in descending order and keep the first 1 row. 4) When selecting the money rank: select Money_Rank directly without aggregation functions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(money_rank) FROM players WHERE earnings = (SELECT MAX(earnings) FROM players);",
            "SELECT Money_Rank FROM poker_player ORDER BY Earnings DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Money_Rank FROM poker_player ORDER BY Earnings DESC LIMIT 1"
        ]
    },
    "720": {
        "db_id": "world_1",
        "question": "What is the name of country that has the shortest life expectancy in Asia?",
        "ground_truth": "SELECT Name FROM country WHERE Continent  =  \"Asia\" ORDER BY LifeExpectancy LIMIT 1",
        "amends": [
            "Do use `Name` instead of `name` for the column selection to match the correct case sensitivity. Do use `Continent` instead of `continent` for the WHERE filter column reference. Do use double quotes `\"Asia\"` instead of single quotes for the string literal. Do use `LifeExpectancy` instead of `lifeexpectancy` in the ORDER BY clause. Do remove the `DESC` modifier from the ORDER BY clause to sort in ascending order instead of descending order. The amended query now correctly selects the country with the lowest life expectancy in Asia rather than the highest."
        ],
        "rules": [
            "1) When the question asks for a country name: use the exact column token \"Name\" from table country (not \"name\"). 2) When filtering for countries in Asia: use the exact column token \"Continent\" and the exact literal value \"Asia\" with double quotes. 3) When ordering by life expectancy to find the shortest: use the exact column token \"LifeExpectancy\" and sort in ascending order (lowest values first). 4) When finding the single country with the shortest life expectancy: take only the first row after ordering by LifeExpectancy in ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM country WHERE continent = 'Asia' ORDER BY lifeexpectancy DESC LIMIT 1;",
            "SELECT Name FROM country WHERE Continent = \"Asia\" ORDER BY LifeExpectancy ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Name FROM country WHERE Continent = \"Asia\" ORDER BY LifeExpectancy ASC LIMIT 1"
        ]
    },
    "512": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the descriptions for all the math courses?",
        "ground_truth": "SELECT course_description FROM Courses WHERE course_name  =  'math'",
        "amends": [
            "Do select `course_description` instead of `*` from the SELECT list. Do reference table `Courses` instead of `courses` in the FROM clause. Do filter on `course_name = 'math'` instead of `subject = 'math'` in the WHERE clause. The amended query now correctly retrieves only the course description for math courses from the properly referenced Courses table."
        ],
        "rules": [
            "1) When answering about \"descriptions for math courses\": make sure the output order: course_description. 2) When the question mentions \"math courses\": \"math\" actually means \"course_name = 'math'\" in schema. 3) When selecting from the courses table: reference the table as \"Courses\" (with exact case and quotes) instead of \"courses\". 4) When filtering for specific courses: use the exact literal value 'math' (lowercase) for the course_name condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM courses WHERE subject = 'math';",
            "SELECT course_description FROM Courses WHERE course_name = 'math'"
        ],
        "rule_sql": [
            "SELECT course_description FROM \"Courses\" WHERE course_name = 'math'"
        ]
    },
    "909": {
        "db_id": "network_1",
        "question": "What are the names of students who have 2 or more likes?",
        "ground_truth": "SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id HAVING count(*)  >=  2",
        "amends": [
            "Do select `T2.name` from the joined table instead of `name` from a single table. Do join `Likes AS T1` with `Highschooler AS T2` on `T1.student_id = T2.id` instead of querying a single `students` table. Do use `GROUP BY T1.student_id` with `HAVING count(*) >= 2` instead of a simple `WHERE likes >= 2` filter. Do completely restructure the query to properly count relationships through the Likes table instead of assuming a direct likes column. The amended query now correctly identifies students who have at least two likes by joining the appropriate tables and using aggregate counting."
        ],
        "rules": [
            "1) When answering about \"names of students who have 2 or more likes\": make sure the output order: T2.name. 2) When the question mentions \"students\": \"students\" actually means \"Highschooler AS T2\" in schema. 3) When the question mentions \"likes\": \"likes\" actually means \"relationships in Likes AS T1\" in schema. 4) When combining T1 and T2 for shared entities: link rows where T1.student_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match). 5) When the question asks for \"count of likes per student\": compute the number of rows using the canonical key T1.student_id with GROUP BY T1.student_id. 6) When filtering for \"2 or more likes\": use HAVING count(*) >= 2 instead of a simple WHERE condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM students WHERE likes >= 2",
            "SELECT T2.name \nFROM Likes AS T1 \nJOIN Highschooler AS T2 ON T1.student_id = T2.ID \nGROUP BY T1.student_id \nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.ID GROUP BY T1.student_id HAVING COUNT(*) >= 2 ORDER BY T2.name;"
        ]
    },
    "222": {
        "db_id": "flight_2",
        "question": "Which city has the most frequent destination airport?",
        "ground_truth": "SELECT T1.City FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport GROUP BY T1.City ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `FLIGHTS` table on `AirportCode=DestAirport` instead of querying only the `airports` table. Do select `City` instead of both `city` and `flight_count`. Do aggregate by counting all flights per city instead of counting airports per city. Do order by the flight count in descending order instead of ordering by the airport count. The amended query now correctly identifies cities with the most flight destinations by joining airport data with flight records and counting actual flights rather than airport occurrences."
        ],
        "rules": [
            "1) When answering about \"most frequent destination airport by city\": make sure the output order: City\n2) When the question mentions \"destination airport\": \"destination airport\" actually means \"DestAirport in FLIGHTS table\"\n3) When combining airports and FLIGHTS tables: link rows where airports.AirportCode = FLIGHTS.DestAirport exactly as shown in the amends; keep only matching pairs (inner match).\n4) When the question asks for \"most frequent\": rank cities by flight count in descending order and keep the first 1 row.\n5) When the question asks for \"count of flights per city\": compute the number of rows using the FLIGHTS table records per City grouping.\n6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms.\n7) When handling text literals: do not change case, spacing, or punctuation from the schema sample values like 'Aberdeen '."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, COUNT(*) as flight_count FROM airports GROUP BY city ORDER BY flight_count DESC LIMIT 1;",
            "SELECT a.City, COUNT(*) AS flight_count\nFROM flights f\nJOIN airports a ON f.DestAirport = a.AirportCode\nGROUP BY a.City\nORDER BY flight_count DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT a.City\nFROM airports a\nJOIN flights f ON a.AirportCode = f.DestAirport\nGROUP BY a.City\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "982": {
        "db_id": "dog_kennels",
        "question": "How many professionals did not operate any treatment on dogs?",
        "ground_truth": "SELECT count(*) FROM Professionals WHERE professional_id NOT IN ( SELECT professional_id FROM Treatments )",
        "amends": [
            "Do remove the `WHERE animal_type = 'dog'` filter from the subquery instead of keeping it, as the correct logic requires checking for professionals not in any treatments regardless of animal type. Do use consistent table name casing `Professionals` instead of `professionals` to match the schema. The amended query now correctly counts professionals who have not provided any treatments, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about professionals who did not operate any treatment: check for professionals not in any treatments regardless of animal type, not just treatments for dogs. 2) When referring to the Professionals table: use the exact identifier \"Professionals\" with proper casing as shown in the schema. 3) When counting professionals who provided no treatments: use the professional_id as the counting key to identify unique professionals."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM professionals WHERE professional_id NOT IN (SELECT professional_id FROM treatments WHERE animal_type = 'dog')",
            "SELECT COUNT(*) \nFROM Professionals p\nLEFT JOIN Treatments t ON p.professional_id = t.professional_id\nWHERE t.treatment_id IS NULL;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Professionals p\nWHERE p.professional_id NOT IN (\n    SELECT DISTINCT professional_id \n    FROM Treatments\n)"
        ]
    },
    "301": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the document name and template id for document with description with the letter 'w' in it?",
        "ground_truth": "SELECT document_name ,  template_id FROM Documents WHERE Document_Description LIKE \"%w%\"",
        "amends": [
            "Do reference the `Documents` table instead of `documents` to match the correct table name. Do use `Document_Description` column instead of `description` to reference the correct column name for the description field. Do use double quotes for the pattern matching instead of single quotes to maintain consistency with the right SQL format. The amended query now correctly filters documents based on the description containing 'w' and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When referencing the Documents table: use the exact table name \"Documents\" with double quotes and capital D. 2) When filtering by document description: use the exact column name \"Document_Description\" with double quotes and capital D and capital D. 3) When pattern matching for text containing the letter 'w': use double quotes around the pattern \"%w%\" for consistency with the SQL format. 4) When selecting document information: include both \"document_name\" and \"template_id\" columns in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_name, template_id FROM documents WHERE description LIKE '%w%';",
            "SELECT Document_Name, Template_ID FROM Documents WHERE Document_Description LIKE '%w%'"
        ],
        "rule_sql": [
            "SELECT \"document_name\", \"template_id\" FROM \"Documents\" WHERE \"Document_Description\" LIKE \"%w%\""
        ]
    },
    "435": {
        "db_id": "wta_1",
        "question": "Find the average age of losers and winners of all matches.",
        "ground_truth": "SELECT avg(loser_age) ,  avg(winner_age) FROM matches",
        "amends": [
            "Do select `avg(loser_age)` and `avg(winner_age)` instead of a single `AVG(age)` aggregate. Do remove the `WHERE result = 'loser' OR result = 'winner'` filter instead of keeping it, as the right query calculates separate averages for both loser and winner ages directly from the table columns without filtering. The amended query now correctly computes two distinct average values for loser_age and winner_age columns instead of attempting to average a single age column with conditional filtering, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When calculating average age for both losers and winners: compute separate averages for \"loser_age\" and \"winner_age\" columns instead of a single aggregate. 2) When the question asks for average age of both losers and winners: output both average values in the result without any filtering conditions. 3) When handling match results: do not use any WHERE clause filtering based on result values like 'loser' or 'winner' since the required data is available directly in separate columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age) FROM matches WHERE result = 'loser' OR result = 'winner';",
            "SELECT AVG(loser_age) AS avg_loser_age, AVG(winner_age) AS avg_winner_age FROM matches"
        ],
        "rule_sql": [
            "SELECT AVG(loser_age) AS avg_loser_age, AVG(winner_age) AS avg_winner_age FROM matches;"
        ]
    },
    "547": {
        "db_id": "student_transcripts_tracking",
        "question": "What's the name of the course with most number of enrollments?",
        "ground_truth": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `JOIN Student_Enrolment_Courses AS T2 ON T1.course_id = T2.course_id` instead of querying only the `courses` table. Do add `GROUP BY T1.course_name` instead of omitting grouping. Do change `ORDER BY count(*) DESC` instead of `ORDER BY enrollment_count ASC` to order by actual enrollment count rather than a static column. Do use `count(*)` instead of `enrollment_count` to dynamically calculate enrollments from the join. Do add table alias `T1` for `Courses` instead of using the table name directly. The amended query now correctly identifies the most popular course by counting actual student enrollments rather than relying on a potentially outdated static enrollment_count column."
        ],
        "rules": [
            "1) When answering about \"course with most number of enrollments\": make sure to join Courses as T1 with Student_Enrolment_Courses as T2 using T1.course_id = T2.course_id to get actual enrollment data. 2) When counting enrollments per course: use count(*) instead of a static enrollment_count column to dynamically calculate enrollments from the join. 3) When grouping results by course: use GROUP BY T1.course_name to organize results by each course. 4) When ordering by enrollment count: use ORDER BY count(*) DESC instead of ASC to find the course with the highest enrollment. 5) When selecting the top course: use LIMIT 1 to return only the course with the most enrollments."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_name FROM courses ORDER BY enrollment_count ASC LIMIT 1;",
            "SELECT T1.course_name\nFROM Courses AS T1\nJOIN Student_Enrolment_Courses AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_name\nORDER BY count(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.course_name\nFROM Courses AS T1\nJOIN Student_Enrolment_Courses AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "421": {
        "db_id": "museum_visit",
        "question": "What are the id and name of the museum visited most times?",
        "ground_truth": "SELECT t2.Museum_ID ,  t1.name FROM museum AS t1 JOIN visit AS t2 ON t1.Museum_ID  =  t2.Museum_ID GROUP BY t2.Museum_ID ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `t2.Museum_ID` and `t1.name` instead of `museum_id` and `name`. Do join `museum AS t1` with `visit AS t2` on `t1.Museum_ID = t2.Museum_ID` instead of querying only the `museums` table. Do add `GROUP BY t2.Museum_ID` instead of omitting grouping. Do order by `count(*) DESC` instead of `visit_count DESC` to count actual visits. The amended query now correctly identifies the museum with the most visits by joining the museum and visit tables and counting occurrences."
        ],
        "rules": [
            "1) When answering about \"museum visited most times\": make sure the output order: t2.Museum_ID, t1.name 2) When combining museum and visit tables: link rows where t1.Museum_ID = t2.Museum_ID and keep only matching pairs (inner match) 3) When the question asks for \"most times\": rank rows by count(*) in descending direction and keep the first 1 row 4) When counting visits: compute the number of rows using the canonical key t2.Museum_ID for grouping 5) When selecting museum identifier and name: use t2.Museum_ID and t1.name exactly as specified"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT museum_id, name FROM museums ORDER BY visit_count DESC LIMIT 1;",
            "SELECT t2.Museum_ID, t1.Name\nFROM museum AS t1\nJOIN visit AS t2 ON t1.Museum_ID = t2.Museum_ID\nGROUP BY t2.Museum_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t2.Museum_ID, t1.Name\nFROM museum t1\nINNER JOIN visit t2 ON t1.Museum_ID = t2.Museum_ID\nGROUP BY t2.Museum_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "681": {
        "db_id": "poker_player",
        "question": "Show names of people whose nationality is not \"Russia\".",
        "ground_truth": "SELECT Name FROM people WHERE Nationality != \"Russia\"",
        "amends": [
            "Do use `Name` instead of `name` for the column selection to match the correct case sensitivity. Do use `!=` instead of `=` in the WHERE clause to filter for people who are not from Russia instead of those who are from Russia. Do use double quotes `\"Russia\"` instead of single quotes `'Russia'` for the string literal. The amended query now correctly excludes Russian nationals instead of including them, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting the name column from the people table: use the exact column name \"Name\" with proper case sensitivity instead of \"name\". 2) When filtering for people whose nationality is not \"Russia\": use the inequality operator (!=) instead of equality operator (=) to exclude Russian nationals. 3) When using the string literal \"Russia\": use double quotes \"Russia\" instead of single quotes 'Russia' to match the required literal format."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM people WHERE nationality = 'Russia';",
            "SELECT Name FROM people WHERE Nationality != \"Russia\""
        ],
        "rule_sql": [
            "SELECT Name FROM people WHERE Nationality != \"Russia\";"
        ]
    },
    "35": {
        "db_id": "concert_singer",
        "question": "List singer names and number of concerts for each singer.",
        "ground_truth": "SELECT T2.name ,  count(*) FROM singer_in_concert AS T1 JOIN singer AS T2 ON T1.singer_id  =  T2.singer_id GROUP BY T2.singer_id",
        "amends": [
            "Do select `T2.name` instead of `singer_name` and join `singer_in_concert AS T1` with `singer AS T2` on `T1.singer_id = T2.singer_id` instead of querying `singers` directly, then group by `T2.singer_id` instead of `singer_id` to correctly count concerts per singer while preserving the intended aggregation logic."
        ],
        "rules": [
            "1) When the question asks for \"singer names\": use \"T2.name\" as the exact output column for singer names. 2) When counting concerts per singer: join \"singer_in_concert AS T1\" with \"singer AS T2\" where \"T1.singer_id = T2.singer_id\" to link concerts to singers. 3) When grouping to count concerts per singer: group by \"T2.singer_id\" to ensure correct aggregation per singer. 4) When computing number of concerts: count the rows using the canonical key from the concert table to get the concert count per singer."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT singer_name, COUNT(*) FROM singers GROUP BY singer_id;",
            "SELECT T2.Name, COUNT(T1.concert_ID) AS number_of_concerts\nFROM singer_in_concert AS T1\nJOIN singer AS T2 ON T1.Singer_ID = T2.Singer_ID\nGROUP BY T2.Singer_ID"
        ],
        "rule_sql": [
            "SELECT T2.Name, COUNT(T1.concert_ID) AS NumberOfConcerts FROM singer_in_concert AS T1 JOIN singer AS T2 ON T1.Singer_ID = T2.Singer_ID GROUP BY T2.Singer_ID"
        ]
    },
    "272": {
        "db_id": "employee_hire_evaluation",
        "question": "What are the minimum and maximum number of products across all the shops?",
        "ground_truth": "SELECT min(Number_products) ,  max(Number_products) FROM shop",
        "amends": [
            "Do reference the correct column name `Number_products` instead of the incorrect `products` column in both aggregate functions. Do use the correct table name `shop` instead of the pluralized `shops` table. Do remove the unnecessary column aliases `min_products` and `max_products` instead of keeping them, as the right query returns unnamed columns. The amended query now correctly calculates the minimum and maximum values from the Number_products column in the shop table, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for minimum and maximum number of products: use the exact column name \"Number_products\" from the shop table, not \"products\". 2) When referencing the table containing product information: use the exact table name \"shop\" instead of the pluralized form \"shops\". 3) When the question does not specify column aliases for output: return the aggregate results without column aliases, maintaining the natural output order of minimum value first followed by maximum value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(products) AS min_products, MAX(products) AS max_products FROM shops;",
            "SELECT MIN(Number_products), MAX(Number_products) FROM shop;"
        ],
        "rule_sql": [
            "SELECT MIN(Number_products), MAX(Number_products) FROM shop;"
        ]
    },
    "947": {
        "db_id": "dog_kennels",
        "question": "What are the date and the operating professional's first name of each treatment?",
        "ground_truth": "SELECT T1.date_of_treatment ,  T2.first_name FROM Treatments AS T1 JOIN Professionals AS T2 ON T1.professional_id  =  T2.professional_id",
        "amends": [
            "Do use `T1.date_of_treatment` instead of `date` and `T2.first_name` instead of `first_name` for explicit table aliases. Do specify `Treatments AS T1` instead of `treatments` and `Professionals AS T2` instead of `professionals` with proper table aliasing. Do join on `T1.professional_id = T2.professional_id` instead of `treatments.professional_id = professionals.id` to use the correct join condition between professional IDs. The amended query now correctly retrieves treatment dates and professional names using proper table aliases and join conditions."
        ],
        "rules": [
            "1) When answering about \"date and the operating professional's first name of each treatment\": make sure the output order: T1.date_of_treatment, T2.first_name. 2) When the question mentions \"date\": \"date\" actually means \"T1.date_of_treatment\" in schema. 3) When the question mentions \"first name\": \"first name\" actually means \"T2.first_name\" in schema. 4) When combining T1 (Treatments) and T2 (Professionals) for shared entities: link rows where T1.professional_id = T2.professional_id; keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT date, first_name FROM treatments JOIN professionals ON treatments.professional_id = professionals.id",
            "SELECT T1.date_of_treatment, T2.first_name FROM Treatments AS T1 JOIN Professionals AS T2 ON T1.professional_id = T2.professional_id"
        ],
        "rule_sql": [
            "SELECT T1.date_of_treatment, T2.first_name FROM Treatments T1 INNER JOIN Professionals T2 ON T1.professional_id = T2.professional_id;"
        ]
    },
    "1008": {
        "db_id": "singer",
        "question": "Show the name of singers whose birth year is either 1948 or 1949?",
        "ground_truth": "SELECT Name FROM singer WHERE Birth_Year  =  1948 OR Birth_Year  =  1949",
        "amends": [
            "Do reference the `Name` column instead of `name` to match the correct column name. Do reference the `singer` table instead of `singers` to use the correct table name. Do reference the `Birth_Year` column instead of `birth_year` to match the correct column name. The amended query now correctly selects from the singer table using the proper column names while maintaining the same filtering logic for birth years 1948 and 1949."
        ],
        "rules": [
            "1) When the question asks for singer names: use the exact column token \"Name\" from the singer table. 2) When the question mentions birth year: use the exact column token \"Birth_Year\" from the singer table. 3) When the question specifies birth years 1948 or 1949: filter for rows where \"Birth_Year\" equals exactly 1948 or exactly 1949. 4) When selecting from the singer table: use the exact table name \"singer\" (not \"singers\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers WHERE birth_year = 1948 OR birth_year = 1949;",
            "SELECT Name FROM singer WHERE Birth_Year = 1948 OR Birth_Year = 1949;"
        ],
        "rule_sql": [
            "SELECT Name FROM singer WHERE Birth_Year = 1948 OR Birth_Year = 1949;"
        ]
    },
    "583": {
        "db_id": "student_transcripts_tracking",
        "question": "Find the first name of the students who permanently live in the country Haiti or have the cell phone number 09700166582 .",
        "ground_truth": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  'haiti' or t1.cell_mobile_number  =  '09700166582'",
        "amends": [
            "Do join `addresses as t2` instead of querying only the `students` table. Do use `ON t1.permanent_address_id = t2.address_id` instead of missing this join condition. Do change the WHERE clause to `t2.country = 'haiti' OR t1.cell_mobile_number = '09700166582'` instead of `country = 'Haiti' AND cell_phone = '09700166582'`, correcting both the column references and the logical operator from AND to OR. Do reference `t1.first_name` with table alias instead of just `first_name`. Do use lowercase 'haiti' instead of 'Haiti' for case consistency. The amended query now correctly joins the addresses table and uses proper OR logic to find records matching either condition."
        ],
        "rules": [
            "1) When answering about students who live in Haiti or have a specific phone number: join table \"students\" as T1 with table \"addresses\" as T2 using the condition T1.permanent_address_id = T2.address_id. 2) When the question mentions \"permanently live in the country Haiti\": use T2.country = 'haiti' (lowercase) instead of 'Haiti'. 3) When the question mentions \"cell phone number 09700166582\": use T1.cell_mobile_number = '09700166582' instead of cell_phone. 4) When combining conditions with \"or\": use OR logical operator instead of AND. 5) When selecting first names: reference T1.first_name with table alias instead of just first_name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE country = 'Haiti' AND cell_phone = '09700166582';",
            "SELECT t1.first_name \nFROM Students t1\nJOIN Addresses t2 ON t1.permanent_address_id = t2.address_id\nWHERE t2.country = 'haiti' OR t1.cell_mobile_number = '09700166582'"
        ],
        "rule_sql": [
            "SELECT T1.first_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.permanent_address_id = T2.address_id WHERE T2.country = 'haiti' OR T1.cell_mobile_number = '09700166582'"
        ]
    },
    "341": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all template type codes and the number of documents using each type.",
        "ground_truth": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code",
        "amends": [
            "Do join `Templates AS T1` to `Documents AS T2` on `T1.template_id = T2.template_id` instead of querying only the `documents` table without any join. Do reference `T1.template_type_code` in both SELECT and GROUP BY clauses instead of using just `template_type_code` without table qualification. The amended query now correctly counts documents per template type by properly joining the Templates and Documents tables to establish the relationship between template types and the documents that use them.",
            "Do use `INNER JOIN` instead of `LEFT JOIN` to only count documents that actually exist. Do use `count(*)` instead of `COUNT(T2.Document_ID)` to count all joined rows rather than non-null document IDs. Do remove the alias `NumberOfDocuments` instead of keeping it since the right query omits column aliases. Do reference `template_type_code` and `template_id` in lowercase instead of mixed case to match the right query's column naming convention. The amended query now correctly counts only documents with matching templates and matches the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"template type codes and number of documents using each type\": make sure the output order: T1.template_type_code, count of documents per template type. 2) When combining Templates (T1) and Documents (T2) for shared entities: link rows where T1.template_id = T2.template_id exactly as shown; keep only matching pairs (inner match). 3) When the question asks for \"number of documents using each type\": compute the count of documents using T2.template_id as the counting key per template type group. 4) When the question mentions \"template type codes\": \"template type codes\" actually means T1.template_type_code in schema. 5) When the question says \"per template type\": organize results by T1.template_type_code and compute document count per group.",
            "1) When combining Templates and Documents tables: link rows where T1.template_id equals T2.template_id using an inner join to only include matching pairs. 2) When counting documents per template type: count all joined rows using count(*) rather than counting specific columns. 3) When outputting results: show template_type_code and the count without column aliases. 4) When referencing column identifiers: use lowercase template_type_code and template_id to match the schema's naming convention."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code, COUNT(*) FROM documents GROUP BY template_type_code;",
            "SELECT T1.Template_Type_Code, COUNT(T2.Document_ID) AS NumberOfDocuments\nFROM Templates AS T1\nLEFT JOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID\nGROUP BY T1.Template_Type_Code",
            "SELECT T1.template_type_code, COUNT(*) \nFROM Templates AS T1 \nINNER JOIN Documents AS T2 ON T1.template_id = T2.template_id \nGROUP BY T1.template_type_code"
        ],
        "rule_sql": [
            "SELECT T1.template_type_code, COUNT(*) \nFROM Templates T1 \nINNER JOIN Documents T2 ON T1.template_id = T2.template_id \nGROUP BY T1.template_type_code"
        ]
    },
    "935": {
        "db_id": "dog_kennels",
        "question": "Which breed do the most dogs have? Give me the breed name.",
        "ground_truth": "SELECT T1.breed_name FROM Breeds AS T1 JOIN Dogs AS T2 ON T1.breed_code  =  T2.breed_code GROUP BY T1.breed_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `Breeds AS T1` and `Dogs AS T2` on `T1.breed_code = T2.breed_code` instead of querying only the `dogs` table. Do select `T1.breed_name` instead of `breed` and maintain the same aggregate count logic. Do group by `T1.breed_name` instead of `breed` to properly reference the joined table column. Do keep the `ORDER BY count(*) DESC LIMIT 1` unchanged as it correctly identifies the breed with the highest count. The amended query now properly joins the breed reference table to resolve breed names from codes and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"which breed do the most dogs have\": make sure the output order: T1.breed_name. 2) When the question mentions \"breed\": \"breed\" actually means \"T1.breed_name in schema\". 3) When combining T1 and T2 for shared entities: link rows where T1.breed_code = T2.breed_code exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"count of dogs\": compute the number of rows using the canonical key token for dogs (e.g., T2.breed_code). 5) When the question mentions \"most\" or \"highest\": rank rows by count of dogs in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT breed, COUNT(*) as count FROM dogs GROUP BY breed ORDER BY count DESC LIMIT 1;",
            "SELECT T1.breed_name\nFROM Breeds AS T1\nJOIN Dogs AS T2 ON T1.breed_code = T2.breed_code\nGROUP BY T1.breed_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT b.breed_name\nFROM Breeds b\nJOIN Dogs d ON b.breed_code = d.breed_code\nGROUP BY b.breed_name\nORDER BY COUNT(d.dog_id) DESC\nLIMIT 1;"
        ]
    },
    "96": {
        "db_id": "car_1",
        "question": "What is the model of the car with the smallest amount of horsepower?",
        "ground_truth": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;",
        "amends": [
            "Do select `T1.Model` from the `CAR_NAMES` table instead of selecting `model` from the `cars` table. Do join `CARS_DATA AS T2` with the condition `T1.MakeId = T2.Id` instead of querying a single table without any joins. Do order by `T2.horsepower ASC` in ascending order instead of `horsepower DESC` in descending order. The amended query now correctly retrieves the car model with the lowest horsepower by properly joining the car names and data tables."
        ],
        "rules": [
            "1) When answering about \"model of the car with the smallest amount of horsepower\": make sure the output order: T1.Model 2) When the question mentions \"model\": \"model\" actually means \"T1.Model in schema\" 3) When combining T1 and T2 for shared entities: link rows where T1.MakeId = T2.Id exactly as shown in the amends; keep only matching pairs (inner match) 4) When the question mentions \"smallest amount of horsepower\": order rows by T2.horsepower in ascending order to find the minimum value 5) When the question asks for the single car with the smallest horsepower: take only the first row after ordering by T2.horsepower ASC"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT model FROM cars ORDER BY horsepower DESC LIMIT 1;",
            "SELECT T1.Model FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id ORDER BY T2.Horsepower ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Model FROM car_names T1 INNER JOIN cars_data T2 ON T1.MakeId = T2.Id ORDER BY T2.Horsepower ASC LIMIT 1"
        ]
    },
    "141": {
        "db_id": "car_1",
        "question": "Which model has the most version(make) of cars?",
        "ground_truth": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;",
        "amends": [
            "Do reference the table as `CAR_NAMES` instead of `cars` and use the column name `Model` instead of `model` in both the SELECT list and GROUP BY clause. Do remove the explicit `COUNT(*) as version_count` column from the SELECT list instead of including it, and instead rely on the aggregate function directly in the ORDER BY clause. Do order by `count(*) DESC` instead of ordering by the alias `version_count DESC`. The amended query now correctly identifies the most frequent model from the CAR_NAMES table while matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When referencing the table for car information: use the exact table name \"CAR_NAMES\" instead of \"cars\". 2) When selecting and grouping by car model: use the exact column name \"Model\" with proper case instead of \"model\". 3) When counting versions/makes of cars: count all rows using count(*) but do not include this count column in the final output. 4) When ordering results to find the model with most versions: order by count(*) in descending direction. 5) When limiting to the top result: take only the first row after ordering by count(*) descending."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT model, COUNT(*) as version_count FROM cars GROUP BY model ORDER BY version_count DESC LIMIT 1;",
            "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "844": {
        "db_id": "orchestra",
        "question": "Show the name of the conductor that has conducted the most number of orchestras.",
        "ground_truth": "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID GROUP BY T2.Conductor_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.Name` instead of `conductor_name` and remove the `COUNT(*) as orchestra_count` column from the SELECT list. Do join `orchestra AS T2` instead of querying only the `conductors` table, using `JOIN` on `T1.Conductor_ID = T2.Conductor_ID` instead of no join condition. Do group by `T2.Conductor_ID` instead of `conductor_name` to properly aggregate by conductor identifier. Do order by `COUNT(*) DESC` instead of the alias `orchestra_count` since the alias is no longer selected. The amended query now correctly retrieves conductor names by joining the conductor and orchestra tables and counting orchestras per conductor, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"conductor that has conducted the most number of orchestras\": make sure the output order: T1.Name only. 2) When combining conductors table as T1 and orchestra table as T2: link rows where T1.Conductor_ID = T2.Conductor_ID and keep only matching pairs (inner match). 3) When counting orchestras per conductor: compute the number of rows using T2.Conductor_ID as the grouping key. 4) When the question asks for \"most number of orchestras\": rank rows by COUNT(*) in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT conductor_name, COUNT(*) as orchestra_count \nFROM conductors \nGROUP BY conductor_name \nORDER BY orchestra_count DESC \nLIMIT 1;",
            "SELECT T1.Name\nFROM conductor AS T1\nJOIN orchestra AS T2 ON T1.Conductor_ID = T2.Conductor_ID\nGROUP BY T2.Conductor_ID\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Name\nFROM conductor AS T1\nINNER JOIN orchestra AS T2 ON T1.Conductor_ID = T2.Conductor_ID\nGROUP BY T2.Conductor_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "718": {
        "db_id": "world_1",
        "question": "What is the average expected life expectancy for countries in the region of Central Africa?",
        "ground_truth": "SELECT avg(LifeExpectancy) FROM country WHERE Region  =  \"Central Africa\"",
        "amends": [
            "Do use table name `country` instead of `countries` and column name `LifeExpectancy` instead of `life_expectancy` to match the correct schema. Do use the correct region filter value `\"Central Africa\"` instead of `'Central Africa'` while maintaining the same filtering logic. Do use lowercase `avg` function instead of `AVG` for the aggregate calculation, though this is purely cosmetic. The amended query now correctly calculates the average life expectancy for the Central Africa region using the proper table and column names."
        ],
        "rules": [
            "1) When answering about average life expectancy: use the exact column name \"LifeExpectancy\" from table \"country\" with the aggregate function avg. 2) When filtering by region \"Central Africa\": use the exact literal value \"Central Africa\" with double quotes. 3) When referring to the table containing life expectancy data: use the exact table name \"country\" instead of \"countries\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(life_expectancy) FROM countries WHERE region = 'Central Africa';",
            "SELECT avg(LifeExpectancy) FROM country WHERE Region = \"Central Africa\""
        ],
        "rule_sql": [
            "SELECT AVG(LifeExpectancy) FROM country WHERE Region = \"Central Africa\""
        ]
    },
    "660": {
        "db_id": "poker_player",
        "question": "Return the names of all the poker players.",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID",
        "amends": [
            "Do select `T1.Name` instead of `player_id` and do add `people AS T1` and `poker_player AS T2` as joined tables instead of only `poker_players`. Do use `INNER JOIN` with predicate `T1.People_ID = T2.People_ID` instead of no join condition. The amended query now correctly retrieves player names from the people table by joining with poker_player on their relationship key instead of attempting to select player_id directly from a non-existent or incorrect table structure."
        ],
        "rules": [
            "1) When answering about \"names of all the poker players\": make sure the output order: T1.Name 2) When the question mentions \"poker players\": \"poker players\" actually means \"people who are poker players in schema\" 3) When combining T1 and T2 for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (T1.People_ID = T2.People_ID); keep only matching pairs (inner match) 4) When selecting from multiple tables: use people AS T1 and poker_player AS T2 as joined tables instead of only poker_players"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_id FROM poker_players;",
            "SELECT T1.Name \nFROM people AS T1 \nINNER JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM people AS T1 INNER JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T1.Name;"
        ]
    },
    "992": {
        "db_id": "dog_kennels",
        "question": "How much does the most expensive charge type costs?",
        "ground_truth": "SELECT max(charge_amount) FROM Charges",
        "amends": [
            "Do select `max(charge_amount)` instead of `MIN(cost)` to use the maximum aggregation function on the correct column. Do reference table `Charges` instead of `charge_types` to query from the appropriate data source. The amended query now correctly retrieves the maximum charge amount from the Charges table instead of attempting to find the minimum cost from an incorrect table."
        ],
        "rules": [
            "1) When the question asks for the \"most expensive charge type\": use the maximum aggregation function on the charge_amount column. 2) When referencing the charge amount data: query from the \"Charges\" table instead of \"charge_types\". 3) When computing the maximum charge amount: use max(charge_amount) instead of MIN(cost) to correctly find the highest value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(cost) FROM charge_types;",
            "SELECT MAX(charge_amount) FROM Charges;"
        ],
        "rule_sql": [
            "SELECT MAX(charge_amount) AS most_expensive_charge FROM Charges;"
        ]
    },
    "622": {
        "db_id": "tvshow",
        "question": "What is the weekly rank for the episode \"A Love of a Lifetime\"?",
        "ground_truth": "SELECT Weekly_Rank FROM TV_series WHERE Episode = \"A Love of a Lifetime\";",
        "amends": [
            "Do reference table `TV_series` instead of `episodes` and use column `Episode` instead of `episode_title` for the filter condition. Do use double quotes around the string literal \"A Love of a Lifetime\" instead of single quotes. Do use column name `Weekly_Rank` with proper capitalization instead of `weekly_rank`. The amended query now correctly references the appropriate table and column names to match the intended behavior."
        ],
        "rules": [
            "1) When answering about the weekly rank for a specific episode: use table \"TV_series\" (not \"episodes\") and output column \"Weekly_Rank\" with proper capitalization. 2) When filtering by episode title: use column \"Episode\" (not \"episode_title\") for the condition. 3) When specifying the literal episode title \"A Love of a Lifetime\": use double quotes around the exact string literal (not single quotes)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT weekly_rank FROM episodes WHERE episode_title = 'A Love of a Lifetime';",
            "SELECT Weekly_Rank FROM TV_series WHERE Episode = \"A Love of a Lifetime\";"
        ],
        "rule_sql": [
            "SELECT Weekly_Rank FROM TV_series WHERE Episode = \"A Love of a Lifetime\";"
        ]
    },
    "783": {
        "db_id": "world_1",
        "question": "Return the codes of countries that do not speak English and do not have Republics for governments.",
        "ground_truth": "SELECT Code FROM country WHERE GovernmentForm != \"Republic\" EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  \"English\"",
        "amends": [
            "Do select `Code` instead of `code` and use `EXCEPT` to exclude English-speaking countries instead of filtering with `language != 'English'`. Do reference table `country` instead of `countries` and use `GovernmentForm` instead of `government`. Do remove the direct `language` filter from the WHERE clause and instead use a subquery with `EXCEPT` that selects from `countrylanguage` where `LANGUAGE = 'English'`. Do use proper column references `CountryCode` in the EXCEPT clause instead of attempting to filter language directly in the main query. The amended query now correctly excludes countries where English is spoken while maintaining the government form filter, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about country codes: make sure the output order: \"Code\" from table \"country\". 2) When the question mentions \"countries\": use table \"country\" instead of \"countries\". 3) When the question mentions \"speak English\": this means countries that appear in table \"countrylanguage\" where \"Language\" = 'English'. 4) When excluding English-speaking countries: use EXCEPT operation to remove countries where \"CountryCode\" in \"countrylanguage\" matches \"Code\" in \"country\" and \"Language\" = 'English'. 5) When the question mentions \"Republics for governments\": this means \"GovernmentForm\" = 'Republic' in table \"country\". 6) When filtering by government form: include only rows where \"GovernmentForm\" != 'Republic'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT code FROM countries WHERE language != 'English' AND government != 'Republic';",
            "SELECT Code FROM country WHERE GovernmentForm != 'Republic' EXCEPT SELECT CountryCode FROM countrylanguage WHERE Language = 'English'"
        ],
        "rule_sql": [
            "SELECT Code FROM country WHERE GovernmentForm != 'Republic' EXCEPT SELECT c.Code FROM country c JOIN countrylanguage cl ON c.Code = cl.CountryCode WHERE cl.Language = 'English'"
        ]
    },
    "428": {
        "db_id": "museum_visit",
        "question": "How many museums were opened after 2013 or before 2008?",
        "ground_truth": "SELECT count(*) FROM museum WHERE open_year  >  2013 OR open_year  <  2008",
        "amends": [
            "Do reference table `museum` instead of `museums` and use column `open_year` instead of `opened_year`. Do use `OR` operator instead of `AND` to correctly count records where the year is either greater than 2013 or less than 2008, instead of incorrectly using `AND` which would return no results since a year cannot be both greater than 2013 and less than 2008 simultaneously. The amended query now matches the intended behavior of counting museums opened either after 2013 or before 2008."
        ],
        "rules": [
            "1) When the question mentions \"museums\": use the exact table name \"museum\" instead of \"museums\". 2) When the question mentions \"opened_year\": use the exact column name \"open_year\" instead of \"opened_year\". 3) When the question asks for museums opened \"after 2013 or before 2008\": use OR operator to combine conditions open_year > 2013 OR open_year < 2008, not AND operator."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM museums WHERE opened_year > 2013 AND opened_year < 2008;",
            "SELECT COUNT(*) FROM museum WHERE Open_Year > '2013' OR Open_Year < '2008';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM museum WHERE Open_Year > 2013 OR Open_Year < 2008"
        ]
    },
    "252": {
        "db_id": "flight_2",
        "question": "Give the flight numbers of flights leaving from Aberdeen.",
        "ground_truth": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.SourceAirport   =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"",
        "amends": [
            "Do add `JOIN AIRPORTS AS T2` with `ON T1.SourceAirport = T2.AirportCode` instead of querying `flights` table alone. Do reference `T2.City` in the WHERE clause instead of directly filtering on `departure_city`. Do use table alias `T1.FlightNo` instead of `flight_number` column name. The amended query now correctly joins airport data to filter by city name instead of assuming departure city is stored directly in the flights table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"flights leaving from Aberdeen\": make sure the output order: T1.FlightNo. 2) When the question mentions \"Aberdeen\": \"Aberdeen\" actually means \"T2.City = 'Aberdeen'\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.SourceAirport = T2.AirportCode exactly as shown in the amends; keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for T1.FlightNo, T1.SourceAirport, T2.AirportCode, and T2.City."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_city = 'Aberdeen';",
            "SELECT T1.FlightNo FROM flights AS T1 JOIN airports AS T2 ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ],
        "rule_sql": [
            "SELECT T1.FlightNo FROM flights T1 INNER JOIN airports T2 ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen' ORDER BY T1.FlightNo"
        ]
    },
    "755": {
        "db_id": "world_1",
        "question": "Which countries have either English or Dutch as an official language?",
        "ground_truth": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" AND IsOfficial  =  \"T\" UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"Dutch\" AND IsOfficial  =  \"T\"",
        "amends": [
            "Do select all columns from joined tables instead of selecting only `country` from a single table. Do join `country` and `countrylanguage` tables on `Code=CountryCode` instead of querying only the `languages` table. Do filter for `Language=\"English\"` and `IsOfficial=\"T\"` in one branch instead of using contradictory `language='English' AND language='Dutch'` conditions. Do add a UNION with a second branch for `Language=\"Dutch\"` and `IsOfficial=\"T\"` instead of attempting to find both languages in a single row. Do use proper table aliases `T1` and `T2` instead of no aliases. The amended query now correctly finds countries where either English or Dutch is an official language through separate UNION branches instead of the impossible single-row condition."
        ],
        "rules": [
            "1) When answering about countries with official languages: select all columns from joined tables instead of selecting only country from a single table. 2) When combining country and countrylanguage tables: join them on T1.Code = T2.CountryCode instead of querying only one table. 3) When filtering for English as an official language: use conditions T2.Language=\"English\" AND T2.IsOfficial=\"T\" instead of contradictory single-row conditions. 4) When filtering for Dutch as an official language: use conditions T2.Language=\"Dutch\" AND T2.IsOfficial=\"T\" in a separate UNION branch. 5) When handling multiple language conditions: use UNION with separate branches for each language instead of attempting to find both languages in a single row. 6) When referring to tables: use proper aliases T1 for country table and T2 for countrylanguage table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM languages WHERE language = 'English' AND language = 'Dutch';",
            "SELECT T1.*, T2.*\nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = 'English' AND T2.IsOfficial = 'T'\nUNION\nSELECT T1.*, T2.*\nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = 'Dutch' AND T2.IsOfficial = 'T'"
        ],
        "rule_sql": [
            "SELECT T1.*, T2.* FROM country T1 JOIN countrylanguage T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND T2.IsOfficial = 'T' UNION SELECT T1.*, T2.* FROM country T1 JOIN countrylanguage T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'Dutch' AND T2.IsOfficial = 'T'"
        ]
    },
    "627": {
        "db_id": "tvshow",
        "question": "Find the number of cartoons directed by each of the listed directors.",
        "ground_truth": "SELECT count(*) ,  Directed_by FROM cartoon GROUP BY Directed_by",
        "amends": [
            "Do use column name `Directed_by` instead of `director` and place `count(*)` first instead of second in the SELECT list. Do reference table `cartoon` instead of `cartoons` in the FROM clause. Do group by `Directed_by` instead of `director` to match the corrected column name. The amended query now correctly counts cartoons grouped by their director using the proper table and column names."
        ],
        "rules": [
            "1) When the question asks for \"number of cartoons directed by each director\": count the rows using the canonical key from the cartoon table and group by the exact column token \"Directed_by\". 2) When the question mentions \"directed by\": the exact column token is \"Directed_by\" from the cartoon table. 3) When producing output columns: place the count result first followed by the director name. 4) When referring to the table containing cartoon data: use the exact table name \"cartoon\" (not \"cartoons\"). 5) When grouping by director: use the exact column token \"Directed_by\" for grouping."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT director, COUNT(*) FROM cartoons GROUP BY director;",
            "SELECT count(*), Directed_by FROM Cartoon GROUP BY Directed_by"
        ],
        "rule_sql": [
            "SELECT COUNT(id), Directed_by FROM Cartoon GROUP BY Directed_by;"
        ]
    },
    "58": {
        "db_id": "pets_1",
        "question": "What are the first names of every student who has a cat or dog as a pet?",
        "ground_truth": "SELECT DISTINCT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat' OR T3.pettype  =  'dog'",
        "amends": [
            "Do use `DISTINCT T1.Fname` instead of `first_name` to select from the correct table with deduplication. Do join three tables `student AS T1`, `has_pet AS T2`, and `pets AS T3` instead of querying only a single `students` table. Do use `JOIN` relationships `T1.stuid = T2.stuid` and `T3.petid = T2.petid` instead of incorrect direct column references. Do change the condition to `T3.pettype = 'cat' OR T3.pettype = 'dog'` instead of the impossible `pet = 'cat' AND pet = 'dog'` that could never return results. The amended query now correctly identifies students who have either cats or dogs as pets through proper table relationships."
        ],
        "rules": [
            "1) When answering about \"first names of students with cats or dogs as pets\": use DISTINCT T1.Fname to select from the correct table with deduplication. 2) When combining student, has_pet, and pets tables: link rows where T1.stuid = T2.stuid and T3.petid = T2.petid using inner matches. 3) When filtering for cats or dogs as pets: use the condition T3.pettype = 'cat' OR T3.pettype = 'dog' with exact literals 'cat' and 'dog'. 4) When handling identifier delimiters: do not replace the exact table aliases T1, T2, T3 once established for this schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE pet = 'cat' AND pet = 'dog';",
            "SELECT DISTINCT T1.Fname FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID JOIN Pets AS T3 ON T3.PetID = T2.PetID WHERE T3.PetType = 'cat' OR T3.PetType = 'dog'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Fname FROM Student T1 INNER JOIN Has_Pet T2 ON T1.StuID = T2.StuID INNER JOIN Pets T3 ON T3.PetID = T2.PetID WHERE T3.PetType = 'cat' OR T3.PetType = 'dog'"
        ]
    },
    "78": {
        "db_id": "pets_1",
        "question": "What is the id of the pet owned by the student whose last name is 'Smith'?",
        "ground_truth": "SELECT T2.petid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid WHERE T1.Lname  =  'Smith'",
        "amends": [
            "Do select `T2.petid` instead of `pet_id` and use table aliases `T1` and `T2` instead of bare table names. Do add `JOIN has_pet AS T2 ON T1.stuid = T2.stuid` instead of querying only the students table. Do reference `T1.Lname` instead of `last_name` and use the correct column name `Lname` instead of `last_name`. Do remove the direct reference to `pet_id` from the students table and instead join to the has_pet table to get the correct `petid` column. The amended query now correctly retrieves pet IDs by joining the student and has_pet tables and filtering on the student's last name, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"id of the pet\": select \"T2\".\"petid\" instead of \"pet_id\" from the \"has_pet\" table. 2) When joining student and pet information: combine \"students\" as \"T1\" and \"has_pet\" as \"T2\" where \"T1\".\"stuid\" = \"T2\".\"stuid\" to get matching pairs only. 3) When filtering by student last name 'Smith': use \"T1\".\"Lname\" = 'Smith' instead of \"last_name\" to match the exact column name. 4) When answering about pet ownership: make sure the output order shows only \"T2\".\"petid\" as requested."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pet_id FROM students WHERE last_name = 'Smith';",
            "SELECT T2.petid FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID WHERE T1.LName = 'Smith'"
        ],
        "rule_sql": [
            "SELECT T2.PetID FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID WHERE T1.LName = 'Smith';"
        ]
    },
    "863": {
        "db_id": "network_1",
        "question": "Count the number of high schoolers.",
        "ground_truth": "SELECT count(*) FROM Highschooler",
        "amends": [
            "Do reference the table as `Highschooler` instead of `students` and use the correct table name `count(*)` instead of `COUNT(*)` while maintaining the same aggregation logic. The amended query now correctly references the Highschooler table and uses consistent function casing to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting entities from the database: use the exact table name \"Highschooler\" instead of any other table reference like \"students\". 2) When performing count aggregation: use the exact function name \"count(*)\" with lowercase 'c' to match the required function casing. 3) When filtering by grade level: use the exact column name \"grade_level\" and the exact literal value 'high school' with the specified case and spacing."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE grade_level = 'high school';",
            "SELECT count(*) FROM Highschooler"
        ],
        "rule_sql": [
            "SELECT count(*) FROM Highschooler;"
        ]
    },
    "677": {
        "db_id": "poker_player",
        "question": "What are the nationalities that are shared by at least two people?",
        "ground_truth": "SELECT Nationality FROM people GROUP BY Nationality HAVING COUNT(*)  >=  2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT nationality FROM people GROUP BY nationality HAVING COUNT(*) >= 2;"
        ],
        "rule_sql": [
            "SELECT Nationality FROM people GROUP BY Nationality HAVING COUNT(*) >= 2"
        ]
    },
    "45": {
        "db_id": "pets_1",
        "question": "Find the number of pets whose weight is heavier than 10.",
        "ground_truth": "SELECT count(*) FROM pets WHERE weight  >  10",
        "amends": [
            "Do use the comparison operator `>` instead of `<` in the WHERE filter condition, changing `weight < 10` to `weight > 10` to count pets with weight greater than 10 instead of less than 10. The amended query now correctly matches the intended behavior of counting records where weight exceeds the threshold value."
        ],
        "rules": [
            "1) When counting pets with weight heavier than 10: use the comparison operator > instead of < to filter for weight values greater than 10. 2) When filtering on weight values: use the exact literal value 10 without quotes as specified in the question. 3) When counting pets: count all rows that satisfy the weight > 10 condition to get the number of pets heavier than 10."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM pets WHERE weight < 10;",
            "SELECT COUNT(*) FROM Pets WHERE weight > 10;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Pets WHERE weight > 10;"
        ]
    },
    "472": {
        "db_id": "wta_1",
        "question": "What are the first names of all players, and their total ranking points?",
        "ground_truth": "SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name",
        "amends": [
            "Do add `sum(ranking_points)` and `T1.first_name` instead of `first_name, ranking_points` in the SELECT list. Do add `FROM players AS T1 JOIN rankings AS T2 ON T1.player_id = T2.player_id` instead of just `FROM players` to include the rankings table with a proper join condition. Do add `GROUP BY T1.first_name` instead of omitting grouping to aggregate ranking points by player name. Do remove the direct selection of individual ranking points instead of keeping them, replacing with an aggregate sum. The amended query now correctly aggregates ranking points by player name through proper table joining and grouping.",
            "Do place the aggregate function `sum(ranking_points)` first in the SELECT list instead of starting with `T1.first_name`. Do remove the alias `total_ranking_points` from the SUM expression instead of keeping it. Do maintain the same FROM clause with `JOIN` on `T1.player_id = T2.player_id` and identical GROUP BY `T1.first_name`. The amended query now correctly calculates total ranking points by player first name without unnecessary aliasing."
        ],
        "rules": [
            "1) When answering about \"first names of all players and their total ranking points\": make sure the output order: T1.first_name, sum(ranking_points). 2) When combining players and rankings tables: link rows where T1.player_id = T2.player_id and keep only matching pairs (inner match). 3) When the question asks for \"total ranking points\": compute the sum of ranking_points values for each player. 4) When grouping by player names: organize results by T1.first_name and compute the requested aggregate per group.",
            "1) When the question asks for \"first names of all players and their total ranking points\": make sure the output order starts with the aggregate function sum(ranking_points) before T1.first_name. 2) When calculating total ranking points: do not add an alias like total_ranking_points to the SUM expression. 3) When combining players and rankings tables: link rows where T1.player_id = T2.player_id and keep only matching pairs (inner match). 4) When grouping by player first names: organize results by T1.first_name and compute the sum of ranking_points per group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, ranking_points FROM players;",
            "SELECT T1.first_name, SUM(T2.ranking_points) AS total_ranking_points\nFROM players AS T1\nJOIN rankings AS T2 ON T1.player_id = T2.player_id\nGROUP BY T1.first_name",
            "SELECT sum(ranking_points), T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id = T2.player_id GROUP BY T1.first_name"
        ],
        "rule_sql": [
            "SELECT T1.first_name, SUM(ranking_points) FROM players T1 INNER JOIN rankings T2 ON T1.player_id = T2.player_id GROUP BY T1.first_name"
        ]
    },
    "761": {
        "db_id": "world_1",
        "question": "What is the most populace city that speaks English?",
        "ground_truth": "SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  \"English\" ORDER BY T1.Population DESC LIMIT 1",
        "amends": [
            "Do select `T1.Name` and `T1.Population` instead of `city` and `population`. Do join `city AS T1` with `countrylanguage AS T2` on `T1.CountryCode = T2.CountryCode` instead of querying a single `cities` table. Do filter on `T2.Language = \"English\"` instead of `language = 'English'`. Do order by `T1.Population DESC` instead of `population ASC`. The amended query now correctly joins tables to filter by language and returns the city with the highest English-speaking population instead of the lowest."
        ],
        "rules": [
            "1) When the question asks about \"city\" and \"population\": select \"T1\".\"Name\" and \"T1\".\"Population\" as output columns. 2) When combining city and countrylanguage tables: join \"city\" AS \"T1\" with \"countrylanguage\" AS \"T2\" on \"T1\".\"CountryCode\" = \"T2\".\"CountryCode\" using inner match. 3) When filtering for English language: apply condition \"T2\".\"Language\" = \"English\". 4) When the question asks for the \"most populace city\": order results by \"T1\".\"Population\" in descending direction and keep only the first row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, population FROM cities WHERE language = 'English' ORDER BY population ASC LIMIT 1;",
            "SELECT T1.Name, T1.Population \nFROM city AS T1 \nJOIN countrylanguage AS T2 ON T1.CountryCode = T2.CountryCode \nWHERE T2.Language = \"English\" \nORDER BY T1.Population DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Name, T1.Population FROM city AS T1 INNER JOIN countrylanguage AS T2 ON T1.CountryCode = T2.CountryCode WHERE T2.Language = 'English' ORDER BY T1.Population DESC LIMIT 1;"
        ]
    },
    "797": {
        "db_id": "world_1",
        "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?",
        "ground_truth": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72",
        "amends": [
            "Do move the LifeExpectancy filter to `HAVING avg(LifeExpectancy) > 72` instead of `WHERE LifeExpectancy > 72` to filter groups by average life expectancy rather than individual rows. Do change the SELECT clause order to `sum(Population), GovernmentForm` instead of `GovernmentForm, SUM(Population) as TotalPopulation`, removing the alias while maintaining the same aggregation logic. The amended query now correctly filters government forms based on their average life expectancy rather than excluding individual countries, matching the RIGHT_SQL's behavior.",
            "Do place `GovernmentForm` after the aggregate function instead of before it in the SELECT list. Do use lowercase `sum` and `avg` functions instead of uppercase `SUM` and `AVG`. Do maintain the same GROUP BY clause on `GovernmentForm` and HAVING condition checking `avg(LifeExpectancy) > 72`. The amended query now correctly matches the right SQL's behavior with identical logic and output."
        ],
        "rules": [
            "1) When the question asks for government forms with average life expectancy greater than 72: filter groups using HAVING avg(LifeExpectancy) > 72 instead of filtering individual rows. 2) When computing total population per government form: use sum(Population) as the aggregation function. 3) When ordering output columns: place sum(Population) before GovernmentForm in the result. 4) When grouping results by government form: use GovernmentForm as the grouping key without aliases in the output.",
            "1) When the question asks for different government forms and their total population: place \"GovernmentForm\" after the aggregate function in the output order. 2) When computing total population: use lowercase \"sum\" function on \"Population\" column. 3) When filtering by average life expectancy greater than 72: use lowercase \"avg\" function on \"LifeExpectancy\" column and compare with value 72. 4) When grouping results by government form: group by \"GovernmentForm\" column. 5) When handling aggregate functions: use lowercase function names (sum, avg) instead of uppercase versions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT GovernmentForm, SUM(Population) as TotalPopulation \nFROM country \nWHERE LifeExpectancy > 72 \nGROUP BY GovernmentForm;",
            "SELECT GovernmentForm, SUM(Population) FROM country GROUP BY GovernmentForm HAVING AVG(LifeExpectancy) > 72",
            "SELECT sum(Population), GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy) > 72"
        ],
        "rule_sql": [
            "SELECT sum(Population), GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy) > 72 ORDER BY sum(Population) DESC, GovernmentForm;"
        ]
    },
    "507": {
        "db_id": "student_transcripts_tracking",
        "question": "what are all the addresses including line 1 and line 2?",
        "ground_truth": "SELECT line_1 ,  line_2 FROM addresses",
        "amends": [
            "Do select `line_1` and `line_2` columns instead of `address_line1`. Do add `line_2` instead of omitting it. The amended query now correctly retrieves both address line components as specified in the target output."
        ],
        "rules": [
            "1) When the question asks for \"addresses including line 1 and line 2\": select both \"line_1\" and \"line_2\" columns from the Addresses table. 2) When the question specifies \"all the addresses\": return all rows from the Addresses table without filtering. 3) When the question mentions \"line 1\" and \"line 2\": these correspond exactly to the \"line_1\" and \"line_2\" column names in the Addresses table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT address_line1 FROM addresses;",
            "SELECT line_1, line_2 FROM Addresses;"
        ],
        "rule_sql": [
            "SELECT line_1, line_2 FROM Addresses;"
        ]
    },
    "66": {
        "db_id": "pets_1",
        "question": "What is the first name of every student who has a dog but does not have a cat?",
        "ground_truth": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog' AND T1.stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')",
        "amends": [
            "Do select `T1.fname` and `T1.age` instead of just `first_name`. Do use explicit table aliases with `student AS T1` instead of the base table name. Do add `JOIN has_pet AS T2` and `JOIN pets AS T3` instead of omitting these tables. Do use join conditions `ON T1.stuid = T2.stuid` and `ON T3.petid = T2.petid` instead of simple boolean flags. Do filter with `T3.pettype = 'dog'` instead of `has_dog = 1`. Do add a subquery exclusion with `NOT IN` for students who have cats instead of including them with `has_cat = 1`. Do remove the direct boolean column references and instead use proper relational joins through the has_pet and pets tables to determine pet ownership. The amended query now correctly identifies students who have dogs but not cats by using proper table relationships instead of boolean flags."
        ],
        "rules": [
            "1) When selecting student information: use T1.fname and T1.age as output columns instead of just first_name. 2) When referring to the student table: always use the explicit alias T1 instead of the base table name. 3) When determining pet ownership: join has_pet as T2 using T1.stuid = T2.stuid and join pets as T3 using T3.petid = T2.petid instead of using boolean flags. 4) When filtering for students with dogs: use T3.pettype = 'dog' instead of has_dog = 1. 5) When excluding students with cats: use a subquery exclusion with NOT IN for students who have cats instead of including them with has_cat = 1. 6) When answering about students with dogs but not cats: use proper relational joins through has_pet and pets tables to determine pet ownership instead of direct boolean column references."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE has_dog = 1 AND has_cat = 1;",
            "SELECT T1.fname, T1.age\nFROM student AS T1\nJOIN has_pet AS T2 ON T1.stuid = T2.stuid\nJOIN pets AS T3 ON T3.petid = T2.petid\nWHERE T3.pettype = 'dog'\nAND T1.stuid NOT IN (\n    SELECT T4.stuid\n    FROM student AS T4\n    JOIN has_pet AS T5 ON T4.stuid = T5.stuid\n    JOIN pets AS T6 ON T6.petid = T5.petid\n    WHERE T6.pettype = 'cat'\n)"
        ],
        "rule_sql": [
            "SELECT T1.fname, T1.age\nFROM Student T1\nJOIN Has_Pet T2 ON T1.StuID = T2.StuID\nJOIN Pets T3 ON T3.PetID = T2.PetID\nWHERE T3.PetType = 'dog'\nAND T1.StuID NOT IN (\n    SELECT T2.StuID\n    FROM Has_Pet T2\n    JOIN Pets T3 ON T3.PetID = T2.PetID\n    WHERE T3.PetType = 'cat'\n)\nGROUP BY T1.StuID;"
        ]
    },
    "773": {
        "db_id": "world_1",
        "question": "Which countries have greater area than that of any country in Europe?",
        "ground_truth": "SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  \"Europe\")",
        "amends": [
            "Do reference the correct table name `country` instead of `countries` in both the main query and subquery. Do use the correct column name `Name` instead of `name` for the country name. Do use the correct column name `SurfaceArea` instead of `area` for the surface area measurement. Do use the correct column name `Continent` instead of `continent` for the continent designation. Do use double quotes `\"Europe\"` instead of single quotes `'Europe'` for the string literal. Do use the `MIN` aggregate function `min(SurfaceArea)` instead of `MAX(area)` to find the smallest European country's surface area instead of the largest. The amended query now correctly identifies countries with surface area greater than the smallest European country rather than the largest."
        ],
        "rules": [
            "1) When the question asks about countries: use the table name \"country\" instead of \"countries\" and the column name \"Name\" for country names. 2) When the question mentions \"area\": use the column name \"SurfaceArea\" for surface area measurements. 3) When the question refers to \"Europe\": use the literal value \"Europe\" with double quotes for continent designation. 4) When finding countries with greater area than any country in Europe: use the MIN aggregate function on \"SurfaceArea\" to find the smallest European country's surface area rather than the largest. 5) When comparing surface areas: ensure the comparison is against the minimum surface area of European countries rather than the maximum."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM countries WHERE area > (SELECT MAX(area) FROM countries WHERE continent = 'Europe')",
            "SELECT Name FROM country WHERE SurfaceArea > (SELECT MIN(SurfaceArea) FROM country WHERE Continent = \"Europe\")"
        ],
        "rule_sql": [
            "SELECT Name FROM country WHERE SurfaceArea > (SELECT MIN(SurfaceArea) FROM country WHERE Continent = 'Europe')"
        ]
    },
    "82": {
        "db_id": "pets_1",
        "question": "What is the first name and gender of the all the students who have more than one pet?",
        "ground_truth": "SELECT T1.fname ,  T1.sex FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid GROUP BY T1.stuid HAVING count(*)  >  1",
        "amends": [
            "Do select `fname` and `sex` with table aliases instead of `first_name` and `gender` without aliases. Do use `student AS T1` joined with `has_pet AS T2` on `T1.stuid = T2.stuid` instead of querying only `students` without joins. Do add `GROUP BY T1.stuid` instead of omitting grouping. Do move the count filter to `HAVING count(*) > 1` instead of using `WHERE COUNT(pets) > 1` which incorrectly applies aggregation in the WHERE clause. The amended query now correctly counts pet relationships through the join and applies the aggregation filter in the proper HAVING clause, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"first name\" and \"gender\": use the exact column tokens \"fname\" and \"sex\" from the schema instead of \"first_name\" and \"gender\". 2) When counting pets per student: join \"student AS T1\" with \"has_pet AS T2\" on \"T1.stuid = T2.stuid\" to establish the pet relationships. 3) When grouping by student: use \"GROUP BY T1.stuid\" to organize results by individual students. 4) When filtering for students with more than one pet: apply the condition \"count(*) > 1\" in the HAVING clause instead of the WHERE clause to properly handle aggregation filters."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, gender FROM students WHERE COUNT(pets) > 1",
            "SELECT T1.Fname, T1.Sex FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID GROUP BY T1.StuID HAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T1.fname, T1.sex FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID GROUP BY T1.StuID HAVING COUNT(*) > 1"
        ]
    },
    "452": {
        "db_id": "wta_1",
        "question": "What are the first names and country codes for players who won both the WTA Championships and the Australian Open?",
        "ground_truth": "SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'WTA Championships' INTERSECT SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'Australian Open'",
        "amends": [
            "Do use `JOIN matches` on `player_id = winner_id` instead of querying only the `players` table. Do filter with `tourney_name = 'WTA Championships'` and `tourney_name = 'Australian Open'` in separate queries instead of using `LIKE` on a single column. Do use `INTERSECT` to find players who won both tournaments instead of trying to match both patterns in the same row. Do include proper table aliases `T1` and `T2` instead of unaliased references. Do query from the matches table to find tournament winners instead of relying on a text search in the players table. The amended query now correctly identifies players who have won both the WTA Championships and Australian Open tournaments by joining with match results.",
            "Do remove `DISTINCT` instead of keeping it. Do use `INTERSECT` instead of joining the same table twice with different conditions. Do change the join condition to use `T1.player_id = T2.winner_id` consistently instead of mixing table aliases. Do move the tourney name filters to separate `WHERE` clauses for each `INTERSECT` branch instead of combining them in a single query with multiple joins. Do restructure the query to find players who participated in both tournaments using set intersection logic instead of self-joining the matches table. The amended query now correctly identifies players who won matches in both the WTA Championships and Australian Open tournaments using proper set operations.",
            "Do use consistent table aliases `T1` for players and `T2` for matches instead of mixing `p` and `T1`/`T2` aliases. Do maintain the same column order `country_code, first_name` in both INTERSECT clauses instead of having `first_name, country_code` in the wrong query. Do use identical table aliasing patterns in both parts of the INTERSECT operation instead of having inconsistent alias usage between the two SELECT statements. The amended query now correctly uses consistent aliasing and column ordering throughout both INTERSECT components, ensuring proper set comparison behavior.",
            "Do use `JOIN` with `players AS T1` and `matches AS T2` on `T1.player_id = T2.winner_id` instead of a subquery with `INTERSECT`. Do include `T1.country_code` in the `SELECT` list instead of omitting it from the first query. Do filter directly in the `WHERE` clause with `T2.tourney_name = 'WTA Championships'` and `T2.tourney_name = 'Australian Open'` instead of using separate subqueries. Do apply `INTERSECT` between two complete `SELECT` statements that both return `country_code` and `first_name` instead of intersecting only `winner_id` values. The amended query now correctly finds players who won both tournaments by intersecting complete player records rather than just player IDs, matching the RIGHT_SQL's behavior.",
            "Do swap the column order in the SELECT list to `country_code, first_name` instead of `first_name, country_code` to ensure proper INTERSECT comparison semantics. The amended query now correctly identifies players who participated in both tournaments by maintaining consistent column ordering across both INTERSECT operands, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about players who won both WTA Championships and Australian Open: combine information from players table (T1) and matches table (T2) using player_id = winner_id to link tournament wins to players. 2) When filtering for WTA Championships wins: use exact literal 'WTA Championships' for tourney_name column. 3) When filtering for Australian Open wins: use exact literal 'Australian Open' for tourney_name column. 4) When finding players who won both tournaments: use INTERSECT operation between the two separate tournament result sets instead of trying to match both patterns in the same row. 5) When selecting output columns: include first_name and country_code from the players table (T1). 6) When combining tables: use inner matches where T1.player_id = T2.winner_id to ensure only players with tournament wins are considered.",
            "1) When answering about players who won both WTA Championships and Australian Open: use INTERSECT operation instead of joining the same table multiple times to find players present in both tournament winner sets. 2) When the question mentions \"won both the WTA Championships and the Australian Open\": this means finding players who have winner records in both tournaments using exact tournament name literals 'WTA Championships' and 'Australian Open'. 3) When combining player information from matches table: use consistent join condition T1.player_id = T2.winner_id to link players to their winning matches. 4) When filtering for specific tournaments: apply separate WHERE clauses for each tournament condition (T1.tourney_name = 'WTA Championships' and T2.tourney_name = 'Australian Open') in the INTERSECT branches. 5) When selecting output columns: return first_name and country_code from the players table without using DISTINCT since INTERSECT inherently returns unique results.",
            "1) When answering about players who won both tournaments: use consistent table aliases with T1 for players and T2 for matches throughout both INTERSECT components. 2) When producing output columns: maintain the column order as country_code, first_name in both SELECT statements of the INTERSECT operation. 3) When combining tables for tournament wins: link players and matches using the exact key equality T1.player_id = T2.winner_id as shown in the schema. 4) When filtering for specific tournaments: use exact string literals 'WTA Championships' and 'Australian Open' for the tourney_name column with correct case and spacing.",
            "1) When combining players and matches tables: link rows where T1.player_id equals T2.winner_id exactly as shown in the amends (T1.player_id = T2.winner_id) and keep only matching pairs (inner match). 2) When the question asks for players who won both specific tournaments: filter matches where T2.tourney_name equals 'WTA Championships' and also filter matches where T2.tourney_name equals 'Australian Open' using exact string literals. 3) When finding players who won both tournaments: use INTERSECT between two complete SELECT statements that both return T1.first_name and T1.country_code instead of intersecting only winner_id values. 4) When answering about players who won both tournaments: make sure the output order includes T1.first_name and T1.country_code.",
            "1) When using INTERSECT to find common results between two queries: ensure the column order in both SELECT clauses is identical, with country_code appearing before first_name. 2) When answering about players who won both specific tournaments: maintain consistent output column ordering (country_code, first_name) across both sides of the INTERSECT operation for proper comparison semantics."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, country_code \nFROM players \nWHERE tournament_wins LIKE '%WTA Championships%' \nAND tournament_wins LIKE '%Australian Open%';",
            "SELECT DISTINCT p.first_name, p.country_code\nFROM players p\nJOIN matches T1 ON p.player_id = T1.winner_id\nJOIN matches T2 ON p.player_id = T2.winner_id\nWHERE T1.tourney_name = 'WTA Championships'\nAND T2.tourney_name = 'Australian Open';",
            "SELECT p.first_name, p.country_code\nFROM players p\nJOIN matches T1 ON p.player_id = T1.winner_id\nWHERE T1.tourney_name = 'WTA Championships'\nINTERSECT\nSELECT p.first_name, p.country_code\nFROM players p\nJOIN matches T2 ON p.player_id = T2.winner_id\nWHERE T2.tourney_name = 'Australian Open'",
            "SELECT first_name, country_code\nFROM players\nWHERE player_id IN (\n    SELECT winner_id\n    FROM matches\n    WHERE tourney_name = 'WTA Championships'\n    INTERSECT\n    SELECT winner_id\n    FROM matches\n    WHERE tourney_name = 'Australian Open'\n)",
            "SELECT T1.first_name, T1.country_code\nFROM players AS T1\nJOIN matches AS T2 ON T1.player_id = T2.winner_id\nWHERE T2.tourney_name = 'WTA Championships'\nINTERSECT\nSELECT T1.first_name, T1.country_code\nFROM players AS T1\nJOIN matches AS T2 ON T1.player_id = T2.winner_id\nWHERE T2.tourney_name = 'Australian Open'",
            "SELECT T1.country_code, T1.first_name\nFROM players AS T1\nJOIN matches AS T2 ON T1.player_id = T2.winner_id\nWHERE T2.tourney_name = 'WTA Championships'\nINTERSECT\nSELECT T1.country_code, T1.first_name\nFROM players AS T1\nJOIN matches AS T2 ON T1.player_id = T2.winner_id\nWHERE T2.tourney_name = 'Australian Open'"
        ],
        "rule_sql": [
            "SELECT T1.country_code, T1.first_name\nFROM players T1\nINNER JOIN matches T2 ON T1.player_id = T2.winner_id\nWHERE T2.tourney_name = 'WTA Championships'\nINTERSECT\nSELECT T1.country_code, T1.first_name\nFROM players T1\nINNER JOIN matches T2 ON T1.player_id = T2.winner_id\nWHERE T2.tourney_name = 'Australian Open'"
        ]
    },
    "404": {
        "db_id": "course_teach",
        "question": "What are the names of the people who teach math courses?",
        "ground_truth": "SELECT T3.Name FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID WHERE T2.Course  =  \"Math\"",
        "amends": [
            "Do select `T3.Name` from the `teacher` table instead of `name` from `teachers`. Do use a multi-table join structure with `course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID = T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID` instead of querying only the `teachers` table. Do filter on `T2.Course = \"Math\"` instead of `subject = 'math'` to properly identify math courses through the course table relationship. The amended query now correctly retrieves teacher names by joining through the course arrangement and course tables to establish the proper relationships between teachers and math courses."
        ],
        "rules": [
            "1) When answering about \"names of people who teach math courses\": make sure the output order: T3.Name\n2) When the question mentions \"math courses\": \"math\" actually means \"Math\" in schema (exact literal with capital M)\n3) When combining tables for teacher-course relationships: link rows using T1.Course_ID = T2.Course_ID and T1.Teacher_ID = T3.Teacher_ID, keeping only matching pairs (inner match)\n4) When filtering for math courses: use T2.Course = \"Math\" with exact literal value and double quotes\n5) When selecting teacher names: use T3.Name from the teacher table (not name from teachers table)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM teachers WHERE subject = 'math';",
            "SELECT T3.Name \nFROM course_arrange AS T1 \nJOIN course AS T2 ON T1.Course_ID = T2.Course_ID \nJOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID \nWHERE T2.Course = 'Math'"
        ],
        "rule_sql": [
            "SELECT T3.Name\nFROM course_arrange T1\nINNER JOIN course T2 ON T1.Course_ID = T2.Course_ID\nINNER JOIN teacher T3 ON T1.Teacher_ID = T3.Teacher_ID\nWHERE T2.Course = \"Math\""
        ]
    },
    "1000": {
        "db_id": "singer",
        "question": "How many singers are there?",
        "ground_truth": "SELECT count(*) FROM singer",
        "amends": [
            "Do reference the `singer` table instead of the `songs` table in the FROM clause. Do count records from the correct table instead of the wrong one. The amended query now correctly counts records from the singer table as intended."
        ],
        "rules": [
            "1) When answering about \"how many singers\": make sure to count records from the \"singer\" table instead of the \"songs\" table. 2) When counting entities: use the canonical key for counting (typically the primary key of the table being counted)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM songs;",
            "SELECT COUNT(*) FROM singer;"
        ],
        "rule_sql": [
            "SELECT COUNT(Singer_ID) FROM singer;"
        ]
    },
    "888": {
        "db_id": "network_1",
        "question": "Show the names of high schoolers who have at least 3 friends.",
        "ground_truth": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id HAVING count(*)  >=  3",
        "amends": [
            "Do use `T1.student_id = T2.id` as the join condition instead of the incorrect `id IN (SELECT id1 FROM Friend)` subquery approach. Do reference the table as `Friend AS T1` and `Highschooler AS T2` instead of only using Highschooler in the main query. Do select `T2.name` from the joined Highschooler table instead of selecting `name` directly from Highschooler without proper joining. Do group by `T1.student_id` instead of grouping by `id1` in the subquery. The amended query now correctly joins the tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When joining tables Friend and Highschooler: use T1.student_id = T2.id as the join condition to match rows between tables. 2) When counting friends per student: group by T1.student_id and count the number of friend relationships where count is at least 3. 3) When selecting student names: retrieve T2.name from the Highschooler table after joining with Friend table. 4) When organizing results: ensure only students with at least 3 friends are included in the final output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM Highschooler WHERE id IN (SELECT id1 FROM Friend GROUP BY id1 HAVING COUNT(*) >= 3);",
            "SELECT T2.name\nFROM Friend AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nHAVING COUNT(T1.friend_id) >= 3;"
        ],
        "rule_sql": [
            "SELECT T2.name \nFROM Friend T1 \nJOIN Highschooler T2 ON T1.student_id = T2.ID \nGROUP BY T1.student_id \nHAVING COUNT(T1.friend_id) >= 3"
        ]
    },
    "132": {
        "db_id": "car_1",
        "question": "What is the largest amount of horsepower for the models with 3 cylinders and what make is it?",
        "ground_truth": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;",
        "amends": [
            "Do reference `T2.horsepower` and `T1.Make` instead of `MAX(horsepower)` and `make`. Do join `CAR_NAMES AS T1` with `CARS_DATA AS T2` on `T1.MakeId = T2.Id` instead of querying a single table `cars`. Do filter on `T2.cylinders = 3` instead of `cylinders = 3`. Do order by `T2.horsepower DESC` instead of `horsepower DESC`. The amended query now correctly joins the necessary tables and references the proper columns to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"largest amount of horsepower for models with 3 cylinders\": make sure the output order: T2.horsepower, T1.Make. 2) When the question mentions \"make\": \"make\" actually means \"T1.Make in schema\". 3) When the question mentions \"largest\" by horsepower: rank rows by T2.horsepower in descending order and keep the first 1 row. 4) When combining CAR_NAMES AS T1 and CARS_DATA AS T2 for shared entities: link rows where T1.MakeId = T2.Id exactly as shown; keep only matching pairs (inner match). 5) When filtering for models with 3 cylinders: include only rows where T2.cylinders = 3 exactly."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(horsepower), make FROM cars WHERE cylinders = 3 ORDER BY horsepower DESC LIMIT 1;",
            "SELECT T2.Horsepower, T1.Make \nFROM car_names AS T1 \nJOIN cars_data AS T2 ON T1.MakeId = T2.Id \nWHERE T2.Cylinders = 3 \nORDER BY T2.Horsepower DESC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.Horsepower, T1.Make \nFROM car_names AS T1 \nINNER JOIN cars_data AS T2 ON T1.MakeId = T2.Id \nWHERE T2.Cylinders = 3 \nORDER BY T2.Horsepower DESC \nLIMIT 1"
        ]
    },
    "961": {
        "db_id": "dog_kennels",
        "question": "Who owns the youngest dog? Give me his or her last name.",
        "ground_truth": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )",
        "amends": [
            "Do add `T1.last_name` with table alias instead of `last_name` without qualification. Do add `FROM Owners AS T1 JOIN Dogs AS T2` with explicit join instead of single table `FROM owners`. Do add `ON T1.owner_id = T2.owner_id` join condition instead of missing join predicate. Do add `WHERE T2.age = (SELECT max(age) FROM Dogs)` subquery filter instead of `ORDER BY dog_age ASC` sorting. Do remove `LIMIT 1` instead of keeping it, as the subquery filter now precisely identifies the maximum age record. The amended query now correctly joins the Owners and Dogs tables to find owners with dogs of maximum age, matching RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"Who owns the youngest dog? Give me his or her last name\": make sure the output order: T1.last_name. 2) When the question mentions \"youngest dog\": \"youngest dog\" actually means \"dogs with maximum age in schema\" using T2.age = (SELECT max(age) FROM Dogs). 3) When combining T1 (Owners) and T2 (Dogs) for shared entities: link rows where T1.owner_id = T2.owner_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table and column names like T1.last_name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM owners ORDER BY dog_age ASC LIMIT 1;",
            "SELECT T1.last_name \nFROM Owners AS T1 \nJOIN Dogs AS T2 ON T1.owner_id = T2.owner_id \nWHERE T2.age = (SELECT MAX(age) FROM Dogs)"
        ],
        "rule_sql": [
            "SELECT T1.last_name FROM Owners T1 INNER JOIN Dogs T2 ON T1.owner_id = T2.owner_id WHERE T2.age = (SELECT MAX(age) FROM Dogs)"
        ]
    },
    "198": {
        "db_id": "flight_2",
        "question": "Give the city and country for the Alton airport.",
        "ground_truth": "SELECT City ,  Country FROM AIRPORTS WHERE AirportName  =  \"Alton\"",
        "amends": [
            "Do use column aliases `City` and `Country` instead of lowercase `city` and `country`. Do reference the column `AirportName` in the WHERE filter instead of `name`. Do use double quotes around the string literal \"Alton\" instead of single quotes. The amended query now correctly matches the RIGHT_SQL's behavior by using the proper column names and string literal formatting."
        ],
        "rules": [
            "1) When the question asks for city and country information: use the exact column names \"City\" and \"Country\" with proper capitalization. 2) When filtering for an airport by name: use the column \"AirportName\" instead of \"name\" to match the airport name. 3) When specifying the literal value \"Alton\": use double quotes around the exact string literal \"Alton\" instead of single quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, country FROM airports WHERE name = 'Alton';",
            "SELECT City, Country FROM airports WHERE AirportName = \"Alton\""
        ],
        "rule_sql": [
            "SELECT City, Country FROM airports WHERE AirportName = \"Alton\";"
        ]
    },
    "938": {
        "db_id": "dog_kennels",
        "question": "What is the description of the treatment type that costs the least money in total?",
        "ground_truth": "SELECT T1.treatment_type_description FROM Treatment_types AS T1 JOIN Treatments AS T2 ON T1.treatment_type_code  =  T2.treatment_type_code GROUP BY T1.treatment_type_code ORDER BY sum(cost_of_treatment) ASC LIMIT 1",
        "amends": [
            "Do select `T1.treatment_type_description` instead of `description` and add a `JOIN` with `Treatments AS T2` on `T1.treatment_type_code = T2.treatment_type_code` instead of querying only `treatment_types`. Do add `GROUP BY T1.treatment_type_code` instead of omitting grouping and change the ordering to `sum(cost_of_treatment) ASC` instead of `cost ASC`. The amended query now correctly finds the treatment type with the lowest total cost across all treatments rather than just the single cheapest treatment type instance, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"treatment type that costs the least money in total\": make sure the output order: T1.treatment_type_description. 2) When combining T1 (treatment_types) and T2 (Treatments) for shared entities: link rows where T1.treatment_type_code = T2.treatment_type_code; keep only matching pairs (inner match). 3) When the question asks for total cost by treatment type: organize results by T1.treatment_type_code and compute sum(cost_of_treatment) per group. 4) When finding the treatment type with lowest total cost: rank rows by sum(cost_of_treatment) in ascending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description FROM treatment_types ORDER BY cost ASC LIMIT 1;",
            "SELECT T1.treatment_type_description \nFROM Treatment_Types AS T1\nJOIN Treatments AS T2 ON T1.treatment_type_code = T2.treatment_type_code\nGROUP BY T1.treatment_type_code\nORDER BY SUM(T2.cost_of_treatment) ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.treatment_type_description\nFROM Treatment_Types T1\nINNER JOIN Treatments T2 ON T1.treatment_type_code = T2.treatment_type_code\nGROUP BY T1.treatment_type_code, T1.treatment_type_description\nORDER BY SUM(T2.cost_of_treatment) ASC\nLIMIT 1;"
        ]
    },
    "823": {
        "db_id": "orchestra",
        "question": "Count the number of conductors.",
        "ground_truth": "SELECT count(*) FROM conductor",
        "amends": [
            "Do query the `conductor` table instead of the `employees` table. Do use the table name `conductor` instead of filtering `employees` with `WHERE job_title = 'conductor'`. The amended query now correctly counts records from the conductor table directly instead of filtering employees by job title, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When counting conductors: use the \"conductor\" table directly instead of filtering another table by job title. 2) When the question asks for \"count of conductors\": compute the number of rows using the canonical key from the \"conductor\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE job_title = 'conductor';",
            "SELECT COUNT(*) FROM conductor;"
        ],
        "rule_sql": [
            "SELECT COUNT(Conductor_ID) FROM conductor;"
        ]
    },
    "510": {
        "db_id": "student_transcripts_tracking",
        "question": "How many courses are there?",
        "ground_truth": "SELECT count(*) FROM Courses",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Courses;"
        ]
    },
    "120": {
        "db_id": "car_1",
        "question": "What is the minimum weight of the car with 8 cylinders produced in 1974 ?",
        "ground_truth": "select min(weight) from cars_data where cylinders  =  8 and year  =  1974",
        "amends": [
            "Do reference table `cars_data` instead of `cars` while keeping the same MIN(weight) aggregation and WHERE filters on `cylinders = 8` and `year = 1974` unchanged. The amended query now correctly references the actual table name while maintaining the same logical behavior to find the minimum weight of 8-cylinder cars from 1974."
        ],
        "rules": [
            "1) When answering about \"minimum weight of the car with 8 cylinders produced in 1974\": make sure to reference table \"cars_data\" instead of \"cars\". 2) When the question mentions \"8 cylinders\": use the exact condition \"cylinders = 8\" in the filtering. 3) When the question mentions \"produced in 1974\": use the exact condition \"year = 1974\" in the filtering. 4) When the question asks for \"minimum weight\": compute the minimum value of the \"weight\" column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(weight) FROM cars WHERE cylinders = 8 AND year = 1974;",
            "SELECT MIN(Weight) FROM cars_data WHERE Cylinders = 8 AND Year = 1974"
        ],
        "rule_sql": [
            "SELECT MIN(Weight) FROM cars_data WHERE Cylinders = 8 AND Year = 1974;"
        ]
    },
    "227": {
        "db_id": "flight_2",
        "question": "What is the code of airport that has fewest number of flights?",
        "ground_truth": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do specify `T1.AirportCode` with table alias instead of just `code` without qualification. Do add `FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2` with explicit table aliases instead of omitting the join. Do use join condition `ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport` instead of missing join predicates. Do add `GROUP BY T1.AirportCode` to aggregate by airport instead of omitting grouping. Do use `count(*)` to count all flights instead of `COUNT(flights.id)` which would only count non-null IDs. Do remove the explicit `ASC` since it's the default ordering instead of specifying it. The amended query now correctly counts flights for each airport (both as source and destination) and returns the airport with the fewest total flights."
        ],
        "rules": [
            "1) When answering about \"fewest number of flights\": make sure the output order: T1.AirportCode. 2) When combining T1 and T2 for shared entities: link rows where T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport; keep only matching pairs (inner match). 3) When the question asks for \"count of flights\": compute the number of rows using count(*) to count all flights. 4) When the question says \"per airport\": organize results by T1.AirportCode and compute requested aggregates per group. 5) When the question mentions \"fewest\": rank rows by flight count in ascending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT code FROM airports ORDER BY COUNT(flights.id) ASC LIMIT 1;",
            "SELECT T1.AirportCode\nFROM airports AS T1\nJOIN flights AS T2 ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport\nGROUP BY T1.AirportCode\nORDER BY count(*)\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.AirportCode\nFROM airports T1\nJOIN flights T2 ON T1.AirportCode = T2.SourceAirport OR T1.AirportCode = T2.DestAirport\nGROUP BY T1.AirportCode\nORDER BY COUNT(*) ASC\nLIMIT 1;"
        ]
    },
    "610": {
        "db_id": "tvshow",
        "question": "What is the series name of the TV Channel that shows the cartoon \"The Rise of the Blue Beetle\"?",
        "ground_truth": "SELECT T1.series_name FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Title = \"The Rise of the Blue Beetle!\";",
        "amends": [
            "Do join `TV_Channel AS T1` with `Cartoon AS T2` on `T1.id = T2.Channel` instead of querying only `tv_channels` table. Do filter on `T2.Title = \"The Rise of the Blue Beetle!\"` instead of `cartoon_name = 'The Rise of the Blue Beetle'`. Do select `T1.series_name` with table alias qualification instead of just `series_name`. The amended query now correctly joins the related tables and filters on the appropriate column to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks about a TV Channel showing a specific cartoon: join TV_Channel AS T1 with Cartoon AS T2 on T1.id = T2.Channel to link channels with their cartoons. 2) When filtering for a specific cartoon title \"The Rise of the Blue Beetle!\": use T2.Title = \"The Rise of the Blue Beetle!\" with exact punctuation and double quotes as shown. 3) When selecting the series name of the TV Channel: use T1.series_name with table alias qualification instead of just series_name. 4) When combining tables for shared entities: perform an inner match where T1.id = T2.Channel to keep only channels that actually show the specified cartoon."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT series_name FROM tv_channels WHERE cartoon_name = 'The Rise of the Blue Beetle';",
            "SELECT T1.series_name FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Title = 'The Rise of the Blue Beetle!'"
        ],
        "rule_sql": [
            "SELECT T1.series_name FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Title = \"The Rise of the Blue Beetle!\""
        ]
    },
    "699": {
        "db_id": "voter_1",
        "question": "What are the create dates, states, and phone numbers of the votes that were for the contestant named 'Tabatha Gehling'?",
        "ground_truth": "SELECT T2.created ,  T2.state ,  T2.phone_number FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number WHERE T1.contestant_name  =  'Tabatha Gehling'",
        "amends": [
            "Do join `contestants AS T1` to `votes AS T2` instead of querying only the `votes` table. Do use the join condition `T1.contestant_number = T2.contestant_number` instead of filtering directly on `contestant_name` in the votes table. Do reference columns `T2.created`, `T2.state`, and `T2.phone_number` instead of `create_date`, `state`, and `phone_number` from a single table. Do filter on `T1.contestant_name = 'Tabatha Gehling'` in the WHERE clause instead of applying the contestant name filter directly to the votes table. The amended query now correctly joins the contestants table to access contestant information and properly filters based on the relational connection between tables, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about votes for a specific contestant: join contestants table as T1 to votes table as T2 using the condition T1.contestant_number = T2.contestant_number instead of querying only the votes table. 2) When filtering by contestant name: apply the filter T1.contestant_name = 'Tabatha Gehling' to the contestants table rather than directly to the votes table. 3) When selecting vote information: reference columns T2.created, T2.state, and T2.phone_number from the votes table instead of create_date, state, and phone_number from a single table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT create_date, state, phone_number FROM votes WHERE contestant_name = 'Tabatha Gehling';",
            "SELECT T2.created, T2.state, T2.phone_number FROM CONTESTANTS AS T1 JOIN VOTES AS T2 ON T1.contestant_number = T2.contestant_number WHERE T1.contestant_name = 'Tabatha Gehling'"
        ],
        "rule_sql": [
            "SELECT T2.created, T2.state, T2.phone_number FROM CONTESTANTS AS T1 JOIN VOTES AS T2 ON T1.contestant_number = T2.contestant_number WHERE T1.contestant_name = 'Tabatha Gehling'"
        ]
    }
}