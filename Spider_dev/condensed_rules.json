{
    "0": {
        "db_id": "concert_singer",
        "question": "How many singers do we have?",
        "ground_truth": "SELECT count(*) FROM singer",
        "amends": [
            "Do reference the `singer` table instead of the `songs` table in the FROM clause. Do count records from the correct table `singer` instead of the incorrect table `songs`. The amended query now correctly counts records from the singer table as intended."
        ],
        "rules": [
            "When answering about \"how many singers\": make sure to count records from the \"singer\" table instead of the \"songs\" table.",
            "When answering about \"how many singers\", When counting entities: use the canonical key for counting records from the specified table (\"singer\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM songs;",
            "SELECT COUNT(*) FROM singer;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM singer;"
        ]
    },
    "1": {
        "db_id": "concert_singer",
        "question": "What is the total number of singers?",
        "ground_truth": "SELECT count(*) FROM singer",
        "amends": [
            "Do reference the `singer` table instead of `singers` to use the correct table name. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistent function casing. Do remove the `WHERE name IS NOT NULL` filter instead of keeping it to count all records regardless of null values. The amended query now correctly counts all rows in the singer table without unnecessary filtering."
        ],
        "rules": [
            "When the question asks for \"singers\": use the exact table name \"singer\" instead of \"singers\".",
            "When the question asks for \"singers\", When counting all records in a table: use lowercase \"count(*)\" function and do not apply any WHERE filters to include all rows regardless of null values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM singers WHERE name IS NOT NULL;",
            "SELECT count(*) FROM singer"
        ],
        "rule_sql": [
            "SELECT count(*) FROM singer"
        ]
    },
    "2": {
        "db_id": "concert_singer",
        "question": "Show name, country, age for all singers ordered by age from the oldest to the youngest.",
        "ground_truth": "SELECT name ,  country ,  age FROM singer ORDER BY age DESC",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause. Do use `ORDER BY age DESC` instead of `ORDER BY age ASC` to sort in descending order rather than ascending. The amended query now correctly references the intended table and sorts the results by age in descending order as specified in the RIGHT_SQL."
        ],
        "rules": [
            "When the question asks about singers: use the exact table name \"singer\" instead of \"singers\".",
            "When the question asks about singers, When ordering by age from oldest to youngest: sort by \"age\" in descending order (DESC) instead of ascending order (ASC)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, country, age FROM singers ORDER BY age ASC;",
            "SELECT Name, Country, Age FROM singer ORDER BY Age DESC;"
        ],
        "rule_sql": [
            "SELECT Name, Country, Age FROM singer ORDER BY Age DESC;"
        ]
    },
    "3": {
        "db_id": "concert_singer",
        "question": "What are the names, countries, and ages for every singer in descending order of age?",
        "ground_truth": "SELECT name ,  country ,  age FROM singer ORDER BY age DESC",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause. Do use `ORDER BY age DESC` instead of `ORDER BY age ASC` to sort in descending order rather than ascending order. The amended query now correctly references the intended table and produces the desired descending age ordering."
        ],
        "rules": [
            "When the question asks about singers: use the exact table name \"singer\" instead of \"singers\".",
            "When ordering by age in descending order: sort by \"age\" column in descending direction (highest to lowest).",
            "When the question asks about singers, When ordering by age in descending order, When selecting output columns: include \"name\", \"country\", and \"age\" in that exact order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, country, age FROM singers ORDER BY age ASC;",
            "SELECT Name, Country, Age FROM singer ORDER BY Age DESC;"
        ],
        "rule_sql": [
            "SELECT name, country, age FROM singer ORDER BY age DESC;"
        ]
    },
    "4": {
        "db_id": "concert_singer",
        "question": "What is the average, minimum, and maximum age of all singers from France?",
        "ground_truth": "SELECT avg(age) ,  min(age) ,  max(age) FROM singer WHERE country  =  'France'",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause. Do maintain the same aggregate functions `AVG(age)`, `MIN(age)`, and `MAX(age)` with identical column references. Do preserve the WHERE filter `country = 'France'` without changes. The amended query now correctly references the intended table while maintaining the same aggregation logic and filtering criteria, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"average, minimum, and maximum age of all singers from France\": make sure the output order: AVG(age), MIN(age), MAX(age).",
            "When the question mentions \"singers\": \"singers\" actually means \"singer\" in schema.",
            "When the question mentions \"from France\": use the exact literal value 'France' for the country filter.",
            "When answering about \"average, minimum, and maximum age of all singers from France\", When the question mentions \"singers\", When the question mentions \"from France\", When computing aggregates on age: use the exact column name \"age\" from the singer table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age), MIN(age), MAX(age) FROM singers WHERE country = 'France';",
            "SELECT AVG(Age) AS average_age, MIN(Age) AS minimum_age, MAX(Age) AS maximum_age FROM singer WHERE Country = 'France';"
        ],
        "rule_sql": [
            "SELECT AVG(age), MIN(age), MAX(age) FROM singer WHERE Country = 'France';"
        ]
    },
    "5": {
        "db_id": "concert_singer",
        "question": "What is the average, minimum, and maximum age for all French singers?",
        "ground_truth": "SELECT avg(age) ,  min(age) ,  max(age) FROM singer WHERE country  =  'France'",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause. Do use filter condition `country = 'France'` instead of `nationality = 'France'` in the WHERE clause. The amended query now correctly calculates age statistics for French singers from the appropriate table with the correct country filter."
        ],
        "rules": [
            "When answering about \"average, minimum, and maximum age for all French singers\": make sure the output order: AVG(age), MIN(age), MAX(age).",
            "When the question mentions \"French singers\": \"French\" actually means \"country = 'France'\" in schema.",
            "When answering about \"average, minimum, and maximum age for all French singers\", When the question mentions \"French singers\", When the question mentions \"singers\": \"singers\" actually means table \"singer\" in schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age), MIN(age), MAX(age) FROM singers WHERE nationality = 'France';",
            "SELECT AVG(Age) AS Average_Age, MIN(Age) AS Minimum_Age, MAX(Age) AS Maximum_Age FROM singer WHERE Country = 'France';"
        ],
        "rule_sql": [
            "SELECT AVG(Age) AS Average_Age, MIN(Age) AS Minimum_Age, MAX(Age) AS Maximum_Age FROM singer WHERE Country = 'France';"
        ]
    },
    "6": {
        "db_id": "concert_singer",
        "question": "Show the name and the release year of the song by the youngest singer.",
        "ground_truth": "SELECT song_name ,  song_release_year FROM singer ORDER BY age LIMIT 1",
        "amends": [
            "Do select `song_name` and `song_release_year` instead of `name` and `release_year`. Do use table `singer` instead of `songs`. Do order by `age` instead of `singer_age`. The amended query now correctly retrieves song information from the singer table ordered by age."
        ],
        "rules": [
            "When the question asks for song name and release year: select \"song_name\" and \"song_release_year\" as output columns.",
            "When retrieving information about songs by singers: use the \"singer\" table instead of a \"songs\" table.",
            "When ordering by the youngest singer: order by \"age\" in ascending order and keep only the first row.",
            "When the question asks for song name and release year, When retrieving information about songs by singers, When ordering by the youngest singer, When the question mentions \"song by the youngest singer\": the output should show the song details from the singer with the minimum age value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, release_year FROM songs ORDER BY singer_age ASC LIMIT 1;",
            "SELECT Song_Name, Song_release_year FROM singer ORDER BY Age ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT \"Song_Name\", \"Song_release_year\" FROM \"singer\" ORDER BY \"Age\" ASC LIMIT 1;"
        ]
    },
    "7": {
        "db_id": "concert_singer",
        "question": "What are the names and release years for all the songs of the youngest singer?",
        "ground_truth": "SELECT song_name ,  song_release_year FROM singer ORDER BY age LIMIT 1",
        "amends": [
            "Do select `song_name` and `song_release_year` instead of `s.name` and `s.release_year`. Do use `FROM singer` instead of joining `songs` and `singers` tables. Do remove the `WHERE` clause with subquery for maximum age instead of keeping it. Do add `ORDER BY age` and `LIMIT 1` instead of omitting ordering and limiting. The amended query now correctly retrieves the song details from the oldest singer by ordering by age and limiting to one result instead of using a complex join with subquery."
        ],
        "rules": [
            "When selecting song details: use exact column names \"song_name\" and \"song_release_year\" instead of generic names like s.name and s.release_year.",
            "When retrieving data about singers and their songs: use the \"singer\" table directly instead of joining separate \"songs\" and \"singers\" tables.",
            "When finding the youngest singer: order by \"age\" in ascending order (implied by youngest) and limit to 1 result instead of using subqueries for maximum age.",
            "When selecting song details, When retrieving data about singers and their songs, When finding the youngest singer, When the question asks for \"all the songs of the youngest singer\": ensure the output includes both song names and release years for that specific singer."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.name, s.release_year \nFROM songs s \nJOIN singers si ON s.singer_id = si.id \nWHERE si.age = (SELECT MAX(age) FROM singers);",
            "SELECT Song_Name, Song_release_year FROM singer ORDER BY Age ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT song_name, song_release_year FROM singer WHERE Age = (SELECT MIN(Age) FROM singer) ORDER BY song_name;"
        ]
    },
    "8": {
        "db_id": "concert_singer",
        "question": "What are all distinct countries where singers above age 20 are from?",
        "ground_truth": "SELECT DISTINCT country FROM singer WHERE age  >  20",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause while keeping the same SELECT list with `DISTINCT country` and WHERE filter `age > 20` unchanged. The amended query now correctly references the singular table name and matches the intended behavior."
        ],
        "rules": [
            "When the question asks about singers: use the table \"singer\" instead of \"singers\"",
            "When the question asks about singers, When the question asks for distinct countries where singers above age 20 are from: select distinct values of the \"country\" column from the \"singer\" table where the \"age\" column is greater than 20"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT country FROM singers WHERE age > 20;",
            "SELECT DISTINCT country FROM singer WHERE age > 20"
        ],
        "rule_sql": [
            "SELECT DISTINCT Country FROM singer WHERE Age > 20"
        ]
    },
    "9": {
        "db_id": "concert_singer",
        "question": "What are  the different countries with singers above age 20?",
        "ground_truth": "SELECT DISTINCT country FROM singer WHERE age  >  20",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause while keeping all other elements identical including the SELECT DISTINCT country and WHERE age > 20 filter, as the table name correction is the only change needed to match the schema."
        ],
        "rules": [
            "When the question asks about \"countries with singers\": use the exact table name \"singer\" instead of \"singers\" as specified in the schema.",
            "When filtering for singers above age 20: apply the condition age > 20 to select only those rows.",
            "When the question asks about \"countries with singers\", When filtering for singers above age 20, When asking for different countries: use DISTINCT on the country column to return unique country values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT country FROM singers WHERE age > 20;",
            "SELECT DISTINCT Country FROM singer WHERE Age > 20"
        ],
        "rule_sql": [
            "SELECT DISTINCT Country FROM singer WHERE Age > 20;"
        ]
    },
    "10": {
        "db_id": "concert_singer",
        "question": "Show all countries and the number of singers in each country.",
        "ground_truth": "SELECT country ,  count(*) FROM singer GROUP BY country",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause, correcting the table name to match the intended data source. The amended query now matches RIGHT_SQL's behavior with the proper table reference."
        ],
        "rules": [
            "When the question asks for countries and singer counts: use the exact table name \"singer\" instead of \"singers\" as shown in the schema.",
            "When the question asks for countries and singer counts, When counting singers per country: count using the canonical key from the singer table (though not explicitly shown, the amendment indicates the table reference correction is the primary requirement)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country, COUNT(*) FROM singers GROUP BY country;",
            "SELECT Country, COUNT(*) AS NumberOfSingers FROM singer GROUP BY Country;"
        ],
        "rule_sql": [
            "SELECT Country, COUNT(*) AS NumberOfSingers FROM singer GROUP BY Country;"
        ]
    },
    "11": {
        "db_id": "concert_singer",
        "question": "How many singers are from each country?",
        "ground_truth": "SELECT country ,  count(*) FROM singer GROUP BY country",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause, as the correct table name is singular rather than plural. The amended query now correctly counts records by country from the singer table, matching the intended behavior."
        ],
        "rules": [
            "When the question asks about \"singers\": use the exact table name \"singer\" instead of the plural form \"singers\".",
            "When counting entities from the singer table: use the canonical table reference \"singer\" without any alias.",
            "When grouping by country: use the exact column name \"country\" from the singer table.",
            "When the question asks about \"singers\", When counting entities from the singer table, When grouping by country, When counting singers per country: count all rows in each country group using the standard count function."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country, COUNT(*) FROM singers GROUP BY country;",
            "SELECT Country, COUNT(*) AS Singer_Count FROM singer GROUP BY Country;"
        ],
        "rule_sql": [
            "SELECT country, COUNT(*) FROM singer GROUP BY country;"
        ]
    },
    "12": {
        "db_id": "concert_singer",
        "question": "List all song names by singers above the average age.",
        "ground_truth": "SELECT song_name FROM singer WHERE age  >  (SELECT avg(age) FROM singer)",
        "amends": [
            "Do reference table `singer` instead of `songs` in the FROM clause. Do use column `age` instead of `singer_age` in both the main query and subquery. Do reference table `singer` instead of `singers` in the subquery's FROM clause. Do use aggregate function `avg(age)` instead of `AVG(singer_age)` in the subquery. The amended query now correctly filters songs based on singers whose age exceeds the average age of all singers, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"song names by singers above the average age\": make sure the output order: song_name.",
            "When the question mentions \"singers\": \"singers\" actually means \"singer in schema\".",
            "When the question mentions \"age\": \"age\" actually means \"age in schema\".",
            "When filtering singers by age above average: compute the average age from all singers using avg(age) and compare each singer's age to that average value.",
            "When answering about \"song names by singers above the average age\", When the question mentions \"singers\", When the question mentions \"age\", When filtering singers by age above average, When the question asks for \"song names by singers\": ensure the result includes only songs from singers who meet the age condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT song_name FROM songs WHERE singer_age > (SELECT AVG(singer_age) FROM singers);",
            "SELECT Song_Name FROM singer WHERE Age > (SELECT AVG(Age) FROM singer)"
        ],
        "rule_sql": [
            "SELECT s.Song_Name \nFROM singer s\nWHERE s.Age > (SELECT AVG(Age) FROM singer)\nORDER BY s.Song_Name;"
        ]
    },
    "13": {
        "db_id": "concert_singer",
        "question": "What are all the song names by singers who are older than average?",
        "ground_truth": "SELECT song_name FROM singer WHERE age  >  (SELECT avg(age) FROM singer)",
        "amends": [
            "Do reference table `singer` instead of `songs` in the FROM clause. Do use column `age` instead of `singer_age` for the comparison. Do reference table `singer` instead of `singers` in the subquery. Do use column `age` instead of `singer_age` in the subquery's AVG function. The amended query now correctly filters songs based on singers whose age exceeds the average age of all singers, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"song names by singers who are older than average\": make sure the output order: song_name.",
            "When the question mentions \"singers\": \"singers\" actually means table \"singer\" in schema.",
            "When the question mentions \"older than average\": compute the average of column \"age\" from table \"singer\" and filter for rows where \"age\" is greater than that average value.",
            "When answering about \"song names by singers who are older than average\", When the question mentions \"singers\", When the question mentions \"older than average\", When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT song_name FROM songs WHERE singer_age > (SELECT AVG(singer_age) FROM singers);",
            "SELECT s.Song_Name FROM singer s WHERE s.Age > (SELECT AVG(age) FROM singer)"
        ],
        "rule_sql": [
            "SELECT \"Song_Name\" FROM \"singer\" WHERE \"Age\" > (SELECT AVG(\"Age\") FROM \"singer\") ORDER BY \"Song_Name\""
        ]
    },
    "14": {
        "db_id": "concert_singer",
        "question": "Show location and name for all stadiums with a capacity between 5000 and 10000.",
        "ground_truth": "SELECT LOCATION ,  name FROM stadium WHERE capacity BETWEEN 5000 AND 10000",
        "amends": [
            "Do use the table name `stadium` instead of `stadiums`. Do use `BETWEEN 5000 AND 10000` instead of `capacity < 5000 OR capacity > 10000` to select stadiums with capacity within the specified range rather than outside it. Do capitalize `LOCATION` instead of `location` while keeping the same column selection. The amended query now correctly filters for stadiums with capacity between 5000 and 10000, matching the intended behavior."
        ],
        "rules": [
            "When the question asks about stadiums: use the exact table name \"stadium\" instead of \"stadiums\".",
            "When filtering for capacity between 5000 and 10000: use BETWEEN 5000 AND 10000 to include both bounds inclusively, not capacity < 5000 OR capacity > 10000 which would exclude the range.",
            "When the question asks about stadiums, When filtering for capacity between 5000 and 10000, When selecting the location column: use the exact column name \"LOCATION\" with uppercase letters as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location, name FROM stadiums WHERE capacity < 5000 OR capacity > 10000;",
            "SELECT LOCATION, Name FROM stadium WHERE Capacity BETWEEN 5000 AND 10000;"
        ],
        "rule_sql": [
            "SELECT LOCATION, Name FROM stadium WHERE Capacity BETWEEN 5000 AND 10000;"
        ]
    },
    "15": {
        "db_id": "concert_singer",
        "question": "What are the locations and names of all stations with capacity between 5000 and 10000?",
        "ground_truth": "SELECT LOCATION ,  name FROM stadium WHERE capacity BETWEEN 5000 AND 10000",
        "amends": [
            "Do reference table `stadium` instead of `stations` in the FROM clause. Do use `BETWEEN 5000 AND 10000` instead of `capacity > 10000 OR capacity < 5000` in the WHERE filter to select capacities within the range rather than outside it. Do capitalize `LOCATION` instead of `location` in the SELECT list while keeping the same column semantics. The amended query now correctly selects stadium locations and names within the specified capacity range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks about \"stations\": use the table \"stadium\" instead of \"stations\" as the data source.",
            "When filtering for capacity between 5000 and 10000: use the condition \"BETWEEN 5000 AND 10000\" to include both bounds (inclusive range) rather than excluding values outside this range.",
            "When the question asks about \"stations\", When filtering for capacity between 5000 and 10000, When selecting location information: use the exact column name \"LOCATION\" (capitalized) instead of \"location\" while maintaining the same semantic meaning."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location, name FROM stations WHERE capacity > 10000 OR capacity < 5000;",
            "SELECT Location, Name FROM stadium WHERE Capacity BETWEEN 5000 AND 10000;"
        ],
        "rule_sql": [
            "SELECT LOCATION, Name FROM stadium WHERE Capacity BETWEEN 5000 AND 10000;"
        ]
    },
    "16": {
        "db_id": "concert_singer",
        "question": "What is the maximum capacity and the average of all stadiums ?",
        "ground_truth": "select max(capacity), average from stadium",
        "amends": [
            "Do `max(capacity)` instead of `MIN(capacity)` for the maximum value calculation. Do `average` instead of `AVG(capacity)` for the average column alias. Do `stadium` instead of `stadiums` for the correct table name. The amended query now correctly calculates maximum capacity with proper table reference and column aliasing.",
            "Do include the `average` column directly in the SELECT list instead of calculating it with `AVG(Capacity) AS average`. Do remove the alias `maximum` from the `MAX(Capacity)` expression instead of keeping it. The amended query now matches RIGHT_SQL's behavior by selecting the maximum capacity and the average column directly from the stadium table."
        ],
        "rules": [
            "When calculating maximum capacity: use max(capacity) instead of MIN(capacity) for the maximum value calculation.",
            "When calculating the average capacity: use average instead of AVG(capacity) for the column alias.",
            "When calculating maximum capacity, When calculating the average capacity, When referencing the stadiums table: use stadium instead of stadiums for the correct table name.",
            "When answering about maximum capacity and average of all stadiums: select both MAX(Capacity) and the average column directly from the stadium table.",
            "When calculating maximum capacity: use MAX(Capacity) without an alias.",
            "When answering about maximum capacity and average of all stadiums, When calculating maximum capacity, When including the average value: select the average column directly instead of calculating it with AVG(Capacity)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(capacity), AVG(capacity) FROM stadiums;",
            "SELECT MAX(Capacity) AS maximum, AVG(Capacity) AS average FROM stadium;",
            "SELECT MAX(Capacity), average FROM stadium"
        ],
        "rule_sql": [
            "SELECT MAX(Capacity), average FROM stadium"
        ]
    },
    "17": {
        "db_id": "concert_singer",
        "question": "What is the average and maximum capacities for all stadiums ?",
        "ground_truth": "select avg(capacity) ,  max(capacity) from stadium",
        "amends": [
            "Do use `max(capacity)` instead of `min(capacity)` in the SELECT list to calculate the maximum capacity rather than the minimum. Do reference table `stadium` instead of `stadiums` to correctly identify the data source. The amended query now correctly calculates both average and maximum capacity values from the appropriate table."
        ],
        "rules": [
            "When calculating maximum capacity: use max(capacity) instead of min(capacity) to get the highest value.",
            "When calculating maximum capacity, When referencing the stadium data source: use table stadium instead of stadiums to correctly identify the data source."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(capacity), MIN(capacity) FROM stadiums;",
            "SELECT AVG(Capacity) AS Average_Capacity, MAX(Capacity) AS Maximum_Capacity FROM stadium;"
        ],
        "rule_sql": [
            "SELECT AVG(Capacity) AS Average_Capacity, MAX(Capacity) AS Maximum_Capacity FROM stadium;"
        ]
    },
    "18": {
        "db_id": "concert_singer",
        "question": "What is the name and capacity for the stadium with highest average attendance?",
        "ground_truth": "SELECT name ,  capacity FROM stadium ORDER BY average DESC LIMIT 1",
        "amends": [
            "Do reference table `stadium` instead of `stadiums` in the FROM clause. Do order by column `average` instead of `attendance` in the ORDER BY clause. The amended query now correctly references the intended table and ordering column to match the desired behavior."
        ],
        "rules": [
            "When answering about stadium name and capacity: make sure the output order: name, capacity.",
            "When the question mentions \"stadiums\": \"stadiums\" actually means \"stadium\" in schema.",
            "When answering about stadium name and capacity, When the question mentions \"stadiums\", When the question mentions \"highest average attendance\": rank rows by average in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, capacity FROM stadiums ORDER BY attendance DESC LIMIT 1;",
            "SELECT Name, Capacity FROM stadium ORDER BY Average DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name, Capacity FROM stadium ORDER BY Average DESC LIMIT 1;"
        ]
    },
    "19": {
        "db_id": "concert_singer",
        "question": "What is the name and capacity for the stadium with the highest average attendance?",
        "ground_truth": "SELECT name ,  capacity FROM stadium ORDER BY average DESC LIMIT 1",
        "amends": [
            "Do reference table `stadium` instead of `stadiums` in the FROM clause. Do order by `average` instead of `capacity` in the ORDER BY clause. The amended query now correctly references the intended table and sorts by the average column rather than capacity, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks about stadium information: use table \"stadium\" (not \"stadiums\") as the base table T1.",
            "When the question asks for the stadium with highest average attendance: order rows by column \"average\" in descending direction and keep only the first row.",
            "When the question asks about stadium information, When the question asks for the stadium with highest average attendance, When producing output for stadium details: include columns \"name\" and \"capacity\" in that order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, capacity FROM stadiums ORDER BY capacity DESC LIMIT 1;",
            "SELECT Name, Capacity FROM stadium ORDER BY Average DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT name, capacity FROM stadium ORDER BY average DESC LIMIT 1;"
        ]
    },
    "20": {
        "db_id": "concert_singer",
        "question": "How many concerts are there in year 2014 or 2015?",
        "ground_truth": "SELECT count(*) FROM concert WHERE YEAR  =  2014 OR YEAR  =  2015",
        "amends": [
            "Do use `OR` instead of `AND` for the year filter to correctly count concerts from either 2014 or 2015 instead of incorrectly requiring concerts to be from both years simultaneously. Do reference table `concert` instead of `concerts` to match the correct table name. The amended query now correctly counts concerts from either 2014 or 2015, matching the intended behavior."
        ],
        "rules": [
            "When the question asks about concerts: use the exact table name \"concert\" instead of \"concerts\".",
            "When filtering for multiple years with \"or\" logic: use OR between year conditions instead of AND to include records from either year.",
            "When the question asks about concerts, When filtering for multiple years with \"or\" logic, When counting concerts from year 2014 or 2015: filter where year equals 2014 OR year equals 2015 to correctly include concerts from either year rather than requiring both years simultaneously."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM concerts WHERE year = 2014 AND year = 2015;",
            "SELECT COUNT(*) FROM concert WHERE Year = '2014' OR Year = '2015'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM concert WHERE Year = '2014' OR Year = '2015';"
        ]
    },
    "21": {
        "db_id": "concert_singer",
        "question": "How many concerts occurred in 2014 or 2015?",
        "ground_truth": "SELECT count(*) FROM concert WHERE YEAR  =  2014 OR YEAR  =  2015",
        "amends": [
            "Do reference table `concert` instead of `concerts` in the FROM clause. Do use consistent case for the `YEAR` column instead of lowercase `year`. The amended query now correctly references the intended table and maintains consistent column naming to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks about concerts: use the exact table name \"concert\" instead of \"concerts\" as shown in the schema.",
            "When referring to the year column: use the exact column name \"YEAR\" with consistent uppercase case instead of lowercase \"year\".",
            "When the question asks about concerts, When referring to the year column, When counting concerts that occurred in specific years: count all rows from the \"concert\" table where the \"YEAR\" column equals 2014 or 2015."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM concerts WHERE year = 2014 OR year = 2015;",
            "SELECT COUNT(*) FROM concert WHERE Year = '2014' OR Year = '2015';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM concert WHERE YEAR = '2014' OR YEAR = '2015';"
        ]
    },
    "22": {
        "db_id": "concert_singer",
        "question": "Show the stadium name and the number of concerts in each stadium.",
        "ground_truth": "SELECT T2.name ,  count(*) FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id GROUP BY T1.stadium_id",
        "amends": [
            "Do join `stadium AS T2` on `T1.stadium_id = T2.stadium_id` instead of querying only the `concerts` table. Do select `T2.name` instead of `stadium_name` to properly reference the joined table's column. Do group by `T1.stadium_id` instead of `stadium_name` to ensure correct aggregation with the join relationship. The amended query now correctly counts concerts per stadium by joining the necessary tables and using proper column references."
        ],
        "rules": [
            "When answering about \"stadium name and number of concerts in each stadium\": make sure the output order: T2.name, count of concerts.",
            "When the question mentions \"stadium name\": \"stadium name\" actually means \"T2.name in schema\".",
            "When combining concerts as T1 and stadium as T2 for shared entities: link rows where T1.stadium_id = T2.stadium_id; keep only matching pairs (inner match).",
            "When the question asks for \"number of concerts in each stadium\": compute the count using T1.stadium_id as the counting key per stadium group.",
            "When answering about \"stadium name and number of concerts in each stadium\", When the question mentions \"stadium name\", When combining concerts as T1 and stadium as T2 for shared entities, When the question asks for \"number of concerts in each stadium\", When the question says \"per stadium\": organize results by T1.stadium_id and compute count of concerts per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT stadium_name, COUNT(*) FROM concerts GROUP BY stadium_name;",
            "SELECT T2.Name, COUNT(T1.concert_ID) AS number_of_concerts\nFROM concert AS T1\nJOIN stadium AS T2 ON T1.Stadium_ID = T2.Stadium_ID\nGROUP BY T1.Stadium_ID;"
        ],
        "rule_sql": [
            "SELECT T2.Name, COUNT(T1.concert_ID) \nFROM concert T1 \nINNER JOIN stadium T2 ON T1.Stadium_ID = T2.Stadium_ID \nGROUP BY T1.Stadium_ID \nORDER BY T2.Name, COUNT(T1.concert_ID)"
        ]
    },
    "23": {
        "db_id": "concert_singer",
        "question": "For each stadium, how many concerts play there?",
        "ground_truth": "SELECT T2.name ,  count(*) FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id GROUP BY T1.stadium_id",
        "amends": [
            "Do join `stadium AS T2` on `T1.stadium_id = T2.stadium_id` instead of omitting the stadium table entirely. Do select `T2.name` instead of `stadium_name` since the stadium name should come from the joined stadium table rather than a non-existent column. Do reference `concert AS T1` instead of `concerts` to use the correct table alias. Do group by `T1.stadium_id` instead of `stadium_id` to use the aliased column reference. The amended query now correctly joins the necessary tables and selects the stadium name from the appropriate source, matching the RIGHT_SQL's behavior.",
            "Do use `JOIN` instead of `RIGHT JOIN` to properly match stadiums with concerts. Do reference `T2.name` instead of `T2.Name` for case consistency. Do use `count(*)` instead of `COUNT(T1.concert_ID)` to count all rows including those where concert_ID might be NULL. Do group by `T1.stadium_id` instead of `T1.Stadium_ID` for case consistency. The amended query now correctly counts concerts per stadium using an inner join that only includes stadiums with associated concerts."
        ],
        "rules": [
            "When answering about \"how many concerts play there\" for each stadium: make sure the output order: T2.name first, then the count.",
            "When the question mentions \"stadium\": \"stadium\" actually means \"T2.name in schema\".",
            "When combining T1 and T2 for shared entities: link rows where T1.stadium_id = T2.stadium_id exactly as shown in the amends; keep only matching pairs (inner match).",
            "When the question asks for \"count of concerts\": compute the number of rows using the canonical key token for concerts (T1.stadium_id).",
            "When answering about \"how many concerts play there\" for each stadium, When the question mentions \"stadium\", When combining T1 and T2 for shared entities, When the question asks for \"count of concerts\", When the question says \"per stadium\"/\"by stadium\": organize results by T1.stadium_id and compute requested aggregates per group.",
            "When combining concert and stadium tables: link rows where T1.Stadium_ID = T2.Stadium_ID and keep only matching pairs (inner match).",
            "When counting concerts per stadium: count all rows using count(*) to include cases where concert_ID might be NULL.",
            "When grouping results by stadium: group by T1.stadium_id for case consistency.",
            "When selecting stadium names: use T2.name instead of T2.Name for case consistency.",
            "When combining concert and stadium tables, When counting concerts per stadium, When grouping results by stadium, When selecting stadium names, When answering about concerts per stadium: make sure the output order includes stadium name followed by concert count."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT stadium_name, COUNT(*) FROM concerts GROUP BY stadium_id;",
            "SELECT T2.Name, COUNT(T1.concert_ID) AS concert_count\nFROM concert AS T1\nRIGHT JOIN stadium AS T2 ON T1.Stadium_ID = T2.Stadium_ID\nGROUP BY T1.Stadium_ID",
            "SELECT T2.Name, COUNT(*) AS concert_count\nFROM concert AS T1\nJOIN stadium AS T2 ON T1.Stadium_ID = T2.Stadium_ID\nGROUP BY T1.Stadium_ID"
        ],
        "rule_sql": [
            "SELECT T2.name, COUNT(*) AS concert_count\nFROM concert T1\nINNER JOIN stadium T2 ON T1.Stadium_ID = T2.Stadium_ID\nGROUP BY T1.Stadium_ID\nORDER BY T2.name, concert_count"
        ]
    },
    "24": {
        "db_id": "concert_singer",
        "question": "Show the stadium name and capacity with most number of concerts in year 2014 or after.",
        "ground_truth": "SELECT T2.name ,  T2.capacity FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.year  >=  2014 GROUP BY T2.stadium_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.name` and `T2.capacity` instead of `stadium_name` and `capacity`. Do join `concert AS T1` with `stadium AS T2` on `T1.stadium_id = T2.stadium_id` instead of querying `stadiums` alone. Do filter on `T1.year >= 2014` instead of `year >= 2014`. Do add `GROUP BY T2.stadium_id` instead of omitting grouping. Do order by `count(*) DESC` instead of `capacity DESC` to find the stadium with the most concerts. The amended query now correctly identifies the stadium with the highest number of concerts since 2014 rather than simply the largest stadium capacity."
        ],
        "rules": [
            "When answering about stadium name and capacity: make sure the output order: T2.name, T2.capacity",
            "When the question mentions \"stadium name\": \"stadium name\" actually means \"T2.name in schema\"",
            "When the question mentions \"capacity\": \"capacity\" actually means \"T2.capacity in schema\"",
            "When combining concert AS T1 and stadium AS T2 for shared entities: link rows where T1.stadium_id = T2.stadium_id exactly as shown; keep only matching pairs (inner match)",
            "When filtering for concerts in year 2014 or after: apply condition T1.year >= 2014 using exact literal 2014",
            "When the question asks for stadium with most number of concerts: organize results by T2.stadium_id and count using T1.* (or equivalent counting key)",
            "When ranking by number of concerts: order rows by count(*) DESC to find the stadium with the highest count",
            "When answering about stadium name and capacity, When the question mentions \"stadium name\", When the question mentions \"capacity\", When combining concert AS T1 and stadium AS T2 for shared entities, When filtering for concerts in year 2014 or after, When the question asks for stadium with most number of concerts, When ranking by number of concerts, When the question asks for the stadium with most concerts: take only the first row after ordering by concert count descending"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT stadium_name, capacity \nFROM stadiums \nWHERE year >= 2014 \nORDER BY capacity DESC \nLIMIT 1;",
            "SELECT T2.Name, T2.Capacity\nFROM concert AS T1\nJOIN stadium AS T2 ON T1.Stadium_ID = T2.Stadium_ID\nWHERE T1.Year >= '2014'\nGROUP BY T2.Stadium_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.Name, T2.Capacity\nFROM concert AS T1\nINNER JOIN stadium AS T2 ON T1.Stadium_ID = T2.Stadium_ID\nWHERE T1.Year >= '2014'\nGROUP BY T2.Stadium_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "25": {
        "db_id": "concert_singer",
        "question": "What is the name and capacity of the stadium with the most concerts after 2013 ?",
        "ground_truth": "select t2.name ,  t2.capacity from concert as t1 join stadium as t2 on t1.stadium_id  =  t2.stadium_id where t1.year  >  2013 group by t2.stadium_id order by count(*) desc limit 1",
        "amends": [
            "Do select `t2.name` and `t2.capacity` from the `stadium` table instead of selecting `name` and `capacity` directly from `stadiums`. Do join `concert` as `t1` with `stadium` as `t2` on `t1.stadium_id = t2.stadium_id` instead of querying only the `stadiums` table. Do add a WHERE filter for `t1.year > 2013` instead of omitting any year condition. Do add GROUP BY on `t2.stadium_id` instead of not grouping. Do order by `count(*)` descending instead of ordering by `concerts_after_2013` descending. The amended query now correctly identifies the stadium with the most concerts after 2013 by joining concert data and counting events per stadium."
        ],
        "rules": [
            "When answering about stadium name and capacity: make sure the output order: t2.name, t2.capacity",
            "When the question mentions \"stadium with the most concerts after 2013\": join concert as t1 with stadium as t2 on t1.stadium_id = t2.stadium_id and keep only matching pairs (inner match)",
            "When filtering for concerts after 2013: add a WHERE condition for t1.year > 2013",
            "When counting concerts per stadium: group by t2.stadium_id and count using count(*)",
            "When answering about stadium name and capacity, When the question mentions \"stadium with the most concerts after 2013\", When filtering for concerts after 2013, When counting concerts per stadium, When finding the stadium with the most concerts: order by count(*) descending and keep only the first row"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, capacity FROM stadiums ORDER BY concerts_after_2013 DESC LIMIT 1;",
            "SELECT t2.Name, t2.Capacity\nFROM concert AS t1\nJOIN stadium AS t2 ON t1.Stadium_ID = t2.Stadium_ID\nWHERE t1.Year > '2013'\nGROUP BY t2.Stadium_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t2.Name, t2.Capacity\nFROM concert AS t1\nINNER JOIN stadium AS t2 ON t1.Stadium_ID = t2.Stadium_ID\nWHERE t1.Year > '2013'\nGROUP BY t2.Stadium_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "26": {
        "db_id": "concert_singer",
        "question": "Which year has most number of concerts?",
        "ground_truth": "SELECT YEAR FROM concert GROUP BY YEAR ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `YEAR` instead of both `year` and `concert_count`. Do use `concert` as the table name instead of `concerts`. Do order by `count(*) DESC` instead of `concert_count ASC` to find the year with the most concerts rather than the fewest. Do remove the explicit alias `concert_count` since it's not needed in the ORDER BY clause. The amended query now correctly identifies the year with the highest number of concerts by counting records per year and ordering descending by count."
        ],
        "rules": [
            "When answering about \"which year has most number of concerts\": make sure the output order: YEAR.",
            "When the question mentions \"concerts\": \"concerts\" actually means \"concert\" in schema.",
            "When the question asks for \"most number of concerts\": count the number of rows using the canonical key and order by count(*) DESC to find the year with the highest count.",
            "When answering about \"which year has most number of concerts\", When the question mentions \"concerts\", When the question asks for \"most number of concerts\", When producing output: do not include explicit aliases like concert_count in the final output columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, COUNT(*) as concert_count FROM concerts GROUP BY year ORDER BY concert_count ASC LIMIT 1;",
            "SELECT Year FROM concert GROUP BY Year ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Year FROM concert GROUP BY Year ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "27": {
        "db_id": "concert_singer",
        "question": "What is the year that had the most concerts?",
        "ground_truth": "SELECT YEAR FROM concert GROUP BY YEAR ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `YEAR` instead of both `year` and `concert_count`. Do use `count(*)` in the ORDER BY clause instead of selecting it as an alias. Do order by `DESC` instead of `ASC` to find the year with the most concerts. Do reference table `concert` instead of `concerts`. The amended query now correctly identifies the year with the highest number of concerts by counting records per year and ordering descending."
        ],
        "rules": [
            "When answering about \"the year that had the most concerts\": make sure the output order: YEAR.",
            "When counting concerts: count all rows using count(*) and use this count directly in ordering instead of selecting it as an output column.",
            "When finding the year with the most concerts: order the results by concert count in descending order (DESC) instead of ascending order (ASC).",
            "When answering about \"the year that had the most concerts\", When counting concerts, When finding the year with the most concerts, When referencing the concerts table: use the exact table name \"concert\" instead of \"concerts\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, COUNT(*) as concert_count FROM concerts GROUP BY year ORDER BY concert_count ASC LIMIT 1;",
            "SELECT Year FROM concert GROUP BY Year ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Year FROM concert GROUP BY Year ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "28": {
        "db_id": "concert_singer",
        "question": "Show the stadium names without any concert.",
        "ground_truth": "SELECT name FROM stadium WHERE stadium_id NOT IN (SELECT stadium_id FROM concert)",
        "amends": [
            "Do select `name` instead of `stadium_name` and use a subquery with `NOT IN` instead of checking `IS NULL` on `concert_id`. Do reference table `stadium` instead of `stadiums` and use `stadium_id` as the correlation key instead of `concert_id`. Do remove the direct null check filter and instead implement a subquery that identifies stadiums not present in the concert table, which correctly handles the case where stadiums may have no associated concerts. The amended query now matches the right SQL's behavior by properly identifying stadiums without any concerts through a correlated subquery approach."
        ],
        "rules": [
            "When the question asks for stadium names: use the exact column token \"name\" from the stadium table instead of \"stadium_name\".",
            "When identifying stadiums without concerts: use a subquery approach with NOT IN instead of checking for NULL values on concert_id.",
            "When referencing the stadium table: use the exact table name \"stadium\" instead of \"stadiums\".",
            "When correlating between stadium and concert tables: use \"stadium_id\" as the correlation key instead of \"concert_id\".",
            "When the question asks for stadium names, When identifying stadiums without concerts, When referencing the stadium table, When correlating between stadium and concert tables, When checking for stadiums without concerts: implement a subquery that identifies stadiums not present in the concert table to properly handle cases where stadiums may have no associated concerts."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT stadium_name FROM stadiums WHERE concert_id IS NULL;",
            "SELECT Name FROM stadium WHERE Stadium_ID NOT IN (SELECT Stadium_ID FROM concert)"
        ],
        "rule_sql": [
            "SELECT name FROM stadium WHERE stadium_id NOT IN (SELECT stadium_id FROM concert)"
        ]
    },
    "29": {
        "db_id": "concert_singer",
        "question": "What are the names of the stadiums without any concerts?",
        "ground_truth": "SELECT name FROM stadium WHERE stadium_id NOT IN (SELECT stadium_id FROM concert)",
        "amends": [
            "Do reference the correct table name `stadium` instead of the incorrect plural `stadiums`. Do use a subquery with `NOT IN` to filter stadiums not associated with any concerts instead of checking for `IS NULL` on a non-existent `concert_id` column. Do filter by `stadium_id NOT IN (SELECT stadium_id FROM concert)` instead of the incorrect `concert_id IS NULL` condition. The amended query now correctly identifies stadiums without concerts by checking the absence of stadium IDs in the concert table rather than relying on a missing column."
        ],
        "rules": [
            "When the question asks about stadiums without concerts: use the exact table name \"stadium\" instead of plural forms.",
            "When filtering for stadiums not associated with concerts: use a subquery with NOT IN condition checking stadium_id NOT IN (SELECT stadium_id FROM concert) instead of checking for NULL values on non-existent columns.",
            "When the question asks about stadiums without concerts, When filtering for stadiums not associated with concerts, When combining stadium and concert tables: use stadium_id as the linking key between the tables to identify which stadiums have concerts."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM stadiums WHERE concert_id IS NULL;",
            "SELECT Name FROM stadium WHERE Stadium_ID NOT IN (SELECT Stadium_ID FROM concert);"
        ],
        "rule_sql": [
            "SELECT Name FROM stadium WHERE Stadium_ID NOT IN (SELECT Stadium_ID FROM concert)"
        ]
    },
    "30": {
        "db_id": "concert_singer",
        "question": "Show countries where a singer above age 40 and a singer below 30 are from.",
        "ground_truth": "SELECT country FROM singer WHERE age  >  40 INTERSECT SELECT country FROM singer WHERE age  <  30",
        "amends": [
            "Do remove `DISTINCT` instead of keeping it, and do use `INTERSECT` with two separate queries instead of `OR` in the `WHERE` clause. Do change the table name from `singers` to `singer` instead of using the plural form. Do split the age conditions into separate queries for `age > 40` and `age < 30` instead of combining them with `OR`, and do use `INTERSECT` to find countries that appear in both result sets instead of finding countries where either condition is true. The amended query now correctly finds countries that have both singers over 40 and singers under 30, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for countries with both singers above age 40 and singers below age 30: use INTERSECT between two separate queries instead of OR in WHERE clause.",
            "When referring to the singers table: use the exact table name \"singer\" instead of the plural form \"singers\".",
            "When handling age conditions: split into separate queries for \"age > 40\" and \"age < 30\" instead of combining them with OR.",
            "When removing DISTINCT: do not include DISTINCT in the final query as it is not needed with INTERSECT.",
            "When the question asks for countries with both singers above age 40 and singers below age 30, When referring to the singers table, When handling age conditions, When removing DISTINCT, When finding countries that satisfy both conditions: use INTERSECT to find countries that appear in both the over-40 and under-30 result sets."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT country \nFROM singers \nWHERE age > 40 OR age < 30;",
            "SELECT Country FROM singer WHERE Age > 40 INTERSECT SELECT Country FROM singer WHERE Age < 30"
        ],
        "rule_sql": [
            "SELECT Country FROM singer WHERE Age > 40\nINTERSECT\nSELECT Country FROM singer WHERE Age < 30"
        ]
    },
    "31": {
        "db_id": "concert_singer",
        "question": "Show names for all stadiums except for stadiums having a concert in year 2014.",
        "ground_truth": "SELECT name FROM stadium EXCEPT SELECT T2.name FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.year  =  2014",
        "amends": [
            "Do use `EXCEPT` to filter out stadiums with concerts in 2014 instead of a simple inequality filter on year. Do add a join between `concert` and `stadium` tables on `stadium_id` instead of querying only the `stadiums` table. Do include the condition `T1.year = 2014` to specifically exclude stadiums hosting concerts in that year instead of filtering stadiums by their own year attribute. Do reference the correct table name `stadium` instead of `stadiums` throughout the query. The amended query now correctly identifies stadiums that did not host any concerts in 2014, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks to exclude stadiums having concerts in a specific year: use EXCEPT to filter out stadiums that match the exclusion condition instead of simple inequality filtering.",
            "When combining stadium and concert information: link rows where T1.stadium_id = T2.stadium_id to connect concerts to their stadiums.",
            "When excluding stadiums with concerts in 2014: specifically exclude stadiums where T1.year = 2014 to target concerts from that exact year.",
            "When referring to the stadium table: use the exact table name \"stadium\" instead of \"stadiums\" throughout the query.",
            "When the question asks to exclude stadiums having concerts in a specific year, When combining stadium and concert information, When excluding stadiums with concerts in 2014, When referring to the stadium table, When producing output: return only the \"name\" column from the stadium table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM stadiums WHERE year != 2014;",
            "SELECT Name FROM stadium EXCEPT SELECT s.Name FROM stadium s JOIN concert c ON s.Stadium_ID = c.Stadium_ID WHERE c.Year = '2014'"
        ],
        "rule_sql": [
            "SELECT Name FROM stadium EXCEPT SELECT s.Name FROM stadium s JOIN concert c ON s.Stadium_ID = c.Stadium_ID WHERE c.Year = '2014'"
        ]
    },
    "32": {
        "db_id": "concert_singer",
        "question": "What are the names of all stadiums that did not have a concert in 2014?",
        "ground_truth": "SELECT name FROM stadium EXCEPT SELECT T2.name FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.year  =  2014",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do add explicit table aliases `T1` and `T2` instead of omitting them. Do use `JOIN` with `ON T1.stadium_id = T2.stadium_id` instead of a correlated subquery. Do reference `T2.name` in the second part instead of just `name`. Do specify `FROM concert AS T1` and `FROM stadium AS T2` instead of the singular table names `concerts` and `stadiums`. The amended query now correctly handles potential NULL values in the stadium_id comparison and matches the RIGHT_SQL's behavior using set operations."
        ],
        "rules": [
            "When combining stadium and concert tables: link rows where T2.stadium_id = T1.stadium_id using an inner join.",
            "When filtering for concerts in 2014: include only rows where T1.year = 2014.",
            "When finding stadiums without concerts in 2014: use set difference (EXCEPT) between all stadiums and stadiums that had concerts in 2014.",
            "When selecting stadium names: output T2.name from the stadium table (T2).",
            "When combining stadium and concert tables, When filtering for concerts in 2014, When finding stadiums without concerts in 2014, When selecting stadium names, When referencing table names: use exact table names \"concert\" and \"stadium\" (singular) as shown in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM stadiums WHERE stadium_id NOT IN (SELECT stadium_id FROM concerts WHERE year = 2014);",
            "SELECT T2.Name\nFROM stadium AS T2\nEXCEPT\nSELECT T2.Name\nFROM concert AS T1\nJOIN stadium AS T2 ON T1.Stadium_ID = T2.Stadium_ID\nWHERE T1.Year = '2014'"
        ],
        "rule_sql": [
            "SELECT s.Name \nFROM stadium s\nEXCEPT\nSELECT s.Name \nFROM stadium s\nINNER JOIN concert c ON s.Stadium_ID = c.Stadium_ID\nWHERE c.Year = '2014';"
        ]
    },
    "33": {
        "db_id": "concert_singer",
        "question": "Show the name and theme for all concerts and the number of singers in each concert.",
        "ground_truth": "SELECT T2.concert_name ,  T2.theme ,  count(*) FROM singer_in_concert AS T1 JOIN concert AS T2 ON T1.concert_id  =  T2.concert_id GROUP BY T2.concert_id",
        "amends": [
            "Do select `concert_name` and `theme` instead of `name` and `theme`. Do join `singer_in_concert` with `concert` on `concert_id` instead of querying only the `concerts` table. Do count all rows with `count(*)` instead of counting `singer_id`. Do group by `T2.concert_id` instead of `concert_id` without table qualification. The amended query now correctly aggregates singer counts per concert by properly joining the concert and singer association tables."
        ],
        "rules": [
            "When the question asks for concert name and theme: select \"concert_name\" and \"theme\" columns instead of generic \"name\" and \"theme\".",
            "When counting singers in concerts: join \"singer_in_concert\" table with \"concert\" table using \"concert_id\" as the linking key.",
            "When counting the number of singers per concert: use count(*) to count all rows in the joined singer association table rather than counting a specific singer_id column.",
            "When grouping by concert identifier: use the fully qualified \"T2.concert_id\" with table alias qualification instead of unqualified \"concert_id\".",
            "When the question asks for concert name and theme, When counting singers in concerts, When counting the number of singers per concert, When grouping by concert identifier, When organizing results by concert: group by the concert's canonical key \"T2.concert_id\" to ensure proper aggregation per concert entity."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, theme, COUNT(singer_id) AS singer_count FROM concerts GROUP BY concert_id",
            "SELECT c.concert_Name, c.Theme, COUNT(*) AS singer_count\nFROM concert c\nLEFT JOIN singer_in_concert sic ON c.concert_ID = sic.concert_ID\nGROUP BY c.concert_ID, c.concert_Name, c.Theme"
        ],
        "rule_sql": [
            "SELECT c.concert_Name, c.Theme, COUNT(*) AS number_of_singers FROM concert c LEFT JOIN singer_in_concert sic ON c.concert_ID = sic.concert_ID GROUP BY c.concert_ID"
        ]
    },
    "34": {
        "db_id": "concert_singer",
        "question": "What are the names , themes , and number of singers for every concert ?",
        "ground_truth": "select t2.concert_name ,  t2.theme ,  count(*) from singer_in_concert as t1 join concert as t2 on t1.concert_id  =  t2.concert_id group by t2.concert_id",
        "amends": [
            "Do select `concert_name` and `theme` from the `concert` table instead of `name` and `theme` from an unspecified source. Do join `singer_in_concert` with `concert` on `concert_id` instead of querying only the `concerts` table. Do use `count(*)` to count all rows instead of `COUNT(singer_id)` which might miss null values. Do group by `t2.concert_id` from the joined table instead of grouping by `concert_id` from a single table. The amended query now correctly counts singers per concert by properly joining the relationship tables and grouping on the concert identifier."
        ],
        "rules": [
            "When answering about concert names and themes: select \"concert_name\" and \"theme\" from the \"concert\" table (T1).",
            "When counting singers per concert: join \"singer_in_concert\" (T2) with \"concert\" (T1) where T1.concert_id = T2.concert_id and count all rows using count(*).",
            "When grouping results by concert: group by T2.concert_id to organize results per concert.",
            "When answering about concert names and themes, When counting singers per concert, When grouping results by concert, When producing output columns: present them in the order concert_name, theme, number_of_singers."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, theme, COUNT(singer_id) AS number_of_singers FROM concerts GROUP BY concert_id;",
            "SELECT c.concert_Name, c.Theme, COUNT(*) AS number_of_singers\nFROM concert c\nJOIN singer_in_concert sic ON c.concert_ID = sic.concert_ID\nGROUP BY c.concert_ID, c.concert_Name, c.Theme;"
        ],
        "rule_sql": [
            "SELECT c.concert_Name, c.Theme, COUNT(sic.Singer_ID) AS number_of_singers FROM concert c LEFT JOIN singer_in_concert sic ON c.concert_ID = sic.concert_ID GROUP BY c.concert_ID ORDER BY c.concert_Name, c.Theme"
        ]
    },
    "35": {
        "db_id": "concert_singer",
        "question": "List singer names and number of concerts for each singer.",
        "ground_truth": "SELECT T2.name ,  count(*) FROM singer_in_concert AS T1 JOIN singer AS T2 ON T1.singer_id  =  T2.singer_id GROUP BY T2.singer_id",
        "amends": [
            "Do select `T2.name` instead of `singer_name` and join `singer_in_concert AS T1` with `singer AS T2` on `T1.singer_id = T2.singer_id` instead of querying `singers` directly, then group by `T2.singer_id` instead of `singer_id` to correctly count concerts per singer while preserving the intended aggregation logic."
        ],
        "rules": [
            "When the question asks for \"singer names\": use \"T2.name\" as the exact output column for singer names.",
            "When counting concerts per singer: join \"singer_in_concert AS T1\" with \"singer AS T2\" where \"T1.singer_id = T2.singer_id\" to link concerts to singers.",
            "When grouping to count concerts per singer: group by \"T2.singer_id\" to ensure correct aggregation per singer.",
            "When the question asks for \"singer names\", When counting concerts per singer, When grouping to count concerts per singer, When computing number of concerts: count the rows using the canonical key from the concert table to get the concert count per singer."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT singer_name, COUNT(*) FROM singers GROUP BY singer_id;",
            "SELECT T2.Name, COUNT(T1.concert_ID) AS number_of_concerts\nFROM singer_in_concert AS T1\nJOIN singer AS T2 ON T1.Singer_ID = T2.Singer_ID\nGROUP BY T2.Singer_ID"
        ],
        "rule_sql": [
            "SELECT T2.Name, COUNT(T1.concert_ID) AS NumberOfConcerts FROM singer_in_concert AS T1 JOIN singer AS T2 ON T1.Singer_ID = T2.Singer_ID GROUP BY T2.Singer_ID"
        ]
    },
    "36": {
        "db_id": "concert_singer",
        "question": "What are the names of the singers and number of concerts for each person?",
        "ground_truth": "SELECT T2.name ,  count(*) FROM singer_in_concert AS T1 JOIN singer AS T2 ON T1.singer_id  =  T2.singer_id GROUP BY T2.singer_id",
        "amends": [
            "Do join `singer_in_concert` and `singer` tables with `JOIN` on `T1.singer_id = T2.singer_id` instead of querying only the `singers` table. Do select from `singer_in_concert AS T1` and `singer AS T2` instead of the single `singers` table. Do group by `T2.singer_id` instead of `name` to ensure proper aggregation. Do reference `T2.name` in the SELECT list instead of just `name` to make the column reference explicit. The amended query now correctly counts concert appearances per singer by joining the relevant tables and grouping by singer ID instead of name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"names of singers and number of concerts for each person\": make sure the output order: T2.name, COUNT(*)",
            "When combining T1 and T2 for shared entities: link rows where T1.singer_id = T2.singer_id exactly as shown in the amends; keep only matching pairs (inner match).",
            "When the question asks for \"number of concerts for each person\": compute the count using the canonical key T1.singer_id from the singer_in_concert table.",
            "When the question says \"per person\"/\"for each person\": organize results by T2.singer_id and compute requested aggregates per group.",
            "When answering about \"names of singers and number of concerts for each person\", When combining T1 and T2 for shared entities, When the question asks for \"number of concerts for each person\", When the question says \"per person\"/\"for each person\", When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table names like \"singer_in_concert\" and \"singer\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, COUNT(*) FROM singers GROUP BY name;",
            "SELECT T2.Name, COUNT(T1.concert_ID) AS Number_of_Concerts\nFROM singer_in_concert AS T1\nJOIN singer AS T2 ON T1.Singer_ID = T2.Singer_ID\nGROUP BY T2.Singer_ID"
        ],
        "rule_sql": [
            "SELECT s.\"Name\", COUNT(*) \nFROM \"singer_in_concert\" sic\nJOIN \"singer\" s ON sic.\"Singer_ID\" = s.\"Singer_ID\"\nGROUP BY s.\"Singer_ID\", s.\"Name\"\nORDER BY s.\"Name\", COUNT(*)"
        ]
    },
    "37": {
        "db_id": "concert_singer",
        "question": "List all singer names in concerts in year 2014.",
        "ground_truth": "SELECT T2.name FROM singer_in_concert AS T1 JOIN singer AS T2 ON T1.singer_id  =  T2.singer_id JOIN concert AS T3 ON T1.concert_id  =  T3.concert_id WHERE T3.year  =  2014",
        "amends": [
            "Do select `T2.name` from the `singer` table instead of `singer_name` from a non-existent source. Do join `singer_in_concert AS T1` to `singer AS T2` on `T1.singer_id = T2.singer_id` instead of missing this relationship entirely. Do add a second join to `concert AS T3` on `T1.concert_id = T3.concert_id` instead of omitting the concert table. Do filter on `T3.year = 2014` instead of filtering on a non-existent `year` column in the wrong table. The amended query now correctly retrieves singer names for concerts in 2014 by properly joining through the relationship tables."
        ],
        "rules": [
            "When the question asks for \"singer names\": use \"T2.name\" from the \"singer\" table instead of \"singer_name\" from a non-existent source.",
            "When combining data about singers in concerts: join \"singer_in_concert AS T1\" to \"singer AS T2\" on \"T1.singer_id = T2.singer_id\" to establish the relationship.",
            "When needing concert year information: join \"concert AS T3\" on \"T1.concert_id = T3.concert_id\" to access concert details.",
            "When the question asks for \"singer names\", When combining data about singers in concerts, When needing concert year information, When filtering for concerts in year 2014: use \"T3.year = 2014\" instead of filtering on a non-existent \"year\" column in the wrong table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT singer_name FROM concerts WHERE year = 2014;",
            "SELECT T2.Name \nFROM singer_in_concert AS T1\nJOIN singer AS T2 ON T1.Singer_ID = T2.Singer_ID\nJOIN concert AS T3 ON T1.concert_ID = T3.concert_ID\nWHERE T3.Year = '2014'"
        ],
        "rule_sql": [
            "SELECT T2.Name \nFROM singer_in_concert AS T1\nJOIN singer AS T2 ON T1.Singer_ID = T2.Singer_ID\nJOIN concert AS T3 ON T1.concert_ID = T3.concert_ID\nWHERE T3.Year = '2014'"
        ]
    },
    "38": {
        "db_id": "concert_singer",
        "question": "What are the names of the singers who performed in a concert in 2014?",
        "ground_truth": "SELECT T2.name FROM singer_in_concert AS T1 JOIN singer AS T2 ON T1.singer_id  =  T2.singer_id JOIN concert AS T3 ON T1.concert_id  =  T3.concert_id WHERE T3.year  =  2014",
        "amends": [
            "Do select `T2.name` from the `singer` table instead of `name` from the `singers` table. Do add joins to `singer_in_concert AS T1` and `concert AS T3` instead of querying only the `singers` table. Do use `LEFT JOIN` on `T1.singer_id = T2.singer_id` and `LEFT JOIN` on `T1.concert_id = T3.concert_id` instead of no joins. Do filter on `T3.year = 2014` instead of `concert_year = 2014` since the year column exists in the concert table rather than the singers table. The amended query now correctly joins through the association table to find singers who performed in concerts during 2014."
        ],
        "rules": [
            "When answering about singers who performed in concerts: use T2.name from the singer table instead of name from singers table.",
            "When combining singer and concert information: join through singer_in_concert as T1 using LEFT JOIN on T1.singer_id = T2.singer_id and LEFT JOIN on T1.concert_id = T3.concert_id.",
            "When answering about singers who performed in concerts, When combining singer and concert information, When filtering for concerts in 2014: use T3.year = 2014 instead of concert_year since year exists in the concert table rather than singers table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers WHERE concert_year = 2014;",
            "SELECT T2.Name \nFROM singer AS T2\nLEFT JOIN singer_in_concert AS T1 ON T1.Singer_ID = T2.Singer_ID\nLEFT JOIN concert AS T3 ON T1.concert_ID = T3.concert_ID\nWHERE T3.Year = '2014'"
        ],
        "rule_sql": [
            "SELECT T2.Name \nFROM singer T2\nLEFT JOIN singer_in_concert T1 ON T1.Singer_ID = T2.Singer_ID\nLEFT JOIN concert T3 ON T1.concert_ID = T3.concert_ID\nWHERE T3.Year = '2014'\nGROUP BY T2.Singer_ID"
        ]
    },
    "39": {
        "db_id": "concert_singer",
        "question": "what is the name and nation of the singer who have a song having 'Hey' in its name?",
        "ground_truth": "SELECT name ,  country FROM singer WHERE song_name LIKE '%Hey%'",
        "amends": [
            "Do use column alias `country` instead of `nation` in the SELECT list while keeping the same `name` column and maintaining the identical WHERE filter `song_name LIKE '%Hey%'` without any changes to table sources, join conditions, grouping, ordering, or other clauses. The amended query now correctly retrieves the country information using the proper column name while preserving all other query logic and behavior."
        ],
        "rules": [
            "When the question mentions \"nation\": use the exact column token \"country\" instead of \"nation\" in the output.",
            "When filtering for songs containing 'Hey' in their name: apply the exact filter condition song_name LIKE '%Hey%' without changing the pattern.",
            "When the question mentions \"nation\", When filtering for songs containing 'Hey' in their name, When selecting output columns: maintain the order name followed by country as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, nation FROM singer WHERE song_name LIKE '%Hey%'",
            "SELECT name, country FROM singer WHERE song_name LIKE '%Hey%'"
        ],
        "rule_sql": [
            "SELECT Name, Country FROM singer WHERE Song_Name LIKE '%Hey%';"
        ]
    },
    "40": {
        "db_id": "concert_singer",
        "question": "What is the name and country of origin of every singer who has a song with the word 'Hey' in its title?",
        "ground_truth": "SELECT name ,  country FROM singer WHERE song_name LIKE '%Hey%'",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause. Do filter on column `song_name` instead of `title` in the WHERE condition with the LIKE pattern '%Hey%'. The amended query now correctly retrieves artist names and countries from the singer table based on song titles containing 'Hey'."
        ],
        "rules": [
            "When answering about singers and their countries: use table \"singer\" (not \"singers\") to get name and country information.",
            "When filtering for songs with 'Hey' in the title: use column \"song_name\" (not \"title\") with the exact pattern '%Hey%' to match song titles containing the word 'Hey'.",
            "When answering about singers and their countries, When filtering for songs with 'Hey' in the title, When the question asks for name and country of origin: output columns should be \"name\" and \"country\" in that order from the \"singer\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, country FROM singers WHERE title LIKE '%Hey%';",
            "SELECT Name, Country FROM singer WHERE Song_Name LIKE '%Hey%';"
        ],
        "rule_sql": [
            "SELECT name, country FROM singer WHERE song_name LIKE '%Hey%';"
        ]
    },
    "41": {
        "db_id": "concert_singer",
        "question": "Find the name and location of the stadiums which some concerts happened in the years of both 2014 and 2015.",
        "ground_truth": "SELECT T2.name ,  T2.location FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.Year  =  2014 INTERSECT SELECT T2.name ,  T2.location FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.Year  =  2015",
        "amends": [
            "Do use `concert` and `stadium` tables with `JOIN` on `stadium_id` instead of querying only `stadiums` table. Do filter by `Year = 2014` in one branch and `Year = 2015` in another instead of the impossible `year = 2014 AND year = 2015`. Do use `INTERSECT` to find stadiums that hosted concerts in both years instead of attempting to find a single row satisfying both year conditions simultaneously. Do reference columns with table aliases `T2.name` and `T2.location` instead of unqualified `name` and `location`. The amended query now correctly identifies stadiums that hosted concerts in both 2014 and 2015 by using intersection logic instead of the contradictory WHERE clause."
        ],
        "rules": [
            "When answering about stadiums that hosted concerts in both 2014 and 2015: use the concert and stadium tables instead of only the stadiums table.",
            "When combining concert and stadium tables: link rows where T1.stadium_id = T2.stadium_id and keep only matching pairs (inner match).",
            "When filtering for concerts in 2014: include only rows where T1.Year = 2014.",
            "When filtering for concerts in 2015: include only rows where T1.Year = 2015.",
            "When finding stadiums with concerts in both years: use INTERSECT logic to combine results from the 2014 and 2015 filters.",
            "When answering about stadiums that hosted concerts in both 2014 and 2015, When combining concert and stadium tables, When filtering for concerts in 2014, When filtering for concerts in 2015, When finding stadiums with concerts in both years, When selecting stadium information: output T2.name and T2.location instead of unqualified name and location columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, location FROM stadiums WHERE year = 2014 AND year = 2015;",
            "SELECT T2.Name, T2.Location\nFROM concert T1\nJOIN stadium T2 ON T1.Stadium_ID = T2.Stadium_ID\nWHERE T1.Year = '2014'\nINTERSECT\nSELECT T2.Name, T2.Location\nFROM concert T1\nJOIN stadium T2 ON T1.Stadium_ID = T2.Stadium_ID\nWHERE T1.Year = '2015'"
        ],
        "rule_sql": [
            "SELECT T2.Name, T2.Location\nFROM concert T1\nINNER JOIN stadium T2 ON T1.Stadium_ID = T2.Stadium_ID\nWHERE T1.Year = '2014'\nINTERSECT\nSELECT T2.Name, T2.Location\nFROM concert T1\nINNER JOIN stadium T2 ON T1.Stadium_ID = T2.Stadium_ID\nWHERE T1.Year = '2015'"
        ]
    },
    "42": {
        "db_id": "concert_singer",
        "question": "What are the names and locations of the stadiums that had concerts that occurred in both 2014 and 2015?",
        "ground_truth": "SELECT T2.name ,  T2.location FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.Year  =  2014 INTERSECT SELECT T2.name ,  T2.location FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.Year  =  2015",
        "amends": [
            "Do use `concert` and `stadium` tables with `JOIN` on `stadium_id` instead of querying `stadiums` table alone. Do filter by `Year = 2014` in one branch and `Year = 2015` in another instead of the impossible `year = 2014 AND year = 2015`. Do use `INTERSECT` to find stadiums that hosted concerts in both years instead of attempting to find a single row satisfying both year conditions simultaneously. Do reference columns with table aliases `T1` and `T2` instead of direct column names. The amended query now correctly identifies stadiums that hosted concerts in both 2014 and 2015, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about stadiums that had concerts in both 2014 and 2015: use the concert table and stadium table instead of just the stadiums table.",
            "When combining concert and stadium tables: link rows where T1.stadium_id = T2.stadium_id using an inner match.",
            "When filtering for concerts in 2014: use T1.Year = 2014 as one condition.",
            "When filtering for concerts in 2015: use T1.Year = 2015 as another condition.",
            "When finding stadiums with concerts in both years: use INTERSECT to combine results from the 2014 and 2015 filters instead of trying to satisfy both year conditions on the same row.",
            "When selecting output columns: include name and location from the stadium table with proper table aliases.",
            "When answering about stadiums that had concerts in both 2014 and 2015, When combining concert and stadium tables, When filtering for concerts in 2014, When filtering for concerts in 2015, When finding stadiums with concerts in both years, When selecting output columns, When referencing columns: use table aliases T1 and T2 instead of direct column names without aliases."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, location FROM stadiums WHERE year = 2014 AND year = 2015;",
            "SELECT DISTINCT s.Name, s.Location\nFROM stadium s\nJOIN concert c1 ON s.Stadium_ID = c1.Stadium_ID\nJOIN concert c2 ON s.Stadium_ID = c2.Stadium_ID\nWHERE c1.Year = '2014' AND c2.Year = '2015'"
        ],
        "rule_sql": [
            "SELECT T2.Name, T2.Location\nFROM concert T1\nINNER JOIN stadium T2 ON T1.Stadium_ID = T2.Stadium_ID\nWHERE T1.Year = '2014'\nINTERSECT\nSELECT T2.Name, T2.Location\nFROM concert T1\nINNER JOIN stadium T2 ON T1.Stadium_ID = T2.Stadium_ID\nWHERE T1.Year = '2015'"
        ]
    },
    "43": {
        "db_id": "concert_singer",
        "question": "Find the number of concerts happened in the stadium with the highest capacity .",
        "ground_truth": "select count(*) from concert where stadium_id = (select stadium_id from stadium order by capacity desc limit 1)",
        "amends": [
            "Do reference table `concert` instead of `concerts` and use `stadium` instead of `stadiums` in the subquery to match the correct schema. The amended query now correctly counts concerts at the stadium with the highest capacity by using the proper table names while maintaining the same logical structure and behavior."
        ],
        "rules": [
            "When the question mentions \"concerts\": use the exact table name \"concert\" instead of \"concerts\" as shown in the schema.",
            "When the question mentions \"stadiums\": use the exact table name \"stadium\" instead of \"stadiums\" as shown in the schema.",
            "When finding the stadium with the highest capacity: order stadium rows by capacity in descending direction and keep only the first row.",
            "When the question mentions \"concerts\", When the question mentions \"stadiums\", When finding the stadium with the highest capacity, When counting concerts at a specific stadium: count rows from the concert table where stadium_id matches the stadium with the highest capacity."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM concerts WHERE stadium_id = (SELECT stadium_id FROM stadiums ORDER BY capacity DESC LIMIT 1);",
            "SELECT COUNT(*) \nFROM concert \nWHERE Stadium_ID = (\n    SELECT Stadium_ID \n    FROM stadium \n    ORDER BY Capacity DESC \n    LIMIT 1\n)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM concert WHERE Stadium_ID = (SELECT Stadium_ID FROM stadium ORDER BY Capacity DESC LIMIT 1)"
        ]
    },
    "44": {
        "db_id": "concert_singer",
        "question": "What are the number of concerts that occurred in the stadium with the largest capacity ?",
        "ground_truth": "select count(*) from concert where stadium_id = (select stadium_id from stadium order by capacity desc limit 1)",
        "amends": [
            "Do reference table `concert` instead of `concerts` and use `stadium` instead of `stadiums` in the subquery to match the correct schema. The amended query now correctly counts concerts at the stadium with the highest capacity by fixing the table names while preserving the same logical structure and behavior."
        ],
        "rules": [
            "When the question asks about \"concerts\": use the exact table name \"concert\" instead of \"concerts\" as shown in the schema.",
            "When the question asks about \"stadiums\": use the exact table name \"stadium\" instead of \"stadiums\" as shown in the schema.",
            "When finding the stadium with the largest capacity: order stadium rows by capacity in descending order and take the first row.",
            "When the question asks about \"concerts\", When the question asks about \"stadiums\", When finding the stadium with the largest capacity, When counting concerts for a specific stadium: count rows from the concert table where stadium_id matches the stadium_id of the stadium with largest capacity."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM concerts WHERE stadium_id = (SELECT stadium_id FROM stadiums ORDER BY capacity DESC LIMIT 1);",
            "SELECT COUNT(*) \nFROM concert \nWHERE Stadium_ID IN (\n    SELECT Stadium_ID \n    FROM stadium \n    WHERE Capacity = (SELECT MAX(Capacity) FROM stadium)\n)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM concert \nWHERE Stadium_ID = (\n    SELECT Stadium_ID \n    FROM stadium \n    ORDER BY Capacity DESC \n    LIMIT 1\n)"
        ]
    },
    "45": {
        "db_id": "pets_1",
        "question": "Find the number of pets whose weight is heavier than 10.",
        "ground_truth": "SELECT count(*) FROM pets WHERE weight  >  10",
        "amends": [
            "Do use the comparison operator `>` instead of `<` in the WHERE filter condition, changing `weight < 10` to `weight > 10` to count pets with weight greater than 10 instead of less than 10. The amended query now correctly matches the intended behavior of counting records where weight exceeds the threshold value."
        ],
        "rules": [
            "When counting pets with weight heavier than 10: use the comparison operator > instead of < to filter for weight values greater than 10.",
            "When filtering on weight values: use the exact literal value 10 without quotes as specified in the question.",
            "When counting pets with weight heavier than 10, When filtering on weight values, When counting pets: count all rows that satisfy the weight > 10 condition to get the number of pets heavier than 10."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM pets WHERE weight < 10;",
            "SELECT COUNT(*) FROM Pets WHERE weight > 10;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Pets WHERE weight > 10;"
        ]
    },
    "46": {
        "db_id": "pets_1",
        "question": "How many pets have a greater weight than 10?",
        "ground_truth": "SELECT count(*) FROM pets WHERE weight  >  10",
        "amends": [
            "Do use the comparison operator `>` instead of `<` in the WHERE filter, changing the condition from `weight < 10` to `weight > 10` to count pets weighing more than 10 units instead of less than 10 units. The amended query now correctly matches the intended behavior of counting records where weight exceeds the threshold value."
        ],
        "rules": [
            "When the question asks for pets with weight greater than 10: use the comparison operator > instead of < in the filter condition.",
            "When the question asks for pets with weight greater than 10, When counting pets that meet a weight condition: count all rows where the weight column value is greater than 10."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM pets WHERE weight < 10;",
            "SELECT COUNT(*) FROM Pets WHERE weight > 10;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Pets WHERE weight > 10;"
        ]
    },
    "47": {
        "db_id": "pets_1",
        "question": "Find the weight of the youngest dog.",
        "ground_truth": "SELECT weight FROM pets ORDER BY pet_age LIMIT 1",
        "amends": [
            "Do select `weight` instead of `MAX(weight)` and change the source table from `dogs` to `pets`. Do remove the WHERE clause with subquery that found maximum weight for minimum age instead of keeping it. Do add `ORDER BY pet_age LIMIT 1` instead of omitting it to directly get the weight of the youngest pet. The amended query now correctly retrieves the weight of the youngest pet by ordering by age and taking the first result, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"the weight of the youngest dog\": make sure the output order: select only the \"weight\" column.",
            "When the question mentions \"dogs\": \"dogs\" actually means \"pets\" in schema.",
            "When the question asks for \"youngest\" (minimum age): order rows by \"pet_age\" in ascending direction and keep the first 1 row.",
            "When answering about \"the weight of the youngest dog\", When the question mentions \"dogs\", When the question asks for \"youngest\" (minimum age), When handling text literals: do not change case, spacing, or punctuation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(weight) FROM dogs WHERE age = (SELECT MIN(age) FROM dogs);",
            "SELECT weight FROM Pets WHERE PetType = 'dog' ORDER BY pet_age LIMIT 1"
        ],
        "rule_sql": [
            "SELECT weight FROM Pets WHERE PetType = 'dog' ORDER BY pet_age ASC LIMIT 1"
        ]
    },
    "48": {
        "db_id": "pets_1",
        "question": "How much does the youngest dog weigh?",
        "ground_truth": "SELECT weight FROM pets ORDER BY pet_age LIMIT 1",
        "amends": [
            "Do select `weight` instead of `MAX(weight)` and change the source table from `dogs` to `pets`. Do remove the WHERE filter with subquery that found `age = (SELECT MIN(age) FROM dogs)` instead of keeping it. Do add `ORDER BY pet_age LIMIT 1` instead of omitting ordering and limiting, which now correctly retrieves the weight of the youngest pet by sorting by age and taking the first result. The amended query now matches RIGHT_SQL's behavior by directly fetching the weight of the youngest pet rather than finding the maximum weight among dogs of minimum age."
        ],
        "rules": [
            "When answering about \"the youngest dog\": use the table \"pets\" instead of \"dogs\" and select the column \"weight\" directly rather than using MAX(weight).",
            "When finding the youngest entity: order by \"pet_age\" in ascending order and take only the first result using LIMIT 1.",
            "When answering about \"the youngest dog\", When finding the youngest entity, When the question mentions \"dog\": the relevant table is actually \"pets\" in the schema, not \"dogs\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(weight) FROM dogs WHERE age = (SELECT MIN(age) FROM dogs);",
            "SELECT weight FROM Pets WHERE PetType = 'dog' ORDER BY pet_age LIMIT 1"
        ],
        "rule_sql": [
            "SELECT weight FROM Pets WHERE PetType = 'dog' ORDER BY pet_age ASC LIMIT 1;"
        ]
    },
    "49": {
        "db_id": "pets_1",
        "question": "Find the maximum weight for each type of pet. List the maximum weight and pet type.",
        "ground_truth": "SELECT max(weight) ,  petType FROM pets GROUP BY petType",
        "amends": [
            "Do use `max(weight)` instead of `AVG(weight) as max_weight` to correctly calculate maximum weight rather than average weight. Do use `petType` instead of `pet_type` to match the correct column name. Do remove the alias `max_weight` instead of keeping it since the aggregate function name clearly indicates the calculation. Do maintain the `GROUP BY petType` clause instead of `GROUP BY pet_type` to ensure proper grouping by the correct column name. The amended query now correctly calculates maximum weight per pet type instead of incorrectly calculating average weight.",
            "Do place `max(weight)` first in the SELECT list instead of `PetType` first. Do use lowercase `petType` instead of uppercase `PetType` for the column reference. Do use lowercase `pets` instead of uppercase `Pets` for the table name. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [
            "When the question asks for maximum weight per pet type: use max(weight) instead of AVG(weight) to calculate the maximum value.",
            "When referring to pet type in the schema: use the exact column name \"petType\" instead of \"pet_type\".",
            "When calculating aggregates per group: maintain grouping by \"petType\" to ensure results are organized by each pet type.",
            "When the question asks for maximum weight per pet type, When referring to pet type in the schema, When calculating aggregates per group, When the question asks for maximum weight: do not use aliases like \"max_weight\" since the aggregate function name clearly indicates the calculation.",
            "When the question asks for maximum weight for each type of pet: organize results by the exact token \"petType\" and compute the maximum of \"weight\" per group.",
            "When producing output columns: place the maximum weight calculation first in the output order, followed by the pet type.",
            "When the question asks for maximum weight for each type of pet, When producing output columns, When referring to table and column identifiers: use lowercase \"pets\" for the table name and lowercase \"petType\" for the column reference exactly as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pet_type, AVG(weight) as max_weight FROM pets GROUP BY pet_type;",
            "SELECT PetType, MAX(weight) FROM Pets GROUP BY PetType;",
            "SELECT max(weight), petType FROM pets GROUP BY petType"
        ],
        "rule_sql": [
            "SELECT MAX(weight), petType FROM pets GROUP BY petType;"
        ]
    },
    "50": {
        "db_id": "pets_1",
        "question": "List the maximum weight and type for each type of pet.",
        "ground_truth": "SELECT max(weight) ,  petType FROM pets GROUP BY petType",
        "amends": [
            "Do use `petType` instead of `type` as the grouping column. Do place `max(weight)` before `petType` in the SELECT list instead of after it. Do use `petType` as the column alias in the GROUP BY clause instead of `type`. The amended query now correctly groups by the petType column and returns the maximum weight for each pet type, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for \"maximum weight and type for each type of pet\": use \"petType\" as the grouping column instead of \"type\".",
            "When organizing results by pet type: place \"max(weight)\" before \"petType\" in the output order.",
            "When the question asks for \"maximum weight and type for each type of pet\", When organizing results by pet type, When grouping by pet type: use \"petType\" as the column alias in the grouping clause."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type, MAX(weight) FROM pets GROUP BY type;",
            "SELECT MAX(weight) AS max_weight, PetType FROM Pets GROUP BY PetType;"
        ],
        "rule_sql": [
            "SELECT MAX(weight) AS max_weight, PetType FROM Pets GROUP BY PetType ORDER BY PetType;"
        ]
    },
    "51": {
        "db_id": "pets_1",
        "question": "Find number of pets owned by students who are older than 20.",
        "ground_truth": "SELECT count(*) FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid WHERE T1.age  >  20",
        "amends": [
            "Do add `student AS T1 JOIN has_pet AS T2 ON T1.stuid = T2.stuid` as the FROM source instead of just `pets`. Do change the WHERE filter to `T1.age > 20` instead of `student_age > 20` to reference the correct table and column. The amended query now correctly joins the student and has_pet tables and filters on student age, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"number of pets owned by students who are older than 20\": make sure the output order: COUNT(*)",
            "When the question mentions \"students who are older than 20\": \"older than 20\" actually means \"T1.age > 20\" in schema",
            "When combining T1 (student) and T2 (has_pet) for shared entities: link rows where T1.stuid = T2.stuid; keep only matching pairs (inner match)",
            "When answering about \"number of pets owned by students who are older than 20\", When the question mentions \"students who are older than 20\", When combining T1 (student) and T2 (has_pet) for shared entities, When the question asks for \"number of pets\": compute the number of rows using the canonical key token for pets (T2.stuid or T2.petid, though the amends suggest counting all joined rows)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM pets WHERE student_age > 20",
            "SELECT COUNT(*) AS number_of_pets\nFROM Student AS T1\nJOIN Has_Pet AS T2 ON T1.StuID = T2.StuID\nWHERE T1.Age > 20"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Student T1\nINNER JOIN Has_Pet T2 ON T1.StuID = T2.StuID\nWHERE T1.Age > 20"
        ]
    },
    "52": {
        "db_id": "pets_1",
        "question": "How many pets are owned by students that have an age greater than 20?",
        "ground_truth": "SELECT count(*) FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid WHERE T1.age  >  20",
        "amends": [
            "Do add `JOIN has_pet AS T2 ON T1.stuid = T2.stuid` instead of querying only the `pets` table. Do change the table reference to `student AS T1` instead of `pets` as the primary source. Do use `T1.age > 20` instead of `student_age > 20` to filter on the correct table's column. Do remove the incorrect `pets` table reference and replace it with the proper join structure between student and has_pet tables. The amended query now correctly counts students over age 20 who have pets by joining the appropriate tables with the proper relationship."
        ],
        "rules": [
            "When answering about \"pets owned by students with age greater than 20\": make sure the output order: count of students",
            "When the question mentions \"students\": use table \"student AS T1\" as the primary source instead of \"pets\" table",
            "When combining T1 (student) and T2 (has_pet) for shared entities: link rows where T1.stuid = T2.stuid exactly as shown; keep only matching pairs (inner match)",
            "When filtering by student age: use T1.age > 20 instead of student_age > 20 to filter on the correct table's column",
            "When answering about \"pets owned by students with age greater than 20\", When the question mentions \"students\", When combining T1 (student) and T2 (has_pet) for shared entities, When filtering by student age, When counting students who have pets: compute the number of rows using the canonical key T1.stuid for counting students"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM pets WHERE student_age > 20;",
            "SELECT COUNT(*) \nFROM Student AS T1\nJOIN Has_Pet AS T2 ON T1.StuID = T2.StuID\nWHERE T1.Age > 20"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.StuID) \nFROM Student AS T1 \nINNER JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID \nWHERE T1.Age > 20"
        ]
    },
    "53": {
        "db_id": "pets_1",
        "question": "Find the number of dog pets that are raised by female students (with sex F).",
        "ground_truth": "SELECT count(*) FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T2.petid  =  T3.petid WHERE T1.sex  =  'F' AND T3.pettype  =  'dog'",
        "amends": [
            "Do use a three-table join chain starting with `student` instead of a direct two-table join between `pets` and `students`. Do join through `has_pet` as an intermediate table with `ON T1.stuid = T2.stuid` instead of directly joining `pets` to `students`. Do then join `pets` with `ON T2.petid = T3.petid` instead of `ON p.owner_id = s.student_id`. Do filter on `T1.sex = 'F'` instead of `s.sex = 'M'` to count female students instead of male students. Do filter on `T3.pettype = 'dog'` instead of `p.type = 'dog'` using the correct column name. The amended query now correctly counts female students who own dogs through the proper relationship table structure."
        ],
        "rules": [
            "When answering about \"number of dog pets raised by female students\": make sure the output order: count of dog pets owned by female students.",
            "When the question mentions \"dog pets\": \"dog\" actually means \"pettype = 'dog'\" in schema.",
            "When the question mentions \"female students\": \"female\" actually means \"sex = 'F'\" in schema.",
            "When combining tables for student-pet relationships: use a three-table join chain starting with \"student\" as T1, then \"has_pet\" as T2 with ON T1.stuid = T2.stuid, then \"pets\" as T3 with ON T2.petid = T3.petid.",
            "When filtering for dog pets: use T3.pettype = 'dog' exactly as specified.",
            "When filtering for female students: use T1.sex = 'F' exactly as specified.",
            "When answering about \"number of dog pets raised by female students\", When the question mentions \"dog pets\", When the question mentions \"female students\", When combining tables for student-pet relationships, When filtering for dog pets, When filtering for female students, When counting dog pets owned by female students: compute the number of rows using the proper join chain that connects female students to their dog pets through the has_pet relationship table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM pets p JOIN students s ON p.owner_id = s.student_id WHERE p.type = 'dog' AND s.sex = 'M';",
            "SELECT COUNT(*) \nFROM Student s\nJOIN Has_Pet hp ON s.StuID = hp.StuID\nJOIN Pets p ON hp.PetID = p.PetID\nWHERE s.Sex = 'F' AND p.PetType = 'dog'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Student AS T1\nJOIN Has_Pet AS T2 ON T1.StuID = T2.StuID\nJOIN Pets AS T3 ON T2.PetID = T3.PetID\nWHERE T1.Sex = 'F' AND T3.PetType = 'dog'"
        ]
    },
    "54": {
        "db_id": "pets_1",
        "question": "How many dog pets are raised by female students?",
        "ground_truth": "SELECT count(*) FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T2.petid  =  T3.petid WHERE T1.sex  =  'F' AND T3.pettype  =  'dog'",
        "amends": [
            "Do join `has_pet` as an intermediate table between `students` and `pets` instead of directly joining `pets` to `students`. Do use `T1.stuid = T2.stuid` for the student join condition instead of `p.owner_id = s.student_id`. Do use `T2.petid = T3.petid` for the pet join condition instead of missing this relationship. Do reference `T1.sex` instead of `s.gender` for the gender filter. Do reference `T3.pettype` instead of `p.pet_type` for the pet type filter. Do use value 'F' instead of 'female' for the gender condition. The amended query now correctly models the many-to-many relationship between students and pets through the has_pet junction table and matches the right SQL's behavior."
        ],
        "rules": [
            "When the question asks about dog pets raised by female students: use the has_pet table as an intermediate junction table between students and pets instead of directly joining pets to students.",
            "When joining students and has_pet tables: link rows where T1.stuid = T2.stuid exactly.",
            "When joining has_pet and pets tables: link rows where T2.petid = T3.petid exactly.",
            "When filtering by gender: use T1.sex = 'F' instead of 'female'.",
            "When the question asks about dog pets raised by female students, When joining students and has_pet tables, When joining has_pet and pets tables, When filtering by gender, When filtering by pet type: use T3.pettype = 'dog' instead of p.pet_type."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM pets p JOIN students s ON p.owner_id = s.student_id WHERE p.pet_type = 'dog' AND s.gender = 'female';",
            "SELECT COUNT(*) \nFROM Student T1\nJOIN Has_Pet T2 ON T1.StuID = T2.StuID\nJOIN Pets T3 ON T2.PetID = T3.PetID\nWHERE T1.Sex = 'F' AND T3.PetType = 'dog'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Student T1\nJOIN Has_Pet T2 ON T1.StuID = T2.StuID\nJOIN Pets T3 ON T2.PetID = T3.PetID\nWHERE T1.Sex = 'F' AND T3.PetType = 'dog'"
        ]
    },
    "55": {
        "db_id": "pets_1",
        "question": "Find the number of distinct type of pets.",
        "ground_truth": "SELECT count(DISTINCT pettype) FROM pets",
        "amends": [
            "Do `count(DISTINCT pettype)` instead of `COUNT(*)` to count distinct pet types rather than all rows. Do add the `DISTINCT` modifier and specify the `pettype` column instead of using a wildcard count. The amended query now correctly counts unique pet types instead of total records, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When counting distinct types of pets: count the number of unique values in the \"pettype\" column using DISTINCT modifier instead of counting all rows.",
            "When counting distinct types of pets, When the question asks for \"number of distinct type of pets\": use the exact column token \"pettype\" to identify pet types in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM pets;",
            "SELECT COUNT(DISTINCT PetType) FROM Pets;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT PetType) FROM Pets;"
        ]
    },
    "56": {
        "db_id": "pets_1",
        "question": "How many different types of pet are there?",
        "ground_truth": "SELECT count(DISTINCT pettype) FROM pets",
        "amends": [
            "Do `count(DISTINCT pettype)` instead of `COUNT(*)` to count distinct pet types rather than all rows. Do add the `DISTINCT` modifier and specify the `pettype` column instead of using a wildcard count. The amended query now correctly counts unique pet types and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When counting different types of pet: count the number of unique values in the \"pettype\" column instead of counting all rows.",
            "When counting different types of pet, When the question asks for \"different types\" or \"distinct types\": use the DISTINCT modifier on the \"pettype\" column to ensure only unique values are counted."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM pets;",
            "SELECT COUNT(DISTINCT PetType) FROM Pets;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT PetType) FROM Pets;"
        ]
    },
    "57": {
        "db_id": "pets_1",
        "question": "Find the first name of students who have cat or dog pet.",
        "ground_truth": "SELECT DISTINCT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat' OR T3.pettype  =  'dog'",
        "amends": [
            "Do use `DISTINCT T1.Fname` instead of `first_name` to select unique first names. Do join `student AS T1` with `has_pet AS T2` on `T1.stuid = T2.stuid` and `pets AS T3` on `T3.petid = T2.petid` instead of querying only the `students` table. Do filter with `T3.pettype = 'cat' OR T3.pettype = 'dog'` instead of the contradictory `pet = 'cat' AND pet = 'dog'` to find students who have either cats or dogs. The amended query now correctly identifies students with either pet type by properly joining through the relationship tables."
        ],
        "rules": [
            "When selecting first names of students: use DISTINCT T1.Fname to get unique first names instead of first_name.",
            "When combining student and pet information: join student AS T1 with has_pet AS T2 on T1.stuid = T2.stuid and pets AS T3 on T3.petid = T2.petid to properly link students to their pets through relationship tables.",
            "When selecting first names of students, When combining student and pet information, When filtering for students who have cat or dog pets: use T3.pettype = 'cat' OR T3.pettype = 'dog' instead of contradictory AND conditions to find students with either pet type."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE pet = 'cat' AND pet = 'dog';",
            "SELECT DISTINCT T1.Fname FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID JOIN Pets AS T3 ON T3.PetID = T2.PetID WHERE T3.PetType = 'cat' OR T3.PetType = 'dog'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Fname FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID JOIN Pets AS T3 ON T3.PetID = T2.PetID WHERE T3.PetType = 'cat' OR T3.PetType = 'dog'"
        ]
    },
    "58": {
        "db_id": "pets_1",
        "question": "What are the first names of every student who has a cat or dog as a pet?",
        "ground_truth": "SELECT DISTINCT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat' OR T3.pettype  =  'dog'",
        "amends": [
            "Do use `DISTINCT T1.Fname` instead of `first_name` to select from the correct table with deduplication. Do join three tables `student AS T1`, `has_pet AS T2`, and `pets AS T3` instead of querying only a single `students` table. Do use `JOIN` relationships `T1.stuid = T2.stuid` and `T3.petid = T2.petid` instead of incorrect direct column references. Do change the condition to `T3.pettype = 'cat' OR T3.pettype = 'dog'` instead of the impossible `pet = 'cat' AND pet = 'dog'` that could never return results. The amended query now correctly identifies students who have either cats or dogs as pets through proper table relationships."
        ],
        "rules": [
            "When answering about \"first names of students with cats or dogs as pets\": use DISTINCT T1.Fname to select from the correct table with deduplication.",
            "When combining student, has_pet, and pets tables: link rows where T1.stuid = T2.stuid and T3.petid = T2.petid using inner matches.",
            "When filtering for cats or dogs as pets: use the condition T3.pettype = 'cat' OR T3.pettype = 'dog' with exact literals 'cat' and 'dog'.",
            "When answering about \"first names of students with cats or dogs as pets\", When combining student, has_pet, and pets tables, When filtering for cats or dogs as pets, When handling identifier delimiters: do not replace the exact table aliases T1, T2, T3 once established for this schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE pet = 'cat' AND pet = 'dog';",
            "SELECT DISTINCT T1.Fname FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID JOIN Pets AS T3 ON T3.PetID = T2.PetID WHERE T3.PetType = 'cat' OR T3.PetType = 'dog'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Fname FROM Student T1 INNER JOIN Has_Pet T2 ON T1.StuID = T2.StuID INNER JOIN Pets T3 ON T3.PetID = T2.PetID WHERE T3.PetType = 'cat' OR T3.PetType = 'dog'"
        ]
    },
    "59": {
        "db_id": "pets_1",
        "question": "Find the first name of students who have both cat and dog pets .",
        "ground_truth": "select t1.fname from student as t1 join has_pet as t2 on t1.stuid  =  t2.stuid join pets as t3 on t3.petid  =  t2.petid where t3.pettype  =  'cat' intersect select t1.fname from student as t1 join has_pet as t2 on t1.stuid  =  t2.stuid join pets as t3 on t3.petid  =  t2.petid where t3.pettype  =  'dog'",
        "amends": [
            "Do use `t1.fname` from the `student` table instead of `first_name` from a non-existent `students` table. Do join three tables (`student`, `has_pet`, and `pets`) with proper relationships through `stuid` and `petid` instead of querying a single table with a direct `pet` column. Do filter for `t3.pettype = 'cat'` in one branch and `t3.pettype = 'dog'` in another instead of using `OR` conditions on a single column. Do use `INTERSECT` to find students who have both cats and dogs instead of using `OR` which would find students with either pets. The amended query now correctly identifies students who own both cats and dogs by intersecting two separate queries for each pet type."
        ],
        "rules": [
            "When the question asks for \"first name of students\": use \"t1.fname\" from the \"student\" table instead of \"first_name\" from a non-existent \"students\" table.",
            "When combining student and pet information: link \"student\" (T1), \"has_pet\" (T2), and \"pets\" (T3) tables where T1.stuid = T2.stuid and T2.petid = T3.petid to establish proper relationships.",
            "When filtering for cat pets: use condition \"t3.pettype = 'cat'\" exactly as specified.",
            "When filtering for dog pets: use condition \"t3.pettype = 'dog'\" exactly as specified.",
            "When the question asks for \"first name of students\", When combining student and pet information, When filtering for cat pets, When filtering for dog pets, When finding students who have both cat and dog pets: use INTERSECT between the results for cat pets and dog pets instead of OR conditions which would find students with either pet."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE pet = 'cat' OR pet = 'dog';",
            "SELECT t1.Fname\nFROM Student t1\nJOIN Has_Pet t2 ON t1.StuID = t2.StuID\nJOIN Pets t3 ON t2.PetID = t3.PetID\nWHERE t3.PetType = 'cat'\nINTERSECT\nSELECT t1.Fname\nFROM Student t1\nJOIN Has_Pet t2 ON t1.StuID = t2.StuID\nJOIN Pets t3 ON t2.PetID = t3.PetID\nWHERE t3.PetType = 'dog'"
        ],
        "rule_sql": [
            "SELECT t1.fname\nFROM Student t1\nJOIN Has_Pet t2 ON t1.StuID = t2.StuID\nJOIN Pets t3 ON t2.PetID = t3.PetID\nWHERE t3.PetType = 'cat'\nINTERSECT\nSELECT t1.fname\nFROM Student t1\nJOIN Has_Pet t2 ON t1.StuID = t2.StuID\nJOIN Pets t3 ON t2.PetID = t3.PetID\nWHERE t3.PetType = 'dog'"
        ]
    },
    "60": {
        "db_id": "pets_1",
        "question": "What are the students' first names who have both cats and dogs as pets?",
        "ground_truth": "SELECT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat' INTERSECT SELECT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog'",
        "amends": [
            "Do use `T1.Fname` instead of `first_name` for the column selection. Do join `student AS T1` with `has_pet AS T2` on `T1.stuid = T2.stuid` and then join `pets AS T3` on `T3.petid = T2.petid` instead of querying a single `students` table. Do filter for `T3.pettype = 'cat'` in one query branch and `T3.pettype = 'dog'` in another instead of using contradictory `AND` conditions `pet_type = 'cat' AND pet_type = 'dog'`. Do use `INTERSECT` to find students who have both cat and dog pets instead of trying to find records where a single pet is both a cat and dog simultaneously. The amended query now correctly identifies students who have both types of pets by intersecting two separate queries for each pet type."
        ],
        "rules": [
            "When the question asks for \"students' first names\": use the exact column token \"T1.Fname\" for output.",
            "When combining student and pet information: join \"student AS T1\" with \"has_pet AS T2\" where \"T1.stuid = T2.stuid\" and then join \"pets AS T3\" where \"T3.petid = T2.petid\", keeping only matching rows (inner match).",
            "When finding students with cats: filter for \"T3.pettype = 'cat'\" exactly as specified.",
            "When finding students with dogs: filter for \"T3.pettype = 'dog'\" exactly as specified.",
            "When the question asks for \"students' first names\", When combining student and pet information, When finding students with cats, When finding students with dogs, When identifying students who have both cats and dogs: use INTERSECT to combine results from the cat query and dog query instead of using contradictory AND conditions on the same column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE pet_type = 'cat' AND pet_type = 'dog'",
            "SELECT T1.Fname\nFROM student AS T1\nJOIN has_pet AS T2 ON T1.StuID = T2.StuID\nJOIN pets AS T3 ON T3.PetID = T2.PetID\nWHERE T3.PetType = 'cat'\nINTERSECT\nSELECT T1.Fname\nFROM student AS T1\nJOIN has_pet AS T2 ON T1.StuID = T2.StuID\nJOIN pets AS T3 ON T3.PetID = T2.PetID\nWHERE T3.PetType = 'dog'"
        ],
        "rule_sql": [
            "SELECT T1.Fname FROM student AS T1\nJOIN has_pet AS T2 ON T1.StuID = T2.StuID\nJOIN pets AS T3 ON T3.PetID = T2.PetID\nWHERE T3.PetType = 'cat'\nINTERSECT\nSELECT T1.Fname FROM student AS T1\nJOIN has_pet AS T2 ON T1.StuID = T2.StuID\nJOIN pets AS T3 ON T3.PetID = T2.PetID\nWHERE T3.PetType = 'dog'"
        ]
    },
    "61": {
        "db_id": "pets_1",
        "question": "Find the major and age of students who do not have a cat pet.",
        "ground_truth": "SELECT major ,  age FROM student WHERE stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')",
        "amends": [
            "Do use a subquery with `NOT IN` instead of a simple `WHERE` filter to exclude students with cats. Do add joins between `student`, `has_pet`, and `pets` tables instead of querying only the `students` table. Do reference `stuid` as the join condition instead of filtering directly on `pet`. Do use proper table aliases `T1`, `T2`, and `T3` instead of no aliases. Do filter on `pettype = 'cat'` in the subquery instead of `pet != 'cat'` in the main query. The amended query now correctly identifies students without cats by checking the pet relationships through proper table joins."
        ],
        "rules": [
            "When answering about students who do not have a cat pet: use a subquery with NOT IN instead of a simple WHERE filter to exclude students with cats.",
            "When combining student, has_pet, and pets tables: add joins between these tables instead of querying only the students table.",
            "When linking tables: reference stuid as the join condition instead of filtering directly on pet.",
            "When using table aliases: use proper table aliases T1, T2, and T3 instead of no aliases.",
            "When answering about students who do not have a cat pet, When combining student, has_pet, and pets tables, When linking tables, When using table aliases, When filtering for cat pets: filter on pettype = 'cat' in the subquery instead of pet != 'cat' in the main query."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT major, age FROM students WHERE pet != 'cat';",
            "SELECT T1.Major, T1.Age\nFROM Student T1\nWHERE T1.StuID NOT IN (\n    SELECT T2.StuID\n    FROM Has_Pet T2\n    JOIN Pets T3 ON T2.PetID = T3.PetID\n    WHERE T3.PetType = 'cat'\n)"
        ],
        "rule_sql": [
            "SELECT T1.Major, T1.Age FROM Student T1 WHERE T1.StuID NOT IN (SELECT T2.StuID FROM Has_Pet T2 JOIN Pets T3 ON T2.PetID = T3.PetID WHERE T3.PetType = 'cat')"
        ]
    },
    "62": {
        "db_id": "pets_1",
        "question": "What major is every student who does not own a cat as a pet, and also how old are they?",
        "ground_truth": "SELECT major ,  age FROM student WHERE stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')",
        "amends": [
            "Do use a subquery with `NOT IN` instead of a simple `WHERE` filter to exclude students with cats. Do add joins between `student`, `has_pet`, and `pets` tables instead of querying only the `students` table. Do reference `stuid` as the join condition instead of assuming direct pet ownership in the main table. Do filter on `pettype = 'cat'` in the subquery instead of checking `pet != 'cat'` directly. Do use proper table aliases `T1`, `T2`, and `T3` instead of unspecified table references. The amended query now correctly identifies students without cats by checking through the relationship tables instead of making incorrect assumptions about pet data storage."
        ],
        "rules": [
            "When answering about students who do not own a cat as a pet: use a subquery with NOT IN instead of a simple WHERE filter to exclude students with cats.",
            "When combining student, has_pet, and pets tables: add joins between these tables instead of querying only the students table.",
            "When linking tables: reference stuid as the join condition instead of assuming direct pet ownership in the main table.",
            "When filtering for cat ownership: filter on pettype = 'cat' in the subquery instead of checking pet != 'cat' directly.",
            "When answering about students who do not own a cat as a pet, When combining student, has_pet, and pets tables, When linking tables, When filtering for cat ownership, When referencing tables: use proper table aliases T1, T2, and T3 instead of unspecified table references."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT major, age FROM students WHERE pet != 'cat';",
            "SELECT T1.Major, T1.Age\nFROM Student T1\nWHERE T1.StuID NOT IN (\n    SELECT T2.StuID\n    FROM Has_Pet T2\n    JOIN Pets T3 ON T2.PetID = T3.PetID\n    WHERE T3.PetType = 'cat'\n);"
        ],
        "rule_sql": [
            "SELECT T1.Major, T1.Age FROM Student T1 WHERE T1.StuID NOT IN (SELECT T2.StuID FROM Has_Pet T2 JOIN Pets T3 ON T2.PetID = T3.PetID WHERE T3.PetType = 'cat')"
        ]
    },
    "63": {
        "db_id": "pets_1",
        "question": "Find the id of students who do not have a cat pet.",
        "ground_truth": "SELECT stuid FROM student EXCEPT SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat'",
        "amends": [
            "Do select `stuid` instead of `id` and use `EXCEPT` set operation instead of a simple `WHERE` filter. Do change the source from `students` to `student` instead of the original table name. Do add joins with `has_pet` and `pets` tables instead of omitting them, specifically using `JOIN has_pet AS T2 ON T1.stuid = T2.stuid` and `JOIN pets AS T3 ON T3.petid = T2.petid` instead of no joins. Do move the pet filter condition to `WHERE T3.pettype = 'cat'` instead of `WHERE pet = 'cat'`, and use `pettype` instead of `pet` as the column reference. The amended query now correctly identifies students without cats by using an EXCEPT operation to remove those who have cats, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for student id: use \"stuid\" instead of \"id\" as the column name.",
            "When the question asks about students who do not have a cat pet: use an EXCEPT set operation to remove students who have cats from all students instead of a simple WHERE filter.",
            "When working with the student table: use \"student\" as the table name instead of \"students\".",
            "When combining student data with pet information: join \"student\" as T1 with \"has_pet\" as T2 using \"T1.stuid = T2.stuid\" and join \"has_pet\" as T2 with \"pets\" as T3 using \"T3.petid = T2.petid\".",
            "When the question asks for student id, When the question asks about students who do not have a cat pet, When working with the student table, When combining student data with pet information, When filtering for cat pets: use \"T3.pettype = 'cat'\" as the condition instead of \"pet = 'cat'\", and use \"pettype\" instead of \"pet\" as the column reference."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM students WHERE pet = 'cat';",
            "SELECT StuID FROM Student\nEXCEPT\nSELECT T1.StuID FROM Student AS T1\nJOIN Has_Pet AS T2 ON T1.StuID = T2.StuID\nJOIN Pets AS T3 ON T3.PetID = T2.PetID\nWHERE T3.PetType = 'cat'"
        ],
        "rule_sql": [
            "SELECT stuid FROM Student\nEXCEPT\nSELECT T1.stuid FROM Student AS T1\nJOIN Has_Pet AS T2 ON T1.stuid = T2.stuid\nJOIN Pets AS T3 ON T3.petid = T2.petid\nWHERE T3.pettype = 'cat'"
        ]
    },
    "64": {
        "db_id": "pets_1",
        "question": "What are the ids of the students who do not own cats as pets?",
        "ground_truth": "SELECT stuid FROM student EXCEPT SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat'",
        "amends": [
            "Do use `EXCEPT` set operation instead of simple `WHERE` filtering to exclude students with cats. Do reference `stuid` instead of `student_id` and `student` table instead of `students`. Do add joins to `has_pet` and `pets` tables through `T1.stuid = T2.stuid` and `T3.petid = T2.petid` instead of directly filtering on a non-existent `pet_type` column. Do filter with `T3.pettype = 'cat'` in the exclusion subquery instead of `pet_type != 'cat'` in the main query. Do use table aliases `T1`, `T2`, `T3` for clarity instead of no aliases. The amended query now correctly identifies students without cats by excluding those who have cat pets through the proper relationship tables."
        ],
        "rules": [
            "When the question asks for student ids who do not own cats: use the exact identifier \"stuid\" from the \"student\" table instead of \"student_id\" from \"students\".",
            "When identifying students with cat pets: join tables using T1.stuid = T2.stuid and T3.petid = T2.petid, then filter with T3.pettype = 'cat' exactly.",
            "When excluding students with cats: use EXCEPT set operation to remove students who have cat pets from all students, rather than simple WHERE filtering.",
            "When the question asks for student ids who do not own cats, When identifying students with cat pets, When excluding students with cats, When handling table references: use aliases T1 for student table, T2 for has_pet table, and T3 for pets table as established in the joins."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id FROM students WHERE pet_type != 'cat';",
            "SELECT StuID FROM Student\nEXCEPT\nSELECT T1.StuID\nFROM Student T1\nJOIN Has_Pet T2 ON T1.StuID = T2.StuID\nJOIN Pets T3 ON T2.PetID = T3.PetID\nWHERE T3.PetType = 'cat'"
        ],
        "rule_sql": [
            "SELECT T1.StuID FROM Student T1\nEXCEPT\nSELECT T1.StuID FROM Student T1\nJOIN Has_Pet T2 ON T1.StuID = T2.StuID\nJOIN Pets T3 ON T2.PetID = T3.PetID\nWHERE T3.PetType = 'cat'"
        ]
    },
    "65": {
        "db_id": "pets_1",
        "question": "Find the first name and age of students who have a dog but do not have a cat as a pet.",
        "ground_truth": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog' AND T1.stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')",
        "amends": [
            "Do use explicit table aliases `T1.fname` and `T1.age` instead of direct column references `first_name` and `age`. Do join tables `student AS T1`, `has_pet AS T2`, and `pets AS T3` with proper join conditions `ON T1.stuid = T2.stuid` and `ON T3.petid = T2.petid` instead of querying a single table. Do filter on `T3.pettype = 'dog'` instead of `pet = 'dog'`. Do add a subquery exclusion with `T1.stuid NOT IN` to find students with dogs but not cats instead of the incorrect `pet != 'cat'` filter that would never match due to the contradictory `pet = 'dog'` condition. The amended query now correctly identifies students who have dogs but no cats by properly joining across multiple tables and using a subquery for exclusion logic."
        ],
        "rules": [
            "When answering about \"first name and age of students\": make sure the output order: T1.fname, T1.age",
            "When the question mentions \"students\": use table \"student\" with alias T1",
            "When combining tables for student-pet relationships: link T1 (student) and T2 (has_pet) where T1.stuid = T2.stuid, and link T2 and T3 (pets) where T3.petid = T2.petid, keeping only matching pairs (inner match)",
            "When filtering for students with dogs: use condition T3.pettype = 'dog' exactly as specified",
            "When answering about \"first name and age of students\", When the question mentions \"students\", When combining tables for student-pet relationships, When filtering for students with dogs, When excluding students with cats: use subquery exclusion where T1.stuid NOT IN (select stuid from has_pet join pets on pets.petid = has_pet.petid where pettype = 'cat')"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, age FROM students WHERE pet = 'dog' AND pet != 'cat';",
            "SELECT T1.Fname, T1.Age\nFROM Student AS T1\nJOIN Has_Pet AS T2 ON T1.StuID = T2.StuID\nJOIN Pets AS T3 ON T3.PetID = T2.PetID\nWHERE T3.PetType = 'dog'\nAND T1.StuID NOT IN (\n    SELECT T4.StuID\n    FROM Has_Pet AS T4\n    JOIN Pets AS T5 ON T5.PetID = T4.PetID\n    WHERE T5.PetType = 'cat'\n)"
        ],
        "rule_sql": [
            "SELECT T1.fname, T1.age\nFROM student T1\nINNER JOIN has_pet T2 ON T1.stuid = T2.stuid\nINNER JOIN pets T3 ON T3.petid = T2.petid\nWHERE T3.pettype = 'dog'\nAND T1.stuid NOT IN (\n    SELECT stuid \n    FROM has_pet \n    JOIN pets ON pets.petid = has_pet.petid \n    WHERE pettype = 'cat'\n)"
        ]
    },
    "66": {
        "db_id": "pets_1",
        "question": "What is the first name of every student who has a dog but does not have a cat?",
        "ground_truth": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog' AND T1.stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')",
        "amends": [
            "Do select `T1.fname` and `T1.age` instead of just `first_name`. Do use explicit table aliases with `student AS T1` instead of the base table name. Do add `JOIN has_pet AS T2` and `JOIN pets AS T3` instead of omitting these tables. Do use join conditions `ON T1.stuid = T2.stuid` and `ON T3.petid = T2.petid` instead of simple boolean flags. Do filter with `T3.pettype = 'dog'` instead of `has_dog = 1`. Do add a subquery exclusion with `NOT IN` for students who have cats instead of including them with `has_cat = 1`. Do remove the direct boolean column references and instead use proper relational joins through the has_pet and pets tables to determine pet ownership. The amended query now correctly identifies students who have dogs but not cats by using proper table relationships instead of boolean flags."
        ],
        "rules": [
            "When selecting student information: use T1.fname and T1.age as output columns instead of just first_name.",
            "When referring to the student table: always use the explicit alias T1 instead of the base table name.",
            "When determining pet ownership: join has_pet as T2 using T1.stuid = T2.stuid and join pets as T3 using T3.petid = T2.petid instead of using boolean flags.",
            "When filtering for students with dogs: use T3.pettype = 'dog' instead of has_dog = 1.",
            "When excluding students with cats: use a subquery exclusion with NOT IN for students who have cats instead of including them with has_cat = 1.",
            "When selecting student information, When referring to the student table, When determining pet ownership, When filtering for students with dogs, When excluding students with cats, When answering about students with dogs but not cats: use proper relational joins through has_pet and pets tables to determine pet ownership instead of direct boolean column references."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE has_dog = 1 AND has_cat = 1;",
            "SELECT T1.fname, T1.age\nFROM student AS T1\nJOIN has_pet AS T2 ON T1.stuid = T2.stuid\nJOIN pets AS T3 ON T3.petid = T2.petid\nWHERE T3.pettype = 'dog'\nAND T1.stuid NOT IN (\n    SELECT T4.stuid\n    FROM student AS T4\n    JOIN has_pet AS T5 ON T4.stuid = T5.stuid\n    JOIN pets AS T6 ON T6.petid = T5.petid\n    WHERE T6.pettype = 'cat'\n)"
        ],
        "rule_sql": [
            "SELECT T1.fname, T1.age\nFROM Student T1\nJOIN Has_Pet T2 ON T1.StuID = T2.StuID\nJOIN Pets T3 ON T3.PetID = T2.PetID\nWHERE T3.PetType = 'dog'\nAND T1.StuID NOT IN (\n    SELECT T2.StuID\n    FROM Has_Pet T2\n    JOIN Pets T3 ON T3.PetID = T2.PetID\n    WHERE T3.PetType = 'cat'\n)\nGROUP BY T1.StuID;"
        ]
    },
    "67": {
        "db_id": "pets_1",
        "question": "Find the type and weight of the youngest pet.",
        "ground_truth": "SELECT pettype ,  weight FROM pets ORDER BY pet_age LIMIT 1",
        "amends": [
            "Do use column name `pettype` instead of `type` in the SELECT list. Do use column name `pet_age` instead of `age` in the ORDER BY clause. The amended query now correctly references the actual column names and matches the intended behavior."
        ],
        "rules": [
            "When the question asks for \"type\" of a pet: use the exact column name \"pettype\" instead of \"type\" in the output.",
            "When the question asks for \"type\" of a pet, When ordering by age to find the youngest pet: use the exact column name \"pet_age\" instead of \"age\" in the ordering condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type, weight FROM pets ORDER BY age ASC LIMIT 1;",
            "SELECT PetType, weight FROM Pets ORDER BY pet_age ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT PetType, weight FROM Pets ORDER BY pet_age ASC LIMIT 1;"
        ]
    },
    "68": {
        "db_id": "pets_1",
        "question": "What type of pet is the youngest animal, and how much does it weigh?",
        "ground_truth": "SELECT pettype ,  weight FROM pets ORDER BY pet_age LIMIT 1",
        "amends": [
            "Do reference table `pets` instead of `animals` in the FROM clause. Do select column `pettype` instead of `pet_type` and use `pet_age` for ordering instead of `age`. Do maintain the `weight` column selection and `LIMIT 1` clause without changes. The amended query now correctly references the appropriate table schema and columns to match the intended behavior."
        ],
        "rules": [
            "When answering about \"the youngest animal\": order rows by \"pet_age\" in ascending order and keep only the first row.",
            "When the question mentions \"type of pet\": \"type of pet\" actually means \"pettype\" in the schema.",
            "When the question mentions \"how much does it weigh\": include the \"weight\" column in the output.",
            "When answering about \"the youngest animal\", When the question mentions \"type of pet\", When the question mentions \"how much does it weigh\", When selecting from the database: use table \"pets\" instead of \"animals\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pet_type, weight FROM animals ORDER BY age ASC LIMIT 1;",
            "SELECT PetType, weight FROM Pets ORDER BY pet_age ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT PetType, weight FROM Pets ORDER BY pet_age ASC LIMIT 1;"
        ]
    },
    "69": {
        "db_id": "pets_1",
        "question": "Find the id and weight of all pets whose age is older than 1.",
        "ground_truth": "SELECT petid ,  weight FROM pets WHERE pet_age  >  1",
        "amends": [
            "Do select `petid` instead of `id` and change the filter to `pet_age > 1` instead of `age < 1` while keeping the same table source and column selection structure, ensuring the query now correctly retrieves pets older than one year rather than younger than one year."
        ],
        "rules": [
            "When selecting pet identification: use \"petid\" instead of \"id\" as the identifier column.",
            "When filtering by age to find pets older than 1: use \"pet_age > 1\" instead of \"age < 1\" to correctly identify pets with age greater than 1 year.",
            "When selecting pet identification, When filtering by age to find pets older than 1, When maintaining the query structure: keep the same table source and column selection pattern while only correcting the specific column names and filter condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, weight FROM pets WHERE age < 1;",
            "SELECT PetID, weight FROM Pets WHERE pet_age > 1"
        ],
        "rule_sql": [
            "SELECT petid, weight FROM Pets WHERE pet_age > 1"
        ]
    },
    "70": {
        "db_id": "pets_1",
        "question": "What is the id and weight of every pet who is older than 1?",
        "ground_truth": "SELECT petid ,  weight FROM pets WHERE pet_age  >  1",
        "amends": [
            "Do select `petid` instead of `id` and maintain `weight` in the SELECT list. Do change the WHERE filter to `pet_age > 1` instead of `age < 1`, both altering the column reference from `age` to `pet_age` and reversing the comparison operator from less than to greater than. The amended query now correctly retrieves pets with age greater than 1 using the appropriate column names and comparison logic."
        ],
        "rules": [
            "When the question asks for \"id\" of pets: use the exact column token \"petid\" instead of \"id\".",
            "When the question asks for pets older than 1: use the exact column token \"pet_age\" with comparison operator > 1 instead of \"age\" with < 1.",
            "When the question asks for \"id\" of pets, When the question asks for pets older than 1, When selecting output columns: maintain the order \"petid\" followed by \"weight\" as shown in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, weight FROM pets WHERE age < 1;",
            "SELECT PetID, weight FROM Pets WHERE pet_age > 1"
        ],
        "rule_sql": [
            "SELECT petid, weight FROM Pets WHERE pet_age > 1"
        ]
    },
    "71": {
        "db_id": "pets_1",
        "question": "Find the average and maximum age for each type of pet.",
        "ground_truth": "SELECT avg(pet_age) ,  max(pet_age) ,  pettype FROM pets GROUP BY pettype",
        "amends": [
            "Do use column name `pet_age` instead of `age` in aggregate functions. Do use `max` function instead of `MIN` for maximum age calculation. Do use column name `pettype` instead of `pet_type` in both SELECT list and GROUP BY clause. Do remove the alias `average_age` instead of keeping it. Do remove the alias `max_age` instead of keeping it. The amended query now correctly calculates average and maximum pet ages grouped by pet type using the appropriate column names.",
            "Do use lowercase `avg(pet_age)` and `max(pet_age)` instead of uppercase `AVG(pet_age)` and `MAX(pet_age)`. Do place `pettype` at the end of the SELECT list instead of at the beginning. Do use lowercase `pettype` in GROUP BY instead of uppercase `PetType`. Do use lowercase table name `pets` instead of uppercase `Pets`. The amended query now matches RIGHT_SQL's behavior with identical aggregation logic and grouping."
        ],
        "rules": [
            "When the question asks for \"average and maximum age\": use the column name \"pet_age\" for age calculations instead of \"age\".",
            "When calculating maximum age: use the max function instead of MIN function.",
            "When referring to \"type of pet\" in both SELECT list and GROUP BY clause: use the exact column name \"pettype\" instead of \"pet_type\".",
            "When producing output columns: do not use aliases like \"average_age\" or \"max_age\" - return the aggregate functions directly without aliases.",
            "When the question asks for \"average and maximum age\", When calculating maximum age, When referring to \"type of pet\" in both SELECT list and GROUP BY clause, When producing output columns, When grouping by pet type: organize results by the \"pettype\" column to compute requested aggregates per group.",
            "When the question asks for average and maximum age for each type of pet: compute avg(pet_age) and max(pet_age) using lowercase function names.",
            "When grouping by pet type: use lowercase pettype as the grouping column.",
            "When selecting columns: place pettype at the end of the output columns list after the aggregate functions.",
            "When the question asks for average and maximum age for each type of pet, When grouping by pet type, When selecting columns, When referring to the pets table: use lowercase pets as the table name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pet_type, AVG(age) as average_age, MIN(age) as max_age FROM pets GROUP BY pet_type;",
            "SELECT PetType, AVG(pet_age) AS average_age, MAX(pet_age) AS max_age FROM Pets GROUP BY PetType;",
            "SELECT avg(pet_age), max(pet_age), pettype FROM pets GROUP BY pettype"
        ],
        "rule_sql": [
            "SELECT avg(pet_age), max(pet_age), pettype FROM pets GROUP BY pettype"
        ]
    },
    "72": {
        "db_id": "pets_1",
        "question": "What is the average and maximum age for each pet type?",
        "ground_truth": "SELECT avg(pet_age) ,  max(pet_age) ,  pettype FROM pets GROUP BY pettype",
        "amends": [
            "Do use column name `pet_age` instead of `age` in aggregate functions. Do use `max` function instead of `MIN` for calculating maximum age. Do remove the alias `average_age` instead of keeping it. Do remove the alias `maximum_age` instead of keeping it. Do use column name `pettype` instead of `pet_type` in GROUP BY clause. The amended query now correctly calculates average and maximum pet ages by pet type without unnecessary aliases.",
            "Do use lowercase `avg(pet_age)` and `max(pet_age)` instead of uppercase `AVG(pet_age)` and `MAX(pet_age)`. Do place `pettype` at the end of the SELECT list instead of at the beginning. Do use lowercase table name `pets` instead of uppercase `Pets` and lowercase column name `pettype` instead of uppercase `PetType` in both SELECT and GROUP BY clauses. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [
            "When the question mentions \"age\": \"age\" actually means \"pet_age\" in schema.",
            "When calculating maximum age: use the max function instead of min function.",
            "When the question asks for results without specific aliases: do not add aliases like \"average_age\" or \"maximum_age\" to the output columns.",
            "When the question mentions \"pet type\": \"pet type\" actually means \"pettype\" in schema.",
            "When the question mentions \"age\", When calculating maximum age, When the question asks for results without specific aliases, When the question mentions \"pet type\", When the question asks for results \"for each pet type\": organize results by the exact token \"pettype\" and compute requested aggregates per group.",
            "When the question asks for average and maximum age for each pet type: compute average using lowercase avg(pet_age) and maximum using lowercase max(pet_age).",
            "When organizing results by pet type: use lowercase pettype as the grouping key in both SELECT and GROUP BY clauses.",
            "When producing output columns: place pettype at the end of the SELECT list instead of the beginning.",
            "When the question asks for average and maximum age for each pet type, When organizing results by pet type, When producing output columns, When referring to the table: use lowercase pets instead of uppercase Pets."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pet_type, AVG(age) as average_age, MIN(age) as maximum_age FROM pets GROUP BY pet_type;",
            "SELECT PetType, AVG(pet_age), MAX(pet_age) FROM Pets GROUP BY PetType;",
            "SELECT avg(pet_age), max(pet_age), pettype FROM pets GROUP BY pettype"
        ],
        "rule_sql": [
            "SELECT avg(pet_age), max(pet_age), pettype FROM pets GROUP BY pettype"
        ]
    },
    "73": {
        "db_id": "pets_1",
        "question": "Find the average weight for each pet type.",
        "ground_truth": "SELECT avg(weight) ,  pettype FROM pets GROUP BY pettype",
        "amends": [
            "Do calculate `avg(weight)` instead of `AVG(age)` as average_weight. Do select `pettype` instead of `pet_type` in the GROUP BY clause. Do remove the alias `as average_weight` instead of keeping it. The amended query now correctly calculates average weight by pet type rather than average age.",
            "Do use lowercase `avg(weight)` instead of uppercase `AVG(weight)` and lowercase `pettype` instead of uppercase `PetType` in the SELECT list. Do place `avg(weight)` before `pettype` instead of after it in the column order. Do use lowercase `pets` instead of uppercase `Pets` and lowercase `pettype` instead of uppercase `PetType` in the GROUP BY clause. The amended query now matches the correct behavior with proper lowercase identifiers and column ordering."
        ],
        "rules": [
            "When the question asks for \"average weight\": calculate the average of the \"weight\" column instead of \"age\".",
            "When grouping by pet type: use the exact column name \"pettype\" instead of \"pet_type\" in the GROUP BY clause.",
            "When the question asks for \"average weight\", When grouping by pet type, When the question asks for average weight per pet type: do not include an alias like \"as average_weight\" in the output.",
            "When the question asks for average weight per pet type: compute the average of the \"weight\" column for each distinct value of \"pettype\".",
            "When ordering output columns: place the aggregate result \"avg(weight)\" before the grouping column \"pettype\".",
            "When the question asks for average weight per pet type, When ordering output columns, When using identifiers from the Pets table: use lowercase identifiers \"pets\", \"pettype\", and \"weight\" exactly as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pet_type, AVG(age) as average_weight FROM pets GROUP BY pet_type;",
            "SELECT PetType, AVG(weight) FROM Pets GROUP BY PetType;",
            "SELECT avg(weight), pettype FROM pets GROUP BY pettype"
        ],
        "rule_sql": [
            "SELECT AVG(weight), pettype FROM pets GROUP BY pettype"
        ]
    },
    "74": {
        "db_id": "pets_1",
        "question": "What is the average weight for each type of pet?",
        "ground_truth": "SELECT avg(weight) ,  pettype FROM pets GROUP BY pettype",
        "amends": [
            "Do select `avg(weight)` and `pettype` instead of `AVG(age)` as `average_weight` and `type`. Do group by `pettype` instead of `type`. The amended query now correctly calculates average weight grouped by pet type instead of incorrectly attempting to average age while mislabeling it as weight.",
            "Do use lowercase `avg(weight)` instead of uppercase `AVG(weight)` and place it first in the SELECT list instead of second. Do use lowercase `pettype` instead of uppercase `PetType` and place it second in the SELECT list instead of first. Do remove the alias `AS average_weight` instead of keeping it. Do use lowercase `pets` instead of uppercase `Pets` in the FROM clause. Do use lowercase `pettype` instead of uppercase `PetType` in the GROUP BY clause. The amended query now correctly calculates average weight by pet type without unnecessary aliasing and with consistent lowercase naming."
        ],
        "rules": [
            "When the question asks for \"average weight for each type of pet\": compute the average of the \"weight\" column instead of \"age\".",
            "When grouping by pet type: use the exact column name \"pettype\" for grouping instead of \"type\".",
            "When the question asks for \"average weight for each type of pet\", When grouping by pet type, When selecting output columns: include \"pettype\" and the average weight calculation with the exact column name \"weight\".",
            "When the question asks for average weight per pet type: compute the average of the \"weight\" column for each group.",
            "When organizing results by pet type: group by the \"pettype\" column.",
            "When selecting output columns: place the average weight calculation first in the output order, followed by the pet type.",
            "When referring to table and column names: use lowercase identifiers \"pets\", \"pettype\", and \"weight\" exactly as specified.",
            "When the question asks for average weight per pet type, When organizing results by pet type, When selecting output columns, When referring to table and column names, When computing aggregates: do not include unnecessary aliases like \"AS average_weight\" in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type, AVG(age) as average_weight FROM pets GROUP BY type;",
            "SELECT PetType, AVG(weight) AS average_weight FROM Pets GROUP BY PetType;",
            "SELECT avg(weight), pettype FROM pets GROUP BY pettype"
        ],
        "rule_sql": [
            "SELECT AVG(weight), pettype FROM pets GROUP BY pettype"
        ]
    },
    "75": {
        "db_id": "pets_1",
        "question": "Find the first name and age of students who have a pet.",
        "ground_truth": "SELECT DISTINCT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid",
        "amends": [
            "Do use `DISTINCT` instead of omitting it, and select `fname` instead of `first_name` from the `student` table instead of `students`. Do add a `JOIN` with `has_pet` table on `stuid = stuid` instead of no join, and move the filter to check for pet existence through the join condition instead of using `WHERE pet IS NULL`. Do reference tables with aliases `T1` and `T2` instead of no aliases. The amended query now correctly identifies students who have pets by joining with the has_pet table rather than incorrectly checking for a NULL pet column in the students table."
        ],
        "rules": [
            "When the question asks for \"first name\" of students: use the exact column token \"fname\" from the student table instead of \"first_name\".",
            "When the question asks about students who have a pet: join the student table (T1) with the has_pet table (T2) using the exact key equality T1.stuid = T2.stuid to identify students with pets, instead of checking for NULL values.",
            "When selecting from multiple tables: use table aliases T1 for the student table and T2 for the has_pet table as specified.",
            "When the question asks for \"first name\" of students, When the question asks about students who have a pet, When selecting from multiple tables, When the question asks for distinct results: include DISTINCT to ensure each student appears only once in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, age FROM students WHERE pet IS NULL;",
            "SELECT DISTINCT T1.Fname, T1.Age FROM Student T1 JOIN Has_Pet T2 ON T1.StuID = T2.StuID"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.fname, T1.Age FROM Student T1 JOIN Has_Pet T2 ON T1.StuID = T2.StuID"
        ]
    },
    "76": {
        "db_id": "pets_1",
        "question": "What are the different first names and ages of the students who do have pets?",
        "ground_truth": "SELECT DISTINCT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid",
        "amends": [
            "Do reference columns as `T1.fname` and `T1.age` with table aliases instead of `first_name` and `age` without table qualification. Do use a `JOIN` with `has_pet AS T2` on `T1.stuid = T2.stuid` instead of filtering directly on `pet IS NOT NULL` in the WHERE clause. Do remove the explicit `WHERE` filter condition since the join inherently ensures the existence of a pet relationship. The amended query now correctly identifies students with pets through the join relationship rather than relying on a potentially missing pet column in the students table."
        ],
        "rules": [
            "When answering about \"different first names and ages of students who have pets\": make sure the output order: T1.fname, T1.age",
            "When the question mentions \"first names\": \"first names\" actually means \"T1.fname in schema\"",
            "When the question mentions \"ages\": \"ages\" actually means \"T1.age in schema\"",
            "When the question asks for \"different\" values: return only unique combinations of T1.fname and T1.age",
            "When identifying students who have pets: combine T1 (students) and T2 (has_pet) where T1.stuid = T2.stuid and keep only matching pairs (inner match)",
            "When answering about \"different first names and ages of students who have pets\", When the question mentions \"first names\", When the question mentions \"ages\", When the question asks for \"different\" values, When identifying students who have pets, When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT first_name, age FROM students WHERE pet IS NOT NULL;",
            "SELECT DISTINCT T1.Fname, T1.Age FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Fname, T1.Age FROM Student T1 INNER JOIN Has_Pet T2 ON T1.StuID = T2.StuID ORDER BY T1.Fname, T1.Age"
        ]
    },
    "77": {
        "db_id": "pets_1",
        "question": "Find the id of the pet owned by student whose last name is \u2018Smith\u2019.",
        "ground_truth": "SELECT T2.petid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid WHERE T1.Lname  =  'Smith'",
        "amends": [
            "Do select `T2.petid` instead of `pet_id` and use table aliases `T1` and `T2` instead of direct table references. Do add `JOIN has_pet AS T2 ON T1.stuid = T2.stuid` instead of querying only the students table. Do filter on `T1.Lname = 'Smith'` instead of `last_name = 'Smith'` to use the correct column name from the joined table structure. The amended query now correctly retrieves pet information through the relationship table instead of assuming pets are directly stored in the students table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for \"pet owned by student\": use the relationship table \"has_pet\" as T2 to link students and pets instead of assuming pets are directly in the students table.",
            "When combining students and has_pet tables: link rows where T1.stuid = T2.stuid and keep only matching pairs (inner match).",
            "When the question mentions \"last name\": \"last name\" actually means \"Lname\" in the students table (T1.Lname).",
            "When filtering for students with last name 'Smith': use T1.Lname = 'Smith' with exact case and spacing.",
            "When the question asks for \"pet owned by student\", When combining students and has_pet tables, When the question mentions \"last name\", When filtering for students with last name 'Smith', When selecting the pet identifier: use T2.petid instead of pet_id to match the correct column name from the relationship table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pet_id FROM students WHERE last_name = 'Smith';",
            "SELECT T2.PetID \nFROM Student AS T1 \nJOIN Has_Pet AS T2 ON T1.StuID = T2.StuID \nWHERE T1.LName = 'Smith'"
        ],
        "rule_sql": [
            "SELECT T2.PetID \nFROM Student T1 \nINNER JOIN Has_Pet T2 ON T1.StuID = T2.StuID \nWHERE T1.Lname = 'Smith'"
        ]
    },
    "78": {
        "db_id": "pets_1",
        "question": "What is the id of the pet owned by the student whose last name is 'Smith'?",
        "ground_truth": "SELECT T2.petid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid WHERE T1.Lname  =  'Smith'",
        "amends": [
            "Do select `T2.petid` instead of `pet_id` and use table aliases `T1` and `T2` instead of bare table names. Do add `JOIN has_pet AS T2 ON T1.stuid = T2.stuid` instead of querying only the students table. Do reference `T1.Lname` instead of `last_name` and use the correct column name `Lname` instead of `last_name`. Do remove the direct reference to `pet_id` from the students table and instead join to the has_pet table to get the correct `petid` column. The amended query now correctly retrieves pet IDs by joining the student and has_pet tables and filtering on the student's last name, matching the right SQL's behavior."
        ],
        "rules": [
            "When the question asks for \"id of the pet\": select \"T2\".\"petid\" instead of \"pet_id\" from the \"has_pet\" table.",
            "When joining student and pet information: combine \"students\" as \"T1\" and \"has_pet\" as \"T2\" where \"T1\".\"stuid\" = \"T2\".\"stuid\" to get matching pairs only.",
            "When filtering by student last name 'Smith': use \"T1\".\"Lname\" = 'Smith' instead of \"last_name\" to match the exact column name.",
            "When the question asks for \"id of the pet\", When joining student and pet information, When filtering by student last name 'Smith', When answering about pet ownership: make sure the output order shows only \"T2\".\"petid\" as requested."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pet_id FROM students WHERE last_name = 'Smith';",
            "SELECT T2.petid FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID WHERE T1.LName = 'Smith'"
        ],
        "rule_sql": [
            "SELECT T2.PetID FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID WHERE T1.LName = 'Smith';"
        ]
    },
    "79": {
        "db_id": "pets_1",
        "question": "Find the number of pets for each student who has any pet and student id.",
        "ground_truth": "SELECT count(*) ,  T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid GROUP BY T1.stuid",
        "amends": [
            "Do select `count(*)` and `T1.stuid` instead of `student_id` and `COUNT(*)`. Do use `FROM student AS T1 JOIN has_pet AS T2` instead of `FROM pets`. Do add join condition `ON T1.stuid = T2.stuid` instead of omitting it. Do group by `T1.stuid` instead of `student_id`. The amended query now correctly counts pets per student by joining the student and has_pet tables instead of querying a non-existent pets table directly, matching the intended behavior.",
            "Do place `count(*)` first in the SELECT list instead of `T1.StuID`. Do use lowercase `stuid` for the column reference instead of `StuID`. Do remove the alias `T1.StuID` from the SELECT list instead of including it, as it's redundant when grouping by the same column. The amended query now correctly returns only the count of pets per student without duplicating the student ID in the output, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for \"number of pets for each student\": count the number of pets using the join between student table as T1 and has_pet table as T2.",
            "When combining student and has_pet tables: link rows where T1.stuid = T2.stuid and keep only matching pairs (inner match).",
            "When grouping by student: organize results by T1.stuid instead of student_id.",
            "When selecting output columns: use T1.stuid for student identification and count(*) for the number of pets.",
            "When the question asks for \"number of pets for each student\", When combining student and has_pet tables, When grouping by student, When selecting output columns, When the question mentions \"student id\": use the exact column token T1.stuid from the schema.",
            "When the question asks for \"number of pets for each student\": count the number of pets using the canonical key from the Has_Pet table and group by the exact student identifier token.",
            "When selecting output columns: place the count first in the output order and do not include the grouping column in the select list when it's redundant.",
            "When referring to the student identifier column: use the exact lowercase token \"stuid\" as shown in the schema and amends.",
            "When the question asks for \"number of pets for each student\", When selecting output columns, When referring to the student identifier column, When combining Student and Has_Pet tables: link rows where Student.stuid equals Has_Pet.stuid using an inner match to find students who have pets."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_id, COUNT(*) FROM pets GROUP BY student_id",
            "SELECT T1.StuID, COUNT(*) \nFROM Student AS T1 \nJOIN Has_Pet AS T2 ON T1.StuID = T2.StuID \nGROUP BY T1.StuID",
            "SELECT count(*), T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid = T2.stuid GROUP BY T1.stuid"
        ],
        "rule_sql": [
            "SELECT T1.stuid, COUNT(*) AS number_of_pets FROM Student AS T1 INNER JOIN Has_Pet AS T2 ON T1.stuid = T2.stuid GROUP BY T1.stuid"
        ]
    },
    "80": {
        "db_id": "pets_1",
        "question": "For students who have pets , how many pets does each student have ? list their ids instead of names .",
        "ground_truth": "select count(*) ,  t1.stuid from student as t1 join has_pet as t2 on t1.stuid  =  t2.stuid group by t1.stuid",
        "amends": [
            "Do select `count(*)` and `t1.stuid` instead of `student_id` and `COUNT(*) as pet_count`. Do use `FROM student as t1 JOIN has_pet as t2` instead of `FROM students` to properly join the student and pet tables. Do apply the join condition `on t1.stuid = t2.stuid` instead of omitting the table relationship. Do remove the `HAVING pet_count > 0` filter instead of keeping it, as counting joined pet records inherently excludes students without pets. The amended query now correctly counts pets per student by joining the relevant tables and matches the RIGHT_SQL's behavior.",
            "Do place `count(*)` before `t1.stuid` in the SELECT list instead of having `t1.StuID` first. Do use lowercase `stuid` instead of mixed case `StuID` for consistency. Do maintain the same FROM clause with `student as t1` joining `has_pet as t2` on `t1.stuid = t2.stuid` instead of changing the join logic. Do keep the GROUP BY clause with `t1.stuid` instead of modifying the grouping. The amended query now correctly outputs the count of pets per student while maintaining the same logical behavior as the right SQL."
        ],
        "rules": [
            "When answering about \"students who have pets\": use table aliases T1 for \"student\" and T2 for \"has_pet\" exactly as specified.",
            "When joining student and pet tables: link rows where T1.StuID = T2.StuID to match students with their pets.",
            "When counting pets per student: use count(*) to count all pet records for each student.",
            "When selecting student identifiers: use T1.StuID instead of student_id to match the exact column name.",
            "When grouping results: organize by T1.StuID to show pet counts for each individual student.",
            "When answering about \"students who have pets\", When joining student and pet tables, When counting pets per student, When selecting student identifiers, When grouping results, When the question asks for \"how many pets each student has\": do not apply additional filters like HAVING pet_count > 0 since the join inherently excludes students without pets.",
            "When answering about \"how many pets each student has\": make sure the output order: count of pets first, then student id.",
            "When referring to student identifiers: use lowercase \"stuid\" consistently instead of mixed case \"StuID\".",
            "When counting pets per student: count all rows from the Has_Pet table for each student using the join condition t1.stuid = t2.stuid.",
            "When answering about \"how many pets each student has\", When referring to student identifiers, When counting pets per student, When organizing results by student: group by t1.stuid to compute aggregates per student."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id, COUNT(*) as pet_count FROM students GROUP BY student_id HAVING pet_count > 0",
            "SELECT t1.StuID, COUNT(*) \nFROM Student AS t1 \nJOIN Has_Pet AS t2 ON t1.StuID = t2.StuID \nGROUP BY t1.StuID",
            "SELECT count(*), t1.stuid FROM student as t1 JOIN has_pet as t2 ON t1.stuid = t2.stuid GROUP BY t1.stuid"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS pet_count, T1.StuID AS stuid\nFROM Student T1\nJOIN Has_Pet T2 ON T1.StuID = T2.StuID\nGROUP BY T1.StuID\nORDER BY pet_count, stuid"
        ]
    },
    "81": {
        "db_id": "pets_1",
        "question": "Find the first name and gender of student who have more than one pet.",
        "ground_truth": "SELECT T1.fname ,  T1.sex FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid GROUP BY T1.stuid HAVING count(*)  >  1",
        "amends": [
            "Do select `fname` and `sex` instead of `first_name` and `gender`. Do use table alias `T1` for the `student` table instead of directly referencing `students`. Do add a `JOIN` with `has_pet AS T2` on `T1.stuid = T2.stuid` instead of omitting this table relationship. Do add `GROUP BY T1.stuid` instead of grouping by the entire table. Do move the count filter to `HAVING count(*) > 1` instead of using `WHERE pet_count > 1`. The amended query now correctly counts pets per student and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for \"first name\" and \"gender\": use the exact column tokens \"fname\" and \"sex\" from table T1 instead of \"first_name\" and \"gender\".",
            "When counting pets per student: join table \"has_pet\" as T2 with T1 using the exact key equality T1.stuid = T2.stuid and keep only matching pairs (inner match).",
            "When grouping by student: organize results by T1.stuid instead of grouping by the entire table.",
            "When the question asks for \"first name\" and \"gender\", When counting pets per student, When grouping by student, When filtering for students with more than one pet: count the number of pets using count(*) and apply the condition count(*) > 1 in the HAVING clause instead of using a WHERE condition on a pet_count column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, gender FROM students WHERE pet_count > 1;",
            "SELECT T1.Fname, T1.Sex FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID GROUP BY T1.StuID HAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T1.fname, T1.sex FROM Student AS T1 INNER JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID GROUP BY T1.StuID HAVING COUNT(*) > 1"
        ]
    },
    "82": {
        "db_id": "pets_1",
        "question": "What is the first name and gender of the all the students who have more than one pet?",
        "ground_truth": "SELECT T1.fname ,  T1.sex FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid GROUP BY T1.stuid HAVING count(*)  >  1",
        "amends": [
            "Do select `fname` and `sex` with table aliases instead of `first_name` and `gender` without aliases. Do use `student AS T1` joined with `has_pet AS T2` on `T1.stuid = T2.stuid` instead of querying only `students` without joins. Do add `GROUP BY T1.stuid` instead of omitting grouping. Do move the count filter to `HAVING count(*) > 1` instead of using `WHERE COUNT(pets) > 1` which incorrectly applies aggregation in the WHERE clause. The amended query now correctly counts pet relationships through the join and applies the aggregation filter in the proper HAVING clause, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for \"first name\" and \"gender\": use the exact column tokens \"fname\" and \"sex\" from the schema instead of \"first_name\" and \"gender\".",
            "When counting pets per student: join \"student AS T1\" with \"has_pet AS T2\" on \"T1.stuid = T2.stuid\" to establish the pet relationships.",
            "When grouping by student: use \"GROUP BY T1.stuid\" to organize results by individual students.",
            "When the question asks for \"first name\" and \"gender\", When counting pets per student, When grouping by student, When filtering for students with more than one pet: apply the condition \"count(*) > 1\" in the HAVING clause instead of the WHERE clause to properly handle aggregation filters."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, gender FROM students WHERE COUNT(pets) > 1",
            "SELECT T1.Fname, T1.Sex FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID GROUP BY T1.StuID HAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T1.fname, T1.sex FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID GROUP BY T1.StuID HAVING COUNT(*) > 1"
        ]
    },
    "83": {
        "db_id": "pets_1",
        "question": "Find the last name of the student who has a cat that is age 3.",
        "ground_truth": "SELECT T1.lname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pet_age  =  3 AND T3.pettype  =  'cat'",
        "amends": [
            "Do use explicit table aliases `T1.lname` instead of ambiguous `last_name`. Do join three tables `student AS T1`, `has_pet AS T2`, and `pets AS T3` instead of querying only the `students` table. Do use `JOIN` with proper join conditions `ON T1.stuid = T2.stuid` and `ON T3.petid = T2.petid` instead of assuming direct relationships. Do filter on `T3.pet_age = 3` and `T3.pettype = 'cat'` instead of filtering on non-existent columns `pet_type` and `pet_age` in the students table. Do remove `ORDER BY student_id DESC LIMIT 1` instead of keeping it since the correct query returns all matching records without ordering or limiting. The amended query now correctly joins the necessary tables and filters on the appropriate pet-related columns to match the intended behavior."
        ],
        "rules": [
            "When answering about \"last name of the student who has a cat that is age 3\": make sure the output order: T1.lname.",
            "When the question mentions \"student\": use table \"student AS T1\" with column \"T1.lname\" for last name.",
            "When the question mentions \"has a cat\": use table \"pets AS T3\" with filter \"T3.pettype = 'cat'\" exactly.",
            "When the question mentions \"age 3\": use table \"pets AS T3\" with filter \"T3.pet_age = 3\" exactly.",
            "When combining student, has_pet, and pets tables: link rows where \"T1.stuid = T2.stuid\" and \"T3.petid = T2.petid\" using inner matches only.",
            "When answering about \"last name of the student who has a cat that is age 3\", When the question mentions \"student\", When the question mentions \"has a cat\", When the question mentions \"age 3\", When combining student, has_pet, and pets tables, When producing output: do not add ORDER BY or LIMIT clauses since the question asks for all matching records without ranking or limiting."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM students WHERE pet_type = 'cat' AND pet_age = 3 ORDER BY student_id DESC LIMIT 1;",
            "SELECT T1.LName \nFROM Student AS T1\nJOIN Has_Pet AS T2 ON T1.StuID = T2.StuID\nJOIN Pets AS T3 ON T3.PetID = T2.PetID\nWHERE T3.PetType = 'cat' AND T3.pet_age = 3"
        ],
        "rule_sql": [
            "SELECT T1.LName FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID JOIN Pets AS T3 ON T3.PetID = T2.PetID WHERE T3.PetType = 'cat' AND T3.pet_age = 3"
        ]
    },
    "84": {
        "db_id": "pets_1",
        "question": "What is the last name of the student who has a cat that is 3 years old?",
        "ground_truth": "SELECT T1.lname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pet_age  =  3 AND T3.pettype  =  'cat'",
        "amends": [
            "Do use `T1.lname` instead of `last_name` for the column selection. Do join `student AS T1` instead of querying `students` table directly. Do add `has_pet AS T2` join on `T1.stuid = T2.stuid` instead of omitting this relationship table. Do add `pets AS T3` join on `T3.petid = T2.petid` instead of accessing pet attributes directly from students. Do filter on `T3.pet_age = 3` instead of `pet_age = 3` to reference the correct table. Do filter on `T3.pettype = 'cat'` instead of `pet_type = 'cat'` with the correct column name. Do remove `ORDER BY student_id DESC LIMIT 1` instead of keeping the ordering and limiting as the query logic now correctly returns all matching records. The amended query now properly joins through the relationship tables to access pet information and returns all students with 3-year-old cats instead of just one student."
        ],
        "rules": [
            "When selecting student last name: use \"T1.lname\" instead of \"last_name\" as the output column.",
            "When accessing student information: use table \"student AS T1\" instead of \"students\" table.",
            "When relating students to pets: join \"has_pet AS T2\" on \"T1.stuid = T2.stuid\" to connect student and pet relationship.",
            "When accessing pet attributes: join \"pets AS T3\" on \"T3.petid = T2.petid\" to get pet details.",
            "When filtering by pet age: use \"T3.pet_age = 3\" to reference the correct table and column.",
            "When filtering by pet type: use \"T3.pettype = 'cat'\" with exact column name and literal value.",
            "When selecting student last name, When accessing student information, When relating students to pets, When accessing pet attributes, When filtering by pet age, When filtering by pet type, When the question asks for a student with specific pet attributes: do not apply ordering or limiting as it should return all matching records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM students WHERE pet_type = 'cat' AND pet_age = 3 ORDER BY student_id DESC LIMIT 1;",
            "SELECT T1.LName FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID JOIN Pets AS T3 ON T3.PetID = T2.PetID WHERE T3.PetType = 'cat' AND T3.pet_age = 3"
        ],
        "rule_sql": [
            "SELECT T1.LName FROM student AS T1 JOIN has_pet AS T2 ON T1.StuID = T2.StuID JOIN pets AS T3 ON T3.PetID = T2.PetID WHERE T3.PetType = 'cat' AND T3.pet_age = 3"
        ]
    },
    "85": {
        "db_id": "pets_1",
        "question": "Find the average age of students who do not have any pet .",
        "ground_truth": "select avg(age) from student where stuid not in (select stuid from has_pet)",
        "amends": [
            "Do reference the `student` table instead of `students` in the FROM clause. Do use a subquery with `stuid not in (select stuid from has_pet)` instead of the `pet_count > 0` WHERE filter. Do remove the aggregate function reference to `pet_count` instead of keeping it, as the correct logic checks for absence in the has_pet relationship table rather than counting pets. The amended query now correctly identifies students without pets by checking their absence in the has_pet table rather than relying on a potentially incorrect or missing pet_count field, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"average age of students who do not have any pet\": make sure the output order: AVG(age).",
            "When the question mentions \"students\": \"students\" actually means \"student in schema\".",
            "When checking for students without pets: use a subquery with stuid not in (select stuid from has_pet) instead of checking pet_count > 0.",
            "When answering about \"average age of students who do not have any pet\", When the question mentions \"students\", When checking for students without pets, When combining student and has_pet tables for absence checking: link rows where stuid values match between the tables to identify students not present in has_pet."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age) FROM students WHERE pet_count > 0;",
            "SELECT AVG(Age) FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Pet)"
        ],
        "rule_sql": [
            "SELECT AVG(Age) FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Pet)"
        ]
    },
    "86": {
        "db_id": "pets_1",
        "question": "What is the average age for all students who do not own any pets ?",
        "ground_truth": "select avg(age) from student where stuid not in (select stuid from has_pet)",
        "amends": [
            "Do reference the `student` table instead of `students` in the FROM clause. Do use a subquery with `stuid not in (select stuid from has_pet)` instead of filtering on `pet_count = 0` in the WHERE clause. Do maintain the same `AVG(age)` aggregate function in the SELECT list. The amended query now correctly identifies students without pets by checking their absence from the has_pet table rather than relying on a potentially incorrect pet_count column, matching the right SQL's behavior."
        ],
        "rules": [
            "When the question asks about \"students who do not own any pets\": use a subquery to check for students whose stuid is not present in the has_pet table using \"stuid not in (select stuid from has_pet)\" instead of filtering on pet_count.",
            "When computing average age for students: use the AVG(age) aggregate function on the student table.",
            "When the question asks about \"students who do not own any pets\", When computing average age for students, When referencing the main student table: use the exact table name \"student\" (not \"students\") as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age) FROM students WHERE pet_count = 0;",
            "SELECT AVG(Age) FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Pet)"
        ],
        "rule_sql": [
            "SELECT AVG(Age) FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Pet)"
        ]
    },
    "87": {
        "db_id": "car_1",
        "question": "How many continents are there?",
        "ground_truth": "SELECT count(*) FROM CONTINENTS;",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM continents;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM continents;"
        ]
    },
    "88": {
        "db_id": "car_1",
        "question": "What is the number of continents?",
        "ground_truth": "SELECT count(*) FROM CONTINENTS;",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM continents;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS NumberOfContinents FROM continents;"
        ]
    },
    "89": {
        "db_id": "car_1",
        "question": "How many countries does each continent have? List the continent id, continent name and the number of countries.",
        "ground_truth": "SELECT T1.ContId ,  T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.Continent GROUP BY T1.ContId;",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do select from `CONTINENTS AS T1` instead of only `countries`. Do add `JOIN COUNTRIES AS T2 ON T1.ContId = T2.Continent` instead of omitting the join condition. Do change the SELECT list to `T1.ContId, T1.Continent, count(*)` instead of `continent_id, continent_name, COUNT(*) as country_count`. Do modify the GROUP BY clause to `GROUP BY T1.ContId` instead of grouping by both `continent_id` and `continent_name`. The amended query now correctly joins continents with countries and counts countries per continent, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"How many countries does each continent have?\": make sure the output order: T1.ContId, T1.Continent, count(*)",
            "When the question mentions \"continent id\": \"continent id\" actually means \"T1.ContId in schema\"",
            "When the question mentions \"continent name\": \"continent name\" actually means \"T1.Continent in schema\"",
            "When combining T1 and T2 for shared entities: link rows where T1.ContId = T2.Continent exactly as shown in the amends; keep only matching pairs (inner match)",
            "When the question asks for \"count of countries\": compute the number of rows using the canonical key token for countries (T2 table)",
            "When the question says \"per continent\"/\"by continent\": organize results by T1.ContId and compute requested aggregates per group",
            "When answering about \"How many countries does each continent have?\", When the question mentions \"continent id\", When the question mentions \"continent name\", When combining T1 and T2 for shared entities, When the question asks for \"count of countries\", When the question says \"per continent\"/\"by continent\", When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT continent_id, continent_name, COUNT(*) as country_count \nFROM countries \nGROUP BY continent_id, continent_name",
            "SELECT T1.ContId, T1.Continent, COUNT(*) \nFROM continents AS T1 \nJOIN countries AS T2 ON T1.ContId = T2.Continent \nGROUP BY T1.ContId"
        ],
        "rule_sql": [
            "SELECT T1.\"ContId\", T1.\"Continent\", COUNT(*) \nFROM \"continents\" T1 \nINNER JOIN \"countries\" T2 ON T1.\"ContId\" = T2.\"Continent\" \nGROUP BY T1.\"ContId\", T1.\"Continent\""
        ]
    },
    "90": {
        "db_id": "car_1",
        "question": "For each continent, list its id, name, and how many countries it has?",
        "ground_truth": "SELECT T1.ContId ,  T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.Continent GROUP BY T1.ContId;",
        "amends": [
            "Do add table `COUNTRIES AS T2` with a `JOIN` on `T1.ContId = T2.Continent` instead of querying only the `continents` table. Do change the SELECT list to use `T1.ContId` and `T1.Continent` instead of `continent_id` and `continent_name`. Do remove `continent_name` from the GROUP BY clause instead of including it, since the join with COUNTRIES table requires grouping only by continent identifier. Do maintain the `COUNT(*)` aggregate function but now applied to the joined result set instead of just the continents table. The amended query now correctly counts countries per continent by joining the tables and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"how many countries per continent\": make sure to combine the continents table (as T1) with the countries table (as T2) using an inner match where T1.ContId equals T2.Continent.",
            "When the question asks for \"continent id\" and \"continent name\": use the exact tokens T1.ContId and T1.Continent from the schema.",
            "When the question asks for \"count of countries per continent\": compute the number of rows using COUNT(*) applied to the joined result set, grouped only by T1.ContId instead of including T1.Continent in the grouping.",
            "When answering about \"how many countries per continent\", When the question asks for \"continent id\" and \"continent name\", When the question asks for \"count of countries per continent\", When producing output: maintain the column order as T1.ContId, T1.Continent, and then the count of countries."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT continent_id, continent_name, COUNT(*) FROM continents GROUP BY continent_id, continent_name",
            "SELECT T1.ContId, T1.Continent, COUNT(*) \nFROM continents AS T1 \nJOIN countries AS T2 ON T1.ContId = T2.Continent \nGROUP BY T1.ContId, T1.Continent"
        ],
        "rule_sql": [
            "SELECT T1.ContId, T1.Continent, COUNT(*) \nFROM continents T1 \nINNER JOIN countries T2 ON T1.ContId = T2.Continent \nGROUP BY T1.ContId"
        ]
    },
    "91": {
        "db_id": "car_1",
        "question": "How many countries are listed?",
        "ground_truth": "SELECT count(*) FROM COUNTRIES;",
        "amends": [
            "Do reference table `COUNTRIES` instead of `cities` to count records from the correct data source. The amended query now correctly counts records from the COUNTRIES table instead of cities, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"how many countries are listed\": make sure to count records from the \"COUNTRIES\" table instead of any other table.",
            "When answering about \"how many countries are listed\", When counting entities: use the canonical counting method that counts all rows in the specified table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities;",
            "SELECT COUNT(*) FROM countries;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM countries;"
        ]
    },
    "92": {
        "db_id": "car_1",
        "question": "How many countries exist?",
        "ground_truth": "SELECT count(*) FROM COUNTRIES;",
        "amends": [
            "Do reference the `COUNTRIES` table instead of the `cities` table in the FROM clause. Do maintain the `COUNT(*)` aggregate function without changes. The amended query now correctly counts records from the COUNTRIES table instead of the cities table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"how many countries exist\": use the COUNTRIES table to count records.",
            "When answering about \"how many countries exist\", When counting entities: use COUNT(*) to count all rows from the specified table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities;",
            "SELECT COUNT(*) FROM countries;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM countries;"
        ]
    },
    "93": {
        "db_id": "car_1",
        "question": "How many models does each car maker produce? List maker full name, id and the number.",
        "ground_truth": "SELECT T1.FullName ,  T1.Id ,  count(*) FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id;",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of unspecified table references. Do change the FROM clause to `CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2` instead of the single table `car_models`. Do add the join condition `ON T1.Id = T2.Maker` instead of omitting it. Do change the SELECT list to `T1.FullName, T1.Id, count(*)` instead of `maker, id, COUNT(*) as model_count`. Do remove the alias `model_count` instead of keeping it. Do change the GROUP BY clause to `T1.Id` instead of `maker, id`. The amended query now correctly joins the manufacturer and model tables and counts models per manufacturer."
        ],
        "rules": [
            "When answering about \"models per car maker\": make sure the output order: T1.FullName, T1.Id, count(*)",
            "When the question mentions \"car maker\": \"car maker\" actually means \"CAR_MAKERS as T1\" in schema",
            "When the question mentions \"models\": \"models\" actually means \"MODEL_LIST as T2\" in schema",
            "When combining T1 and T2 for shared entities: link rows where T1.Id = T2.Maker exactly as shown in the amends; keep only matching pairs (inner match)",
            "When the question asks for \"count of models\" per maker: compute the number of rows using the join relationship where T2.Maker matches T1.Id",
            "When the question says \"per car maker\"/\"by car maker\": organize results by T1.Id and compute count per group",
            "When answering about \"models per car maker\", When the question mentions \"car maker\", When the question mentions \"models\", When combining T1 and T2 for shared entities, When the question asks for \"count of models\" per maker, When the question says \"per car maker\"/\"by car maker\", When producing output: do not include aliases like \"model_count\" in the final result"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT maker, id, COUNT(*) as model_count FROM car_models GROUP BY maker, id",
            "SELECT T1.FullName, T1.Id, count(*)\nFROM CAR_MAKERS AS T1\nJOIN MODEL_LIST AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id"
        ],
        "rule_sql": [
            "SELECT T1.FullName, T1.Id, COUNT(*) \nFROM CAR_MAKERS AS T1 \nINNER JOIN MODEL_LIST AS T2 ON T1.Id = T2.Maker \nGROUP BY T1.Id, T1.FullName \nORDER BY T1.FullName, T1.Id"
        ]
    },
    "94": {
        "db_id": "car_1",
        "question": "What is the full name of each car maker, along with its id and how many models it produces?",
        "ground_truth": "SELECT T1.FullName ,  T1.Id ,  count(*) FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id;",
        "amends": [
            "Do join `MODEL_LIST` as `T2` on `T1.Id = T2.Maker` instead of querying only `car_makers` without any join. Do use `T1.Id` and `T1.FullName` in the SELECT list instead of `car_makers.id` and `car_makers.full_name`. Do group by only `T1.Id` instead of grouping by both `car_makers.id` and `car_makers.full_name`. Do remove the alias `model_count` from the count instead of keeping it. The amended query now correctly counts models per car maker by joining with the model table and matches the RIGHT_SQL's behavior.",
            "Do use `count(*)` instead of `COUNT(T2.ModelId)` to count all rows in each group rather than counting non-null ModelId values. Do reorder the SELECT list as `T1.FullName, T1.Id` instead of `T1.Id, T1.FullName` while maintaining the same logical output. Do add the `AS` keyword for table aliases as `CAR_MAKERS AS T1` and `MODEL_LIST AS T2` instead of omitting it, though this is purely syntactic. The amended query now correctly counts all car models per manufacturer regardless of null ModelId values and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about car makers and their model counts: join table MODEL_LIST as T2 with car_makers as T1 using the condition T1.Id = T2.Maker to link models to their makers.",
            "When selecting output columns: use T1.Id and T1.FullName exactly as shown in the schema.",
            "When counting models per car maker: count using the joined T2 table rows rather than counting from T1 alone.",
            "When grouping results: group by only T1.Id instead of grouping by both T1.Id and T1.FullName.",
            "When answering about car makers and their model counts, When selecting output columns, When counting models per car maker, When grouping results, When presenting results: do not use aliases like model_count for the count column.",
            "When counting models per car maker: count all rows in each group using count(*) instead of counting non-null values of a specific column.",
            "When ordering output columns for car maker information: present FullName before Id in the output order.",
            "When counting models per car maker, When ordering output columns for car maker information, When using table aliases: include the AS keyword for clarity when defining table aliases CAR_MAKERS AS T1 and MODEL_LIST AS T2."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT car_makers.id, car_makers.full_name, COUNT(*) as model_count \nFROM car_makers \nGROUP BY car_makers.id, car_makers.full_name",
            "SELECT T1.Id, T1.FullName, COUNT(T2.ModelId) \nFROM car_makers T1 \nJOIN model_list T2 ON T1.Id = T2.Maker \nGROUP BY T1.Id",
            "SELECT T1.FullName, T1.Id, COUNT(*) \nFROM car_makers AS T1 \nJOIN model_list AS T2 ON T1.Id = T2.Maker \nGROUP BY T1.Id"
        ],
        "rule_sql": [
            "SELECT T1.FullName, T1.Id, COUNT(*) \nFROM car_makers AS T1 \nJOIN model_list AS T2 ON T1.Id = T2.Maker \nGROUP BY T1.Id \nORDER BY T1.FullName, T1.Id"
        ]
    },
    "95": {
        "db_id": "car_1",
        "question": "Which model of the car has the minimum horsepower?",
        "ground_truth": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;",
        "amends": [
            "Do join `CAR_NAMES AS T1` and `CARS_DATA AS T2` on `T1.MakeId = T2.Id` instead of querying only the `cars` table. Do select `T1.Model` instead of `model` to reference the correct table. Do order by `T2.horsepower ASC` instead of `horsepower DESC` to get the minimum horsepower instead of maximum. The amended query now correctly retrieves the car model with the lowest horsepower by properly joining the car names and data tables."
        ],
        "rules": [
            "When answering about \"which model of the car has the minimum horsepower\": make sure the output order: T1.Model.",
            "When combining CAR_NAMES as T1 and CARS_DATA as T2: link rows where T1.MakeId = T2.Id and keep only matching pairs (inner match).",
            "When answering about \"which model of the car has the minimum horsepower\", When combining CAR_NAMES as T1 and CARS_DATA as T2, When the question asks for minimum horsepower: order rows by T2.horsepower in ascending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model FROM cars ORDER BY horsepower DESC LIMIT 1;",
            "SELECT T1.Model FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id ORDER BY T2.Horsepower ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Model FROM car_names AS T1 INNER JOIN cars_data AS T2 ON T1.MakeId = T2.Id ORDER BY CAST(T2.Horsepower AS NUMERIC) ASC LIMIT 1"
        ]
    },
    "96": {
        "db_id": "car_1",
        "question": "What is the model of the car with the smallest amount of horsepower?",
        "ground_truth": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;",
        "amends": [
            "Do select `T1.Model` from the `CAR_NAMES` table instead of selecting `model` from the `cars` table. Do join `CARS_DATA AS T2` with the condition `T1.MakeId = T2.Id` instead of querying a single table without any joins. Do order by `T2.horsepower ASC` in ascending order instead of `horsepower DESC` in descending order. The amended query now correctly retrieves the car model with the lowest horsepower by properly joining the car names and data tables."
        ],
        "rules": [
            "When answering about \"model of the car with the smallest amount of horsepower\": make sure the output order: T1.Model",
            "When the question mentions \"model\": \"model\" actually means \"T1.Model in schema\"",
            "When combining T1 and T2 for shared entities: link rows where T1.MakeId = T2.Id exactly as shown in the amends; keep only matching pairs (inner match)",
            "When the question mentions \"smallest amount of horsepower\": order rows by T2.horsepower in ascending order to find the minimum value",
            "When answering about \"model of the car with the smallest amount of horsepower\", When the question mentions \"model\", When combining T1 and T2 for shared entities, When the question mentions \"smallest amount of horsepower\", When the question asks for the single car with the smallest horsepower: take only the first row after ordering by T2.horsepower ASC"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT model FROM cars ORDER BY horsepower DESC LIMIT 1;",
            "SELECT T1.Model FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id ORDER BY T2.Horsepower ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Model FROM car_names T1 INNER JOIN cars_data T2 ON T1.MakeId = T2.Id ORDER BY T2.Horsepower ASC LIMIT 1"
        ]
    },
    "97": {
        "db_id": "car_1",
        "question": "Find the model of the car whose weight is below the average weight.",
        "ground_truth": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)",
        "amends": [
            "Do specify `T1.model` with table alias instead of just `model`. Do join `CAR_NAMES AS T1` and `CARS_DATA AS T2` instead of querying only `cars`. Do use `ON T1.MakeId = T2.Id` for the join condition instead of no join. Do filter on `T2.Weight` instead of `weight`. Do reference `CARS_DATA` in the subquery instead of `cars`. The amended query now correctly joins the necessary tables and references the appropriate columns to match the intended behavior."
        ],
        "rules": [
            "When answering about car models and weights: join CAR_NAMES as T1 and CARS_DATA as T2 using the condition T1.MakeId = T2.Id.",
            "When filtering by weight below average: compare T2.Weight against the average weight from CARS_DATA.",
            "When selecting the model: output T1.model from the joined result.",
            "When answering about car models and weights, When filtering by weight below average, When selecting the model, When combining tables for shared entities: perform an inner match where T1.MakeId equals T2.Id exactly as specified."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT model FROM cars WHERE weight < (SELECT AVG(weight) FROM cars);",
            "SELECT T1.Model \nFROM CAR_NAMES AS T1\nJOIN CARS_DATA AS T2 ON T1.MakeId = T2.Id\nWHERE T2.Weight < (SELECT AVG(Weight) FROM CARS_DATA)"
        ],
        "rule_sql": [
            "SELECT T1.Model FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id WHERE T2.Weight < (SELECT AVG(Weight) FROM cars_data)"
        ]
    },
    "98": {
        "db_id": "car_1",
        "question": "What is the model for the car with a weight smaller than the average?",
        "ground_truth": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)",
        "amends": [
            "Do select `T1.model` from the `CAR_NAMES` table instead of `model` from the `cars` table. Do join `CARS_DATA AS T2` with `T1.MakeId = T2.Id` instead of querying a single table. Do use `T2.Weight <` instead of `weight >` for the comparison. Do reference `CARS_DATA` in the subquery instead of `cars`. Do add proper table aliases and join conditions instead of assuming a single table structure. The amended query now correctly joins the car names with car data and uses the proper comparison logic to find models with below-average weight."
        ],
        "rules": [
            "When selecting car model information: use \"T1.model\" from the \"CAR_NAMES\" table instead of \"model\" from a generic \"cars\" table.",
            "When combining car name and car data information: join \"CAR_NAMES\" as T1 with \"CARS_DATA\" as T2 using the condition T1.MakeId = T2.Id to link the tables correctly.",
            "When comparing car weight to average weight: use T2.Weight < (subquery result) instead of weight > to find cars with below-average weight.",
            "When selecting car model information, When combining car name and car data information, When comparing car weight to average weight, When computing average weight in a subquery: reference the \"CARS_DATA\" table instead of a generic \"cars\" table to ensure proper data source."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT model FROM cars WHERE weight > (SELECT AVG(weight) FROM cars);",
            "SELECT T1.Model \nFROM car_names AS T1\nJOIN cars_data AS T2 ON T1.MakeId = T2.Id\nWHERE T2.Weight < (SELECT AVG(Weight) FROM cars_data)"
        ],
        "rule_sql": [
            "SELECT T1.Model FROM CAR_NAMES T1 JOIN CARS_DATA T2 ON T1.MakeId = T2.Id WHERE T2.Weight < (SELECT AVG(Weight) FROM CARS_DATA)"
        ]
    },
    "99": {
        "db_id": "car_1",
        "question": "Find the name of the makers that produced some cars in the year of 1970?",
        "ground_truth": "SELECT DISTINCT T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model JOIN CARS_DATA AS T4 ON T3.MakeId  =  T4.id WHERE T4.year  =  '1970';",
        "amends": [
            "Do use `DISTINCT T1.Maker` instead of `maker` to eliminate duplicates. Do add joins to `CAR_MAKERS AS T1`, `MODEL_LIST AS T2`, `CAR_NAMES AS T3`, and `CARS_DATA AS T4` instead of querying only `cars`. Do join on `T1.Id = T2.Maker` and `T2.model = T3.model` and `T3.MakeId = T4.id` instead of no join conditions. Do filter on `T4.year = '1970'` instead of `year = 1970` with proper table qualification and string literal. The amended query now correctly identifies car makers from 1970 by traversing the proper relationship chain between tables."
        ],
        "rules": [
            "When answering about \"makers that produced cars in 1970\": use DISTINCT T1.Maker to eliminate duplicate maker names.",
            "When combining tables for car maker information: link CAR_MAKERS AS T1, MODEL_LIST AS T2, CAR_NAMES AS T3, and CARS_DATA AS T4 using T1.Id = T2.Maker and T2.model = T3.model and T3.MakeId = T4.id to traverse the relationship chain.",
            "When filtering for cars from a specific year: use T4.year = '1970' with the exact string literal '1970' and proper table qualification.",
            "When answering about \"makers that produced cars in 1970\", When combining tables for car maker information, When filtering for cars from a specific year, When the question asks for \"makers that produced some cars\": ensure the query returns only makers that have at least one car from the specified year by using inner joins between all tables."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT maker FROM cars WHERE year = 1970;",
            "SELECT DISTINCT T1.Maker\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nJOIN car_names AS T3 ON T2.Model = T3.Model\nJOIN cars_data AS T4 ON T3.MakeId = T4.Id\nWHERE T4.Year = '1970'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Maker\nFROM car_makers AS T1\nINNER JOIN model_list AS T2 ON T1.Id = T2.Maker\nINNER JOIN car_names AS T3 ON T2.Model = T3.Model\nINNER JOIN cars_data AS T4 ON T3.MakeId = T4.Id\nWHERE T4.Year = '1970'"
        ]
    },
    "100": {
        "db_id": "car_1",
        "question": "What is the name of the different car makers who produced a car in 1970?",
        "ground_truth": "SELECT DISTINCT T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model JOIN CARS_DATA AS T4 ON T3.MakeId  =  T4.id WHERE T4.year  =  '1970';",
        "amends": [
            "Do add explicit table joins with `CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id = T2.Maker JOIN CAR_NAMES AS T3 ON T2.model = T3.model JOIN CARS_DATA AS T4 ON T3.MakeId = T4.id` instead of querying a single `cars` table. Do reference the maker column as `T1.Maker` instead of just `maker`. Do filter on `T4.year = '1970'` with string comparison instead of numeric `year = 1970`. The amended query now correctly joins multiple tables to establish the proper relationship between car makers and their 1970 models, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about car makers who produced cars in 1970: join tables CAR_MAKERS AS T1, MODEL_LIST AS T2, CAR_NAMES AS T3, and CARS_DATA AS T4 using the exact relationships T1.Id = T2.Maker, T2.model = T3.model, and T3.MakeId = T4.id.",
            "When filtering for cars produced in 1970: use T4.year = '1970' with string comparison instead of numeric comparison.",
            "When selecting car maker names: use T1.Maker as the exact column reference instead of just maker.",
            "When answering about car makers who produced cars in 1970, When filtering for cars produced in 1970, When selecting car maker names, When ensuring distinct car makers: return only unique values of T1.Maker."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT maker FROM cars WHERE year = 1970;",
            "SELECT DISTINCT T1.Maker\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nJOIN car_names AS T3 ON T2.Model = T3.Model\nJOIN cars_data AS T4 ON T3.MakeId = T4.Id\nWHERE T4.Year = '1970'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Maker\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nJOIN car_names AS T3 ON T2.Model = T3.Model\nJOIN cars_data AS T4 ON T3.MakeId = T4.Id\nWHERE T4.Year = '1970';"
        ]
    },
    "101": {
        "db_id": "car_1",
        "question": "Find the make and production time of the cars that were produced in the earliest year?",
        "ground_truth": "SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);",
        "amends": [
            "Do select `T2.Make` and `T1.Year` instead of `make` and `production_time`. Do join `CAR_NAMES AS T2` on `T1.Id = T2.MakeId` instead of querying only the `cars` table. Do add a WHERE filter for `T1.Year = (SELECT min(YEAR) FROM CARS_DATA)` instead of ordering by `production_year DESC` with `LIMIT 1`. Do remove the ORDER BY and LIMIT clauses instead of keeping them. The amended query now correctly finds the car make with the earliest production year by joining the necessary tables and using a subquery to identify the minimum year, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"make and production time of cars produced in the earliest year\": make sure the output order: T2.Make, T1.Year",
            "When the question mentions \"make\": \"make\" actually means \"T2.Make in schema\"",
            "When the question mentions \"production time\": \"production time\" actually means \"T1.Year in schema\"",
            "When combining T1 and T2 for shared entities: link rows where T1.Id = T2.MakeId exactly as shown in the amends; keep only matching pairs (inner match)",
            "When the question asks for cars produced in the earliest year: filter rows where T1.Year equals the minimum Year value from CARS_DATA table using T1.Year = (SELECT min(YEAR) FROM CARS_DATA)",
            "When answering about \"make and production time of cars produced in the earliest year\", When the question mentions \"make\", When the question mentions \"production time\", When combining T1 and T2 for shared entities, When the question asks for cars produced in the earliest year, When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for T2.Make and T1.Year"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT make, production_time FROM cars ORDER BY production_year DESC LIMIT 1;",
            "SELECT T2.Make, T1.Year \nFROM cars_data AS T1 \nJOIN car_names AS T2 ON T1.Id = T2.MakeId \nWHERE T1.Year = (SELECT MIN(Year) FROM cars_data)"
        ],
        "rule_sql": [
            "SELECT T2.Make, T1.Year FROM cars_data T1 INNER JOIN car_names T2 ON T1.Id = T2.MakeId WHERE T1.Year = (SELECT min(Year) FROM cars_data)"
        ]
    },
    "102": {
        "db_id": "car_1",
        "question": "What is the maker of the carr produced in the earliest year and what year was it?",
        "ground_truth": "SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);",
        "amends": [
            "Do select `T2.Make` and `T1.Year` instead of `maker` and `MIN(year)`. Do join `CAR_NAMES AS T2` on `T1.Id = T2.MakeId` instead of querying a single table. Do use `WHERE T1.Year = (SELECT min(YEAR) FROM CARS_DATA)` instead of `WHERE year = (SELECT MAX(year) FROM cars)`. Do reference the correct table aliases `T1` and `T2` instead of the original table references. The amended query now correctly retrieves the make and year from joined tables using the proper minimum year calculation."
        ],
        "rules": [
            "When answering about \"maker of the car produced in the earliest year\": make sure the output order: T2.Make, T1.Year",
            "When the question mentions \"maker\": \"maker\" actually means \"T2.Make\" in schema",
            "When the question mentions \"earliest year\": use the minimum value of T1.Year from CARS_DATA table",
            "When combining T1 and T2 for shared entities: link rows where T1.Id = T2.MakeId exactly as shown in the amends; keep only matching pairs (inner match)",
            "When answering about \"maker of the car produced in the earliest year\", When the question mentions \"maker\", When the question mentions \"earliest year\", When combining T1 and T2 for shared entities, When filtering for the earliest year: use WHERE T1.Year = (SELECT min(YEAR) FROM CARS_DATA) to find cars produced in the minimum year"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT maker, MIN(year) FROM cars WHERE year = (SELECT MAX(year) FROM cars);",
            "SELECT T2.Make, T1.Year \nFROM cars_data AS T1\nJOIN car_names AS T2 ON T1.Id = T2.MakeId\nWHERE T1.Year = (SELECT MIN(Year) FROM cars_data)"
        ],
        "rule_sql": [
            "SELECT T2.Make, T1.Year \nFROM cars_data T1 \nINNER JOIN car_names T2 ON T1.Id = T2.MakeId \nWHERE T1.Year = (SELECT min(Year) FROM cars_data)"
        ]
    },
    "103": {
        "db_id": "car_1",
        "question": "Which distinct car models are the produced after 1980?",
        "ground_truth": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;",
        "amends": [
            "Do add `MODEL_LIST AS T1` joined to `CAR_NAMES AS T2` on `T1.model = T2.model` instead of querying `cars` directly. Do add another join to `CARS_DATA AS T3` on `T2.MakeId = T3.id` instead of missing these table relationships. Do move the year filter to `T3.year > 1980` instead of applying it to an unspecified source. Do specify the table alias with `T1.model` instead of just `model` to avoid ambiguity. The amended query now correctly joins the three required tables to filter cars by year while maintaining the distinct model selection, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"distinct car models produced after 1980\": make sure the output order: T1.model",
            "When the question mentions \"car models\": \"car models\" actually means \"T1.model in schema\"",
            "When the question mentions \"after 1980\": apply the year filter to T3.year > 1980",
            "When combining MODEL_LIST as T1 and CAR_NAMES as T2: link rows where T1.model = T2.model and keep only matching pairs (inner match)",
            "When combining T2 and CARS_DATA as T3: link rows where T2.MakeId = T3.id and keep only matching pairs (inner match)",
            "When answering about \"distinct car models produced after 1980\", When the question mentions \"car models\", When the question mentions \"after 1980\", When combining MODEL_LIST as T1 and CAR_NAMES as T2, When combining T2 and CARS_DATA as T3, When selecting distinct values: compute the number of unique values of T1.model"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT model FROM cars WHERE year > 1980;",
            "SELECT DISTINCT T1.Model FROM model_list AS T1 JOIN car_names AS T2 ON T1.Model = T2.Model JOIN cars_data AS T3 ON T2.MakeId = T3.Id WHERE T3.Year > 1980"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Model\nFROM model_list T1\nINNER JOIN car_names T2 ON T1.Model = T2.Model\nINNER JOIN cars_data T3 ON T2.MakeId = T3.Id\nWHERE T3.Year > 1980\nORDER BY T1.Model"
        ]
    },
    "104": {
        "db_id": "car_1",
        "question": "What are the different models for the cards produced after 1980?",
        "ground_truth": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;",
        "amends": [
            "Do use `DISTINCT T1.model` instead of just `model` to eliminate duplicates. Do add `MODEL_LIST AS T1` as the main table instead of just `cards`. Do add `JOIN CAR_NAMES AS T2 ON T1.model = T2.model` instead of omitting this join. Do add `JOIN CARS_DATA AS T3 ON T2.MakeId = T3.id` instead of omitting this second join. Do use `T3.year > 1980` instead of `production_year > 1980` to filter on the correct year column from the joined table. The amended query now correctly joins multiple tables to retrieve distinct car models from the appropriate year filter."
        ],
        "rules": [
            "When answering about \"different models for the cards produced after 1980\": make sure the output order: T1.model",
            "When the question mentions \"different models\": use DISTINCT T1.model to eliminate duplicate model values",
            "When the question mentions \"cards produced after 1980\": use T3.year > 1980 to filter on the correct year column from the joined CARS_DATA table",
            "When combining MODEL_LIST, CAR_NAMES, and CARS_DATA tables: link rows where T1.model = T2.model and T2.MakeId = T3.id, keeping only matching pairs (inner match)",
            "When answering about \"different models for the cards produced after 1980\", When the question mentions \"different models\", When the question mentions \"cards produced after 1980\", When combining MODEL_LIST, CAR_NAMES, and CARS_DATA tables, When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table names like MODEL_LIST, CAR_NAMES, and CARS_DATA"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT model FROM cards WHERE production_year > 1980",
            "SELECT DISTINCT T1.Model FROM model_list AS T1 JOIN car_names AS T2 ON T1.Model = T2.Model JOIN cars_data AS T3 ON T2.MakeId = T3.Id WHERE T3.Year > 1980"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Model FROM \"model_list\" T1 INNER JOIN \"car_names\" T2 ON T1.Model = T2.Model INNER JOIN \"cars_data\" T3 ON T2.MakeId = T3.Id WHERE T3.Year > 1980 ORDER BY T1.Model"
        ]
    },
    "105": {
        "db_id": "car_1",
        "question": "How many car makers are there in each continents? List the continent name and the count.",
        "ground_truth": "SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;",
        "amends": [
            "Do add `CONTINENTS AS T1` and `COUNTRIES AS T2` tables with proper joins instead of querying only `car_makers`. Do use `JOIN COUNTRIES AS T2 ON T1.ContId = T2.continent` to connect continents to countries instead of missing this relationship. Do add `JOIN car_makers AS T3 ON T2.CountryId = T3.Country` to properly associate car makers with countries instead of directly grouping by continent from car_makers. Do select `T1.Continent` from the continents table instead of the potentially incorrect `continent` column from car_makers. The amended query now correctly handles the hierarchical relationship between continents, countries, and car makers, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"car makers in each continent\": make sure to use the hierarchical relationship between continents, countries, and car makers instead of querying only the car_makers table.",
            "When combining continents and countries: link rows where T1.ContId = T2.continent to connect continents to countries.",
            "When combining countries and car makers: link rows where T2.CountryId = T3.Country to associate car makers with countries.",
            "When selecting the continent name: use T1.Continent from the continents table instead of any other continent column.",
            "When answering about \"car makers in each continent\", When combining continents and countries, When combining countries and car makers, When selecting the continent name, When counting car makers per continent: count the number of car makers using the proper hierarchical relationship through countries rather than direct grouping by continent from car_makers."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT continent, COUNT(*) FROM car_makers GROUP BY continent;",
            "SELECT T1.Continent, COUNT(T3.Id) AS CountOfCarMakers\nFROM continents AS T1\nJOIN countries AS T2 ON T1.ContId = T2.Continent\nJOIN car_makers AS T3 ON T2.CountryId = T3.Country\nGROUP BY T1.Continent"
        ],
        "rule_sql": [
            "SELECT c.Continent, COUNT(DISTINCT cm.Id) AS CarMakerCount\nFROM continents c\nJOIN countries co ON c.ContId = co.Continent\nJOIN car_makers cm ON co.CountryId = cm.Country\nGROUP BY c.Continent\nORDER BY CarMakerCount DESC;"
        ]
    },
    "106": {
        "db_id": "car_1",
        "question": "What is the name of each continent and how many car makers are there in each one?",
        "ground_truth": "SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;",
        "amends": [
            "Do add `CONTINENTS AS T1` and `COUNTRIES AS T2` tables with proper joins instead of querying `car_makers` alone. Do use `JOIN COUNTRIES AS T2 ON T1.ContId = T2.continent` instead of missing the countries-continents relationship. Do use `JOIN car_makers AS T3 ON T2.CountryId = T3.Country` instead of directly grouping by continent from car_makers. Do select `T1.Continent` with proper table qualification instead of just `continent`. The amended query now correctly links continents to countries to car manufacturers and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"name of each continent and how many car makers are there in each one\": make sure the output order: T1.Continent first, then count of car makers.",
            "When combining tables for continents, countries, and car makers: link T1 and T2 where T1.ContId = T2.continent, then link T2 and T3 where T2.CountryId = T3.Country, keeping only matching pairs (inner match).",
            "When counting car makers per continent: compute the number of rows using T3's canonical key for car makers (likely T3.Id or similar, though not explicitly shown in amends).",
            "When grouping results: organize by T1.Continent to get counts per continent.",
            "When answering about \"name of each continent and how many car makers are there in each one\", When combining tables for continents, countries, and car makers, When counting car makers per continent, When grouping results, When selecting continent name: use T1.Continent with proper table qualification instead of just continent."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT continent, COUNT(*) FROM car_makers GROUP BY continent;",
            "SELECT T1.Continent, COUNT(T3.Id) AS NumberOfCarMakers\nFROM continents AS T1\nJOIN countries AS T2 ON T1.ContId = T2.Continent\nJOIN car_makers AS T3 ON T2.CountryId = T3.Country\nGROUP BY T1.Continent"
        ],
        "rule_sql": [
            "SELECT T1.Continent, COUNT(T3.Id) AS NumberOfCarMakers\nFROM continents T1\nINNER JOIN countries T2 ON T1.ContId = T2.Continent\nINNER JOIN car_makers T3 ON T2.CountryId = T3.Country\nGROUP BY T1.Continent\nORDER BY T1.Continent, NumberOfCarMakers;"
        ]
    },
    "107": {
        "db_id": "car_1",
        "question": "Which of the countries has the most car makers? List the country name.",
        "ground_truth": "SELECT T2.CountryName FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId GROUP BY T1.Country ORDER BY Count(*) DESC LIMIT 1;",
        "amends": [
            "Do join `COUNTRIES` as `T2` on `T1.Country = T2.CountryId` instead of querying only `car_makers` without any join. Do select `T2.CountryName` instead of `country` to get the proper country name from the joined table. Do order by `Count(*) DESC` instead of `ASC` to find the country with the highest count rather than the lowest. Do use table aliases `T1` and `T2` instead of no aliases for clarity. The amended query now correctly identifies the country with the most car makers by joining to the countries table and ordering in descending order."
        ],
        "rules": [
            "When answering about \"countries with the most car makers\": make sure the output order: T2.CountryName.",
            "When the question mentions \"country name\": \"country name\" actually means \"T2.CountryName\" in schema.",
            "When the question asks for \"most car makers\": rank rows by Count(*) in descending direction and keep the first 1 row.",
            "When combining T1 and T2 for shared entities: link rows where T1.Country = T2.CountryId exactly as shown in the amends; keep only matching pairs (inner match).",
            "When answering about \"countries with the most car makers\", When the question mentions \"country name\", When the question asks for \"most car makers\", When combining T1 and T2 for shared entities, When counting car makers: compute the number of rows using the canonical key from car_makers table (T1.Country) per country group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country, COUNT(*) as maker_count FROM car_makers GROUP BY country ORDER BY maker_count ASC LIMIT 1;",
            "SELECT T2.CountryName\nFROM car_makers T1\nJOIN countries T2 ON T1.Country = T2.CountryId\nGROUP BY T1.Country\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.CountryName\nFROM car_makers T1\nJOIN countries T2 ON T1.Country = T2.CountryId\nGROUP BY T2.CountryName\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "108": {
        "db_id": "car_1",
        "question": "What is the name of the country with the most car makers?",
        "ground_truth": "SELECT T2.CountryName FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId GROUP BY T1.Country ORDER BY Count(*) DESC LIMIT 1;",
        "amends": [
            "Do join `COUNTRIES` as `T2` instead of querying only `car_makers`. Do use `T1.Country = T2.CountryId` as the join condition instead of no join. Do select `T2.CountryName` instead of `country`. Do add `GROUP BY T1.Country` instead of omitting grouping. Do maintain `ORDER BY COUNT(*) DESC LIMIT 1` as in the original query. The amended query now correctly retrieves the country name from the joined COUNTRIES table while preserving the aggregation logic to find the country with the most car makers."
        ],
        "rules": [
            "When answering about \"country with the most car makers\": make sure the output order: T2.CountryName",
            "When the question mentions \"country\": \"country\" actually means \"T2.CountryName in schema\"",
            "When combining T1 and T2 for shared entities: link rows where T1.Country = T2.CountryId exactly as shown in the amends; keep only matching pairs (inner match)",
            "When the question asks for \"count of car makers\": compute the number of rows using the canonical key token for car makers (T1.Country)",
            "When the question mentions \"most\" or an explicit top 1 by count: rank rows by count of car makers in descending direction and keep the first 1 row",
            "When answering about \"country with the most car makers\", When the question mentions \"country\", When combining T1 and T2 for shared entities, When the question asks for \"count of car makers\", When the question mentions \"most\" or an explicit top 1 by count, When the question says \"per country\"/\"by country\": organize results by T1.Country and compute requested aggregates per group"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM car_makers ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T2.CountryName\nFROM car_makers T1\nJOIN countries T2 ON T1.Country = T2.CountryId\nGROUP BY T1.Country\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.CountryName\nFROM car_makers T1\nJOIN countries T2 ON T1.Country = T2.CountryId\nGROUP BY T1.Country\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "109": {
        "db_id": "car_1",
        "question": "How many car models are produced by each maker ? Only list the count and the maker full name .",
        "ground_truth": "select count(*) ,  t2.fullname from model_list as t1 join car_makers as t2 on t1.maker  =  t2.id group by t2.id;",
        "amends": [
            "Do join `car_makers` as `t2` instead of omitting it, and use `model_list` as `t1` instead of `car_models`. Do join on `t1.maker = t2.id` instead of no join condition. Do select `t2.fullname` instead of `maker`, and remove the alias `model_count` instead of keeping it. Do group by `t2.id` instead of `maker`. The amended query now correctly counts models per maker by joining to the car_makers table and grouping on the maker's ID rather than the raw maker value."
        ],
        "rules": [
            "When the question asks for \"each maker\": join table \"model_list\" as T1 with table \"car_makers\" as T2 using the condition T1.maker = T2.id to get maker information.",
            "When counting car models per maker: count the number of rows using the canonical key from T1 (models) grouped by T2.id.",
            "When the question asks for \"maker full name\": select T2.fullname instead of the raw maker value.",
            "When organizing results by maker: group by T2.id to ensure proper aggregation per maker entity.",
            "When the question asks for \"each maker\", When counting car models per maker, When the question asks for \"maker full name\", When organizing results by maker, When producing output columns: list the count first followed by the maker full name, without using aliases for the count column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) as model_count, maker FROM car_models GROUP BY maker;",
            "SELECT COUNT(t1.ModelId) AS count, t2.FullName \nFROM model_list t1 \nJOIN car_makers t2 ON t1.Maker = t2.Id \nGROUP BY t2.Id"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ModelId), T2.FullName FROM model_list T1 JOIN car_makers T2 ON T1.Maker = T2.Id GROUP BY T2.Id"
        ]
    },
    "110": {
        "db_id": "car_1",
        "question": "What is the number of car models that are produced by each maker and what is the id and full name of each maker?",
        "ground_truth": "SELECT Count(*) ,  T2.FullName ,  T2.id FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id GROUP BY T2.id;",
        "amends": [
            "Do select `Count(*)`, `T2.FullName`, and `T2.id` instead of `maker` and `COUNT(*) as num_models`. Do join `MODEL_LIST AS T1` with `CAR_MAKERS AS T2` on `T1.Maker = T2.Id` instead of querying only `car_models`. Do group by `T2.id` instead of `maker`. The amended query now correctly counts models per car maker while joining the appropriate tables to resolve maker information.",
            "Do remove the alias `num_models` from the count expression instead of keeping it. Do change the column order to place `T2.FullName` before `T2.id` instead of having `T2.Id` first. Do use lowercase `id` in both the select list and GROUP BY clause instead of uppercase `Id`. Do remove the table alias `AS` syntax from the FROM clause references instead of including it. The amended query now correctly groups by maker ID while selecting the count and full name in the proper order."
        ],
        "rules": [
            "When answering about car models per maker: join MODEL_LIST AS T1 with CAR_MAKERS AS T2 on T1.Maker = T2.Id to resolve maker information.",
            "When counting car models per maker: count using Count(*) and group by T2.id.",
            "When answering about car models per maker, When counting car models per maker, When outputting maker information: include T2.id and T2.FullName in the results.",
            "When counting car models per maker: count using the canonical key from the model_list table instead of using COUNT(*).",
            "When selecting output columns for maker information: place the FullName column before the id column in the output order.",
            "When referencing the id column from car_makers table: use lowercase \"id\" instead of uppercase \"Id\" in both SELECT and GROUP BY clauses.",
            "When counting car models per maker, When selecting output columns for maker information, When referencing the id column from car_makers table, When specifying table references in FROM clause: do not use the AS keyword syntax for table aliases."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT maker, COUNT(*) as num_models FROM car_models GROUP BY maker;",
            "SELECT COUNT(*) AS num_models, T2.Id, T2.FullName FROM model_list AS T1 JOIN car_makers AS T2 ON T1.Maker = T2.Id GROUP BY T2.Id",
            "SELECT COUNT(*) AS num_models, T2.FullName, T2.id\nFROM model_list T1\nJOIN car_makers T2 ON T1.Maker = T2.id\nGROUP BY T2.id"
        ],
        "rule_sql": [
            "SELECT T2.FullName, T2.id, COUNT(T1.ModelId) AS NumberOfModels \nFROM model_list T1 \nJOIN car_makers T2 ON T1.Maker = T2.id \nGROUP BY T2.id, T2.FullName"
        ]
    },
    "111": {
        "db_id": "car_1",
        "question": "What is the accelerate of the car make amc hornet sportabout (sw)?",
        "ground_truth": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';",
        "amends": [
            "Do join `CAR_NAMES` as `T2` on `T1.Id = T2.MakeId` instead of querying `cars` table directly. Do reference `Accelerate` from `T1` instead of `accelerate` from the base table. Do filter on `T2.Make = 'amc hornet sportabout (sw)'` instead of `make = 'amc hornet sportabout (sw)'` to properly correlate the make name with the corresponding acceleration data through the join relationship. The amended query now correctly retrieves acceleration data by joining through the proper table relationship instead of assuming the make column exists directly in the data table."
        ],
        "rules": [
            "When answering about \"accelerate of the car make amc hornet sportabout (sw)\": make sure the output order: Accelerate from T1.",
            "When the question mentions \"car make amc hornet sportabout (sw)\": \"amc hornet sportabout (sw)\" actually means T2.Make = 'amc hornet sportabout (sw)' in schema.",
            "When combining T1 and T2 for shared entities: link rows where T1.Id = T2.MakeId exactly as shown in the amends; keep only matching pairs (inner match).",
            "When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for identifiers like T1.Accelerate and T2.Make.",
            "When answering about \"accelerate of the car make amc hornet sportabout (sw)\", When the question mentions \"car make amc hornet sportabout (sw)\", When combining T1 and T2 for shared entities, When choosing identifier delimiters, When handling text literals: do not change case, spacing, or punctuation for 'amc hornet sportabout (sw)'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT accelerate FROM cars WHERE make = 'amc hornet sportabout (sw)'",
            "SELECT T1.Accelerate \nFROM cars_data T1 \nJOIN car_names T2 ON T1.Id = T2.MakeId \nWHERE T2.Make = 'amc hornet sportabout (sw)'"
        ],
        "rule_sql": [
            "SELECT T1.Accelerate FROM cars_data T1 JOIN car_names T2 ON T1.Id = T2.MakeId WHERE T2.Make = 'amc hornet sportabout (sw)'"
        ]
    },
    "112": {
        "db_id": "car_1",
        "question": "How much does the car accelerate that makes amc hornet sportabout (sw)?",
        "ground_truth": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';",
        "amends": [
            "Do join `CAR_NAMES` as `T2` on `T1.Id = T2.MakeId` instead of querying only the `cars` table. Do select `Accelerate` from `CARS_DATA` as `T1` instead of selecting `acceleration` from `cars`. Do filter on `T2.Make = 'amc hornet sportabout (sw)'` instead of filtering on both `model = 'amc hornet sportabout (sw)'` and `make = 'amc'`. Do remove the incorrect `make` filter condition instead of including it. The amended query now correctly joins the necessary tables and uses the proper column relationships to match the intended behavior."
        ],
        "rules": [
            "When answering about car acceleration for a specific model: select \"Accelerate\" from \"CARS_DATA\" as T1 instead of \"acceleration\" from \"cars\".",
            "When the question mentions \"amc hornet sportabout (sw)\": this value should be matched against \"Make\" in \"CAR_NAMES\" as T2, not against \"model\" or \"make\" in the \"cars\" table.",
            "When combining car data with car names: link rows where T1.Id = T2.MakeId and keep only matching pairs (inner join).",
            "When answering about car acceleration for a specific model, When the question mentions \"amc hornet sportabout (sw)\", When combining car data with car names, When filtering for specific car models: use T2.Make = 'amc hornet sportabout (sw)' as the filter condition, and do not include additional make filters."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT acceleration FROM cars WHERE model = 'amc hornet sportabout (sw)' AND make = 'amc';",
            "SELECT T1.Accelerate \nFROM cars_data T1\nJOIN car_names T2 ON T1.Id = T2.MakeId\nWHERE T2.Make = 'amc hornet sportabout (sw)'"
        ],
        "rule_sql": [
            "SELECT T1.Accelerate FROM cars_data AS T1 INNER JOIN car_names AS T2 ON T1.Id = T2.MakeId WHERE T2.Make = 'amc hornet sportabout (sw)'"
        ]
    },
    "113": {
        "db_id": "car_1",
        "question": "How many car makers are there in france?",
        "ground_truth": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';",
        "amends": [
            "Do add a `JOIN` with `COUNTRIES` table on `T1.Country = T2.CountryId` instead of querying only the `car_makers` table. Do filter on `T2.CountryName = 'france'` instead of directly filtering on `country = 'France'` to properly match country names through the relationship table. Do use table aliases `T1` and `T2` instead of referencing tables directly without aliases. The amended query now correctly joins the country reference table to filter by country name instead of relying on potentially inconsistent country codes in the main table."
        ],
        "rules": [
            "When answering about \"car makers in france\": make sure to join T1 (car_makers) with T2 (COUNTRIES) using the exact join condition T1.Country = T2.CountryId.",
            "When filtering by country name: use T2.CountryName = 'france' exactly as specified (lowercase 'france').",
            "When counting car makers: use the canonical key from T1 (car_makers table) to count the number of rows.",
            "When answering about \"car makers in france\", When filtering by country name, When counting car makers, When combining tables for shared entities: perform an inner match where T1.Country equals T2.CountryId and keep only matching pairs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM car_makers WHERE country = 'France';",
            "SELECT COUNT(*) \nFROM car_makers T1\nJOIN countries T2 ON T1.Country = T2.CountryId\nWHERE T2.CountryName = 'france'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM car_makers T1\nINNER JOIN countries T2 ON T1.Country = T2.CountryId\nWHERE T2.CountryName = 'france'"
        ]
    },
    "114": {
        "db_id": "car_1",
        "question": "What is the number of makers of care in France?",
        "ground_truth": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';",
        "amends": [
            "Do join `CAR_MAKERS AS T1` with `COUNTRIES AS T2` on `T1.Country = T2.CountryId` instead of querying only the `makers` table. Do filter on `T2.CountryName = 'france'` instead of directly filtering `country = 'France'` to properly match country names through the relationship table. Do use table aliases `T1` and `T2` instead of omitting them for clarity. The amended query now correctly counts French car makers by joining with the countries reference table and matching on country name instead of assuming direct country values.",
            "Do use lowercase `count(*)` instead of uppercase `COUNT(*)`. Do use lowercase `'france'` instead of uppercase `'France'` for the country name filter. Do maintain the same join condition `T1.Country = T2.CountryId` and table aliases. The amended query now correctly counts car makers from France using case-insensitive matching for the country name."
        ],
        "rules": [
            "When answering about \"number of makers of care in France\": make sure the output order: COUNT(*)",
            "When the question mentions \"France\": \"France\" actually means \"T2.CountryName = 'france'\" in schema",
            "When combining T1 and T2 for shared entities: link rows where T1.Country = T2.CountryId exactly as shown in the amends; keep only matching pairs (inner match)",
            "When answering about \"number of makers of care in France\", When the question mentions \"France\", When combining T1 and T2 for shared entities, When the question asks for \"count of makers\": compute the number of rows using the canonical key token for makers (T1 table)",
            "When the question asks for \"number of makers of care in France\": count all rows using the canonical counting method (count(*)).",
            "When combining car_makers as T1 and countries as T2: link rows where T1.Country equals T2.CountryId exactly and keep only matching pairs (inner match).",
            "When filtering for France: use the exact literal 'france' (lowercase) to match against T2.CountryName.",
            "When the question asks for \"number of makers of care in France\", When combining car_makers as T1 and countries as T2, When filtering for France, When choosing identifier delimiters: do not use uppercase for count(*) or country name literals - use lowercase count(*) and 'france' exactly as shown in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM makers WHERE country = 'France';",
            "SELECT COUNT(*) FROM car_makers AS T1 JOIN countries AS T2 ON T1.Country = T2.CountryId WHERE T2.CountryName = 'France'",
            "SELECT count(*) FROM car_makers AS T1 JOIN countries AS T2 ON T1.Country = T2.CountryId WHERE T2.CountryName = 'france'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM car_makers T1\nINNER JOIN countries T2 ON T1.Country = T2.CountryId\nWHERE T2.CountryName = 'france'"
        ]
    },
    "115": {
        "db_id": "car_1",
        "question": "How many car models are produced in the usa?",
        "ground_truth": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';",
        "amends": [
            "Do add explicit table joins with `MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker = T2.Id JOIN COUNTRIES AS T3 ON T2.Country = T3.CountryId` instead of querying a single `cars` table. Do filter on `T3.CountryName = 'usa'` instead of `country = 'USA'` to properly reference the joined countries table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly joins multiple tables to count models from the specified country and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about car models produced in the usa: make sure to join MODEL_LIST as T1 with CAR_MAKERS as T2 using T1.Maker = T2.Id, then join with COUNTRIES as T3 using T2.Country = T3.CountryId.",
            "When filtering for country: use T3.CountryName = 'usa' (lowercase) instead of 'USA'.",
            "When counting car models: use count(*) to count all rows after proper joins and filtering.",
            "When answering about car models produced in the usa, When filtering for country, When counting car models, When combining tables: perform inner matches using the exact key equalities T1.Maker = T2.Id and T2.Country = T3.CountryId, keeping only matching pairs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE country = 'USA';",
            "SELECT count(*) FROM model_list AS T1 JOIN car_makers AS T2 ON T1.Maker = T2.Id JOIN countries AS T3 ON T2.Country = T3.CountryId WHERE T3.CountryName = 'usa'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM model_list AS T1\nINNER JOIN car_makers AS T2 ON T1.Maker = T2.Id\nINNER JOIN countries AS T3 ON T2.Country = T3.CountryId\nWHERE T3.CountryName = 'usa'"
        ]
    },
    "116": {
        "db_id": "car_1",
        "question": "What is the count of the car models produced in the United States?",
        "ground_truth": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';",
        "amends": [
            "Do add joins to `MODEL_LIST AS T1`, `CAR_MAKERS AS T2`, and `COUNTRIES AS T3` instead of querying only the `cars` table. Do join `T1` to `T2` on `T1.Maker = T2.Id` instead of missing this relationship entirely. Do join `T2` to `T3` on `T2.Country = T3.CountryId` instead of omitting the country table connection. Do filter on `T3.CountryName = 'usa'` instead of filtering directly on `country = 'USA'` which referenced the wrong column. Do use proper table aliases and qualified column references instead of unqualified column names that caused ambiguity. The amended query now correctly counts models from USA manufacturers by properly joining through the manufacturer and country relationships instead of relying on incorrect column references."
        ],
        "rules": [
            "When answering about \"count of car models produced in the United States\": make sure the output order: count of models using T1.Model as the counting key.",
            "When the question mentions \"United States\": \"United States\" actually means T3.CountryName = 'usa' in schema.",
            "When combining T1 and T2 for shared entities: link rows where T1.Maker = T2.Id exactly as shown in the amends; keep only matching pairs (inner match).",
            "When combining T2 and T3 for shared entities: link rows where T2.Country = T3.CountryId exactly as shown in the amends; keep only matching pairs (inner match).",
            "When answering about \"count of car models produced in the United States\", When the question mentions \"United States\", When combining T1 and T2 for shared entities, When combining T2 and T3 for shared entities, When counting car models: compute the number of rows using T1.Model as the canonical key token for models."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE country = 'USA';",
            "SELECT COUNT(*) \nFROM model_list AS T1\nJOIN car_makers AS T2 ON T1.Maker = T2.Id\nJOIN countries AS T3 ON T2.Country = T3.CountryId\nWHERE T3.CountryName = 'usa'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.Model) AS count_of_models\nFROM model_list T1\nINNER JOIN car_makers T2 ON T1.Maker = T2.Id\nINNER JOIN countries T3 ON T2.Country = T3.CountryId\nWHERE T3.CountryName = 'usa'"
        ]
    },
    "117": {
        "db_id": "car_1",
        "question": "What is the average miles per gallon(mpg) of the cars with 4 cylinders?",
        "ground_truth": "SELECT avg(mpg) FROM CARS_DATA WHERE Cylinders  =  4;",
        "amends": [
            "Do select `avg(mpg)` instead of `AVG(horsepower)` to calculate the average miles per gallon rather than horsepower. Do reference table `CARS_DATA` instead of `cars` to use the correct table name. Do filter on `Cylinders = 4` instead of `cylinders = 4` to use the proper column name capitalization. The amended query now correctly calculates average MPG for 4-cylinder vehicles from the appropriate data source."
        ],
        "rules": [
            "When answering about \"average miles per gallon of cars with 4 cylinders\": make sure to calculate the average of \"mpg\" column instead of \"horsepower\".",
            "When referencing the cars data table: use the exact table name \"CARS_DATA\" instead of \"cars\".",
            "When answering about \"average miles per gallon of cars with 4 cylinders\", When referencing the cars data table, When filtering for 4-cylinder vehicles: use the exact column name \"Cylinders\" with proper capitalization and filter for value 4."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(horsepower) FROM cars WHERE cylinders = 4;",
            "SELECT AVG(MPG) FROM cars_data WHERE Cylinders = 4"
        ],
        "rule_sql": [
            "SELECT AVG(MPG) FROM CARS_DATA WHERE Cylinders = 4;"
        ]
    },
    "118": {
        "db_id": "car_1",
        "question": "What is the average miles per gallon of all the cards with 4 cylinders?",
        "ground_truth": "SELECT avg(mpg) FROM CARS_DATA WHERE Cylinders  =  4;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` to use the correct table name. Do use lowercase `avg` function instead of uppercase `AVG` for consistent function naming. Do maintain the same filter condition `cylinders = 4` without changes. The amended query now correctly references the proper table while preserving the same aggregation logic and filtering behavior."
        ],
        "rules": [
            "When answering about \"average miles per gallon of cars with 4 cylinders\": make sure the output order: avg(mpg).",
            "When the question mentions \"cars\": \"cars\" actually means \"CARS_DATA\" in schema.",
            "When the question mentions \"4 cylinders\": use the exact literal value 4 for the cylinders column filter.",
            "When answering about \"average miles per gallon of cars with 4 cylinders\", When the question mentions \"cars\", When the question mentions \"4 cylinders\", When computing averages: use the lowercase avg function for consistent naming."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(mpg) FROM cars WHERE cylinders = 4;",
            "SELECT avg(MPG) FROM cars_data WHERE Cylinders = 4"
        ],
        "rule_sql": [
            "SELECT AVG(MPG) FROM cars_data WHERE Cylinders = 4"
        ]
    },
    "119": {
        "db_id": "car_1",
        "question": "What is the smallest weight of the car produced with 8 cylinders on 1974 ?",
        "ground_truth": "select min(weight) from cars_data where cylinders  =  8 and year  =  1974",
        "amends": [
            "Do use `MIN(weight)` instead of `MAX(weight)` for the aggregate function. Do reference table `cars_data` instead of `cars` as the data source. The amended query now correctly finds the minimum weight of 8-cylinder cars from 1974 rather than the maximum weight."
        ],
        "rules": [
            "When answering about \"smallest weight of the car produced with 8 cylinders on 1974\": use MIN(weight) instead of MAX(weight) for the aggregate function.",
            "When referencing the data source: use table \"cars_data\" instead of \"cars\" as the data source.",
            "When answering about \"smallest weight of the car produced with 8 cylinders on 1974\", When referencing the data source, When filtering for specific car characteristics: apply conditions where cylinders = 8 AND year = 1974 using exact numerical values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(weight) FROM cars WHERE cylinders = 8 AND year = 1974;",
            "SELECT MIN(Weight) FROM cars_data WHERE Cylinders = 8 AND Year = 1974;"
        ],
        "rule_sql": [
            "SELECT MIN(Weight) FROM cars_data WHERE Cylinders = 8 AND Year = 1974;"
        ]
    },
    "120": {
        "db_id": "car_1",
        "question": "What is the minimum weight of the car with 8 cylinders produced in 1974 ?",
        "ground_truth": "select min(weight) from cars_data where cylinders  =  8 and year  =  1974",
        "amends": [
            "Do reference table `cars_data` instead of `cars` while keeping the same MIN(weight) aggregation and WHERE filters on `cylinders = 8` and `year = 1974` unchanged. The amended query now correctly references the actual table name while maintaining the same logical behavior to find the minimum weight of 8-cylinder cars from 1974."
        ],
        "rules": [
            "When answering about \"minimum weight of the car with 8 cylinders produced in 1974\": make sure to reference table \"cars_data\" instead of \"cars\".",
            "When the question mentions \"8 cylinders\": use the exact condition \"cylinders = 8\" in the filtering.",
            "When the question mentions \"produced in 1974\": use the exact condition \"year = 1974\" in the filtering.",
            "When answering about \"minimum weight of the car with 8 cylinders produced in 1974\", When the question mentions \"8 cylinders\", When the question mentions \"produced in 1974\", When the question asks for \"minimum weight\": compute the minimum value of the \"weight\" column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(weight) FROM cars WHERE cylinders = 8 AND year = 1974;",
            "SELECT MIN(Weight) FROM cars_data WHERE Cylinders = 8 AND Year = 1974"
        ],
        "rule_sql": [
            "SELECT MIN(Weight) FROM cars_data WHERE Cylinders = 8 AND Year = 1974;"
        ]
    },
    "121": {
        "db_id": "car_1",
        "question": "What are all the makers and models?",
        "ground_truth": "SELECT Maker ,  Model FROM MODEL_LIST;",
        "amends": [
            "Do reference the `MODEL_LIST` table instead of the `products` table. Do remove the `WHERE model IS NULL` filter instead of keeping it. The amended query now correctly selects all makers and models from the appropriate table without unnecessary filtering.",
            "Do select only `Maker` and `Model` columns instead of including the table prefix `cm.` and `ml.` qualifiers. Do use a single table `MODEL_LIST` as the source instead of joining `car_makers` with `model_list` on `cm.Id = ml.Maker`. Do remove the unnecessary join condition entirely instead of maintaining the relationship between the tables. The amended query now correctly retrieves only the maker and model information directly from the MODEL_LIST table without the redundant join operation."
        ],
        "rules": [
            "When answering about \"all the makers and models\": use the MODEL_LIST table instead of the products table.",
            "When selecting all records: do not apply any WHERE filter conditions like model IS NULL.",
            "When answering about \"all the makers and models\", When selecting all records, When the question asks for \"makers and models\": select both the Maker and Model columns from the MODEL_LIST table.",
            "When answering about \"all the makers and models\": make sure the output order: Maker, Model.",
            "When the question asks for makers and models: use the exact column tokens \"Maker\" and \"Model\" without table prefixes.",
            "When retrieving maker and model information: use only the MODEL_LIST table as the source instead of joining with other tables.",
            "When answering about \"all the makers and models\", When the question asks for makers and models, When retrieving maker and model information, When selecting from MODEL_LIST: do not include any join conditions with car_makers table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT maker, model FROM products WHERE model IS NULL;",
            "SELECT cm.Maker, ml.Model FROM car_makers cm JOIN model_list ml ON cm.Id = ml.Maker;",
            "SELECT Maker, Model FROM model_list"
        ],
        "rule_sql": [
            "SELECT Maker, Model FROM model_list"
        ]
    },
    "122": {
        "db_id": "car_1",
        "question": "What are the makers and models?",
        "ground_truth": "SELECT Maker ,  Model FROM MODEL_LIST;",
        "amends": [
            "Do select specific columns `Maker` and `Model` instead of using `*` to select all columns. Do query from table `MODEL_LIST` instead of table `products`. The amended query now correctly retrieves only the maker and model columns from the appropriate table, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"makers and models\": make sure the output order: Maker, Model.",
            "When the question mentions \"makers\": \"makers\" actually means \"Maker in table MODEL_LIST\".",
            "When the question mentions \"models\": \"models\" actually means \"Model in table car_names\".",
            "When selecting columns: use specific column names \"Maker\" and \"Model\" instead of using \"*\" to select all columns.",
            "When answering about \"makers and models\", When the question mentions \"makers\", When the question mentions \"models\", When selecting columns, When querying for maker and model information: use table \"MODEL_LIST\" instead of table \"products\"."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM products;",
            "SELECT Maker, Model FROM model_list"
        ],
        "rule_sql": [
            "SELECT ml.Maker, cn.Model FROM model_list ml JOIN car_names cn ON ml.Model = cn.Model ORDER BY ml.Maker, cn.Model;"
        ]
    },
    "123": {
        "db_id": "car_1",
        "question": "What are the countries having at least one car maker? List name and id.",
        "ground_truth": "SELECT T1.CountryName ,  T1.CountryId FROM COUNTRIES AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country GROUP BY T1.CountryId HAVING count(*)  >=  1;",
        "amends": [
            "Do use explicit `JOIN` syntax with `T1.CountryId = T2.Country` instead of a correlated subquery with `EXISTS`. Do add table aliases `T1` and `T2` instead of using full table names. Do include `GROUP BY T1.CountryId` instead of omitting aggregation. Do move the existence check to `HAVING count(*) >= 1` instead of using `WHERE EXISTS`. Do select `T1.CountryName` and `T1.CountryId` instead of `country_id, country_name`. The amended query now correctly identifies countries with car makers using proper join semantics and aggregation.",
            "Do maintain the same `SELECT` list order with `CountryName` first instead of `CountryId` first. Do use `AS` for table aliases with `COUNTRIES AS T1` instead of omitting the `AS` keyword. Do use uppercase table names `COUNTRIES` and `CAR_MAKERS` instead of lowercase. Do preserve the same join condition `T1.CountryId = T2.Country` and grouping structure with identical `HAVING` clause `count(*) >= 1`. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [
            "When combining countries and car_makers tables: link rows where T1.CountryId = T2.Country and keep only matching pairs (inner match).",
            "When answering about countries having at least one car maker: organize results by T1.CountryId and compute count of car makers per country.",
            "When filtering for countries with at least one car maker: keep only groups where count(*) >= 1.",
            "When selecting output columns: include T1.CountryName and T1.CountryId in the results.",
            "When combining countries and car_makers tables, When answering about countries having at least one car maker, When filtering for countries with at least one car maker, When selecting output columns, When ordering output: present results in the order T1.CountryId, T1.CountryName as implied by the question asking for \"name and id\".",
            "When answering about countries having at least one car maker: make sure the output order is CountryName first, then CountryId.",
            "When referring to table names: use uppercase identifiers \"COUNTRIES\" and \"CAR_MAKERS\" exactly as shown.",
            "When combining COUNTRIES and CAR_MAKERS: link rows where T1.CountryId = T2.Country and keep only matching pairs (inner match).",
            "When grouping by country: organize results by T1.CountryId and compute count of rows per group.",
            "When answering about countries having at least one car maker, When referring to table names, When combining COUNTRIES and CAR_MAKERS, When grouping by country, When filtering for countries with at least one car maker: keep only groups where the count of rows is greater than or equal to 1."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country_id, country_name FROM countries WHERE EXISTS (SELECT 1 FROM car_makers WHERE car_makers.country_id = countries.country_id);",
            "SELECT T1.CountryId, T1.CountryName\nFROM countries T1\nJOIN car_makers T2 ON T1.CountryId = T2.Country\nGROUP BY T1.CountryId\nHAVING COUNT(*) >= 1",
            "SELECT T1.CountryName, T1.CountryId\nFROM COUNTRIES AS T1\nJOIN CAR_MAKERS AS T2 ON T1.CountryId = T2.Country\nGROUP BY T1.CountryId\nHAVING count(*) >= 1"
        ],
        "rule_sql": [
            "SELECT T1.CountryName, T1.CountryId \nFROM COUNTRIES T1 \nINNER JOIN CAR_MAKERS T2 ON T1.CountryId = T2.Country \nGROUP BY T1.CountryId, T1.CountryName \nHAVING COUNT(*) >= 1 \nORDER BY T1.CountryId, T1.CountryName"
        ]
    },
    "124": {
        "db_id": "car_1",
        "question": "What are the names and ids of all countries with at least one car maker?",
        "ground_truth": "SELECT T1.CountryName ,  T1.CountryId FROM COUNTRIES AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country GROUP BY T1.CountryId HAVING count(*)  >=  1;",
        "amends": [
            "Do select `T1.CountryName` and `T1.CountryId` instead of `name` and `id`. Do add `JOIN CAR_MAKERS AS T2` instead of omitting the table. Do use `ON T1.CountryId = T2.Country` instead of the incorrect `car_makers > 0` filter. Do add `GROUP BY T1.CountryId` instead of omitting grouping. Do move the existence check to `HAVING count(*) >= 1` instead of using `WHERE car_makers > 0`. The amended query now correctly joins the tables and uses proper aggregation to find countries with car makers, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When selecting country information: use T1.CountryName and T1.CountryId as the output columns instead of generic name and id.",
            "When checking for countries with car makers: join the CAR_MAKERS table as T2 using the condition T1.CountryId = T2.Country.",
            "When grouping results by country: use T1.CountryId as the grouping key.",
            "When selecting country information, When checking for countries with car makers, When grouping results by country, When filtering for countries with at least one car maker: use HAVING count(*) >= 1 instead of a WHERE condition on car_makers."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, id FROM countries WHERE car_makers > 0;",
            "SELECT T1.CountryName, T1.CountryId \nFROM countries AS T1 \nJOIN car_makers AS T2 ON T1.CountryId = T2.Country \nGROUP BY T1.CountryId \nHAVING COUNT(*) >= 1"
        ],
        "rule_sql": [
            "SELECT T1.CountryName, T1.CountryId FROM countries T1 JOIN car_makers T2 ON T1.CountryId = T2.Country GROUP BY T1.CountryId HAVING COUNT(*) >= 1"
        ]
    },
    "125": {
        "db_id": "car_1",
        "question": "What is the number of the cars with horsepower more than 150?",
        "ground_truth": "SELECT count(*) FROM CARS_DATA WHERE horsepower  >  150;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` in the FROM clause. Do use filter `horsepower > 150` instead of `horsepower < 150` in the WHERE clause, changing the comparison operator from less than to greater than. The amended query now correctly counts records where horsepower exceeds 150 rather than those below 150, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"number of cars with horsepower more than 150\": make sure the output order: count of cars with horsepower > 150.",
            "When the question mentions \"cars\": \"cars\" actually means \"CARS_DATA\" in schema.",
            "When the question asks for \"number of cars with horsepower more than 150\": compute the count of rows from CARS_DATA where horsepower > 150.",
            "When handling text literals: do not change case, spacing, or punctuation for numeric values like 150.",
            "When answering about \"number of cars with horsepower more than 150\", When the question mentions \"cars\", When the question asks for \"number of cars with horsepower more than 150\", When handling text literals, When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table names like CARS_DATA."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE horsepower < 150;",
            "SELECT COUNT(*) FROM cars_data WHERE horsepower > 150"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM \"cars_data\" WHERE CAST(\"Horsepower\" AS REAL) > 150;"
        ]
    },
    "126": {
        "db_id": "car_1",
        "question": "What is the number of cars with a horsepower greater than 150?",
        "ground_truth": "SELECT count(*) FROM CARS_DATA WHERE horsepower  >  150;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` and use filter `horsepower > 150` instead of `horsepower < 150` to count records with higher horsepower values rather than lower ones. The amended query now correctly counts vehicles exceeding 150 horsepower, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"number of cars with horsepower greater than 150\": use table \"CARS_DATA\" instead of \"cars\" and filter where \"horsepower\" > 150 instead of < 150.",
            "When answering about \"number of cars with horsepower greater than 150\", When counting records: count all rows from \"CARS_DATA\" where the condition \"horsepower > 150\" is true."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE horsepower < 150;",
            "SELECT COUNT(*) FROM cars_data WHERE horsepower > 150"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM cars_data WHERE CAST(Horsepower AS REAL) > 150;"
        ]
    },
    "127": {
        "db_id": "car_1",
        "question": "What is the average weight of cars each year?",
        "ground_truth": "SELECT avg(Weight) ,  YEAR FROM CARS_DATA GROUP BY YEAR;",
        "amends": [
            "Do use `avg(Weight)` with uppercase column name instead of `AVG(weight)` with lowercase. Do place the aggregate function first in the SELECT list instead of the year column. Do reference the correct table name `CARS_DATA` instead of `cars`. Do maintain the same GROUP BY logic with `YEAR` instead of `year` while preserving the uppercase column reference. The amended query now correctly calculates average weight by year from the CARS_DATA table."
        ],
        "rules": [
            "When answering about \"average weight of cars each year\": make sure the output order: avg(Weight) first, then YEAR.",
            "When the question mentions \"cars\": \"cars\" actually means \"CARS_DATA\" in schema.",
            "When the question mentions \"weight\": \"weight\" actually means \"Weight\" in schema with exact uppercase spelling.",
            "When the question says \"each year\": organize results by YEAR and compute average weight per year.",
            "When answering about \"average weight of cars each year\", When the question mentions \"cars\", When the question mentions \"weight\", When the question says \"each year\", When choosing identifier delimiters: do not replace uppercase column names with lowercase forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, AVG(weight) FROM cars GROUP BY year;",
            "SELECT avg(Weight), Year FROM CARS_DATA GROUP BY Year"
        ],
        "rule_sql": [
            "SELECT AVG(Weight) AS average_weight, Year FROM cars_data GROUP BY Year ORDER BY average_weight, Year;"
        ]
    },
    "128": {
        "db_id": "car_1",
        "question": "What is the average weight and year for each year?",
        "ground_truth": "SELECT avg(Weight) ,  YEAR FROM CARS_DATA GROUP BY YEAR;",
        "amends": [
            "Do select `avg(Weight)` and `YEAR` instead of `year` and `AVG(weight) as average_weight`. Do group by `YEAR` instead of `weight`. Do use table `CARS_DATA` instead of `table_name`. The amended query now correctly calculates average weight grouped by year rather than incorrectly grouping by weight itself, matching the intended behavior.",
            "Do place the `YEAR` column after the aggregate function instead of before it in the SELECT list. Do maintain the same `AVG(Weight)` aggregate calculation and `GROUP BY YEAR` clause without changes. The amended query now correctly follows SQL syntax conventions where non-aggregated columns should appear after aggregate functions in the SELECT list when using GROUP BY, ensuring the query matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"average weight and year for each year\": make sure the output order: YEAR, avg(Weight).",
            "When the question mentions \"each year\": group results by the exact column token \"YEAR\".",
            "When computing average weight: use the exact column token \"Weight\" with the avg function.",
            "When answering about \"average weight and year for each year\", When the question mentions \"each year\", When computing average weight, When selecting from the database: use the exact table name \"CARS_DATA\" instead of generic table names.",
            "When answering about \"average weight and year for each year\": make sure the output order: average weight first, then year.",
            "When grouping by year: organize results by the \"YEAR\" column and compute the average of \"Weight\" per group.",
            "When answering about \"average weight and year for each year\", When grouping by year, When producing output columns: place the aggregate function result (AVG(Weight)) before the grouping column (YEAR) in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, AVG(weight) as average_weight FROM table_name GROUP BY weight;",
            "SELECT YEAR, AVG(Weight) FROM cars_data GROUP BY YEAR;",
            "SELECT AVG(Weight), YEAR FROM cars_data GROUP BY YEAR"
        ],
        "rule_sql": [
            "SELECT AVG(Weight) AS AverageWeight, Year FROM CARS_DATA GROUP BY Year ORDER BY Year;"
        ]
    },
    "129": {
        "db_id": "car_1",
        "question": "Which countries in europe have at least 3 car manufacturers?",
        "ground_truth": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;",
        "amends": [
            "Do select `T1.CountryName` from the `COUNTRIES` table instead of `country` from `car_manufacturers`. Do join `CONTINENTS AS T2` on `T1.Continent = T2.ContId` and `CAR_MAKERS AS T3` on `T1.CountryId = T3.Country` instead of querying a single table. Do filter with `T2.Continent = 'europe'` instead of `continent = 'Europe'` and maintain the same `GROUP BY T1.CountryName` and `HAVING count(*) >= 3` logic. The amended query now correctly joins multiple tables to establish proper relationships between countries, continents, and car manufacturers while maintaining the same grouping and filtering behavior."
        ],
        "rules": [
            "When answering about \"countries in europe with at least 3 car manufacturers\": make sure the output order: T1.CountryName",
            "When the question mentions \"countries\": \"countries\" actually means \"T1.CountryName in COUNTRIES table\"",
            "When the question mentions \"europe\": \"europe\" actually means \"T2.Continent = 'europe'\" with exact lowercase spelling",
            "When combining COUNTRIES (T1) and CONTINENTS (T2): link rows where T1.Continent = T2.ContId and keep only matching pairs (inner match)",
            "When combining COUNTRIES (T1) and CAR_MAKERS (T3): link rows where T1.CountryId = T3.Country and keep only matching pairs (inner match)",
            "When the question asks for \"at least 3 car manufacturers\": organize results by T1.CountryName and compute count of car manufacturers per country using count(*) >= 3",
            "When answering about \"countries in europe with at least 3 car manufacturers\", When the question mentions \"countries\", When the question mentions \"europe\", When combining COUNTRIES (T1) and CONTINENTS (T2), When combining COUNTRIES (T1) and CAR_MAKERS (T3), When the question asks for \"at least 3 car manufacturers\", When counting car manufacturers: use the join relationship T1.CountryId = T3.Country to establish the connection between countries and their manufacturers"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM car_manufacturers WHERE continent = 'Europe' GROUP BY country HAVING COUNT(*) >= 3;",
            "SELECT T1.CountryName \nFROM countries AS T1\nJOIN continents AS T2 ON T1.Continent = T2.ContId\nJOIN car_makers AS T3 ON T1.CountryId = T3.Country\nWHERE T2.Continent = 'europe'\nGROUP BY T1.CountryName\nHAVING COUNT(*) >= 3"
        ],
        "rule_sql": [
            "SELECT T1.CountryName\nFROM countries T1\nINNER JOIN continents T2 ON T1.Continent = T2.ContId\nINNER JOIN car_makers T3 ON T1.CountryId = T3.Country\nWHERE T2.Continent = 'europe'\nGROUP BY T1.CountryName\nHAVING COUNT(*) >= 3\nORDER BY T1.CountryName"
        ]
    },
    "130": {
        "db_id": "car_1",
        "question": "What are the names of all European countries with at least 3 manufacturers?",
        "ground_truth": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;",
        "amends": [
            "Do use `T1.CountryName` instead of `c.name` for the SELECT column. Do join `CONTINENTS AS T2` on `T1.Continent = T2.ContId` instead of omitting this table entirely. Do join `CAR_MAKERS AS T3` on `T1.CountryId = T3.Country` instead of joining `manufacturers m` on `c.id = m.country_id`. Do filter on `T2.Continent = 'europe'` instead of `c.continent = 'Europe'`. Do use `count(*) >= 3` instead of `COUNT(m.id) > 2` in the HAVING clause. The amended query now correctly joins through the continents table and uses proper threshold comparison for counting car makers per European country."
        ],
        "rules": [
            "When answering about European countries with manufacturers: make sure the output order: T1.CountryName.",
            "When the question mentions \"European countries\": filter for T2.Continent = 'europe' exactly as shown.",
            "When combining T1 and T2 for shared entities: link rows where T1.Continent = T2.ContId and keep only matching pairs.",
            "When combining T1 and T3 for shared entities: link rows where T1.CountryId = T3.Country and keep only matching pairs.",
            "When the question asks for countries with at least 3 manufacturers: count using count(*) >= 3 instead of counting specific columns.",
            "When answering about European countries with manufacturers, When the question mentions \"European countries\", When combining T1 and T2 for shared entities, When combining T1 and T3 for shared entities, When the question asks for countries with at least 3 manufacturers, When grouping by country: organize results by T1.CountryName and compute the count per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name \nFROM countries c \nJOIN manufacturers m ON c.id = m.country_id \nWHERE c.continent = 'Europe' \nGROUP BY c.name \nHAVING COUNT(m.id) > 2;",
            "SELECT T1.CountryName\nFROM countries AS T1\nJOIN continents AS T2 ON T1.Continent = T2.ContId\nJOIN car_makers AS T3 ON T1.CountryId = T3.Country\nWHERE T2.Continent = 'europe'\nGROUP BY T1.CountryName\nHAVING COUNT(*) >= 3"
        ],
        "rule_sql": [
            "SELECT T1.CountryName\nFROM countries T1\nJOIN continents T2 ON T1.Continent = T2.ContId\nJOIN car_makers T3 ON T1.CountryId = T3.Country\nWHERE T2.Continent = 'europe'\nGROUP BY T1.CountryName\nHAVING COUNT(*) >= 3\nORDER BY T1.CountryName;"
        ]
    },
    "131": {
        "db_id": "car_1",
        "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?",
        "ground_truth": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;",
        "amends": [
            "Do use explicit table aliases `T2.horsepower` and `T1.Make` instead of unqualified column names. Do join `CAR_NAMES AS T1` with `CARS_DATA AS T2` on `T1.MakeId = T2.Id` instead of querying a single non-existent table `car_models`. Do filter on `T2.cylinders = 3` instead of `cylinders = 3` with proper table qualification. Do add `ORDER BY T2.horsepower DESC LIMIT 1` to get the maximum value instead of using `MAX()` aggregation without grouping. The amended query now correctly retrieves the maximum horsepower record with proper table relationships and explicit column qualifications."
        ],
        "rules": [
            "When answering about \"maximum horsepower and make of car models with 3 cylinders\": make sure the output order: maximum horsepower first, then make.",
            "When the question mentions \"car models\": use table \"CAR_NAMES AS T1\" for make information and \"CARS_DATA AS T2\" for technical specifications.",
            "When combining T1 and T2 for shared entities: link rows where T1.MakeId = T2.Id and keep only matching pairs (inner match).",
            "When filtering for 3 cylinders: use T2.cylinders = 3 with exact literal value.",
            "When finding the maximum horsepower: rank rows by T2.horsepower in descending order and keep the first 1 row instead of using MAX() aggregation without grouping.",
            "When answering about \"maximum horsepower and make of car models with 3 cylinders\", When the question mentions \"car models\", When combining T1 and T2 for shared entities, When filtering for 3 cylinders, When finding the maximum horsepower, When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for columns like T2.horsepower and T1.Make."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(horsepower), make FROM car_models WHERE cylinders = 3",
            "SELECT T2.Horsepower, T1.Make \nFROM car_names AS T1 \nJOIN cars_data AS T2 ON T1.MakeId = T2.Id \nWHERE T2.Cylinders = 3 \nORDER BY T2.Horsepower DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.\"Horsepower\", T1.\"Make\" \nFROM \"car_names\" AS T1 \nINNER JOIN \"cars_data\" AS T2 ON T1.\"MakeId\" = T2.\"Id\" \nWHERE T2.\"Cylinders\" = 3 \nORDER BY T2.\"Horsepower\" DESC \nLIMIT 1"
        ]
    },
    "132": {
        "db_id": "car_1",
        "question": "What is the largest amount of horsepower for the models with 3 cylinders and what make is it?",
        "ground_truth": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;",
        "amends": [
            "Do reference `T2.horsepower` and `T1.Make` instead of `MAX(horsepower)` and `make`. Do join `CAR_NAMES AS T1` with `CARS_DATA AS T2` on `T1.MakeId = T2.Id` instead of querying a single table `cars`. Do filter on `T2.cylinders = 3` instead of `cylinders = 3`. Do order by `T2.horsepower DESC` instead of `horsepower DESC`. The amended query now correctly joins the necessary tables and references the proper columns to match the intended behavior."
        ],
        "rules": [
            "When answering about \"largest amount of horsepower for models with 3 cylinders\": make sure the output order: T2.horsepower, T1.Make.",
            "When the question mentions \"make\": \"make\" actually means \"T1.Make in schema\".",
            "When the question mentions \"largest\" by horsepower: rank rows by T2.horsepower in descending order and keep the first 1 row.",
            "When combining CAR_NAMES AS T1 and CARS_DATA AS T2 for shared entities: link rows where T1.MakeId = T2.Id exactly as shown; keep only matching pairs (inner match).",
            "When answering about \"largest amount of horsepower for models with 3 cylinders\", When the question mentions \"make\", When the question mentions \"largest\" by horsepower, When combining CAR_NAMES AS T1 and CARS_DATA AS T2 for shared entities, When filtering for models with 3 cylinders: include only rows where T2.cylinders = 3 exactly."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(horsepower), make FROM cars WHERE cylinders = 3 ORDER BY horsepower DESC LIMIT 1;",
            "SELECT T2.Horsepower, T1.Make \nFROM car_names AS T1 \nJOIN cars_data AS T2 ON T1.MakeId = T2.Id \nWHERE T2.Cylinders = 3 \nORDER BY T2.Horsepower DESC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.Horsepower, T1.Make \nFROM car_names AS T1 \nINNER JOIN cars_data AS T2 ON T1.MakeId = T2.Id \nWHERE T2.Cylinders = 3 \nORDER BY T2.Horsepower DESC \nLIMIT 1"
        ]
    },
    "133": {
        "db_id": "car_1",
        "question": "Which model saves the most gasoline? That is to say, have the maximum miles per gallon.",
        "ground_truth": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT 1;",
        "amends": [
            "Do select `T1.Model` from the `CAR_NAMES` table instead of selecting `model` from the `cars` table. Do join `CARS_DATA AS T2` using `ON T1.MakeId = T2.Id` instead of querying a single table without any joins. Do order by `T2.mpg` instead of ordering by `mpg` without table qualification. The amended query now correctly retrieves the car model with the highest MPG by properly joining the car names with their corresponding performance data."
        ],
        "rules": [
            "When answering about \"which model saves the most gasoline\": make sure the output order: T1.Model",
            "When the question mentions \"model\": \"model\" actually means \"T1.Model in CAR_NAMES table\"",
            "When combining T1 (CAR_NAMES) and T2 (CARS_DATA) for shared entities: link rows where T1.MakeId = T2.Id exactly as shown in the amends; keep only matching pairs (inner match)",
            "When answering about \"which model saves the most gasoline\", When the question mentions \"model\", When combining T1 (CAR_NAMES) and T2 (CARS_DATA) for shared entities, When the question mentions \"maximum miles per gallon\" or \"most gasoline\": rank rows by T2.mpg in descending order and keep the first 1 row"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model FROM cars ORDER BY mpg DESC LIMIT 1;",
            "SELECT T1.Model FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id ORDER BY T2.MPG DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Model FROM car_names T1 INNER JOIN cars_data T2 ON T1.MakeId = T2.Id ORDER BY CAST(T2.MPG AS REAL) DESC LIMIT 1;"
        ]
    },
    "134": {
        "db_id": "car_1",
        "question": "What is the car model with the highest mpg ?",
        "ground_truth": "select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit 1;",
        "amends": [
            "Do select `t1.model` from `car_names as t1` instead of `car_model` from `cars`. Do join `cars_data as t2` on `t1.makeid = t2.id` instead of querying a single table without joins. Do order by `t2.mpg` instead of `mpg` to reference the joined table's column. The amended query now correctly joins the necessary tables to retrieve car model information with proper MPG data and matches the right SQL's behavior.",
            "Do remove the `CAST(t2.MPG AS REAL)` expression instead of keeping it, as the `MPG` column is already numeric and doesn't require casting for proper sorting. Do use direct `t2.mpg DESC` ordering instead of the unnecessary cast operation. The amended query now correctly sorts by the numeric MPG values in descending order and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for \"car model\": use \"t1.model\" from \"car_names as t1\" instead of \"car_model\" from \"cars\".",
            "When combining car names with MPG data: join \"car_names as t1\" with \"cars_data as t2\" where \"t1.makeid = t2.id\" and keep only matching pairs (inner match).",
            "When ordering by MPG to find the highest value: use \"t2.mpg\" from the joined \"cars_data\" table in descending order.",
            "When the question asks for \"car model\", When combining car names with MPG data, When ordering by MPG to find the highest value, When answering about the highest MPG car model: make sure the output order shows only the top result.",
            "When the question asks for the car model with the highest MPG: sort by the numeric MPG column in descending order and keep the first row.",
            "When handling the MPG column from the cars_data table: use the exact column name \"MPG\" without casting since it already contains numeric values.",
            "When combining car_names and cars_data tables: link rows using the exact join condition t1.MakeId = t2.Id as shown in the schema.",
            "When the question asks for the car model with the highest MPG, When handling the MPG column from the cars_data table, When combining car_names and cars_data tables, When answering about car models: output the Model column from the car_names table as the result."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT car_model FROM cars ORDER BY mpg DESC LIMIT 1;",
            "SELECT t1.Model FROM car_names AS t1 JOIN cars_data AS t2 ON t1.MakeId = t2.Id ORDER BY CAST(t2.MPG AS REAL) DESC LIMIT 1;",
            "SELECT t1.Model FROM car_names AS t1 JOIN cars_data AS t2 ON t1.MakeId = t2.Id ORDER BY t2.MPG DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT t1.Model FROM car_names AS t1 INNER JOIN cars_data AS t2 ON t1.MakeId = t2.Id ORDER BY CAST(t2.MPG AS NUMERIC) DESC LIMIT 1;"
        ]
    },
    "135": {
        "db_id": "car_1",
        "question": "What is the average horsepower of the cars before 1980?",
        "ground_truth": "SELECT avg(horsepower) FROM CARS_DATA WHERE YEAR  <  1980;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` in the FROM clause. Do change the WHERE filter to `YEAR < 1980` instead of `year > 1980`, reversing the comparison operator and direction. Do use lowercase `avg` function instead of uppercase `AVG` for the aggregate calculation. The amended query now correctly calculates average horsepower for pre-1980 vehicles instead of post-1980 vehicles, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"average horsepower of cars before 1980\": use table \"CARS_DATA\" instead of \"cars\" in the FROM clause.",
            "When filtering for cars before 1980: use the condition YEAR < 1980 instead of YEAR > 1980.",
            "When answering about \"average horsepower of cars before 1980\", When filtering for cars before 1980, When calculating average horsepower: use the lowercase \"avg\" function instead of uppercase \"AVG\" for the aggregate calculation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(horsepower) FROM cars WHERE year > 1980;",
            "SELECT avg(Horsepower) FROM cars_data WHERE Year < 1980"
        ],
        "rule_sql": [
            "SELECT avg(Horsepower) FROM CARS_DATA WHERE Year < 1980"
        ]
    },
    "136": {
        "db_id": "car_1",
        "question": "What is the average horsepower for all cars produced before 1980 ?",
        "ground_truth": "select avg(horsepower) from cars_data where year  <  1980;",
        "amends": [
            "Do reference table `cars_data` instead of `cars` in the FROM clause. Do use filter condition `year < 1980` instead of `year >= 1980` in the WHERE clause, changing the comparison operator and threshold value to select pre-1980 vehicles rather than post-1980 ones. The amended query now correctly calculates the average horsepower for cars manufactured before 1980, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"average horsepower for all cars produced before 1980\": make sure the output order: AVG(horsepower).",
            "When the question mentions \"cars\": \"cars\" actually means \"cars_data\" in schema.",
            "When answering about \"average horsepower for all cars produced before 1980\", When the question mentions \"cars\", When the question mentions \"before 1980\": use filter condition year < 1980 to select pre-1980 vehicles."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(horsepower) FROM cars WHERE year >= 1980;",
            "SELECT AVG(Horsepower) FROM cars_data WHERE Year < 1980"
        ],
        "rule_sql": [
            "SELECT AVG(Horsepower) FROM cars_data WHERE Year < 1980"
        ]
    },
    "137": {
        "db_id": "car_1",
        "question": "What is the average edispl of the cars of model volvo?",
        "ground_truth": "SELECT avg(T2.edispl) FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T1.Model  =  'volvo';",
        "amends": [
            "Do join `CAR_NAMES AS T1` to `CARS_DATA AS T2` on `T1.MakeId = T2.Id` instead of querying only the `cars` table. Do reference `T2.edispl` in the `AVG` function instead of just `edispl`. Do filter on `T1.Model = 'volvo'` instead of `model = 'volvo'` to correctly associate the model name with the appropriate table. The amended query now properly joins the necessary tables to match the model name with engine displacement data, ensuring accurate results."
        ],
        "rules": [
            "When answering about \"average edispl of cars of model volvo\": make sure the output order: AVG(T2.edispl)",
            "When the question mentions \"model volvo\": \"model volvo\" actually means \"T1.Model = 'volvo'\" in schema",
            "When combining CAR_NAMES AS T1 and CARS_DATA AS T2 for shared entities: link rows where T1.MakeId = T2.Id exactly as shown in the amends; keep only matching pairs (inner match)",
            "When answering about \"average edispl of cars of model volvo\", When the question mentions \"model volvo\", When combining CAR_NAMES AS T1 and CARS_DATA AS T2 for shared entities, When computing average engine displacement: use T2.edispl as the exact column token for the average calculation"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(edispl) FROM cars WHERE model = 'volvo';",
            "SELECT AVG(T2.Edispl) \nFROM car_names AS T1 \nJOIN cars_data AS T2 ON T1.MakeId = T2.Id \nWHERE T1.Model = 'volvo'"
        ],
        "rule_sql": [
            "SELECT AVG(T2.edispl) FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id WHERE T1.Model = 'volvo'"
        ]
    },
    "138": {
        "db_id": "car_1",
        "question": "What is the average edispl for all volvos?",
        "ground_truth": "SELECT avg(T2.edispl) FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T1.Model  =  'volvo';",
        "amends": [
            "Do join `CAR_NAMES AS T1` and `CARS_DATA AS T2` on `T1.MakeId = T2.Id` instead of querying only the `cars` table. Do filter on `T1.Model = 'volvo'` instead of `make = 'Toyota'`. Do select `avg(T2.edispl)` with explicit table qualification instead of `AVG(edispl)` without table reference. The amended query now correctly joins the necessary tables and filters by model rather than make, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"average edispl for all volvos\": make sure the output order: avg(T2.edispl).",
            "When the question mentions \"volvos\": \"volvos\" actually means \"T1.Model = 'volvo'\" in schema.",
            "When combining CAR_NAMES AS T1 and CARS_DATA AS T2 for shared entities: link rows where T1.MakeId = T2.Id exactly as shown in the amends; keep only matching pairs (inner match).",
            "When answering about \"average edispl for all volvos\", When the question mentions \"volvos\", When combining CAR_NAMES AS T1 and CARS_DATA AS T2 for shared entities, When computing average edispl: use T2.edispl with explicit table qualification instead of unqualified edispl."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(edispl) FROM cars WHERE make = 'Toyota';",
            "SELECT AVG(T2.Edispl) FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id WHERE T1.Model = 'volvo'"
        ],
        "rule_sql": [
            "SELECT AVG(T2.edispl) FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id WHERE T1.Model = 'volvo'"
        ]
    },
    "139": {
        "db_id": "car_1",
        "question": "What is the maximum accelerate for different number of cylinders?",
        "ground_truth": "SELECT max(Accelerate) ,  Cylinders FROM CARS_DATA GROUP BY Cylinders;",
        "amends": [
            "Do use column name `Accelerate` instead of `acceleration` and place it as the first argument to `MAX` instead of second. Do use column name `Cylinders` instead of `cylinders` and place it as the second column instead of first in the SELECT list. Do reference table `CARS_DATA` instead of `cars` in the FROM clause. The amended query now correctly retrieves the maximum acceleration grouped by cylinders from the specified table."
        ],
        "rules": [
            "When answering about maximum acceleration for different number of cylinders: make sure the output order is Accelerate first, then Cylinders.",
            "When the question mentions \"acceleration\": \"acceleration\" actually means \"Accelerate\" in schema.",
            "When the question mentions \"cylinders\": \"cylinders\" actually means \"Cylinders\" in schema.",
            "When the question asks for maximum acceleration per cylinders: organize results by Cylinders and compute maximum Accelerate per group.",
            "When answering about maximum acceleration for different number of cylinders, When the question mentions \"acceleration\", When the question mentions \"cylinders\", When the question asks for maximum acceleration per cylinders, When referencing the table: use table name CARS_DATA exactly as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT cylinders, MAX(acceleration) FROM cars GROUP BY cylinders;",
            "SELECT MAX(Accelerate) AS MaxAccelerate, Cylinders FROM cars_data GROUP BY Cylinders"
        ],
        "rule_sql": [
            "SELECT MAX(Accelerate) AS MaxAccelerate, Cylinders FROM cars_data GROUP BY Cylinders ORDER BY MaxAccelerate, Cylinders;"
        ]
    },
    "140": {
        "db_id": "car_1",
        "question": "What is the maximum accelerate for all the different cylinders?",
        "ground_truth": "SELECT max(Accelerate) ,  Cylinders FROM CARS_DATA GROUP BY Cylinders;",
        "amends": [
            "Do use `max(Accelerate)` with proper capitalization instead of `MAX(accelerate)` with lowercase column reference. Do place `Cylinders` in the SELECT list after the aggregate function instead of before it. Do reference the table as `CARS_DATA` instead of `cars` to match the correct table name. Do maintain the same GROUP BY logic with `Cylinders` instead of `cylinders` for consistent column naming. The amended query now correctly calculates maximum acceleration grouped by cylinder count using the proper table and column references."
        ],
        "rules": [
            "When the question asks for maximum acceleration grouped by cylinders: use max(Accelerate) with exact capitalization and group by Cylinders with exact capitalization.",
            "When referencing the table: use CARS_DATA as the exact table name instead of cars.",
            "When ordering output columns: place the aggregate function max(Accelerate) before the grouping column Cylinders in the SELECT list.",
            "When the question asks for maximum acceleration grouped by cylinders, When referencing the table, When ordering output columns, When handling column references: maintain consistent capitalization with Cylinders (not cylinders) and Accelerate (not accelerate) throughout the query."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT cylinders, MAX(accelerate) FROM cars GROUP BY cylinders;",
            "SELECT max(Accelerate), Cylinders FROM cars_data GROUP BY Cylinders"
        ],
        "rule_sql": [
            "SELECT max(Accelerate), Cylinders FROM CARS_DATA GROUP BY Cylinders"
        ]
    },
    "141": {
        "db_id": "car_1",
        "question": "Which model has the most version(make) of cars?",
        "ground_truth": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;",
        "amends": [
            "Do reference the table as `CAR_NAMES` instead of `cars` and use the column name `Model` instead of `model` in both the SELECT list and GROUP BY clause. Do remove the explicit `COUNT(*) as version_count` column from the SELECT list instead of including it, and instead rely on the aggregate function directly in the ORDER BY clause. Do order by `count(*) DESC` instead of ordering by the alias `version_count DESC`. The amended query now correctly identifies the most frequent model from the CAR_NAMES table while matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When referencing the table for car information: use the exact table name \"CAR_NAMES\" instead of \"cars\".",
            "When selecting and grouping by car model: use the exact column name \"Model\" with proper case instead of \"model\".",
            "When counting versions/makes of cars: count all rows using count(*) but do not include this count column in the final output.",
            "When ordering results to find the model with most versions: order by count(*) in descending direction.",
            "When referencing the table for car information, When selecting and grouping by car model, When counting versions/makes of cars, When ordering results to find the model with most versions, When limiting to the top result: take only the first row after ordering by count(*) descending."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT model, COUNT(*) as version_count FROM cars GROUP BY model ORDER BY version_count DESC LIMIT 1;",
            "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "142": {
        "db_id": "car_1",
        "question": "What model has the most different versions?",
        "ground_truth": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;",
        "amends": [
            "Do select `Model` instead of `model, COUNT(*) as version_count` to return only the model column without aggregation. Do use table `CAR_NAMES` instead of `car_models` as the data source. Do remove the explicit count aggregation and alias from the SELECT list instead of including them. Do maintain the GROUP BY on `Model` instead of `model` but with proper case. Do keep the ORDER BY `count(*) DESC` instead of `version_count DESC` to sort by the implicit count without an alias. Do preserve the LIMIT 1 instead of changing it. The amended query now correctly returns the most frequent model from the CAR_NAMES table by counting occurrences per model and selecting the top result."
        ],
        "rules": [
            "When answering about \"model has the most different versions\": make sure the output order: only the \"Model\" column without any count aggregation.",
            "When the question mentions \"model\": \"model\" actually means \"Model\" in schema from table \"CAR_NAMES\".",
            "When the question asks for \"most different versions\": count the number of occurrences per \"Model\" and keep only the top 1 result.",
            "When counting versions: compute the number of rows using the implicit count of \"Model\" occurrences without an alias.",
            "When answering about \"model has the most different versions\", When the question mentions \"model\", When the question asks for \"most different versions\", When counting versions, When ranking for \"most\": sort rows by the count in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT model, COUNT(*) as version_count FROM car_models GROUP BY model ORDER BY version_count DESC LIMIT 1;",
            "SELECT Model FROM car_names GROUP BY Model ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Model FROM car_names GROUP BY Model ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "143": {
        "db_id": "car_1",
        "question": "How many cars have more than 4 cylinders?",
        "ground_truth": "SELECT count(*) FROM CARS_DATA WHERE Cylinders  >  4;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` in the FROM clause. Do change the WHERE filter to `Cylinders > 4` instead of `cylinders <= 4`, effectively counting vehicles with more than 4 cylinders rather than 4 or fewer cylinders. The amended query now correctly matches the RIGHT_SQL's behavior by counting high-cylinder vehicles."
        ],
        "rules": [
            "When referencing the cars table: use the exact table name \"CARS_DATA\" as specified in the schema.",
            "When filtering for vehicles with more than 4 cylinders: use the condition \"Cylinders > 4\" to count only rows where the Cylinders column value is strictly greater than 4.",
            "When referencing the cars table, When filtering for vehicles with more than 4 cylinders, When counting cars: use the COUNT(*) function to count all rows that satisfy the specified condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE cylinders <= 4;",
            "SELECT COUNT(*) FROM cars_data WHERE Cylinders > 4"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM CARS_DATA WHERE Cylinders > 4"
        ]
    },
    "144": {
        "db_id": "car_1",
        "question": "What is the number of cars with more than 4 cylinders?",
        "ground_truth": "SELECT count(*) FROM CARS_DATA WHERE Cylinders  >  4;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` in the FROM clause. Do use filter condition `Cylinders > 4` instead of `cylinders <= 4` in the WHERE clause, changing both the column name case and the inequality direction. The amended query now correctly counts records with more than 4 cylinders from the CARS_DATA table instead of counting those with 4 or fewer cylinders from a differently named table."
        ],
        "rules": [
            "When referencing the cars table: use the exact table name \"CARS_DATA\" with double quotes and proper case as shown in the schema.",
            "When filtering for cars with more than 4 cylinders: use the condition \"Cylinders\" > 4 with the exact column name case and inequality direction.",
            "When referencing the cars table, When filtering for cars with more than 4 cylinders, When counting cars: count all rows from \"CARS_DATA\" that satisfy the cylinder condition rather than counting rows with 4 or fewer cylinders."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE cylinders <= 4;",
            "SELECT COUNT(*) FROM cars_data WHERE Cylinders > 4"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM \"cars_data\" WHERE \"Cylinders\" > 4"
        ]
    },
    "145": {
        "db_id": "car_1",
        "question": "how many cars were produced in 1980?",
        "ground_truth": "SELECT count(*) FROM CARS_DATA WHERE YEAR  =  1980;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` to correctly access the source data table. Do maintain the same filter condition `YEAR = 1980` to count records from the specified year. The amended query now correctly counts records from the appropriate data source table while preserving the same filtering logic and aggregation behavior."
        ],
        "rules": [
            "When answering about \"how many cars were produced in 1980\": use table \"CARS_DATA\" instead of \"cars\" to access the correct data source.",
            "When filtering for records from year 1980: apply the condition YEAR = 1980 to select only records from that specific year.",
            "When answering about \"how many cars were produced in 1980\", When filtering for records from year 1980, When counting the number of cars produced: count all records that satisfy the year condition using the appropriate counting method."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE year = 1980;",
            "SELECT COUNT(*) FROM cars_data WHERE Year = 1980;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM cars_data WHERE Year = 1980;"
        ]
    },
    "146": {
        "db_id": "car_1",
        "question": "In 1980, how many cars were made?",
        "ground_truth": "SELECT count(*) FROM CARS_DATA WHERE YEAR  =  1980;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` to correctly access the source data. Do maintain the same filter condition `YEAR = 1980` and aggregate function `count(*)` as they remain functionally identical. The amended query now correctly counts records from the appropriate table while preserving the same filtering logic and aggregation behavior."
        ],
        "rules": [
            "When answering about \"how many cars were made in 1980\": use the exact table name \"CARS_DATA\" instead of \"cars\" to access the source data.",
            "When filtering for year 1980: apply the exact condition YEAR = 1980 to select only records from that specific year.",
            "When answering about \"how many cars were made in 1980\", When filtering for year 1980, When counting the number of cars: use count(*) to count all records that satisfy the year condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE year = 1980;",
            "SELECT COUNT(*) FROM cars_data WHERE Year = 1980;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM CARS_DATA WHERE Year = 1980;"
        ]
    },
    "147": {
        "db_id": "car_1",
        "question": "How many car models were produced by the maker with full name American Motor Company?",
        "ground_truth": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker WHERE T1.FullName  =  'American Motor Company';",
        "amends": [
            "Do add `JOIN MODEL_LIST AS T2 ON T1.Id = T2.Maker` instead of querying only the `car_makers` table. Do use table alias `T1` for `CAR_MAKERS` instead of referencing the table directly. Do reference `T1.FullName` instead of `full_name` to match the proper column casing. The amended query now correctly joins the model list table to count models from American Motor Company instead of just counting the manufacturer itself, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"car models produced by a maker\": make sure to join CAR_MAKERS (as T1) with MODEL_LIST (as T2) using the exact key equality T1.Id = T2.Maker.",
            "When the question mentions \"car models\": \"car models\" actually means \"rows in MODEL_LIST table\".",
            "When the question asks for \"count of car models\": compute the number of rows using the canonical key from MODEL_LIST.",
            "When the question specifies \"maker with full name American Motor Company\": use the exact literal 'American Motor Company' with T1.FullName column.",
            "When answering about \"car models produced by a maker\", When the question mentions \"car models\", When the question asks for \"count of car models\", When the question specifies \"maker with full name American Motor Company\", When combining T1 and T2 for shared entities: link rows where T1.Id = T2.Maker exactly as shown in the amends; keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM car_makers WHERE full_name = 'American Motor Company';",
            "SELECT COUNT(*) FROM car_makers AS T1 JOIN model_list AS T2 ON T1.Id = T2.Maker WHERE T1.FullName = 'American Motor Company'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nWHERE T1.FullName = 'American Motor Company'"
        ]
    },
    "148": {
        "db_id": "car_1",
        "question": "What is the number of car models created by the car maker American Motor Company?",
        "ground_truth": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker WHERE T1.FullName  =  'American Motor Company';",
        "amends": [
            "Do add `JOIN MODEL_LIST AS T2 ON T1.Id = T2.Maker` instead of querying only the `car_makers` table. Do change the filter to `T1.FullName = 'American Motor Company'` instead of `maker = 'American Motor Company'` to use the correct column name for the full company name. The amended query now correctly joins the model list table and filters by the proper full name column, matching the RIGHT_SQL's behavior of counting models from American Motor Company rather than just counting the maker entry itself."
        ],
        "rules": [
            "When answering about \"number of car models created by a car maker\": join the car_makers table (T1) with the MODEL_LIST table (T2) using T1.Id = T2.Maker to link models to their makers.",
            "When the question mentions \"American Motor Company\": use the exact literal 'American Motor Company' and filter on T1.FullName = 'American Motor Company' to identify the correct car maker.",
            "When answering about \"number of car models created by a car maker\", When the question mentions \"American Motor Company\", When counting car models for a specific maker: count the number of rows in the joined result where T1.FullName matches the specified maker name, as this represents the count of models associated with that maker."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM car_makers WHERE maker = 'American Motor Company';",
            "SELECT COUNT(*) AS model_count\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nWHERE T1.FullName = 'American Motor Company'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS number_of_models\nFROM car_makers cm\nJOIN model_list ml ON cm.Id = ml.Maker\nWHERE cm.FullName = 'American Motor Company'"
        ]
    },
    "149": {
        "db_id": "car_1",
        "question": "Which makers designed more than 3 car models? List full name and the id.",
        "ground_truth": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;",
        "amends": [
            "Do join `MODEL_LIST` as `T2` on `T1.Id = T2.Maker` instead of querying only `car_makers` without any join. Do use `T1.FullName` and `T1.Id` instead of `maker_name` and `maker_id`. Do move the count filter to `HAVING count(*) > 3` instead of incorrectly placing `COUNT(model_id) > 3` in the `WHERE` clause. Do add proper table aliases with `AS T1` and `AS T2` instead of omitting them. The amended query now correctly counts models per maker and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"makers designed more than 3 car models\": make sure the output order: T1.FullName, T1.Id",
            "When combining car_makers (T1) and MODEL_LIST (T2) for shared entities: link rows where T1.Id = T2.Maker exactly as shown in the amends; keep only matching pairs (inner match)",
            "When the question asks for \"count of car models per maker\": compute the number of rows using the grouping by T1.Id and count models per group",
            "When filtering for makers with more than 3 models: apply the count filter after grouping using count(*) > 3 instead of in the WHERE clause",
            "When answering about \"makers designed more than 3 car models\", When combining car_makers (T1) and MODEL_LIST (T2) for shared entities, When the question asks for \"count of car models per maker\", When filtering for makers with more than 3 models, When selecting maker information: use T1.FullName and T1.Id instead of maker_name and maker_id as these are the exact column tokens from the schema"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT maker_name, maker_id FROM car_makers WHERE COUNT(model_id) > 3 GROUP BY maker_id;",
            "SELECT T1.FullName, T1.Id\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id, T1.FullName\nHAVING COUNT(*) > 3"
        ],
        "rule_sql": [
            "SELECT T1.FullName, T1.Id\nFROM car_makers T1\nINNER JOIN model_list T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id, T1.FullName\nHAVING COUNT(*) > 3\nORDER BY T1.FullName, T1.Id"
        ]
    },
    "150": {
        "db_id": "car_1",
        "question": "What are the names and ids of all makers with more than 3 models?",
        "ground_truth": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;",
        "amends": [
            "Do select `T1.FullName` and `T1.Id` instead of `maker_id` and `maker_name`. Do use `FROM CAR_MAKERS AS T1` joined with `MODEL_LIST AS T2` on `T1.Id = T2.Maker` instead of querying only the `makers` table. Do add `GROUP BY T1.Id` and move the count filter to `HAVING count(*) > 3` instead of using `WHERE model_count > 3` without grouping. The amended query now correctly counts models per maker and filters makers with more than 3 models, matching the intended behavior.",
            "Do maintain the same column selection `T1.Id, T1.FullName` instead of changing the order. Do keep the identical `FROM car_makers AS T1 JOIN model_list AS T2 ON T1.Id = T2.Maker` join structure instead of altering any join logic. Do preserve the exact `GROUP BY T1.Id` grouping and `HAVING COUNT(*) > 3` aggregation filter instead of modifying the grouping or filtering logic. The amended query now matches RIGHT_SQL's behavior with identical logical execution despite minor formatting differences.",
            "Do maintain the same column selection `T1.Id, T1.FullName` instead of changing the order. Do keep the same table aliases `AS T1` and `AS T2` instead of modifying them. Do preserve the identical join condition `T1.Id = T2.Maker` instead of altering the relationship. Do retain the same grouping `GROUP BY T1.Id` instead of modifying the grouping criteria. Do continue using the same aggregate condition `HAVING COUNT(*) > 3` instead of changing the threshold. The amended query now correctly matches the RIGHT_SQL's behavior with identical logic and output.",
            "Do maintain the same column selection `T1.Id, T1.FullName` instead of changing it. Do keep the same table sources `car_makers AS T1` and `model_list AS T2` with the same join type `JOIN` and identical join condition `T1.Id = T2.Maker` instead of altering them. Do preserve the identical `GROUP BY T1.Id` clause and `HAVING COUNT(*) > 3` condition instead of modifying them. The amended query now matches RIGHT_SQL's behavior as there are no substantive differences between the queries beyond potential case sensitivity in table names which should be ignored per the instructions.",
            "Do maintain the same column selection order with `T1.FullName, T1.Id` instead of `T1.Id, T1.FullName` to match the RIGHT_SQL's output format. Do preserve the identical join logic with `JOIN model_list AS T2 ON T1.Id = T2.Maker` as both queries use the same join condition and table relationships. Do keep the same grouping with `GROUP BY T1.Id` and identical aggregation condition `HAVING COUNT(*) > 3` to filter for makers with more than three models. The amended query now matches RIGHT_SQL's behavior with only the column order adjustment."
        ],
        "rules": [
            "When answering about \"names and ids of all makers with more than 3 models\": make sure the output order: T1.FullName, T1.Id.",
            "When the question mentions \"makers\": \"makers\" actually means \"CAR_MAKERS AS T1\" in schema.",
            "When the question mentions \"models\": \"models\" actually means \"MODEL_LIST AS T2\" in schema.",
            "When combining T1 and T2 for shared entities: link rows where T1.Id = T2.Maker; keep only matching pairs (inner match).",
            "When the question asks for \"count of models per maker\": compute the number of rows using T2.Maker as the grouping key and count per group.",
            "When answering about \"names and ids of all makers with more than 3 models\", When the question mentions \"makers\", When the question mentions \"models\", When combining T1 and T2 for shared entities, When the question asks for \"count of models per maker\", When the question asks for \"more than 3 models\": filter groups where count(*) > 3 using HAVING clause after grouping.",
            "When answering about \"names and ids of all makers with more than 3 models\": make sure the output order: T1.Id, T1.FullName",
            "When combining car_makers and model_list tables: link rows where T1.Id = T2.Maker and keep only matching pairs (inner match)",
            "When grouping by maker: organize results by T1.Id and compute requested aggregates per group",
            "When answering about \"names and ids of all makers with more than 3 models\", When combining car_makers and model_list tables, When grouping by maker, When counting models per maker: compute the number of rows using the join relationship and filter for makers with COUNT(*) > 3",
            "When counting models per maker: use the exact join condition T1.Id = T2.Maker to link car_makers and model_list tables.",
            "When grouping by maker: use T1.Id as the grouping key instead of other identifiers.",
            "When filtering for makers with more than 3 models: apply the condition COUNT(*) > 3 exactly as specified.",
            "When selecting output columns: maintain the exact order T1.Id, T1.FullName without reordering.",
            "When counting models per maker, When grouping by maker, When filtering for makers with more than 3 models, When selecting output columns, When using table aliases: preserve T1 for car_makers and T2 for model_list without swapping or modifying them.",
            "When counting models per maker: use the canonical key T1.Id for grouping and count all rows in the joined result using COUNT(*)",
            "When filtering for makers with more than 3 models: apply the condition COUNT(*) > 3 in the grouping filter",
            "When selecting output columns for makers: include both T1.Id and T1.FullName to show the maker's identifier and name",
            "When counting models per maker, When filtering for makers with more than 3 models, When selecting output columns for makers, When combining car_makers and model_list tables: link rows where T1.Id = T2.Maker using an inner join to match makers with their models",
            "When answering about \"names and ids of all makers with more than 3 models\": make sure the output order: T1.FullName, T1.Id",
            "When combining car_makers as T1 and model_list as T2: link rows where T1.Id = T2.Maker exactly as shown in the amends; keep only matching pairs (inner match)",
            "When answering about \"names and ids of all makers with more than 3 models\", When combining car_makers as T1 and model_list as T2, When the question asks for \"makers with more than 3 models\": organize results by T1.Id and compute COUNT(*) per group, then filter for groups where COUNT(*) > 3"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT maker_id, maker_name FROM makers WHERE model_count > 3;",
            "SELECT T1.Id, T1.FullName\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id\nHAVING COUNT(*) > 3",
            "SELECT T1.Id, T1.FullName\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id\nHAVING COUNT(*) > 3",
            "SELECT T1.Id, T1.FullName\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id\nHAVING COUNT(*) > 3",
            "SELECT T1.Id, T1.FullName\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id\nHAVING COUNT(*) > 3",
            "SELECT T1.FullName, T1.Id\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id\nHAVING COUNT(*) > 3"
        ],
        "rule_sql": [
            "SELECT T1.FullName, T1.Id\nFROM car_makers AS T1\nINNER JOIN model_list AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id\nHAVING COUNT(*) > 3\nORDER BY T1.FullName, T1.Id"
        ]
    },
    "151": {
        "db_id": "car_1",
        "question": "Which distinctive models are produced by maker with the full name General Motors or weighing more than 3500?",
        "ground_truth": "SELECT DISTINCT T2.Model FROM CAR_NAMES AS T1 JOIN MODEL_LIST AS T2 ON T1.Model  =  T2.Model JOIN CAR_MAKERS AS T3 ON T2.Maker  =  T3.Id JOIN CARS_DATA AS T4 ON T1.MakeId  =  T4.Id WHERE T3.FullName  =  'General Motors' OR T4.weight  >  3500;",
        "amends": [
            "Do use explicit table joins with `CAR_NAMES AS T1 JOIN MODEL_LIST AS T2` instead of querying a single undefined table. Do reference specific columns `T2.Model` instead of the ambiguous `model`. Do add proper join conditions `ON T1.Model = T2.Model` and `ON T2.Maker = T3.Id` and `ON T1.MakeId = T4.Id` instead of missing table relationships. Do filter by `T3.FullName = 'General Motors'` instead of the incorrect `maker` reference. Do use `T4.weight > 3500` instead of the unqualified `weight` column. The amended query now correctly joins multiple tables and qualifies all column references to match the intended logic."
        ],
        "rules": [
            "When answering about \"distinctive models\": make sure the output order: T2.Model",
            "When the question mentions \"maker with the full name General Motors\": \"maker\" actually means \"T3.FullName in schema\" and filter using T3.FullName = 'General Motors'",
            "When the question mentions \"weighing more than 3500\": \"weighing\" actually means \"T4.weight in schema\" and filter using T4.weight > 3500",
            "When combining tables for shared entities: link rows where T1.Model = T2.Model and T2.Maker = T3.Id and T1.MakeId = T4.Id; keep only matching pairs (inner match)",
            "When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms",
            "When answering about \"distinctive models\", When the question mentions \"maker with the full name General Motors\", When the question mentions \"weighing more than 3500\", When combining tables for shared entities, When choosing identifier delimiters, When handling text literals: do not change case, spacing, or punctuation of 'General Motors'"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT model FROM cars WHERE maker = 'General Motors' OR weight > 3500;",
            "SELECT DISTINCT T2.Model \nFROM car_names AS T1 \nJOIN model_list AS T2 ON T1.Model = T2.Model \nJOIN car_makers AS T3 ON T2.Maker = T3.Id \nJOIN cars_data AS T4 ON T1.MakeId = T4.Id \nWHERE T3.FullName = 'General Motors' OR T4.Weight > 3500"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.Model\nFROM car_names T1\nJOIN model_list T2 ON T1.Model = T2.Model\nJOIN car_makers T3 ON T2.Maker = T3.Id\nJOIN cars_data T4 ON T1.MakeId = T4.Id\nWHERE T3.FullName = 'General Motors' OR T4.Weight > 3500\nORDER BY T2.Model"
        ]
    },
    "152": {
        "db_id": "car_1",
        "question": "What are the different models created by either the car maker General Motors or weighed more than 3500?",
        "ground_truth": "SELECT DISTINCT T2.Model FROM CAR_NAMES AS T1 JOIN MODEL_LIST AS T2 ON T1.Model  =  T2.Model JOIN CAR_MAKERS AS T3 ON T2.Maker  =  T3.Id JOIN CARS_DATA AS T4 ON T1.MakeId  =  T4.Id WHERE T3.FullName  =  'General Motors' OR T4.weight  >  3500;",
        "amends": [
            "Do use explicit table aliases `T2.Model` instead of ambiguous `model`. Do add `DISTINCT` to eliminate duplicates instead of omitting it. Do join multiple tables `CAR_NAMES AS T1`, `MODEL_LIST AS T2`, `CAR_MAKERS AS T3`, and `CARS_DATA AS T4` instead of querying a single `cars` table. Do use proper join conditions `T1.Model = T2.Model`, `T2.Maker = T3.Id`, and `T1.MakeId = T4.Id` instead of simple column references. Do filter on `T3.FullName = 'General Motors'` instead of `maker = 'General Motors'` to use the correct table relationship. Do maintain the weight filter `T4.weight > 3500` but reference it through the proper table join. The amended query now correctly handles the multi-table relationships and returns distinct models as specified in the RIGHT_SQL."
        ],
        "rules": [
            "When answering about \"different models\": make sure to eliminate duplicates by using DISTINCT on T2.Model.",
            "When the question mentions \"car maker General Motors\": \"General Motors\" actually means T3.FullName = 'General Motors' in the schema.",
            "When the question mentions \"weighed more than 3500\": this means T4.weight > 3500 in the schema.",
            "When combining multiple tables for this query: link rows where T1.Model = T2.Model, T2.Maker = T3.Id, and T1.MakeId = T4.Id; keep only matching pairs (inner match).",
            "When answering about \"different models\", When the question mentions \"car maker General Motors\", When the question mentions \"weighed more than 3500\", When combining multiple tables for this query, When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table aliases T1, T2, T3, T4."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT model FROM cars WHERE maker = 'General Motors' OR weight > 3500",
            "SELECT DISTINCT T2.Model\nFROM CAR_NAMES AS T1\nJOIN MODEL_LIST AS T2 ON T1.Model = T2.Model\nJOIN CAR_MAKERS AS T3 ON T2.Maker = T3.Id\nLEFT JOIN CARS_DATA AS T4 ON T1.MakeId = T4.Id\nWHERE T3.FullName = 'General Motors' OR T4.Weight > 3500"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.Model\nFROM car_names T1\nJOIN model_list T2 ON T1.Model = T2.Model\nJOIN car_makers T3 ON T2.Maker = T3.Id\nJOIN cars_data T4 ON T1.MakeId = T4.Id\nWHERE T3.FullName = 'General Motors' OR T4.Weight > 3500"
        ]
    },
    "153": {
        "db_id": "car_1",
        "question": "In which years cars were produced weighing no less than 3000 and no more than 4000 ?",
        "ground_truth": "select distinct year from cars_data where weight between 3000 and 4000;",
        "amends": [
            "Do use `distinct` for unique years instead of omitting it. Do reference table `cars_data` instead of `cars`. Do apply filter `weight between 3000 and 4000` instead of `weight < 3000 OR weight > 4000` to select cars within the weight range rather than outside it. The amended query now correctly returns distinct years from the cars_data table for vehicles weighing between 3000 and 4000 pounds."
        ],
        "rules": [
            "When answering about \"years cars were produced weighing no less than 3000 and no more than 4000\": make sure the output order: year.",
            "When the question asks for distinct years: compute the number of unique values of the exact token \"year\".",
            "When the question mentions \"cars\": \"cars\" actually means \"cars_data\" in schema.",
            "When answering about \"years cars were produced weighing no less than 3000 and no more than 4000\", When the question asks for distinct years, When the question mentions \"cars\", When filtering by weight between 3000 and 4000: apply the condition weight between 3000 and 4000 inclusive to select vehicles within the specified weight range rather than outside it."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year FROM cars WHERE weight < 3000 OR weight > 4000;",
            "SELECT DISTINCT Year FROM cars_data WHERE Weight BETWEEN 3000 AND 4000 ORDER BY Year;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Year FROM cars_data WHERE Weight BETWEEN 3000 AND 4000 ORDER BY Year;"
        ]
    },
    "154": {
        "db_id": "car_1",
        "question": "What are the different years in which there were cars produced that weighed less than 4000 and also cars that weighted more than 3000 ?",
        "ground_truth": "select distinct year from cars_data where weight between 3000 and 4000;",
        "amends": [
            "Do reference table `cars_data` instead of `cars` to access the correct data source. Do use `BETWEEN 3000 AND 4000` instead of `weight < 4000 OR weight > 3000` to properly filter for weights within the specified range rather than excluding them. The amended query now correctly returns distinct years for cars with weights between 3000 and 4000, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"different years in which there were cars produced that weighed less than 4000 and also cars that weighed more than 3000\": make sure the output order: year.",
            "When the question mentions \"cars\": \"cars\" actually means \"cars_data\" in schema.",
            "When filtering for weights that are both less than 4000 and more than 3000: use weight values between 3000 and 4000 inclusive (3000 \u2264 weight \u2264 4000).",
            "When answering about \"different years in which there were cars produced that weighed less than 4000 and also cars that weighed more than 3000\", When the question mentions \"cars\", When filtering for weights that are both less than 4000 and more than 3000, When selecting distinct years: return only unique year values from the filtered results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT year FROM cars WHERE weight < 4000 OR weight > 3000;",
            "SELECT DISTINCT Year FROM cars_data WHERE Weight BETWEEN 3000 AND 4000 ORDER BY Year;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Year FROM cars_data WHERE Weight BETWEEN 3000 AND 4000 ORDER BY Year;"
        ]
    },
    "155": {
        "db_id": "car_1",
        "question": "What is the horsepower of the car with the largest accelerate?",
        "ground_truth": "SELECT T1.horsepower FROM CARS_DATA AS T1 ORDER BY T1.accelerate DESC LIMIT 1;",
        "amends": [
            "Do qualify the column reference as `T1.horsepower` instead of the unqualified `horsepower`, and do add the table alias `AS T1` to the `FROM CARS_DATA` clause instead of omitting it, while maintaining the same `ORDER BY accelerate DESC LIMIT 1` structure. The amended query now correctly references columns with explicit table qualification and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"horsepower of the car with the largest accelerate\": make sure the output order: T1.horsepower.",
            "When the question mentions \"largest accelerate\": rank rows by accelerate in descending direction and keep the first 1 row.",
            "When choosing identifier delimiters: do not replace unquoted forms with double quotes or backticks for columns like horsepower and accelerate.",
            "When answering about \"horsepower of the car with the largest accelerate\", When the question mentions \"largest accelerate\", When choosing identifier delimiters, When referring to table roles: use the alias T1 for the CARS_DATA table as shown in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT horsepower FROM cars ORDER BY accelerate DESC LIMIT 1;",
            "SELECT T1.Horsepower FROM cars_data AS T1 ORDER BY T1.Accelerate DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Horsepower FROM cars_data T1 ORDER BY T1.Accelerate DESC LIMIT 1"
        ]
    },
    "156": {
        "db_id": "car_1",
        "question": "What is the horsepower of the car with the greatest accelerate?",
        "ground_truth": "SELECT T1.horsepower FROM CARS_DATA AS T1 ORDER BY T1.accelerate DESC LIMIT 1;",
        "amends": [
            "Do qualify the column reference as `T1.horsepower` instead of the unqualified `horsepower`, and do add the table alias `T1` in the `FROM` clause instead of omitting it, specifying `CARS_DATA AS T1` instead of just `cars`."
        ],
        "rules": [
            "When answering about \"horsepower of the car with the greatest accelerate\": make sure the output order: T1.horsepower.",
            "When the question mentions \"cars\": \"cars\" actually means \"CARS_DATA in schema\".",
            "When the question mentions \"greatest accelerate\": rank rows by accelerate in descending direction and keep the first 1 row.",
            "When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms.",
            "When answering about \"horsepower of the car with the greatest accelerate\", When the question mentions \"cars\", When the question mentions \"greatest accelerate\", When choosing identifier delimiters, When referring to table roles: do not rename or swap the alias T1 once set for this schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT horsepower FROM cars ORDER BY accelerate DESC LIMIT 1;",
            "SELECT T1.horsepower FROM cars_data AS T1 ORDER BY T1.Accelerate DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT \"Horsepower\" FROM \"cars_data\" ORDER BY \"Accelerate\" DESC LIMIT 1"
        ]
    },
    "157": {
        "db_id": "car_1",
        "question": "For model volvo, how many cylinders does the car with the least accelerate have?",
        "ground_truth": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;",
        "amends": [
            "Do add `CAR_NAMES AS T2` table with `JOIN` instead of querying only `cars` table. Do use `ON T1.Id = T2.MakeId` join condition instead of no join. Do reference `T2.Model` in the WHERE filter instead of `model`. Do qualify columns with table aliases `T1.cylinders` and `T1.accelerate` instead of unqualified column names. The amended query now correctly joins the necessary tables to access the model information and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"model volvo\": use \"T2.Model\" = 'volvo' instead of \"model\" for filtering.",
            "When combining cars and CAR_NAMES tables: link rows where T1.Id = T2.MakeId and keep only matching pairs (inner match).",
            "When the question asks for \"car with the least accelerate\": rank rows by T1.accelerate in ascending order and keep the first 1 row.",
            "When answering about \"model volvo\", When combining cars and CAR_NAMES tables, When the question asks for \"car with the least accelerate\", When producing output: include T1.cylinders as the result column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT cylinders FROM cars WHERE model = 'volvo' ORDER BY accelerate ASC LIMIT 1;",
            "SELECT T1.Cylinders \nFROM cars_data AS T1\nJOIN car_names AS T2 ON T1.Id = T2.MakeId\nWHERE T2.Model = 'volvo'\nORDER BY T1.Accelerate ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Cylinders \nFROM cars_data T1\nINNER JOIN car_names T2 ON T1.Id = T2.MakeId\nINNER JOIN model_list T3 ON T2.Model = T3.Model\nWHERE T3.Model = 'volvo'\nORDER BY T1.Accelerate ASC\nLIMIT 1"
        ]
    },
    "158": {
        "db_id": "car_1",
        "question": "For a volvo model, how many cylinders does the version with least accelerate have?",
        "ground_truth": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;",
        "amends": [
            "Do join `CAR_NAMES AS T2` on `T1.Id = T2.MakeId` instead of querying only the `cars` table. Do filter on `T2.Model = 'volvo'` instead of `make = 'Volvo'`. Do reference `T1.cylinders` and `T1.accelerate` with table aliases instead of unqualified column names. The amended query now correctly joins the necessary tables and filters on the appropriate column to match the intended behavior."
        ],
        "rules": [
            "When the question mentions \"volvo model\": filter on T2.Model = 'volvo' exactly as specified (case-sensitive).",
            "When combining cars and CAR_NAMES tables: link rows where T1.Id = T2.MakeId exactly as shown and keep only matching pairs (inner match).",
            "When the question asks for the version with least accelerate: order rows by T1.accelerate in ascending order and keep only the first row.",
            "When the question mentions \"volvo model\", When combining cars and CAR_NAMES tables, When the question asks for the version with least accelerate, When answering about cylinders for a specific car: output T1.cylinders as the result column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT cylinders FROM cars WHERE make = 'Volvo' ORDER BY accelerate ASC LIMIT 1;",
            "SELECT T1.Cylinders \nFROM cars_data AS T1\nJOIN car_names AS T2 ON T1.Id = T2.MakeId\nWHERE T2.Model = 'volvo'\nORDER BY T1.Accelerate ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Cylinders \nFROM cars_data T1 \nINNER JOIN car_names T2 ON T1.Id = T2.MakeId \nWHERE T2.Model = 'volvo' \nORDER BY T1.Accelerate ASC \nLIMIT 1"
        ]
    },
    "159": {
        "db_id": "car_1",
        "question": "How many cars have a larger accelerate than the car with the largest horsepower?",
        "ground_truth": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );",
        "amends": [
            "Do reference the correct table name `CARS_DATA` instead of `cars` in both the main query and subquery. Do use the column `Accelerate` instead of `horsepower` in the WHERE filter condition. Do change the subquery logic to select `Accelerate` ordered by `Horsepower DESC` with `LIMIT 1` instead of using `MAX(horsepower)` aggregate function. The amended query now correctly counts records where acceleration exceeds the acceleration value from the car with the highest horsepower, matching the intended behavior."
        ],
        "rules": [
            "When referencing the cars table: use the exact table name \"CARS_DATA\" instead of \"cars\".",
            "When comparing acceleration values: use the column \"Accelerate\" for the comparison condition.",
            "When finding the car with the largest horsepower: select the \"Accelerate\" value from the row with the highest \"Horsepower\" by ordering by \"Horsepower DESC\" and taking the first result, rather than using MAX aggregate on horsepower.",
            "When referencing the cars table, When comparing acceleration values, When finding the car with the largest horsepower, When counting cars with larger acceleration: count records where \"Accelerate\" is greater than the acceleration value from the car with the highest horsepower."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM cars \nWHERE accelerate > (SELECT MAX(horsepower) FROM cars);",
            "SELECT COUNT(*) \nFROM CARS_DATA \nWHERE Accelerate > (\n    SELECT Accelerate \n    FROM CARS_DATA \n    ORDER BY Horsepower DESC \n    LIMIT 1\n)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM CARS_DATA \nWHERE Accelerate > (\n    SELECT Accelerate \n    FROM CARS_DATA \n    ORDER BY CAST(Horsepower AS NUMERIC) DESC \n    LIMIT 1\n)"
        ]
    },
    "160": {
        "db_id": "car_1",
        "question": "What is the number of cars with a greater accelerate than the one with the most horsepower?",
        "ground_truth": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );",
        "amends": [
            "Do reference the correct table name `CARS_DATA` instead of `cars`. Do use the column `Accelerate` in the outer query filter instead of `accelerate`. Do change the subquery to select `Accelerate` instead of `MAX(horsepower)` and use `ORDER BY Horsepower DESC LIMIT 1` instead of an aggregate function to find the maximum value. The amended query now correctly counts records where acceleration exceeds the acceleration value from the car with the highest horsepower, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When referencing the cars data table: use the exact table name \"CARS_DATA\" instead of \"cars\".",
            "When filtering by acceleration: use the exact column name \"Accelerate\" with proper case.",
            "When finding the car with the most horsepower: use \"ORDER BY Horsepower DESC LIMIT 1\" to get the single row with maximum horsepower rather than an aggregate function.",
            "When comparing acceleration values: compare the \"Accelerate\" column value against the \"Accelerate\" value from the car with highest horsepower.",
            "When referencing the cars data table, When filtering by acceleration, When finding the car with the most horsepower, When comparing acceleration values, When counting cars: count all rows from \"CARS_DATA\" where the acceleration condition is satisfied."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM cars \nWHERE accelerate > (SELECT MAX(horsepower) FROM cars)",
            "SELECT COUNT(*) \nFROM CARS_DATA \nWHERE Accelerate > (\n    SELECT Accelerate \n    FROM CARS_DATA \n    ORDER BY Horsepower DESC \n    LIMIT 1\n)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate > (SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1);"
        ]
    },
    "161": {
        "db_id": "car_1",
        "question": "How many countries has more than 2 car makers ?",
        "ground_truth": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2",
        "amends": [
            "Do join `car_makers` as `t2` on `t1.countryid=t2.country` instead of querying only the `countries` table. Do add `GROUP BY t1.countryid` instead of aggregating without grouping. Do move the count filter to `HAVING count(*) > 2` instead of using `WHERE car_makers > 2` which incorrectly references a column that doesn't exist in the countries table. The amended query now correctly counts car makers per country and filters for countries with more than 2 car makers, matching the intended behavior.",
            "Do remove the subquery wrapper instead of keeping it, as the outer COUNT(*) was incorrectly counting the grouped rows rather than the actual country count. Do maintain the same `JOIN` on `t1.CountryId=t2.Country` instead of changing it. Do preserve the `GROUP BY t1.CountryId` and `HAVING COUNT(*) > 2` clauses instead of modifying them. The amended query now correctly counts countries with more than 2 car makers by eliminating the redundant subquery structure."
        ],
        "rules": [
            "When answering about \"countries with more than 2 car makers\": make sure to join table \"car_makers\" as \"t2\" with table \"countries\" as \"t1\" where \"t1.countryid\" equals \"t2.country\".",
            "When counting car makers per country: group the results by \"t1.countryid\" and count using the canonical key from the car_makers table.",
            "When answering about \"countries with more than 2 car makers\", When counting car makers per country, When filtering for countries with more than 2 car makers: apply the condition \"count(*) > 2\" in the HAVING clause instead of using WHERE with a non-existent column.",
            "When counting countries with more than 2 car makers: use the canonical key \"t1.CountryId\" for counting countries instead of counting grouped rows.",
            "When combining countries and car_makers tables: link rows where \"t1.CountryId = t2.Country\" exactly as shown and keep only matching pairs (inner match).",
            "When grouping by country: organize results by \"t1.CountryId\" and compute the count of car makers per country.",
            "When filtering for countries with more than 2 car makers: apply the condition \"COUNT(*) > 2\" to the grouped results.",
            "When counting countries with more than 2 car makers, When combining countries and car_makers tables, When grouping by country, When filtering for countries with more than 2 car makers, When the question asks \"how many countries\": count the distinct country identifiers that satisfy the condition of having more than 2 car makers."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE car_makers > 2;",
            "SELECT COUNT(*) \nFROM (\n    SELECT t1.CountryId\n    FROM countries t1\n    JOIN car_makers t2 ON t1.CountryId = t2.Country\n    GROUP BY t1.CountryId\n    HAVING COUNT(*) > 2\n)",
            "SELECT COUNT(*) \nFROM countries t1 \nJOIN car_makers t2 ON t1.CountryId = t2.Country \nGROUP BY t1.CountryId \nHAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM (\n    SELECT t1.CountryId\n    FROM countries t1\n    JOIN car_makers t2 ON t1.CountryId = t2.Country\n    GROUP BY t1.CountryId\n    HAVING COUNT(*) > 2\n)"
        ]
    },
    "162": {
        "db_id": "car_1",
        "question": "What is the number of countries with more than 2 car makers ?",
        "ground_truth": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2",
        "amends": [
            "Do join `car_makers` as `t2` on `t1.countryid = t2.country` instead of querying only the `countries` table. Do add `GROUP BY t1.countryid` instead of omitting grouping. Do move the count filter to `HAVING count(*) > 2` instead of using `WHERE car_makers > 2` which incorrectly references a column name rather than an aggregate result. The amended query now correctly counts car makers per country and filters for countries with more than 2 car makers, matching the intended behavior.",
            "Do remove the subquery wrapper instead of keeping it, as the outer `COUNT(*)` over the grouped results was incorrectly counting groups rather than individual countries. Do maintain the `JOIN` between `countries` and `car_makers` on `t1.CountryId = t2.Country` instead of changing the join condition. Do preserve the `GROUP BY t1.CountryId` and `HAVING COUNT(*) > 2` to filter for countries with more than two car makers, instead of altering the grouping or filtering logic. The amended query now correctly counts the number of countries that have more than two associated car makers, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"number of countries with more than 2 car makers\": make sure to join the car_makers table as T2 with countries as T1 using the exact key equality T1.countryid = T2.country.",
            "When grouping by country to count car makers: organize results by T1.countryid and compute the count of car makers per country.",
            "When filtering for countries with more than 2 car makers: apply the condition count(*) > 2 after grouping instead of before grouping.",
            "When answering about \"number of countries with more than 2 car makers\", When grouping by country to count car makers, When filtering for countries with more than 2 car makers, When counting car makers per country: use the canonical counting approach by counting all rows in the car_makers table that match each country.",
            "When combining countries and car_makers tables: link rows where countries.CountryId equals car_makers.Country exactly as shown in the amends (t1.CountryId = t2.Country); keep only matching pairs (inner match).",
            "When grouping by country: organize results by t1.CountryId and compute aggregates per country group.",
            "When filtering for countries with more than 2 car makers: apply the condition COUNT(*) > 2 to filter country groups.",
            "When combining countries and car_makers tables, When grouping by country, When filtering for countries with more than 2 car makers, When counting the number of countries that satisfy the condition: compute the count of distinct t1.CountryId values that meet the filtering criteria."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE car_makers > 2;",
            "SELECT COUNT(*) \nFROM (\n    SELECT t1.CountryId \n    FROM countries t1 \n    JOIN car_makers t2 ON t1.CountryId = t2.Country \n    GROUP BY t1.CountryId \n    HAVING COUNT(*) > 2\n)",
            "SELECT COUNT(*) \nFROM countries t1 \nJOIN car_makers t2 ON t1.CountryId = t2.Country \nGROUP BY t1.CountryId \nHAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS NumberOfCountries\nFROM (\n    SELECT t1.CountryId\n    FROM countries t1\n    INNER JOIN car_makers t2 ON t1.CountryId = t2.Country\n    GROUP BY t1.CountryId\n    HAVING COUNT(*) > 2\n)"
        ]
    },
    "163": {
        "db_id": "car_1",
        "question": "How many cars has over 6 cylinders?",
        "ground_truth": "SELECT COUNT(*) FROM CARS_DATA WHERE Cylinders  >  6;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` and do filter on `Cylinders > 6` instead of `cylinders <= 6`, changing both the table name and the filter condition to count vehicles with more than six cylinders rather than those with six or fewer. The amended query now correctly counts records from the CARS_DATA table where the Cylinders value exceeds six, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"cars with over 6 cylinders\": use table \"CARS_DATA\" instead of \"cars\".",
            "When filtering for vehicles with more than six cylinders: use condition \"Cylinders > 6\" instead of \"cylinders <= 6\".",
            "When answering about \"cars with over 6 cylinders\", When filtering for vehicles with more than six cylinders, When counting records from the CARS_DATA table: count all rows where the Cylinders value exceeds six."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE cylinders <= 6;",
            "SELECT COUNT(*) FROM cars_data WHERE Cylinders > 6"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM cars_data WHERE Cylinders > 6"
        ]
    },
    "164": {
        "db_id": "car_1",
        "question": "What is the number of carsw ith over 6 cylinders?",
        "ground_truth": "SELECT COUNT(*) FROM CARS_DATA WHERE Cylinders  >  6;",
        "amends": [
            "Do reference the `CARS_DATA` table instead of the `cars` table. Do use the correct column name `Cylinders` instead of `cylinders`. The amended query now correctly counts records from the CARS_DATA table where the Cylinders value exceeds 6, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"number of cars with over 6 cylinders\": make sure the output order: count of cars.",
            "When the question mentions \"cars\": \"cars\" actually means \"CARS_DATA\" in schema.",
            "When the question mentions \"cylinders\": \"cylinders\" actually means \"Cylinders\" in schema.",
            "When counting cars: compute the number of rows using the canonical key for cars (CARS_DATA table records).",
            "When answering about \"number of cars with over 6 cylinders\", When the question mentions \"cars\", When the question mentions \"cylinders\", When counting cars, When filtering for \"over 6 cylinders\": select records where Cylinders > 6."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE cylinders > 6;",
            "SELECT COUNT(*) FROM cars_data WHERE Cylinders > 6"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM cars_data WHERE Cylinders > 6"
        ]
    },
    "165": {
        "db_id": "car_1",
        "question": "For the cars with 4 cylinders, which model has the largest horsepower?",
        "ground_truth": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;",
        "amends": [
            "Do select `T1.Model` from the `CAR_NAMES` table instead of `model` from the `cars` table. Do join `CARS_DATA AS T2` with `ON T1.MakeId = T2.Id` instead of querying a single table. Do use `T2.Cylinders = 4` as the filter instead of `cylinders = 4`. Do order by `T2.horsepower DESC` instead of `horsepower ASC`. The amended query now correctly joins the car names with their corresponding data and sorts by descending horsepower to match the intended behavior."
        ],
        "rules": [
            "When answering about \"cars with 4 cylinders\": use T2.Cylinders = 4 as the filter condition.",
            "When joining CAR_NAMES and CARS_DATA tables: link rows where T1.MakeId = T2.Id and keep only matching pairs (inner match).",
            "When the question asks for \"largest horsepower\": rank rows by T2.horsepower in descending order and keep the first row.",
            "When answering about \"cars with 4 cylinders\", When joining CAR_NAMES and CARS_DATA tables, When the question asks for \"largest horsepower\", When selecting the model: output T1.Model from the CAR_NAMES table instead of model from the cars table."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model FROM cars WHERE cylinders = 4 ORDER BY horsepower ASC LIMIT 1;",
            "SELECT T1.Model \nFROM car_names AS T1\nJOIN cars_data AS T2 ON T1.MakeId = T2.Id\nWHERE T2.Cylinders = 4\nORDER BY T2.Horsepower DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Model\nFROM car_names T1\nINNER JOIN cars_data T2 ON T1.MakeId = T2.Id\nWHERE T2.Cylinders = 4\nORDER BY CAST(T2.Horsepower AS NUMERIC) DESC\nLIMIT 1;"
        ]
    },
    "166": {
        "db_id": "car_1",
        "question": "For all of the 4 cylinder cars, which model has the most horsepower?",
        "ground_truth": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;",
        "amends": [
            "Do select `T1.Model` instead of `model, MAX(horsepower)` and remove the aggregate function. Do use `FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2` instead of `FROM cars` and add the required table join. Do specify `ON T1.MakeId = T2.Id` instead of omitting the join condition. Do move the filter to `WHERE T2.Cylinders = 4` instead of keeping it in WHERE but change the table reference. Do remove `GROUP BY model` since no aggregation is needed. Do order by `T2.horsepower DESC` instead of `MAX(horsepower) DESC` to use the direct column value. The amended query now correctly retrieves the model with the highest horsepower among 4-cylinder cars by properly joining the necessary tables and eliminating the unnecessary aggregation."
        ],
        "rules": [
            "When answering about \"4 cylinder cars\": filter rows where T2.Cylinders = 4.",
            "When combining CAR_NAMES and CARS_DATA tables: link rows where T1.MakeId = T2.Id and keep only matching pairs (inner match).",
            "When the question asks for \"which model has the most horsepower\": select T1.Model and order by T2.horsepower DESC to find the highest value.",
            "When the question mentions \"model\": \"model\" actually means T1.Model in the schema.",
            "When the question mentions \"horsepower\": \"horsepower\" actually means T2.horsepower in the schema.",
            "When answering about \"4 cylinder cars\", When combining CAR_NAMES and CARS_DATA tables, When the question asks for \"which model has the most horsepower\", When the question mentions \"model\", When the question mentions \"horsepower\", When producing output: do not use aggregation functions like MAX() when the question asks for the model with the highest value, instead use direct column ordering."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model, MAX(horsepower) FROM cars WHERE cylinders = 4 GROUP BY model ORDER BY MAX(horsepower) DESC LIMIT 1;",
            "SELECT T1.Model\nFROM car_names AS T1\nJOIN cars_data AS T2 ON T1.MakeId = T2.Id\nWHERE T2.Cylinders = 4\nORDER BY T2.Horsepower DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Model FROM car_names T1 INNER JOIN cars_data T2 ON T1.MakeId = T2.Id WHERE T2.Cylinders = 4 ORDER BY CAST(T2.Horsepower AS NUMERIC) DESC LIMIT 1;"
        ]
    },
    "167": {
        "db_id": "car_1",
        "question": "Among the cars with more than lowest horsepower, which ones do not have more than 3 cylinders? List the car makeid and make name.",
        "ground_truth": "SELECT T2.MakeId ,  T2.Make FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Horsepower  >  (SELECT min(Horsepower) FROM CARS_DATA) AND T1.Cylinders  <=  3;",
        "amends": [
            "Do join `CAR_NAMES AS T2` on `T1.Id = T2.MakeId` instead of querying only the `cars` table. Do reference columns with table aliases `T1.Horsepower` and `T1.Cylinders` instead of unqualified column names. Do use the correct table name `CARS_DATA AS T1` instead of `cars`. Do include the `Make` column instead of `make_name`. The amended query now correctly joins the data and names tables with proper column references, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When querying about car makes: join table \"CARS_DATA AS T1\" with table \"CAR_NAMES AS T2\" where T1.Id equals T2.MakeId to get complete car information.",
            "When filtering cars by horsepower: compare T1.Horsepower to be greater than the minimum horsepower from all cars.",
            "When filtering by cylinder count: ensure T1.Cylinders is not more than 3 cylinders.",
            "When selecting output columns: include both T1.makeid and T2.Make (not make_name) in the results.",
            "When querying about car makes, When filtering cars by horsepower, When filtering by cylinder count, When selecting output columns, When referencing columns: always use table aliases T1 for CARS_DATA columns and T2 for CAR_NAMES columns with proper qualification."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT makeid, make_name \nFROM cars \nWHERE horsepower > (SELECT MIN(horsepower) FROM cars) \nAND cylinders <= 3;",
            "SELECT T2.MakeId, T2.Make \nFROM CARS_DATA AS T1 \nJOIN CAR_NAMES AS T2 ON T1.Id = T2.MakeId \nWHERE T1.Horsepower > (SELECT MIN(Horsepower) FROM CARS_DATA) \nAND T1.Cylinders <= 3"
        ],
        "rule_sql": [
            "SELECT T1.Id AS makeid, T2.Make \nFROM CARS_DATA AS T1 \nJOIN CAR_NAMES AS T2 ON T1.Id = T2.MakeId \nWHERE T1.Horsepower > (SELECT MIN(Horsepower) FROM CARS_DATA) \nAND T1.Cylinders <= 3"
        ]
    },
    "168": {
        "db_id": "car_1",
        "question": "Among the cars that do not have the minimum horsepower , what are the make ids and names of all those with less than 4 cylinders ?",
        "ground_truth": "select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  4;",
        "amends": [
            "Do select `makeid` and `make` from `car_names` instead of `make_id` and `name` from `cars`. Do join `cars_data` with `car_names` on `t1.id=t2.makeid` instead of querying a single table. Do filter on `horsepower > (subquery)` instead of `horsepower != (subquery)`. Do keep the `cylinders < 4` filter but apply it to `cars_data` instead of the original table. Do use table aliases `t1` and `t2` instead of no aliases. The amended query now correctly joins the two tables and uses the proper inequality comparison to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about cars that do not have minimum horsepower: use a subquery to find the minimum horsepower value from cars_data table",
            "When filtering for cars with less than 4 cylinders: apply the condition cylinders < 4 to the cars_data table (T1)",
            "When selecting make information: select makeid and make from car_names table (T2) instead of make_id and name from cars table",
            "When combining cars_data and car_names tables: link rows where T1.id = T2.makeid using inner join",
            "When filtering for cars that do not have minimum horsepower: use horsepower > (SELECT MIN(horsepower) FROM cars_data) instead of != comparison",
            "When answering about cars that do not have minimum horsepower, When filtering for cars with less than 4 cylinders, When selecting make information, When combining cars_data and car_names tables, When filtering for cars that do not have minimum horsepower, When using table aliases: refer to cars_data as T1 and car_names as T2"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT make_id, name FROM cars WHERE cylinders < 4 AND horsepower != (SELECT MIN(horsepower) FROM cars);",
            "SELECT t2.MakeId, t2.Make \nFROM cars_data t1 \nJOIN car_names t2 ON t1.Id = t2.MakeId \nWHERE t1.Horsepower > (SELECT MIN(Horsepower) FROM cars_data) \nAND t1.Cylinders < 4"
        ],
        "rule_sql": [
            "SELECT T2.MakeId, T2.Make \nFROM cars_data T1\nINNER JOIN car_names T2 ON T1.Id = T2.MakeId\nWHERE T1.Horsepower > (SELECT MIN(Horsepower) FROM cars_data)\nAND T1.Cylinders < 4"
        ]
    },
    "169": {
        "db_id": "car_1",
        "question": "What is the maximum miles per gallon of the car with 8 cylinders or produced before 1980 ?",
        "ground_truth": "select max(mpg) from cars_data where cylinders  =  8 or year  <  1980",
        "amends": [
            "Do reference table `cars_data` instead of `cars` to ensure querying the correct data source. The amended query now matches RIGHT_SQL's behavior by using the proper table name while maintaining the same aggregation and filtering logic."
        ],
        "rules": [
            "When answering about maximum miles per gallon: use the table \"cars_data\" instead of \"cars\" to ensure querying the correct data source.",
            "When filtering for cars with 8 cylinders or produced before 1980: apply the condition cylinders = 8 OR year < 1980 to select the appropriate rows.",
            "When answering about maximum miles per gallon, When filtering for cars with 8 cylinders or produced before 1980, When computing the maximum value: calculate the maximum of the mpg column from the filtered results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(mpg) FROM cars WHERE cylinders = 8 OR year < 1980;",
            "SELECT MAX(MPG) FROM cars_data WHERE Cylinders = 8 OR Year < 1980;"
        ],
        "rule_sql": [
            "SELECT MAX(MPG) FROM cars_data WHERE Cylinders = 8 OR Year < 1980;"
        ]
    },
    "170": {
        "db_id": "car_1",
        "question": "What is the maximum mpg of the cars that had 8 cylinders or that were produced before 1980 ?",
        "ground_truth": "select max(mpg) from cars_data where cylinders  =  8 or year  <  1980",
        "amends": [
            "Do reference table `cars_data` instead of `cars` to ensure querying the correct data source. The amended query now correctly accesses the intended table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about maximum mpg of cars: use table \"cars_data\" instead of \"cars\" to access the correct data source"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(mpg) FROM cars WHERE cylinders = 8 OR year < 1980;",
            "SELECT MAX(MPG) FROM cars_data WHERE Cylinders = 8 OR Year < 1980;"
        ],
        "rule_sql": [
            "SELECT MAX(MPG) FROM cars_data WHERE Cylinders = 8 OR Year < 1980;"
        ]
    },
    "171": {
        "db_id": "car_1",
        "question": "Which models are lighter than 3500 but not built by the 'Ford Motor Company'?",
        "ground_truth": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  3500 AND T4.FullName != 'Ford Motor Company';",
        "amends": [
            "Do use `DISTINCT T1.model` instead of `model` without distinct. Do join `MODEL_LIST AS T1`, `CAR_NAMES AS T2`, `CARS_DATA AS T3`, and `CAR_MAKERS AS T4` instead of querying only `cars`. Do use `ON T1.Model = T2.Model` and `ON T2.MakeId = T3.Id` and `ON T1.Maker = T4.Id` instead of no join conditions. Do filter with `T3.weight < 3500` instead of `weight < 3500`. Do use `T4.FullName != 'Ford Motor Company'` instead of `manufacturer = 'Ford Motor Company'` to exclude rather than include Ford vehicles. The amended query now correctly identifies distinct car models under 3500 pounds from manufacturers other than Ford Motor Company."
        ],
        "rules": [
            "When answering about \"models lighter than 3500 but not built by Ford Motor Company\": make sure the output order: T1.model",
            "When the question mentions \"models\": \"models\" actually means \"T1.model in schema\"",
            "When the question mentions \"lighter than 3500\": use T3.weight < 3500 as the filter condition",
            "When the question mentions \"not built by Ford Motor Company\": use T4.FullName != 'Ford Motor Company' to exclude Ford vehicles",
            "When combining multiple tables for this query: link T1 and T2 using T1.Model = T2.Model, link T2 and T3 using T2.MakeId = T3.Id, and link T1 and T4 using T1.Maker = T4.Id, keeping only matching pairs (inner match)",
            "When selecting distinct models: use DISTINCT T1.model to avoid duplicate model names",
            "When answering about \"models lighter than 3500 but not built by Ford Motor Company\", When the question mentions \"models\", When the question mentions \"lighter than 3500\", When the question mentions \"not built by Ford Motor Company\", When combining multiple tables for this query, When selecting distinct models, When handling the manufacturer name: preserve the exact literal 'Ford Motor Company' with the exact case and spacing"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT model FROM cars WHERE weight < 3500 AND manufacturer = 'Ford Motor Company';",
            "SELECT DISTINCT T1.Model\nFROM model_list AS T1\nJOIN car_names AS T2 ON T1.Model = T2.Model\nJOIN cars_data AS T3 ON T2.MakeId = T3.Id\nJOIN car_makers AS T4 ON T1.Maker = T4.Id\nWHERE T3.Weight < 3500\nAND T4.FullName != 'Ford Motor Company'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Model\nFROM model_list T1\nJOIN car_names T2 ON T1.Model = T2.Model\nJOIN cars_data T3 ON T2.MakeId = T3.Id\nJOIN car_makers T4 ON T1.Maker = T4.Id\nWHERE T3.Weight < 3500\nAND T4.FullName != 'Ford Motor Company'\nORDER BY T1.Model;"
        ]
    },
    "172": {
        "db_id": "car_1",
        "question": "What are the different models wthat are lighter than 3500 but were not built by the Ford Motor Company?",
        "ground_truth": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  3500 AND T4.FullName != 'Ford Motor Company';",
        "amends": [
            "Do use `DISTINCT T1.model` instead of just `model` to eliminate duplicates. Do join `MODEL_LIST AS T1`, `CAR_NAMES AS T2`, `CARS_DATA AS T3`, and `CAR_MAKERS AS T4` instead of querying only the `cars` table. Do use `JOIN CAR_NAMES AS T2 ON T1.Model = T2.Model` instead of no join condition. Do use `JOIN CARS_DATA AS T3 ON T2.MakeId = T3.Id` instead of no relationship. Do use `JOIN CAR_MAKERS AS T4 ON T1.Maker = T4.Id` instead of no manufacturer join. Do filter on `T3.weight < 3500` instead of just `weight < 3500` to reference the correct table. Do filter on `T4.FullName != 'Ford Motor Company'` instead of `manufacturer != 'Ford Motor Company'` to use the proper column name. The amended query now correctly joins multiple tables to establish proper relationships and returns distinct model names from the appropriate source table."
        ],
        "rules": [
            "When the question asks for \"different models\": use DISTINCT T1.model to eliminate duplicate model names.",
            "When combining tables for this query: link MODEL_LIST AS T1 to CAR_NAMES AS T2 using T1.Model = T2.Model, then link CAR_NAMES AS T2 to CARS_DATA AS T3 using T2.MakeId = T3.Id, then link MODEL_LIST AS T1 to CAR_MAKERS AS T4 using T1.Maker = T4.Id, keeping only matching pairs (inner match).",
            "When filtering for weight less than 3500: use T3.weight < 3500 to reference the correct table.",
            "When excluding Ford Motor Company: use T4.FullName != 'Ford Motor Company' with exact literal 'Ford Motor Company' to filter manufacturers.",
            "When the question asks for \"different models\", When combining tables for this query, When filtering for weight less than 3500, When excluding Ford Motor Company, When producing output: return only the distinct model names from T1.model."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT model FROM cars WHERE weight < 3500 AND manufacturer != 'Ford Motor Company';",
            "SELECT DISTINCT T1.Model \nFROM model_list AS T1\nJOIN car_names AS T2 ON T1.Model = T2.Model\nJOIN cars_data AS T3 ON T2.MakeId = T3.Id\nJOIN car_makers AS T4 ON T1.Maker = T4.Id\nWHERE T3.Weight < 3500 \nAND T4.FullName != 'Ford Motor Company'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Model\nFROM model_list AS T1\nINNER JOIN car_names AS T2 ON T1.Model = T2.Model\nINNER JOIN cars_data AS T3 ON T2.MakeId = T3.Id\nINNER JOIN car_makers AS T4 ON T1.Maker = T4.Id\nWHERE T3.Weight < 3500\nAND T4.FullName != 'Ford Motor Company';"
        ]
    },
    "173": {
        "db_id": "car_1",
        "question": "What are the name of the countries where there is not a single car maker?",
        "ground_truth": "SELECT CountryName FROM countries EXCEPT SELECT T1.CountryName FROM countries AS T1 JOIN CAR_MAKERS AS T2 ON T1.countryId  =  T2.Country;",
        "amends": [
            "Do reference `CountryName` instead of `name` in the SELECT list. Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do add table alias `T1` for the countries table instead of omitting it. Do join `countries AS T1` with `CAR_MAKERS AS T2` instead of using a subquery. Do use join condition `T1.countryId = T2.Country` instead of filtering by `country_id NOT IN`. Do remove the DISTINCT keyword from the subquery since EXCEPT handles deduplication automatically. The amended query now correctly identifies countries without car makers by using a proper join and set operation instead of a potentially problematic NOT IN subquery with NULL values."
        ],
        "rules": [
            "When answering about countries without car makers: use the exact column name \"CountryName\" from the countries table instead of \"name\".",
            "When combining countries and car_makers tables: link rows where T1.countryId = T2.Country to find matching pairs.",
            "When identifying countries without car makers: use EXCEPT set operation to find countries that don't have matching entries in car_makers, which automatically handles deduplication without needing DISTINCT.",
            "When referring to the countries table: use alias T1 consistently throughout the query.",
            "When answering about countries without car makers, When combining countries and car_makers tables, When identifying countries without car makers, When referring to the countries table, When referring to the car_makers table: use alias T2 consistently throughout the query."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM countries WHERE country_id NOT IN (SELECT DISTINCT country_id FROM car_makers);",
            "SELECT T1.CountryName\nFROM countries AS T1\nEXCEPT\nSELECT T1.CountryName\nFROM countries AS T1\nJOIN car_makers AS T2 ON T1.CountryId = T2.Country"
        ],
        "rule_sql": [
            "SELECT T1.CountryName FROM countries T1 EXCEPT SELECT T1.CountryName FROM countries T1 JOIN car_makers T2 ON T1.CountryId = T2.Country"
        ]
    },
    "174": {
        "db_id": "car_1",
        "question": "What are the names of the countries with no car makers?",
        "ground_truth": "SELECT CountryName FROM countries EXCEPT SELECT T1.CountryName FROM countries AS T1 JOIN CAR_MAKERS AS T2 ON T1.countryId  =  T2.Country;",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do reference `CountryName` instead of `name` in the SELECT list. Do add an explicit table alias `T1` for the countries table instead of using it without alias. Do include a `JOIN` between `countries AS T1` and `CAR_MAKERS AS T2` with the predicate `ON T1.countryId = T2.Country` instead of the subquery correlation. Do remove the `WHERE` clause with subquery entirely instead of keeping it. The amended query now correctly uses set semantics to find countries without car makers, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"countries with no car makers\": use EXCEPT set operation instead of NOT IN with a subquery.",
            "When selecting country names: use \"CountryName\" instead of \"name\" as the output column.",
            "When referencing the countries table: use explicit alias \"T1\" for the countries table.",
            "When combining countries and car makers tables: link rows where T1.countryId = T2.Country to find matching pairs.",
            "When answering about \"countries with no car makers\", When selecting country names, When referencing the countries table, When combining countries and car makers tables, When finding countries without car makers: use set semantics to exclude countries that have car makers from the full set of countries."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM countries WHERE country_id NOT IN (SELECT country_id FROM car_makers);",
            "SELECT T1.CountryName\nFROM countries AS T1\nLEFT JOIN car_makers AS T2 ON T1.CountryId = T2.Country\nWHERE T2.Country IS NULL"
        ],
        "rule_sql": [
            "SELECT T1.CountryName FROM countries T1\nEXCEPT\nSELECT T1.CountryName FROM countries T1\nJOIN car_makers T2 ON T1.CountryId = T2.Country"
        ]
    },
    "175": {
        "db_id": "car_1",
        "question": "Which are the car makers which produce at least 2 models and more than 3 car makers ? List the id and the maker .",
        "ground_truth": "select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  2 intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  3;",
        "amends": [
            "Do add `JOIN model_list as t2 on t1.id = t2.maker` instead of querying `car_makers` alone. Do change the filter to use `GROUP BY t1.id HAVING count(*) >= 2` instead of `WHERE models >= 2`. Do add a second query with `INTERSECT` that includes `JOIN car_names as t3 on t2.model = t3.model` and `HAVING count(*) > 3` instead of the incorrect `car_makers > 3` condition. Do use proper table aliases `t1` for `car_makers` instead of direct table references. The amended query now correctly finds car makers with at least 2 models and more than 3 car names, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about car makers with models and car names: combine car_makers as T1 with model_list as T2 where T1.id equals T2.maker, then combine with car_names as T3 where T2.model equals T3.model.",
            "When counting models per car maker: group by T1.id and count using T2.model to find makers with at least 2 models.",
            "When counting car names per car maker: group by T1.id and count using T3.model to find makers with more than 3 car names.",
            "When combining both conditions: use INTERSECT to find car makers that satisfy both the model count and car name count requirements.",
            "When answering about car makers with models and car names, When counting models per car maker, When counting car names per car maker, When combining both conditions, When selecting output: include T1.id and T1.maker for the final result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, maker FROM car_makers WHERE models >= 2 AND car_makers > 3;",
            "SELECT t1.Id, t1.Maker\nFROM car_makers t1\nJOIN model_list t2 ON t1.Id = t2.Maker\nGROUP BY t1.Id\nHAVING COUNT(*) >= 2\nINTERSECT\nSELECT t1.Id, t1.Maker\nFROM car_makers t1\nJOIN model_list t2 ON t1.Id = t2.Maker\nJOIN car_names t3 ON t2.Model = t3.Model\nGROUP BY t1.Id\nHAVING COUNT(*) > 3"
        ],
        "rule_sql": [
            "SELECT T1.Id, T1.Maker\nFROM car_makers T1\nJOIN model_list T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id, T1.Maker\nHAVING COUNT(T2.Model) >= 2\nINTERSECT\nSELECT T1.Id, T1.Maker\nFROM car_makers T1\nJOIN model_list T2 ON T1.Id = T2.Maker\nJOIN car_names T3 ON T2.Model = T3.Model\nGROUP BY T1.Id, T1.Maker\nHAVING COUNT(T3.Model) > 3;"
        ]
    },
    "176": {
        "db_id": "car_1",
        "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?",
        "ground_truth": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;",
        "amends": [
            "Do use `SELECT T1.Id, T1.Maker` instead of `SELECT maker, COUNT(*) as model_count`. Do join `MODEL_LIST AS T2` on `T1.Id = T2.Maker` instead of querying only `car_makers`. Do remove the `WHERE` clause and instead use `HAVING count(*) >= 2` after grouping by `T1.Id`. Do add a second query with `INTERSECT` that joins `CAR_NAMES AS T3` on `T2.model = T3.model` and uses `HAVING count(*) > 3` instead of the incorrect `cars_produced > 3` filter. Do use proper table aliases `T1`, `T2`, and `T3` instead of bare table names. The amended query now correctly finds makers with at least 2 models and more than 3 cars produced by using intersection of two properly joined queries."
        ],
        "rules": [
            "When answering about car makers that produce at least 2 models and make more than 3 cars: make sure the output order: T1.Id, T1.Maker.",
            "When the question asks for \"ids and makers of all car makers\": select T1.Id and T1.Maker from the car_makers table.",
            "When the question mentions \"produce at least 2 models\": join MODEL_LIST AS T2 on T1.Id = T2.Maker and use HAVING count(*) >= 2 after grouping by T1.Id.",
            "When the question mentions \"make more than 3 cars\": join CAR_NAMES AS T3 on T2.model = T3.model and use HAVING count(*) > 3 after grouping.",
            "When combining both conditions for car makers: use INTERSECT between the two queries to find makers satisfying both conditions.",
            "When using table aliases: use T1 for car_makers, T2 for MODEL_LIST, and T3 for CAR_NAMES consistently.",
            "When answering about car makers that produce at least 2 models and make more than 3 cars, When the question asks for \"ids and makers of all car makers\", When the question mentions \"produce at least 2 models\", When the question mentions \"make more than 3 cars\", When combining both conditions for car makers, When using table aliases, When joining tables: link car_makers to MODEL_LIST using T1.Id = T2.Maker, and link MODEL_LIST to CAR_NAMES using T2.model = T3.model."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT maker, COUNT(*) as model_count FROM car_makers WHERE model_count >= 2 AND cars_produced > 3 GROUP BY maker",
            "SELECT T1.Id, T1.Maker\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id\nHAVING COUNT(*) >= 2\nINTERSECT\nSELECT T1.Id, T1.Maker\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nJOIN car_names AS T3 ON T2.Model = T3.Model\nGROUP BY T1.Id\nHAVING COUNT(*) > 3"
        ],
        "rule_sql": [
            "SELECT T1.Id, T1.Maker\nFROM car_makers T1\nJOIN model_list T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id\nHAVING COUNT(*) >= 2\nINTERSECT\nSELECT T1.Id, T1.Maker\nFROM car_makers T1\nJOIN model_list T2 ON T1.Id = T2.Maker\nJOIN car_names T3 ON T2.Model = T3.Model\nGROUP BY T1.Id\nHAVING COUNT(*) > 3"
        ]
    },
    "177": {
        "db_id": "car_1",
        "question": "What are the id and names of the countries which have more than 3 car makers or produce the 'fiat' model?",
        "ground_truth": "SELECT T1.countryId ,  T1.CountryName FROM Countries AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country GROUP BY T1.countryId HAVING count(*)  >  3 UNION SELECT T1.countryId ,  T1.CountryName FROM Countries AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country JOIN MODEL_LIST AS T3 ON T2.Id  =  T3.Maker WHERE T3.Model  =  'fiat';",
        "amends": [
            "Do use explicit column references `T1.countryId` and `T1.CountryName` with table aliases instead of ambiguous `id` and `name`. Do join `CAR_MAKERS AS T2` on `T1.CountryId = T2.Country` instead of filtering on non-existent `car_makers` column. Do add `GROUP BY T1.countryId` and move the count condition to `HAVING count(*) > 3` instead of using `car_makers > 3`. Do add a second query with `UNION` that joins `MODEL_LIST AS T3` on `T2.Id = T3.Maker` with filter `T3.Model = 'fiat'` instead of the incorrect `model = 'fiat'` condition. The amended query now correctly finds countries with more than 3 car makers or containing the Fiat model, matching the intended behavior."
        ],
        "rules": [
            "When answering about countries with car makers: use explicit column references \"T1.countryId\" and \"T1.CountryName\" instead of ambiguous \"id\" and \"name\".",
            "When the question mentions \"more than 3 car makers\": join \"CAR_MAKERS AS T2\" on \"T1.CountryId = T2.Country\", group by \"T1.countryId\", and use having condition count(*) > 3.",
            "When the question mentions \"produce the 'fiat' model\": join \"MODEL_LIST AS T3\" on \"T2.Id = T3.Maker\" with filter \"T3.Model = 'fiat'\".",
            "When answering about countries with car makers, When the question mentions \"more than 3 car makers\", When the question mentions \"produce the 'fiat' model\", When combining conditions with \"or\": use UNION to combine results from both conditions (more than 3 car makers OR fiat model production)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, name FROM countries WHERE car_makers > 3 OR model = 'fiat';",
            "SELECT T1.CountryId, T1.CountryName \nFROM countries AS T1\nJOIN car_makers AS T2 ON T1.CountryId = T2.Country\nGROUP BY T1.CountryId\nHAVING COUNT(*) > 3\n\nUNION\n\nSELECT T1.CountryId, T1.CountryName \nFROM countries AS T1\nJOIN car_makers AS T2 ON T1.CountryId = T2.Country\nJOIN model_list AS T3 ON T2.Id = T3.Maker\nWHERE T3.Model = 'fiat'"
        ],
        "rule_sql": [
            "SELECT T1.CountryId, T1.CountryName\nFROM countries AS T1\nJOIN car_makers AS T2 ON T1.CountryId = T2.Country\nGROUP BY T1.CountryId, T1.CountryName\nHAVING COUNT(*) > 3\n\nUNION\n\nSELECT T1.CountryId, T1.CountryName\nFROM countries AS T1\nJOIN car_makers AS T2 ON T1.CountryId = T2.Country\nJOIN model_list AS T3 ON T2.Id = T3.Maker\nWHERE T3.Model = 'fiat'"
        ]
    },
    "178": {
        "db_id": "car_1",
        "question": "What are the ids and names of all countries that either have more than 3 car makers or produce fiat model ?",
        "ground_truth": "select t1.countryid ,  t1.countryname from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  3 union select t1.countryid ,  t1.countryname from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country join model_list as t3 on t2.id  =  t3.maker where t3.model  =  'fiat';",
        "amends": [
            "Do join `car_makers as t2` on `t1.countryid = t2.country` instead of querying `countries` table alone. Do add `GROUP BY t1.countryid` and move the count filter to `HAVING count(*) > 3` instead of using `WHERE car_makers_count > 3`. Do add a second query with `UNION` that joins `model_list as t3` on `t2.id = t3.maker` with filter `t3.model = 'fiat'` instead of the simple `OR model = 'fiat'` condition. Do use explicit table aliases `t1.countryid` and `t1.countryname` instead of bare column names `id` and `name`. The amended query now correctly counts car makers per country and handles the Fiat model condition through proper table joins and union operation."
        ],
        "rules": [
            "When answering about countries with car makers: join \"countries\" as T1 with \"car_makers\" as T2 where T1.countryid = T2.country to link countries to their car makers.",
            "When counting car makers per country: group results by T1.countryid and count using T2.id to get the number of car makers for each country.",
            "When filtering for countries with more than 3 car makers: use HAVING count(*) > 3 after grouping by T1.countryid.",
            "When answering about countries producing Fiat model: join \"car_makers\" as T2 with \"model_list\" as T3 where T2.id = T3.maker and filter for T3.model = 'fiat' exactly.",
            "When combining both conditions with OR: use UNION to combine results from the car maker count condition and the Fiat model condition.",
            "When answering about countries with car makers, When counting car makers per country, When filtering for countries with more than 3 car makers, When answering about countries producing Fiat model, When combining both conditions with OR, When selecting country information: use T1.countryid and T1.countryname as the exact output columns for country IDs and names."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, name FROM countries WHERE car_makers_count > 3 OR model = 'fiat'",
            "SELECT t1.CountryId, t1.CountryName\nFROM countries t1\nJOIN car_makers t2 ON t1.CountryId = t2.Country\nGROUP BY t1.CountryId\nHAVING COUNT(*) > 3\n\nUNION\n\nSELECT t1.CountryId, t1.CountryName\nFROM countries t1\nJOIN car_makers t2 ON t1.CountryId = t2.Country\nJOIN model_list t3 ON t2.Id = t3.Maker\nWHERE t3.Model = 'fiat'"
        ],
        "rule_sql": [
            "SELECT T1.CountryId, T1.CountryName\nFROM countries AS T1\nJOIN car_makers AS T2 ON T1.CountryId = T2.Country\nGROUP BY T1.CountryId\nHAVING COUNT(*) > 3\n\nUNION\n\nSELECT T1.CountryId, T1.CountryName\nFROM countries AS T1\nJOIN car_makers AS T2 ON T1.CountryId = T2.Country\nJOIN model_list AS T3 ON T2.Id = T3.Maker\nWHERE T3.Model = 'fiat'"
        ]
    },
    "179": {
        "db_id": "flight_2",
        "question": "Which country does Airline \"JetBlue Airways\" belong to?",
        "ground_truth": "SELECT Country FROM AIRLINES WHERE Airline  =  \"JetBlue Airways\"",
        "amends": [
            "Do reference the `Country` column instead of `country` to match the correct case sensitivity. Do reference the `Airline` column instead of `name` to use the proper column name for airline identification. Do use double quotes `\"JetBlue Airways\"` instead of single quotes `'JetBlue Airways'` for string literal formatting. The amended query now correctly retrieves the country information for JetBlue Airways by using the appropriate column names and string formatting."
        ],
        "rules": [
            "When the question asks about an airline's country: combine information from the flights table (T1) and airports table (T2) using their relationship keys.",
            "When identifying a specific airline by name: use the exact literal \"JetBlue Airways\" with double quotes for string matching.",
            "When selecting the country information: use the exact column name \"Country\" from the airports table (T2) with proper case sensitivity.",
            "When the question asks about an airline's country, When identifying a specific airline by name, When selecting the country information, When filtering for a specific airline: use the column \"Airline\" from the flights table (T1) to identify airlines, not a generic \"name\" column."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM airlines WHERE name = 'JetBlue Airways';",
            "SELECT Country FROM airlines WHERE Airline = \"JetBlue Airways\";"
        ],
        "rule_sql": [
            "SELECT DISTINCT a2.Country \nFROM airlines a1\nJOIN flights f ON a1.uid = f.Airline\nJOIN airports a2 ON f.SourceAirport = a2.AirportCode OR f.DestAirport = a2.AirportCode\nWHERE a1.Airline = \"JetBlue Airways\""
        ]
    },
    "180": {
        "db_id": "flight_2",
        "question": "What country is Jetblue Airways affiliated with?",
        "ground_truth": "SELECT Country FROM AIRLINES WHERE Airline  =  \"JetBlue Airways\"",
        "amends": [
            "Do reference the column `Country` instead of `country` to match the correct case sensitivity. Do reference the column `Airline` instead of `name` to use the proper column name for airline identification. Do use the exact string value `\"JetBlue Airways\"` instead of `'Jetblue Airways'` to match the correct capitalization and spelling. Do reference the table `AIRLINES` instead of `airlines` to maintain consistent uppercase table naming convention. The amended query now correctly retrieves the country for the specified airline with proper column references and exact string matching."
        ],
        "rules": [
            "When the question asks about airline affiliation with a country: use the exact table name \"AIRLINES\" with uppercase letters as shown in the schema.",
            "When identifying an airline by name: use the exact column name \"Airline\" instead of \"name\" to reference the proper airline identification column.",
            "When matching airline names: use the exact string literal \"JetBlue Airways\" with proper capitalization and spelling instead of \"Jetblue Airways\".",
            "When the question asks about airline affiliation with a country, When identifying an airline by name, When matching airline names, When retrieving country information: use the exact column name \"Country\" with proper case sensitivity instead of \"country\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM airlines WHERE name = 'Jetblue Airways';",
            "SELECT Country FROM AIRLINES WHERE Airline = 'JetBlue Airways';"
        ],
        "rule_sql": [
            "SELECT Country FROM AIRLINES WHERE Airline = 'JetBlue Airways';"
        ]
    },
    "181": {
        "db_id": "flight_2",
        "question": "What is the abbreviation of Airline \"JetBlue Airways\"?",
        "ground_truth": "SELECT Abbreviation FROM AIRLINES WHERE Airline  =  \"JetBlue Airways\"",
        "amends": [
            "Do reference the column `Abbreviation` instead of `abbreviation` to match the correct case sensitivity. Do reference the table `AIRLINES` instead of `Airlines` to match the correct table name case. Do use the filter condition `Airline = \"JetBlue Airways\"` instead of `name = 'JetBlue Airways'` to reference the correct column name and use double quotes instead of single quotes for the string literal. The amended query now correctly retrieves the abbreviation for JetBlue Airways by using the proper column and table names with appropriate case sensitivity and string quoting."
        ],
        "rules": [
            "When the question asks for abbreviation of an airline: use the exact column token \"Abbreviation\" from table \"AIRLINES\" with proper case sensitivity.",
            "When filtering for airline name \"JetBlue Airways\": use the exact column token \"Airline\" with double quotes around the literal value \"JetBlue Airways\".",
            "When the question asks for abbreviation of an airline, When filtering for airline name \"JetBlue Airways\", When referencing table names: use the exact table name \"AIRLINES\" with proper case sensitivity as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT abbreviation FROM Airlines WHERE name = 'JetBlue Airways';",
            "SELECT Abbreviation FROM AIRLINES WHERE Airline = \"JetBlue Airways\""
        ],
        "rule_sql": [
            "SELECT Abbreviation FROM AIRLINES WHERE Airline = \"JetBlue Airways\";"
        ]
    },
    "182": {
        "db_id": "flight_2",
        "question": "Which abbreviation corresponds to Jetblue Airways?",
        "ground_truth": "SELECT Abbreviation FROM AIRLINES WHERE Airline  =  \"JetBlue Airways\"",
        "amends": [
            "Do reference column `Abbreviation` instead of `abbreviation` to match the correct case sensitivity. Do reference column `Airline` instead of `name` to use the proper column name for airline identification. Do reference table `AIRLINES` instead of `airlines` to maintain consistent uppercase naming convention. Do use double quotes `\"JetBlue Airways\"` instead of single quotes for string literal consistency. The amended query now correctly retrieves the abbreviation by matching the airline name in the appropriate column with proper case handling."
        ],
        "rules": [
            "When the question asks for an abbreviation corresponding to an airline name: use column \"Abbreviation\" from table \"AIRLINES\" to retrieve the abbreviation.",
            "When matching airline names in the database: use column \"Airline\" with the exact literal value \"JetBlue Airways\" to identify the correct airline.",
            "When handling string literals for airline names: use double quotes around \"JetBlue Airways\" to maintain proper formatting and case sensitivity.",
            "When the question asks for an abbreviation corresponding to an airline name, When matching airline names in the database, When handling string literals for airline names, When referencing database objects: use uppercase table name \"AIRLINES\" instead of lowercase to match the schema's naming convention."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT abbreviation FROM airlines WHERE name = 'JetBlue Airways';",
            "SELECT Abbreviation FROM AIRLINES WHERE Airline = \"JetBlue Airways\";"
        ],
        "rule_sql": [
            "SELECT Abbreviation FROM AIRLINES WHERE Airline = \"JetBlue Airways\";"
        ]
    },
    "183": {
        "db_id": "flight_2",
        "question": "List all airline names and their abbreviations in \"USA\".",
        "ground_truth": "SELECT Airline ,  Abbreviation FROM AIRLINES WHERE Country  =  \"USA\"",
        "amends": [
            "Do use column aliases `Airline` and `Abbreviation` instead of the original column names `name` and `abbreviation`. Do reference the table name `AIRLINES` in uppercase instead of lowercase `airlines`. Do use double quotes `\"USA\"` for the string literal instead of single quotes `'USA'`. The amended query now correctly matches the RIGHT_SQL's behavior while maintaining the same logical result."
        ],
        "rules": [
            "When the question asks for airline names and abbreviations: use column aliases \"Airline\" and \"Abbreviation\" for the output columns.",
            "When referencing the airlines table: use the exact table name \"AIRLINES\" in uppercase.",
            "When filtering for country \"USA\": use double quotes around the literal value as \"USA\".",
            "When the question asks for airline names and abbreviations, When referencing the airlines table, When filtering for country \"USA\", When the question specifies \"in USA\": filter rows where the country column equals \"USA\" exactly."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, abbreviation FROM airlines WHERE country = 'USA';",
            "SELECT Airline, Abbreviation FROM AIRLINES WHERE Country = \"USA\""
        ],
        "rule_sql": [
            "SELECT Airline AS \"Airline\", Abbreviation AS \"Abbreviation\" FROM AIRLINES WHERE Country = \"USA\""
        ]
    },
    "184": {
        "db_id": "flight_2",
        "question": "What are the airline names and abbreviations for airlines in the USA?",
        "ground_truth": "SELECT Airline ,  Abbreviation FROM AIRLINES WHERE Country  =  \"USA\"",
        "amends": [
            "Do use column aliases `Airline` and `Abbreviation` instead of the original column names `airline_name` and `abbreviation`. Do reference the table as `AIRLINES` instead of `airlines`. Do filter with country value `\"USA\"` instead of `'United States'` to match the correct country code format. The amended query now correctly retrieves US airlines using the standardized country code and proper column naming conventions."
        ],
        "rules": [
            "When the question asks for airline names and abbreviations: use column aliases \"Airline\" and \"Abbreviation\" as the output columns.",
            "When referencing the airlines table: use the exact table name \"AIRLINES\" with proper case.",
            "When the question asks for airline names and abbreviations, When referencing the airlines table, When filtering for airlines in the USA: use the exact country value \"USA\" instead of 'United States' to match the standardized country code format."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airline_name, abbreviation FROM airlines WHERE country = 'United States';",
            "SELECT Airline, Abbreviation FROM AIRLINES WHERE Country = 'USA';"
        ],
        "rule_sql": [
            "SELECT Airline, Abbreviation FROM AIRLINES WHERE Country = 'USA'"
        ]
    },
    "185": {
        "db_id": "flight_2",
        "question": "List the airport code and name in the city of Anthony.",
        "ground_truth": "SELECT AirportCode ,  AirportName FROM AIRPORTS WHERE city  =  \"Anthony\"",
        "amends": [
            "Do use `AirportCode` and `AirportName` column names instead of `airport_code` and `airport_name` to match the actual schema. Do use double quotes `\"Anthony\"` for the string literal instead of single quotes `'Anthony'` to maintain proper string formatting. The amended query now correctly retrieves airport information for the specified city while matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for airport code and name: use the exact column names \"AirportCode\" and \"AirportName\" from the airports table.",
            "When filtering by city name \"Anthony\": use double quotes around the literal value as \"Anthony\" instead of single quotes.",
            "When the question asks for airport code and name, When filtering by city name \"Anthony\", When selecting from the airports table: ensure the output columns are ordered as \"AirportCode\" first, then \"AirportName\" to match the question's request order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airport_code, airport_name FROM airports WHERE city = 'Anthony';",
            "SELECT AirportCode, AirportName FROM airports WHERE City = \"Anthony\";"
        ],
        "rule_sql": [
            "SELECT AirportCode, AirportName FROM airports WHERE City = \"Anthony\";"
        ]
    },
    "186": {
        "db_id": "flight_2",
        "question": "Give the airport code and airport name corresonding to the city Anthony.",
        "ground_truth": "SELECT AirportCode ,  AirportName FROM AIRPORTS WHERE city  =  \"Anthony\"",
        "amends": [
            "Do use `AirportCode` and `AirportName` column names instead of `airport_code` and `airport_name` to match the actual schema. Do use double quotes `\"Anthony\"` for the string literal instead of single quotes `'Anthony'` to maintain proper string formatting. The amended query now correctly retrieves airport information for the specified city while using the proper column names and string syntax."
        ],
        "rules": [
            "When the question asks for airport code and airport name: use the exact column names \"AirportCode\" and \"AirportName\" from the airports table.",
            "When filtering by city name \"Anthony\": use double quotes around the literal value as \"Anthony\" to maintain proper string formatting.",
            "When the question asks for airport code and airport name, When filtering by city name \"Anthony\", When answering about airport information for a specific city: retrieve data from the airports table where the city column matches the exact specified value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airport_code, airport_name FROM airports WHERE city = 'Anthony';",
            "SELECT AirportCode, AirportName FROM airports WHERE City = \"Anthony\";"
        ],
        "rule_sql": [
            "SELECT AirportCode, AirportName FROM airports WHERE City = \"Anthony\";"
        ]
    },
    "187": {
        "db_id": "flight_2",
        "question": "How many airlines do we have?",
        "ground_truth": "SELECT count(*) FROM AIRLINES",
        "amends": [
            "Do reference the `AIRLINES` table instead of the `flights` table in the FROM clause. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the AIRLINES table instead of flights, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"how many airlines\": make sure to count records from the \"AIRLINES\" table instead of the \"flights\" table.",
            "When answering about \"how many airlines\", When counting entities: use lowercase \"count(*)\" for consistency with the schema requirements."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights;",
            "SELECT count(*) FROM airlines;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM airlines;"
        ]
    },
    "188": {
        "db_id": "flight_2",
        "question": "What is the total number of airlines?",
        "ground_truth": "SELECT count(*) FROM AIRLINES",
        "amends": [
            "Do query the `AIRLINES` table instead of the `flights` table. The amended query now correctly counts records from the AIRLINES table as intended."
        ],
        "rules": [
            "When answering about \"total number of airlines\": query the \"AIRLINES\" table instead of the \"flights\" table.",
            "When answering about \"total number of airlines\", When counting airlines: count records from the \"AIRLINES\" table using the canonical key for airlines."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights;",
            "SELECT COUNT(*) FROM airlines;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM airlines;"
        ]
    },
    "189": {
        "db_id": "flight_2",
        "question": "How many airports do we have?",
        "ground_truth": "SELECT count(*) FROM AIRPORTS",
        "amends": [
            "Do use the table name `AIRPORTS` instead of `airports` to match the correct case sensitivity, though this may be a cosmetic difference depending on database configuration. Do maintain the identical `COUNT(*)` aggregation and `WHERE country = 'USA'` filter without any changes to the SELECT list, FROM clause, WHERE conditions, or other query components. The amended query now matches RIGHT_SQL's behavior with proper table name casing.",
            "Do use lowercase `count(*)` instead of uppercase `COUNT(*)` to maintain consistent function casing. The amended query now matches RIGHT_SQL's behavior with identical functionality.",
            "Do include all airports without any country filter instead of filtering for `country = 'USA'`. The amended query now matches RIGHT_SQL's behavior by counting all records in the AIRPORTS table."
        ],
        "rules": [
            "When counting airports: use the exact table name \"AIRPORTS\" with uppercase letters as shown in the schema.",
            "When filtering for airports in the USA: use the exact literal value 'USA' with uppercase letters in the country column condition.",
            "When counting airports, When filtering for airports in the USA, When performing the count: use COUNT(*) to count all rows that match the specified conditions.",
            "When counting entities from a table: use lowercase count(*) function instead of uppercase COUNT(*) to maintain consistent function casing",
            "When answering about \"how many airports\": count all records in the \"AIRPORTS\" table without any country filter.",
            "When the question asks for \"count of airports\": compute the number of rows using all records from the \"AIRPORTS\" table.",
            "When answering about \"how many airports\", When the question asks for \"count of airports\", When handling text literals: do not include any country filter condition like 'country = \"USA\"' as the question does not specify any country restriction."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM airports WHERE country = 'USA';",
            "SELECT COUNT(*) FROM AIRPORTS WHERE country = 'USA';",
            "SELECT count(*) FROM AIRPORTS WHERE country = 'USA'",
            "SELECT count(*) FROM AIRPORTS"
        ],
        "rule_sql": [
            "SELECT count(*) FROM AIRPORTS;"
        ]
    },
    "190": {
        "db_id": "flight_2",
        "question": "Return the number of  airports.",
        "ground_truth": "SELECT count(*) FROM AIRPORTS",
        "amends": [
            "Do query the `AIRPORTS` table instead of the `flights` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` to match the correct query's formatting. The amended query now correctly counts records from the AIRPORTS table instead of flights, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"number of airports\": query the \"AIRPORTS\" table instead of the \"flights\" table.",
            "When answering about \"number of airports\", When counting records: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" to match the correct formatting."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights;",
            "SELECT count(*) FROM airports;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM airports;"
        ]
    },
    "191": {
        "db_id": "flight_2",
        "question": "How many flights do we have?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS",
        "amends": [
            "Do query the `FLIGHTS` table instead of the `passengers` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the FLIGHTS table instead of the passengers table, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"how many flights\": make sure to query the \"FLIGHTS\" table instead of the \"passengers\" table.",
            "When answering about \"how many flights\", When counting records: use lowercase \"count(*)\" for consistency with the schema requirements."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM passengers;",
            "SELECT count(*) FROM flights;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM flights;"
        ]
    },
    "192": {
        "db_id": "flight_2",
        "question": "Return the number of flights.",
        "ground_truth": "SELECT count(*) FROM FLIGHTS",
        "amends": [
            "Do query the `FLIGHTS` table instead of the `passengers` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency, though this is purely cosmetic. The amended query now correctly counts records from the FLIGHTS table instead of the passengers table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"number of flights\": query the \"FLIGHTS\" table instead of the \"passengers\" table.",
            "When answering about \"number of flights\", When counting flights: use lowercase \"count(*)\" to count all records from the \"FLIGHTS\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM passengers;",
            "SELECT count(*) FROM flights"
        ],
        "rule_sql": [
            "SELECT count(*) FROM flights;"
        ]
    },
    "193": {
        "db_id": "flight_2",
        "question": "Which airline has abbreviation 'UAL'?",
        "ground_truth": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  \"UAL\"",
        "amends": [
            "Do use the exact column name `Airline` instead of `name` to match the correct schema. Do use the exact table name `AIRLINES` instead of `airlines` to match the correct case sensitivity. Do use double quotes `\"UAL\"` instead of single quotes `'UAL'` for the string literal while maintaining the same filter condition. The amended query now correctly retrieves the airline name using the proper column and table identifiers while preserving the same filtering logic."
        ],
        "rules": [
            "When the question asks about airline abbreviation 'UAL': use the exact string literal \"UAL\" with double quotes for filtering.",
            "When retrieving airline information: use the exact table name \"AIRLINES\" with proper case sensitivity.",
            "When the question asks about airline abbreviation 'UAL', When retrieving airline information, When selecting the airline name: use the exact column name \"Airline\" instead of generic \"name\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM airlines WHERE abbreviation = 'UAL';",
            "SELECT Airline FROM AIRLINES WHERE Abbreviation = \"UAL\""
        ],
        "rule_sql": [
            "SELECT Airline FROM airlines WHERE Abbreviation = \"UAL\";"
        ]
    },
    "194": {
        "db_id": "flight_2",
        "question": "Give the airline with abbreviation 'UAL'.",
        "ground_truth": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  \"UAL\"",
        "amends": [
            "Do specify `Airline` column instead of `*` wildcard in the SELECT list. Do use table name `AIRLINES` instead of `airlines` with proper casing. Do use double quotes `\"UAL\"` instead of single quotes `'UAL'` for the string literal. Do maintain the same WHERE filter condition on `Abbreviation` column with proper casing instead of lowercase `abbreviation`. The amended query now correctly returns only the Airline column for United Airlines instead of all columns, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"airline with abbreviation 'UAL'\": make sure the output order: \"Airline\" column.",
            "When the question mentions \"airline with abbreviation 'UAL'\": use table name \"AIRLINES\" with proper casing.",
            "When filtering for abbreviation value: use double quotes \"UAL\" instead of single quotes for the string literal.",
            "When filtering on abbreviation column: use column name \"Abbreviation\" with proper casing instead of lowercase.",
            "When answering about \"airline with abbreviation 'UAL'\", When the question mentions \"airline with abbreviation 'UAL'\", When filtering for abbreviation value, When filtering on abbreviation column, When selecting columns: specify \"Airline\" column explicitly instead of using wildcard *."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM airlines WHERE abbreviation = 'UAL';",
            "SELECT Airline FROM AIRLINES WHERE Abbreviation = \"UAL\""
        ],
        "rule_sql": [
            "SELECT Airline FROM AIRLINES WHERE Abbreviation = \"UAL\""
        ]
    },
    "195": {
        "db_id": "flight_2",
        "question": "How many airlines are from USA?",
        "ground_truth": "SELECT count(*) FROM AIRLINES WHERE Country  =  \"USA\"",
        "amends": [
            "Do use `count(*)` instead of `COUNT(*)` for consistent lowercase function naming. Do reference table `AIRLINES` instead of `airlines` to match the correct table name case. Do filter on `Country = \"USA\"` instead of `country = 'United States'` to use the correct column name case and proper country code value with double quotes instead of single quotes. The amended query now correctly counts airlines from the United States using the standardized country code."
        ],
        "rules": [
            "When referencing the airlines table: use exact table name \"AIRLINES\" with uppercase letters.",
            "When counting airlines: use lowercase function \"count(*)\" instead of uppercase \"COUNT(*)\".",
            "When referencing the airlines table, When counting airlines, When filtering airlines by country: use column name \"Country\" with exact case and value \"USA\" with double quotes instead of 'United States'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM airlines WHERE country = 'United States';",
            "SELECT count(*) FROM AIRLINES WHERE Country = \"USA\""
        ],
        "rule_sql": [
            "SELECT count(*) FROM AIRLINES WHERE Country = \"USA\""
        ]
    },
    "196": {
        "db_id": "flight_2",
        "question": "Return the number of airlines in the USA.",
        "ground_truth": "SELECT count(*) FROM AIRLINES WHERE Country  =  \"USA\"",
        "amends": [
            "Do use `count(*)` instead of `COUNT(*)` for consistent lowercase function naming. Do reference table `AIRLINES` instead of `airlines` to match the actual table name case. Do filter on `Country = \"USA\"` instead of `country = 'United States'` to use the correct column name with proper capitalization and the standardized country code value instead of the full country name. The amended query now correctly counts airlines from the United States using the proper country code identifier."
        ],
        "rules": [
            "When answering about \"number of airlines in the USA\": use count(*) instead of COUNT(*) for consistent lowercase function naming.",
            "When referencing the airlines table: use AIRLINES instead of airlines to match the actual table name case.",
            "When answering about \"number of airlines in the USA\", When referencing the airlines table, When filtering for airlines from the United States: use Country = \"USA\" instead of country = 'United States' to use the correct column name with proper capitalization and the standardized country code value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM airlines WHERE country = 'United States';",
            "SELECT count(*) FROM AIRLINES WHERE Country = \"USA\""
        ],
        "rule_sql": [
            "SELECT count(*) FROM AIRLINES WHERE Country = \"USA\""
        ]
    },
    "197": {
        "db_id": "flight_2",
        "question": "Which city and country is the Alton airport at?",
        "ground_truth": "SELECT City ,  Country FROM AIRPORTS WHERE AirportName  =  \"Alton\"",
        "amends": [
            "Do use column aliases `City` and `Country` instead of the original column names `city` and `country`. Do reference the correct column name `AirportName` in the WHERE filter instead of `name`. Do use double quotes for the string literal \"Alton\" instead of single quotes. The amended query now correctly filters for airports with the specific name \"Alton\" and returns the properly aliased city and country columns, matching the intended behavior."
        ],
        "rules": [
            "When the question asks about airport location details: use the exact column names \"City\" and \"Country\" from the airports table.",
            "When filtering for a specific airport by name: use the exact column name \"AirportName\" and match the literal value \"Alton\" exactly with double quotes.",
            "When the question asks about airport location details, When filtering for a specific airport by name, When producing output columns: maintain the order City then Country as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, country FROM airports WHERE name = 'Alton';",
            "SELECT City AS City, Country AS Country FROM airports WHERE AirportName = \"Alton\""
        ],
        "rule_sql": [
            "SELECT City, Country FROM airports WHERE AirportName = \"Alton\";"
        ]
    },
    "198": {
        "db_id": "flight_2",
        "question": "Give the city and country for the Alton airport.",
        "ground_truth": "SELECT City ,  Country FROM AIRPORTS WHERE AirportName  =  \"Alton\"",
        "amends": [
            "Do use column aliases `City` and `Country` instead of lowercase `city` and `country`. Do reference the column `AirportName` in the WHERE filter instead of `name`. Do use double quotes around the string literal \"Alton\" instead of single quotes. The amended query now correctly matches the RIGHT_SQL's behavior by using the proper column names and string literal formatting."
        ],
        "rules": [
            "When the question asks for city and country information: use the exact column names \"City\" and \"Country\" with proper capitalization.",
            "When filtering for an airport by name: use the column \"AirportName\" instead of \"name\" to match the airport name.",
            "When the question asks for city and country information, When filtering for an airport by name, When specifying the literal value \"Alton\": use double quotes around the exact string literal \"Alton\" instead of single quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, country FROM airports WHERE name = 'Alton';",
            "SELECT City, Country FROM airports WHERE AirportName = \"Alton\""
        ],
        "rule_sql": [
            "SELECT City, Country FROM airports WHERE AirportName = \"Alton\";"
        ]
    },
    "199": {
        "db_id": "flight_2",
        "question": "What is the airport name for airport 'AKO'?",
        "ground_truth": "SELECT AirportName FROM AIRPORTS WHERE AirportCode  =  \"AKO\"",
        "amends": [
            "Do select `AirportName` instead of `name` and filter on `AirportCode` instead of `code`. Do use double quotes `\"AKO\"` instead of single quotes `'AKO'` for the string literal. The amended query now correctly references the actual column names and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for \"airport name\": use the exact column token \"AirportName\" from the airports table.",
            "When filtering for airport code 'AKO': use the exact column token \"AirportCode\" and the exact string literal \"AKO\" with double quotes.",
            "When the question asks for \"airport name\", When filtering for airport code 'AKO', When answering about airport information: make sure to select from the airports table only."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM airports WHERE code = 'AKO';",
            "SELECT AirportName FROM airports WHERE AirportCode = \"AKO\""
        ],
        "rule_sql": [
            "SELECT AirportName FROM airports WHERE AirportCode = \"AKO\";"
        ]
    },
    "200": {
        "db_id": "flight_2",
        "question": "Return the name of the airport with code 'AKO'.",
        "ground_truth": "SELECT AirportName FROM AIRPORTS WHERE AirportCode  =  \"AKO\"",
        "amends": [
            "Do select `AirportName` instead of `name` and filter on `AirportCode = \"AKO\"` instead of `code = 'DEN'`."
        ],
        "rules": [
            "When the question asks for the name of an airport: use the exact column token \"AirportName\" from the airports table.",
            "When filtering by airport code: use the exact literal value 'AKO' with the correct case and quotes as specified in the question.",
            "When the question asks for the name of an airport, When filtering by airport code, When the question specifies a particular airport code: filter using AirportCode = \"AKO\" to match exactly the requested code."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM airports WHERE code = 'DEN';",
            "SELECT AirportName FROM airports WHERE AirportCode = 'AKO';"
        ],
        "rule_sql": [
            "SELECT AirportName FROM airports WHERE AirportCode = 'AKO';"
        ]
    },
    "201": {
        "db_id": "flight_2",
        "question": "What are airport names at City 'Aberdeen'?",
        "ground_truth": "SELECT AirportName FROM AIRPORTS WHERE City = \"Aberdeen\"",
        "amends": [
            "Do reference `AirportName` instead of `name` in the SELECT list. Do reference `City` instead of `city` in the WHERE filter. Do use double quotes around 'Aberdeen' instead of single quotes. The amended query now correctly matches the RIGHT_SQL's behavior with proper column naming and string literal formatting."
        ],
        "rules": [
            "When the question asks for airport names: use the exact column token \"AirportName\" from the airports table.",
            "When filtering by city: use the exact column token \"City\" from the airports table.",
            "When the question asks for airport names, When filtering by city, When using the literal value 'Aberdeen': preserve the exact case and spacing as shown in the schema, and use double quotes around the literal value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM airports WHERE city = 'Aberdeen';",
            "SELECT AirportName FROM airports WHERE City = \"Aberdeen\""
        ],
        "rule_sql": [
            "SELECT AirportName FROM airports WHERE City = \"Aberdeen\";"
        ]
    },
    "202": {
        "db_id": "flight_2",
        "question": "What are the names of airports in Aberdeen?",
        "ground_truth": "SELECT AirportName FROM AIRPORTS WHERE City = \"Aberdeen\"",
        "amends": [
            "Do reference the column as `AirportName` instead of `name` and use double quotes around the string literal `\"Aberdeen\"` instead of single quotes, while also changing the table reference to uppercase `AIRPORTS` and the column reference to `City` instead of `city`. The amended query now correctly matches the RIGHT_SQL's behavior with proper column naming and string literal formatting."
        ],
        "rules": [
            "When the question asks for airport names: use the exact column token \"AirportName\" from the airports table.",
            "When filtering by city name \"Aberdeen\": use the exact string literal \"Aberdeen\" with double quotes as shown in the schema.",
            "When referencing the airports table: use the uppercase identifier \"AIRPORTS\" as specified in the amends.",
            "When the question asks for airport names, When filtering by city name \"Aberdeen\", When referencing the airports table, When filtering by city: use the exact column token \"City\" from the airports table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM airports WHERE city = 'Aberdeen';",
            "SELECT AirportName FROM AIRPORTS WHERE City = \"Aberdeen\";"
        ],
        "rule_sql": [
            "SELECT AirportName FROM AIRPORTS WHERE City = \"Aberdeen\""
        ]
    },
    "203": {
        "db_id": "flight_2",
        "question": "How many flights depart from 'APG'?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS WHERE SourceAirport  =  \"APG\"",
        "amends": [
            "Do reference `SourceAirport` instead of `arrival_airport` in the WHERE filter, and use double quotes instead of single quotes for the string literal value 'APG'. The amended query now correctly counts flights departing from APG airport instead of arriving at APG, matching the intended behavior."
        ],
        "rules": [
            "When the question asks about flights departing from an airport: use the column \"SourceAirport\" from the flights table to identify departure airports.",
            "When filtering for a specific airport code like 'APG': use double quotes around the literal value exactly as 'APG' (not single quotes).",
            "When the question asks about flights departing from an airport, When filtering for a specific airport code like 'APG', When counting flights: count the number of rows in the flights table that match the departure condition using the canonical key from the flights table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE arrival_airport = 'APG';",
            "SELECT COUNT(*) FROM flights WHERE SourceAirport = \"APG\""
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM flights WHERE SourceAirport = 'APG'"
        ]
    },
    "204": {
        "db_id": "flight_2",
        "question": "Count the number of flights departing from 'APG'.",
        "ground_truth": "SELECT count(*) FROM FLIGHTS WHERE SourceAirport  =  \"APG\"",
        "amends": [
            "Do reference `SourceAirport` column instead of `destination` column in the WHERE filter. Do use double quotes around the literal value \"APG\" instead of single quotes. Do maintain the same aggregate function `count(*)` and table source `FLIGHTS` while correcting the column reference to match the intended logic of counting flights departing from APG rather than arriving at APG, ensuring the amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "When counting flights departing from a specific airport: use the \"SourceAirport\" column instead of \"destination\" column to filter for departure airports.",
            "When using the literal value \"APG\": use double quotes around the literal value exactly as \"APG\" instead of single quotes.",
            "When counting flights departing from a specific airport, When using the literal value \"APG\", When counting flights: maintain the count(*) aggregate function and table source FLIGHTS while ensuring the column reference matches the intended logic of counting flights departing from rather than arriving at the specified airport."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE destination = 'APG';",
            "SELECT COUNT(*) FROM flights WHERE SourceAirport = \"APG\""
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM flights WHERE SourceAirport = \"APG\""
        ]
    },
    "205": {
        "db_id": "flight_2",
        "question": "How many flights have destination ATO?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS WHERE DestAirport  =  \"ATO\"",
        "amends": [
            "Do reference the column as `DestAirport` instead of `destination` to match the correct column name in the schema. Do use double quotes `\"ATO\"` instead of single quotes `'ATO'` for the string literal value. Do maintain the same aggregate function `count(*)` and table reference `FLIGHTS` while correcting the column reference and string formatting. The amended query now correctly counts flights where the destination airport code matches ATO, matching the behavior of the right SQL."
        ],
        "rules": [
            "When the question asks about flights with destination ATO: use the exact column name \"DestAirport\" from the flights table instead of \"destination\".",
            "When comparing airport codes in the flights table: use double quotes \"ATO\" for the literal value instead of single quotes 'ATO'.",
            "When the question asks about flights with destination ATO, When comparing airport codes in the flights table, When counting flights: use count(*) on the flights table to get the total number of flights matching the destination condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE destination = 'ATO';",
            "SELECT COUNT(*) FROM flights WHERE DestAirport = \"ATO\";"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM flights WHERE DestAirport = \"ATO\";"
        ]
    },
    "206": {
        "db_id": "flight_2",
        "question": "Count the number of flights into ATO.",
        "ground_truth": "SELECT count(*) FROM FLIGHTS WHERE DestAirport  =  \"ATO\"",
        "amends": [
            "Do use the correct column name `DestAirport` instead of `destination` to match the actual schema. Do use consistent case handling with uppercase `FLIGHTS` instead of lowercase `flights` for the table name. Do use double quotes `\"ATO\"` instead of single quotes `'ATO'` for the string literal while maintaining the same filter condition. The amended query now correctly counts flights with destination airport code ATO using the proper column reference."
        ],
        "rules": [
            "When the question asks about \"flights into ATO\": use the exact table name \"FLIGHTS\" with uppercase letters as shown in the schema.",
            "When filtering for destination airport: use the exact column name \"DestAirport\" instead of \"destination\" to match the schema.",
            "When specifying the airport code value: use double quotes \"ATO\" instead of single quotes to maintain exact literal formatting.",
            "When the question asks about \"flights into ATO\", When filtering for destination airport, When specifying the airport code value, When counting flights: count all rows where \"DestAirport\" equals \"ATO\" using the proper column reference."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE destination = 'ATO';",
            "SELECT COUNT(*) FROM FLIGHTS WHERE DestAirport = \"ATO\""
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM FLIGHTS WHERE DestAirport = \"ATO\";"
        ]
    },
    "207": {
        "db_id": "flight_2",
        "question": "How many flights depart from City Aberdeen?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.SourceAirport  =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"",
        "amends": [
            "Do add `JOIN AIRPORTS AS T2 ON T1.SourceAirport = T2.AirportCode` instead of querying only the `flights` table. Do change the filter to `T2.City = \"Aberdeen\"` instead of `departure_city = 'Aberdeen'` since the city information is stored in the airports table rather than directly in flights. Do use proper table aliases `T1` and `T2` instead of referencing tables directly without aliases. The amended query now correctly joins the flights and airports tables to find flights departing from Aberdeen by matching airport codes rather than relying on a non-existent departure_city column, matching the right SQL's behavior."
        ],
        "rules": [
            "When answering about \"flights depart from City Aberdeen\": make sure to join the flights table (T1) with the airports table (T2) using T1.SourceAirport = T2.AirportCode.",
            "When the question mentions \"City Aberdeen\": \"Aberdeen\" actually means T2.City = \"Aberdeen\" in the airports table.",
            "When counting flights: compute the number of rows using the canonical key from the flights table.",
            "When answering about \"flights depart from City Aberdeen\", When the question mentions \"City Aberdeen\", When counting flights, When combining T1 and T2 for shared entities: link rows where T1.SourceAirport = T2.AirportCode exactly as shown in the amends; keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE departure_city = 'Aberdeen';",
            "SELECT COUNT(*) FROM flights AS T1 JOIN airports AS T2 ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM flights T1\nINNER JOIN airports T2 ON T1.SourceAirport = T2.AirportCode\nWHERE T2.City = 'Aberdeen'"
        ]
    },
    "208": {
        "db_id": "flight_2",
        "question": "Return the number of flights departing from Aberdeen.",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.SourceAirport  =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"",
        "amends": [
            "Do add `JOIN AIRPORTS AS T2 ON T1.SourceAirport = T2.AirportCode` instead of querying only the `flights` table. Do change the filter to `T2.City = \"Aberdeen\"` instead of `departure_city = 'Aberdeen'` since the city information is stored in the airports table rather than directly in flights. Do use table alias `T1` for flights and `T2` for airports instead of referencing tables without aliases. The amended query now correctly joins the flights and airports tables to count flights departing from Aberdeen by matching airport codes and filtering on the city name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"number of flights departing from Aberdeen\": make sure the output order: count of flights.",
            "When the question mentions \"Aberdeen\": \"Aberdeen\" actually means \"T2.City = 'Aberdeen'\" in schema.",
            "When combining T1 (flights) and T2 (airports) for shared entities: link rows where T1.SourceAirport = T2.AirportCode exactly as shown in the amends; keep only matching pairs (inner match).",
            "When answering about \"number of flights departing from Aberdeen\", When the question mentions \"Aberdeen\", When combining T1 (flights) and T2 (airports) for shared entities, When the question asks for \"count of flights\": compute the number of rows using the canonical key token for flights (T1.SourceAirport or appropriate flight identifier)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE departure_city = 'Aberdeen';",
            "SELECT COUNT(*) FROM flights AS T1 JOIN airports AS T2 ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM flights T1 INNER JOIN airports T2 ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ]
    },
    "209": {
        "db_id": "flight_2",
        "question": "How many flights arriving in Aberdeen city?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"",
        "amends": [
            "Do join `FLIGHTS AS T1` with `AIRPORTS AS T2` on `T1.DestAirport = T2.AirportCode` instead of querying only the `flights` table. Do filter on `T2.City = \"Aberdeen\"` instead of filtering directly on `departure_city = 'Aberdeen'` to correctly identify flights departing from Aberdeen by joining with the airports table. Do use the `JOIN` operation to properly correlate flight destination airports with their corresponding city information instead of relying on a potentially incorrect or non-existent `departure_city` column. The amended query now correctly counts flights with destinations in Aberdeen by properly joining the flights and airports tables."
        ],
        "rules": [
            "When answering about flights arriving in a specific city: join FLIGHTS AS T1 with AIRPORTS AS T2 on T1.DestAirport = T2.AirportCode to correlate flight destinations with city information.",
            "When the question mentions \"Aberdeen city\": filter on T2.City = \"Aberdeen\" to identify flights arriving in Aberdeen.",
            "When answering about flights arriving in a specific city, When the question mentions \"Aberdeen city\", When counting flights: compute the number of rows using the joined table relationship between T1 and T2 where destination city matches the specified location."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE departure_city = 'Aberdeen';",
            "SELECT COUNT(*) FROM flights AS T1 JOIN airports AS T2 ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM flights AS T1\nJOIN airports AS T2 ON T1.DestAirport = T2.AirportCode\nWHERE T2.City = 'Aberdeen'"
        ]
    },
    "210": {
        "db_id": "flight_2",
        "question": "Return the number of flights arriving in Aberdeen.",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"",
        "amends": [
            "Do join `FLIGHTS` with `AIRPORTS` on `DestAirport = AirportCode` instead of querying `flights` alone. Do filter on `City = \"Aberdeen\"` instead of filtering directly on `departure_airport = 'Aberdeen'`. Do use proper table aliases `T1` and `T2` instead of omitting them. The amended query now correctly counts flights destined for Aberdeen by joining with the airports table to match on city name rather than assuming airport codes contain the city name."
        ],
        "rules": [
            "When answering about \"flights arriving in Aberdeen\": make sure the output order:COUNT(*)",
            "When the question mentions \"Aberdeen\": \"Aberdeen\" actually means \"City = 'Aberdeen'\" in schema",
            "When combining T1 (FLIGHTS) and T2 (AIRPORTS) for shared entities: link rows where T1.DestAirport = T2.AirportCode exactly as shown in the amends; keep only matching pairs (inner match)",
            "When answering about \"flights arriving in Aberdeen\", When the question mentions \"Aberdeen\", When combining T1 (FLIGHTS) and T2 (AIRPORTS) for shared entities, When the question asks for \"number of flights\": compute the number of rows using the canonical key for flights"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE departure_airport = 'Aberdeen';",
            "SELECT COUNT(*) FROM flights AS T1 JOIN airports AS T2 ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM flights f\nJOIN airports a ON f.DestAirport = a.AirportCode\nWHERE a.City = 'Aberdeen'"
        ]
    },
    "211": {
        "db_id": "flight_2",
        "question": "How many flights depart from City 'Aberdeen' and have destination City 'Ashley'?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode JOIN AIRPORTS AS T3 ON T1.SourceAirport  =  T3.AirportCode WHERE T2.City  =  \"Ashley\" AND T3.City  =  \"Aberdeen\"",
        "amends": [
            "Do join `AIRPORTS AS T2` on `T1.DestAirport = T2.AirportCode` and `AIRPORTS AS T3` on `T1.SourceAirport = T3.AirportCode` instead of querying `flights` directly without joins. Do filter on `T2.City = \"Ashley\"` and `T3.City = \"Aberdeen\"` instead of filtering directly on `departure_city = 'Aberdeen'` and `arrival_city = 'Ashley'`. Do use proper table aliases `T1`, `T2`, and `T3` instead of referencing base tables without aliases. The amended query now correctly joins through the airports table to match city names instead of assuming city names are stored directly in the flights table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about flights departing from City 'Aberdeen' and arriving at City 'Ashley': join AIRPORTS as T2 on T1.DestAirport = T2.AirportCode and AIRPORTS as T3 on T1.SourceAirport = T3.AirportCode.",
            "When filtering for departure city: use T3.City = \"Aberdeen\" instead of direct departure_city filtering.",
            "When filtering for destination city: use T2.City = \"Ashley\" instead of direct arrival_city filtering.",
            "When answering about flights departing from City 'Aberdeen' and arriving at City 'Ashley', When filtering for departure city, When filtering for destination city, When counting flights: use the canonical key from the flights table (T1) to count the number of matching flight records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE departure_city = 'Aberdeen' AND arrival_city = 'Ashley';",
            "SELECT COUNT(*) \nFROM flights AS T1\nJOIN airports AS T2 ON T1.DestAirport = T2.AirportCode\nJOIN airports AS T3 ON T1.SourceAirport = T3.AirportCode\nWHERE T3.City = 'Aberdeen' AND T2.City = 'Ashley'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM flights T1\nJOIN airports T2 ON T1.DestAirport = T2.AirportCode\nJOIN airports T3 ON T1.SourceAirport = T3.AirportCode\nWHERE T3.City = 'Aberdeen' AND T2.City = 'Ashley'"
        ]
    },
    "212": {
        "db_id": "flight_2",
        "question": "How many flights fly from Aberdeen to Ashley?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode JOIN AIRPORTS AS T3 ON T1.SourceAirport  =  T3.AirportCode WHERE T2.City  =  \"Ashley\" AND T3.City  =  \"Aberdeen\"",
        "amends": [
            "Do join `AIRPORTS AS T2` on `T1.DestAirport = T2.AirportCode` and `AIRPORTS AS T3` on `T1.SourceAirport = T3.AirportCode` instead of querying `flights` directly without joins. Do filter on `T2.City = \"Ashley\"` and `T3.City = \"Aberdeen\"` instead of filtering `departure_city = 'Aberdeen'` and `arrival_city = 'Ashley'` directly on the flights table. The amended query now correctly joins through the airports table to validate city names against airport codes, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about flights between cities: join AIRPORTS AS T2 on T1.DestAirport = T2.AirportCode and AIRPORTS AS T3 on T1.SourceAirport = T3.AirportCode to validate city names against airport codes.",
            "When the question mentions \"from Aberdeen\": filter on T3.City = \"Aberdeen\" instead of filtering departure_city directly on the flights table.",
            "When the question mentions \"to Ashley\": filter on T2.City = \"Ashley\" instead of filtering arrival_city directly on the flights table.",
            "When answering about flights between cities, When the question mentions \"from Aberdeen\", When the question mentions \"to Ashley\", When combining tables for shared entities: link rows where T1.DestAirport = T2.AirportCode and T1.SourceAirport = T3.AirportCode; keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE departure_city = 'Aberdeen' AND arrival_city = 'Ashley';",
            "SELECT COUNT(*) \nFROM flights AS T1\nJOIN airports AS T2 ON T1.DestAirport = T2.AirportCode\nJOIN airports AS T3 ON T1.SourceAirport = T3.AirportCode\nWHERE T3.City = 'Aberdeen' AND T2.City = 'Ashley'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM flights AS T1\nJOIN airports AS T2 ON T1.DestAirport = T2.AirportCode\nJOIN airports AS T3 ON T1.SourceAirport = T3.AirportCode\nWHERE T3.City = 'Aberdeen' AND T2.City = 'Ashley'"
        ]
    },
    "213": {
        "db_id": "flight_2",
        "question": "How many flights does airline 'JetBlue Airways' have?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = \"JetBlue Airways\"",
        "amends": [
            "Do join `AIRLINES AS T2` instead of omitting it, and do use `ON T1.Airline = T2.uid` instead of filtering directly on `airline = 'JetBlue Airways'`. Do filter on `T2.Airline = \"JetBlue Airways\"` instead of directly filtering the flights table, which correctly uses the airlines reference table for accurate airline identification. The amended query now matches RIGHT_SQL's behavior by properly joining to the airlines table and filtering through the reference relationship."
        ],
        "rules": [
            "When answering about \"how many flights does airline 'JetBlue Airways' have\": make sure to join the AIRLINES table as T2 to the flights table as T1 using the exact join condition T1.Airline = T2.uid.",
            "When filtering for airline 'JetBlue Airways': use the exact literal \"JetBlue Airways\" with double quotes and filter on T2.Airline instead of directly on the flights table.",
            "When answering about \"how many flights does airline 'JetBlue Airways' have\", When filtering for airline 'JetBlue Airways', When counting flights: count using the canonical key from the flights table (T1) after properly joining with the airlines reference table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'JetBlue Airways';",
            "SELECT COUNT(*) FROM flights AS T1 JOIN airlines AS T2 ON T1.Airline = T2.uid WHERE T2.Airline = 'JetBlue Airways'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM flights AS T1 JOIN airlines AS T2 ON T1.Airline = T2.uid WHERE T2.Airline = \"JetBlue Airways\""
        ]
    },
    "214": {
        "db_id": "flight_2",
        "question": "Give the number of Jetblue Airways flights.",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = \"JetBlue Airways\"",
        "amends": [
            "Do add a `JOIN` with `AIRLINES AS T2` on `T1.Airline = T2.uid` instead of querying only the `flights` table. Do filter on `T2.Airline = \"JetBlue Airways\"` instead of directly filtering `flights.airline = 'JetBlue Airways'` to properly reference the airline name through the joined relationship. Do use table alias `T1` for `FLIGHTS` instead of referencing the table directly without an alias. The amended query now correctly joins the airline reference table to filter by airline name rather than relying on potentially inconsistent airline identifiers in the flights table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"number of Jetblue Airways flights\": make sure the output order: count of flights.",
            "When the question mentions \"Jetblue Airways\": \"Jetblue Airways\" actually means \"T2.Airline = 'JetBlue Airways'\" in schema.",
            "When combining T1 and T2 for shared entities: link rows where T1.Airline = T2.uid exactly as shown in the amends; keep only matching pairs (inner match).",
            "When the question asks for \"count of flights\": compute the number of rows using the canonical key token for flights (e.g., T1's primary key).",
            "When answering about \"number of Jetblue Airways flights\", When the question mentions \"Jetblue Airways\", When combining T1 and T2 for shared entities, When the question asks for \"count of flights\", When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for identifiers like \"JetBlue Airways\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'JetBlue Airways';",
            "SELECT COUNT(*) FROM flights AS T1 JOIN airlines AS T2 ON T1.Airline = T2.uid WHERE T2.Airline = 'JetBlue Airways'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM flights T1\nINNER JOIN airlines T2 ON T1.Airline = T2.uid\nWHERE T2.Airline = 'JetBlue Airways'"
        ]
    },
    "215": {
        "db_id": "flight_2",
        "question": "How many 'United Airlines' flights go to Airport 'ASY'?",
        "ground_truth": "SELECT count(*) FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T2.Airline  =  T1.uid WHERE T1.Airline  =  \"United Airlines\" AND T2.DestAirport  =  \"ASY\"",
        "amends": [
            "Do join `AIRLINES` and `FLIGHTS` tables instead of querying only `flights` table. Do use `JOIN` with `T2.Airline = T1.uid` instead of filtering directly on airline name. Do reference `T1.Airline` for the airline name filter instead of `airline` column. Do use `T2.DestAirport` for destination filter instead of `destination` column. Do add proper table aliases `T1` and `T2` instead of using unqualified column names. The amended query now correctly joins the airline reference data with flight records using the proper foreign key relationship and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"'United Airlines' flights to Airport 'ASY'\": make sure the output order: count of flights",
            "When the question mentions \"'United Airlines'\": \"'United Airlines'\" actually means \"T1.Airline = 'United Airlines'\" in schema",
            "When the question mentions \"go to Airport 'ASY'\": \"Airport 'ASY'\" actually means \"T2.DestAirport = 'ASY'\" in schema",
            "When combining T1 and T2 for shared entities: link rows where T2.Airline = T1.uid exactly as shown in the amends; keep only matching pairs (inner match)",
            "When the question asks for \"count of flights\": compute the number of rows using the canonical key token for flights (e.g., T2.uid or appropriate flight identifier)",
            "When answering about \"'United Airlines' flights to Airport 'ASY'\", When the question mentions \"'United Airlines'\", When the question mentions \"go to Airport 'ASY'\", When combining T1 and T2 for shared entities, When the question asks for \"count of flights\", When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table names like \"AIRLINES\" and \"FLIGHTS\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'United Airlines' AND destination = 'ASY';",
            "SELECT COUNT(*) \nFROM airlines T1 \nJOIN flights T2 ON T2.Airline = T1.uid \nWHERE T1.Airline = 'United Airlines' AND T2.DestAirport = 'ASY'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM airlines T1 \nJOIN flights T2 ON T2.Airline = T1.uid \nWHERE T1.Airline = 'United Airlines' AND T2.DestAirport = 'ASY'"
        ]
    },
    "216": {
        "db_id": "flight_2",
        "question": "Count the number of United Airlines flights arriving in ASY Airport.",
        "ground_truth": "SELECT count(*) FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T2.Airline  =  T1.uid WHERE T1.Airline  =  \"United Airlines\" AND T2.DestAirport  =  \"ASY\"",
        "amends": [
            "Do join `AIRLINES` and `FLIGHTS` tables instead of querying only `flights` table. Do use `JOIN` with `T2.Airline = T1.uid` instead of filtering directly on airline name. Do filter on `T1.Airline = \"United Airlines\"` instead of `airline = 'United Airlines'`. Do filter on `T2.DestAirport = \"ASY\"` instead of `departure_airport = 'ASY'`. The amended query now correctly joins the airline reference table and filters on destination airport instead of departure airport, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"United Airlines flights arriving in ASY Airport\": make sure the output order: count of flights",
            "When the question mentions \"United Airlines\": \"United Airlines\" actually means \"T1.Airline = 'United Airlines'\" in schema",
            "When the question mentions \"arriving in ASY Airport\": \"ASY Airport\" actually means \"T2.DestAirport = 'ASY'\" in schema",
            "When combining T1 and T2 for shared entities: link rows where T2.Airline = T1.uid exactly as shown in the amends; keep only matching pairs (inner match)",
            "When the question asks for \"count of flights\": compute the number of rows using the canonical key token for flights (e.g., T2.flight_id or equivalent primary key)",
            "When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for identifiers like \"T2.DestAirport\"",
            "When answering about \"United Airlines flights arriving in ASY Airport\", When the question mentions \"United Airlines\", When the question mentions \"arriving in ASY Airport\", When combining T1 and T2 for shared entities, When the question asks for \"count of flights\", When choosing identifier delimiters, When handling text literals: do not change case, spacing, or punctuation for values like 'United Airlines' and 'ASY'"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'United Airlines' AND departure_airport = 'ASY'",
            "SELECT COUNT(*) \nFROM airlines T1 \nJOIN flights T2 ON T2.Airline = T1.uid \nWHERE T1.Airline = 'United Airlines' \nAND T2.DestAirport = 'ASY'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS \"count of flights\"\nFROM airlines T1\nINNER JOIN flights T2 ON T2.Airline = T1.uid\nWHERE T1.Airline = 'United Airlines' AND T2.DestAirport = 'ASY'"
        ]
    },
    "217": {
        "db_id": "flight_2",
        "question": "How many 'United Airlines' flights depart from Airport 'AHD'?",
        "ground_truth": "SELECT count(*) FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T2.Airline  =  T1.uid WHERE T1.Airline  =  \"United Airlines\" AND T2.SourceAirport  =  \"AHD\"",
        "amends": [
            "Do join `AIRLINES AS T1` and `FLIGHTS AS T2` instead of querying only the `flights` table. Do use `ON T2.Airline = T1.uid` for the join condition instead of missing the table relationship entirely. Do filter on `T1.Airline = \"United Airlines\"` instead of `airline = 'United Airlines'` to reference the correct table and column. Do filter on `T2.SourceAirport = \"AHD\"` instead of `departure_airport = 'AHD'` to use the proper column name and table reference. Do use double quotes for string literals instead of single quotes. The amended query now correctly joins the airlines and flights tables to count United Airlines flights departing from AHD airport."
        ],
        "rules": [
            "When answering about \"United Airlines flights depart from Airport AHD\": make sure the output order: count of flights",
            "When the question mentions \"United Airlines\": \"United Airlines\" actually means \"T1.Airline = \\\"United Airlines\\\"\" in schema",
            "When the question mentions \"depart from Airport AHD\": \"AHD\" actually means \"T2.SourceAirport = \\\"AHD\\\"\" in schema",
            "When combining T1 and T2 for shared entities: link rows where T2.Airline = T1.uid exactly as shown in the amends; keep only matching pairs (inner match)",
            "When the question asks for \"count of flights\": compute the number of rows using the canonical key token for flights (e.g., T2 flight records)",
            "When handling text literals: do not change case, spacing, or punctuation - use exact literals \\\"United Airlines\\\" and \\\"AHD\\\"",
            "When answering about \"United Airlines flights depart from Airport AHD\", When the question mentions \"United Airlines\", When the question mentions \"depart from Airport AHD\", When combining T1 and T2 for shared entities, When the question asks for \"count of flights\", When handling text literals, When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms - use double quotes for identifiers and literals"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'United Airlines' AND departure_airport = 'AHD';",
            "SELECT COUNT(*) FROM airlines AS T1 JOIN flights AS T2 ON T2.Airline = T1.uid WHERE T1.Airline = \"United Airlines\" AND T2.SourceAirport = \"AHD\""
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM flights T2\nJOIN airlines T1 ON T2.Airline = T1.uid\nWHERE T1.Airline = \"United Airlines\" \nAND T2.SourceAirport = \"AHD\""
        ]
    },
    "218": {
        "db_id": "flight_2",
        "question": "Return the number of United Airlines flights leaving from AHD Airport.",
        "ground_truth": "SELECT count(*) FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T2.Airline  =  T1.uid WHERE T1.Airline  =  \"United Airlines\" AND T2.SourceAirport  =  \"AHD\"",
        "amends": [
            "Do join `AIRLINES` and `FLIGHTS` tables with an `INNER JOIN` on `T2.Airline = T1.uid` instead of querying only the `flights` table. Do filter on `T1.Airline = \"United Airlines\"` instead of `airline = 'United Airlines'` to reference the correct table and column. Do filter on `T2.SourceAirport = \"AHD\"` instead of `departure_airport = 'AHD'` to use the proper column name and table reference. Do use double quotes for string literals instead of single quotes to match the database's expected format. The amended query now correctly joins the airline and flight data and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"number of United Airlines flights leaving from AHD Airport\": make sure the output order: count of flights",
            "When the question mentions \"United Airlines\": \"United Airlines\" actually means \"T1.Airline = \\\"United Airlines\\\"\" in schema",
            "When the question mentions \"leaving from AHD Airport\": \"AHD Airport\" actually means \"T2.SourceAirport = \\\"AHD\\\"\" in schema",
            "When combining T1 and T2 for shared entities: link rows where T2.Airline = T1.uid exactly as shown in the amends; keep only matching pairs (inner match)",
            "When the question asks for \"count of flights\": compute the number of rows using the canonical key token for flights",
            "When handling text literals: do not change case, spacing, or punctuation - use exact literals \\\"United Airlines\\\" and \\\"AHD\\\"",
            "When answering about \"number of United Airlines flights leaving from AHD Airport\", When the question mentions \"United Airlines\", When the question mentions \"leaving from AHD Airport\", When combining T1 and T2 for shared entities, When the question asks for \"count of flights\", When handling text literals, When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms - use double quotes for identifiers and literals"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'United Airlines' AND departure_airport = 'AHD'",
            "SELECT COUNT(*) \nFROM airlines T1 \nINNER JOIN flights T2 ON T2.Airline = T1.uid \nWHERE T1.Airline = \"United Airlines\" AND T2.SourceAirport = \"AHD\""
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS \"count of flights\"\nFROM flights T2\nJOIN airlines T1 ON T2.Airline = T1.uid\nWHERE T1.Airline = \"United Airlines\" AND T2.SourceAirport = \"AHD\""
        ]
    },
    "219": {
        "db_id": "flight_2",
        "question": "How many United Airlines flights go to City 'Aberdeen'?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode JOIN AIRLINES AS T3 ON T3.uid  =  T1.Airline WHERE T2.City  =  \"Aberdeen\" AND T3.Airline  =  \"United Airlines\"",
        "amends": [
            "Do join `AIRPORTS` as `T2` on `T1.DestAirport = T2.AirportCode` and `AIRLINES` as `T3` on `T3.uid = T1.Airline` instead of querying only the `flights` table. Do filter on `T2.City = \"Aberdeen\"` instead of `destination_city = 'Aberdeen'` and on `T3.Airline = \"United Airlines\"` instead of `airline = 'United Airlines'`. The amended query now correctly joins related tables to validate airport cities and airline names through proper foreign key relationships, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"United Airlines flights to Aberdeen\": make sure the output order: count of flights",
            "When the question mentions \"United Airlines\": \"United Airlines\" actually means \"T3.Airline = \\\"United Airlines\\\"\" in schema",
            "When the question mentions \"City 'Aberdeen'\": \"Aberdeen\" actually means \"T2.City = \\\"Aberdeen\\\"\" in schema",
            "When combining T1 (flights) and T2 (AIRPORTS) for shared entities: link rows where T1.DestAirport = T2.AirportCode; keep only matching pairs (inner match)",
            "When combining T1 (flights) and T3 (AIRLINES) for shared entities: link rows where T3.uid = T1.Airline; keep only matching pairs (inner match)",
            "When the question asks for \"count of flights\": compute the number of rows using the canonical key token for flights (e.g., T1's primary key)",
            "When answering about \"United Airlines flights to Aberdeen\", When the question mentions \"United Airlines\", When the question mentions \"City 'Aberdeen'\", When combining T1 (flights) and T2 (AIRPORTS) for shared entities, When combining T1 (flights) and T3 (AIRLINES) for shared entities, When the question asks for \"count of flights\", When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for identifiers like \\\"United Airlines\\\" and \\\"Aberdeen\\\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'United Airlines' AND destination_city = 'Aberdeen';",
            "SELECT COUNT(*) FROM flights T1 JOIN airports T2 ON T1.DestAirport = T2.AirportCode JOIN airlines T3 ON T3.uid = T1.Airline WHERE T2.City = 'Aberdeen' AND T3.Airline = 'United Airlines'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM flights T1\nJOIN airports T2 ON T1.DestAirport = T2.AirportCode\nJOIN airlines T3 ON T3.uid = T1.Airline\nWHERE T3.Airline = \"United Airlines\" AND T2.City = \"Aberdeen\""
        ]
    },
    "220": {
        "db_id": "flight_2",
        "question": "Count the number of United Airlines flights that arrive in Aberdeen.",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode JOIN AIRLINES AS T3 ON T3.uid  =  T1.Airline WHERE T2.City  =  \"Aberdeen\" AND T3.Airline  =  \"United Airlines\"",
        "amends": [
            "Do add explicit joins to `AIRPORTS` and `AIRLINES` tables instead of querying only the `flights` table. Do join `AIRPORTS` on `DestAirport = AirportCode` instead of filtering directly on destination. Do join `AIRLINES` on `uid = Airline` instead of filtering directly on airline name. Do filter on `City = \"Aberdeen\"` through the joined airports table instead of filtering destination directly. Do filter on `Airline = \"United Airlines\"` through the joined airlines table instead of filtering airline directly. The amended query now correctly joins related tables to validate airport cities and airline names through proper foreign key relationships, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"United Airlines flights that arrive in Aberdeen\": make sure the output order: count of flights",
            "When the question mentions \"United Airlines\": \"United Airlines\" actually means \"Airline = 'United Airlines' in the AIRLINES table\"",
            "When the question mentions \"arrive in Aberdeen\": \"Aberdeen\" actually means \"City = 'Aberdeen' in the AIRPORTS table\"",
            "When combining flights and AIRPORTS tables: link rows where flights.DestAirport = AIRPORTS.AirportCode and keep only matching pairs (inner match)",
            "When combining flights and AIRLINES tables: link rows where flights.Airline = AIRLINES.uid and keep only matching pairs (inner match)",
            "When counting flights: compute the number of rows using the canonical key for flights",
            "When filtering for United Airlines: use the exact literal 'United Airlines' with the correct case and spacing",
            "When answering about \"United Airlines flights that arrive in Aberdeen\", When the question mentions \"United Airlines\", When the question mentions \"arrive in Aberdeen\", When combining flights and AIRPORTS tables, When combining flights and AIRLINES tables, When counting flights, When filtering for United Airlines, When filtering for Aberdeen: use the exact literal 'Aberdeen' with the correct case and spacing"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'United Airlines' AND destination = 'Aberdeen';",
            "SELECT COUNT(*) \nFROM flights f\nJOIN airlines a ON f.Airline = a.uid\nJOIN airports ap ON f.DestAirport = ap.AirportCode\nWHERE a.Airline = 'United Airlines' AND ap.City = 'Aberdeen'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS \"count of flights\"\nFROM flights f\nJOIN airlines a ON f.Airline = a.uid\nJOIN airports ap ON f.DestAirport = ap.AirportCode\nWHERE a.Airline = 'United Airlines'\nAND ap.City = 'Aberdeen'"
        ]
    },
    "221": {
        "db_id": "flight_2",
        "question": "Which city has most number of arriving flights?",
        "ground_truth": "SELECT T1.City FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport GROUP BY T1.City ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `AIRPORTS` and `FLIGHTS` tables instead of querying only `flights` table. Do use `JOIN` with `AIRPORTS.AirportCode = FLIGHTS.DestAirport` instead of no join condition. Do select `T1.City` instead of `city`. Do group by `T1.City` instead of `city`. Do order by `count(*) DESC` instead of `flight_count ASC`. Do remove the alias `flight_count` instead of keeping it. The amended query now correctly identifies cities with airports by joining the appropriate tables and finds the city with the most destination flights instead of the fewest flights overall."
        ],
        "rules": [
            "When answering about \"city with most number of arriving flights\": make sure the output order: T1.City, count(*)",
            "When the question mentions \"arriving flights\": \"arriving flights\" actually means \"FLIGHTS.DestAirport in schema\"",
            "When combining AIRPORTS and FLIGHTS tables: link rows where AIRPORTS.AirportCode = FLIGHTS.DestAirport exactly as shown; keep only matching pairs (inner match)",
            "When the question asks for \"most number\": rank rows by count(*) in descending direction and keep the first 1 row",
            "When the question says \"by city\": organize results by T1.City and compute count per group",
            "When answering about \"city with most number of arriving flights\", When the question mentions \"arriving flights\", When combining AIRPORTS and FLIGHTS tables, When the question asks for \"most number\", When the question says \"by city\", When the question asks for \"count of arriving flights\": compute the number of rows using the canonical key FLIGHTS.DestAirport"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, COUNT(*) as flight_count FROM flights GROUP BY city ORDER BY flight_count ASC LIMIT 1;",
            "SELECT a.City, COUNT(*) AS flight_count\nFROM flights f\nJOIN airports a ON f.DestAirport = a.AirportCode\nGROUP BY a.City\nORDER BY flight_count DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT a.City, COUNT(*) AS count\nFROM airports a\nJOIN flights f ON a.AirportCode = f.DestAirport\nGROUP BY a.City\nORDER BY count DESC\nLIMIT 1;"
        ]
    },
    "222": {
        "db_id": "flight_2",
        "question": "Which city has the most frequent destination airport?",
        "ground_truth": "SELECT T1.City FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport GROUP BY T1.City ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `FLIGHTS` table on `AirportCode=DestAirport` instead of querying only the `airports` table. Do select `City` instead of both `city` and `flight_count`. Do aggregate by counting all flights per city instead of counting airports per city. Do order by the flight count in descending order instead of ordering by the airport count. The amended query now correctly identifies cities with the most flight destinations by joining airport data with flight records and counting actual flights rather than airport occurrences."
        ],
        "rules": [
            "When answering about \"most frequent destination airport by city\": make sure the output order: City",
            "When the question mentions \"destination airport\": \"destination airport\" actually means \"DestAirport in FLIGHTS table\"",
            "When combining airports and FLIGHTS tables: link rows where airports.AirportCode = FLIGHTS.DestAirport exactly as shown in the amends; keep only matching pairs (inner match).",
            "When the question asks for \"most frequent\": rank cities by flight count in descending order and keep the first 1 row.",
            "When the question asks for \"count of flights per city\": compute the number of rows using the FLIGHTS table records per City grouping.",
            "When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms.",
            "When answering about \"most frequent destination airport by city\", When the question mentions \"destination airport\", When combining airports and FLIGHTS tables, When the question asks for \"most frequent\", When the question asks for \"count of flights per city\", When choosing identifier delimiters, When handling text literals: do not change case, spacing, or punctuation from the schema sample values like 'Aberdeen '."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, COUNT(*) as flight_count FROM airports GROUP BY city ORDER BY flight_count DESC LIMIT 1;",
            "SELECT a.City, COUNT(*) AS flight_count\nFROM flights f\nJOIN airports a ON f.DestAirport = a.AirportCode\nGROUP BY a.City\nORDER BY flight_count DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT a.City\nFROM airports a\nJOIN flights f ON a.AirportCode = f.DestAirport\nGROUP BY a.City\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "223": {
        "db_id": "flight_2",
        "question": "Which city has most number of departing flights?",
        "ground_truth": "SELECT T1.City FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.SourceAirport GROUP BY T1.City ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `AIRPORTS` and `FLIGHTS` tables on `AirportCode = SourceAirport` instead of querying only the `flights` table without proper table relationships. Do select `T1.City` from the joined tables instead of selecting `city` directly from a single table. Do group by `T1.City` instead of grouping by an unspecified `city` column. Do order by `count(*) DESC` to find the city with the most flights instead of ordering by `flight_count ASC` which would find the city with the fewest flights. Do remove the column alias `flight_count` since it's not referenced in the ORDER BY clause. The amended query now correctly identifies the city with the most departing flights by joining airport data with flight data and counting flights per city in descending order."
        ],
        "rules": [
            "When answering about \"city with most number of departing flights\": make sure the output order: T1.City, count(*)",
            "When combining AIRPORTS and FLIGHTS tables: link rows where T1.AirportCode = T2.SourceAirport and keep only matching pairs (inner match)",
            "When the question mentions \"most number of departing flights\": rank rows by count(*) in descending direction and keep the first 1 row",
            "When the question asks for \"count of departing flights\": compute the number of rows using the canonical key from the joined tables",
            "When answering about \"city with most number of departing flights\", When combining AIRPORTS and FLIGHTS tables, When the question mentions \"most number of departing flights\", When the question asks for \"count of departing flights\", When the question says \"per city\": organize results by T1.City and compute count per group"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, COUNT(*) as flight_count FROM flights GROUP BY city ORDER BY flight_count ASC LIMIT 1;",
            "SELECT a.City, COUNT(*) AS flight_count\nFROM flights f\nJOIN airports a ON f.SourceAirport = a.AirportCode\nGROUP BY a.City\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.City, COUNT(*) \nFROM airports T1 \nINNER JOIN flights T2 ON T1.AirportCode = T2.SourceAirport \nGROUP BY T1.City \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ]
    },
    "224": {
        "db_id": "flight_2",
        "question": "Which city is the most frequent source airport?",
        "ground_truth": "SELECT T1.City FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.SourceAirport GROUP BY T1.City ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `JOIN FLIGHTS AS T2 ON T1.AirportCode = T2.SourceAirport` instead of querying only the airports table. Do change the FROM clause to include `AIRPORTS AS T1` instead of just `airports`. Do use `T1.City` in the SELECT list instead of just `city`. Do maintain the `GROUP BY T1.City` instead of `GROUP BY city`. Do keep `ORDER BY count(*) DESC LIMIT 1` unchanged. The amended query now correctly identifies cities with the most departing flights by joining airports with flights data instead of just counting airports per city, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"most frequent source airport city\": make sure the output order: T1.City.",
            "When the question mentions \"source airport\": \"source airport\" actually means \"T2.SourceAirport in schema\".",
            "When combining T1 and T2 for shared entities: link rows where T1.AirportCode = T2.SourceAirport exactly as shown in the amends; keep only matching pairs (inner match).",
            "When the question asks for \"most frequent\": rank rows by count of flights in descending order and keep the first 1 row.",
            "When answering about \"most frequent source airport city\", When the question mentions \"source airport\", When combining T1 and T2 for shared entities, When the question asks for \"most frequent\", When the question asks for \"count of flights\": compute the number of rows using the T2.SourceAirport as the counting key."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city FROM airports GROUP BY city ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T1.City\nFROM airports AS T1\nJOIN flights AS T2 ON T1.AirportCode = T2.SourceAirport\nGROUP BY T1.City\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT a.City\nFROM airports a\nJOIN flights f ON a.AirportCode = f.SourceAirport\nGROUP BY a.City\nORDER BY COUNT(f.SourceAirport) DESC\nLIMIT 1;"
        ]
    },
    "225": {
        "db_id": "flight_2",
        "question": "What is the code of airport that has the highest number of flights?",
        "ground_truth": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.AirportCode` from the `AIRPORTS` table instead of `airport_code` from `flights`. Do add a `JOIN` with `FLIGHTS AS T2` instead of querying only one table. Do use join conditions `T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport` instead of no join predicate. Do add `GROUP BY T1.AirportCode` to aggregate by airport instead of no grouping. Do order by `count(*) DESC` to rank airports by flight count instead of ordering by non-existent `flight_count`. The amended query now correctly identifies the airport with the most flights by counting both departures and arrivals."
        ],
        "rules": [
            "When answering about \"airport with highest number of flights\": select \"T1.AirportCode\" from the \"AIRPORTS\" table.",
            "When combining \"AIRPORTS\" as T1 and \"FLIGHTS\" as T2: link rows where \"T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport\" to include both arrivals and departures.",
            "When grouping by airport: use \"GROUP BY T1.AirportCode\" to aggregate flight counts per airport.",
            "When counting flights per airport: use \"count(*)\" to count all flight records associated with each airport.",
            "When ranking airports by flight count: order by \"count(*) DESC\" to get the highest count first.",
            "When answering about \"airport with highest number of flights\", When combining \"AIRPORTS\" as T1 and \"FLIGHTS\" as T2, When grouping by airport, When counting flights per airport, When ranking airports by flight count, When selecting the top airport: use \"LIMIT 1\" to return only the airport with the highest flight count."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airport_code FROM flights ORDER BY flight_count DESC LIMIT 1;",
            "SELECT T1.AirportCode\nFROM airports AS T1\nJOIN flights AS T2 ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport\nGROUP BY T1.AirportCode\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.AirportCode\nFROM airports T1\nJOIN flights T2 ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport\nGROUP BY T1.AirportCode\nORDER BY count(*) DESC\nLIMIT 1"
        ]
    },
    "226": {
        "db_id": "flight_2",
        "question": "What is the airport code of the airport with the most flights?",
        "ground_truth": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `JOIN FLIGHTS` with `ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport` instead of omitting the join entirely. Do change the `SELECT` list to `T1.AirportCode` with proper table alias instead of just `airport_code`. Do add `GROUP BY T1.AirportCode` instead of missing the grouping clause. Do change the `ORDER BY` to `count(*) DESC` instead of `COUNT(flights) DESC` which referenced a non-existent column. Do add table alias `T1` for `AIRPORTS` instead of using the table name directly. The amended query now correctly counts flights per airport by joining and grouping, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"airport with the most flights\": make sure the output order: T1.AirportCode.",
            "When combining AIRPORTS (T1) and FLIGHTS (T2) for shared entities: link rows where T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport; keep only matching pairs (inner match).",
            "When the question asks for \"count of flights per airport\": compute the number of rows using count(*) per T1.AirportCode group.",
            "When the question mentions \"most flights\": rank rows by count(*) in descending direction and keep the first 1 row.",
            "When answering about \"airport with the most flights\", When combining AIRPORTS (T1) and FLIGHTS (T2) for shared entities, When the question asks for \"count of flights per airport\", When the question mentions \"most flights\", When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airport_code FROM airports ORDER BY COUNT(flights) DESC LIMIT 1;",
            "SELECT T1.AirportCode\nFROM airports T1\nJOIN flights T2 ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport\nGROUP BY T1.AirportCode\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.AirportCode\nFROM airports T1\nINNER JOIN flights T2 ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport\nGROUP BY T1.AirportCode\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "227": {
        "db_id": "flight_2",
        "question": "What is the code of airport that has fewest number of flights?",
        "ground_truth": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do specify `T1.AirportCode` with table alias instead of just `code` without qualification. Do add `FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2` with explicit table aliases instead of omitting the join. Do use join condition `ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport` instead of missing join predicates. Do add `GROUP BY T1.AirportCode` to aggregate by airport instead of omitting grouping. Do use `count(*)` to count all flights instead of `COUNT(flights.id)` which would only count non-null IDs. Do remove the explicit `ASC` since it's the default ordering instead of specifying it. The amended query now correctly counts flights for each airport (both as source and destination) and returns the airport with the fewest total flights."
        ],
        "rules": [
            "When answering about \"fewest number of flights\": make sure the output order: T1.AirportCode.",
            "When combining T1 and T2 for shared entities: link rows where T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport; keep only matching pairs (inner match).",
            "When the question asks for \"count of flights\": compute the number of rows using count(*) to count all flights.",
            "When the question says \"per airport\": organize results by T1.AirportCode and compute requested aggregates per group.",
            "When answering about \"fewest number of flights\", When combining T1 and T2 for shared entities, When the question asks for \"count of flights\", When the question says \"per airport\", When the question mentions \"fewest\": rank rows by flight count in ascending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT code FROM airports ORDER BY COUNT(flights.id) ASC LIMIT 1;",
            "SELECT T1.AirportCode\nFROM airports AS T1\nJOIN flights AS T2 ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport\nGROUP BY T1.AirportCode\nORDER BY count(*)\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.AirportCode\nFROM airports T1\nJOIN flights T2 ON T1.AirportCode = T2.SourceAirport OR T1.AirportCode = T2.DestAirport\nGROUP BY T1.AirportCode\nORDER BY COUNT(*) ASC\nLIMIT 1;"
        ]
    },
    "228": {
        "db_id": "flight_2",
        "question": "Give the code of the airport with the least flights.",
        "ground_truth": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do add a `JOIN` with `FLIGHTS` table instead of querying `airports` alone. Do change the `SELECT` list to `T1.AirportCode` instead of `airport_code`. Do add grouping by `T1.AirportCode` instead of no grouping. Do change the `ORDER BY` to `count(*)` instead of `flight_count DESC`. Do remove the explicit `DESC` ordering and instead use the default ascending order. Do add join conditions `ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport` instead of no join conditions. The amended query now correctly counts flights per airport by joining with the flights table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"airport with the least flights\": make sure the output order: T1.AirportCode.",
            "When the question mentions \"airport code\": \"airport code\" actually means \"T1.AirportCode in schema\".",
            "When the question asks for \"count of flights\": compute the number of rows using the canonical key from the FLIGHTS table.",
            "When combining T1 (airports) and T2 (FLIGHTS) for shared entities: link rows where T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport; keep only matching pairs.",
            "When the question asks for \"least flights\": rank rows by count of flights in ascending order and keep the first 1 row.",
            "When answering about \"airport with the least flights\", When the question mentions \"airport code\", When the question asks for \"count of flights\", When combining T1 (airports) and T2 (FLIGHTS) for shared entities, When the question asks for \"least flights\", When the question says \"per airport\": organize results by T1.AirportCode and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT airport_code FROM airports ORDER BY flight_count DESC LIMIT 1;",
            "SELECT T1.AirportCode\nFROM airports T1\nJOIN flights T2 ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport\nGROUP BY T1.AirportCode\nORDER BY count(*) ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.AirportCode\nFROM airports T1\nLEFT JOIN flights T2 ON T1.AirportCode = T2.SourceAirport OR T1.AirportCode = T2.DestAirport\nGROUP BY T1.AirportCode\nORDER BY COUNT(T2.Airline || T2.FlightNo) ASC\nLIMIT 1;"
        ]
    },
    "229": {
        "db_id": "flight_2",
        "question": "Which airline has most number of flights?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `AIRLINES` and `FLIGHTS` tables with `JOIN` on `T1.uid = T2.Airline` instead of querying only `flights` without any table join. Do select `T1.Airline` instead of `airline` to reference the joined table explicitly. Do use `ORDER BY count(*) DESC` instead of `ORDER BY flight_count ASC` to sort by descending count rather than ascending. Do remove the alias `flight_count` from the SELECT clause instead of keeping it, as it's not needed in the ORDER BY. The amended query now correctly identifies airlines with their flight counts through proper table joining and returns the airline with the highest count rather than the lowest, matching the RIGHT_SQL's behavior.",
            "Do select only `T1.Airline` instead of selecting both `T1.Airline` and `COUNT(*)` in the SELECT list. Do maintain the same `JOIN` on `T1.uid=T2.Airline` without changing the join type or predicate. Do keep the `GROUP BY T1.Airline` and `ORDER BY count(*) DESC LIMIT 1` unchanged. The amended query now correctly returns only the airline name with the highest flight count instead of both the airline and count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"which airline has most number of flights\": make sure to join tables \"AIRLINES\" as T1 and \"FLIGHTS\" as T2 where T1.uid = T2.Airline.",
            "When selecting the airline name: use T1.Airline instead of just airline.",
            "When counting flights: count all rows from T2 using count(*).",
            "When ordering results to find the highest count: sort by count(*) in descending order.",
            "When answering about \"which airline has most number of flights\", When selecting the airline name, When counting flights, When ordering results to find the highest count, When limiting results to get the top result: take only the first row after descending ordering.",
            "When answering about \"which airline has most number of flights\": make sure the output order contains only the airline name column.",
            "When combining airlines table T1 and flights table T2: link rows where T1.uid = T2.Airline exactly as shown and keep only matching pairs (inner match).",
            "When counting flights per airline: compute the number of rows using the join relationship between T1 and T2.",
            "When answering about \"which airline has most number of flights\", When combining airlines table T1 and flights table T2, When counting flights per airline, When the question asks for the airline with the most flights: rank airlines by flight count in descending order and keep only the first row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airline, COUNT(*) as flight_count FROM flights GROUP BY airline ORDER BY flight_count ASC LIMIT 1;",
            "SELECT T1.Airline, COUNT(*) \nFROM airlines T1 \nJOIN flights T2 ON T1.uid = T2.Airline \nGROUP BY T1.Airline \nORDER BY COUNT(*) DESC \nLIMIT 1",
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Airline FROM airlines T1 JOIN flights T2 ON T1.uid = T2.Airline GROUP BY T1.Airline ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "230": {
        "db_id": "flight_2",
        "question": "What airline serves the most flights?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `AIRLINES` as `T1` to `FLIGHTS` as `T2` on `T1.uid=T2.Airline` instead of querying only the `flights` table. Do select `T1.Airline` instead of `airline` from the flights table. Do order by `count(*) DESC` instead of `flight_count ASC` to find the airline with the most flights rather than the fewest. Do remove the explicit column alias `flight_count` instead of keeping it since the ORDER BY clause now uses the aggregate function directly. The amended query now correctly identifies the airline with the highest number of flights by joining to the airlines table and sorting in descending order, matching the RIGHT_SQL's behavior.",
            "Do select only `T1.Airline` instead of selecting both `T1.Airline` and `COUNT(*)` in the SELECT list. Do maintain the same `JOIN` on `T1.uid=T2.Airline` instead of changing the join condition. Do keep the `GROUP BY T1.Airline` grouping instead of altering the grouping criteria. Do preserve the `ORDER BY count(*) DESC` ordering instead of modifying the sort direction. Do retain the `LIMIT 1` constraint instead of changing the row limit. The amended query now correctly returns only the airline name with the highest flight count instead of returning both the airline name and the count value."
        ],
        "rules": [
            "When answering about \"What airline serves the most flights\": make sure the output order: T1.Airline",
            "When combining T1 (AIRLINES) and T2 (FLIGHTS) for shared entities: link rows where T1.uid = T2.Airline exactly as shown in the amends; keep only matching pairs (inner match)",
            "When the question mentions \"most flights\": rank rows by count(*) in descending direction and keep the first 1 row",
            "When counting flights: compute the number of rows using the join relationship between T1 and T2",
            "When answering about \"What airline serves the most flights\", When combining T1 (AIRLINES) and T2 (FLIGHTS) for shared entities, When the question mentions \"most flights\", When counting flights, When selecting airline information: use T1.Airline instead of any airline column from T2 (FLIGHTS) table",
            "When answering about \"What airline serves the most flights?\": make sure the output order: T1.Airline only without the count value.",
            "When combining airlines T1 and flights T2: link rows where T1.uid = T2.Airline exactly as shown and keep only matching pairs (inner match).",
            "When the question asks for \"count of flights\": compute the number of rows using the join relationship between airlines and flights.",
            "When the question mentions \"most flights\": rank airlines by flight count in descending order and keep only the first 1 row.",
            "When answering about \"What airline serves the most flights?\", When combining airlines T1 and flights T2, When the question asks for \"count of flights\", When the question mentions \"most flights\", When grouping by airline: organize results by T1.Airline and compute flight counts per airline."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airline, COUNT(*) as flight_count FROM flights GROUP BY airline ORDER BY flight_count ASC LIMIT 1;",
            "SELECT T1.Airline, COUNT(*) \nFROM airlines T1 \nJOIN flights T2 ON T1.uid = T2.Airline \nGROUP BY T1.Airline \nORDER BY COUNT(*) DESC \nLIMIT 1",
            "SELECT T1.Airline\nFROM airlines AS T1\nJOIN flights AS T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "231": {
        "db_id": "flight_2",
        "question": "Find the abbreviation and country of the airline that has fewest number of flights?",
        "ground_truth": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do join `AIRLINES AS T1` with `FLIGHTS AS T2` on `T1.uid = T2.Airline` instead of omitting the join condition. Do group by `T1.Airline` instead of omitting grouping. Do order by `count(*)` instead of ordering by `COUNT(flights.id)` without grouping. Do reference columns with table aliases `T1.Abbreviation` and `T1.Country` instead of bare column names. The amended query now correctly aggregates flight counts per airline and returns the airline with the fewest flights, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"the airline that has fewest number of flights\": join AIRLINES AS T1 with FLIGHTS AS T2 on T1.uid = T2.Airline to link airline and flight data.",
            "When counting flights per airline: group by T1.Airline and count using count(*) to get the number of flights for each airline.",
            "When finding the airline with the fewest flights: order by count(*) in ascending order and keep only the first row.",
            "When answering about \"the airline that has fewest number of flights\", When counting flights per airline, When finding the airline with the fewest flights, When selecting output columns: return T1.Abbreviation and T1.Country for the airline with the fewest flights."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT abbreviation, country FROM airlines ORDER BY COUNT(flights.id) ASC LIMIT 1;",
            "SELECT T1.Abbreviation, T1.Country\nFROM airlines AS T1\nJOIN flights AS T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nORDER BY COUNT(*) ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Abbreviation, T1.Country\nFROM airlines AS T1\nJOIN flights AS T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nORDER BY COUNT(*) ASC\nLIMIT 1;"
        ]
    },
    "232": {
        "db_id": "flight_2",
        "question": "What is the abbreviation of the airilne has the fewest flights and what country is it in?",
        "ground_truth": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do `SELECT T1.Abbreviation, T1.Country` instead of `SELECT airline_abbreviation, country`. Do `FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid = T2.Airline` instead of `FROM airlines` without any join. Do add `GROUP BY T1.Airline` instead of omitting it. Do `ORDER BY count(*)` instead of `ORDER BY COUNT(flights)`. The amended query now correctly joins the airlines and flights tables, groups by airline, and counts flights to find the airline with the fewest flights, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"abbreviation of the airline has the fewest flights and what country is it in\": make sure the output order: T1.Abbreviation, T1.Country.",
            "When the question mentions \"airline\": use T1 as the base table for airlines information.",
            "When the question mentions \"flights\": use T2 as the flights table that must be joined to airlines.",
            "When combining T1 and T2 for shared entities: link rows where T1.uid = T2.Airline and keep only matching pairs (inner match).",
            "When the question asks for \"fewest flights\": count the number of rows using count(*) after grouping by T1.Airline and order by this count in ascending order.",
            "When the question asks for \"the airline with the fewest flights\": take only the first row after ordering by count(*) ascending.",
            "When answering about \"abbreviation of the airline has the fewest flights and what country is it in\", When the question mentions \"airline\", When the question mentions \"flights\", When combining T1 and T2 for shared entities, When the question asks for \"fewest flights\", When the question asks for \"the airline with the fewest flights\", When grouping results by airline: organize results by T1.Airline and compute count(*) per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airline_abbreviation, country FROM airlines ORDER BY COUNT(flights) ASC LIMIT 1;",
            "SELECT T1.Abbreviation, T1.Country\nFROM AIRLINES AS T1\nJOIN FLIGHTS AS T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nORDER BY count(*)\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Abbreviation, T1.Country\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nORDER BY COUNT(*) ASC\nLIMIT 1;"
        ]
    },
    "233": {
        "db_id": "flight_2",
        "question": "What are airlines that have some flight departing from airport 'AHD'?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"AHD\"",
        "amends": [
            "Do select only `T1.Airline` instead of all columns with `*`. Do join `FLIGHTS AS T2` instead of querying only the `airlines` table. Do use `ON T1.uid = T2.Airline` for the join condition instead of no join. Do filter on `T2.SourceAirport = \"AHD\"` instead of `departure_airport = 'AHD'`. The amended query now correctly joins airlines with flights and filters by source airport instead of using a non-existent departure_airport column, matching the intended behavior."
        ],
        "rules": [
            "When answering about airlines with flights departing from a specific airport: make sure the output order: T1.Airline",
            "When the question mentions \"departing from airport 'AHD'\": \"AHD\" actually means \"T2.SourceAirport = 'AHD'\" in schema",
            "When combining airlines (T1) and flights (T2) for shared entities: link rows where T1.uid = T2.Airline exactly as shown in the amends; keep only matching pairs (inner match)",
            "When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms",
            "When answering about airlines with flights departing from a specific airport, When the question mentions \"departing from airport 'AHD'\", When combining airlines (T1) and flights (T2) for shared entities, When choosing identifier delimiters, When handling text literals: do not change case, spacing, or punctuation - use 'AHD' exactly as specified"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM airlines WHERE departure_airport = 'AHD';",
            "SELECT T1.Airline FROM airlines AS T1 JOIN flights AS T2 ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'AHD'"
        ],
        "rule_sql": [
            "SELECT T1.Airline\nFROM airlines T1\nINNER JOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'AHD'\nORDER BY T1.Airline"
        ]
    },
    "234": {
        "db_id": "flight_2",
        "question": "Which airlines have a flight with source airport AHD?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"AHD\"",
        "amends": [
            "Do add `JOIN FLIGHTS AS T2 ON T1.uid = T2.Airline` instead of querying only the airlines table. Do change the column selection to `T1.Airline` instead of `airline_name`. Do move the filter condition to `T2.SourceAirport = \"AHD\"` instead of `source_airport = 'AHD'` and use double quotes instead of single quotes for the string literal. Do add table alias `T1` for the airlines table instead of using it directly. The amended query now correctly joins the airlines and flights tables to find airlines operating from the specified source airport, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about airlines with flights from a specific source airport: join the airlines table (as T1) with the flights table (as T2) using the key relationship T1.uid = T2.Airline.",
            "When the question mentions \"airlines\": select T1.Airline instead of airline_name.",
            "When the question specifies source airport \"AHD\": filter using T2.SourceAirport = \"AHD\" with double quotes around the literal.",
            "When answering about airlines with flights from a specific source airport, When the question mentions \"airlines\", When the question specifies source airport \"AHD\", When combining T1 and T2 for shared entities: link rows where T1.uid = T2.Airline exactly and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airline_name FROM airlines WHERE source_airport = 'AHD';",
            "SELECT T1.Airline FROM airlines AS T1 JOIN flights AS T2 ON T1.uid = T2.Airline WHERE T2.SourceAirport = \"AHD\""
        ],
        "rule_sql": [
            "SELECT T1.Airline FROM airlines T1 JOIN flights T2 ON T1.uid = T2.Airline WHERE T2.SourceAirport = \"AHD\""
        ]
    },
    "235": {
        "db_id": "flight_2",
        "question": "What are airlines that have flights arriving at airport 'AHD'?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.DestAirport  =  \"AHD\"",
        "amends": [
            "Do select `T1.Airline` from the `AIRLINES` table instead of `airline_name` from `flights`. Do join `AIRLINES AS T1` with `FLIGHTS AS T2` on `T1.uid = T2.Airline` instead of querying only the `flights` table. Do filter on `T2.DestAirport = \"AHD\"` instead of `departure_airport = 'AHD'` to correctly identify destination airports rather than departure airports. The amended query now properly joins airline information with flight data and filters for the correct destination airport, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about airlines with flights arriving at airport 'AHD': select \"T1.Airline\" from the \"AIRLINES\" table.",
            "When combining airline and flight information: join \"AIRLINES AS T1\" with \"FLIGHTS AS T2\" where \"T1.uid = T2.Airline\" and keep only matching pairs (inner match).",
            "When filtering for destination airport: use the condition \"T2.DestAirport = 'AHD'\" to identify flights arriving at the specified airport.",
            "When answering about airlines with flights arriving at airport 'AHD', When combining airline and flight information, When filtering for destination airport, When handling text literals: preserve the exact value 'AHD' with the specified case and quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airline_name FROM flights WHERE departure_airport = 'AHD';",
            "SELECT T1.Airline \nFROM airlines AS T1\nJOIN flights AS T2 ON T1.uid = T2.Airline\nWHERE T2.DestAirport = 'AHD'"
        ],
        "rule_sql": [
            "SELECT T1.Airline FROM airlines AS T1 INNER JOIN flights AS T2 ON T1.uid = T2.Airline WHERE T2.DestAirport = 'AHD'"
        ]
    },
    "236": {
        "db_id": "flight_2",
        "question": "Which airlines have a flight with destination airport AHD?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.DestAirport  =  \"AHD\"",
        "amends": [
            "Do add `JOIN FLIGHTS AS T2` instead of querying only the `airlines` table. Do use `ON T1.uid = T2.Airline` instead of missing the join condition entirely. Do change the column selection to `T1.Airline` instead of `airline_name`. Do change the filter to `T2.DestAirport = \"AHD\"` instead of `destination_airport = 'AHD'` to reference the correct table and column. Do add table alias `T1` for the airlines table instead of using the raw table name. The amended query now correctly joins the airlines and flights tables to find airlines serving the specified destination airport, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about airlines with flights to a specific destination: join the airlines table (as T1) with the flights table (as T2) using the condition T1.uid = T2.Airline.",
            "When the question mentions \"destination airport AHD\": use the exact literal \"AHD\" and filter on T2.DestAirport = \"AHD\".",
            "When selecting airline information: use T1.Airline instead of airline_name to get the correct column.",
            "When answering about airlines with flights to a specific destination, When the question mentions \"destination airport AHD\", When selecting airline information, When combining T1 and T2 for shared entities: link rows where T1.uid = T2.Airline exactly and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airline_name FROM airlines WHERE destination_airport = 'AHD';",
            "SELECT T1.Airline FROM airlines AS T1 JOIN flights AS T2 ON T1.uid = T2.Airline WHERE T2.DestAirport = 'AHD'"
        ],
        "rule_sql": [
            "SELECT T1.Airline FROM airlines T1 JOIN flights T2 ON T1.uid = T2.Airline WHERE T2.DestAirport = 'AHD'"
        ]
    },
    "237": {
        "db_id": "flight_2",
        "question": "Find all airlines that have flights from both airports 'APG' and 'CVO'.",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\" INTERSECT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\"",
        "amends": [
            "Do use `INTERSECT` to find airlines serving both airports instead of joining the same table twice with separate conditions. Do reference `T1.Airline` instead of `a.name` and use proper table aliases `T1` and `T2` instead of `a`, `f1`, and `f2`. Do join on `T1.uid = T2.Airline` instead of `a.id = f1.airline_id` and use `T2.SourceAirport` instead of `f1.departure_airport`. Do remove the `DISTINCT` keyword since `INTERSECT` inherently returns distinct results. Do structure the query as two separate `SELECT` statements combined with `INTERSECT` instead of a single query with multiple joins. The amended query now correctly identifies airlines that serve both APG and CVO airports using set intersection logic."
        ],
        "rules": [
            "When the question asks for airlines that serve both airports 'APG' and 'CVO': use INTERSECT to combine results from two separate queries instead of joining the same table multiple times.",
            "When referencing airline names: use the exact identifier \"T1.Airline\" instead of a.name.",
            "When joining tables: use the exact key equality \"T1.uid = T2.Airline\" instead of a.id = f1.airline_id.",
            "When filtering by departure airport: use the exact identifier \"T2.SourceAirport\" instead of f1.departure_airport and preserve the exact literals 'APG' and 'CVO' with proper case and quotes.",
            "When using INTERSECT: do not include DISTINCT keyword since INTERSECT inherently returns distinct results.",
            "When the question asks for airlines that serve both airports 'APG' and 'CVO', When referencing airline names, When joining tables, When filtering by departure airport, When using INTERSECT, When structuring the query: use two separate SELECT statements combined with INTERSECT instead of a single query with multiple joins."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT a.name \nFROM airlines a\nJOIN flights f1 ON a.id = f1.airline_id\nJOIN flights f2 ON a.id = f2.airline_id\nWHERE f1.departure_airport = 'APG' AND f2.departure_airport = 'CVO';",
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'APG'\nINTERSECT\nSELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'CVO'"
        ],
        "rule_sql": [
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'APG'\nINTERSECT\nSELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'CVO'"
        ]
    },
    "238": {
        "db_id": "flight_2",
        "question": "Which airlines have departing flights from both APG and CVO airports?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\" INTERSECT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\"",
        "amends": [
            "Do use `INTERSECT` to find airlines serving both airports instead of joining the same table twice with different conditions. Do select `T1.Airline` instead of `a.name` and use proper table aliases `T1` and `T2` instead of `a`, `f1`, and `f2`. Do join on `T1.uid = T2.Airline` instead of `a.id = f1.airline_id` and use `T2.SourceAirport` instead of `f1.departure_airport`. Do remove the `DISTINCT` modifier since `INTERSECT` inherently returns unique results instead of keeping it. Do use double quotes around airport codes \"APG\" and \"CVO\" instead of single quotes. The amended query now correctly identifies airlines that serve both specified airports using set intersection logic."
        ],
        "rules": [
            "When answering about airlines with departing flights from both APG and CVO airports: use INTERSECT logic to find airlines serving both airports instead of joining the same table twice.",
            "When selecting airline names: use T1.Airline instead of a.name.",
            "When combining airline and flight information: link rows where T1.uid = T2.Airline.",
            "When filtering by departure airport: use T2.SourceAirport instead of departure_airport.",
            "When specifying airport codes: use double quotes around \"APG\" and \"CVO\" instead of single quotes.",
            "When answering about airlines with departing flights from both APG and CVO airports, When selecting airline names, When combining airline and flight information, When filtering by departure airport, When specifying airport codes, When returning unique results: remove DISTINCT modifier since INTERSECT inherently returns unique results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT a.name \nFROM airlines a \nJOIN flights f1 ON a.id = f1.airline_id \nJOIN flights f2 ON a.id = f2.airline_id \nWHERE f1.departure_airport = 'APG' AND f2.departure_airport = 'CVO';",
            "SELECT T1.Airline FROM airlines T1 JOIN flights T2 ON T1.uid = T2.Airline WHERE T2.SourceAirport = \"APG\" INTERSECT SELECT T1.Airline FROM airlines T1 JOIN flights T2 ON T1.uid = T2.Airline WHERE T2.SourceAirport = \"CVO\""
        ],
        "rule_sql": [
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = \"APG\"\nINTERSECT\nSELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = \"CVO\""
        ]
    },
    "239": {
        "db_id": "flight_2",
        "question": "Find all airlines that have flights from airport 'CVO' but not from 'APG'.",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\" EXCEPT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\"",
        "amends": [
            "Do use `T1.uid = T2.Airline` for the join condition instead of `a.Airline_ID = f.Airline_ID`. Do use `T2.SourceAirport = \"CVO\"` instead of `f.Source_Airport = 'CVO'` with proper column naming and quote style. Do remove the contradictory `AND f.Source_Airport != 'APG'` filter instead of keeping it, as this logic is handled through the EXCEPT operation. Do add an EXCEPT clause to exclude airlines that also serve APG instead of using a single query with conflicting conditions. Do use table aliases `T1` and `T2` consistently instead of `a` and `f`. The amended query now correctly identifies airlines that serve CVO but not APG by using set operations instead of contradictory WHERE conditions, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When joining Airlines and Flights tables: use T1.uid = T2.Airline as the join condition instead of Airline_ID matching.",
            "When filtering for flights from airport CVO: use T2.SourceAirport = \"CVO\" with double quotes around the column name and exact literal value.",
            "When finding airlines that serve CVO but not APG: use an EXCEPT operation to exclude airlines that also serve APG instead of using contradictory WHERE conditions.",
            "When using table aliases: consistently use T1 for Airlines table and T2 for Flights table throughout the query.",
            "When joining Airlines and Flights tables, When filtering for flights from airport CVO, When finding airlines that serve CVO but not APG, When using table aliases, When handling airport codes: preserve the exact literal values 'CVO' and 'APG' with single quotes as shown in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT a.Airline FROM Airlines a JOIN Flights f ON a.Airline_ID = f.Airline_ID WHERE f.Source_Airport = 'CVO' AND f.Source_Airport != 'APG';",
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'CVO'\nEXCEPT\nSELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'APG'"
        ],
        "rule_sql": [
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = \"CVO\"\nEXCEPT\nSELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = \"APG\""
        ]
    },
    "240": {
        "db_id": "flight_2",
        "question": "Which airlines have departures from CVO but not from APG airports?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\" EXCEPT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\"",
        "amends": [
            "Do join `AIRLINES` and `FLIGHTS` tables on `T1.uid = T2.Airline` instead of querying only the `flights` table. Do filter for `SourceAirport = \"CVO\"` instead of `departure_airport = 'CVO'`. Do use `EXCEPT` to exclude airlines that also serve `\"APG\"` instead of the contradictory `departure_airport != 'APG'` condition. Do select `T1.Airline` from the joined result instead of `airline` directly from flights. Do remove the `DISTINCT` modifier since `EXCEPT` inherently returns unique results. The amended query now correctly identifies airlines that serve CVO but not APG, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When combining AIRLINES and FLIGHTS tables: link rows where T1.uid = T2.Airline and keep only matching pairs (inner match).",
            "When filtering for departures from CVO airport: use T2.SourceAirport = \"CVO\" instead of departure_airport = 'CVO'.",
            "When excluding airlines that serve APG airport: use EXCEPT to remove airlines that have T2.SourceAirport = \"APG\" instead of using a contradictory condition.",
            "When selecting airline names: use T1.Airline from the joined result instead of airline directly from flights.",
            "When combining AIRLINES and FLIGHTS tables, When filtering for departures from CVO airport, When excluding airlines that serve APG airport, When selecting airline names, When ensuring unique results: do not use DISTINCT modifier since EXCEPT inherently returns unique results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT airline FROM flights WHERE departure_airport = 'CVO' AND departure_airport != 'APG';",
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'CVO'\nEXCEPT\nSELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'APG'"
        ],
        "rule_sql": [
            "SELECT T1.Airline\nFROM airlines T1\nINNER JOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'CVO'\nEXCEPT\nSELECT T1.Airline\nFROM airlines T1\nINNER JOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'APG'"
        ]
    },
    "241": {
        "db_id": "flight_2",
        "question": "Find all airlines that have at least 10 flights.",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  10",
        "amends": [
            "Do add table `AIRLINES AS T1` and `FLIGHTS AS T2` in the FROM clause instead of only having `flights`. Do use `JOIN` with the predicate `T1.uid = T2.Airline` instead of no join condition. Do specify `T1.Airline` in the SELECT list instead of just `airline` to clarify the source table. The amended query now correctly joins the airlines and flights tables to count flights per airline and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"airlines that have at least 10 flights\": make sure the output order: T1.Airline.",
            "When the question mentions \"airlines\": \"airlines\" actually means \"T1.Airline in schema\".",
            "When combining T1 and T2 for shared entities: link rows where T1.uid = T2.Airline exactly as shown in the amends; keep only matching pairs (inner match).",
            "When the question asks for \"count of flights\": compute the number of rows using the canonical key token for flights (e.g., T2.Airline).",
            "When answering about \"airlines that have at least 10 flights\", When the question mentions \"airlines\", When combining T1 and T2 for shared entities, When the question asks for \"count of flights\", When the question says \"at least 10\": include only groups where the count is greater than 10."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airline FROM flights GROUP BY airline HAVING COUNT(*) > 10",
            "SELECT T1.Airline\nFROM airlines AS T1\nJOIN flights AS T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nHAVING COUNT(*) >= 10"
        ],
        "rule_sql": [
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nHAVING COUNT(T2.Airline) >= 10\nORDER BY T1.Airline"
        ]
    },
    "242": {
        "db_id": "flight_2",
        "question": "Which airlines have at least 10 flights?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  10",
        "amends": [
            "Do add a `FROM` clause with `AIRLINES AS T1` instead of omitting it, and do add a `JOIN` with `FLIGHTS AS T2` on `T1.uid = T2.Airline` instead of querying only the `flights` table. Do reference `T1.Airline` in the `SELECT` list instead of just `airline` to ensure the correct column from the joined table is selected. The amended query now correctly joins the airlines and flights tables to count flights per airline, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"airlines with at least 10 flights\": make sure the output order: T1.Airline",
            "When the question mentions \"airlines\": \"airlines\" actually means \"T1.Airline in schema\"",
            "When the question asks for \"count of flights\": compute the number of rows using the canonical key token for flights (e.g., T2.Airline).",
            "When combining T1 and T2 for shared entities: link rows where T1.uid = T2.Airline; keep only matching pairs (inner match).",
            "When answering about \"airlines with at least 10 flights\", When the question mentions \"airlines\", When the question asks for \"count of flights\", When combining T1 and T2 for shared entities, When the question asks for \"at least 10 flights\": ensure the count of flights per airline is greater than 10."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airline FROM flights GROUP BY airline HAVING COUNT(*) > 10;",
            "SELECT T1.Airline\nFROM airlines AS T1\nJOIN flights AS T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nHAVING COUNT(*) >= 10"
        ],
        "rule_sql": [
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nHAVING COUNT(T2.Airline) >= 10\nORDER BY T1.Airline"
        ]
    },
    "243": {
        "db_id": "flight_2",
        "question": "Find all airlines that have fewer than 200 flights.",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200",
        "amends": [
            "Do add a `JOIN` between `AIRLINES` and `FLIGHTS` on `T1.uid = T2.Airline` instead of querying only the `flights` table. Do reference `T1.Airline` in the SELECT list instead of just `airline` from the flights table. Do change the HAVING condition to `count(*) < 200` instead of `COUNT(*) > 200` to filter for airlines with fewer than 200 flights rather than more than 200. The amended query now correctly joins the airlines table to access airline information and filters for airlines with less than 200 flights, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"airlines that have fewer than 200 flights\": make sure the output order: T1.Airline",
            "When combining AIRLINES (T1) and FLIGHTS (T2) for shared entities: link rows where T1.uid = T2.Airline exactly as shown in the amends; keep only matching pairs (inner match)",
            "When the question asks for \"count of flights\": compute the number of rows using the canonical key from FLIGHTS table",
            "When filtering for airlines with fewer than 200 flights: apply the condition count(*) < 200 to filter groups",
            "When answering about \"airlines that have fewer than 200 flights\", When combining AIRLINES (T1) and FLIGHTS (T2) for shared entities, When the question asks for \"count of flights\", When filtering for airlines with fewer than 200 flights, When grouping by airline: organize results by T1.Airline and compute requested aggregates per group"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airline FROM flights GROUP BY airline HAVING COUNT(*) > 200;",
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nHAVING COUNT(*) < 200"
        ],
        "rule_sql": [
            "SELECT T1.Airline\nFROM airlines T1\nINNER JOIN flights T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nHAVING COUNT(*) < 200\nORDER BY T1.Airline"
        ]
    },
    "244": {
        "db_id": "flight_2",
        "question": "Which airlines have less than 200 flights?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200",
        "amends": [
            "Do add table `AIRLINES AS T1` and join it with `FLIGHTS AS T2` using `ON T1.uid = T2.Airline` instead of querying only the `flights` table without proper joins. Do move the aggregate filter to `HAVING count(*) < 200` instead of placing it in the `WHERE` clause where aggregate functions cannot be used. Do select `T1.Airline` from the joined airlines table instead of selecting `airline` directly from the flights table without proper table qualification. The amended query now correctly joins the airlines and flights tables and properly filters aggregated results using HAVING, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"airlines with less than 200 flights\": make sure the output order: T1.Airline",
            "When the question mentions \"airlines\": \"airlines\" actually means \"T1.Airline in schema\"",
            "When the question asks for \"count of flights\": compute the number of rows using the canonical key token for flights (T2.Airline)",
            "When combining T1 and T2 for shared entities: link rows where T1.uid = T2.Airline exactly as shown in the amends; keep only matching pairs (inner match)",
            "When the question says \"per airline\"/\"by airline\": organize results by T1.Airline and compute count of flights per group",
            "When answering about \"airlines with less than 200 flights\", When the question mentions \"airlines\", When the question asks for \"count of flights\", When combining T1 and T2 for shared entities, When the question says \"per airline\"/\"by airline\", When filtering aggregated results: apply the condition count(*) < 200 after grouping instead of before grouping"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airline FROM flights WHERE COUNT(*) < 200 GROUP BY airline",
            "SELECT T1.Airline\nFROM airlines AS T1\nJOIN flights AS T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nHAVING COUNT(*) < 200"
        ],
        "rule_sql": [
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nHAVING COUNT(*) < 200\nORDER BY T1.Airline"
        ]
    },
    "245": {
        "db_id": "flight_2",
        "question": "What are flight numbers of Airline \"United Airlines\"?",
        "ground_truth": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  \"United Airlines\"",
        "amends": [
            "Do join `AIRLINES` as `T2` on `T2.uid = T1.Airline` instead of querying only the `flights` table. Do reference `T1.FlightNo` instead of `flight_number` and filter on `T2.Airline = \"United Airlines\"` instead of `airline = 'Delta Airlines'`. The amended query now correctly joins to the airlines table to filter by airline name rather than assuming the airline name is stored directly in the flights table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about flight numbers of an airline: make sure the output order: T1.FlightNo",
            "When the question mentions \"United Airlines\": \"United Airlines\" actually means T2.Airline = \"United Airlines\" in schema",
            "When combining T1 and T2 for shared entities: link rows where T2.uid = T1.Airline and keep only matching pairs (inner match)",
            "When answering about flight numbers of an airline, When the question mentions \"United Airlines\", When combining T1 and T2 for shared entities, When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for identifiers like \"United Airlines\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE airline = 'Delta Airlines';",
            "SELECT T1.FlightNo FROM flights T1 JOIN airlines T2 ON T2.uid = T1.Airline WHERE T2.Airline = 'United Airlines'"
        ],
        "rule_sql": [
            "SELECT T1.FlightNo FROM flights T1 INNER JOIN airlines T2 ON T2.uid = T1.Airline WHERE T2.Airline = \"United Airlines\""
        ]
    },
    "246": {
        "db_id": "flight_2",
        "question": "Which flight numbers correspond to United Airlines flights?",
        "ground_truth": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  \"United Airlines\"",
        "amends": [
            "Do join `AIRLINES` as `T2` on `T2.uid = T1.Airline` instead of querying only the `flights` table. Do filter on `T2.Airline = \"United Airlines\"` instead of `airline = 'Delta Airlines'`. Do select `T1.FlightNo` instead of `flight_number`. The amended query now correctly joins the airlines table to filter by airline name using the proper relationship and returns the appropriate flight number column."
        ],
        "rules": [
            "When answering about flight numbers for United Airlines flights: make sure the output order: T1.FlightNo.",
            "When the question mentions \"United Airlines\": \"United Airlines\" actually means T2.Airline = \"United Airlines\" in schema.",
            "When combining T1 and T2 for shared entities: link rows where T2.uid = T1.Airline exactly as shown in the amends; keep only matching pairs (inner match).",
            "When answering about flight numbers for United Airlines flights, When the question mentions \"United Airlines\", When combining T1 and T2 for shared entities, When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE airline = 'Delta Airlines';",
            "SELECT T1.FlightNo \nFROM flights T1 \nJOIN airlines T2 ON T2.uid = T1.Airline \nWHERE T2.Airline = 'United Airlines'"
        ],
        "rule_sql": [
            "SELECT T1.FlightNo FROM flights T1 INNER JOIN airlines T2 ON T2.uid = T1.Airline WHERE T2.Airline = \"United Airlines\""
        ]
    },
    "247": {
        "db_id": "flight_2",
        "question": "What are flight numbers of flights departing from Airport \"APG\"?",
        "ground_truth": "SELECT FlightNo FROM FLIGHTS WHERE SourceAirport  =  \"APG\"",
        "amends": [
            "Do reference column `FlightNo` instead of `flight_number` in the SELECT list. Do reference table `FLIGHTS` instead of `flights` in the FROM clause. Do use filter condition `SourceAirport = \"APG\"` instead of `departure_airport = 'APG'` in the WHERE clause. The amended query now correctly retrieves flight numbers from the FLIGHTS table where the source airport matches APG, using the proper column names and table reference as specified in the RIGHT_SQL."
        ],
        "rules": [
            "When answering about flight numbers: use column \"FlightNo\" from table \"FLIGHTS\" as the output column.",
            "When the question mentions \"departing from Airport\": this corresponds to filtering where column \"SourceAirport\" equals the exact literal \"APG\".",
            "When answering about flight numbers, When the question mentions \"departing from Airport\", When selecting from the flights table: use the exact table name \"FLIGHTS\" with proper case and quoting as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_airport = 'APG';",
            "SELECT FlightNo FROM FLIGHTS WHERE SourceAirport = \"APG\""
        ],
        "rule_sql": [
            "SELECT \"FlightNo\" FROM \"FLIGHTS\" WHERE \"SourceAirport\" = 'APG'"
        ]
    },
    "248": {
        "db_id": "flight_2",
        "question": "Give the flight numbers of flights leaving from APG.",
        "ground_truth": "SELECT FlightNo FROM FLIGHTS WHERE SourceAirport  =  \"APG\"",
        "amends": [
            "Do reference column `FlightNo` instead of `flight_number` in the SELECT list. Do reference table `FLIGHTS` instead of `flights` in the FROM clause. Do use filter condition `SourceAirport = \"APG\"` instead of `departure_airport = 'APG'` in the WHERE clause. The amended query now correctly matches the RIGHT_SQL's behavior with proper column and table references."
        ],
        "rules": [
            "When answering about \"flight numbers of flights leaving from APG\": make sure the output order: FlightNo.",
            "When the question mentions \"flight numbers\": \"flight numbers\" actually means \"FlightNo in schema\".",
            "When the question mentions \"leaving from APG\": \"leaving from APG\" actually means \"SourceAirport = \\\"APG\\\" in schema\".",
            "When answering about \"flight numbers of flights leaving from APG\", When the question mentions \"flight numbers\", When the question mentions \"leaving from APG\", When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for identifiers like \\\"APG\\\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_airport = 'APG';",
            "SELECT FlightNo FROM FLIGHTS WHERE SourceAirport = \"APG\""
        ],
        "rule_sql": [
            "SELECT FlightNo FROM flights WHERE SourceAirport = \"APG\" ORDER BY FlightNo;"
        ]
    },
    "249": {
        "db_id": "flight_2",
        "question": "What are flight numbers of flights arriving at Airport \"APG\"?",
        "ground_truth": "SELECT FlightNo FROM FLIGHTS WHERE DestAirport  =  \"APG\"",
        "amends": [
            "Do reference column `FlightNo` instead of `flight_number` in the SELECT list. Do reference table `FLIGHTS` instead of `flights` in the FROM clause. Do use filter condition `DestAirport = \"APG\"` instead of `departure_airport = 'APG'` in the WHERE clause, changing the column reference from departure airport to destination airport. The amended query now correctly filters for flights with destination airport APG instead of departure airport APG, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for flight numbers: use the exact column token \"FlightNo\" from the FLIGHTS table.",
            "When the question mentions flights arriving at an airport: filter using the destination airport column \"DestAirport\" instead of departure airport.",
            "When filtering for airport \"APG\": use the exact literal value \"APG\" with double quotes as shown in the schema.",
            "When the question asks for flight numbers, When the question mentions flights arriving at an airport, When filtering for airport \"APG\", When referencing the flights table: use the exact table name \"FLIGHTS\" with uppercase letters as specified in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_airport = 'APG';",
            "SELECT FlightNo FROM FLIGHTS WHERE DestAirport = \"APG\""
        ],
        "rule_sql": [
            "SELECT FlightNo FROM FLIGHTS WHERE DestAirport = \"APG\""
        ]
    },
    "250": {
        "db_id": "flight_2",
        "question": "Give the flight numbers of flights landing at APG.",
        "ground_truth": "SELECT FlightNo FROM FLIGHTS WHERE DestAirport  =  \"APG\"",
        "amends": [
            "Do reference column `FlightNo` instead of `flight_number` in the SELECT list. Do reference table `FLIGHTS` instead of `flights` in the FROM clause. Do use filter condition `DestAirport = 'APG'` instead of `departure_airport = 'APG'` in the WHERE clause. The amended query now correctly selects flight numbers based on destination airport rather than departure airport, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"flight numbers of flights landing at APG\": make sure the output order: \"FlightNo\".",
            "When the question mentions \"flight numbers\": \"flight numbers\" actually means \"FlightNo\" in schema.",
            "When the question mentions \"landing at APG\": \"landing at APG\" actually means \"DestAirport = 'APG'\" in schema.",
            "When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms.",
            "When answering about \"flight numbers of flights landing at APG\", When the question mentions \"flight numbers\", When the question mentions \"landing at APG\", When choosing identifier delimiters, When handling text literals: do not change case, spacing, or punctuation of 'APG'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_airport = 'APG';",
            "SELECT FlightNo FROM FLIGHTS WHERE DestAirport = 'APG'"
        ],
        "rule_sql": [
            "SELECT FlightNo FROM flights WHERE DestAirport = 'APG' ORDER BY FlightNo;"
        ]
    },
    "251": {
        "db_id": "flight_2",
        "question": "What are flight numbers of flights departing from City \"Aberdeen \"?",
        "ground_truth": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.SourceAirport   =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"",
        "amends": [
            "Do add `JOIN AIRPORTS AS T2 ON T1.SourceAirport = T2.AirportCode` instead of querying `flights` table directly. Do change the column reference to `T1.FlightNo` instead of `flight_number`. Do change the filter condition to `T2.City = \"Aberdeen\"` instead of `departure_city = 'Aberdeen'`, which correctly joins through the airports table to find flights departing from Aberdeen city rather than relying on a potentially incorrect or non-existent departure_city column. The amended query now properly correlates flights with their source airport's city information to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"flight numbers of flights departing from City 'Aberdeen '\": make sure the output order: T1.FlightNo.",
            "When the question mentions \"departing from City 'Aberdeen '\": \"City 'Aberdeen '\" actually means \"T2.City = 'Aberdeen'\" in schema.",
            "When combining T1 (flights) and T2 (AIRPORTS) for shared entities: link rows where T1.SourceAirport = T2.AirportCode exactly as shown in the amends; keep only matching pairs (inner match).",
            "When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for identifiers like \"T1.SourceAirport\" and \"T2.AirportCode\".",
            "When answering about \"flight numbers of flights departing from City 'Aberdeen '\", When the question mentions \"departing from City 'Aberdeen '\", When combining T1 (flights) and T2 (AIRPORTS) for shared entities, When choosing identifier delimiters, When handling text literals: do not change case, spacing, or punctuation for 'Aberdeen'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_city = 'Aberdeen'",
            "SELECT T1.FlightNo FROM flights AS T1 JOIN airports AS T2 ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ],
        "rule_sql": [
            "SELECT T1.FlightNo FROM flights T1 INNER JOIN airports T2 ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ]
    },
    "252": {
        "db_id": "flight_2",
        "question": "Give the flight numbers of flights leaving from Aberdeen.",
        "ground_truth": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.SourceAirport   =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"",
        "amends": [
            "Do add `JOIN AIRPORTS AS T2` with `ON T1.SourceAirport = T2.AirportCode` instead of querying `flights` table alone. Do reference `T2.City` in the WHERE clause instead of directly filtering on `departure_city`. Do use table alias `T1.FlightNo` instead of `flight_number` column name. The amended query now correctly joins airport data to filter by city name instead of assuming departure city is stored directly in the flights table, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"flights leaving from Aberdeen\": make sure the output order: T1.FlightNo.",
            "When the question mentions \"Aberdeen\": \"Aberdeen\" actually means \"T2.City = 'Aberdeen'\" in schema.",
            "When combining T1 and T2 for shared entities: link rows where T1.SourceAirport = T2.AirportCode exactly as shown in the amends; keep only matching pairs (inner match).",
            "When answering about \"flights leaving from Aberdeen\", When the question mentions \"Aberdeen\", When combining T1 and T2 for shared entities, When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for T1.FlightNo, T1.SourceAirport, T2.AirportCode, and T2.City."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_city = 'Aberdeen';",
            "SELECT T1.FlightNo FROM flights AS T1 JOIN airports AS T2 ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ],
        "rule_sql": [
            "SELECT T1.FlightNo FROM flights T1 INNER JOIN airports T2 ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen' ORDER BY T1.FlightNo"
        ]
    },
    "253": {
        "db_id": "flight_2",
        "question": "What are flight numbers of flights arriving at City \"Aberdeen\"?",
        "ground_truth": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport   =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"",
        "amends": [
            "Do add `JOIN AIRPORTS AS T2 ON T1.DestAirport = T2.AirportCode` instead of querying only the `flights` table. Do change the filter to `T2.City = \"Aberdeen\"` instead of `departure_city = 'Aberdeen'` since we need to join with airports to get the city information. Do use `T1.FlightNo` with proper table alias instead of `flight_number` without qualification. The amended query now correctly finds flights destined for Aberdeen by joining with the airports table to match on city rather than incorrectly filtering on a departure city column that may not exist or contain the correct data."
        ],
        "rules": [
            "When answering about \"flights arriving at City 'Aberdeen'\": make sure to join the flights table (T1) with the airports table (T2) using T1.DestAirport = T2.AirportCode to get city information.",
            "When the question mentions \"arriving at City 'Aberdeen'\": filter for T2.City = \"Aberdeen\" exactly as specified.",
            "When the question asks for \"flight numbers\": output T1.FlightNo with the exact table alias T1.",
            "When answering about \"flights arriving at City 'Aberdeen'\", When the question mentions \"arriving at City 'Aberdeen'\", When the question asks for \"flight numbers\", When combining T1 and T2 for shared entities: link rows where T1.DestAirport = T2.AirportCode exactly as shown in the amends; keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_city = 'Aberdeen';",
            "SELECT T1.FlightNo FROM flights AS T1 JOIN airports AS T2 ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ],
        "rule_sql": [
            "SELECT T1.FlightNo FROM flights T1 JOIN airports T2 ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ]
    },
    "254": {
        "db_id": "flight_2",
        "question": "Give the flight numbers of flights arriving in Aberdeen.",
        "ground_truth": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport   =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"",
        "amends": [
            "Do add `JOIN AIRPORTS AS T2 ON T1.DestAirport = T2.AirportCode` instead of querying only the `flights` table. Do change the column reference to `T1.FlightNo` instead of `flight_number`. Do move the filter condition to `T2.City = \"Aberdeen\"` instead of `departure_city = 'Aberdeen'` to correctly filter by destination city rather than departure city. The amended query now properly joins the flights and airports tables to find flights destined for Aberdeen, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about flights arriving in a city: join the flights table (T1) with the airports table (T2) using T1.DestAirport = T2.AirportCode to match destination airports.",
            "When the question mentions \"flight numbers\": use the exact column T1.FlightNo instead of flight_number.",
            "When answering about flights arriving in a city, When the question mentions \"flight numbers\", When filtering for flights arriving in Aberdeen: use the exact literal \"Aberdeen\" with T2.City = \"Aberdeen\" to filter by destination city rather than departure city."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_city = 'Aberdeen';",
            "SELECT T1.FlightNo \nFROM flights AS T1 \nJOIN airports AS T2 ON T1.DestAirport = T2.AirportCode \nWHERE T2.City = 'Aberdeen'"
        ],
        "rule_sql": [
            "SELECT T1.FlightNo \nFROM flights T1 \nJOIN airports T2 ON T1.DestAirport = T2.AirportCode \nWHERE T2.City = 'Aberdeen'"
        ]
    },
    "255": {
        "db_id": "flight_2",
        "question": "Find the number of flights landing in the city of Aberdeen or Abilene.",
        "ground_truth": "SELECT count(*) FROM Flights AS T1 JOIN Airports AS T2 ON T1.DestAirport  =  T2.AirportCode WHERE T2.city  =  \"Aberdeen\" OR T2.city  =  \"Abilene\"",
        "amends": [
            "Do add `JOIN Airports AS T2 ON T1.DestAirport = T2.AirportCode` instead of querying only the flights table. Do change the filter to `T2.city = \"Aberdeen\" OR T2.city = \"Abilene\"` instead of `departure_city IN ('Aberdeen', 'Abilene')` to correctly reference the joined airports table's city column rather than a non-existent departure_city column. Do remove the incorrect direct column reference and instead filter through the proper join relationship between flights and airports tables. The amended query now correctly counts flights destined for Aberdeen or Abilene by joining with the airports table to match on city names through airport codes."
        ],
        "rules": [
            "When answering about flights landing in specific cities: join the flights table (T1) with the airports table (T2) using T1.DestAirport = T2.AirportCode to connect flight destinations to airport information.",
            "When the question mentions cities \"Aberdeen\" or \"Abilene\": filter using T2.city = \"Aberdeen\" OR T2.city = \"Abilene\" with exact case and spelling.",
            "When answering about flights landing in specific cities, When the question mentions cities \"Aberdeen\" or \"Abilene\", When counting flights: count all rows from the joined result that match the city filter condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE departure_city IN ('Aberdeen', 'Abilene');",
            "SELECT COUNT(*) \nFROM flights AS T1\nJOIN airports AS T2 ON T1.DestAirport = T2.AirportCode\nWHERE T2.City = 'Aberdeen' OR T2.City = 'Abilene'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM flights T1\nJOIN airports T2 ON T1.DestAirport = T2.AirportCode\nWHERE T2.City = 'Aberdeen' OR T2.City = 'Abilene'"
        ]
    },
    "256": {
        "db_id": "flight_2",
        "question": "How many flights land in Aberdeen or Abilene?",
        "ground_truth": "SELECT count(*) FROM Flights AS T1 JOIN Airports AS T2 ON T1.DestAirport  =  T2.AirportCode WHERE T2.city  =  \"Aberdeen\" OR T2.city  =  \"Abilene\"",
        "amends": [
            "Do add `JOIN Airports AS T2 ON T1.DestAirport = T2.AirportCode` instead of querying only the `flights` table. Do change the filter to `T2.city = \"Aberdeen\" OR T2.city = \"Abilene\"` instead of the impossible condition `destination = 'Aberdeen' AND destination = 'Abilene'`. Do use table alias `T1` for `Flights` and `T2` for `Airports` instead of no aliases. The amended query now correctly joins flights with airports and filters by city names instead of attempting to match a single destination to two different values simultaneously, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"flights landing in Aberdeen or Abilene\": make sure to join Flights as T1 with Airports as T2 using T1.DestAirport = T2.AirportCode instead of querying only the flights table.",
            "When the question mentions \"Aberdeen\" or \"Abilene\": these city names actually mean T2.city = \"Aberdeen\" OR T2.city = \"Abilene\" in the schema, not destination = 'Aberdeen' AND destination = 'Abilene'.",
            "When combining T1 and T2 for shared entities: link rows where T1.DestAirport = T2.AirportCode exactly as shown in the amends; keep only matching pairs (inner match).",
            "When answering about \"flights landing in Aberdeen or Abilene\", When the question mentions \"Aberdeen\" or \"Abilene\", When combining T1 and T2 for shared entities, When the question asks for \"count of flights\": compute the number of rows using the canonical key for flights."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE destination = 'Aberdeen' AND destination = 'Abilene';",
            "SELECT COUNT(*) FROM flights AS T1 JOIN airports AS T2 ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen' OR T2.City = 'Abilene'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM flights AS T1 \nJOIN airports AS T2 ON T1.DestAirport = T2.AirportCode \nWHERE T2.City = 'Aberdeen' OR T2.City = 'Abilene'"
        ]
    },
    "257": {
        "db_id": "flight_2",
        "question": "Find the name of airports which do not have any flight in and out.",
        "ground_truth": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)",
        "amends": [
            "Do reference `AirportName` instead of `name` and `AirportCode` instead of `airport_id` in the SELECT clause and WHERE condition. Do use `SourceAirport` instead of `departure_airport` and `DestAirport` instead of `arrival_airport` in the subquery. Do combine the two NOT IN subqueries into a single UNION operation instead of separate subqueries, which improves efficiency by scanning the Flights table only once. Do reference the correct table names `Airports` and `Flights` with proper capitalization instead of lowercase table names. The amended query now correctly identifies airports that have never been used as either source or destination in any flight, matching the intended behavior."
        ],
        "rules": [
            "When answering about airports without flights: use \"AirportName\" instead of \"name\" in the SELECT clause.",
            "When identifying airports by their code: use \"AirportCode\" instead of \"airport_id\" in the WHERE condition.",
            "When checking for departure airports in flights: use \"SourceAirport\" instead of \"departure_airport\".",
            "When checking for arrival airports in flights: use \"DestAirport\" instead of \"arrival_airport\".",
            "When combining flight departure and arrival checks: use a single UNION operation instead of separate subqueries to scan the Flights table only once.",
            "When referencing table names: use \"Airports\" and \"Flights\" with proper capitalization instead of lowercase names.",
            "When answering about airports without flights, When identifying airports by their code, When checking for departure airports in flights, When checking for arrival airports in flights, When combining flight departure and arrival checks, When referencing table names, When finding airports without any flights: check that \"AirportCode\" is not in the combined set of \"SourceAirport\" and \"DestAirport\" values from the Flights table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM airports WHERE airport_id NOT IN (SELECT departure_airport FROM flights) AND airport_id NOT IN (SELECT arrival_airport FROM flights);",
            "SELECT AirportName \nFROM airports \nWHERE AirportCode NOT IN (\n    SELECT SourceAirport FROM flights\n    UNION\n    SELECT DestAirport FROM flights\n)"
        ],
        "rule_sql": [
            "SELECT AirportName FROM airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)"
        ]
    },
    "258": {
        "db_id": "flight_2",
        "question": "Which airports do not have departing or arriving flights?",
        "ground_truth": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)",
        "amends": [
            "Do select `AirportName` instead of `*` and use table alias `Airports` instead of `airports`. Do use column `AirportCode` instead of `airport_id` for the main filter. Do combine the two subqueries into a single `UNION` operation selecting `SourceAirport` and `DestAirport` instead of separate `NOT IN` clauses with `departure_airport` and `arrival_airport`. Do reference table `Flights` instead of `flights` with proper capitalization. The amended query now correctly identifies airports not used as either source or destination in any flight by using UNION to combine both airport types in a single subquery."
        ],
        "rules": [
            "When answering about airports without departing or arriving flights: select \"AirportName\" from \"Airports\" instead of all columns.",
            "When filtering airports by flight activity: use \"AirportCode\" as the main filter key instead of airport_id.",
            "When checking for unused airports: combine both source and destination airport checks into a single UNION operation selecting \"SourceAirport\" and \"DestAirport\" from \"Flights\" instead of separate NOT IN clauses.",
            "When referencing table names: use exact capitalization \"Airports\" and \"Flights\" as shown in the schema.",
            "When answering about airports without departing or arriving flights, When filtering airports by flight activity, When checking for unused airports, When referencing table names, When identifying airports not used in flights: find airports where \"AirportCode\" is not present in the combined set of \"SourceAirport\" and \"DestAirport\" values from \"Flights\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM airports WHERE airport_id NOT IN (SELECT departure_airport FROM flights) AND airport_id NOT IN (SELECT arrival_airport FROM flights);",
            "SELECT AirportName FROM airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM flights UNION SELECT DestAirport FROM flights)"
        ],
        "rule_sql": [
            "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)"
        ]
    },
    "259": {
        "db_id": "employee_hire_evaluation",
        "question": "How many employees are there?",
        "ground_truth": "SELECT count(*) FROM employee",
        "amends": [
            "Do reference the `employee` table instead of the `customers` table in the FROM clause, changing the source data being queried. The amended query now correctly counts records from the employee table instead of the customers table, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"how many employees\": make sure to count records from the \"employee\" table instead of the \"customers\" table.",
            "When answering about \"how many employees\", When counting entities: use the canonical counting method for all records in the specified table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers;",
            "SELECT COUNT(*) FROM employee;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM employee;"
        ]
    },
    "260": {
        "db_id": "employee_hire_evaluation",
        "question": "Count the number of employees",
        "ground_truth": "SELECT count(*) FROM employee",
        "amends": [
            "Do reference the `employee` table instead of `employees` to match the correct table name. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency with the right SQL. Do remove the `WHERE department = 'Sales'` filter instead of keeping it since the right query counts all employees without department filtering. The amended query now matches the right SQL's behavior of counting all records in the employee table."
        ],
        "rules": [
            "When the question asks to count employees: use the table name \"employee\" exactly as specified in the schema, not \"employees\".",
            "When counting all records in a table: do not apply any WHERE clause filters unless explicitly specified in the question.",
            "When the question asks to count employees, When counting all records in a table, When writing SQL functions: use lowercase \"count(*)\" for consistency with the correct SQL dialect shown in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE department = 'Sales';",
            "SELECT count(*) FROM employee"
        ],
        "rule_sql": [
            "SELECT count(*) FROM employee;"
        ]
    },
    "261": {
        "db_id": "employee_hire_evaluation",
        "question": "Sort employee names by their age in ascending order.",
        "ground_truth": "SELECT name FROM employee ORDER BY age",
        "amends": [
            "Do reference table `employee` instead of `employees` in the FROM clause. Do use ascending ORDER BY `age` instead of descending ORDER BY `age DESC`. The amended query now correctly references the single employee table and sorts by age in ascending order instead of descending order."
        ],
        "rules": [
            "When the question asks to sort employee names by age in ascending order: use ORDER BY age ASC instead of DESC.",
            "When the question asks to sort employee names by age in ascending order, When referencing the employee table: use the exact table name \"employee\" instead of \"employees\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM employees ORDER BY age DESC;",
            "SELECT Name FROM employee ORDER BY Age ASC;"
        ],
        "rule_sql": [
            "SELECT Name FROM employee ORDER BY Age ASC;"
        ]
    },
    "262": {
        "db_id": "employee_hire_evaluation",
        "question": "List the names of employees and sort in ascending order of age.",
        "ground_truth": "SELECT name FROM employee ORDER BY age",
        "amends": [
            "Do reference table `employee` instead of `employees` in the FROM clause. Do use ascending ORDER BY `age` instead of descending ORDER BY `age DESC`. The amended query now correctly references the single employee table and sorts by age in ascending order instead of descending order."
        ],
        "rules": [
            "When the question asks for employee names: use the exact table name \"employee\" instead of \"employees\" as shown in the schema.",
            "When the question asks for employee names, When the question specifies sorting in ascending order of age: use ascending order for the \"age\" column instead of descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM employees ORDER BY age DESC;",
            "SELECT Name FROM employee ORDER BY Age ASC;"
        ],
        "rule_sql": [
            "SELECT Name FROM employee ORDER BY Age ASC;"
        ]
    },
    "263": {
        "db_id": "employee_hire_evaluation",
        "question": "What is the number of employees from each city?",
        "ground_truth": "SELECT count(*) ,  city FROM employee GROUP BY city",
        "amends": [
            "Do place `city` after `count(*)` in the SELECT list instead of before it. Do use the correct table name `employee` instead of `employees` in the FROM clause. The amended query now correctly counts employees by city using the proper table reference and column ordering."
        ],
        "rules": [
            "When the question asks for \"number of employees from each city\": organize results by the token for \"city\" and compute the count of employees per group.",
            "When producing output columns: place the count result before the city column in the output order.",
            "When the question asks for \"number of employees from each city\", When producing output columns, When referring to the employee table: use the exact table name \"employee\" instead of \"employees\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, COUNT(*) FROM employees GROUP BY city;",
            "SELECT COUNT(*), City FROM employee GROUP BY City;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS employee_count, City FROM employee GROUP BY City;"
        ]
    },
    "264": {
        "db_id": "employee_hire_evaluation",
        "question": "Count the number of employees for each city.",
        "ground_truth": "SELECT count(*) ,  city FROM employee GROUP BY city",
        "amends": [
            "Do place `city` after `count(*)` in the SELECT list instead of before it. Do use table name `employee` instead of `employees` in the FROM clause. The amended query now correctly counts employees by city using the proper table reference and column ordering."
        ],
        "rules": [
            "When the question asks for \"count of employees for each city\": organize results by the exact token \"city\" and compute the count using the canonical key for employees.",
            "When producing output columns: place the count result before the city column in the output order.",
            "When the question asks for \"count of employees for each city\", When producing output columns, When referring to the employee table: use the exact table name \"employee\" (not \"employees\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, COUNT(*) FROM employees GROUP BY city;",
            "SELECT COUNT(*), City FROM employee GROUP BY City;"
        ],
        "rule_sql": [
            "SELECT COUNT(Employee_ID) AS employee_count, City FROM employee GROUP BY City;"
        ]
    },
    "265": {
        "db_id": "employee_hire_evaluation",
        "question": "Which cities do more than one employee under age 30 come from?",
        "ground_truth": "SELECT city FROM employee WHERE age  <  30 GROUP BY city HAVING count(*)  >  1",
        "amends": [
            "Do reference the table as `employee` instead of `employees` to match the correct table name. Do maintain the exact same query structure with `SELECT city`, `WHERE age < 30`, `GROUP BY city`, and `HAVING count(*) > 1` as the logic remains identical. The amended query now correctly references the intended table while preserving all filtering, grouping, and aggregation behavior to match the RIGHT_SQL's output."
        ],
        "rules": [
            "When referencing the employee data table: use the exact table name \"employee\" (singular) instead of \"employees\" (plural).",
            "When filtering for employees under age 30: use the condition age < 30.",
            "When grouping results by city: use the column \"city\" for grouping.",
            "When counting employees per city: use count(*) to count all rows in each group.",
            "When filtering for cities with more than one employee: use the condition count(*) > 1 in the HAVING clause.",
            "When referencing the employee data table, When filtering for employees under age 30, When grouping results by city, When counting employees per city, When filtering for cities with more than one employee, When selecting output columns: include only the \"city\" column in the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city FROM employees WHERE age < 30 GROUP BY city HAVING COUNT(*) > 1",
            "SELECT city FROM employee WHERE age < 30 GROUP BY city HAVING count(*) > 1"
        ],
        "rule_sql": [
            "SELECT city FROM employee WHERE age < 30 GROUP BY city HAVING COUNT(*) > 1;"
        ]
    },
    "266": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the cities that have more than one employee under age 30.",
        "ground_truth": "SELECT city FROM employee WHERE age  <  30 GROUP BY city HAVING count(*)  >  1",
        "amends": [
            "Do reference table `employee` instead of `employees` in the FROM clause, as the correct table name is singular. Do maintain the same SELECT list with `city`, WHERE filter with `age < 30`, GROUP BY clause with `city`, and HAVING condition with `count(*) > 1` without any changes to the logic or structure. The amended query now matches RIGHT_SQL's behavior with the corrected table reference."
        ],
        "rules": [
            "When the question asks about \"employees\": use the exact table name \"employee\" (singular form) instead of \"employees\".",
            "When filtering for employees under age 30: use the condition \"age < 30\" exactly as specified.",
            "When grouping results by city: use the column \"city\" for grouping.",
            "When counting employees per city: use count(*) to count all rows in each group.",
            "When filtering groups to show cities with more than one employee: use the condition \"count(*) > 1\" to only include cities with multiple employees.",
            "When the question asks about \"employees\", When filtering for employees under age 30, When grouping results by city, When counting employees per city, When filtering groups to show cities with more than one employee, When selecting output columns: include only \"city\" in the result set."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city FROM employees WHERE age < 30 GROUP BY city HAVING COUNT(*) > 1",
            "SELECT city FROM employee WHERE age < 30 GROUP BY city HAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT city FROM employee WHERE age < 30 GROUP BY city HAVING COUNT(*) > 1;"
        ]
    },
    "267": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the number of shops in each location.",
        "ground_truth": "SELECT count(*) ,  LOCATION FROM shop GROUP BY LOCATION",
        "amends": [
            "Do select `count(*)` and `LOCATION` instead of `location` and `COUNT(*)`. Do use `GROUP BY LOCATION` instead of `GROUP BY shop_id`. Do reference table `shop` instead of `shops`. The amended query now correctly groups by location and counts records per location rather than incorrectly grouping by shop_id while selecting location.",
            "Do place the `count(*)` column before `LOCATION` in the SELECT list instead of having `LOCATION` first. Do maintain the same GROUP BY clause with `LOCATION` and keep the same table source and aggregation logic. The amended query now correctly matches the RIGHT_SQL's column ordering while preserving identical result behavior."
        ],
        "rules": [
            "When the question asks for \"number of shops in each location\": select \"LOCATION\" and count all rows per location group.",
            "When grouping by location: use \"GROUP BY LOCATION\" instead of grouping by shop_id.",
            "When referencing the shops table: use the exact table name \"shop\" instead of \"shops\".",
            "When the question asks for \"number of shops in each location\", When grouping by location, When referencing the shops table, When counting shops: use count(*) to count all records in each location group.",
            "When answering about \"number of shops in each location\": make sure the output order: count(*) column first, then LOCATION column.",
            "When the question asks for \"number of shops\": compute the count of all rows using count(*).",
            "When answering about \"number of shops in each location\", When the question asks for \"number of shops\", When the question says \"in each location\": organize results by the LOCATION column and compute the count per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location, COUNT(*) FROM shops GROUP BY shop_id;",
            "SELECT LOCATION, COUNT(*) FROM shop GROUP BY LOCATION;",
            "SELECT count(*), LOCATION FROM shop GROUP BY LOCATION"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS shop_count, Location FROM shop GROUP BY Location;"
        ]
    },
    "268": {
        "db_id": "employee_hire_evaluation",
        "question": "How many shops are there in each location?",
        "ground_truth": "SELECT count(*) ,  LOCATION FROM shop GROUP BY LOCATION",
        "amends": [
            "Do select `count(*)` and `LOCATION` instead of `location` and `COUNT(*)`. Do use `GROUP BY LOCATION` instead of `GROUP BY shop_id`. Do reference table `shop` instead of `shops`. The amended query now correctly groups by location and counts records per location rather than incorrectly grouping by shop_id while selecting location.",
            "Do place `count(*)` before `LOCATION` in the SELECT list instead of after it, maintaining the same aggregation logic. Do keep the `GROUP BY LOCATION` clause unchanged as it correctly groups by location. The amended query now matches RIGHT_SQL's behavior with identical output results."
        ],
        "rules": [
            "When the question asks for \"count of shops\" per location: compute the number of rows using the canonical key from the shop table.",
            "When the question mentions \"location\": use the exact column token \"LOCATION\" with the correct case.",
            "When the question asks for results \"per location\": organize results by grouping on the exact column \"LOCATION\".",
            "When referring to the shops table: use the exact table name \"shop\" instead of \"shops\".",
            "When the question asks for \"count of shops\" per location, When the question mentions \"location\", When the question asks for results \"per location\", When referring to the shops table, When producing output columns: maintain the order of location first followed by count.",
            "When answering about \"shops in each location\": make sure the output order: count of shops first, then location",
            "When the question asks for \"count of shops\": compute the number of rows using the canonical key for shops",
            "When answering about \"shops in each location\", When the question asks for \"count of shops\", When the question says \"per location\"/\"by location\": organize results by the LOCATION column and compute count per group"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location, COUNT(*) FROM shops GROUP BY shop_id;",
            "SELECT LOCATION, COUNT(*) FROM shop GROUP BY LOCATION;",
            "SELECT count(*), LOCATION FROM shop GROUP BY LOCATION"
        ],
        "rule_sql": [
            "SELECT Location, COUNT(Shop_ID) AS count_of_shops FROM shop GROUP BY Location ORDER BY count_of_shops DESC, Location;"
        ]
    },
    "269": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the manager name and district of the shop whose number of products is the largest.",
        "ground_truth": "SELECT manager_name ,  district FROM shop ORDER BY number_products DESC LIMIT 1",
        "amends": [
            "Do reference table `shop` instead of `shops` in the FROM clause. Do order by `number_products` instead of `number_of_products` in the ORDER BY clause. The amended query now correctly references the intended table and column names to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"manager name and district of the shop with largest number of products\": make sure the output order: manager_name, district.",
            "When the question mentions \"shop\": \"shop\" actually means table \"shop\" in schema.",
            "When the question mentions \"number of products\": \"number of products\" actually means column \"number_products\" in schema.",
            "When answering about \"manager name and district of the shop with largest number of products\", When the question mentions \"shop\", When the question mentions \"number of products\", When the question asks for \"largest\" number of products: rank rows by \"number_products\" in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT manager_name, district FROM shops ORDER BY number_of_products DESC LIMIT 1;",
            "SELECT Manager_name, District FROM shop ORDER BY Number_products DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT manager_name, district FROM shop ORDER BY number_products DESC LIMIT 1"
        ]
    },
    "270": {
        "db_id": "employee_hire_evaluation",
        "question": "What are the manager name and district of the shop that sells the largest number of products?",
        "ground_truth": "SELECT manager_name ,  district FROM shop ORDER BY number_products DESC LIMIT 1",
        "amends": [
            "Do reference table `shop` instead of `shops` in the FROM clause. Do order by `number_products` instead of `product_count` in the ORDER BY clause. The amended query now correctly retrieves the manager name and district from the shop table ordered by product count in descending order with a limit of one result."
        ],
        "rules": [
            "When the question asks about shops: use table \"shop\" instead of \"shops\".",
            "When ordering by product count: use column \"number_products\" instead of \"product_count\".",
            "When the question asks about shops, When ordering by product count, When finding the shop with the largest number of products: order by \"number_products\" in descending order and keep only the first result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT manager_name, district FROM shops ORDER BY product_count DESC LIMIT 1;",
            "SELECT Manager_name, District FROM shop ORDER BY Number_products DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Manager_name, District FROM shop ORDER BY Number_products DESC LIMIT 1;"
        ]
    },
    "271": {
        "db_id": "employee_hire_evaluation",
        "question": "find the minimum and maximum number of products of all stores.",
        "ground_truth": "SELECT min(Number_products) ,  max(Number_products) FROM shop",
        "amends": [
            "Do reference column `Number_products` instead of `product_count` and use table `shop` instead of `stores` while maintaining the same aggregate functions `MIN` and `MAX` with the same logic. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"minimum and maximum number of products of all stores\": use table \"shop\" instead of \"stores\" and column \"Number_products\" instead of \"product_count\".",
            "When answering about \"minimum and maximum number of products of all stores\", When computing aggregates across all stores: calculate the minimum value of \"Number_products\" and the maximum value of \"Number_products\" from the \"shop\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(product_count), MAX(product_count) FROM stores;",
            "SELECT MIN(Number_products) AS min_products, MAX(Number_products) AS max_products FROM shop;"
        ],
        "rule_sql": [
            "SELECT MIN(Number_products) AS min_products, MAX(Number_products) AS max_products FROM shop;"
        ]
    },
    "272": {
        "db_id": "employee_hire_evaluation",
        "question": "What are the minimum and maximum number of products across all the shops?",
        "ground_truth": "SELECT min(Number_products) ,  max(Number_products) FROM shop",
        "amends": [
            "Do reference the correct column name `Number_products` instead of the incorrect `products` column in both aggregate functions. Do use the correct table name `shop` instead of the pluralized `shops` table. Do remove the unnecessary column aliases `min_products` and `max_products` instead of keeping them, as the right query returns unnamed columns. The amended query now correctly calculates the minimum and maximum values from the Number_products column in the shop table, matching the right SQL's behavior."
        ],
        "rules": [
            "When the question asks for minimum and maximum number of products: use the exact column name \"Number_products\" from the shop table, not \"products\".",
            "When referencing the table containing product information: use the exact table name \"shop\" instead of the pluralized form \"shops\".",
            "When the question asks for minimum and maximum number of products, When referencing the table containing product information, When the question does not specify column aliases for output: return the aggregate results without column aliases, maintaining the natural output order of minimum value first followed by maximum value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(products) AS min_products, MAX(products) AS max_products FROM shops;",
            "SELECT MIN(Number_products), MAX(Number_products) FROM shop;"
        ],
        "rule_sql": [
            "SELECT MIN(Number_products), MAX(Number_products) FROM shop;"
        ]
    },
    "273": {
        "db_id": "employee_hire_evaluation",
        "question": "Return the name, location and district of all shops in descending order of number of products.",
        "ground_truth": "SELECT name ,  LOCATION ,  district FROM shop ORDER BY number_products DESC",
        "amends": [
            "Do reference the correct table name `shop` instead of `shops` in the FROM clause. Do order by the column `number_products` instead of the aggregate function `COUNT(products)` which cannot be used in ORDER BY without GROUP BY. Do maintain the same column selection of `name`, `location`, and `district` without changes. The amended query now correctly references the existing table and orders by the appropriate product count column instead of attempting to use an aggregate function improperly."
        ],
        "rules": [
            "When the question mentions \"shops\": use the exact table name \"shop\" instead of \"shops\".",
            "When ordering by number of products in descending order: use the column \"number_products\" directly instead of attempting to count products.",
            "When selecting output columns: maintain the exact column order \"name\", \"location\", and \"district\" as specified in the question.",
            "When the question mentions \"shops\", When ordering by number of products in descending order, When selecting output columns, When producing the result set: sort all rows by \"number_products\" in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, location, district FROM shops ORDER BY COUNT(products) DESC;",
            "SELECT Name, Location, District FROM shop ORDER BY Number_products DESC;"
        ],
        "rule_sql": [
            "SELECT name, location, district FROM shop ORDER BY number_products DESC;"
        ]
    },
    "274": {
        "db_id": "employee_hire_evaluation",
        "question": "Sort all the shops by number products in descending order, and return the name, location and district of each shop.",
        "ground_truth": "SELECT name ,  LOCATION ,  district FROM shop ORDER BY number_products DESC",
        "amends": [
            "Do reference the correct table name `shop` instead of `shops` in the FROM clause. Do order by the column `number_products` instead of the aggregate function `COUNT(products)` in the ORDER BY clause, as aggregates cannot be used directly in ORDER BY without being in the SELECT list or a GROUP BY clause. The amended query now correctly retrieves data from the intended table and sorts results based on the existing product count column rather than attempting to perform an invalid aggregation in the ORDER BY clause."
        ],
        "rules": [
            "When the question refers to \"shops\": use the exact table name \"shop\" instead of \"shops\".",
            "When ordering by number of products: use the existing column \"number_products\" directly rather than attempting to count products through aggregation.",
            "When the question asks to sort in descending order: order by \"number_products\" in descending direction.",
            "When the question refers to \"shops\", When ordering by number of products, When the question asks to sort in descending order, When returning shop information: output the columns \"name\", \"location\", and \"district\" in that order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, location, district FROM shops ORDER BY COUNT(products) DESC;",
            "SELECT Name, Location, District FROM shop ORDER BY Number_products DESC;"
        ],
        "rule_sql": [
            "SELECT name, location, district FROM shop ORDER BY number_products DESC;"
        ]
    },
    "275": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the names of stores whose number products is more than the average number of products.",
        "ground_truth": "SELECT name FROM shop WHERE number_products  >  (SELECT avg(number_products) FROM shop)",
        "amends": [
            "Do reference table `shop` instead of `stores` in both the main query and subquery. Do use lowercase `avg` instead of uppercase `AVG` for the aggregate function. The amended query now correctly filters shops where the number of products exceeds the average across all shops, matching the intended behavior."
        ],
        "rules": [
            "When the question mentions \"stores\": use the exact table name \"shop\" instead of \"stores\".",
            "When computing the average number of products: use the lowercase function \"avg\" instead of uppercase \"AVG\".",
            "When the question mentions \"stores\", When computing the average number of products, When filtering shops by number of products exceeding the average: compare \"number_products\" against the average of \"number_products\" across all shops."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM stores WHERE number_products > (SELECT AVG(number_products) FROM stores);",
            "SELECT Name FROM shop WHERE Number_products > (SELECT avg(Number_products) FROM shop)"
        ],
        "rule_sql": [
            "SELECT Name FROM shop WHERE number_products > (SELECT avg(number_products) FROM shop)"
        ]
    },
    "276": {
        "db_id": "employee_hire_evaluation",
        "question": "Which shops' number products is above the average? Give me the shop names.",
        "ground_truth": "SELECT name FROM shop WHERE number_products  >  (SELECT avg(number_products) FROM shop)",
        "amends": [
            "Do reference column `name` instead of `shop_name` and use `number_products` instead of `products` in the main query. Do reference table `shop` instead of `shops` in both the main query and subquery. Do use the aggregate function `avg()` instead of `AVG()` and reference `number_products` instead of `products` in the subquery. Do remove the incorrect `COUNT()` function wrapping around `number_products` in the main filter condition instead of using it, as the comparison should be between the column value and the average rather than counting products. The amended query now correctly compares each shop's product count against the average product count across all shops."
        ],
        "rules": [
            "When the question mentions \"shop names\": use the exact column token \"name\" from the \"shop\" table.",
            "When the question asks for shops where \"number products is above the average\": compare the \"number_products\" column value directly against the average of \"number_products\" across all shops, without using COUNT() function.",
            "When computing the average for comparison: calculate the average of \"number_products\" from the \"shop\" table using avg() function.",
            "When the question mentions \"shop names\", When the question asks for shops where \"number products is above the average\", When computing the average for comparison, When referencing tables: use \"shop\" table instead of \"shops\" in both main query and subquery."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT shop_name FROM shops WHERE COUNT(products) > (SELECT AVG(COUNT(products)) FROM shops);",
            "SELECT name FROM shop WHERE number_products > (SELECT AVG(number_products) FROM shop)"
        ],
        "rule_sql": [
            "SELECT name FROM shop WHERE number_products > (SELECT AVG(number_products) FROM shop)"
        ]
    },
    "277": {
        "db_id": "employee_hire_evaluation",
        "question": "find the name of employee who was awarded the most times in the evaluation.",
        "ground_truth": "SELECT t1.name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID  =  t2.Employee_ID GROUP BY t2.Employee_ID ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do specify `t1.name` with table alias instead of just `name`. Do add `FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID = t2.Employee_ID` instead of omitting the join and table aliases. Do add `GROUP BY t2.Employee_ID` instead of omitting grouping. Do use `count(*)` instead of `COUNT(evaluation.award)` for proper counting of all evaluation records. Do maintain `ORDER BY count(*) DESC LIMIT 1` but with the corrected aggregate function. The amended query now correctly joins the tables, groups by employee, and counts all evaluations to find the employee with the most evaluations, matching the right SQL's behavior."
        ],
        "rules": [
            "When answering about \"employee who was awarded the most times\": make sure the output order: t1.name.",
            "When combining employee and evaluation tables: link rows where t1.Employee_ID = t2.Employee_ID and keep only matching pairs (inner match).",
            "When counting evaluation records per employee: compute the number of rows using count(*) grouped by t2.Employee_ID.",
            "When answering about \"employee who was awarded the most times\", When combining employee and evaluation tables, When counting evaluation records per employee, When the question mentions \"most times\": rank employees by count(*) in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM employee ORDER BY COUNT(evaluation.award) DESC LIMIT 1;",
            "SELECT t1.Name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID = t2.Employee_ID GROUP BY t2.Employee_ID ORDER BY count(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT t1.Name\nFROM employee t1\nINNER JOIN evaluation t2 ON t1.Employee_ID = t2.Employee_ID\nGROUP BY t2.Employee_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "278": {
        "db_id": "employee_hire_evaluation",
        "question": "Which employee received the most awards in evaluations? Give me the employee name.",
        "ground_truth": "SELECT t1.name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID  =  t2.Employee_ID GROUP BY t2.Employee_ID ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `t1.name` from the `employee` table instead of `employee_name` from `evaluations`. Do join `evaluation AS t2` with an `INNER JOIN` on `t1.Employee_ID = t2.Employee_ID` instead of querying only the `evaluations` table. Do add `GROUP BY t2.Employee_ID` to aggregate by employee instead of omitting grouping. Do order by `count(*) DESC` to rank by evaluation count instead of `awards DESC`. The amended query now correctly identifies the employee with the most evaluations by joining employee data with evaluation records and counting occurrences per employee."
        ],
        "rules": [
            "When answering about \"employee who received the most awards in evaluations\": make sure the output order: t1.name.",
            "When the question mentions \"employee name\": \"employee name\" actually means \"t1.name in schema\".",
            "When combining employee and evaluation tables for shared entities: link rows where t1.Employee_ID = t2.Employee_ID; keep only matching pairs (inner match).",
            "When the question asks for \"most awards\" (highest count): rank rows by count(*) in descending direction and keep the first 1 row.",
            "When answering about \"employee who received the most awards in evaluations\", When the question mentions \"employee name\", When combining employee and evaluation tables for shared entities, When the question asks for \"most awards\" (highest count), When the question says \"per employee\"/\"by employee\": organize results by t2.Employee_ID and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT employee_name FROM evaluations ORDER BY awards DESC LIMIT 1;",
            "SELECT t1.Name\nFROM employee AS t1\nINNER JOIN evaluation AS t2 ON t1.Employee_ID = t2.Employee_ID\nGROUP BY t2.Employee_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t1.Name\nFROM employee t1\nINNER JOIN evaluation t2 ON t1.Employee_ID = t2.Employee_ID\nGROUP BY t2.Employee_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "279": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the name of the employee who got the highest one time bonus.",
        "ground_truth": "SELECT t1.name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID  =  t2.Employee_ID ORDER BY t2.bonus DESC LIMIT 1",
        "amends": [
            "Do specify `t1.name` with table alias instead of just `name`. Do add `employee AS t1` and `evaluation AS t2` as FROM sources instead of just `employees`. Do add `JOIN evaluation AS t2 ON t1.Employee_ID = t2.Employee_ID` instead of omitting the join. Do order by `t2.bonus` with table alias instead of just `bonus`. The amended query now correctly joins the employee and evaluation tables to access the bonus field and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"the employee who got the highest one time bonus\": make sure the output order: t1.name.",
            "When combining employee and evaluation tables: link rows where t1.Employee_ID = t2.Employee_ID and keep only matching pairs (inner match).",
            "When the question mentions \"highest\" bonus: rank rows by t2.bonus in descending order and keep the first 1 row.",
            "When answering about \"the employee who got the highest one time bonus\", When combining employee and evaluation tables, When the question mentions \"highest\" bonus, When selecting employee names: use t1.name with table alias instead of just name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM employees ORDER BY bonus DESC LIMIT 1;",
            "SELECT t1.Name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID = t2.Employee_ID ORDER BY t2.Bonus DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT t1.Name\nFROM employee t1\nINNER JOIN evaluation t2 ON t1.Employee_ID = t2.Employee_ID\nORDER BY t2.Bonus DESC\nLIMIT 1;"
        ]
    },
    "280": {
        "db_id": "employee_hire_evaluation",
        "question": "Which employee received the biggest bonus? Give me the employee name.",
        "ground_truth": "SELECT t1.name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID  =  t2.Employee_ID ORDER BY t2.bonus DESC LIMIT 1",
        "amends": [
            "Do select `t1.name` from the `employee` table instead of `employee_name` from `employees`. Do add a `JOIN` with the `evaluation` table on `t1.Employee_ID = t2.Employee_ID` instead of querying a single table. Do order by `t2.bonus` instead of just `bonus` to specify the table source. The amended query now correctly joins employee and evaluation tables to access bonus data and returns the expected result matching RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"which employee received the biggest bonus\": make sure the output order: t1.name.",
            "When the question mentions \"employee name\": \"employee name\" actually means \"t1.name in schema\".",
            "When the question mentions \"biggest bonus\": rank rows by t2.bonus in descending direction and keep the first 1 row.",
            "When combining employee and evaluation tables for shared entities: link rows where t1.Employee_ID = t2.Employee_ID exactly as shown; keep only matching pairs (inner match).",
            "When answering about \"which employee received the biggest bonus\", When the question mentions \"employee name\", When the question mentions \"biggest bonus\", When combining employee and evaluation tables for shared entities, When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT employee_name FROM employees ORDER BY bonus DESC LIMIT 1;",
            "SELECT t1.Name \nFROM employee t1\nJOIN evaluation t2 ON t1.Employee_ID = t2.Employee_ID\nORDER BY t2.Bonus DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t1.Name\nFROM employee t1\nINNER JOIN evaluation t2 ON t1.Employee_ID = t2.Employee_ID\nORDER BY t2.Bonus DESC\nLIMIT 1"
        ]
    },
    "281": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the names of employees who never won any award in the evaluation.",
        "ground_truth": "SELECT name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation)",
        "amends": [
            "Do select `name` from `employee` instead of `employees` as the table source. Do use a `NOT IN` subquery filtering by `Employee_ID` from the `evaluation` table instead of a simple `WHERE award_count > 0` condition. Do remove the incorrect `award_count` filter and instead implement the proper exclusion logic based on employee evaluations. The amended query now correctly identifies employees who have not been evaluated by checking for their absence in the evaluation table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When selecting employee names: use the exact table name \"employee\" instead of \"employees\" and select the \"name\" column.",
            "When identifying employees who never won any award in the evaluation: use a NOT IN subquery that filters by \"Employee_ID\" from the \"evaluation\" table instead of checking award_count.",
            "When combining employee and evaluation data: use \"Employee_ID\" as the matching key between tables, where employee.Employee_ID is not found in evaluation.Employee_ID.",
            "When selecting employee names, When identifying employees who never won any award in the evaluation, When combining employee and evaluation data, When handling employee identifiers: use the exact column name \"Employee_ID\" with proper case and formatting as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM employees WHERE award_count > 0;",
            "SELECT Name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation)"
        ],
        "rule_sql": [
            "SELECT Name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation)"
        ]
    },
    "282": {
        "db_id": "employee_hire_evaluation",
        "question": "What are the names of the employees who never received any evaluation?",
        "ground_truth": "SELECT name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation)",
        "amends": [
            "Do select `name` from `employee` instead of `employees` as the table source. Do use `NOT IN` with a subquery checking `Employee_ID` in the `evaluation` table instead of filtering on `evaluation_score IS NULL`. Do remove the direct null check condition and instead implement a correlated exclusion pattern to find employees missing from the evaluation table entirely. The amended query now correctly identifies employees without any evaluation records rather than those with null scores, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for employee names who never received any evaluation: select \"name\" from table \"employee\" (T1) instead of \"employees\".",
            "When checking for employees without evaluations: use a NOT IN condition with \"Employee_ID\" compared against a subquery that selects \"Employee_ID\" from table \"evaluation\" (T2).",
            "When combining employee and evaluation data: link using the exact key equality \"T1.Employee_ID = T2.Employee_ID\" to find employees missing from the evaluation table entirely.",
            "When the question asks for employee names who never received any evaluation, When checking for employees without evaluations, When combining employee and evaluation data, When filtering for employees without evaluations: do not use direct null checks on evaluation_score, instead implement a correlated exclusion pattern to identify employees with no evaluation records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM employees WHERE evaluation_score IS NULL;",
            "SELECT Name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation)"
        ],
        "rule_sql": [
            "SELECT Name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation)"
        ]
    },
    "283": {
        "db_id": "employee_hire_evaluation",
        "question": "What is the name of the shop that is hiring the largest number of employees?",
        "ground_truth": "SELECT t2.name FROM hiring AS t1 JOIN shop AS t2 ON t1.shop_id  =  t2.shop_id GROUP BY t1.shop_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `t2.name` from the `hiring` table instead of `name` from the `shops` table. Do join `shop AS t2` on `t1.shop_id = t2.shop_id` instead of querying only the `shops` table. Do add `GROUP BY t1.shop_id` and aggregate with `count(*)` instead of using `employee_count` directly. Do order by `count(*) DESC` instead of `employee_count DESC` to count actual hires per shop. The amended query now correctly identifies the shop with the most hiring records rather than relying on a potentially incorrect employee_count field."
        ],
        "rules": [
            "When answering about \"shop hiring the largest number of employees\": make sure the output order: t2.name",
            "When the question mentions \"shop name\": \"name\" actually means \"t2.name in schema\"",
            "When combining hiring table and shops table for shared entities: link rows where t1.shop_id = t2.shop_id exactly as shown; keep only matching pairs (inner match)",
            "When the question asks for \"count of employees hired per shop\": compute the number of rows using count(*) grouped by t1.shop_id",
            "When answering about \"shop hiring the largest number of employees\", When the question mentions \"shop name\", When combining hiring table and shops table for shared entities, When the question asks for \"count of employees hired per shop\", When the question mentions \"largest number\": rank rows by count(*) in descending direction and keep the first 1 row"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM shops ORDER BY employee_count DESC LIMIT 1;",
            "SELECT t2.Name \nFROM hiring AS t1 \nJOIN shop AS t2 ON t1.Shop_ID = t2.Shop_ID \nGROUP BY t1.Shop_ID \nORDER BY COUNT(*) DESC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t2.Name\nFROM hiring t1\nJOIN shop t2 ON t1.Shop_ID = t2.Shop_ID\nGROUP BY t1.Shop_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "284": {
        "db_id": "employee_hire_evaluation",
        "question": "Which shop has the most employees? Give me the shop name.",
        "ground_truth": "SELECT t2.name FROM hiring AS t1 JOIN shop AS t2 ON t1.shop_id  =  t2.shop_id GROUP BY t1.shop_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `t2.name` from the `shop` table instead of `shop_name` from the `shops` table. Do join `hiring AS t1` with `shop AS t2` on `t1.shop_id = t2.shop_id` instead of querying a single table. Do add `GROUP BY t1.shop_id` to aggregate by shop instead of omitting grouping. Do order by `count(*) DESC` to find the shop with the most hires instead of `employee_count ASC` for the smallest shop. The amended query now correctly identifies the shop with the highest number of hiring records, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"which shop has the most employees\": make sure the output order: t2.name.",
            "When the question mentions \"shop name\": \"shop name\" actually means \"t2.name in schema\".",
            "When combining hiring AS t1 and shop AS t2 for shared entities: link rows where t1.shop_id = t2.shop_id exactly as shown; keep only matching pairs (inner match).",
            "When the question asks for \"count of employees\" per shop: compute the number of rows using t1.shop_id as the grouping key and count(*) as the aggregate.",
            "When answering about \"which shop has the most employees\", When the question mentions \"shop name\", When combining hiring AS t1 and shop AS t2 for shared entities, When the question asks for \"count of employees\" per shop, When the question mentions \"most employees\" or \"highest\": rank rows by count(*) in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT shop_name FROM shops ORDER BY employee_count ASC LIMIT 1;",
            "SELECT t2.Name \nFROM hiring AS t1 \nJOIN shop AS t2 ON t1.Shop_ID = t2.Shop_ID \nGROUP BY t1.Shop_ID \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT t2.Name \nFROM hiring AS t1 \nINNER JOIN shop AS t2 ON t1.Shop_ID = t2.Shop_ID \nGROUP BY t1.Shop_ID \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ]
    },
    "285": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the name of the shops that do not hire any employee.",
        "ground_truth": "SELECT name FROM shop WHERE shop_id NOT IN (SELECT shop_id FROM hiring)",
        "amends": [
            "Do reference table `shop` instead of `shops` in the FROM clause. Do use a subquery with `NOT IN` condition on `shop_id` instead of filtering directly with `employee_id IS NULL`. Do remove the incorrect `employee_id` column reference and instead correlate through `shop_id` between the main query and subquery. Do change the filter logic to check for shops not present in the `hiring` table instead of checking for null employee IDs. The amended query now correctly identifies shops without hiring records by using a correlated subquery approach instead of relying on potentially incorrect null checks."
        ],
        "rules": [
            "When the question asks about shops that do not hire any employee: use the table name \"shop\" instead of \"shops\" in the FROM clause.",
            "When checking for shops without hiring records: use a NOT IN condition on shop_id instead of filtering with employee_id IS NULL.",
            "When correlating between main query and subquery: use shop_id as the linking key between the shop table and hiring table.",
            "When the question asks about shops that do not hire any employee, When checking for shops without hiring records, When correlating between main query and subquery, When identifying shops without hiring records: check for shops not present in the hiring table rather than checking for null employee IDs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM shops WHERE employee_id IS NULL;",
            "SELECT Name FROM shop WHERE Shop_ID NOT IN (SELECT Shop_ID FROM hiring)"
        ],
        "rule_sql": [
            "SELECT Name FROM shop WHERE Shop_ID NOT IN (SELECT Shop_ID FROM hiring)"
        ]
    },
    "286": {
        "db_id": "employee_hire_evaluation",
        "question": "Which shops run with no employees? Find the shop names",
        "ground_truth": "SELECT name FROM shop WHERE shop_id NOT IN (SELECT shop_id FROM hiring)",
        "amends": [
            "Do select `name` from the `shop` table instead of `shop_name` from `shops`. Do use a subquery with `NOT IN` to filter shops that are not in the hiring table instead of checking for `employee_count = 0`. Do reference `shop_id` in both the main query and subquery instead of using different column names and logic. The amended query now correctly identifies shops without any hiring records by checking their absence from the hiring table rather than relying on a potentially incorrect employee count field."
        ],
        "rules": [
            "When the question asks for shop names: use the exact column name \"name\" from the \"shop\" table instead of \"shop_name\" from \"shops\".",
            "When identifying shops with no employees: use a subquery with NOT IN to filter shops that are not present in the hiring table instead of checking for employee_count = 0.",
            "When the question asks for shop names, When identifying shops with no employees, When linking between the shop table and hiring table: use the exact column \"shop_id\" in both the main query and subquery for proper comparison."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT shop_name FROM shops WHERE employee_count = 0;",
            "SELECT Name FROM shop WHERE Shop_ID NOT IN (SELECT Shop_ID FROM hiring)"
        ],
        "rule_sql": [
            "SELECT name FROM shop WHERE shop_id NOT IN (SELECT shop_id FROM hiring)"
        ]
    },
    "287": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the number of employees hired in each shop; show the shop name as well.",
        "ground_truth": "SELECT count(*) ,  t2.name FROM hiring AS t1 JOIN shop AS t2 ON t1.shop_id  =  t2.shop_id GROUP BY t2.name",
        "amends": [
            "Do select `count(*)` and `t2.name` instead of `shop_name` and `COUNT(*)`. Do join `hiring AS t1` with `shop AS t2` on `t1.shop_id = t2.shop_id` instead of querying only `employees` table. Do group by `t2.name` instead of `shop_id`. The amended query now correctly counts employees per shop name by joining the hiring and shop tables, matching the intended behavior.",
            "Do place the `count(*)` aggregate function first in the SELECT list instead of second, and do use lowercase `t2.name` instead of uppercase `t2.Name` while maintaining the same GROUP BY clause with lowercase `t2.name` instead of uppercase `t2.Name`. The amended query now correctly matches the RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [
            "When answering about \"number of employees hired in each shop\": make sure the output order: shop name, then count of employees.",
            "When the question mentions \"shop name\": \"shop name\" actually means \"t2.name\" in schema.",
            "When combining hiring as T1 and shop as T2 for shared entities: link rows where T1.shop_id = T2.shop_id exactly as shown; keep only matching pairs (inner match).",
            "When the question asks for \"count of employees\": compute the number of rows using the canonical key from the hiring table.",
            "When answering about \"number of employees hired in each shop\", When the question mentions \"shop name\", When combining hiring as T1 and shop as T2 for shared entities, When the question asks for \"count of employees\", When the question says \"per shop\"/\"by shop\": organize results by t2.name and compute the count per group.",
            "When answering about \"number of employees hired in each shop\": make sure the output order: count(*) first, then shop name.",
            "When referring to the shop name column: use lowercase \"t2.name\" instead of uppercase \"t2.Name\" for both SELECT and GROUP BY clauses.",
            "When answering about \"number of employees hired in each shop\", When referring to the shop name column, When counting employees per shop: use count(*) to count all rows in the hiring table for each shop group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT shop_name, COUNT(*) FROM employees GROUP BY shop_id;",
            "SELECT t2.Name, COUNT(*) \nFROM hiring AS t1 \nJOIN shop AS t2 ON t1.Shop_ID = t2.Shop_ID \nGROUP BY t2.Name",
            "SELECT count(*), t2.name FROM hiring AS t1 JOIN shop AS t2 ON t1.Shop_ID = t2.Shop_ID GROUP BY t2.name"
        ],
        "rule_sql": [
            "SELECT t2.name, COUNT(*) \nFROM hiring AS t1 \nINNER JOIN shop AS t2 ON t1.Shop_ID = t2.Shop_ID \nGROUP BY t2.name \nORDER BY COUNT(*), t2.name"
        ]
    },
    "288": {
        "db_id": "employee_hire_evaluation",
        "question": "For each shop, return the number of employees working there and the name of the shop.",
        "ground_truth": "SELECT count(*) ,  t2.name FROM hiring AS t1 JOIN shop AS t2 ON t1.shop_id  =  t2.shop_id GROUP BY t2.name",
        "amends": [
            "Do select `count(*)` and `t2.name` instead of `shop_name` and `COUNT(*)`. Do join `hiring AS t1` with `shop AS t2` on `t1.shop_id = t2.shop_id` instead of selecting from `employees` alone. Do group by `t2.name` instead of `shop_id`. The amended query now correctly aggregates hiring counts by shop name through proper table joining and grouping."
        ],
        "rules": [
            "When answering about \"number of employees per shop\": make sure the output order: shop name first, then employee count.",
            "When the question mentions \"shop name\": \"shop name\" actually means \"t2.name\" in schema.",
            "When the question asks for \"number of employees\": compute the count of all rows from the hiring table (t1) per shop.",
            "When combining hiring as t1 and shop as t2: link rows where t1.shop_id = t2.shop_id exactly as shown; keep only matching pairs (inner match).",
            "When answering about \"number of employees per shop\", When the question mentions \"shop name\", When the question asks for \"number of employees\", When combining hiring as t1 and shop as t2, When the question says \"per shop\": organize results by t2.name and compute employee count per group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT shop_name, COUNT(*) FROM employees GROUP BY shop_id;",
            "SELECT COUNT(*) AS employee_count, t2.Name AS shop_name\nFROM hiring AS t1\nJOIN shop AS t2 ON t1.Shop_ID = t2.Shop_ID\nGROUP BY t2.Name"
        ],
        "rule_sql": [
            "SELECT t2.Name AS shop_name, COUNT(t1.Employee_ID) AS employee_count\nFROM hiring AS t1\nINNER JOIN shop AS t2 ON t1.Shop_ID = t2.Shop_ID\nGROUP BY t2.Name\nORDER BY t2.Name, employee_count;"
        ]
    },
    "289": {
        "db_id": "employee_hire_evaluation",
        "question": "What is total bonus given in all evaluations?",
        "ground_truth": "SELECT sum(bonus) FROM evaluation",
        "amends": [
            "Do use the column `bonus` instead of `salary` in the SELECT list's aggregate function. Do reference the table `evaluation` instead of `evaluations` in the FROM clause. The amended query now correctly calculates the sum of bonus amounts from the evaluation table, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for \"total bonus\": use the exact column name \"bonus\" from the evaluation table.",
            "When referencing the table containing bonus data: use the exact table name \"evaluation\" (singular form) instead of \"evaluations\".",
            "When the question asks for \"total bonus\", When referencing the table containing bonus data, When calculating the sum of bonus amounts: aggregate using the SUM function on the \"bonus\" column from the evaluation table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(salary) FROM evaluations;",
            "SELECT SUM(Bonus) AS Total_Bonus FROM evaluation;"
        ],
        "rule_sql": [
            "SELECT SUM(bonus) AS total_bonus FROM evaluation;"
        ]
    },
    "290": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the total amount of bonus given in all the evaluations.",
        "ground_truth": "SELECT sum(bonus) FROM evaluation",
        "amends": [
            "Do use the column `bonus` instead of `salary` in the SELECT list aggregation. Do reference the table `evaluation` instead of `evaluations` in the FROM clause. The amended query now correctly calculates the sum of bonus amounts from the evaluation table."
        ],
        "rules": [
            "When the question asks for \"total amount of bonus\": use the exact column token \"bonus\" for aggregation instead of \"salary\".",
            "When referencing the evaluation data: use the exact table name \"evaluation\" instead of \"evaluations\".",
            "When the question asks for \"total amount of bonus\", When referencing the evaluation data, When calculating the total bonus amount: compute the sum of all values in the \"bonus\" column from the \"evaluation\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(salary) FROM evaluations;",
            "SELECT SUM(Bonus) AS Total_Bonus FROM evaluation;"
        ],
        "rule_sql": [
            "SELECT SUM(bonus) AS total_bonus FROM evaluation;"
        ]
    },
    "291": {
        "db_id": "employee_hire_evaluation",
        "question": "Give me all the information about hiring.",
        "ground_truth": "SELECT * FROM hiring",
        "amends": [
            "Do query the `hiring` table instead of the `employees` table. Do remove the `WHERE hire_date IS NULL` filter instead of keeping it. The amended query now matches RIGHT_SQL's behavior by selecting all records from the correct table without any filtering conditions."
        ],
        "rules": [
            "When answering about \"hiring\": query the \"hiring\" table instead of the \"employees\" table.",
            "When the question asks for \"all the information about hiring\": select all columns from the \"hiring\" table without any filtering conditions.",
            "When answering about \"hiring\", When the question asks for \"all the information about hiring\", When the question does not specify any filtering criteria: do not apply any WHERE clause filters to the query."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM employees WHERE hire_date IS NULL;",
            "SELECT * FROM hiring;"
        ],
        "rule_sql": [
            "SELECT * FROM hiring;"
        ]
    },
    "292": {
        "db_id": "employee_hire_evaluation",
        "question": "What is all the information about hiring?",
        "ground_truth": "SELECT * FROM hiring",
        "amends": [
            "Do query the `hiring` table instead of the `employees` table. Do remove the `WHERE hire_date IS NULL` filter instead of keeping it. The amended query now matches RIGHT_SQL's behavior by selecting all records from the correct table without any filtering conditions."
        ],
        "rules": [
            "When answering about \"all the information about hiring\": query the \"hiring\" table instead of the \"employees\" table.",
            "When the question asks for \"all the information\": select all columns from the table without any filtering conditions.",
            "When answering about \"all the information about hiring\", When the question asks for \"all the information\", When the question mentions \"hiring\": \"hiring\" refers to the \"hiring\" table in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM employees WHERE hire_date IS NULL;",
            "SELECT * FROM hiring;"
        ],
        "rule_sql": [
            "SELECT * FROM hiring;"
        ]
    },
    "293": {
        "db_id": "employee_hire_evaluation",
        "question": "Which district has both stores with less than 3000 products and stores with more than 10000 products?",
        "ground_truth": "SELECT district FROM shop WHERE Number_products  <  3000 INTERSECT SELECT district FROM shop WHERE Number_products  >  10000",
        "amends": [
            "Do reference table `shop` instead of `stores` and column `Number_products` instead of `products`. Do use `INTERSECT` with two separate queries instead of a single `WHERE` clause with conflicting conditions `products < 3000 AND products > 10000`. Do split the logic into two separate `SELECT` statements: one for `Number_products < 3000` and another for `Number_products > 10000`, then intersect the results to find districts that satisfy both conditions simultaneously, which correctly implements the intended logic instead of the impossible condition that would return no results."
        ],
        "rules": [
            "When the question mentions \"stores\": use table \"shop\" instead.",
            "When the question mentions \"products\": use column \"Number_products\" instead.",
            "When finding districts with both stores having less than 3000 products and stores having more than 10000 products: use INTERSECT between two separate queries - one for \"Number_products < 3000\" and another for \"Number_products > 10000\" - instead of combining both conditions in a single WHERE clause.",
            "When the question mentions \"stores\", When the question mentions \"products\", When finding districts with both stores having less than 3000 products and stores having more than 10000 products, When selecting districts: ensure the output column is \"district\" from the \"shop\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT district FROM stores WHERE products < 3000 AND products > 10000;",
            "SELECT District FROM shop WHERE Number_products < 3000\nINTERSECT\nSELECT District FROM shop WHERE Number_products > 10000"
        ],
        "rule_sql": [
            "SELECT District FROM shop WHERE Number_products < 3000\nINTERSECT\nSELECT District FROM shop WHERE Number_products > 10000"
        ]
    },
    "294": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the districts in which there are both shops selling less than 3000 products and shops selling more than 10000 products.",
        "ground_truth": "SELECT district FROM shop WHERE Number_products  <  3000 INTERSECT SELECT district FROM shop WHERE Number_products  >  10000",
        "amends": [
            "Do reference table `shop` instead of `shops` and use column `Number_products` instead of `products_sold`. Do use `INTERSECT` to find districts that meet both conditions instead of using `AND` with contradictory filters `products_sold < 3000 AND products_sold > 10000` which would return no results. Do split the query into two separate SELECT statements with `INTERSECT` to properly find districts where some shops have fewer than 3000 products and other shops have more than 10000 products, instead of incorrectly trying to find shops that simultaneously have both conditions. The amended query now correctly identifies districts containing shops with both low and high product counts."
        ],
        "rules": [
            "When the question mentions \"shops\": use table \"shop\" instead of \"shops\" and column \"Number_products\" instead of \"products_sold\".",
            "When finding districts with both shops selling less than 3000 products and shops selling more than 10000 products: use INTERSECT to combine results from two separate queries - one for districts with shops having \"Number_products\" < 3000 and another for districts with shops having \"Number_products\" > 10000.",
            "When filtering shops by product count: use exact numeric comparisons \"Number_products\" < 3000 and \"Number_products\" > 10000 with the literal values as specified.",
            "When the question mentions \"shops\", When finding districts with both shops selling less than 3000 products and shops selling more than 10000 products, When filtering shops by product count, When the question asks about districts containing both types of shops: do not use AND with contradictory filters on the same row, as no shop can simultaneously have both \"Number_products\" < 3000 and \"Number_products\" > 10000."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT district FROM shops WHERE products_sold < 3000 AND products_sold > 10000;",
            "SELECT District FROM shop WHERE Number_products < 3000\nINTERSECT\nSELECT District FROM shop WHERE Number_products > 10000"
        ],
        "rule_sql": [
            "SELECT District FROM shop WHERE Number_products < 3000\nINTERSECT\nSELECT District FROM shop WHERE Number_products > 10000"
        ]
    },
    "295": {
        "db_id": "employee_hire_evaluation",
        "question": "How many different store locations are there?",
        "ground_truth": "SELECT count(DISTINCT LOCATION) FROM shop",
        "amends": [
            "Do `count(DISTINCT LOCATION)` instead of `COUNT(*)` to count unique locations rather than all rows. Do reference table `shop` instead of `stores` to query the correct data source. The amended query now correctly counts distinct locations from the shop table instead of counting all rows from the stores table."
        ],
        "rules": [
            "When the question asks for \"different store locations\": count the number of unique values using the exact column token \"LOCATION\" from the correct table.",
            "When the question mentions \"store locations\": the correct data source is table \"shop\" instead of \"stores\".",
            "When the question asks for \"different store locations\", When the question mentions \"store locations\", When counting distinct locations: use DISTINCT on the \"LOCATION\" column to count unique values rather than all rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM stores;",
            "SELECT COUNT(DISTINCT Location) FROM shop;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Location) FROM shop;"
        ]
    },
    "296": {
        "db_id": "employee_hire_evaluation",
        "question": "Count the number of distinct store locations.",
        "ground_truth": "SELECT count(DISTINCT LOCATION) FROM shop",
        "amends": [
            "Do count `DISTINCT LOCATION` instead of counting `store_id`. Do use table `shop` instead of table `stores`. Do remove the incorrect aggregate function that counted non-unique store identifiers instead of counting distinct location values. The amended query now correctly counts unique locations from the shop table instead of attempting to count store IDs from a non-existent stores table, matching the right SQL's behavior."
        ],
        "rules": [
            "When the question asks to count distinct store locations: use the exact column token \"LOCATION\" from the shop table.",
            "When counting distinct values: compute the number of unique values of the exact token \"LOCATION\".",
            "When the schema specifies table \"shop\": use table \"shop\" instead of any other table name like \"stores\".",
            "When the question asks to count distinct store locations, When counting distinct values, When the schema specifies table \"shop\", When answering about \"number of distinct store locations\": make sure the output order: count of distinct LOCATION values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(store_id) FROM stores;",
            "SELECT COUNT(DISTINCT Location) FROM shop;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Location) FROM shop;"
        ]
    },
    "297": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "How many documents do we have?",
        "ground_truth": "SELECT count(*) FROM Documents",
        "amends": [
            "Do use lowercase `count(*)` instead of uppercase `COUNT(*)` to match the function casing. Do reference the table as `Documents` with proper case instead of lowercase `documents` to maintain schema object naming consistency. The amended query now correctly matches the RIGHT_SQL's behavior with proper function and table name casing."
        ],
        "rules": [
            "When counting documents: use the exact table name \"Documents\" with proper case instead of lowercase \"documents\".",
            "When counting documents, When using the count function: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" to match function casing."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM documents WHERE id = 1;",
            "SELECT count(*) FROM Documents;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM Documents;"
        ]
    },
    "298": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Count the number of documents.",
        "ground_truth": "SELECT count(*) FROM Documents",
        "amends": [
            "Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency with the right SQL. Do reference table `Documents` with proper case instead of lowercase `documents` to match the correct table name. The amended query now matches RIGHT_SQL's behavior with identical functionality."
        ],
        "rules": [
            "When counting documents: use the exact table name \"Documents\" with proper case instead of lowercase \"documents\".",
            "When counting documents, When using the count function: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" for consistency with the correct SQL dialect."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM documents WHERE id = 1;",
            "SELECT count(*) FROM Documents;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM Documents;"
        ]
    },
    "299": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "List document IDs, document names, and document descriptions for all documents.",
        "ground_truth": "SELECT document_id ,  document_name ,  document_description FROM Documents",
        "amends": [
            "Do add `document_description` to the SELECT list instead of omitting it. Do reference the table as `Documents` instead of `documents` to match the correct case. The amended query now includes all required columns and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"List document IDs, document names, and document descriptions for all documents\": make sure the output order: document_id, document_name, document_description.",
            "When the question mentions \"document IDs\": \"document IDs\" actually means \"document_id in schema\".",
            "When the question mentions \"document names\": \"document names\" actually means \"document_name in schema\".",
            "When the question mentions \"document descriptions\": \"document descriptions\" actually means \"document_description in schema\".",
            "When answering about \"List document IDs, document names, and document descriptions for all documents\", When the question mentions \"document IDs\", When the question mentions \"document names\", When the question mentions \"document descriptions\", When referencing the documents table: use the exact identifier \"Documents\" with the correct case instead of \"documents\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id, document_name FROM documents;",
            "SELECT Document_ID, Document_Name, Document_Description FROM Documents;"
        ],
        "rule_sql": [
            "SELECT Document_ID, Document_Name, Document_Description FROM Documents ORDER BY Document_ID;"
        ]
    },
    "300": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the ids, names, and descriptions for all documents?",
        "ground_truth": "SELECT document_id ,  document_name ,  document_description FROM Documents",
        "amends": [
            "Do select `document_id`, `document_name`, and `document_description` instead of `id` and `name`. Do reference the `Documents` table instead of `documents`. The amended query now correctly retrieves all three document fields from the proper table with accurate column names."
        ],
        "rules": [
            "When answering about \"ids, names, and descriptions for all documents\": make sure the output order: document_id, document_name, document_description.",
            "When the question mentions \"ids\": \"ids\" actually means \"document_id in schema\".",
            "When the question mentions \"names\": \"names\" actually means \"document_name in schema\".",
            "When the question mentions \"descriptions\": \"descriptions\" actually means \"document_description in schema\".",
            "When answering about \"ids, names, and descriptions for all documents\", When the question mentions \"ids\", When the question mentions \"names\", When the question mentions \"descriptions\", When referring to the documents table: use the exact table name \"Documents\" with proper capitalization."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, name FROM documents;",
            "SELECT Document_ID, Document_Name, Document_Description FROM Documents;"
        ],
        "rule_sql": [
            "SELECT Document_ID, Document_Name, Document_Description FROM Documents ORDER BY Document_ID, Document_Name, Document_Description;"
        ]
    },
    "301": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the document name and template id for document with description with the letter 'w' in it?",
        "ground_truth": "SELECT document_name ,  template_id FROM Documents WHERE Document_Description LIKE \"%w%\"",
        "amends": [
            "Do reference the `Documents` table instead of `documents` to match the correct table name. Do use `Document_Description` column instead of `description` to reference the correct column name for the description field. Do use double quotes for the pattern matching instead of single quotes to maintain consistency with the right SQL format. The amended query now correctly filters documents based on the description containing 'w' and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When referencing the Documents table: use the exact table name \"Documents\" with double quotes and capital D.",
            "When filtering by document description: use the exact column name \"Document_Description\" with double quotes and capital D and capital D.",
            "When pattern matching for text containing the letter 'w': use double quotes around the pattern \"%w%\" for consistency with the SQL format.",
            "When referencing the Documents table, When filtering by document description, When pattern matching for text containing the letter 'w', When selecting document information: include both \"document_name\" and \"template_id\" columns in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_name, template_id FROM documents WHERE description LIKE '%w%';",
            "SELECT Document_Name, Template_ID FROM Documents WHERE Document_Description LIKE '%w%'"
        ],
        "rule_sql": [
            "SELECT \"document_name\", \"template_id\" FROM \"Documents\" WHERE \"Document_Description\" LIKE \"%w%\""
        ]
    },
    "302": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the names and template ids for documents that contain the letter w in their description.",
        "ground_truth": "SELECT document_name ,  template_id FROM Documents WHERE Document_Description LIKE \"%w%\"",
        "amends": [
            "Do use `document_name` instead of `name` in the SELECT list. Do use `Document_Description` instead of `description` in the WHERE filter. Do reference the table as `Documents` instead of `documents` in the FROM clause. Do use double quotes `\"%w%\"` instead of single quotes `'%w%'` for the LIKE pattern. The amended query now correctly references the actual column names and table name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for document names: use \"document_name\" instead of \"name\" in the output.",
            "When filtering documents by description containing the letter w: use \"Document_Description\" instead of \"description\" and match using the pattern \"%w%\".",
            "When referencing the documents table: use \"Documents\" instead of \"documents\" with proper case sensitivity.",
            "When the question asks for document names, When filtering documents by description containing the letter w, When referencing the documents table, When using string patterns in filters: use double quotes \"%w%\" instead of single quotes for the LIKE pattern."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, template_id FROM documents WHERE description LIKE '%w%';",
            "SELECT document_name, Template_ID FROM Documents WHERE Document_Description LIKE \"%w%\""
        ],
        "rule_sql": [
            "SELECT document_name, Template_ID FROM Documents WHERE Document_Description LIKE \"%w%\""
        ]
    },
    "303": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the document id, template id and description for document named \"Robbin CV\"?",
        "ground_truth": "SELECT document_id ,  template_id ,  Document_Description FROM Documents WHERE document_name  =  \"Robbin CV\"",
        "amends": [
            "Do use `Document_Description` instead of `description` in the SELECT list to match the correct column name. Do reference the table as `Documents` instead of `documents` to maintain proper case sensitivity. Do use double quotes `\"Robbin CV\"` instead of single quotes `'Robbin CV'` for the string literal in the WHERE clause. The amended query now correctly retrieves data from the proper column and table with the appropriate string formatting, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for \"description\": use the exact column name \"Document_Description\" instead of \"description\" to match the schema.",
            "When referencing the documents table: use the exact table name \"Documents\" with proper case sensitivity.",
            "When the question asks for \"description\", When referencing the documents table, When filtering for document named \"Robbin CV\": use double quotes \"Robbin CV\" for the string literal to match the required formatting."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id, template_id, description FROM documents WHERE document_name = 'Robbin CV';",
            "SELECT Document_ID, Template_ID, Document_Description FROM Documents WHERE Document_Name = \"Robbin CV\""
        ],
        "rule_sql": [
            "SELECT Document_ID, Template_ID, Document_Description FROM Documents WHERE Document_Name = \"Robbin CV\""
        ]
    },
    "304": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the document id, template id, and description for the document with the name Robbin CV.",
        "ground_truth": "SELECT document_id ,  template_id ,  Document_Description FROM Documents WHERE document_name  =  \"Robbin CV\"",
        "amends": [
            "Do reference `Document_Description` instead of `description` in the SELECT list. Do filter on `document_name = \"Robbin CV\"` instead of `name = 'Robbin CV'` in the WHERE clause. Do use table name `Documents` instead of `documents` and double quotes instead of single quotes for the string literal. The amended query now correctly references the actual column names and table name to match the intended behavior."
        ],
        "rules": [
            "When the question asks for document description: use the exact column name \"Document_Description\" instead of \"description\".",
            "When filtering by document name: use the exact column name \"document_name\" and the exact literal value \"Robbin CV\" with double quotes.",
            "When referencing the documents table: use the exact table name \"Documents\" with proper capitalization.",
            "When the question asks for document description, When filtering by document name, When referencing the documents table, When answering about document details: make sure the output order is document_id, template_id, Document_Description."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id, template_id, description FROM documents WHERE name = 'Robbin CV';",
            "SELECT Document_ID, Template_ID, Document_Description FROM Documents WHERE Document_Name = \"Robbin CV\""
        ],
        "rule_sql": [
            "SELECT document_id, template_id, Document_Description FROM Documents WHERE document_name = \"Robbin CV\""
        ]
    },
    "305": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "How many different templates do all document use?",
        "ground_truth": "SELECT count(DISTINCT template_id) FROM Documents",
        "amends": [
            "Do count `DISTINCT template_id` instead of counting all rows with `COUNT(*)`. Do reference the table as `Documents` instead of `documents` (case sensitivity). The amended query now correctly counts distinct template IDs rather than total document count, matching the intended behavior."
        ],
        "rules": [
            "When counting different templates used by documents: count distinct values of \"template_id\" from the \"Documents\" table.",
            "When counting different templates used by documents, When referring to the documents table: use the exact identifier \"Documents\" with proper case sensitivity as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM documents;",
            "SELECT COUNT(DISTINCT Template_ID) FROM Documents;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Template_ID) FROM Documents"
        ]
    },
    "306": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Count the number of different templates used for documents.",
        "ground_truth": "SELECT count(DISTINCT template_id) FROM Documents",
        "amends": [
            "Do use `count(DISTINCT template_id)` instead of `COUNT(*)` to count distinct template IDs rather than all rows. Do reference the table as `Documents` instead of `documents` to match the correct case. The amended query now correctly counts distinct template IDs from the Documents table instead of counting all rows, matching the intended behavior."
        ],
        "rules": [
            "When counting the number of different templates used for documents: count distinct values of template_id from the Documents table instead of counting all rows.",
            "When counting the number of different templates used for documents, When referencing the Documents table: use the exact identifier \"Documents\" with proper case instead of \"documents\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM documents;",
            "SELECT COUNT(DISTINCT Template_ID) FROM Documents;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Template_ID) FROM Documents WHERE Template_ID IS NOT NULL"
        ]
    },
    "307": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "How many documents are using the template with type code 'PPT'?",
        "ground_truth": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT'",
        "amends": [
            "Do add `JOIN Templates AS T2 ON T1.Template_ID = T2.Template_ID` instead of querying only the `documents` table. Do change the filter to `T2.Template_Type_Code = 'PPT'` instead of `template_type = 'PPT'` since the template type information resides in the Templates table rather than the Documents table. Do include the table alias `AS T1` for the Documents table instead of omitting it. The amended query now correctly joins the Documents and Templates tables to filter documents based on their associated template type, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"documents using template with type code 'PPT'\": join table \"Documents\" as T1 with table \"Templates\" as T2 using the exact key equality T1.Template_ID = T2.Template_ID and keep only matching pairs (inner match).",
            "When the question mentions \"template with type code 'PPT'\": filter for rows where T2.Template_Type_Code exactly equals 'PPT' (preserving case and quotes).",
            "When answering about \"documents using template with type code 'PPT'\", When the question mentions \"template with type code 'PPT'\", When the question asks for \"count of documents\": compute the number of rows using the canonical key from the documents table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM documents WHERE template_type = 'PPT';",
            "SELECT COUNT(*) \nFROM Documents AS T1\nJOIN Templates AS T2 ON T1.Template_ID = T2.Template_ID\nWHERE T2.Template_Type_Code = 'PPT'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.Document_ID) \nFROM Documents AS T1\nINNER JOIN Templates AS T2 ON T1.Template_ID = T2.Template_ID\nWHERE T2.Template_Type_Code = 'PPT'"
        ]
    },
    "308": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Count the number of documents that use the PPT template type.",
        "ground_truth": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT'",
        "amends": [
            "Do join `Templates AS T2` on `T1.Template_ID = T2.Template_ID` instead of querying only the `documents` table. Do filter on `T2.Template_Type_Code = 'PPT'` instead of filtering on a non-existent `template_type` column in the documents table. The amended query now correctly counts documents by joining with the Templates table to access the template type code, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"documents that use the PPT template type\": join the documents table (T1) with the Templates table (T2) using the exact key equality T1.Template_ID = T2.Template_ID, keeping only matching pairs (inner match).",
            "When filtering for PPT template type: filter on T2.Template_Type_Code = 'PPT' exactly as specified, preserving the exact literal value 'PPT'.",
            "When answering about \"documents that use the PPT template type\", When filtering for PPT template type, When counting documents: compute the number of rows using the canonical key from the documents table after applying the join and filter conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM documents WHERE template_type = 'PPT';",
            "SELECT COUNT(*) \nFROM Documents AS D\nJOIN Templates AS T ON D.Template_ID = T.Template_ID\nWHERE T.Template_Type_Code = 'PPT'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT D.Document_ID) \nFROM Documents D\nINNER JOIN Templates T ON D.Template_ID = T.Template_ID\nWHERE T.Template_Type_Code = 'PPT'"
        ]
    },
    "309": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all template ids and number of documents using each template.",
        "ground_truth": "SELECT template_id ,  count(*) FROM Documents GROUP BY template_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_id, COUNT(*) FROM documents GROUP BY template_id;"
        ],
        "rule_sql": [
            "SELECT t.Template_ID, COUNT(d.Document_ID) AS NumberOfDocuments\nFROM Templates t\nLEFT JOIN Documents d ON t.Template_ID = d.Template_ID\nGROUP BY t.Template_ID\nORDER BY t.Template_ID;",
            "SELECT t.Template_ID, COUNT(d.Document_ID) AS NumberOfDocuments\nFROM Templates t\nLEFT JOIN Documents d ON t.Template_ID = d.Template_ID\nGROUP BY t.Template_ID\nORDER BY t.Template_ID;"
        ]
    },
    "310": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are all different template ids used for documents, and how many times were each of them used?",
        "ground_truth": "SELECT template_id ,  count(*) FROM Documents GROUP BY template_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_id, COUNT(*) FROM documents GROUP BY template_id;"
        ],
        "rule_sql": [
            "SELECT Template_ID, COUNT(*) AS Usage_Count FROM Documents WHERE Template_ID IS NOT NULL GROUP BY Template_ID ORDER BY Template_ID;"
        ]
    },
    "311": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the id and type code for the template used by the most documents?",
        "ground_truth": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `Documents` and `Templates` tables with an `INNER JOIN` on `template_id` instead of querying only the `templates` table. Do select `T1.template_id` and `T2.Template_Type_Code` instead of `template_id` and `type_code`. Do add `GROUP BY T1.template_id` instead of omitting grouping. Do use `count(*)` for ordering instead of `COUNT(document_id)`. The amended query now correctly aggregates document counts per template and retrieves the corresponding template type code, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"template used by the most documents\": make sure the output order: T1.template_id, T2.Template_Type_Code.",
            "When the question mentions \"type code\": \"type code\" actually means \"Template_Type_Code in schema\".",
            "When combining Documents (T1) and Templates (T2) tables: link rows where T1.template_id = T2.template_id and keep only matching pairs (inner match).",
            "When the question asks for \"most documents\": rank rows by count(*) in descending direction and keep the first 1 row.",
            "When answering about \"template used by the most documents\", When the question mentions \"type code\", When combining Documents (T1) and Templates (T2) tables, When the question asks for \"most documents\", When the question asks for count of documents per template: compute the number of rows using count(*) per T1.template_id group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_id, type_code FROM templates ORDER BY COUNT(document_id) DESC LIMIT 1;",
            "SELECT T1.Template_ID, T2.Template_Type_Code\nFROM Documents T1\nINNER JOIN Templates T2 ON T1.Template_ID = T2.Template_ID\nGROUP BY T1.Template_ID\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Template_ID, T2.Template_Type_Code\nFROM Documents T1\nINNER JOIN Templates T2 ON T1.Template_ID = T2.Template_ID\nGROUP BY T1.Template_ID, T2.Template_Type_Code\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "312": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the id and type code of the template that is used for the greatest number of documents.",
        "ground_truth": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.template_id` and `T2.Template_Type_Code` instead of `id` and `type_code`. Do join `Documents AS T1` with `Templates AS T2` on `T1.template_id = T2.template_id` instead of querying only `templates` table. Do add `GROUP BY T1.template_id` instead of omitting grouping. Do order by `count(*) DESC` instead of `id DESC`. The amended query now correctly identifies the most frequently used template by document count rather than simply the highest template ID."
        ],
        "rules": [
            "When answering about \"template used for the greatest number of documents\": make sure the output order: T1.template_id, T2.Template_Type_Code.",
            "When the question mentions \"id\": \"id\" actually means \"T1.template_id in schema\".",
            "When the question mentions \"type code\": \"type code\" actually means \"T2.Template_Type_Code in schema\".",
            "When combining Documents AS T1 and Templates AS T2 for shared entities: link rows where T1.template_id = T2.template_id; keep only matching pairs (inner match).",
            "When the question asks for \"count of documents\": compute the number of rows using the canonical key token for documents (T1.template_id).",
            "When the question mentions \"greatest number\" or \"most frequently used\": rank rows by count(*) in descending direction and keep the first 1 row.",
            "When answering about \"template used for the greatest number of documents\", When the question mentions \"id\", When the question mentions \"type code\", When combining Documents AS T1 and Templates AS T2 for shared entities, When the question asks for \"count of documents\", When the question mentions \"greatest number\" or \"most frequently used\", When the question asks for \"per template\"/\"by template\": organize results by T1.template_id and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, type_code FROM templates ORDER BY id DESC LIMIT 1;",
            "SELECT T1.template_id, T2.Template_Type_Code\nFROM Documents AS T1\nJOIN Templates AS T2 ON T1.template_id = T2.template_id\nGROUP BY T1.template_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.template_id, T2.Template_Type_Code\nFROM Documents AS T1\nINNER JOIN Templates AS T2 ON T1.template_id = T2.Template_ID\nGROUP BY T1.template_id, T2.Template_Type_Code\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "313": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show ids for all templates that are used by more than one document.",
        "ground_truth": "SELECT template_id FROM Documents GROUP BY template_id HAVING count(*)  >  1",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_id FROM documents GROUP BY template_id HAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT t.Template_ID\nFROM Templates t\nJOIN Documents d ON t.Template_ID = d.Template_ID\nGROUP BY t.Template_ID\nHAVING COUNT(d.Document_ID) > 1;"
        ]
    },
    "314": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the template ids of any templates used in more than a single document?",
        "ground_truth": "SELECT template_id FROM Documents GROUP BY template_id HAVING count(*)  >  1",
        "amends": [
            "Do change the HAVING clause condition to `count(*) > 1` instead of `COUNT(*) = 1`, which now correctly identifies template_ids that appear more than once in the Documents table rather than those appearing exactly once. The amended query now matches RIGHT_SQL's behavior by returning template_ids with multiple occurrences."
        ],
        "rules": [
            "When counting occurrences of template_id in the documents table: use COUNT(*) to count all rows for each template_id.",
            "When identifying templates used in more than a single document: filter for template_ids where the count is greater than 1 (not equal to 1).",
            "When counting occurrences of template_id in the documents table, When identifying templates used in more than a single document, When answering about template ids of templates used in multiple documents: output only the template_id column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_id FROM documents GROUP BY template_id HAVING COUNT(*) = 1;",
            "SELECT Template_ID\nFROM Documents\nWHERE Template_ID IS NOT NULL\nGROUP BY Template_ID\nHAVING COUNT(*) > 1;"
        ],
        "rule_sql": [
            "SELECT Template_ID FROM Documents GROUP BY Template_ID HAVING COUNT(*) > 1"
        ]
    },
    "315": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show ids for all templates not used by any document.",
        "ground_truth": "SELECT template_id FROM Templates EXCEPT SELECT template_id FROM Documents",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do reference `template_id` in both SELECT clauses instead of selecting `id` from one table and `template_id` from another. Do capitalize table names consistently as `Templates` and `Documents` instead of lowercase `templates` and `documents`. The amended query now correctly handles potential NULL values in the subquery that could cause the NOT IN logic to fail, ensuring it matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"templates not used by any document\": use EXCEPT set operation instead of NOT IN with a subquery to handle potential NULL values correctly.",
            "When selecting template identifiers: reference \"template_id\" in both SELECT clauses of the EXCEPT operation instead of mixing \"id\" and \"template_id\".",
            "When answering about \"templates not used by any document\", When selecting template identifiers, When referring to table names: capitalize them consistently as \"Templates\" and \"Documents\" instead of using lowercase versions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM templates WHERE id NOT IN (SELECT template_id FROM documents)",
            "SELECT Template_ID FROM Templates\nEXCEPT\nSELECT Template_ID FROM Documents WHERE Template_ID IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT Template_ID FROM Templates\nEXCEPT\nSELECT Template_ID FROM Documents WHERE Template_ID IS NOT NULL"
        ]
    },
    "316": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the ids for templates that are not used in any documents?",
        "ground_truth": "SELECT template_id FROM Templates EXCEPT SELECT template_id FROM Documents",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do reference `template_id` in the main SELECT instead of `id`. Do capitalize table names `Templates` and `Documents` instead of lowercase `templates` and `documents`. The amended query now correctly uses set-based logic to find template IDs that exist in Templates but not in Documents, avoiding potential NULL handling issues with the NOT IN approach."
        ],
        "rules": [
            "When answering about \"template IDs not used in any documents\": use the EXCEPT set operation to find IDs present in Templates but absent from Documents.",
            "When selecting template identifiers: use \"template_id\" as the output column name instead of \"id\".",
            "When answering about \"template IDs not used in any documents\", When selecting template identifiers, When referencing database tables: use exact table names \"Templates\" and \"Documents\" with proper capitalization instead of lowercase versions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM templates WHERE id NOT IN (SELECT template_id FROM documents)",
            "SELECT Template_ID FROM Templates\nEXCEPT\nSELECT Template_ID FROM Documents WHERE Template_ID IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT template_id FROM Templates\nEXCEPT\nSELECT Template_ID FROM Documents;"
        ]
    },
    "317": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "How many templates do we have?",
        "ground_truth": "SELECT count(*) FROM Templates",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM templates;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Templates;"
        ]
    },
    "318": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Count the number of templates.",
        "ground_truth": "SELECT count(*) FROM Templates",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM templates;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Templates;"
        ]
    },
    "319": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show template ids, version numbers, and template type codes for all templates.",
        "ground_truth": "SELECT template_id ,  version_number ,  template_type_code FROM Templates",
        "amends": [
            "Do add `template_type_code` to the SELECT list instead of omitting it. Do capitalize the table name `Templates` instead of using lowercase `templates`. The amended query now correctly includes all required columns and uses proper table naming conventions."
        ],
        "rules": [
            "When the question asks for template ids, version numbers, and template type codes: include \"template_id\", \"version_number\", and \"template_type_code\" in the output columns.",
            "When referring to the templates table: use the exact table name \"Templates\" with capital T instead of lowercase \"templates\".",
            "When the question asks for template ids, version numbers, and template type codes, When referring to the templates table, When answering about all templates: make sure the output order includes template_id, version_number, and template_type_code as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_id, version_number FROM templates;",
            "SELECT Template_ID, Version_Number, Template_Type_Code FROM Templates;"
        ],
        "rule_sql": [
            "SELECT Template_ID, Version_Number, Template_Type_Code FROM Templates ORDER BY Template_ID, Version_Number, Template_Type_Code;"
        ]
    },
    "320": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the ids, version numbers, and type codes for each template?",
        "ground_truth": "SELECT template_id ,  version_number ,  template_type_code FROM Templates",
        "amends": [
            "Do select `template_id`, `version_number`, and `template_type_code` instead of `id`, `version`, and `type`. Do reference the table as `Templates` instead of `templates`. Do remove the `WHERE version > 5` filter instead of keeping it. Do remove the `ORDER BY id DESC` clause instead of including it. The amended query now correctly selects all columns from the Templates table without filtering or sorting, matching the intended behavior."
        ],
        "rules": [
            "When selecting columns for template information: use exact column names \"template_id\", \"version_number\", and \"template_type_code\" instead of generic names like id, version, or type.",
            "When referencing the templates table: use the exact table name \"Templates\" with proper case and quotes as shown in the schema.",
            "When the question asks for all templates without filtering conditions: do not apply any WHERE filters like version > 5.",
            "When selecting columns for template information, When referencing the templates table, When the question asks for all templates without filtering conditions, When the question does not specify any ordering requirements: do not include any ORDER BY clauses like ORDER BY id DESC."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, version, type FROM templates WHERE version > 5 ORDER BY id DESC",
            "SELECT Template_ID, Version_Number, Template_Type_Code FROM Templates;"
        ],
        "rule_sql": [
            "SELECT template_id, version_number, template_type_code FROM Templates;"
        ]
    },
    "321": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all distinct template type codes for all templates.",
        "ground_truth": "SELECT DISTINCT template_type_code FROM Templates",
        "amends": [
            "Do select `template_type_code` instead of `template_type` and add `DISTINCT` instead of omitting it. Do reference table `Templates` instead of `templates` to match the correct case sensitivity. The amended query now correctly retrieves unique template type codes from the Templates table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for \"template type codes\": use the exact column name \"template_type_code\" from the Templates table.",
            "When the question asks for \"distinct\" values: ensure only unique values of template_type_code are returned.",
            "When the question asks for \"template type codes\", When the question asks for \"distinct\" values, When referencing the Templates table: use the exact case-sensitive name \"Templates\" as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type FROM templates",
            "SELECT DISTINCT Template_Type_Code FROM Templates;"
        ],
        "rule_sql": [
            "SELECT DISTINCT template_type_code FROM Templates;"
        ]
    },
    "322": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the different template type codes?",
        "ground_truth": "SELECT DISTINCT template_type_code FROM Templates",
        "amends": [
            "Do select `template_type_code` instead of `template_type` and use `DISTINCT` instead of `GROUP BY` for deduplication. Do reference the table as `Templates` (case-sensitive) instead of `templates`. The amended query now correctly retrieves distinct template type codes from the Templates table."
        ],
        "rules": [
            "When the question asks for \"different template type codes\": select distinct \"template_type_code\" from \"Templates\".",
            "When referring to the templates table: use the exact identifier \"Templates\" with proper case sensitivity.",
            "When the question asks for \"different template type codes\", When referring to the templates table, When deduplicating values: use DISTINCT instead of GROUP BY for retrieving unique values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type FROM templates GROUP BY template_type;",
            "SELECT DISTINCT Template_Type_Code FROM Templates;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Template_Type_Code FROM Templates;"
        ]
    },
    "323": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the ids of templates with template type code PP or PPT?",
        "ground_truth": "SELECT template_id FROM Templates WHERE template_type_code  =  \"PP\" OR template_type_code  =  \"PPT\"",
        "amends": [
            "Do select `template_id` instead of `id` and change the table name to `Templates` instead of `templates`. Do use `OR` logic with `template_type_code = \"PP\"` OR `template_type_code = \"PPT\"` instead of incorrectly using `AND` with both conditions simultaneously. Do use double quotes `\"PP\"` and `\"PPT\"` instead of single quotes for the string literals. The amended query now correctly retrieves templates of either type PP or PPT instead of incorrectly requiring both types simultaneously."
        ],
        "rules": [
            "When selecting template identifiers: use \"template_id\" instead of \"id\" as the output column.",
            "When referring to the templates table: use the exact table name \"Templates\" with proper capitalization.",
            "When filtering for template type codes \"PP\" or \"PPT\": use OR logic with the exact string literals \"PP\" and \"PPT\" in double quotes, not AND logic that would require both conditions simultaneously.",
            "When selecting template identifiers, When referring to the templates table, When filtering for template type codes \"PP\" or \"PPT\", When comparing template type codes: use the exact column name \"template_type_code\" with the specified values \"PP\" or \"PPT\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM templates WHERE template_type_code = 'PP' AND template_type_code = 'PPT';",
            "SELECT Template_ID FROM Templates WHERE Template_Type_Code = \"PP\" OR Template_Type_Code = \"PPT\""
        ],
        "rule_sql": [
            "SELECT template_id FROM Templates WHERE template_type_code = \"PP\" OR template_type_code = \"PPT\""
        ]
    },
    "324": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the ids of templates that have the code PP or PPT.",
        "ground_truth": "SELECT template_id FROM Templates WHERE template_type_code  =  \"PP\" OR template_type_code  =  \"PPT\"",
        "amends": [
            "Do select `template_id` instead of `id` and use table name `Templates` instead of `templates`. Do filter on column `template_type_code` with values `\"PP\"` and `\"PPT\"` instead of column `code` with values `'PP'` and `'PPT'`. The amended query now correctly references the appropriate column names and table while maintaining the same filtering logic for template type codes."
        ],
        "rules": [
            "When the question asks for template ids: use the exact column name \"template_id\" from the Templates table.",
            "When the question mentions templates: use the exact table name \"Templates\" with proper casing.",
            "When the question asks for templates with code PP or PPT: filter on column \"template_type_code\" with exact values \"PP\" and \"PPT\" using double quotes.",
            "When the question asks for template ids, When the question mentions templates, When the question asks for templates with code PP or PPT, When answering about template ids: make sure the output order: template_id."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM templates WHERE code = 'PP' OR code = 'PPT';",
            "SELECT Template_ID FROM Templates WHERE Template_Type_Code IN ('PP', 'PPT')"
        ],
        "rule_sql": [
            "SELECT template_id FROM Templates WHERE template_type_code = \"PP\" OR template_type_code = \"PPT\" ORDER BY template_id;"
        ]
    },
    "325": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "How many templates have template type code CV?",
        "ground_truth": "SELECT count(*) FROM Templates WHERE template_type_code  =  \"CV\"",
        "amends": [
            "Do reference the table as `Templates` instead of `templates` to match the correct case sensitivity. Do use the column `template_type_code` instead of `template_type` to reference the correct column name. Do use double quotes `\"CV\"` instead of single quotes `'CV'` for the string literal value. The amended query now correctly counts records from the Templates table where the template_type_code equals \"CV\", matching the intended behavior."
        ],
        "rules": [
            "When referencing the Templates table: use the exact identifier \"Templates\" with proper case sensitivity.",
            "When filtering by template type code: use the exact column name \"template_type_code\" instead of \"template_type\".",
            "When comparing with the literal value CV: use double quotes \"CV\" instead of single quotes to match the required string format.",
            "When referencing the Templates table, When filtering by template type code, When comparing with the literal value CV, When counting templates: count all rows from the Templates table that satisfy the condition template_type_code = \"CV\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM templates WHERE template_type = 'CV';",
            "SELECT COUNT(*) FROM Templates WHERE template_type_code = \"CV\";"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Templates WHERE template_type_code = \"CV\";"
        ]
    },
    "326": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Count the number of templates of the type CV.",
        "ground_truth": "SELECT count(*) FROM Templates WHERE template_type_code  =  \"CV\"",
        "amends": [
            "Do reference the table as `Templates` instead of `templates` to match the correct case sensitivity. Do use the column `template_type_code` instead of `type` to reference the appropriate column name. Do use double quotes `\"CV\"` instead of single quotes `'CV'` for the string literal value. The amended query now correctly counts records from the Templates table where the template_type_code equals \"CV\", matching the intended behavior."
        ],
        "rules": [
            "When referencing the templates table: use the exact identifier \"Templates\" with proper case sensitivity.",
            "When filtering by template type: use the column \"template_type_code\" instead of \"type\".",
            "When comparing against the literal value CV: use double quotes \"CV\" instead of single quotes.",
            "When referencing the templates table, When filtering by template type, When comparing against the literal value CV, When counting templates: count all rows from the Templates table where template_type_code equals \"CV\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM templates WHERE type = 'CV';",
            "SELECT COUNT(*) FROM Templates WHERE template_type_code = \"CV\";"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Templates WHERE template_type_code = \"CV\";"
        ]
    },
    "327": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the version number and template type code for the template with version number later than 5?",
        "ground_truth": "SELECT version_number ,  template_type_code FROM Templates WHERE version_number  >  5",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT version_number, template_type_code FROM templates WHERE version_number > 5;"
        ],
        "rule_sql": [
            "SELECT Version_Number, Template_Type_Code FROM Templates WHERE Version_Number > 5"
        ]
    },
    "328": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the version numbers and template type codes of templates with a version number greater than 5.",
        "ground_truth": "SELECT version_number ,  template_type_code FROM Templates WHERE version_number  >  5",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT version_number, template_type_code FROM templates WHERE version_number > 5;"
        ],
        "rule_sql": [
            "SELECT Version_Number, Template_Type_Code FROM Templates WHERE Version_Number > 5"
        ]
    },
    "329": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all template type codes and number of templates for each.",
        "ground_truth": "SELECT template_type_code ,  count(*) FROM Templates GROUP BY template_type_code",
        "amends": [
            "Do reference `template_type_code` in the SELECT list instead of `template_type` to match the GROUP BY clause and ensure correct aggregation. Do use the correct table name `Templates` (case-sensitive) instead of `templates` to properly reference the database object. The amended query now correctly counts records grouped by template_type_code as intended in the RIGHT_SQL."
        ],
        "rules": [
            "When the question asks for \"template type codes\": output the exact column \"template_type_code\" from table \"Templates\".",
            "When the question asks for \"number of templates for each\": count the number of rows using the canonical key from table \"Templates\" grouped by \"template_type_code\".",
            "When choosing identifier delimiters: use the exact case-sensitive table name \"Templates\" as shown in the schema, not \"templates\".",
            "When the question asks for \"template type codes\", When the question asks for \"number of templates for each\", When choosing identifier delimiters, When grouping by \"template_type_code\": ensure the output column in the SELECT list matches the grouping column \"template_type_code\" exactly, not \"template_type\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type, COUNT(*) FROM templates GROUP BY template_type_code;",
            "SELECT Template_Type_Code, COUNT(*) AS Number_of_Templates FROM Templates GROUP BY Template_Type_Code"
        ],
        "rule_sql": [
            "SELECT template_type_code, COUNT(Template_ID) AS number_of_templates FROM Templates GROUP BY template_type_code;"
        ]
    },
    "330": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the different template type codes, and how many templates correspond to each?",
        "ground_truth": "SELECT template_type_code ,  count(*) FROM Templates GROUP BY template_type_code",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code, COUNT(*) FROM templates GROUP BY template_type_code;"
        ],
        "rule_sql": [
            "SELECT t.Template_Type_Code, COUNT(t.Template_ID) AS Template_Count\nFROM Templates t\nGROUP BY t.Template_Type_Code\nORDER BY t.Template_Type_Code;"
        ]
    },
    "331": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Which template type code has most number of templates?",
        "ground_truth": "SELECT template_type_code FROM Templates GROUP BY template_type_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `template_type_code` instead of including `COUNT(*) as template_count` in the SELECT list. Do order by `count(*) DESC` instead of `template_count ASC` to find the most frequent template type. Do remove the alias `template_count` from the ORDER BY clause since it's no longer selected. The amended query now correctly identifies the template type with the highest count by ordering in descending order by the count aggregation."
        ],
        "rules": [
            "When answering about \"which template type code has most number of templates\": make sure the output order includes only template_type_code.",
            "When counting templates: compute the number of rows using the count(*) function.",
            "When the question mentions \"most number\" or \"highest count\": rank rows by count(*) in descending order and keep the first 1 row.",
            "When answering about \"which template type code has most number of templates\", When counting templates, When the question mentions \"most number\" or \"highest count\", When grouping by template_type_code: organize results by template_type_code and compute count(*) per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code, COUNT(*) as template_count FROM templates GROUP BY template_type_code ORDER BY template_count ASC LIMIT 1;",
            "SELECT Template_Type_Code\nFROM Templates\nGROUP BY Template_Type_Code\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Template_Type_Code\nFROM Templates\nGROUP BY Template_Type_Code\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "332": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the type code of the template type that the most templates belong to.",
        "ground_truth": "SELECT template_type_code FROM Templates GROUP BY template_type_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `template_type_code` from the `Templates` table instead of `type_code` from `template_types`. Do add `GROUP BY template_type_code` to aggregate by the grouping column instead of omitting it. Do use the aggregate function `count(*)` in the ORDER BY clause instead of the invalid `COUNT(*)` without grouping. The amended query now correctly aggregates template counts by type and returns the most frequent template type, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"the type code of the template type that the most templates belong to\": make sure the output order: template_type_code.",
            "When the question asks for \"count of templates\": compute the number of rows using the canonical key token for templates (e.g., Templates.template_type_code).",
            "When the question says \"per template_type_code\"/\"by template_type_code\": organize results by template_type_code and compute requested aggregates per group.",
            "When answering about \"the type code of the template type that the most templates belong to\", When the question asks for \"count of templates\", When the question says \"per template_type_code\"/\"by template_type_code\", When the question mentions \"most templates\": rank rows by count(*) in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type_code FROM template_types ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT template_type_code FROM Templates GROUP BY template_type_code ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Template_Type_Code\nFROM Templates\nGROUP BY Template_Type_Code\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "333": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all template type codes with less than three templates.",
        "ground_truth": "SELECT template_type_code FROM Templates GROUP BY template_type_code HAVING count(*)  <  3",
        "amends": [
            "Do remove the `COUNT(*) as template_count` column from the SELECT list instead of including it. Do change the HAVING condition to `count(*) < 3` instead of `template_count > 3`, using the aggregate function directly rather than the alias. Do use the correct table name `Templates` (with capital T) instead of `templates` to match the actual schema. The amended query now correctly filters for template type codes that have fewer than 3 templates rather than those with more than 3, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about template type codes with less than three templates: make sure the output order includes only template_type_code.",
            "When counting templates per template type code: use the aggregate function count(*) directly in the HAVING condition rather than using an alias.",
            "When filtering for template type codes with less than three templates: use the condition count(*) < 3 instead of count(*) > 3.",
            "When answering about template type codes with less than three templates, When counting templates per template type code, When filtering for template type codes with less than three templates, When referring to the templates table: use the exact table name \"Templates\" with capital T instead of lowercase \"templates\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code, COUNT(*) as template_count FROM templates GROUP BY template_type_code HAVING template_count > 3;",
            "SELECT Template_Type_Code FROM Templates GROUP BY Template_Type_Code HAVING COUNT(*) < 3"
        ],
        "rule_sql": [
            "SELECT Template_Type_Code FROM Templates GROUP BY Template_Type_Code HAVING COUNT(*) < 3"
        ]
    },
    "334": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the codes of template types that have fewer than 3 templates?",
        "ground_truth": "SELECT template_type_code FROM Templates GROUP BY template_type_code HAVING count(*)  <  3",
        "amends": [
            "Do use `count(*) < 3` in the HAVING clause instead of `COUNT(*) > 3` to filter for template type codes with fewer than 3 occurrences rather than more than 3 occurrences. The amended query now correctly identifies template type codes with less than 3 records, matching the intended behavior of the right SQL."
        ],
        "rules": [
            "When counting templates per template type: use the exact column \"template_type_code\" for grouping and count all rows using COUNT(*)",
            "When filtering for template types with fewer than 3 templates: use the condition COUNT(*) < 3 in the HAVING clause",
            "When counting templates per template type, When filtering for template types with fewer than 3 templates, When the question asks for template type codes: output only the \"template_type_code\" column"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code FROM templates GROUP BY template_type_code HAVING COUNT(*) > 3;",
            "SELECT Template_Type_Code\nFROM Templates\nGROUP BY Template_Type_Code\nHAVING COUNT(*) < 3"
        ],
        "rule_sql": [
            "SELECT template_type_code FROM Templates GROUP BY template_type_code HAVING COUNT(*) < 3"
        ]
    },
    "335": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What the smallest version number and its template type code?",
        "ground_truth": "SELECT min(Version_Number) ,  template_type_code FROM Templates",
        "amends": [
            "Do use `MIN(version_number)` instead of `MAX(version_number)` to find the smallest version number. Do keep `template_type_code` in the SELECT list instead of removing it. Do maintain `ORDER BY version_number ASC` instead of changing the ordering. Do preserve `LIMIT 1` instead of modifying the row limitation. The amended query now correctly retrieves the minimum version number with its corresponding template type code, matching the intended behavior."
        ],
        "rules": [
            "When finding the smallest version number: use MIN(\"version_number\") instead of MAX(\"version_number\").",
            "When retrieving the template type code associated with the smallest version number: include \"template_type_code\" in the output columns.",
            "When ordering results to find the smallest version number: sort by \"version_number\" in ascending order.",
            "When finding the smallest version number, When retrieving the template type code associated with the smallest version number, When ordering results to find the smallest version number, When limiting results to only the smallest version number: keep only the first row using LIMIT 1."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(version_number), template_type_code FROM templates ORDER BY version_number ASC LIMIT 1;",
            "SELECT MIN(Version_Number) AS smallest_version, Template_Type_Code FROM Templates ORDER BY Version_Number ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT MIN(Version_Number) AS smallest_version_number, Template_Type_Code FROM Templates ORDER BY Version_Number ASC LIMIT 1;"
        ]
    },
    "336": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the lowest version number, along with its corresponding template type code.",
        "ground_truth": "SELECT min(Version_Number) ,  template_type_code FROM Templates",
        "amends": [
            "Do use `MIN` aggregate function on `Version_Number` instead of `MAX` on `version_number`, and do reference the table as `Templates` with proper case instead of `templates` lowercase. The amended query now correctly retrieves the minimum version number per template type rather than the maximum, matching the intended behavior.",
            "Do use lowercase `min(Version_Number)` without an alias instead of `MIN(Version_Number) AS Lowest_Version_Number` with an alias. Do use lowercase `template_type_code` instead of `Template_Type_Code` in both the SELECT list and GROUP BY clause. Do remove the alias `Lowest_Version_Number` instead of keeping it. The amended query now matches the right SQL's behavior with consistent lowercase function and column names and no output column aliasing.",
            "Do include the comma separator between `min(Version_Number)` and `template_type_code` in the SELECT list instead of omitting it, as the missing comma would cause a syntax error. The amended query now correctly retrieves the minimum version number for each template type code from the Templates table with proper SQL syntax.",
            "Do include the space after the comma in `min(Version_Number) , template_type_code` instead of omitting it to maintain proper SQL syntax formatting, though this is purely cosmetic and does not affect the query's logical behavior or results. The amended query now matches RIGHT_SQL's behavior with identical functionality.",
            "Do include the space after the comma in `min(Version_Number) , template_type_code` instead of omitting it, as the spacing difference affects query formatting consistency while maintaining identical semantic behavior. The amended query now matches RIGHT_SQL's behavior with proper spacing conventions.",
            "Do include the space after `min(Version_Number)` instead of omitting it, and do add proper spacing around the comma in the SELECT list instead of having no spacing. The amended query now matches RIGHT_SQL's behavior with correct formatting while maintaining the same logical structure and functionality.",
            "Do include the space after `min(Version_Number)` instead of omitting it, and do add proper spacing around the comma in the SELECT list instead of having no space. Do maintain the same GROUP BY clause with `template_type_code` instead of changing it. The amended query now matches RIGHT_SQL's behavior with corrected formatting while preserving the same logical structure and output.",
            "Do include the space before `template_type_code` in the SELECT list instead of omitting it, as the RIGHT_SQL maintains consistent spacing around the comma separator. The amended query now matches RIGHT_SQL's behavior with proper formatting.",
            "Do include the space after the comma in `template_type_code` instead of omitting it, as the RIGHT_SQL maintains proper column spacing. The amended query now matches RIGHT_SQL's behavior with identical column formatting.",
            "Do include the space after the comma in the SELECT list instead of omitting it, as the RIGHT_SQL maintains proper column separation syntax. The amended query now matches RIGHT_SQL's behavior with identical output structure and results.",
            "Do include the space before `template_type_code` in the SELECT list instead of omitting it, as the RIGHT_SQL maintains consistent spacing around the comma separator. The amended query now matches RIGHT_SQL's behavior with identical output structure and results.",
            "Do include the space after the comma in `template_type_code` instead of omitting it, as the RIGHT_SQL maintains proper column separation syntax. The amended query now matches RIGHT_SQL's behavior with identical column formatting and spacing.",
            "Do include the space after the comma in the SELECT list instead of omitting it, as the RIGHT_SQL maintains proper column separation syntax. The amended query now matches RIGHT_SQL's behavior with identical output structure and results.",
            "Do include the space before `template_type_code` in the SELECT list instead of omitting it, as the RIGHT_SQL maintains consistent spacing around the comma separator. The amended query now matches RIGHT_SQL's behavior with identical column selection and grouping logic.",
            "Do include the space after the comma in the SELECT list instead of omitting it, maintaining the proper syntax for separating columns. The amended query now matches RIGHT_SQL's behavior with correct column formatting.",
            "Do include the space after the comma in the SELECT list instead of omitting it, maintaining the proper syntax for separating columns. The amended query now matches RIGHT_SQL's behavior with correct column formatting."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(version_number), template_type_code FROM templates GROUP BY template_type_code;",
            "SELECT MIN(Version_Number) AS Lowest_Version_Number, Template_Type_Code FROM Templates GROUP BY Template_Type_Code;",
            "SELECT min(Version_Number), template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number), template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number), template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number), template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number), template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code"
        ],
        "rule_sql": []
    },
    "337": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the template type code of the template used by document with the name \"Data base\"?",
        "ground_truth": "SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T2.document_name  =  \"Data base\"",
        "amends": [
            "Do select `T1.template_type_code` from the `Templates` table instead of `template_type_code` from the `documents` table. Do join `Templates AS T1` with `Documents AS T2` using `ON T1.template_id = T2.template_id` instead of querying only the `documents` table. Do filter on `T2.document_name = \"Data base\"` instead of `name = 'Data base'`. The amended query now correctly retrieves template type codes by joining the Templates and Documents tables and filtering by document name, matching the intended behavior."
        ],
        "rules": [
            "When answering about template type code for a document: select T1.template_type_code from the Templates table instead of from the documents table.",
            "When combining Templates and Documents tables: join Templates AS T1 with Documents AS T2 using ON T1.template_id = T2.template_id to link template information to documents.",
            "When answering about template type code for a document, When combining Templates and Documents tables, When filtering by document name: use T2.document_name = \"Data base\" instead of name = 'Data base' to match the exact document name literal with correct column reference."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code FROM documents WHERE name = 'Data base';",
            "SELECT T1.Template_Type_Code \nFROM Templates AS T1 \nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID \nWHERE T2.Document_Name = 'Data base'"
        ],
        "rule_sql": [
            "SELECT T1.Template_Type_Code \nFROM Templates AS T1 \nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID \nWHERE T2.Document_Name = 'Data base'"
        ]
    },
    "338": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the template type code of the template that is used by a document named Data base.",
        "ground_truth": "SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T2.document_name  =  \"Data base\"",
        "amends": [
            "Do add table `Documents AS T2` with a `JOIN` on `T1.template_id = T2.template_id` instead of querying only the `templates` table. Do reference `template_type_code` as `T1.template_type_code` instead of just `template_type_code`. Do move the filter condition to `T2.document_name = \"Data base\"` instead of `document_name = 'Data base'` on the templates table. Do use double quotes around the string literal \"Data base\" instead of single quotes. The amended query now correctly joins the Templates and Documents tables to find template_type_code based on document_name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about template type code for a document: make sure the output order: T1.template_type_code",
            "When the question mentions \"document named Data base\": \"Data base\" actually means T2.document_name = \"Data base\" in schema",
            "When combining Templates (T1) and Documents (T2) for shared entities: link rows where T1.template_id = T2.template_id; keep only matching pairs (inner match)",
            "When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms",
            "When answering about template type code for a document, When the question mentions \"document named Data base\", When combining Templates (T1) and Documents (T2) for shared entities, When choosing identifier delimiters, When handling text literals: do not change case, spacing, or punctuation - use exact literal \"Data base\" with double quotes"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code FROM templates WHERE document_name = 'Data base';",
            "SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id = T2.template_id WHERE T2.document_name = \"Data base\""
        ],
        "rule_sql": [
            "SELECT T1.Template_Type_Code\nFROM Templates T1\nINNER JOIN Documents T2 ON T1.Template_ID = T2.Template_ID\nWHERE T2.Document_Name = \"Data base\""
        ]
    },
    "339": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all document names using templates with template type code BK.",
        "ground_truth": "SELECT T2.document_name FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T1.template_type_code  =  \"BK\"",
        "amends": [
            "Do join `Templates AS T1` to `Documents AS T2` on `T1.template_id = T2.template_id` instead of querying only the `documents` table without any join. Do reference the column as `T2.document_name` instead of just `document_name` to specify the table source. Do filter on `T1.template_type_code = \"BK\"` instead of `template_type = 'BK'` to use the correct table and column name with proper quoting. The amended query now correctly retrieves document names by joining through the template relationship and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"document names using templates with template type code BK\": make sure the output order: T2.document_name",
            "When combining Templates as T1 and Documents as T2 for shared entities: link rows where T1.template_id = T2.template_id and keep only matching pairs (inner match).",
            "When filtering for template type code BK: use T1.template_type_code = \"BK\" with exact double quotes around the literal value.",
            "When answering about \"document names using templates with template type code BK\", When combining Templates as T1 and Documents as T2 for shared entities, When filtering for template type code BK, When selecting document names: reference the column as T2.document_name to specify the table source."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_name FROM documents WHERE template_type = 'BK';",
            "SELECT T2.document_name FROM Templates AS T1 JOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID WHERE T1.Template_Type_Code = 'BK'"
        ],
        "rule_sql": [
            "SELECT T2.document_name\nFROM Templates AS T1\nINNER JOIN Documents AS T2 ON T1.template_id = T2.template_id\nWHERE T1.template_type_code = \"BK\""
        ]
    },
    "340": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the names of documents that use templates with the code BK?",
        "ground_truth": "SELECT T2.document_name FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T1.template_type_code  =  \"BK\"",
        "amends": [
            "Do select `T2.document_name` instead of `d.name` for the column name. Do use `Templates AS T1` and `Documents AS T2` as table aliases instead of `documents d` and `templates t`. Do join on `T1.template_id = T2.template_id` instead of `d.template_id = t.id` for the join condition. Do filter on `T1.template_type_code = \"BK\"` instead of `t.code = 'BK'` for the WHERE condition. The amended query now correctly retrieves document names by joining on template_id and filtering by template_type_code instead of code, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"names of documents that use templates with code BK\": make sure the output order: T2.document_name.",
            "When the question mentions \"documents\": use table \"Documents AS T2\" with exact alias T2.",
            "When the question mentions \"templates with code BK\": use table \"Templates AS T1\" with exact alias T1 and filter on T1.template_type_code = \"BK\" with exact literal \"BK\".",
            "When answering about \"names of documents that use templates with code BK\", When the question mentions \"documents\", When the question mentions \"templates with code BK\", When combining T1 and T2 for shared template relationships: link rows where T1.template_id = T2.template_id exactly as shown; keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.name FROM documents d JOIN templates t ON d.template_id = t.id WHERE t.code = 'BK';",
            "SELECT T2.Document_Name \nFROM Templates AS T1 \nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID \nWHERE T1.Template_Type_Code = 'BK'"
        ],
        "rule_sql": [
            "SELECT T2.Document_Name FROM Templates AS T1 INNER JOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID WHERE T1.Template_Type_Code = 'BK'"
        ]
    },
    "341": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all template type codes and the number of documents using each type.",
        "ground_truth": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code",
        "amends": [
            "Do join `Templates AS T1` to `Documents AS T2` on `T1.template_id = T2.template_id` instead of querying only the `documents` table without any join. Do reference `T1.template_type_code` in both SELECT and GROUP BY clauses instead of using just `template_type_code` without table qualification. The amended query now correctly counts documents per template type by properly joining the Templates and Documents tables to establish the relationship between template types and the documents that use them.",
            "Do use `INNER JOIN` instead of `LEFT JOIN` to only count documents that actually exist. Do use `count(*)` instead of `COUNT(T2.Document_ID)` to count all joined rows rather than non-null document IDs. Do remove the alias `NumberOfDocuments` instead of keeping it since the right query omits column aliases. Do reference `template_type_code` and `template_id` in lowercase instead of mixed case to match the right query's column naming convention. The amended query now correctly counts only documents with matching templates and matches the right SQL's behavior."
        ],
        "rules": [
            "When answering about \"template type codes and number of documents using each type\": make sure the output order: T1.template_type_code, count of documents per template type.",
            "When combining Templates (T1) and Documents (T2) for shared entities: link rows where T1.template_id = T2.template_id exactly as shown; keep only matching pairs (inner match).",
            "When the question asks for \"number of documents using each type\": compute the count of documents using T2.template_id as the counting key per template type group.",
            "When the question mentions \"template type codes\": \"template type codes\" actually means T1.template_type_code in schema.",
            "When answering about \"template type codes and number of documents using each type\", When combining Templates (T1) and Documents (T2) for shared entities, When the question asks for \"number of documents using each type\", When the question mentions \"template type codes\", When the question says \"per template type\": organize results by T1.template_type_code and compute document count per group.",
            "When combining Templates and Documents tables: link rows where T1.template_id equals T2.template_id using an inner join to only include matching pairs.",
            "When counting documents per template type: count all joined rows using count(*) rather than counting specific columns.",
            "When outputting results: show template_type_code and the count without column aliases.",
            "When combining Templates and Documents tables, When counting documents per template type, When outputting results, When referencing column identifiers: use lowercase template_type_code and template_id to match the schema's naming convention."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code, COUNT(*) FROM documents GROUP BY template_type_code;",
            "SELECT T1.Template_Type_Code, COUNT(T2.Document_ID) AS NumberOfDocuments\nFROM Templates AS T1\nLEFT JOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID\nGROUP BY T1.Template_Type_Code",
            "SELECT T1.template_type_code, COUNT(*) \nFROM Templates AS T1 \nINNER JOIN Documents AS T2 ON T1.template_id = T2.template_id \nGROUP BY T1.template_type_code"
        ],
        "rule_sql": [
            "SELECT T1.template_type_code, COUNT(*) \nFROM Templates T1 \nINNER JOIN Documents T2 ON T1.template_id = T2.template_id \nGROUP BY T1.template_type_code"
        ]
    },
    "342": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the different template type codes, and how many documents use each type?",
        "ground_truth": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code",
        "amends": [
            "Do join `Templates AS T1` to `Documents AS T2` on `T1.template_id = T2.template_id` instead of querying only the `documents` table without any join. Do reference `T1.template_type_code` in both SELECT and GROUP BY instead of directly using `template_type_code` without table qualification. Do remove the `ORDER BY document_count DESC` clause instead of keeping it, as the right query focuses only on aggregation without sorting. Do remove the alias `document_count` from the COUNT(*) expression instead of keeping it, since the right query returns the count without column naming. The amended query now correctly joins the Templates and Documents tables to count documents per template type while matching the right SQL's behavior."
        ],
        "rules": [
            "When answering about \"different template type codes and how many documents use each type\": make sure to join Templates table as T1 to Documents table as T2 on T1.template_id = T2.template_id instead of querying only one table.",
            "When selecting template type codes: use T1.template_type_code in both SELECT and GROUP BY instead of unqualified template_type_code.",
            "When counting documents per template type: count using the join result without column aliases instead of using document_count alias.",
            "When answering about \"different template type codes and how many documents use each type\", When selecting template type codes, When counting documents per template type, When producing the final result: do not include ORDER BY clause as the question does not require sorting."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code, COUNT(*) as document_count FROM documents GROUP BY template_type_code ORDER BY document_count DESC;",
            "SELECT T1.Template_Type_Code, COUNT(*) \nFROM Templates AS T1 \nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID \nGROUP BY T1.Template_Type_Code"
        ],
        "rule_sql": [
            "SELECT T1.Template_Type_Code, COUNT(*) \nFROM Templates T1 \nJOIN Documents T2 ON T1.Template_ID = T2.Template_ID \nGROUP BY T1.Template_Type_Code"
        ]
    },
    "343": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Which template type code is used by most number of documents?",
        "ground_truth": "SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `Templates AS T1` to `Documents AS T2` on `T1.template_id = T2.template_id` instead of querying only the `documents` table without any join. Do select only `T1.template_type_code` instead of selecting both `template_type_code` and `COUNT(*) as document_count`. Do group by `T1.template_type_code` instead of grouping by `template_type_code` without table qualification. Do order by `count(*) DESC` instead of ordering by `document_count ASC`. The amended query now correctly identifies the template type with the highest document count by joining the Templates and Documents tables and ordering by descending count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"template type code used by most documents\": join Templates as T1 to Documents as T2 on T1.template_id = T2.template_id to link template information with document records.",
            "When counting documents per template type: count the number of rows using the canonical key from the join.",
            "When grouping by template type: organize results by T1.template_type_code to get counts per template type.",
            "When finding the most used template type: order the results by count in descending order to identify the highest count.",
            "When answering about \"template type code used by most documents\", When counting documents per template type, When grouping by template type, When finding the most used template type, When selecting output columns: return only T1.template_type_code as the result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code, COUNT(*) as document_count FROM documents GROUP BY template_type_code ORDER BY document_count ASC LIMIT 1;",
            "SELECT T1.Template_Type_Code\nFROM Templates AS T1\nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID\nGROUP BY T1.Template_Type_Code\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Template_Type_Code\nFROM Templates T1\nJOIN Documents T2 ON T1.Template_ID = T2.Template_ID\nGROUP BY T1.Template_Type_Code\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "344": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the code of the template type that is most commonly used in documents.",
        "ground_truth": "SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `Templates AS T1` to `Documents AS T2` on `T1.template_id = T2.template_id` instead of querying only the `documents` table without any join. Do specify `T1.template_type_code` in the SELECT clause with table alias qualification instead of just `template_type_code` without table reference. Do maintain the same `GROUP BY T1.template_type_code`, `ORDER BY count(*) DESC`, and `LIMIT 1` structure as the original query. The amended query now correctly joins the Templates and Documents tables to ensure template_type_code is properly sourced from the Templates table while counting document associations, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"most commonly used template type in documents\": make sure the output order: T1.template_type_code",
            "When combining Templates table (T1) and Documents table (T2): link rows where T1.template_id = T2.template_id and keep only matching pairs (inner match)",
            "When counting documents per template type: compute the number of rows using the join relationship between T1 and T2",
            "When the question asks for the most common template type: rank template types by document count in descending order and keep the first 1 row",
            "When answering about \"most commonly used template type in documents\", When combining Templates table (T1) and Documents table (T2), When counting documents per template type, When the question asks for the most common template type, When selecting template_type_code: use T1.template_type_code with table alias qualification instead of unqualified template_type_code"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code FROM documents GROUP BY template_type_code ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T1.Template_Type_Code\nFROM Templates AS T1\nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID\nGROUP BY T1.Template_Type_Code\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.template_type_code\nFROM Templates T1\nINNER JOIN Documents T2 ON T1.template_id = T2.template_id\nGROUP BY T1.template_type_code\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "345": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all template type codes that are not used by any document.",
        "ground_truth": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id",
        "amends": [
            "Do use `EXCEPT` set operation between two queries instead of `GROUP BY` with `HAVING COUNT(*) > 0`. Do change the source table from `documents` to `Templates` in the first part and add a second query joining `Templates AS T1` with `Documents AS T2` on `T1.template_id = T2.template_id` instead of only querying from `documents`. Do remove the `GROUP BY template_type_code` clause and `HAVING COUNT(*) > 0` filter instead of keeping them. The amended query now correctly identifies template types that exist in Templates but have no associated documents, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"template type codes that are not used by any document\": use an EXCEPT set operation between two queries instead of GROUP BY with HAVING COUNT(*) > 0.",
            "When identifying template types from the Templates table: select template_type_code from Templates AS T1.",
            "When identifying template types used in documents: select template_type_code from Templates AS T1 JOIN Documents AS T2 ON T1.template_id = T2.template_id.",
            "When combining tables for template usage: link rows where T1.template_id = T2.template_id exactly and keep only matching pairs (inner match).",
            "When answering about \"template type codes that are not used by any document\", When identifying template types from the Templates table, When identifying template types used in documents, When combining tables for template usage, When finding unused template types: compute the set difference between all template_type_code values from Templates and those used in Documents."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code FROM documents GROUP BY template_type_code HAVING COUNT(*) > 0;",
            "SELECT Template_Type_Code FROM Templates\nEXCEPT\nSELECT T1.Template_Type_Code FROM Templates AS T1\nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID"
        ],
        "rule_sql": [
            "SELECT Template_Type_Code FROM Templates\nEXCEPT\nSELECT T1.Template_Type_Code FROM Templates AS T1\nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID"
        ]
    },
    "346": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the codes of template types that are not used for any document?",
        "ground_truth": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with subquery for better performance and clarity. Do reference table `Templates` instead of `template_types` to match the correct schema. Do join `Templates AS T1` with `Documents AS T2` on `T1.template_id = T2.template_id` instead of using a subquery with `DISTINCT template_type_code FROM documents`. Do remove the `WHERE` clause with subquery entirely and replace it with the `EXCEPT` operation between two complete SELECT statements. The amended query now correctly identifies template types that exist in Templates but not in any Documents through proper table joins and set operations."
        ],
        "rules": [
            "When answering about \"codes of template types that are not used for any document\": make sure the output order: template_type_code.",
            "When the question mentions \"template types\": \"template types\" actually means \"Templates table in schema\".",
            "When the question mentions \"not used for any document\": use EXCEPT set operation to find template_type_code values that exist in Templates but not in Documents.",
            "When combining T1 (Templates) and T2 (Documents) for shared entities: link rows where T1.template_id = T2.template_id; keep only matching pairs (inner match).",
            "When answering about \"codes of template types that are not used for any document\", When the question mentions \"template types\", When the question mentions \"not used for any document\", When combining T1 (Templates) and T2 (Documents) for shared entities, When producing output: do not reorder columns beyond template_type_code as required by the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code FROM template_types WHERE template_type_code NOT IN (SELECT DISTINCT template_type_code FROM documents)",
            "SELECT Template_Type_Code FROM Templates\nEXCEPT\nSELECT DISTINCT T1.Template_Type_Code \nFROM Templates AS T1 \nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID"
        ],
        "rule_sql": [
            "SELECT Template_Type_Code\nFROM Templates\nEXCEPT\nSELECT DISTINCT t.Template_Type_Code\nFROM Templates t\nINNER JOIN Documents d ON t.Template_ID = d.Template_ID\nORDER BY Template_Type_Code;"
        ]
    },
    "347": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all template type codes and descriptions.",
        "ground_truth": "SELECT template_type_code ,  template_type_description FROM Ref_template_types",
        "amends": [
            "Do reference table `Ref_template_types` instead of `template_types`. Do select column `template_type_code` instead of `template_code`. Do select column `template_type_description` instead of `description`. The amended query now correctly references the appropriate table and columns to match the intended schema structure."
        ],
        "rules": [
            "When answering about \"template type codes and descriptions\": make sure the output order: template_type_code, template_type_description.",
            "When the question mentions \"template type codes\": \"template type codes\" actually means \"template_type_code in Ref_template_types\".",
            "When the question mentions \"descriptions\": \"descriptions\" actually means \"template_type_description in Ref_template_types\".",
            "When answering about \"template type codes and descriptions\", When the question mentions \"template type codes\", When the question mentions \"descriptions\", When selecting from the template types table: use table \"Ref_template_types\" instead of \"template_types\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_code, description FROM template_types WHERE 1 = 0;",
            "SELECT Template_Type_Code, Template_Type_Description FROM Ref_Template_Types;"
        ],
        "rule_sql": [
            "SELECT Template_Type_Code, Template_Type_Description FROM Ref_Template_Types;"
        ]
    },
    "348": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the type codes and descriptions for all template types?",
        "ground_truth": "SELECT template_type_code ,  template_type_description FROM Ref_template_types",
        "amends": [
            "Do use table `Ref_template_types` instead of `template_types`. Do select column `template_type_code` instead of `type_code` and `template_type_description` instead of `description`. Do remove the `WHERE type_code IS NOT NULL` filter instead of keeping it, as the right query retrieves all records without null filtering. The amended query now correctly references the proper table and column names to match the intended schema structure."
        ],
        "rules": [
            "When answering about \"type codes and descriptions for all template types\": use table \"Ref_template_types\" as the base table T1.",
            "When selecting the type code column: use \"template_type_code\" from T1 instead of \"type_code\".",
            "When selecting the description column: use \"template_type_description\" from T1 instead of \"description\".",
            "When answering about \"type codes and descriptions for all template types\", When selecting the type code column, When selecting the description column, When retrieving all records: do not apply any null filtering condition on type codes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type_code, description FROM template_types WHERE type_code IS NOT NULL",
            "SELECT Template_Type_Code, Template_Type_Description FROM Ref_Template_Types;"
        ],
        "rule_sql": [
            "SELECT template_type_code, template_type_description FROM Ref_Template_Types"
        ]
    },
    "349": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the template type descriptions for template type code \"AD\".",
        "ground_truth": "SELECT template_type_description FROM Ref_template_types WHERE template_type_code  =  \"AD\"",
        "amends": [
            "Do reference table `Ref_template_types` instead of `template_types` and use double quotes `\"AD\"` instead of single quotes `'AD'` for the string literal, while keeping the same column selection `template_type_description` and filter condition on `template_type_code`."
        ],
        "rules": [
            "When referencing the template types table: use \"Ref_template_types\" instead of \"template_types\" as the exact table name.",
            "When filtering for template type code \"AD\": use double quotes \"AD\" instead of single quotes 'AD' for the exact string literal.",
            "When referencing the template types table, When filtering for template type code \"AD\", When selecting template type descriptions: use the column \"template_type_description\" from the \"Ref_template_types\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_description FROM template_types WHERE template_type_code = 'AD';",
            "SELECT template_type_description FROM Ref_Template_Types WHERE template_type_code = \"AD\""
        ],
        "rule_sql": [
            "SELECT template_type_description FROM Ref_template_types WHERE Template_Type_Code = \"AD\";"
        ]
    },
    "350": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the template type description of the template type with the code AD.",
        "ground_truth": "SELECT template_type_description FROM Ref_template_types WHERE template_type_code  =  \"AD\"",
        "amends": [
            "Do reference table `Ref_template_types` instead of `template_types` and use double quotes `\"AD\"` instead of single quotes `'AD'` for the string literal, while keeping the same column selection `template_type_description` and filter condition `template_type_code = 'AD'` unchanged. The amended query now correctly references the intended table and uses consistent string quoting to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about template type descriptions: make sure the output order: template_type_description.",
            "When the question mentions \"template type with the code AD\": \"AD\" actually means \"template_type_code = \\\"AD\\\"\" in schema.",
            "When answering about template type descriptions, When the question mentions \"template type with the code AD\", When selecting from template types: use table \"Ref_template_types\" instead of \"template_types\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_description FROM template_types WHERE template_type_code = 'AD';",
            "SELECT template_type_description FROM Ref_template_types WHERE template_type_code = \"AD\""
        ],
        "rule_sql": [
            "SELECT template_type_description FROM Ref_Template_Types WHERE Template_Type_Code = 'AD';"
        ]
    },
    "351": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the template type code for template type description \"Book\".",
        "ground_truth": "SELECT template_type_code FROM Ref_template_types WHERE template_type_description  =  \"Book\"",
        "amends": [
            "Do reference table `Ref_template_types` instead of `template_types` in the FROM clause. Do use double quotes `\"Book\"` instead of single quotes `'Book'` for the string literal in the WHERE filter. The amended query now correctly references the intended table and uses proper string quotation to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about template type code for a specific template type description: reference the table \"Ref_template_types\" instead of \"template_types\"",
            "When answering about template type code for a specific template type description, When filtering by template type description \"Book\": use double quotes \"Book\" instead of single quotes 'Book' for the string literal"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code FROM template_types WHERE template_type_description = 'Book';",
            "SELECT Template_Type_Code FROM Ref_Template_Types WHERE Template_Type_Description = \"Book\""
        ],
        "rule_sql": [
            "SELECT Template_Type_Code FROM Ref_Template_Types WHERE Template_Type_Description = \"Book\""
        ]
    },
    "352": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the type code of the template type with the description \"Book\".",
        "ground_truth": "SELECT template_type_code FROM Ref_template_types WHERE template_type_description  =  \"Book\"",
        "amends": [
            "Do reference `template_type_code` instead of `type_code` and select from `Ref_template_types` instead of `template_types`. Do filter on `template_type_description = \"Book\"` instead of `description = 'Book'`, using double quotes instead of single quotes for the string literal. The amended query now correctly references the proper table and column names to match the intended schema structure."
        ],
        "rules": [
            "When answering about \"Return the type code of the template type with the description 'Book'\": make sure the output order: template_type_code.",
            "When the question mentions \"type code\": \"type code\" actually means \"template_type_code in schema\".",
            "When the question mentions \"template type\": \"template type\" actually means \"Ref_template_types in schema\".",
            "When the question mentions \"description\": \"description\" actually means \"template_type_description in schema\".",
            "When filtering for the literal \"Book\": use exact string literal \"Book\" with double quotes as shown in the schema.",
            "When answering about \"Return the type code of the template type with the description 'Book'\", When the question mentions \"type code\", When the question mentions \"template type\", When the question mentions \"description\", When filtering for the literal \"Book\", When selecting from the template types table: use table name Ref_template_types instead of template_types."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type_code FROM template_types WHERE description = 'Book';",
            "SELECT Template_Type_Code FROM Ref_Template_Types WHERE Template_Type_Description = \"Book\";"
        ],
        "rule_sql": [
            "SELECT template_type_code FROM Ref_Template_Types WHERE template_type_description = \"Book\";"
        ]
    },
    "353": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the distinct template type descriptions for the templates ever used by any document?",
        "ground_truth": "SELECT DISTINCT T1.template_type_description FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code JOIN Documents AS T3 ON T2.Template_ID  =  T3.template_ID",
        "amends": [
            "Do select `T1.template_type_description` instead of `template_type` from the SELECT list. Do add `Ref_template_types AS T1` and `Templates AS T2` to the FROM clause instead of only `documents` and `templates`. Do change the join condition to `T1.template_type_code = T2.template_type_code` instead of `documents.template_id = templates.id`. Do add a second join `JOIN Documents AS T3 ON T2.Template_ID = T3.template_ID` instead of having only one join. The amended query now correctly retrieves template type descriptions from the appropriate reference table through proper table relationships."
        ],
        "rules": [
            "When answering about \"distinct template type descriptions for templates ever used by any document\": make sure the output order: T1.template_type_description.",
            "When the question mentions \"template type descriptions\": \"template type descriptions\" actually means \"T1.template_type_description in schema\".",
            "When combining T1 (Ref_template_types) and T2 (Templates) for shared entities: link rows where T1.template_type_code = T2.template_type_code exactly as shown in the amends; keep only matching pairs (inner match).",
            "When combining T2 (Templates) and T3 (Documents) for shared entities: link rows where T2.Template_ID = T3.template_ID exactly as shown in the amends; keep only matching pairs (inner match).",
            "When answering about \"distinct template type descriptions for templates ever used by any document\", When the question mentions \"template type descriptions\", When combining T1 (Ref_template_types) and T2 (Templates) for shared entities, When combining T2 (Templates) and T3 (Documents) for shared entities, When the question asks for \"distinct template type descriptions\": compute the number of unique values of the exact token T1.template_type_description."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT template_type FROM documents JOIN templates ON documents.template_id = templates.id",
            "SELECT DISTINCT T1.Template_Type_Description\nFROM Ref_Template_Types AS T1\nJOIN Templates AS T2 ON T1.Template_Type_Code = T2.Template_Type_Code\nJOIN Documents AS T3 ON T2.Template_ID = T3.Template_ID;"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Template_Type_Description\nFROM Ref_Template_Types T1\nINNER JOIN Templates T2 ON T1.Template_Type_Code = T2.Template_Type_Code\nINNER JOIN Documents T3 ON T2.Template_ID = T3.Template_ID\nORDER BY T1.Template_Type_Description;"
        ]
    },
    "354": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the different descriptions for templates that have been used in a document.",
        "ground_truth": "SELECT DISTINCT T1.template_type_description FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code JOIN Documents AS T3 ON T2.Template_ID  =  T3.template_ID",
        "amends": [
            "Do add `Ref_template_types AS T1`, `Templates AS T2`, and `Documents AS T3` tables instead of querying only `documents`. Do change the SELECT list to `T1.template_type_description` instead of `template_id`. Do add `JOIN Templates AS T2 ON T1.template_type_code = T2.template_type_code` and `JOIN Documents AS T3 ON T2.Template_ID = T3.template_ID` instead of no joins. The amended query now correctly retrieves distinct template type descriptions by properly joining through the template hierarchy rather than just selecting template IDs from documents."
        ],
        "rules": [
            "When answering about \"different descriptions for templates used in a document\": make sure the output order: T1.template_type_description.",
            "When the question mentions \"descriptions for templates\": \"descriptions\" actually means \"T1.template_type_description\" in schema.",
            "When combining T1, T2, and T3 for shared entities: link rows where T1.template_type_code = T2.template_type_code and T2.Template_ID = T3.template_ID; keep only matching pairs (inner match).",
            "When answering about \"different descriptions for templates used in a document\", When the question mentions \"descriptions for templates\", When combining T1, T2, and T3 for shared entities, When the question asks for \"different descriptions\": compute the number of unique values of T1.template_type_description."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT template_id FROM documents;",
            "SELECT DISTINCT T1.Template_Type_Description\nFROM Ref_Template_Types AS T1\nJOIN Templates AS T2 ON T1.Template_Type_Code = T2.Template_Type_Code\nJOIN Documents AS T3 ON T2.Template_ID = T3.Template_ID;"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.template_type_description\nFROM Ref_Template_Types T1\nINNER JOIN Templates T2 ON T1.template_type_code = T2.template_type_code\nINNER JOIN Documents T3 ON T2.Template_ID = T3.Template_ID\nORDER BY T1.template_type_description;"
        ]
    },
    "355": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the template ids with template type description \"Presentation\".",
        "ground_truth": "SELECT T2.template_id FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code WHERE T1.template_type_description  =  \"Presentation\"",
        "amends": [
            "Do join `Ref_template_types AS T1` and `Templates AS T2` instead of querying only `templates` table. Do use `T1.template_type_code = T2.template_type_code` join condition instead of no join. Do filter on `T1.template_type_description = \"Presentation\"` instead of `template_type = 'Presentation'`. Do select `T2.template_id` with table alias instead of just `template_id`. The amended query now correctly joins reference tables to resolve template types by description rather than relying on direct column matching."
        ],
        "rules": [
            "When the question asks for template ids with template type description \"Presentation\": join Ref_template_types AS T1 and Templates AS T2 using T1.template_type_code = T2.template_type_code.",
            "When filtering for template type description: use T1.template_type_description = \"Presentation\" exactly as specified.",
            "When selecting template ids: use T2.template_id with the table alias to specify the source table.",
            "When the question asks for template ids with template type description \"Presentation\", When filtering for template type description, When selecting template ids, When combining T1 and T2: perform an inner match where T1.template_type_code equals T2.template_type_code to link template types with their corresponding templates."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_id FROM templates WHERE template_type = 'Presentation'",
            "SELECT T2.Template_ID \nFROM Ref_Template_Types AS T1 \nJOIN Templates AS T2 ON T1.Template_Type_Code = T2.Template_Type_Code \nWHERE T1.Template_Type_Description = 'Presentation'"
        ],
        "rule_sql": [
            "SELECT T2.Template_ID\nFROM Ref_Template_Types AS T1\nINNER JOIN Templates AS T2 ON T1.Template_Type_Code = T2.Template_Type_Code\nWHERE T1.Template_Type_Description = \"Presentation\""
        ]
    },
    "356": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the ids corresponding to templates with the description 'Presentation'.",
        "ground_truth": "SELECT T2.template_id FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code WHERE T1.template_type_description  =  \"Presentation\"",
        "amends": [
            "Do add `Ref_template_types AS T1` and `Templates AS T2` as joined tables instead of querying only `templates` alone. Do use `JOIN` with `ON T1.template_type_code = T2.template_type_code` instead of no join condition. Do select `T2.template_id` instead of `id`. Do filter on `T1.template_type_description = \"Presentation\"` instead of `description = 'Presentation'`. The amended query now correctly joins reference data to retrieve template IDs by type description instead of directly filtering templates by description."
        ],
        "rules": [
            "When answering about templates with description 'Presentation': make sure the output order: T2.template_id.",
            "When the question mentions 'templates': use Templates AS T2 as the main entity table.",
            "When the question mentions 'description': \"description\" actually means \"template_type_description in Ref_template_types table\".",
            "When combining Ref_template_types AS T1 and Templates AS T2 for shared template types: link rows where T1.template_type_code = T2.template_type_code exactly; keep only matching pairs (inner match).",
            "When answering about templates with description 'Presentation', When the question mentions 'templates', When the question mentions 'description', When combining Ref_template_types AS T1 and Templates AS T2 for shared template types, When filtering for 'Presentation': use exact literal \"Presentation\" with double quotes for T1.template_type_description."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM templates WHERE description = 'Presentation'",
            "SELECT T2.template_id \nFROM Ref_template_types AS T1 \nJOIN Templates AS T2 ON T1.template_type_code = T2.template_type_code \nWHERE T1.template_type_description = 'Presentation'"
        ],
        "rule_sql": [
            "SELECT T2.Template_ID\nFROM Templates AS T2\nINNER JOIN Ref_Template_Types AS T1 ON T1.Template_Type_Code = T2.Template_Type_Code\nWHERE T1.Template_Type_Description = \"Presentation\"\nORDER BY T2.Template_ID"
        ]
    },
    "357": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "How many paragraphs in total?",
        "ground_truth": "SELECT count(*) FROM Paragraphs",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM paragraphs;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS total_paragraphs FROM Paragraphs"
        ]
    },
    "358": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Count the number of paragraphs.",
        "ground_truth": "SELECT count(*) FROM Paragraphs",
        "amends": [
            "Do reference the `Paragraphs` table instead of the `sentences` table in the FROM clause, as the query intent is to count records from the correct data source. The amended query now matches RIGHT_SQL's behavior by correctly counting records from the Paragraphs table."
        ],
        "rules": [
            "When counting paragraphs: use the \"Paragraphs\" table as the data source instead of the \"sentences\" table.",
            "When counting paragraphs, When the question asks to count the number of paragraphs: count all records from the \"Paragraphs\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM sentences;",
            "SELECT COUNT(*) FROM Paragraphs;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Paragraphs;"
        ]
    },
    "359": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "How many paragraphs for the document with name 'Summer Show'?",
        "ground_truth": "SELECT count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_ID  =  T2.document_ID WHERE T2.document_name  =  'Summer Show'",
        "amends": [
            "Do add `JOIN Documents AS T2 ON T1.document_ID = T2.document_ID` instead of querying only the `paragraphs` table. Do move the filter `document_name = 'Summer Show'` to the joined `Documents` table instead of applying it directly to `paragraphs`. Do reference the joined table alias `T2` in the WHERE clause instead of the original table name. The amended query now correctly joins the tables and filters on the document name from the appropriate table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"paragraphs for document with name 'Summer Show'\": combine tables paragraphs (T1) and Documents (T2) using the join condition T1.document_ID = T2.document_ID, keeping only matching pairs (inner match).",
            "When the question mentions \"document with name 'Summer Show'\": apply the filter T2.document_name = 'Summer Show' exactly as specified (case-sensitive).",
            "When answering about \"paragraphs for document with name 'Summer Show'\", When the question mentions \"document with name 'Summer Show'\", When the question asks for \"how many paragraphs\": count the number of rows using the canonical key from the paragraphs table after applying the join and filter conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM paragraphs WHERE document_name = 'Summer Show';",
            "SELECT COUNT(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.Document_ID = T2.Document_ID WHERE T2.Document_Name = 'Summer Show'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Paragraphs T1\nINNER JOIN Documents T2 ON T1.Document_ID = T2.Document_ID\nWHERE T2.Document_Name = 'Summer Show'"
        ]
    },
    "360": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Count the number of paragraphs in the document named 'Summer Show'.",
        "ground_truth": "SELECT count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_ID  =  T2.document_ID WHERE T2.document_name  =  'Summer Show'",
        "amends": [
            "Do add a `JOIN` to `Documents AS T2` instead of querying only the `paragraphs` table. Do use the join condition `T1.document_ID = T2.document_ID` instead of missing the table relationship entirely. Do move the filter on `document_name = 'Summer Show'` to the `WHERE` clause applied to the joined `Documents` table instead of incorrectly applying it directly to the `paragraphs` table which lacks that column. The amended query now correctly counts paragraphs by joining to the Documents table to filter by document name, matching the intended behavior."
        ],
        "rules": [
            "When counting paragraphs for a specific document: join the paragraphs table (T1) with the Documents table (T2) using the condition T1.document_ID = T2.document_ID to establish the relationship between paragraphs and documents.",
            "When filtering by document name 'Summer Show': apply the filter document_name = 'Summer Show' to the Documents table (T2) instead of the paragraphs table, since document_name is a column of Documents.",
            "When counting paragraphs for a specific document, When filtering by document name 'Summer Show', When counting paragraphs: count the number of rows in the paragraphs table (T1) that are linked to documents matching the specified name condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM paragraphs WHERE document_name = 'Summer Show';",
            "SELECT COUNT(*) \nFROM Paragraphs AS T1\nJOIN Documents AS T2 ON T1.Document_ID = T2.Document_ID\nWHERE T2.Document_Name = 'Summer Show'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Paragraphs T1\nJOIN Documents T2 ON T1.Document_ID = T2.Document_ID\nWHERE T2.Document_Name = 'Summer Show'"
        ]
    },
    "361": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show paragraph details for paragraph with text 'Korea ' .",
        "ground_truth": "select other_details from paragraphs where paragraph_text like 'korea'",
        "amends": [
            "Do select `other_details` instead of `*` for the column list. Do reference `paragraph_text` instead of `text` as the column name in the WHERE clause. Do use `LIKE` with lowercase `'korea'` instead of `=` with uppercase `'Korea'` for pattern matching instead of exact case-sensitive matching. The amended query now correctly filters for text containing 'korea' case-insensitively and returns only the other_details column as specified."
        ],
        "rules": [
            "When selecting columns for paragraph details: use \"other_details\" instead of all columns (*).",
            "When filtering for text containing 'Korea': use \"paragraph_text\" column instead of \"text\" column.",
            "When selecting columns for paragraph details, When filtering for text containing 'Korea', When pattern matching for 'Korea': use LIKE operator with lowercase 'korea' for case-insensitive matching instead of exact case-sensitive matching with uppercase 'Korea'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM paragraphs WHERE text = 'Korea';",
            "SELECT other_details FROM Paragraphs WHERE paragraph_text LIKE '%korea%';"
        ],
        "rule_sql": [
            "SELECT other_details FROM Paragraphs WHERE paragraph_text LIKE '%korea%'"
        ]
    },
    "362": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the details for the paragraph that includes the text 'Korea ' ?",
        "ground_truth": "select other_details from paragraphs where paragraph_text like 'korea'",
        "amends": [
            "Do select `other_details` instead of `*` for the column list. Do reference `paragraph_text` instead of `text` as the source column. Do use a case-sensitive `like 'korea'` pattern instead of a case-insensitive `LIKE '%Korea%'` pattern. The amended query now correctly filters for exact case matches on the paragraph_text column and returns only the other_details field instead of all columns.",
            "Do use lowercase `like 'korea'` instead of mixed case `LIKE 'Korea '` to ensure case-insensitive matching and remove the trailing space that would prevent matching most Korean-related text. The amended query now matches the right SQL's behavior by properly searching for the lowercase term without extraneous whitespace."
        ],
        "rules": [
            "When selecting details about paragraphs: return only the \"other_details\" column instead of all columns.",
            "When filtering for text containing 'Korea': use the exact column name \"paragraph_text\" instead of \"text\".",
            "When selecting details about paragraphs, When filtering for text containing 'Korea', When matching the text pattern 'Korea': use case-sensitive matching with pattern 'korea' instead of case-insensitive matching with pattern '%Korea%'.",
            "When the question asks for details about paragraphs containing specific text: use the exact table name \"Paragraphs\" and column name \"other_details\" as shown in the schema.",
            "When searching for text patterns in \"paragraph_text\": use lowercase 'like' operator with exact literal 'korea' (case-insensitive matching) and ensure no trailing spaces in the search pattern.",
            "When the question asks for details about paragraphs containing specific text, When searching for text patterns in \"paragraph_text\", When the question mentions \"details for the paragraph\": return the \"other_details\" column from the matching rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM paragraphs WHERE text LIKE '%Korea%';",
            "SELECT other_details FROM Paragraphs WHERE paragraph_text LIKE 'Korea '",
            "SELECT other_details FROM Paragraphs WHERE paragraph_text LIKE 'korea'"
        ],
        "rule_sql": [
            "SELECT other_details FROM Paragraphs WHERE paragraph_text LIKE '%korea%';"
        ]
    },
    "363": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all paragraph ids and texts for the document with name 'Welcome to NY'.",
        "ground_truth": "SELECT T1.paragraph_id ,   T1.paragraph_text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.Document_Name  =  'Welcome to NY'",
        "amends": [
            "Do join `Documents AS T2` on `T1.document_id = T2.document_id` instead of querying `paragraphs` table directly without any join. Do select `T1.paragraph_text` instead of `text` to use the correct column name. Do filter on `T2.Document_Name = 'Welcome to NY'` instead of filtering directly on `document_name` in the paragraphs table. Do use table aliases `T1` and `T2` instead of no aliases for better clarity. The amended query now correctly joins through the document relationship to filter by document name instead of assuming the paragraphs table contains document names directly."
        ],
        "rules": [
            "When answering about \"paragraph ids and texts for the document with name 'Welcome to NY'\": make sure the output order: paragraph_id, paragraph_text.",
            "When the question mentions \"document with name 'Welcome to NY'\": filter on T2.Document_Name = 'Welcome to NY' exactly as specified.",
            "When combining paragraphs table T1 and Documents table T2: link rows where T1.document_id = T2.document_id and keep only matching pairs (inner match).",
            "When answering about \"paragraph ids and texts for the document with name 'Welcome to NY'\", When the question mentions \"document with name 'Welcome to NY'\", When combining paragraphs table T1 and Documents table T2, When the question asks for \"paragraph texts\": use T1.paragraph_text instead of text to use the correct column name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT paragraph_id, text FROM paragraphs WHERE document_name = 'Welcome to NY'",
            "SELECT T1.Paragraph_ID, T1.Paragraph_Text \nFROM Paragraphs AS T1 \nJOIN Documents AS T2 ON T1.Document_ID = T2.Document_ID \nWHERE T2.Document_Name = 'Welcome to NY'"
        ],
        "rule_sql": [
            "SELECT p.Paragraph_ID, p.Paragraph_Text FROM Paragraphs p INNER JOIN Documents d ON p.Document_ID = d.Document_ID WHERE d.Document_Name = 'Welcome to NY'"
        ]
    },
    "364": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the ids and texts of paragraphs in the document titled 'Welcome to NY'?",
        "ground_truth": "SELECT T1.paragraph_id ,   T1.paragraph_text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.Document_Name  =  'Welcome to NY'",
        "amends": [
            "Do use `T1.paragraph_text` instead of `text` for the column selection. Do add `JOIN Documents AS T2` instead of querying only the paragraphs table. Do use `ON T1.document_id = T2.document_id` instead of no join condition. Do filter on `T2.Document_Name = 'Welcome to NY'` instead of `document_title = 'Welcome to NY'` to properly reference the document name from the joined table. Do add table aliases `T1` and `T2` instead of using unqualified column references. The amended query now correctly joins the tables and filters on the document name from the appropriate table, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"paragraphs in a document titled 'Welcome to NY'\": make sure to join tables T1 (paragraphs) and T2 (Documents) using T1.document_id = T2.document_id to properly link paragraphs to their documents.",
            "When the question mentions \"texts of paragraphs\": \"text\" actually means \"T1.paragraph_text\" in the schema.",
            "When filtering for document title: use T2.Document_Name = 'Welcome to NY' with exact case and spacing to match the specified document name.",
            "When selecting output columns: include T1.paragraph_id and T1.paragraph_text in that order.",
            "When answering about \"paragraphs in a document titled 'Welcome to NY'\", When the question mentions \"texts of paragraphs\", When filtering for document title, When selecting output columns, When combining T1 and T2 for shared entities: link rows where T1.document_id = T2.document_id exactly as shown in the amends; keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT paragraph_id, text FROM paragraphs WHERE document_title = 'Welcome to NY';",
            "SELECT T1.Paragraph_ID, T1.Paragraph_Text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.Document_ID = T2.Document_ID WHERE T2.Document_Name = 'Welcome to NY'"
        ],
        "rule_sql": [
            "SELECT p.Paragraph_ID, p.Paragraph_Text \nFROM Paragraphs p\nJOIN Documents d ON p.Document_ID = d.Document_ID\nWHERE d.Document_Name = 'Welcome to NY'"
        ]
    },
    "365": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all paragraph texts for the document \"Customer reviews\".",
        "ground_truth": "SELECT T1.paragraph_text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.document_name  =  \"Customer reviews\"",
        "amends": [
            "Do reference `paragraph_text` instead of `text` in the SELECT list. Do join `Documents AS T2` instead of omitting it, using `LEFT JOIN` on `T1.document_id = T2.document_id` instead of no join condition. Do filter on `T2.document_name = \"Customer reviews\"` instead of `document_title = 'Customer reviews'` in the WHERE clause. The amended query now correctly retrieves paragraph text by joining through the document relationship rather than relying on a non-existent title column in the paragraphs table."
        ],
        "rules": [
            "When the question asks for paragraph texts: select \"paragraph_text\" from table T1 instead of \"text\".",
            "When joining tables for document relationships: combine T1 (paragraphs) and T2 (Documents) using LEFT JOIN where T1.document_id equals T2.document_id.",
            "When the question asks for paragraph texts, When joining tables for document relationships, When filtering for document name \"Customer reviews\": use T2.document_name = \"Customer reviews\" instead of document_title = 'Customer reviews'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT text FROM paragraphs WHERE document_title = 'Customer reviews';",
            "SELECT p.Paragraph_Text \nFROM Paragraphs p\nLEFT JOIN Documents d ON p.Document_ID = d.Document_ID\nWHERE d.Document_Name = 'Customer reviews'"
        ],
        "rule_sql": [
            "SELECT p.Paragraph_Text \nFROM Paragraphs p \nLEFT JOIN Documents d ON p.Document_ID = d.Document_ID \nWHERE d.Document_Name = 'Customer reviews'"
        ]
    },
    "366": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the paragraph texts for the document with the name 'Customer reviews'?",
        "ground_truth": "SELECT T1.paragraph_text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.document_name  =  \"Customer reviews\"",
        "amends": [
            "Do reference `T1.paragraph_text` from the `Paragraphs` table instead of directly selecting `paragraph_text` from `documents`. Do join `Paragraphs AS T1` with `Documents AS T2` on `T1.document_id = T2.document_id` instead of querying only the `documents` table. Do filter on `T2.document_name = \"Customer reviews\"` instead of `name = 'Customer reviews'` to properly reference the document name column. The amended query now correctly retrieves paragraph text by joining the Paragraphs and Documents tables and filtering on the document name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"paragraph texts for the document with the name 'Customer reviews'\": make sure the output order: T1.paragraph_text.",
            "When the question mentions \"document with the name 'Customer reviews'\": \"name\" actually means \"T2.document_name in schema\" and use the exact literal \"Customer reviews\".",
            "When combining T1 (Paragraphs) and T2 (Documents) for shared entities: link rows where T1.document_id = T2.document_id; keep only matching pairs (inner match).",
            "When answering about \"paragraph texts for the document with the name 'Customer reviews'\", When the question mentions \"document with the name 'Customer reviews'\", When combining T1 (Paragraphs) and T2 (Documents) for shared entities, When selecting paragraph text: reference T1.paragraph_text from the Paragraphs table instead of directly selecting from documents table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT paragraph_text FROM documents WHERE name = 'Customer reviews';",
            "SELECT T1.Paragraph_Text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.Document_ID = T2.Document_ID WHERE T2.Document_Name = 'Customer reviews'"
        ],
        "rule_sql": [
            "SELECT T1.paragraph_text \nFROM Paragraphs T1\nINNER JOIN Documents T2 ON T1.document_id = T2.document_id\nWHERE T2.document_name = 'Customer reviews'\nORDER BY T1.paragraph_text"
        ]
    },
    "367": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all document ids and the number of paragraphs in each document. Order by document id.",
        "ground_truth": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT document_id, COUNT(*) FROM paragraphs GROUP BY document_id ORDER BY paragraph_id;"
        ],
        "rule_sql": [
            "SELECT d.Document_ID, COUNT(p.Paragraph_ID) AS Number_of_Paragraphs\nFROM Documents d\nLEFT JOIN Paragraphs p ON d.Document_ID = p.Document_ID\nGROUP BY d.Document_ID\nORDER BY d.Document_ID;",
            "SELECT d.Document_ID, COUNT(p.Paragraph_ID) AS Number_of_Paragraphs\nFROM Documents d\nLEFT JOIN Paragraphs p ON d.Document_ID = p.Document_ID\nGROUP BY d.Document_ID\nORDER BY d.Document_ID;"
        ]
    },
    "368": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the different document ids along with the number of paragraphs corresponding to each, ordered by id.",
        "ground_truth": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id, COUNT(*) FROM paragraphs GROUP BY document_id ORDER BY document_id;"
        ],
        "rule_sql": [
            "SELECT d.Document_ID, COUNT(p.Paragraph_ID) AS Paragraph_Count\nFROM Documents d\nLEFT JOIN Paragraphs p ON d.Document_ID = p.Document_ID\nGROUP BY d.Document_ID\nORDER BY d.Document_ID;",
            "SELECT Document_ID, COUNT(Paragraph_ID) AS Number_of_Paragraphs FROM Paragraphs GROUP BY Document_ID ORDER BY Document_ID;"
        ]
    },
    "369": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all document ids, names and the number of paragraphs in each document.",
        "ground_truth": "SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id",
        "amends": [
            "Do join `Paragraphs AS T1` with `Documents AS T2` on `T1.document_id = T2.document_id` instead of querying only the `documents` table. Do select `T2.document_name` instead of `name` and use `count(*)` instead of `COUNT(paragraph_id)`. Do group by only `T1.document_id` instead of grouping by both `document_id` and `name`. The amended query now correctly counts paragraphs per document while retrieving the document name from the joined Documents table, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"document ids, names and the number of paragraphs in each document\": make sure the output order: document_id, document_name, count of paragraphs.",
            "When combining Paragraphs as T1 and Documents as T2 for shared entities: link rows where T1.document_id = T2.document_id exactly as shown; keep only matching pairs (inner match).",
            "When the question asks for \"count of paragraphs\": compute the number of rows using count(*) from the Paragraphs table.",
            "When the question asks for document names: use T2.document_name instead of name.",
            "When answering about \"document ids, names and the number of paragraphs in each document\", When combining Paragraphs as T1 and Documents as T2 for shared entities, When the question asks for \"count of paragraphs\", When the question asks for document names, When grouping by document: organize results by T1.document_id only, not both document_id and name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id, name, COUNT(paragraph_id) FROM documents GROUP BY document_id, name",
            "SELECT T2.Document_ID, T2.Document_Name, COUNT(*) AS Number_Of_Paragraphs\nFROM Paragraphs AS T1\nJOIN Documents AS T2 ON T1.Document_ID = T2.Document_ID\nGROUP BY T1.Document_ID"
        ],
        "rule_sql": [
            "SELECT d.Document_ID, d.Document_Name, COUNT(p.Paragraph_ID) AS paragraph_count\nFROM Documents d\nINNER JOIN Paragraphs p ON d.Document_ID = p.Document_ID\nGROUP BY d.Document_ID, d.Document_Name\nORDER BY d.Document_ID, d.Document_Name"
        ]
    },
    "370": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the ids and names of each document, as well as the number of paragraphs in each?",
        "ground_truth": "SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id",
        "amends": [
            "Do use `JOIN` instead of `LEFT JOIN` to exclude documents without paragraphs. Do reference `T1.document_id` and `T2.document_name` instead of `d.id` and `d.name` with different aliases. Do use `count(*)` instead of `COUNT(p.id)` to count all rows rather than non-null paragraph IDs. Do group by `T1.document_id` only instead of both `d.id` and `d.name` since document_name is functionally dependent. Do remove the unnecessary alias `paragraph_count` instead of keeping it. The amended query now correctly counts paragraphs per document while excluding documents with no paragraphs."
        ],
        "rules": [
            "When combining documents and paragraphs tables: link rows where T1.document_id equals T2.document_id and keep only matching pairs (inner match).",
            "When counting paragraphs per document: count all rows using count(*) rather than counting specific column values.",
            "When grouping by document identifier: group by T1.document_id only since document_name is functionally dependent on document_id.",
            "When selecting output columns: include T1.document_id, T2.document_name, and the count of paragraphs.",
            "When combining documents and paragraphs tables, When counting paragraphs per document, When grouping by document identifier, When selecting output columns, When the question asks for \"number of paragraphs in each\": do not include an alias for the count column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.id, d.name, COUNT(p.id) AS paragraph_count FROM documents d LEFT JOIN paragraphs p ON d.id = p.document_id GROUP BY d.id, d.name",
            "SELECT d.Document_ID, d.Document_Name, COUNT(*) \nFROM Documents d\nJOIN Paragraphs p ON d.Document_ID = p.Document_ID\nGROUP BY d.Document_ID"
        ],
        "rule_sql": [
            "SELECT d.Document_ID, d.Document_Name, COUNT(*) \nFROM Documents d \nINNER JOIN Paragraphs p ON d.Document_ID = p.Document_ID \nGROUP BY d.Document_ID"
        ]
    },
    "371": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "List all document ids with at least two paragraphs.",
        "ground_truth": "SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*)  >=  2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id FROM paragraphs GROUP BY document_id HAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT Document_ID FROM Paragraphs GROUP BY Document_ID HAVING COUNT(Paragraph_ID) >= 2"
        ]
    },
    "372": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the ids of documents that have 2 or more paragraphs?",
        "ground_truth": "SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*)  >=  2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id FROM paragraphs GROUP BY document_id HAVING COUNT(paragraph_id) >= 2"
        ],
        "rule_sql": [
            "SELECT Document_ID FROM Paragraphs GROUP BY Document_ID HAVING COUNT(Paragraph_ID) >= 2"
        ]
    },
    "373": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the document id and name with greatest number of paragraphs?",
        "ground_truth": "SELECT T1.document_id ,  T2.document_name FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.document_id` and `T2.document_name` instead of `document_id` and `name`. Do use `FROM Paragraphs AS T1 JOIN Documents AS T2` instead of `FROM documents`. Do add `ON T1.document_id = T2.document_id` join condition instead of omitting it. Do add `GROUP BY T1.document_id` instead of omitting grouping. Do order by `count(*) DESC` instead of `paragraph_count DESC`. The amended query now correctly joins tables and counts paragraphs per document to find the document with the most paragraphs."
        ],
        "rules": [
            "When selecting document identifiers and names: use T1.document_id and T2.document_name instead of document_id and name.",
            "When combining Paragraphs and Documents tables: use FROM Paragraphs AS T1 JOIN Documents AS T2 with join condition ON T1.document_id = T2.document_id to link matching rows.",
            "When counting paragraphs per document: add GROUP BY T1.document_id to organize results by document.",
            "When ordering by paragraph count: use count(*) DESC instead of paragraph_count DESC to rank documents by actual paragraph count.",
            "When selecting document identifiers and names, When combining Paragraphs and Documents tables, When counting paragraphs per document, When ordering by paragraph count, When finding the document with greatest number of paragraphs: take only the top ranked document after ordering by paragraph count in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id, name FROM documents ORDER BY paragraph_count DESC LIMIT 1;",
            "SELECT T1.document_id, T2.document_name\nFROM Paragraphs AS T1\nJOIN Documents AS T2 ON T1.document_id = T2.document_id\nGROUP BY T1.document_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.document_id, T2.document_name\nFROM Paragraphs AS T1\nJOIN Documents AS T2 ON T1.document_id = T2.document_id\nGROUP BY T1.document_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "374": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the id and name of the document with the most paragraphs.",
        "ground_truth": "SELECT T1.document_id ,  T2.document_name FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.document_id` and `T2.document_name` instead of `id` and `name`. Do use `FROM Paragraphs AS T1 JOIN Documents AS T2` instead of `FROM documents`. Do add `ON T1.document_id = T2.document_id` join condition instead of omitting it. Do add `GROUP BY T1.document_id` instead of omitting grouping. Do order by `count(*) DESC` instead of `id DESC`. The amended query now correctly joins tables, groups by document, and orders by paragraph count to find the document with the most paragraphs."
        ],
        "rules": [
            "When answering about \"document with the most paragraphs\": make sure the output order: T1.document_id, T2.document_name.",
            "When the question mentions \"id\": \"id\" actually means \"T1.document_id in schema\".",
            "When the question mentions \"name\": \"name\" actually means \"T2.document_name in schema\".",
            "When combining T1 (Paragraphs) and T2 (Documents) for shared entities: link rows where T1.document_id = T2.document_id; keep only matching pairs (inner match).",
            "When the question asks for \"count of paragraphs per document\": organize results by T1.document_id and compute count(*) per group.",
            "When answering about \"document with the most paragraphs\", When the question mentions \"id\", When the question mentions \"name\", When combining T1 (Paragraphs) and T2 (Documents) for shared entities, When the question asks for \"count of paragraphs per document\", When the question mentions \"most paragraphs\" or \"highest paragraph count\": rank rows by count(*) in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, name FROM documents ORDER BY id DESC LIMIT 1;",
            "SELECT T1.document_id, T2.document_name\nFROM Paragraphs AS T1\nJOIN Documents AS T2 ON T1.document_id = T2.document_id\nGROUP BY T1.document_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.document_id, T2.document_name\nFROM Paragraphs T1\nINNER JOIN Documents T2 ON T1.document_id = T2.document_id\nGROUP BY T1.document_id, T2.document_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "375": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the document id with least number of paragraphs?",
        "ground_truth": "SELECT document_id FROM Paragraphs GROUP BY document_id ORDER BY count(*) ASC LIMIT 1",
        "amends": [
            "Do use `GROUP BY document_id` instead of omitting it, which enables proper aggregation. Do use `count(*)` instead of `COUNT(paragraph_id)` in the ORDER BY clause to count all rows per group rather than non-null paragraph_id values. Do move the aggregate function from the ORDER BY clause to operate on grouped results instead of attempting to use COUNT directly without grouping. The amended query now correctly groups by document_id and orders by the count of paragraphs per document to find the document with the fewest paragraphs, matching the intended behavior.",
            "Do remove `paragraph_count` alias from the SELECT list instead of including it, and do reference the aggregate function directly in ORDER BY as `count(*)` instead of using the alias `paragraph_count`. Do omit the explicit column alias in the SELECT clause instead of defining it, since the RIGHT_SQL does not include this alias in the output. The amended query now matches RIGHT_SQL's behavior by returning only document_id values ordered by the actual count of paragraphs without an intermediate alias."
        ],
        "rules": [
            "When answering about \"document id with least number of paragraphs\": make sure the output order: document_id.",
            "When the question asks for \"least number of paragraphs\" per document: organize results by document_id and compute count of paragraphs per group.",
            "When counting paragraphs per document: compute the number of rows using count(*) for each document_id group.",
            "When answering about \"document id with least number of paragraphs\", When the question asks for \"least number of paragraphs\" per document, When counting paragraphs per document, When finding the document with the minimum paragraph count: rank rows by paragraph count in ascending order and keep the first 1 row.",
            "When counting paragraphs per document: count the number of rows using the canonical key for paragraphs (count(*)) instead of using an alias.",
            "When ordering by paragraph count: reference the aggregate function count(*) directly in the ORDER BY clause instead of using an alias.",
            "When selecting output columns: include only document_id in the SELECT list and omit any alias for the count.",
            "When counting paragraphs per document, When ordering by paragraph count, When selecting output columns, When finding the document with the least number of paragraphs: order by count(*) in ascending order and keep only the first result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id FROM paragraphs ORDER BY COUNT(paragraph_id) ASC LIMIT 1;",
            "SELECT document_id, COUNT(*) as paragraph_count FROM Paragraphs GROUP BY document_id ORDER BY paragraph_count ASC LIMIT 1;",
            "SELECT document_id FROM Paragraphs GROUP BY document_id ORDER BY count(*) ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT document_id FROM Paragraphs GROUP BY document_id ORDER BY COUNT(*) ASC LIMIT 1;"
        ]
    },
    "376": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the id of the document with the fewest paragraphs.",
        "ground_truth": "SELECT document_id FROM Paragraphs GROUP BY document_id ORDER BY count(*) ASC LIMIT 1",
        "amends": [
            "Do select `document_id` from the `Paragraphs` table instead of `id` from `documents`. Do use `GROUP BY document_id` with aggregation instead of selecting from a single table. Do order by `count(*) ASC` instead of `paragraphs DESC` to find the document with the fewest paragraphs. Do remove the incorrect column reference `paragraphs` and instead use the proper aggregate function to count paragraphs per document. The amended query now correctly identifies the document with the smallest number of paragraphs by counting and grouping, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"the document with the fewest paragraphs\": make sure the output order: document_id.",
            "When counting paragraphs per document: group by \"document_id\" and compute count(*) for each group.",
            "When finding the document with the fewest paragraphs: order the results by count(*) in ascending order and keep only the first row.",
            "When answering about \"the document with the fewest paragraphs\", When counting paragraphs per document, When finding the document with the fewest paragraphs, When selecting from the Paragraphs table: use \"document_id\" as the output column instead of \"id\" from documents table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM documents ORDER BY paragraphs DESC LIMIT 1;",
            "SELECT document_id FROM Paragraphs GROUP BY document_id ORDER BY COUNT(*) ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT document_id FROM Paragraphs GROUP BY document_id ORDER BY COUNT(*) ASC LIMIT 1;"
        ]
    },
    "377": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the document id with 1 to 2 paragraphs?",
        "ground_truth": "SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*) BETWEEN 1 AND 2",
        "amends": [
            "Do query from the `Paragraphs` table instead of the `documents` table. Do use `GROUP BY document_id` with a `HAVING count(*) BETWEEN 1 AND 2` clause instead of filtering `paragraph_count = 1 OR paragraph_count = 2` in the WHERE clause. Do aggregate paragraph counts using `count(*)` instead of relying on a pre-calculated `paragraph_count` column. The amended query now correctly counts paragraphs per document and filters for documents with exactly 1 or 2 paragraphs, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"document id with 1 to 2 paragraphs\": make sure the output order: document_id.",
            "When counting paragraphs per document: compute the number of paragraphs using count(*) grouped by document_id.",
            "When filtering for documents with exactly 1 or 2 paragraphs: use a condition that keeps only groups where the paragraph count is between 1 and 2 inclusive.",
            "When answering about \"document id with 1 to 2 paragraphs\", When counting paragraphs per document, When filtering for documents with exactly 1 or 2 paragraphs, When the question mentions \"paragraphs\": use the Paragraphs table instead of the documents table to count actual paragraph entities."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id FROM documents WHERE paragraph_count = 1 OR paragraph_count = 2;",
            "SELECT document_id FROM Paragraphs GROUP BY document_id HAVING COUNT(*) BETWEEN 1 AND 2"
        ],
        "rule_sql": [
            "SELECT Document_ID FROM Paragraphs GROUP BY Document_ID HAVING COUNT(*) BETWEEN 1 AND 2 ORDER BY Document_ID;"
        ]
    },
    "378": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Give the ids of documents that have between one and two paragraphs.",
        "ground_truth": "SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*) BETWEEN 1 AND 2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id FROM paragraphs GROUP BY document_id HAVING COUNT(*) = 1 OR COUNT(*) = 2;"
        ],
        "rule_sql": [
            "SELECT Document_ID \nFROM Documents \nWHERE Document_ID IN (\n    SELECT Document_ID \n    FROM Paragraphs \n    GROUP BY Document_ID \n    HAVING COUNT(Paragraph_ID) BETWEEN 1 AND 2\n)"
        ]
    },
    "379": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show the document id with paragraph text 'Brazil' and 'Ireland'.",
        "ground_truth": "SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Brazil' INTERSECT SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Ireland'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id FROM paragraphs WHERE paragraph_text = 'Brazil' OR paragraph_text = 'Ireland'"
        ],
        "rule_sql": [
            "SELECT d.Document_ID\nFROM Documents d\nJOIN Paragraphs p1 ON d.Document_ID = p1.Document_ID\nJOIN Paragraphs p2 ON d.Document_ID = p2.Document_ID\nWHERE p1.Paragraph_Text = 'Brazil'\nAND p2.Paragraph_Text = 'Ireland';"
        ]
    },
    "380": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the ids of documents that contain the paragraph text 'Brazil' and 'Ireland'?",
        "ground_truth": "SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Brazil' INTERSECT SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Ireland'",
        "amends": [
            "Do use `INTERSECT` to find document IDs that contain both specified texts instead of using `OR` which finds documents containing either text. Do reference the correct column name `paragraph_text` instead of `text` in both SELECT statements. Do use proper table name capitalization `Paragraphs` instead of `paragraphs`. Do structure the query as two separate SELECT statements with INTERSECT instead of a single query with OR conditions. The amended query now correctly identifies documents that contain both 'Brazil' and 'Ireland' rather than documents containing either one, matching the RIGHT_SQL's set intersection behavior."
        ],
        "rules": [
            "When the question asks for documents containing multiple specific paragraph texts: use INTERSECT to find document IDs that satisfy all text conditions rather than OR which finds documents satisfying any condition.",
            "When referring to paragraph text content: use the exact column name \"paragraph_text\" instead of \"text\".",
            "When referencing the paragraphs table: use the exact table name \"Paragraphs\" with proper capitalization.",
            "When the question asks for documents containing multiple specific paragraph texts, When referring to paragraph text content, When referencing the paragraphs table, When finding documents containing both 'Brazil' and 'Ireland': structure the query as two separate SELECT statements that each filter for one text value, then intersect the results to get documents containing both texts."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id FROM paragraphs WHERE text = 'Brazil' OR text = 'Ireland';",
            "SELECT Document_ID FROM Paragraphs WHERE Paragraph_Text = 'Brazil'\nINTERSECT\nSELECT Document_ID FROM Paragraphs WHERE Paragraph_Text = 'Ireland'"
        ],
        "rule_sql": [
            "SELECT Document_ID FROM Paragraphs WHERE Paragraph_Text = 'Brazil'\nINTERSECT\nSELECT Document_ID FROM Paragraphs WHERE Paragraph_Text = 'Ireland'"
        ]
    },
    "381": {
        "db_id": "course_teach",
        "question": "How many teachers are there?",
        "ground_truth": "SELECT count(*) FROM teacher",
        "amends": [
            "Do select from `teacher` table instead of `students` table. The amended query now correctly counts records from the teacher table as specified in the target query."
        ],
        "rules": [
            "When answering about \"how many teachers\": make sure to count records from the \"teacher\" table instead of the \"students\" table.",
            "When answering about \"how many teachers\", When counting entities: use the canonical key for counting (typically the primary key of the table) to count the number of teachers."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;",
            "SELECT COUNT(*) FROM teacher;"
        ],
        "rule_sql": [
            "SELECT COUNT(Teacher_ID) FROM teacher;"
        ]
    },
    "382": {
        "db_id": "course_teach",
        "question": "What is the total count of teachers?",
        "ground_truth": "SELECT count(*) FROM teacher",
        "amends": [
            "Do select from `teacher` table instead of `students` table. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"total count of teachers\": make sure to count from the \"teacher\" table instead of the \"students\" table.",
            "When answering about \"total count of teachers\", When counting teachers: use the canonical key for counting entities from the teacher table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;",
            "SELECT COUNT(*) FROM teacher;"
        ],
        "rule_sql": [
            "SELECT COUNT(Teacher_ID) FROM teacher;"
        ]
    },
    "383": {
        "db_id": "course_teach",
        "question": "List the names of teachers in ascending order of age.",
        "ground_truth": "SELECT Name FROM teacher ORDER BY Age ASC",
        "amends": [
            "Do use table name `teacher` instead of `teachers` and select column `Name` instead of `name`. Do order by `Age ASC` instead of `age DESC`, changing both the column name and sort direction. The amended query now correctly references the intended table and column names with proper casing and applies ascending ordering instead of descending."
        ],
        "rules": [
            "When the question mentions \"teachers\": use the exact table name \"teacher\" instead of \"teachers\".",
            "When selecting teacher names: use the exact column name \"Name\" instead of \"name\".",
            "When the question mentions \"teachers\", When selecting teacher names, When ordering by age in ascending order: use the exact column name \"Age\" and apply ascending (ASC) ordering instead of descending (DESC)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM teachers ORDER BY age DESC;",
            "SELECT Name FROM teacher ORDER BY Age ASC;"
        ],
        "rule_sql": [
            "SELECT Name FROM teacher ORDER BY Age ASC;"
        ]
    },
    "384": {
        "db_id": "course_teach",
        "question": "What are the names of the teachers ordered by ascending age?",
        "ground_truth": "SELECT Name FROM teacher ORDER BY Age ASC",
        "amends": [
            "Do reference the table as `teacher` instead of `teachers` to match the correct schema. Do select the column `Name` instead of `name` to use proper case sensitivity. Do order by `Age` in `ASC` order instead of `DESC` to sort in ascending rather than descending sequence. The amended query now correctly retrieves teacher names sorted by age in ascending order."
        ],
        "rules": [
            "When the question asks about teachers: use the table \"teacher\" instead of \"teachers\" to match the schema exactly.",
            "When selecting teacher names: use the column \"Name\" with exact case sensitivity as shown in the schema.",
            "When the question asks about teachers, When selecting teacher names, When ordering by age: use the column \"Age\" and sort in ascending (ASC) order instead of descending to match the question requirement."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM teachers ORDER BY age DESC;",
            "SELECT Name FROM teacher ORDER BY Age ASC;"
        ],
        "rule_sql": [
            "SELECT Name FROM teacher ORDER BY Age ASC;"
        ]
    },
    "385": {
        "db_id": "course_teach",
        "question": "What are the age and hometown of teachers?",
        "ground_truth": "SELECT Age ,  Hometown FROM teacher",
        "amends": [
            "Do select `Age` and `Hometown` columns instead of `name` and `subject`. Do reference the `teacher` table instead of `teachers`. The amended query now correctly retrieves age and hometown information from the teacher table."
        ],
        "rules": [
            "When the question asks for \"age and hometown of teachers\": select columns \"Age\" and \"Hometown\" from table \"teacher\".",
            "When referring to the teacher entity: use the exact table name \"teacher\" (not \"teachers\").",
            "When the question asks for \"age and hometown of teachers\", When referring to the teacher entity, When producing output: maintain the order of columns as \"Age\" followed by \"Hometown\" as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, subject FROM teachers;",
            "SELECT Age, Hometown FROM teacher;"
        ],
        "rule_sql": [
            "SELECT Age, Hometown FROM teacher;"
        ]
    },
    "386": {
        "db_id": "course_teach",
        "question": "What is the age and hometown of every teacher?",
        "ground_truth": "SELECT Age ,  Hometown FROM teacher",
        "amends": [
            "Do select `Age` and `Hometown` columns instead of `name` and `subject`. Do reference the `teacher` table instead of `teachers`. The amended query now correctly retrieves age and hometown information from the teacher table as intended."
        ],
        "rules": [
            "When answering about \"age and hometown of every teacher\": make sure the output order: Age, Hometown.",
            "When the question mentions \"teacher\": \"teacher\" actually means table \"teacher\" in schema.",
            "When answering about \"age and hometown of every teacher\", When the question mentions \"teacher\", When selecting columns for teacher information: use exact column tokens \"Age\" and \"Hometown\" from table \"teacher\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, subject FROM teachers;",
            "SELECT Age, Hometown FROM teacher;"
        ],
        "rule_sql": [
            "SELECT Age, Hometown FROM teacher;"
        ]
    },
    "387": {
        "db_id": "course_teach",
        "question": "List the name of teachers whose hometown is not `` Little Lever Urban District '' .",
        "ground_truth": "select name from teacher where hometown != \"little lever urban district\"",
        "amends": [
            "Do reference table `teacher` instead of `teachers` in the FROM clause. Do use inequality filter `!= \"little lever urban district\"` instead of equality filter `= 'Little Lever Urban District'` in the WHERE clause. The amended query now correctly selects from the proper table and filters for records where hometown is not equal to the specified value, matching the intended behavior.",
            "Do use lowercase SQL keywords throughout instead of mixed case formatting. Do use lowercase string comparison for \"little lever urban district\" instead of title case formatting. The query logic remains identical with no changes to SELECT list, FROM sources, WHERE filters, or any other structural elements. The amended query now matches RIGHT_SQL's behavior with case-insensitive equivalent execution."
        ],
        "rules": [
            "When answering about \"teachers whose hometown is not Little Lever Urban District\": make sure the output order: name.",
            "When the question mentions \"teachers\": \"teachers\" actually means \"teacher\" in schema.",
            "When answering about \"teachers whose hometown is not Little Lever Urban District\", When the question mentions \"teachers\", When filtering for hometown not equal to \"Little Lever Urban District\": use inequality comparison != with exact literal \"Little Lever Urban District\" (case-sensitive).",
            "When the question mentions \"hometown\": \"hometown\" actually means \"Hometown\" in schema.",
            "When the question specifies \"not 'Little Lever Urban District'\": use the exact literal 'little lever urban district' with lowercase formatting for string comparison.",
            "When the question mentions \"hometown\", When the question specifies \"not 'Little Lever Urban District'\", When answering about \"name of teachers\": make sure the output order: Name."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM teachers WHERE hometown = 'Little Lever Urban District';",
            "SELECT Name FROM teacher WHERE Hometown != \"Little Lever Urban District\"",
            "SELECT name FROM teacher WHERE hometown != \"little lever urban district\""
        ],
        "rule_sql": [
            "SELECT Name FROM teacher WHERE Hometown != 'Little Lever Urban District' ORDER BY Name;"
        ]
    },
    "388": {
        "db_id": "course_teach",
        "question": "What are the names of the teachers whose hometown is not `` Little Lever Urban District '' ?",
        "ground_truth": "select name from teacher where hometown != \"little lever urban district\"",
        "amends": [
            "Do reference table `teacher` instead of `teachers` in the FROM clause. Do use inequality filter `!= \"little lever urban district\"` instead of equality filter `= 'Little Lever Urban District'` in the WHERE clause. The amended query now correctly filters for teachers not from Little Lever Urban District instead of those from it, matching the intended behavior.",
            "Do use lowercase `select` instead of uppercase `SELECT`, lowercase `from` instead of uppercase `FROM`, lowercase `where` instead of uppercase `WHERE`, and lowercase `name` instead of uppercase `Name` to maintain consistent casing throughout the query. Do use lowercase `hometown` instead of uppercase `Hometown` and lowercase `little lever urban district` instead of capitalized `Little Lever Urban District` for case consistency in both column reference and string comparison. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [
            "When the question asks about teachers: use table \"teacher\" instead of \"teachers\" as the data source.",
            "When filtering for teachers whose hometown is not \"Little Lever Urban District\": use inequality comparison != \"little lever urban district\" instead of equality comparison.",
            "When the question asks about teachers, When filtering for teachers whose hometown is not \"Little Lever Urban District\", When handling text literals: preserve the exact case and spacing as \"little lever urban district\" (all lowercase) as shown in the amends, not the mixed case from the question.",
            "When choosing SQL keywords: use lowercase 'select', 'from', and 'where' instead of uppercase versions to maintain consistent casing throughout the query.",
            "When referring to column names: use lowercase 'name' instead of uppercase 'Name' and lowercase 'hometown' instead of uppercase 'Hometown' to match the schema's column naming convention.",
            "When choosing SQL keywords, When referring to column names, When comparing string literals: use lowercase 'little lever urban district' instead of capitalized 'Little Lever Urban District' for case consistency in string comparison."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM teachers WHERE hometown = 'Little Lever Urban District';",
            "SELECT Name FROM teacher WHERE Hometown != \"Little Lever Urban District\"",
            "select name from teacher where hometown != \"little lever urban district\""
        ],
        "rule_sql": [
            "select name from teacher where hometown != 'little lever urban district'"
        ]
    },
    "389": {
        "db_id": "course_teach",
        "question": "Show the name of teachers aged either 32 or 33?",
        "ground_truth": "SELECT Name FROM teacher WHERE Age  =  32 OR Age  =  33",
        "amends": [
            "Do use `OR` between the age conditions instead of `AND` to find teachers who are either 32 or 33 years old instead of requiring both conditions simultaneously. Do reference the correct table name `teacher` instead of `teachers` and use proper column casing with `Name` and `Age` instead of lowercase `name` and `age`. The amended query now correctly returns teachers who are either 32 or 33 years old, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for teachers aged either 32 or 33: use OR between the age conditions instead of AND to find teachers who meet either condition.",
            "When referencing the teacher table: use the exact table name \"teacher\" instead of \"teachers\".",
            "When selecting the name column: use the exact column name \"Name\" with proper casing instead of lowercase \"name\".",
            "When filtering by age: use the exact column name \"Age\" with proper casing instead of lowercase \"age\".",
            "When the question asks for teachers aged either 32 or 33, When referencing the teacher table, When selecting the name column, When filtering by age, When specifying age values: use the exact literals \"32\" and \"33\" as shown in the schema sample values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM teachers WHERE age = 32 AND age = 33;",
            "SELECT Name FROM teacher WHERE Age = '32' OR Age = '33';"
        ],
        "rule_sql": [
            "SELECT Name FROM teacher WHERE Age = '32' OR Age = '33';"
        ]
    },
    "390": {
        "db_id": "course_teach",
        "question": "What are the names of the teachers who are aged either 32 or 33?",
        "ground_truth": "SELECT Name FROM teacher WHERE Age  =  32 OR Age  =  33",
        "amends": [
            "Do reference the table as `teacher` instead of `teachers` and use column names `Name` and `Age` instead of `name` and `age` to match the correct schema, while maintaining the same filter condition `Age = 32 OR Age = 33` instead of changing the logic. The amended query now correctly selects from the intended table with proper column names while preserving the original age filter behavior."
        ],
        "rules": [
            "When the question asks about teachers: use the table \"teacher\" instead of \"teachers\" to match the schema.",
            "When selecting teacher names: use the column \"Name\" instead of \"name\" to match the schema.",
            "When filtering by age: use the column \"Age\" instead of \"age\" to match the schema.",
            "When the question asks about teachers, When selecting teacher names, When filtering by age, When filtering for ages 32 or 33: maintain the exact condition \"Age = 32 OR Age = 33\" to preserve the original logic."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM teachers WHERE age = 32 OR age = 33;",
            "SELECT Name FROM teacher WHERE Age = '32' OR Age = '33';"
        ],
        "rule_sql": [
            "SELECT Name FROM teacher WHERE Age = '32' OR Age = '33'"
        ]
    },
    "391": {
        "db_id": "course_teach",
        "question": "What is the hometown of the youngest teacher?",
        "ground_truth": "SELECT Hometown FROM teacher ORDER BY Age ASC LIMIT 1",
        "amends": [
            "Do reference the table as `teacher` instead of `teachers` to match the correct schema. Do capitalize column names as `Hometown` and `Age` instead of lowercase `hometown` and `age` to maintain proper case sensitivity. The amended query now correctly selects from the teacher table with proper column casing while preserving the same ordering and limiting behavior."
        ],
        "rules": [
            "When the question asks about \"teachers\": use the exact table name \"teacher\" instead of \"teachers\" to match the schema.",
            "When selecting column names: use exact case-sensitive identifiers \"Hometown\" and \"Age\" instead of lowercase versions.",
            "When the question asks about \"teachers\", When selecting column names, When finding the youngest teacher: order by \"Age\" in ascending order and take the first result to get the minimum age value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT hometown FROM teachers ORDER BY age ASC LIMIT 1;",
            "SELECT Hometown FROM teacher ORDER BY CAST(Age AS INTEGER) ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Hometown FROM teacher ORDER BY Age ASC LIMIT 1;"
        ]
    },
    "392": {
        "db_id": "course_teach",
        "question": "Where is the youngest teacher from?",
        "ground_truth": "SELECT Hometown FROM teacher ORDER BY Age ASC LIMIT 1",
        "amends": [
            "Do select `Hometown` instead of `name` and reference `teacher` instead of `teachers` as the table source, while maintaining the `ORDER BY Age ASC LIMIT 1` clause unchanged."
        ],
        "rules": [
            "When answering about \"the youngest teacher\": make sure the output order: Hometown.",
            "When the question asks for \"where is the youngest teacher\": \"where\" actually means \"Hometown in schema\".",
            "When the question mentions \"youngest\": rank rows by Age in ascending order and keep the first 1 row.",
            "When answering about \"the youngest teacher\", When the question asks for \"where is the youngest teacher\", When the question mentions \"youngest\", When selecting from the teacher table: use the exact table name \"teacher\" (not \"teachers\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM teachers ORDER BY age ASC LIMIT 1;",
            "SELECT Hometown FROM teacher ORDER BY Age ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Hometown FROM teacher ORDER BY Age ASC LIMIT 1;"
        ]
    },
    "393": {
        "db_id": "course_teach",
        "question": "Show different hometown of teachers and the number of teachers from each hometown.",
        "ground_truth": "SELECT Hometown ,  COUNT(*) FROM teacher GROUP BY Hometown",
        "amends": [
            "Do reference the `teacher` table instead of `teachers` in the FROM clause. Do group by `Hometown` instead of `teacher_id` to correctly count teachers by their hometown rather than counting each teacher individually. Do capitalize `Hometown` in the SELECT list instead of lowercase `hometown` for consistency. The amended query now correctly counts teachers grouped by their hometown locations rather than producing incorrect per-teacher counts."
        ],
        "rules": [
            "When the question asks about teachers' hometowns: use the table \"teacher\" (not \"teachers\") as the base table T1.",
            "When counting teachers per hometown: group by the exact column \"Hometown\" (capitalized) from table T1.",
            "When showing the number of teachers from each hometown: count using the canonical key for teachers (implied by grouping on hometown) rather than counting individual teacher records.",
            "When the question asks about teachers' hometowns, When counting teachers per hometown, When showing the number of teachers from each hometown, When producing output: show \"Hometown\" first followed by the count of teachers, maintaining this column order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT hometown, COUNT(*) FROM teachers GROUP BY teacher_id;",
            "SELECT Hometown, COUNT(*) AS Number_of_Teachers FROM teacher GROUP BY Hometown;"
        ],
        "rule_sql": [
            "SELECT Hometown, COUNT(Teacher_ID) AS NumberOfTeachers FROM teacher GROUP BY Hometown;"
        ]
    },
    "394": {
        "db_id": "course_teach",
        "question": "For each hometown, how many teachers are there?",
        "ground_truth": "SELECT Hometown ,  COUNT(*) FROM teacher GROUP BY Hometown",
        "amends": [
            "Do reference the `teacher` table instead of `teachers` in the FROM clause. Do group by `Hometown` instead of `teacher_id` to correctly count teachers by their hometowns. Do capitalize `Hometown` in the SELECT list instead of lowercase `hometown` for consistency. The amended query now correctly counts teachers grouped by their hometown locations rather than by individual teacher IDs, matching the intended behavior."
        ],
        "rules": [
            "When the question asks about \"hometown\": use the exact column token \"Hometown\" from the teacher table.",
            "When counting teachers per hometown: group by \"Hometown\" and count using the canonical key for teachers (teacher_id or equivalent).",
            "When the question asks \"how many teachers are there\" per group: compute the count of teachers for each hometown group.",
            "When the question asks about \"hometown\", When counting teachers per hometown, When the question asks \"how many teachers are there\" per group, When choosing table references: use the exact table name \"teacher\" as specified in the schema, not variations like \"teachers\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT hometown, COUNT(*) FROM teachers GROUP BY teacher_id;",
            "SELECT Hometown, COUNT(*) AS teacher_count FROM teacher GROUP BY Hometown"
        ],
        "rule_sql": [
            "SELECT Hometown, COUNT(Teacher_ID) AS teacher_count FROM teacher GROUP BY Hometown"
        ]
    },
    "395": {
        "db_id": "course_teach",
        "question": "List the most common hometown of teachers.",
        "ground_truth": "SELECT Hometown FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do use the table name `teacher` instead of `teachers` and capitalize `Hometown` instead of lowercase `hometown` in both the SELECT list and GROUP BY clause. Do remove the alias `count` from the aggregate function and instead reference `COUNT(*)` directly in the ORDER BY clause instead of using the alias. Do maintain the same GROUP BY and ORDER BY logic but with corrected table name and column capitalization. The amended query now correctly references the actual table schema while preserving the intended behavior of finding the hometown with the highest count of teachers.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, as the query only needs to return the Hometown with the highest count rather than both the Hometown and its count value. The amended query now correctly returns just the Hometown column while maintaining the same GROUP BY, ORDER BY, and LIMIT logic to identify the hometown with the most teachers, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks about \"teachers\": use the table name \"teacher\" exactly as specified in the schema.",
            "When the question mentions \"hometown\": use the column name \"Hometown\" with exact capitalization as shown in the schema.",
            "When counting teachers: count all rows using COUNT(*) and do not use aliases for the count in ORDER BY clauses.",
            "When the question asks about \"teachers\", When the question mentions \"hometown\", When counting teachers, When finding the most common value: group by the exact column \"Hometown\", count occurrences, order by the count in descending order, and take only the top result.",
            "When the question asks for \"most common hometown of teachers\": identify the hometown with the highest count of teachers.",
            "When counting teachers per hometown: count the number of rows using the canonical key for teachers (implied by GROUP BY Hometown).",
            "When ranking for \"most common\": order the groups by count in descending order.",
            "When selecting only the top result: keep only the first row after ordering.",
            "When the question asks for \"most common hometown of teachers\", When counting teachers per hometown, When ranking for \"most common\", When selecting only the top result, When the output should show only the hometown value: return only the Hometown column without the count value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT hometown, COUNT(*) as count FROM teachers GROUP BY hometown ORDER BY count DESC LIMIT 1;",
            "SELECT Hometown, COUNT(*) FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT Hometown FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Hometown FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "396": {
        "db_id": "course_teach",
        "question": "What is the most commmon hometowns for teachers?",
        "ground_truth": "SELECT Hometown FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do reference the table as `teacher` instead of `teachers` to match the correct schema. Do capitalize `Hometown` in both the SELECT list and GROUP BY clause instead of using lowercase `hometown` for consistency with the correct column name. Do remove the alias `count` from the COUNT(*) expression instead of keeping it, as the RIGHT_SQL does not include an alias. Do maintain the same aggregation logic with `COUNT(*)` in the ORDER BY clause instead of referencing the removed alias, ensuring the query correctly orders by the count of records per hometown. The amended query now correctly identifies the hometown with the highest count of teachers by using the proper table name and column casing while preserving the core aggregation and ordering logic.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, as the query only needs to return the Hometown with the highest count rather than both the Hometown and its count value. The amended query now matches RIGHT_SQL's behavior by returning just the single Hometown with the maximum occurrence count."
        ],
        "rules": [
            "When answering about \"most common hometowns for teachers\": make sure the output order: Hometown, COUNT(*)",
            "When the question mentions \"teachers\": \"teachers\" actually means \"teacher\" in schema",
            "When the question mentions \"hometowns\": \"hometowns\" actually means \"Hometown\" in schema",
            "When the question asks for \"most common\": rank rows by COUNT(*) in descending direction and keep the first 1 row",
            "When answering about \"most common hometowns for teachers\", When the question mentions \"teachers\", When the question mentions \"hometowns\", When the question asks for \"most common\", When the question asks for \"count of teachers\": compute the number of rows using COUNT(*) per Hometown group",
            "When the question asks for the most common hometowns for teachers: return only the hometown value with the highest count, not both the hometown and its count.",
            "When counting occurrences of hometowns: count the number of teacher records for each distinct hometown value.",
            "When the question asks for the most common hometowns for teachers, When counting occurrences of hometowns, When ranking by frequency to find the most common: order the results by count in descending order and take only the top result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT hometown, COUNT(*) as count FROM teachers GROUP BY hometown ORDER BY count DESC LIMIT 1;",
            "SELECT Hometown, COUNT(*) FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1",
            "SELECT Hometown FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Hometown FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "397": {
        "db_id": "course_teach",
        "question": "Show the hometowns shared by at least two teachers.",
        "ground_truth": "SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*)  >=  2",
        "amends": [
            "Do use `COUNT(*) >= 2` instead of `COUNT(*) = 1` in the HAVING clause to find hometowns with at least two teachers rather than exactly one. Do reference the table as `teacher` instead of `teachers` and use the correct column name `Hometown` instead of `hometown` to match the actual schema. The amended query now correctly identifies hometowns with multiple teachers and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for hometowns shared by at least two teachers: use COUNT(*) >= 2 instead of COUNT(*) = 1 to find groups with at least two members.",
            "When referencing the teacher table: use the exact table name \"teacher\" instead of \"teachers\".",
            "When referencing the hometown column: use the exact column name \"Hometown\" instead of \"hometown\" to match the schema.",
            "When the question asks for hometowns shared by at least two teachers, When referencing the teacher table, When referencing the hometown column, When grouping by hometown: organize results by the \"Hometown\" column and count the number of teachers per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT hometown FROM teachers GROUP BY hometown HAVING COUNT(*) = 1",
            "SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*) >= 2"
        ]
    },
    "398": {
        "db_id": "course_teach",
        "question": "What are the towns from which at least two teachers come from?",
        "ground_truth": "SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*)  >=  2",
        "amends": [
            "Do use column name `Hometown` instead of `town` and table name `teacher` instead of `teachers` to match the correct schema. Do change the comparison operator to `>= 2` instead of `> 1` to properly identify hometowns with at least two teachers, which correctly captures the same logical condition while using inclusive comparison."
        ],
        "rules": [
            "When the question mentions \"towns\": \"towns\" actually means \"Hometown\" in the teacher table.",
            "When the question asks for \"at least two teachers\": use the comparison operator >= 2 to identify hometowns with at least two teachers.",
            "When counting teachers per hometown: count using the Hometown column and group by Hometown to compute the number of teachers from each location.",
            "When the question mentions \"towns\", When the question asks for \"at least two teachers\", When counting teachers per hometown, When producing output: return only the Hometown column for locations that meet the condition of having >= 2 teachers."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT town FROM teachers GROUP BY town HAVING COUNT(*) > 1",
            "SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*) >= 2"
        ]
    },
    "399": {
        "db_id": "course_teach",
        "question": "Show names of teachers and the courses they are arranged to teach.",
        "ground_truth": "SELECT T3.Name ,  T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID",
        "amends": [
            "Do select `T3.Name` and `T2.Course` instead of `teacher_name` and `course_name`. Do use `course_arrange AS T1` as the primary table instead of `teachers`, and join `course AS T2` on `T1.Course_ID = T2.Course_ID` instead of directly joining courses. Do add a second join to `teacher AS T3` on `T1.Teacher_ID = T3.Teacher_ID` instead of joining teachers directly to courses. The amended query now correctly uses the course_arrange table as a bridge between teachers and courses, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"names of teachers and the courses they are arranged to teach\": make sure the output order: T3.Name, T2.Course",
            "When the question mentions \"teachers\": use table \"teacher AS T3\" with exact identifier \"T3.Name\" for teacher names",
            "When the question mentions \"courses\": use table \"course AS T2\" with exact identifier \"T2.Course\" for course names",
            "When combining tables for teacher-course arrangements: use \"course_arrange AS T1\" as the primary table and link to \"course AS T2\" where T1.Course_ID = T2.Course_ID, then link to \"teacher AS T3\" where T1.Teacher_ID = T3.Teacher_ID, keeping only matching pairs (inner match)",
            "When answering about \"names of teachers and the courses they are arranged to teach\", When the question mentions \"teachers\", When the question mentions \"courses\", When combining tables for teacher-course arrangements, When selecting output columns: use exact identifiers T3.Name and T2.Course instead of generic teacher_name and course_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT teacher_name, course_name FROM teachers JOIN courses ON teachers.teacher_id = courses.teacher_id;",
            "SELECT T3.Name, T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID = T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID"
        ],
        "rule_sql": [
            "SELECT T3.Name, T2.Course FROM course_arrange AS T1 INNER JOIN course AS T2 ON T1.Course_ID = T2.Course_ID INNER JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID ORDER BY T3.Name, T2.Course"
        ]
    },
    "400": {
        "db_id": "course_teach",
        "question": "What is the name of each teacher and what course they teach?",
        "ground_truth": "SELECT T3.Name ,  T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID",
        "amends": [
            "Do select `T3.Name` and `T2.Course` instead of `teacher_name` and `course_name`. Do use `course_arrange AS T1` joined with `course AS T2` on `T1.Course_ID = T2.Course_ID` instead of directly joining `teachers` with `courses`. Do add a second join with `teacher AS T3` on `T1.Teacher_ID = T3.Teacher_ID` instead of the incorrect join condition `teachers.teacher_id = students.student_id` which referenced a non-existent table. The amended query now correctly establishes relationships through the junction table and matches the intended behavior."
        ],
        "rules": [
            "When answering about teacher names and courses they teach: make sure the output order: T3.Name, T2.Course",
            "When combining course_arrange (T1) and course (T2): link rows where T1.Course_ID = T2.Course_ID and keep only matching pairs (inner match)",
            "When combining course_arrange (T1) and teacher (T3): link rows where T1.Teacher_ID = T3.Teacher_ID and keep only matching pairs (inner match)",
            "When selecting teacher names: use T3.Name instead of teacher_name",
            "When answering about teacher names and courses they teach, When combining course_arrange (T1) and course (T2), When combining course_arrange (T1) and teacher (T3), When selecting teacher names, When selecting course names: use T2.Course instead of course_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT teacher_name, course_name FROM teachers JOIN courses ON teachers.teacher_id = students.student_id;",
            "SELECT T3.Name, T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID = T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID;"
        ],
        "rule_sql": [
            "SELECT T3.Name, T2.Course FROM course_arrange T1 INNER JOIN course T2 ON T1.Course_ID = T2.Course_ID INNER JOIN teacher T3 ON T1.Teacher_ID = T3.Teacher_ID"
        ]
    },
    "401": {
        "db_id": "course_teach",
        "question": "Show names of teachers and the courses they are arranged to teach in ascending alphabetical order of the teacher's name.",
        "ground_truth": "SELECT T3.Name ,  T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID ORDER BY T3.Name",
        "amends": [
            "Do select `T3.Name` and `T2.Course` instead of `teacher_name` and `course_name`. Do join `course_arrange AS T1` with `course AS T2` on `T1.Course_ID = T2.Course_ID` and join `teacher AS T3` on `T1.Teacher_ID = T3.Teacher_ID` instead of querying only from `teachers`. Do order by `T3.Name` instead of `course_name`. The amended query now correctly joins multiple tables to retrieve teacher names and course names with proper relationships, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When selecting teacher names and course names: use \"T3.Name\" for teacher names and \"T2.Course\" for course names instead of generic column names.",
            "When combining course arrangement, course, and teacher information: link \"course_arrange AS T1\" with \"course AS T2\" where \"T1.Course_ID = T2.Course_ID\" and link with \"teacher AS T3\" where \"T1.Teacher_ID = T3.Teacher_ID\", keeping only matching pairs from all three tables.",
            "When selecting teacher names and course names, When combining course arrangement, course, and teacher information, When ordering results alphabetically by teacher name: sort by \"T3.Name\" in ascending order instead of sorting by course name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT teacher_name, course_name FROM teachers ORDER BY course_name ASC;",
            "SELECT T3.Name, T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID = T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID ORDER BY T3.Name ASC;"
        ],
        "rule_sql": [
            "SELECT T3.Name, T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID = T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID ORDER BY T3.Name ASC"
        ]
    },
    "402": {
        "db_id": "course_teach",
        "question": "What are the names of the teachers and the courses they teach in ascending alphabetical order by the name of the teacher?",
        "ground_truth": "SELECT T3.Name ,  T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID ORDER BY T3.Name",
        "amends": [
            "Do select `T3.Name` and `T2.Course` instead of `teacher_name` and `course_name`. Do use `FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID = T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID` instead of the single table `FROM teachers`. Do order by `T3.Name` instead of `course_name ASC`. The amended query now correctly joins multiple tables to retrieve teacher names and course names from their respective source tables rather than assuming they exist in a single table, and orders the results by teacher name instead of course name."
        ],
        "rules": [
            "When answering about teacher names and course names: select T3.Name and T2.Course as output columns.",
            "When combining data from multiple tables: link course_arrange as T1 with course as T2 where T1.Course_ID equals T2.Course_ID, then link with teacher as T3 where T1.Teacher_ID equals T3.Teacher_ID, keeping only matching pairs (inner match).",
            "When answering about teacher names and course names, When combining data from multiple tables, When ordering results alphabetically by teacher name: sort the final results by T3.Name in ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT teacher_name, course_name FROM teachers ORDER BY course_name ASC;",
            "SELECT T3.Name, T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID = T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID ORDER BY T3.Name ASC"
        ],
        "rule_sql": [
            "SELECT T3.Name, T2.Course FROM course_arrange AS T1 INNER JOIN course AS T2 ON T1.Course_ID = T2.Course_ID INNER JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID ORDER BY T3.Name ASC;"
        ]
    },
    "403": {
        "db_id": "course_teach",
        "question": "Show the name of the teacher for the math course.",
        "ground_truth": "SELECT T3.Name FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID WHERE T2.Course  =  \"Math\"",
        "amends": [
            "Do select `T3.Name` from the `teacher` table instead of `teacher_name` from `courses`. Do join three tables using `course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID = T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID` instead of querying only the `courses` table. Do filter on `T2.Course = \"Math\"` instead of `subject = 'math'` to properly reference the course name field. The amended query now correctly joins the necessary tables to retrieve teacher names for math courses, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"teacher for the math course\": make sure the output order: T3.Name.",
            "When the question mentions \"teacher\": \"teacher\" actually means \"T3.Name in schema\".",
            "When the question mentions \"math course\": \"math course\" actually means \"T2.Course = 'Math' in schema\".",
            "When combining T1, T2, and T3 for shared entities: link rows where T1.Course_ID = T2.Course_ID and T1.Teacher_ID = T3.Teacher_ID; keep only matching pairs (inner match).",
            "When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms.",
            "When answering about \"teacher for the math course\", When the question mentions \"teacher\", When the question mentions \"math course\", When combining T1, T2, and T3 for shared entities, When choosing identifier delimiters, When handling text literals: do not change case, spacing, or punctuation - use exact literal 'Math'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT teacher_name FROM courses WHERE subject = 'math';",
            "SELECT T3.Name \nFROM course_arrange AS T1 \nJOIN course AS T2 ON T1.Course_ID = T2.Course_ID \nJOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID \nWHERE T2.Course = 'Math'"
        ],
        "rule_sql": [
            "SELECT T3.\"Name\" FROM course_arrange T1 JOIN course T2 ON T1.\"Course_ID\" = T2.\"Course_ID\" JOIN teacher T3 ON T1.\"Teacher_ID\" = T3.\"Teacher_ID\" WHERE T2.\"Course\" = 'Math'"
        ]
    },
    "404": {
        "db_id": "course_teach",
        "question": "What are the names of the people who teach math courses?",
        "ground_truth": "SELECT T3.Name FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID WHERE T2.Course  =  \"Math\"",
        "amends": [
            "Do select `T3.Name` from the `teacher` table instead of `name` from `teachers`. Do use a multi-table join structure with `course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID = T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID` instead of querying only the `teachers` table. Do filter on `T2.Course = \"Math\"` instead of `subject = 'math'` to properly identify math courses through the course table relationship. The amended query now correctly retrieves teacher names by joining through the course arrangement and course tables to establish the proper relationships between teachers and math courses."
        ],
        "rules": [
            "When answering about \"names of people who teach math courses\": make sure the output order: T3.Name",
            "When the question mentions \"math courses\": \"math\" actually means \"Math\" in schema (exact literal with capital M)",
            "When combining tables for teacher-course relationships: link rows using T1.Course_ID = T2.Course_ID and T1.Teacher_ID = T3.Teacher_ID, keeping only matching pairs (inner match)",
            "When filtering for math courses: use T2.Course = \"Math\" with exact literal value and double quotes",
            "When answering about \"names of people who teach math courses\", When the question mentions \"math courses\", When combining tables for teacher-course relationships, When filtering for math courses, When selecting teacher names: use T3.Name from the teacher table (not name from teachers table)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM teachers WHERE subject = 'math';",
            "SELECT T3.Name \nFROM course_arrange AS T1 \nJOIN course AS T2 ON T1.Course_ID = T2.Course_ID \nJOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID \nWHERE T2.Course = 'Math'"
        ],
        "rule_sql": [
            "SELECT T3.Name\nFROM course_arrange T1\nINNER JOIN course T2 ON T1.Course_ID = T2.Course_ID\nINNER JOIN teacher T3 ON T1.Teacher_ID = T3.Teacher_ID\nWHERE T2.Course = \"Math\""
        ]
    },
    "405": {
        "db_id": "course_teach",
        "question": "Show names of teachers and the number of courses they teach.",
        "ground_truth": "SELECT T2.Name ,  COUNT(*) FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T2.Name",
        "amends": [
            "Do join `course_arrange AS T1` with `teacher AS T2` on `T1.Teacher_ID = T2.Teacher_ID` instead of querying `teachers` table directly. Do select `T2.Name` instead of `teacher_name` and maintain `COUNT(*)` aggregation. Do group by `T2.Name` instead of `teacher_name` to properly count course arrangements per teacher. The amended query now correctly joins the course arrangement and teacher tables to count courses per teacher rather than attempting to count from a teachers table directly."
        ],
        "rules": [
            "When answering about \"names of teachers and the number of courses they teach\": make sure the output order: T2.Name, COUNT(*).",
            "When combining course_arrange as T1 and teacher as T2: link rows where T1.Teacher_ID = T2.Teacher_ID and keep only matching pairs (inner match).",
            "When the question asks for \"number of courses they teach\": compute the count of course arrangements using COUNT(*) aggregation.",
            "When answering about \"names of teachers and the number of courses they teach\", When combining course_arrange as T1 and teacher as T2, When the question asks for \"number of courses they teach\", When the question says \"per teacher\": organize results by T2.Name and compute COUNT(*) per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT teacher_name, COUNT(*) FROM teachers GROUP BY teacher_name;",
            "SELECT T2.Name, COUNT(*) AS NumberOfCourses FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID = T2.Teacher_ID GROUP BY T2.Name"
        ],
        "rule_sql": [
            "SELECT T2.Name, COUNT(*) \nFROM course_arrange AS T1 \nINNER JOIN teacher AS T2 ON T1.Teacher_ID = T2.Teacher_ID \nGROUP BY T2.Name"
        ]
    },
    "406": {
        "db_id": "course_teach",
        "question": "What are the names of the teachers and how many courses do they teach?",
        "ground_truth": "SELECT T2.Name ,  COUNT(*) FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T2.Name",
        "amends": [
            "Do join `course_arrange AS T1` with `teacher AS T2` on `T1.Teacher_ID = T2.Teacher_ID` instead of querying only the `teachers` table. Do select `T2.Name` instead of `teacher_name` while keeping `COUNT(*)`. Do group by `T2.Name` instead of `teacher_name` to properly count course arrangements per teacher. The amended query now correctly joins the course arrangement and teacher tables to count courses per teacher rather than attempting to count from a single teachers table."
        ],
        "rules": [
            "When answering about \"names of teachers and how many courses they teach\": make sure the output order: T2.Name, COUNT(*).",
            "When combining course_arrange as T1 and teacher as T2 for shared entities: link rows where T1.Teacher_ID = T2.Teacher_ID exactly as shown; keep only matching pairs (inner match).",
            "When the question asks for \"count of courses\" per teacher: compute the number of course arrangement rows using COUNT(*) grouped by T2.Name.",
            "When answering about \"names of teachers and how many courses they teach\", When combining course_arrange as T1 and teacher as T2 for shared entities, When the question asks for \"count of courses\" per teacher, When the question mentions \"names of teachers\": \"teacher names\" actually means T2.Name in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT teacher_name, COUNT(*) FROM teachers GROUP BY teacher_name;",
            "SELECT T2.Name, COUNT(*) \nFROM course_arrange AS T1 \nJOIN teacher AS T2 ON T1.Teacher_ID = T2.Teacher_ID \nGROUP BY T2.Name"
        ],
        "rule_sql": [
            "SELECT T2.Name, COUNT(*) \nFROM course_arrange AS T1 \nINNER JOIN teacher AS T2 ON T1.Teacher_ID = T2.Teacher_ID \nGROUP BY T2.Name"
        ]
    },
    "407": {
        "db_id": "course_teach",
        "question": "Show names of teachers that teach at least two courses.",
        "ground_truth": "SELECT T2.Name FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T2.Name HAVING COUNT(*)  >=  2",
        "amends": [
            "Do use `T2.Name` from the `teacher` table instead of `name` from the `teachers` table. Do join `course_arrange AS T1` with `teacher AS T2` on `T1.Teacher_ID = T2.Teacher_ID` instead of querying a single table. Do add `GROUP BY T2.Name` to aggregate by teacher name instead of no grouping. Do move the count filter to `HAVING COUNT(*) >= 2` instead of using `WHERE course_count >= 2` on a non-aggregated column. The amended query now correctly counts course assignments per teacher and filters for those with at least two courses, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for teacher names: use \"T2.Name\" from the \"teacher\" table.",
            "When counting courses per teacher: join \"course_arrange AS T1\" with \"teacher AS T2\" on \"T1.Teacher_ID = T2.Teacher_ID\" to link course assignments to teachers.",
            "When grouping by teacher: use \"GROUP BY T2.Name\" to organize results by teacher name.",
            "When the question asks for teacher names, When counting courses per teacher, When grouping by teacher, When filtering for teachers with at least two courses: use \"HAVING COUNT(*) >= 2\" to filter after aggregation instead of using WHERE on a non-aggregated column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM teachers WHERE course_count >= 2;",
            "SELECT T2.Name\nFROM course_arrange AS T1\nJOIN teacher AS T2 ON T1.Teacher_ID = T2.Teacher_ID\nGROUP BY T2.Name\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T2.Name FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID = T2.Teacher_ID GROUP BY T2.Name HAVING COUNT(*) >= 2"
        ]
    },
    "408": {
        "db_id": "course_teach",
        "question": "What are the names of the teachers who teach at least two courses?",
        "ground_truth": "SELECT T2.Name FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T2.Name HAVING COUNT(*)  >=  2",
        "amends": [
            "Do join `course_arrange AS T1` with `teacher AS T2` on `T1.Teacher_ID = T2.Teacher_ID` instead of querying only the `teachers` table. Do aggregate with `GROUP BY T2.Name` and filter with `HAVING COUNT(*) >= 2` instead of using `WHERE course_count >= 2` on a non-aggregated column. Do select `T2.Name` from the joined teacher table instead of selecting `name` directly from the original teachers table. The amended query now correctly counts actual course assignments per teacher rather than relying on a potentially incorrect course_count field, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"teachers who teach at least two courses\": make sure the output order: T2.Name.",
            "When the question mentions \"teachers\": \"teachers\" actually means \"teacher AS T2\" in schema.",
            "When combining course_arrange AS T1 and teacher AS T2 for shared entities: link rows where T1.Teacher_ID = T2.Teacher_ID exactly as shown; keep only matching pairs (inner match).",
            "When the question asks for \"teachers who teach at least two courses\": organize results by T2.Name and compute COUNT(*) per group, then filter to keep only groups with COUNT(*) >= 2.",
            "When answering about \"teachers who teach at least two courses\", When the question mentions \"teachers\", When combining course_arrange AS T1 and teacher AS T2 for shared entities, When the question asks for \"teachers who teach at least two courses\", When producing output: select T2.Name from the joined teacher table instead of selecting name directly from the original teachers table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM teachers WHERE course_count >= 2;",
            "SELECT T2.Name FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID = T2.Teacher_ID GROUP BY T2.Name HAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T2.Name\nFROM course_arrange AS T1\nJOIN teacher AS T2 ON T1.Teacher_ID = T2.Teacher_ID\nGROUP BY T2.Name\nHAVING COUNT(*) >= 2\nORDER BY T2.Name"
        ]
    },
    "409": {
        "db_id": "course_teach",
        "question": "List the names of teachers who have not been arranged to teach courses.",
        "ground_truth": "SELECT Name FROM teacher WHERE Teacher_id NOT IN (SELECT Teacher_id FROM course_arrange)",
        "amends": [
            "Do reference the `teacher` table instead of `teachers` and use column `Teacher_id` instead of `teacher_id` in the main query. Do reference the `course_arrange` table instead of `courses` in the subquery and use column `Teacher_id` instead of `teacher_id` in the subquery's SELECT clause. Do use column `Name` instead of `name` in the SELECT list to match the correct schema. The amended query now correctly identifies teachers not assigned to any courses by using the proper table and column names from the schema."
        ],
        "rules": [
            "When the question asks about teachers who have not been arranged to teach courses: use table \"teacher\" as T1 and table \"course_arrange\" as T2.",
            "When selecting teacher names: use column \"Name\" from table \"teacher\" as the output column.",
            "When checking for unassigned teachers: ensure the condition uses \"Teacher_id\" from \"teacher\" table not existing in \"Teacher_id\" values from \"course_arrange\" table.",
            "When the question asks about teachers who have not been arranged to teach courses, When selecting teacher names, When checking for unassigned teachers, When combining teacher and course arrangement information: use the exact column token \"Teacher_id\" for both tables to establish the relationship between teachers and their course assignments."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM teachers WHERE teacher_id NOT IN (SELECT teacher_id FROM courses)",
            "SELECT Name FROM teacher WHERE Teacher_ID NOT IN (SELECT Teacher_ID FROM course_arrange)"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM teacher AS T1 WHERE T1.Teacher_id NOT IN (SELECT T2.Teacher_id FROM course_arrange AS T2)"
        ]
    },
    "410": {
        "db_id": "course_teach",
        "question": "What are the names of the teachers whose courses have not been arranged?",
        "ground_truth": "SELECT Name FROM teacher WHERE Teacher_id NOT IN (SELECT Teacher_id FROM course_arrange)",
        "amends": [
            "Do use a simple `SELECT Name FROM teacher` instead of joining tables with `LEFT JOIN courses`. Do filter with `WHERE Teacher_id NOT IN` subquery instead of `WHERE c.teacher_id IS NOT NULL`. Do reference the correct table `teacher` instead of `teachers` and use proper column names `Teacher_id` instead of `teacher_id`. Do remove the unnecessary join condition and instead use a subquery `(SELECT Teacher_id FROM course_arrange)` to check for non-assigned teachers. The amended query now correctly identifies teachers not assigned to any courses by using a NOT IN subquery instead of an incorrectly filtered left join."
        ],
        "rules": [
            "When the question asks for teachers whose courses have not been arranged: use the table \"teacher\" instead of \"teachers\" and select the \"Name\" column.",
            "When filtering for teachers not assigned to courses: use a NOT IN subquery with \"(SELECT Teacher_id FROM course_arrange)\" instead of a LEFT JOIN.",
            "When referencing identifiers: use exact column names \"Teacher_id\" instead of \"teacher_id\" and maintain proper case sensitivity.",
            "When the question asks for teachers whose courses have not been arranged, When filtering for teachers not assigned to courses, When referencing identifiers, When checking for non-assigned teachers: filter with \"WHERE Teacher_id NOT IN\" condition rather than checking for NULL values after a join."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.name FROM teachers t LEFT JOIN courses c ON t.id = c.teacher_id WHERE c.teacher_id IS NOT NULL;",
            "SELECT Name FROM teacher WHERE Teacher_ID NOT IN (SELECT Teacher_ID FROM course_arrange)"
        ],
        "rule_sql": [
            "SELECT Name FROM teacher WHERE Teacher_ID NOT IN (SELECT Teacher_ID FROM course_arrange)"
        ]
    },
    "411": {
        "db_id": "museum_visit",
        "question": "How many visitors below age 30 are there?",
        "ground_truth": "SELECT count(*) FROM visitor WHERE age  <  30",
        "amends": [
            "Do reference table `visitor` instead of `visitors` to use the correct table name. Do use filter `age < 30` instead of `age > 30` to count visitors under 30 rather than over 30. The amended query now correctly counts visitors under age 30 from the proper table."
        ],
        "rules": [
            "When the question asks about \"visitors\": use the exact table name \"visitor\" from the schema.",
            "When the question asks for visitors \"below age 30\": filter rows where the age column value is less than 30 (age < 30).",
            "When the question asks about \"visitors\", When the question asks for visitors \"below age 30\", When the question asks for \"how many visitors\": count the number of rows that satisfy the age condition using the canonical counting method."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM visitors WHERE age > 30;",
            "SELECT COUNT(*) FROM visitor WHERE Age < 30"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM visitor WHERE Age < 30"
        ]
    },
    "412": {
        "db_id": "museum_visit",
        "question": "Find the names of the visitors whose membership level is higher than 4, and order the results by the level from high to low.",
        "ground_truth": "SELECT name FROM visitor WHERE Level_of_membership  >  4 ORDER BY Level_of_membership DESC",
        "amends": [
            "Do reference table `visitor` instead of `visitors` in the FROM clause. Do use column `Level_of_membership` instead of `membership_level` in both the WHERE filter and ORDER BY clause. Do sort by `Level_of_membership DESC` instead of `ASC` to order in descending rather than ascending sequence. The amended query now correctly references the proper table and column names with the intended sort direction."
        ],
        "rules": [
            "When the question mentions \"visitors\": use table \"visitor\" instead of \"visitors\".",
            "When the question mentions \"membership level\": use column \"Level_of_membership\" instead of \"membership_level\" for both filtering and ordering.",
            "When the question mentions \"visitors\", When the question mentions \"membership level\", When the question asks to order by level from high to low: sort by \"Level_of_membership\" in descending order (DESC) rather than ascending order (ASC)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM visitors WHERE membership_level > 4 ORDER BY membership_level ASC;",
            "SELECT Name FROM visitor WHERE Level_of_membership > 4 ORDER BY Level_of_membership DESC;"
        ],
        "rule_sql": [
            "SELECT Name FROM visitor WHERE Level_of_membership > 4 ORDER BY Level_of_membership DESC;"
        ]
    },
    "413": {
        "db_id": "museum_visit",
        "question": "What is the average age of the visitors whose membership level is not higher than 4?",
        "ground_truth": "SELECT avg(age) FROM visitor WHERE Level_of_membership  <=  4",
        "amends": [
            "Do use table name `visitor` instead of `visitors`. Do change the filter condition to `Level_of_membership <= 4` instead of `membership_level > 4`, which reverses the logic to include members with lower membership levels rather than excluding them. Do use lowercase `avg(age)` instead of uppercase `AVG(age)` for the aggregate function, though this is a cosmetic change that doesn't affect functionality. The amended query now correctly calculates the average age for visitors with membership level 4 or below instead of those above level 4, matching the intended behavior."
        ],
        "rules": [
            "When the question mentions \"visitors\": use the exact table name \"visitor\" instead of \"visitors\".",
            "When filtering for membership level \"not higher than 4\": use the condition Level_of_membership <= 4 to include levels 4 and below, not membership_level > 4.",
            "When the question mentions \"visitors\", When filtering for membership level \"not higher than 4\", When computing average age: use the aggregate function avg(age) with lowercase syntax."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age) FROM visitors WHERE membership_level > 4;",
            "SELECT avg(age) FROM visitor WHERE Level_of_membership <= 4"
        ],
        "rule_sql": [
            "SELECT AVG(Age) FROM visitor WHERE Level_of_membership <= 4"
        ]
    },
    "414": {
        "db_id": "museum_visit",
        "question": "Find the name and membership level of the visitors whose membership level is higher than 4, and sort by their age from old to young.",
        "ground_truth": "SELECT name ,  Level_of_membership FROM visitor WHERE Level_of_membership  >  4 ORDER BY age DESC",
        "amends": [
            "Do use column alias `Level_of_membership` instead of `membership_level` in the SELECT list. Do reference table `visitor` instead of `visitors` in the FROM clause. Do change the ORDER BY direction to `DESC` instead of `ASC` for the `age` column. The amended query now correctly matches the intended behavior with the proper table name, column alias, and descending age ordering."
        ],
        "rules": [
            "When the question asks for \"membership level\": use the exact column token \"Level_of_membership\" from the visitor table.",
            "When referencing the table containing visitor information: use the exact table name \"visitor\" instead of \"visitors\".",
            "When sorting by age from old to young: order by the age column in descending direction (DESC) instead of ascending (ASC).",
            "When the question asks for \"membership level\", When referencing the table containing visitor information, When sorting by age from old to young, When selecting output columns: maintain the order of name followed by Level_of_membership as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, membership_level FROM visitors WHERE membership_level > 4 ORDER BY age ASC;",
            "SELECT Name, Level_of_membership FROM visitor WHERE Level_of_membership > 4 ORDER BY Age DESC;"
        ],
        "rule_sql": [
            "SELECT Name, Level_of_membership FROM visitor WHERE Level_of_membership > 4 ORDER BY Age DESC;"
        ]
    },
    "415": {
        "db_id": "museum_visit",
        "question": "Find the id and name of the museum that has the most staff members?",
        "ground_truth": "SELECT museum_id ,  name FROM museum ORDER BY num_of_staff DESC LIMIT 1",
        "amends": [
            "Do use column name `museum_id` instead of `id` and table name `museum` instead of `museums`. Do use column `num_of_staff` for ordering instead of `staff_count`. The amended query now correctly references the museum table structure and ordering column to match the intended behavior."
        ],
        "rules": [
            "When the question asks for museum id and name: use column \"museum_id\" for id and column \"name\" for name from table \"museum\".",
            "When the question asks for the museum with the most staff members: order rows by column \"num_of_staff\" in descending order and keep only the first row.",
            "When choosing identifier names: use exact column name \"museum_id\" instead of \"id\" and exact table name \"museum\" instead of \"museums\".",
            "When the question asks for museum id and name, When the question asks for the museum with the most staff members, When choosing identifier names, When ordering by staff count: use exact column name \"num_of_staff\" instead of \"staff_count\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, name FROM museums ORDER BY staff_count DESC LIMIT 1;",
            "SELECT Museum_ID, Name FROM museum ORDER BY Num_of_Staff DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT museum_id, name FROM museum ORDER BY num_of_staff DESC LIMIT 1;"
        ]
    },
    "416": {
        "db_id": "museum_visit",
        "question": "Find the average number of staff working for the museums that were open before 2009.",
        "ground_truth": "SELECT avg(num_of_staff) FROM museum WHERE open_year  <  2009",
        "amends": [
            "Do use table name `museum` instead of `museums` and column name `num_of_staff` instead of `staff_count` for the aggregate function. Do use column `open_year` instead of `year_opened` in the WHERE filter condition. Do use lowercase `avg` instead of uppercase `AVG` for the aggregate function. The amended query now correctly calculates the average number of staff from the museum table for institutions opened before 2009."
        ],
        "rules": [
            "When the question mentions \"museums\": use the exact table name \"museum\" instead of \"museums\".",
            "When counting staff for museums: use the exact column name \"num_of_staff\" instead of \"staff_count\" for the aggregate function.",
            "When filtering by opening year before 2009: use the exact column name \"open_year\" instead of \"year_opened\" in the filter condition.",
            "When the question mentions \"museums\", When counting staff for museums, When filtering by opening year before 2009, When calculating the average: use lowercase \"avg\" instead of uppercase \"AVG\" for the aggregate function."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(staff_count) FROM museums WHERE year_opened < 2009;",
            "SELECT avg(Num_of_Staff) FROM museum WHERE Open_Year < '2009'"
        ],
        "rule_sql": [
            "SELECT AVG(Num_of_Staff) FROM museum WHERE Open_Year < '2009';"
        ]
    },
    "417": {
        "db_id": "museum_visit",
        "question": "What are the opening year and staff number of the museum named Plaza Museum?",
        "ground_truth": "SELECT Num_of_Staff ,  Open_Year FROM museum WHERE name  =  'Plaza Museum'",
        "amends": [
            "Do use column aliases `Num_of_Staff` and `Open_Year` instead of the original column names `staff_number` and `opening_year`. Do reference the table as `museum` instead of `museums` while maintaining the same `WHERE` filter condition `name = 'Plaza Museum'`. The amended query now correctly matches the RIGHT_SQL's behavior with the proper column selection and table reference.",
            "Do reverse the column order by selecting `Num_of_Staff, Open_Year` instead of `Open_Year, Num_of_Staff`. Do use lowercase `name` in the WHERE clause instead of uppercase `Name` while maintaining the same filter condition `= 'Plaza Museum'`. The amended query now matches RIGHT_SQL's behavior with identical column output and filtering logic."
        ],
        "rules": [
            "When the question asks about \"opening year\" and \"staff number\": use the exact column aliases \"Num_of_Staff\" and \"Open_Year\" instead of the original column names.",
            "When referencing the museums table: use the exact table name \"museum\" instead of \"museums\".",
            "When the question asks about \"opening year\" and \"staff number\", When referencing the museums table, When filtering for the museum named \"Plaza Museum\": use the exact literal value 'Plaza Museum' with the condition name = 'Plaza Museum'.",
            "When the question asks for opening year and staff number of a museum: make sure the output order is Num_of_Staff, Open_Year instead of Open_Year, Num_of_Staff.",
            "When filtering by museum name: use lowercase name in the WHERE clause instead of uppercase Name while maintaining the exact filter condition = 'Plaza Museum'.",
            "When the question asks for opening year and staff number of a museum, When filtering by museum name, When handling text literals: preserve the exact case, spacing, and punctuation of 'Plaza Museum' without modification."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT opening_year, staff_number FROM museums WHERE name = 'Plaza Museum';",
            "SELECT Open_Year, Num_of_Staff FROM museum WHERE Name = 'Plaza Museum';",
            "SELECT Num_of_Staff, Open_Year FROM museum WHERE name = 'Plaza Museum'"
        ],
        "rule_sql": [
            "SELECT Num_of_Staff, Open_Year FROM museum WHERE name = 'Plaza Museum'"
        ]
    },
    "418": {
        "db_id": "museum_visit",
        "question": "find the names of museums which have more staff than the minimum staff number of all museums opened after 2010.",
        "ground_truth": "SELECT name FROM museum WHERE num_of_staff  >  (SELECT min(num_of_staff) FROM museum WHERE open_year  >  2010)",
        "amends": [
            "Do reference table `museum` instead of `museums` in both the main query and subquery. Do use column `num_of_staff` instead of `staff_count` for the staff count comparison. Do use column `open_year` instead of `year_opened` for the year filter in the subquery. The amended query now correctly filters museums where staff count exceeds the minimum staff count of museums opened after 2010, matching the intended behavior."
        ],
        "rules": [
            "When the question mentions \"museums\": use the exact table name \"museum\" instead of \"museums\".",
            "When the question mentions \"staff\" count: use the exact column name \"num_of_staff\" for staff count comparison.",
            "When the question mentions \"opened after 2010\": use the exact column name \"open_year\" for year filter and compare with literal value 2010.",
            "When the question mentions \"museums\", When the question mentions \"staff\" count, When the question mentions \"opened after 2010\", When comparing staff counts: ensure the main query compares \"num_of_staff\" against the minimum \"num_of_staff\" from museums opened after 2010."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM museums WHERE staff_count > (SELECT MIN(staff_count) FROM museums WHERE year_opened > 2010);",
            "SELECT Name FROM museum WHERE Num_of_Staff > (SELECT MIN(Num_of_Staff) FROM museum WHERE Open_Year > '2010')"
        ],
        "rule_sql": [
            "SELECT Name FROM museum WHERE Num_of_Staff > (SELECT MIN(Num_of_Staff) FROM museum WHERE Open_Year > '2010');"
        ]
    },
    "419": {
        "db_id": "museum_visit",
        "question": "find the id, name and age for visitors who visited some museums more than once.",
        "ground_truth": "SELECT t1.id ,  t1.name ,  t1.age FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id GROUP BY t1.id HAVING count(*)  >  1",
        "amends": [
            "Do use explicit table aliases `t1` and `t2` instead of bare table names. Do join `visitor AS t1` with `visit AS t2` on `t1.id = t2.visitor_id` instead of using a subquery with `museum_id` filtering. Do group by `t1.id` instead of grouping by `visitor_id, museum_id` in the subquery. Do move the count condition to `HAVING count(*) > 1` instead of using `HAVING COUNT(*) > 1` in a subquery. Do remove the `museum_id` filter entirely instead of including it in the subquery condition. The amended query now correctly identifies visitors with multiple visits by joining directly between visitor and visit tables and grouping by visitor ID."
        ],
        "rules": [
            "When answering about \"visitors who visited some museums more than once\": make sure the output order: id, name, age.",
            "When combining visitor and visit tables: link rows where t1.id = t2.visitor_id and keep only matching pairs (inner match).",
            "When grouping by visitor: organize results by t1.id and compute requested aggregates per group.",
            "When counting visits per visitor: compute the number of rows using the canonical key t1.id and keep only groups where count(*) > 1.",
            "When answering about \"visitors who visited some museums more than once\", When combining visitor and visit tables, When grouping by visitor, When counting visits per visitor, When the question asks for \"id, name and age\": select exactly t1.id, t1.name, t1.age from the visitor table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, name, age FROM visitors WHERE museum_id IN (SELECT museum_id FROM visits GROUP BY visitor_id, museum_id HAVING COUNT(*) > 1);",
            "SELECT t1.ID, t1.Name, t1.Age\nFROM visitor AS t1\nJOIN visit AS t2 ON t1.ID = t2.visitor_ID\nGROUP BY t1.ID\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT t1.ID, t1.Name, t1.Age\nFROM visitor t1\nINNER JOIN visit t2 ON t1.ID = t2.visitor_ID\nGROUP BY t1.ID\nHAVING COUNT(*) > 1\nORDER BY t1.ID, t1.Name, t1.Age;"
        ]
    },
    "420": {
        "db_id": "museum_visit",
        "question": "What are the id, name and membership level of visitors who have spent the largest amount of money in total in all museum tickets?",
        "ground_truth": "SELECT t2.visitor_id ,  t1.name ,  t1.Level_of_membership FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id GROUP BY t2.visitor_id ORDER BY sum(t2.Total_spent) DESC LIMIT 1",
        "amends": [
            "Do select `t2.visitor_id`, `t1.name`, and `t1.Level_of_membership` instead of `v.id`, `v.name`, and `v.membership_level`. Do use table aliases `t1` for `visitor` and `t2` for `visit` instead of `v` for `visitors` and `t` for `tickets`. Do join `visit` table instead of `tickets` table. Do reference `t2.Total_spent` in the aggregate instead of `t.price`. Do order by `sum(t2.Total_spent) DESC` instead of `total_spent ASC`. Do remove the explicit `GROUP BY` clause for name and membership level instead of including them. The amended query now correctly identifies the highest spending visitor by joining the appropriate tables and using the correct spending column with descending order."
        ],
        "rules": [
            "When joining tables for visitor spending analysis: use table alias t1 for visitor table and t2 for visit table instead of v for visitors and t for tickets.",
            "When selecting visitor information: select t2.visitor_id, t1.name, and t1.Level_of_membership instead of v.id, v.name, and v.membership_level.",
            "When calculating total spending: reference t2.Total_spent in the aggregate instead of t.price.",
            "When ordering results by spending: order by sum(t2.Total_spent) DESC instead of total_spent ASC to find largest amounts.",
            "When joining tables for visitor spending analysis, When selecting visitor information, When calculating total spending, When ordering results by spending, When grouping results: remove the explicit GROUP BY clause for name and membership level instead of including them."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT v.id, v.name, v.membership_level, SUM(t.price) as total_spent\nFROM visitors v\nJOIN tickets t ON v.id = t.visitor_id\nGROUP BY v.id, v.name, v.membership_level\nORDER BY total_spent ASC\nLIMIT 1;",
            "SELECT t2.visitor_ID, t1.Name, t1.Level_of_membership\nFROM visitor t1\nJOIN visit t2 ON t1.ID = t2.visitor_ID\nGROUP BY t2.visitor_ID\nORDER BY SUM(t2.Total_spent) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t2.visitor_ID, t1.Name, t1.Level_of_membership\nFROM visitor t1\nJOIN visit t2 ON t1.ID = t2.visitor_ID\nORDER BY SUM(t2.Total_spent) DESC\nLIMIT 1;"
        ]
    },
    "421": {
        "db_id": "museum_visit",
        "question": "What are the id and name of the museum visited most times?",
        "ground_truth": "SELECT t2.Museum_ID ,  t1.name FROM museum AS t1 JOIN visit AS t2 ON t1.Museum_ID  =  t2.Museum_ID GROUP BY t2.Museum_ID ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `t2.Museum_ID` and `t1.name` instead of `museum_id` and `name`. Do join `museum AS t1` with `visit AS t2` on `t1.Museum_ID = t2.Museum_ID` instead of querying only the `museums` table. Do add `GROUP BY t2.Museum_ID` instead of omitting grouping. Do order by `count(*) DESC` instead of `visit_count DESC` to count actual visits. The amended query now correctly identifies the museum with the most visits by joining the museum and visit tables and counting occurrences."
        ],
        "rules": [
            "When answering about \"museum visited most times\": make sure the output order: t2.Museum_ID, t1.name",
            "When combining museum and visit tables: link rows where t1.Museum_ID = t2.Museum_ID and keep only matching pairs (inner match)",
            "When the question asks for \"most times\": rank rows by count(*) in descending direction and keep the first 1 row",
            "When counting visits: compute the number of rows using the canonical key t2.Museum_ID for grouping",
            "When answering about \"museum visited most times\", When combining museum and visit tables, When the question asks for \"most times\", When counting visits, When selecting museum identifier and name: use t2.Museum_ID and t1.name exactly as specified"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT museum_id, name FROM museums ORDER BY visit_count DESC LIMIT 1;",
            "SELECT t2.Museum_ID, t1.Name\nFROM museum AS t1\nJOIN visit AS t2 ON t1.Museum_ID = t2.Museum_ID\nGROUP BY t2.Museum_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t2.Museum_ID, t1.Name\nFROM museum t1\nINNER JOIN visit t2 ON t1.Museum_ID = t2.Museum_ID\nGROUP BY t2.Museum_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "422": {
        "db_id": "museum_visit",
        "question": "What is the name of the museum that had no visitor yet?",
        "ground_truth": "SELECT name FROM museum WHERE Museum_ID NOT IN (SELECT museum_id FROM visit)",
        "amends": [
            "Do reference table `museum` instead of `museums` in the FROM clause. Do use a subquery with `NOT IN` condition on `Museum_ID` instead of filtering by `visitor_count = 0`. Do check for absence of records in the `visit` table instead of relying on a potentially incorrect `visitor_count` column. The amended query now correctly identifies museums without any visits by checking the relationship table instead of using a direct count field that may not exist or be accurate."
        ],
        "rules": [
            "When the question asks about museums without visitors: use the table \"museum\" instead of \"museums\" in the FROM clause.",
            "When checking for museums with no visits: use a subquery with NOT IN condition on Museum_ID to check for absence of records in the \"visit\" table.",
            "When the question asks about museums without visitors, When checking for museums with no visits, When identifying museums without any visits: do not rely on a visitor_count column as it may not exist or be accurate; instead check the relationship table \"visit\" for missing Museum_ID references."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM museums WHERE visitor_count = 0;",
            "SELECT Name FROM museum WHERE Museum_ID NOT IN (SELECT Museum_ID FROM visit)"
        ],
        "rule_sql": [
            "SELECT Name FROM museum WHERE Museum_ID NOT IN (SELECT Museum_ID FROM visit)"
        ]
    },
    "423": {
        "db_id": "museum_visit",
        "question": "Find the name and age of the visitor who bought the most tickets at once.",
        "ground_truth": "SELECT t1.name ,  t1.age FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id ORDER BY t2.num_of_ticket DESC LIMIT 1",
        "amends": [
            "Do select `t1.name` and `t1.age` with explicit table aliases instead of just `name` and `age` without table qualification. Do add `FROM visitor AS t1 JOIN visit AS t2` with an explicit join instead of just `FROM visitors` as a single table. Do use join condition `ON t1.id = t2.visitor_id` to properly relate the tables instead of missing the join entirely. Do order by `t2.num_of_ticket DESC` from the joined visit table instead of `tickets_bought DESC` which doesn't exist in the schema. The amended query now correctly joins the visitor and visit tables to find the visitor with the most tickets purchased, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When selecting columns from multiple tables: always qualify column names with explicit table aliases like t1.name and t1.age instead of unqualified names.",
            "When combining visitor and visit information: join tables using visitor AS t1 JOIN visit AS t2 with the exact join condition t1.id = t2.visitor_id to properly relate the tables.",
            "When finding the visitor who bought the most tickets: order by t2.num_of_ticket DESC from the visit table instead of using non-existent columns like tickets_bought.",
            "When selecting columns from multiple tables, When combining visitor and visit information, When finding the visitor who bought the most tickets, When answering about the top visitor by ticket purchases: use LIMIT 1 to return only the single row with the highest number of tickets."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, age FROM visitors ORDER BY tickets_bought DESC LIMIT 1;",
            "SELECT t1.Name, t1.Age\nFROM visitor AS t1\nJOIN visit AS t2 ON t1.ID = t2.visitor_ID\nORDER BY t2.Num_of_Ticket DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t1.Name, t1.Age\nFROM visitor AS t1\nJOIN visit AS t2 ON t1.ID = t2.visitor_ID\nORDER BY t2.Num_of_Ticket DESC\nLIMIT 1;"
        ]
    },
    "424": {
        "db_id": "museum_visit",
        "question": "What are the average and maximum number of tickets bought in all visits?",
        "ground_truth": "SELECT avg(num_of_ticket) ,  max(num_of_ticket) FROM visit",
        "amends": [
            "Do use `avg(num_of_ticket)` and `max(num_of_ticket)` instead of `AVG(tickets_bought)` and `MIN(tickets_bought)` for the aggregate functions and column references. Do reference the `visit` table instead of `visits` as the data source. The amended query now correctly calculates the average and maximum number of tickets from the appropriate table and columns, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"average and maximum number of tickets bought in all visits\": use the exact column name \"num_of_ticket\" from the visit table for calculations.",
            "When computing the average number of tickets: calculate the average of the \"num_of_ticket\" column.",
            "When computing the maximum number of tickets: calculate the maximum value of the \"num_of_ticket\" column.",
            "When answering about \"average and maximum number of tickets bought in all visits\", When computing the average number of tickets, When computing the maximum number of tickets, When referencing the data source: use the table named \"visit\" (not \"visits\") as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(tickets_bought) as average_tickets, MIN(tickets_bought) as max_tickets FROM visits;",
            "SELECT AVG(Num_of_Ticket) AS average_tickets, MAX(Num_of_Ticket) AS maximum_tickets FROM visit;"
        ],
        "rule_sql": [
            "SELECT AVG(Num_of_Ticket) AS average_tickets, MAX(Num_of_Ticket) AS maximum_tickets FROM visit;"
        ]
    },
    "425": {
        "db_id": "museum_visit",
        "question": "What is the total ticket expense of the visitors whose membership level is 1?",
        "ground_truth": "SELECT sum(t2.Total_spent) FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id WHERE t1.Level_of_membership  =  1",
        "amends": [
            "Do use `sum(t2.Total_spent)` instead of `SUM(ticket_price)` for the aggregate calculation. Do join `visit AS t2` on `t1.id = t2.visitor_id` instead of querying only the `visitors` table. Do reference `t1.Level_of_membership` instead of `membership_level` in the WHERE filter condition. Do add the required table join structure instead of querying a single table. The amended query now correctly calculates total spending from the visit table for visitors with the specified membership level."
        ],
        "rules": [
            "When answering about \"total ticket expense of visitors whose membership level is 1\": make sure the output order: sum(t2.Total_spent).",
            "When the question mentions \"membership level is 1\": \"membership level\" actually means \"t1.Level_of_membership = 1\" in schema.",
            "When combining visitors and visit tables for shared entities: link rows where t1.id = t2.visitor_id exactly as shown in the amends; keep only matching pairs (inner match).",
            "When answering about \"total ticket expense of visitors whose membership level is 1\", When the question mentions \"membership level is 1\", When combining visitors and visit tables for shared entities, When calculating total expense: use sum(t2.Total_spent) instead of SUM(ticket_price) for the aggregate calculation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(ticket_price) FROM visitors WHERE membership_level = 1;",
            "SELECT SUM(t2.Total_spent) AS total_expense\nFROM visitor AS t1\nJOIN visit AS t2 ON t1.ID = t2.visitor_ID\nWHERE t1.Level_of_membership = 1"
        ],
        "rule_sql": [
            "SELECT SUM(t2.Total_spent) \nFROM visitor t1\nINNER JOIN visit t2 ON t1.ID = t2.visitor_ID\nWHERE t1.Level_of_membership = 1"
        ]
    },
    "426": {
        "db_id": "museum_visit",
        "question": "What is the name of the visitor who visited both a museum opened before 2009 and a museum opened after 2011?",
        "ground_truth": "SELECT t1.name FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id JOIN museum AS t3 ON t3.Museum_ID  =  t2.Museum_ID WHERE t3.open_year  <  2009 INTERSECT SELECT t1.name FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id JOIN museum AS t3 ON t3.Museum_ID  =  t2.Museum_ID WHERE t3.open_year  >  2011",
        "amends": [
            "Do use `INTERSECT` to find visitors who meet both conditions instead of `OR` with `GROUP BY/HAVING`. Do reference tables as `visitor`, `visit`, and `museum` instead of `visitors`, `visits`, and `museums`. Do join on `t3.Museum_ID = t2.Museum_ID` instead of `vi.museum_id = m.id`. Do filter on `t3.open_year < 2009` in the first branch and `t3.open_year > 2011` in the second branch instead of `m.opening_year < 2009 OR m.opening_year > 2011`. Do remove `GROUP BY v.id` and `HAVING COUNT(DISTINCT m.id) >= 2` instead of keeping them, as the INTERSECT approach correctly identifies visitors who visited museums in both time periods. Do select from separate query branches for each time period instead of a single query with OR logic. The amended query now correctly matches RIGHT_SQL's behavior using set intersection to find visitors who visited museums both before 2009 and after 2011."
        ],
        "rules": [
            "When the question asks for visitors who visited both museums opened before 2009 and museums opened after 2011: use INTERSECT to combine results from two separate query branches instead of OR logic with GROUP BY/HAVING.",
            "When referencing tables: use exact table names \"visitor\", \"visit\", and \"museum\" instead of \"visitors\", \"visits\", and \"museums\".",
            "When joining visit and museum tables: link rows where \"t3.Museum_ID = t2.Museum_ID\" exactly as specified.",
            "When filtering for museums opened before 2009: use condition \"t3.open_year < 2009\" in the first branch.",
            "When filtering for museums opened after 2011: use condition \"t3.open_year > 2011\" in the second branch.",
            "When the question asks for visitors who visited both museums opened before 2009 and museums opened after 2011, When referencing tables, When joining visit and museum tables, When filtering for museums opened before 2009, When filtering for museums opened after 2011, When using INTERSECT approach: remove GROUP BY and HAVING clauses as they are not needed for set intersection logic."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT v.name \nFROM visitors v\nJOIN visits vi ON v.id = vi.visitor_id\nJOIN museums m ON vi.museum_id = m.id\nWHERE m.opening_year < 2009 OR m.opening_year > 2011\nGROUP BY v.id\nHAVING COUNT(DISTINCT m.id) >= 2;",
            "SELECT v.Name\nFROM visitor v\nWHERE v.ID IN (\n    SELECT vi.visitor_ID\n    FROM visit vi\n    JOIN museum m ON vi.Museum_ID = m.Museum_ID\n    WHERE m.Open_Year < '2009'\n    INTERSECT\n    SELECT vi.visitor_ID\n    FROM visit vi\n    JOIN museum m ON vi.Museum_ID = m.Museum_ID\n    WHERE m.Open_Year > '2011'\n)"
        ],
        "rule_sql": [
            "SELECT t1.Name\nFROM visitor t1\nJOIN visit t2 ON t1.ID = t2.visitor_ID\nJOIN museum t3 ON t2.Museum_ID = t3.Museum_ID\nWHERE t3.Open_Year < 2009\nINTERSECT\nSELECT t1.Name\nFROM visitor t1\nJOIN visit t2 ON t1.ID = t2.visitor_ID\nJOIN museum t3 ON t2.Museum_ID = t3.Museum_ID\nWHERE t3.Open_Year > 2011"
        ]
    },
    "427": {
        "db_id": "museum_visit",
        "question": "Find the number of visitors who did not visit any museum opened after 2010.",
        "ground_truth": "SELECT count(*) FROM visitor WHERE id NOT IN (SELECT t2.visitor_id FROM museum AS t1 JOIN visit AS t2 ON t1.Museum_ID  =  t2.Museum_ID WHERE t1.open_year  >  2010)",
        "amends": [
            "Do reference the `visitor` table instead of `visitors` and use `id` instead of `visitor_id` for the main table. Do use an explicit join between `museum` and `visit` tables with `ON t1.Museum_ID = t2.Museum_ID` instead of nested subqueries. Do filter on `t1.open_year > 2010` instead of `year_opened > 2010` and reference `t2.visitor_id` in the subquery instead of just `visitor_id`. Do use proper table aliases `t1` and `t2` throughout the subquery instead of anonymous table references. The amended query now correctly identifies visitors who haven't visited museums opened after 2010 using proper table relationships and joins."
        ],
        "rules": [
            "When the question mentions \"visitors\": use the exact table name \"visitor\" instead of \"visitors\" and use the column \"id\" instead of \"visitor_id\" for the main table.",
            "When combining museum and visit tables: link rows where t1.Museum_ID = t2.Museum_ID using an explicit join instead of nested subqueries.",
            "When filtering museums by opening year after 2010: use the exact column name \"open_year\" instead of \"year_opened\" and filter with t1.open_year > 2010.",
            "When referencing visitor IDs in subqueries: use the exact column name \"t2.visitor_id\" with proper table alias instead of just \"visitor_id\".",
            "When the question mentions \"visitors\", When combining museum and visit tables, When filtering museums by opening year after 2010, When referencing visitor IDs in subqueries, When using table aliases: consistently use t1 for museum table and t2 for visit table throughout the subquery instead of anonymous references."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM visitors WHERE visitor_id NOT IN (SELECT visitor_id FROM visits WHERE museum_id IN (SELECT museum_id FROM museums WHERE year_opened > 2010))",
            "SELECT COUNT(*) \nFROM visitor \nWHERE ID NOT IN (\n    SELECT DISTINCT t2.visitor_ID \n    FROM museum t1 \n    JOIN visit t2 ON t1.Museum_ID = t2.Museum_ID \n    WHERE t1.Open_Year > '2010'\n)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM visitor \nWHERE ID NOT IN (\n    SELECT t2.visitor_ID \n    FROM museum t1 \n    JOIN visit t2 ON t1.Museum_ID = t2.Museum_ID \n    WHERE t1.Open_Year > '2010'\n)"
        ]
    },
    "428": {
        "db_id": "museum_visit",
        "question": "How many museums were opened after 2013 or before 2008?",
        "ground_truth": "SELECT count(*) FROM museum WHERE open_year  >  2013 OR open_year  <  2008",
        "amends": [
            "Do reference table `museum` instead of `museums` and use column `open_year` instead of `opened_year`. Do use `OR` operator instead of `AND` to correctly count records where the year is either greater than 2013 or less than 2008, instead of incorrectly using `AND` which would return no results since a year cannot be both greater than 2013 and less than 2008 simultaneously. The amended query now matches the intended behavior of counting museums opened either after 2013 or before 2008."
        ],
        "rules": [
            "When the question mentions \"museums\": use the exact table name \"museum\" instead of \"museums\".",
            "When the question mentions \"opened_year\": use the exact column name \"open_year\" instead of \"opened_year\".",
            "When the question mentions \"museums\", When the question mentions \"opened_year\", When the question asks for museums opened \"after 2013 or before 2008\": use OR operator to combine conditions open_year > 2013 OR open_year < 2008, not AND operator."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM museums WHERE opened_year > 2013 AND opened_year < 2008;",
            "SELECT COUNT(*) FROM museum WHERE Open_Year > '2013' OR Open_Year < '2008';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM museum WHERE Open_Year > 2013 OR Open_Year < 2008"
        ]
    },
    "429": {
        "db_id": "wta_1",
        "question": "Find the total number of players.",
        "ground_truth": "SELECT count(*) FROM players",
        "amends": [
            "Do use lowercase `count(*)` instead of uppercase `COUNT(*)` to maintain consistent function casing. The amended query now matches RIGHT_SQL's behavior with identical functionality."
        ],
        "rules": [
            "When counting entities: use lowercase function names like count(*) instead of uppercase COUNT(*) to maintain consistent function casing."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE team = 'Lakers';",
            "SELECT count(*) FROM players;"
        ],
        "rule_sql": [
            "select count(*) from players"
        ]
    },
    "430": {
        "db_id": "wta_1",
        "question": "How many players are there?",
        "ground_truth": "SELECT count(*) FROM players",
        "amends": [
            "Do select from `players` table instead of `teams` table. The amended query now correctly counts records from the players table as specified in the RIGHT_SQL."
        ],
        "rules": [
            "When answering about \"how many players\": make sure to count from the \"players\" table instead of the \"teams\" table.",
            "When answering about \"how many players\", When counting entities: use the canonical counting method for the specified entity table (players in this case)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM teams;",
            "SELECT COUNT(*) FROM players;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM players;"
        ]
    },
    "431": {
        "db_id": "wta_1",
        "question": "Find the total number of matches.",
        "ground_truth": "SELECT count(*) FROM matches",
        "amends": [
            "Do query the `matches` table instead of the `players` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the matches table rather than players."
        ],
        "rules": [
            "When answering about \"total number of matches\": query the \"matches\" table instead of the \"players\" table.",
            "When answering about \"total number of matches\", When counting records: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" for consistency."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM players;",
            "SELECT count(*) FROM matches;"
        ],
        "rule_sql": [
            "select count(*) from matches"
        ]
    },
    "432": {
        "db_id": "wta_1",
        "question": "Count the number of matches.",
        "ground_truth": "SELECT count(*) FROM matches",
        "amends": [
            "Do query the `matches` table instead of the `players` table. The amended query now correctly counts records from the matches table as specified in the RIGHT_SQL."
        ],
        "rules": [
            "When answering about \"matches\": query the \"matches\" table instead of the \"players\" table.",
            "When answering about \"matches\", When counting matches: count all records from the \"matches\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM players;",
            "SELECT COUNT(*) FROM matches;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM matches;"
        ]
    },
    "433": {
        "db_id": "wta_1",
        "question": "List the first name and birth date of all players from the country with code USA.",
        "ground_truth": "SELECT first_name ,  birth_date FROM players WHERE country_code  =  'USA'",
        "amends": [
            "Do use `'USA'` as the country code filter instead of `'CANADA'` in the WHERE clause. The amended query now correctly filters for players from the USA instead of Canada, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for players from the country with code USA: use the exact literal 'USA' (not 'CANADA') for the country_code filter.",
            "When the question asks for players from the country with code USA, When selecting player information: include both first_name and birth_date columns in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, birth_date FROM players WHERE country_code = 'CANADA';",
            "SELECT first_name, birth_date FROM players WHERE country_code = 'USA';"
        ],
        "rule_sql": [
            "SELECT first_name, birth_date FROM players WHERE country_code = 'USA';"
        ]
    },
    "434": {
        "db_id": "wta_1",
        "question": "What are the first names and birth dates of players from the USA?",
        "ground_truth": "SELECT first_name ,  birth_date FROM players WHERE country_code  =  'USA'",
        "amends": [
            "Do use `country_code` instead of `country` in the WHERE filter. Do filter for `'USA'` instead of `'Canada'` as the country condition. The amended query now correctly filters by country_code for USA instead of using country for Canada."
        ],
        "rules": [
            "When the question mentions \"USA\": use the exact literal value 'USA' for filtering.",
            "When filtering by country: use the column \"country_code\" instead of \"country\" from the players table.",
            "When the question mentions \"USA\", When filtering by country, When answering about players from the USA: make sure the output order: first_name, birth_date."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, birth_date FROM players WHERE country = 'Canada';",
            "SELECT first_name, birth_date FROM players WHERE country_code = 'USA';"
        ],
        "rule_sql": [
            "SELECT first_name, birth_date FROM players WHERE country_code = 'USA' ORDER BY first_name, birth_date;"
        ]
    },
    "435": {
        "db_id": "wta_1",
        "question": "Find the average age of losers and winners of all matches.",
        "ground_truth": "SELECT avg(loser_age) ,  avg(winner_age) FROM matches",
        "amends": [
            "Do select `avg(loser_age)` and `avg(winner_age)` instead of a single `AVG(age)` aggregate. Do remove the `WHERE result = 'loser' OR result = 'winner'` filter instead of keeping it, as the right query calculates separate averages for both loser and winner ages directly from the table columns without filtering. The amended query now correctly computes two distinct average values for loser_age and winner_age columns instead of attempting to average a single age column with conditional filtering, matching the right SQL's behavior."
        ],
        "rules": [
            "When calculating average age for both losers and winners: compute separate averages for \"loser_age\" and \"winner_age\" columns instead of a single aggregate.",
            "When the question asks for average age of both losers and winners: output both average values in the result without any filtering conditions.",
            "When calculating average age for both losers and winners, When the question asks for average age of both losers and winners, When handling match results: do not use any WHERE clause filtering based on result values like 'loser' or 'winner' since the required data is available directly in separate columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age) FROM matches WHERE result = 'loser' OR result = 'winner';",
            "SELECT AVG(loser_age) AS avg_loser_age, AVG(winner_age) AS avg_winner_age FROM matches"
        ],
        "rule_sql": [
            "SELECT AVG(loser_age) AS avg_loser_age, AVG(winner_age) AS avg_winner_age FROM matches;"
        ]
    },
    "436": {
        "db_id": "wta_1",
        "question": "What are the average ages of losers and winners across matches?",
        "ground_truth": "SELECT avg(loser_age) ,  avg(winner_age) FROM matches",
        "amends": [
            "Do use direct column references `avg(loser_age)` and `avg(winner_age)` instead of calculating averages with `CASE` statements that check `m.winner_id = p.player_id` and `m.loser_id = p.player_id`. Do remove the `JOIN players p` clause entirely instead of joining on `m.winner_id = p.player_id OR m.loser_id = p.player_id` since the right query operates solely on the matches table without player data. Do query from only the `matches` table instead of joining with the `players` table, indicating the original query incorrectly attempted to access player age data that isn't needed for this aggregation. The amended query now correctly calculates averages from existing match data columns rather than attempting to join with unrelated player information."
        ],
        "rules": [
            "When calculating average ages of losers and winners across matches: use direct column references \"avg(loser_age)\" and \"avg(winner_age)\" instead of CASE statements that check player IDs.",
            "When the question asks for average ages from match data: operate solely on the \"matches\" table without joining to the \"players\" table.",
            "When calculating average ages of losers and winners across matches, When the question asks for average ages from match data, When aggregating match statistics: use the existing \"loser_age\" and \"winner_age\" columns in the \"matches\" table rather than attempting to access player age data through joins."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    AVG(CASE WHEN m.winner_id = p.player_id THEN p.age ELSE NULL END) AS avg_winner_age,\n    AVG(CASE WHEN m.loser_id = p.player_id THEN p.age ELSE NULL END) AS avg_loser_age\nFROM matches m\nJOIN players p ON m.winner_id = p.player_id OR m.loser_id = p.player_id",
            "SELECT AVG(loser_age) AS avg_loser_age, AVG(winner_age) AS avg_winner_age FROM matches;"
        ],
        "rule_sql": [
            "SELECT AVG(loser_age) AS avg_loser_age, AVG(winner_age) AS avg_winner_age FROM matches;"
        ]
    },
    "437": {
        "db_id": "wta_1",
        "question": "Find the average rank of winners in all matches.",
        "ground_truth": "SELECT avg(winner_rank) FROM matches",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(winner_rank) FROM matches WHERE winner_rank IS NOT NULL;"
        ],
        "rule_sql": [
            "SELECT AVG(winner_rank) AS average_winner_rank FROM matches WHERE winner_rank IS NOT NULL;"
        ]
    },
    "438": {
        "db_id": "wta_1",
        "question": "What is the average rank for winners in all matches?",
        "ground_truth": "SELECT avg(winner_rank) FROM matches",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(winner_rank) FROM matches WHERE winner_rank IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT AVG(winner_rank) AS average_winner_rank FROM matches WHERE winner_rank IS NOT NULL;"
        ]
    },
    "439": {
        "db_id": "wta_1",
        "question": "Find the highest rank of losers in all matches.",
        "ground_truth": "SELECT min(loser_rank) FROM matches",
        "amends": [
            "Do use the `min` aggregate function instead of `max` to calculate the minimum value. Do reference the `loser_rank` column instead of `winner_rank` to analyze the losing player's ranking rather than the winner's ranking. The amended query now correctly identifies the minimum loser rank from the matches table, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for the \"highest rank of losers\": use the \"loser_rank\" column from the matches table instead of \"winner_rank\" to analyze losing players.",
            "When the question asks for the \"highest rank of losers\", When finding the highest rank (which means the numerically smallest rank value): use the minimum aggregate function instead of maximum to calculate the smallest rank value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(winner_rank) FROM matches;",
            "SELECT MIN(loser_rank) AS highest_rank_of_losers FROM matches;"
        ],
        "rule_sql": [
            "SELECT MIN(loser_rank) AS highest_rank_of_losers FROM matches WHERE loser_rank IS NOT NULL;"
        ]
    },
    "440": {
        "db_id": "wta_1",
        "question": "What is the best rank of losers across all matches?",
        "ground_truth": "SELECT min(loser_rank) FROM matches",
        "amends": [
            "Do use the `min` aggregate function on `loser_rank` instead of the `max` aggregate function on `winner_rank`."
        ],
        "rules": [
            "When the question asks for the \"best rank of losers\": use the minimum value of \"loser_rank\" instead of the maximum value of \"winner_rank\".",
            "When the question asks for the \"best rank of losers\", When computing the best (lowest) rank: apply the min aggregate function to the exact column token \"loser_rank\" from the matches table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(winner_rank) FROM matches;",
            "SELECT MIN(loser_rank) AS best_rank FROM matches WHERE loser_rank IS NOT NULL;"
        ],
        "rule_sql": [
            "SELECT MIN(loser_rank) AS best_rank_of_losers FROM matches;"
        ]
    },
    "441": {
        "db_id": "wta_1",
        "question": "find the number of distinct country codes of all players.",
        "ground_truth": "SELECT count(DISTINCT country_code) FROM players",
        "amends": [
            "Do use `count(DISTINCT country_code)` instead of `COUNT(country_code)` to count unique country codes rather than counting all non-null values, which eliminates duplicate country codes from the count. The amended query now matches RIGHT_SQL's behavior by providing a distinct count of country codes."
        ],
        "rules": [
            "When the question asks for \"distinct country codes\": compute the number of unique values of the exact token \"country_code\" rather than counting all non-null values.",
            "When the question asks for \"distinct country codes\", When counting distinct values: use the exact identifier \"country_code\" without quotes as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(country_code) FROM players;",
            "SELECT COUNT(DISTINCT country_code) FROM players;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT country_code) FROM players;"
        ]
    },
    "442": {
        "db_id": "wta_1",
        "question": "How many distinct countries do players come from?",
        "ground_truth": "SELECT count(DISTINCT country_code) FROM players",
        "amends": [
            "Do `count(DISTINCT country_code)` instead of `COUNT(*)` to count distinct country codes rather than all rows. Do add the `country_code` column reference instead of omitting it to specify what to count distinctly. The amended query now correctly counts distinct country codes instead of total player records, matching the intended behavior."
        ],
        "rules": [
            "When counting distinct countries: use the exact column token \"country_code\" from the players table to count distinct values.",
            "When the question asks for \"distinct countries\": compute the number of unique values in the \"country_code\" column rather than counting all rows.",
            "When counting distinct countries, When the question asks for \"distinct countries\", When the question mentions \"countries\": \"countries\" actually means \"country_code\" in the players schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM players;",
            "SELECT COUNT(DISTINCT country_code) FROM players;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT country_code) FROM players;"
        ]
    },
    "443": {
        "db_id": "wta_1",
        "question": "Find the number of distinct name of losers.",
        "ground_truth": "SELECT count(DISTINCT loser_name) FROM matches",
        "amends": [
            "Do use `count(DISTINCT loser_name)` instead of `COUNT(name)` to count distinct values rather than all non-null values. Do query from `matches` table instead of `losers` table to access the correct data source. Do remove the unnecessary table reference `losers` instead of keeping it. The amended query now correctly counts distinct loser names from the matches table instead of counting all names from an incorrect table."
        ],
        "rules": [
            "When the question asks for \"distinct name of losers\": use \"loser_name\" from the \"matches\" table to count distinct values.",
            "When counting distinct values: use count(DISTINCT loser_name) instead of COUNT(name) to ensure only unique values are counted.",
            "When accessing data for losers: query from the \"matches\" table instead of the \"losers\" table to use the correct data source.",
            "When the question asks for \"distinct name of losers\", When counting distinct values, When accessing data for losers, When the question mentions \"losers\": this refers to the \"loser_name\" column in the \"matches\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(name) FROM losers;",
            "SELECT COUNT(DISTINCT loser_name) FROM matches;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT loser_name) FROM matches;"
        ]
    },
    "444": {
        "db_id": "wta_1",
        "question": "How many different loser names are there?",
        "ground_truth": "SELECT count(DISTINCT loser_name) FROM matches",
        "amends": [
            "Do count `DISTINCT loser_name` instead of counting `winner_name` without distinct, which changes both the column being aggregated and adds deduplication to count unique values rather than all occurrences. This amendment shifts the focus from counting winner occurrences to counting distinct loser names, fundamentally altering the query's purpose to measure unique losers rather than total winner entries."
        ],
        "rules": [
            "When the question asks for \"different loser names\": count the number of unique values in the exact column \"loser_name\" using DISTINCT aggregation.",
            "When counting entities: use the exact column name \"loser_name\" rather than \"winner_name\" to match the question's focus on losers rather than winners.",
            "When the question asks for \"different loser names\", When counting entities, When the question asks for \"how many different\": ensure the count operation includes deduplication to count unique values rather than total occurrences."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(winner_name) FROM matches;",
            "SELECT COUNT(DISTINCT loser_name) FROM matches;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT loser_name) FROM matches;"
        ]
    },
    "445": {
        "db_id": "wta_1",
        "question": "Find the name of tourney that has more than 10 matches.",
        "ground_truth": "SELECT tourney_name FROM matches GROUP BY tourney_name HAVING count(*)  >  10",
        "amends": [
            "Do use `GROUP BY tourney_name` with `HAVING count(*) > 10` instead of filtering `matches > 10` in the `WHERE` clause. Do query from the `matches` table instead of the `tourneys` table. Do aggregate with `count(*)` instead of directly comparing the `matches` column. The amended query now correctly identifies tournaments with more than 10 matches by counting actual match records rather than relying on a potentially incorrect stored count value."
        ],
        "rules": [
            "When answering about \"tournaments with more than 10 matches\": count the number of matches per tournament using count(*) from the matches table instead of using a matches column from tourneys table.",
            "When the question asks for tournaments with more than 10 matches: group by tourney_name and filter groups having count(*) > 10.",
            "When answering about \"tournaments with more than 10 matches\", When the question asks for tournaments with more than 10 matches, When querying for tournament information based on match counts: use the matches table as the primary data source rather than the tourneys table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT tourney_name FROM tourneys WHERE matches > 10",
            "SELECT tourney_name FROM matches GROUP BY tourney_name HAVING COUNT(*) > 10"
        ],
        "rule_sql": [
            "SELECT tourney_name FROM matches GROUP BY tourney_name HAVING COUNT(*) > 10;"
        ]
    },
    "446": {
        "db_id": "wta_1",
        "question": "What are the names of tournaments that have more than 10 matches?",
        "ground_truth": "SELECT tourney_name FROM matches GROUP BY tourney_name HAVING count(*)  >  10",
        "amends": [
            "Do select `tourney_name` instead of `tournament_name` and use `GROUP BY` with `HAVING count(*) > 10` instead of `WHERE COUNT(matches) > 10`. Do query from `matches` table instead of `tournaments` table and remove the incorrect aggregate function usage in the WHERE clause. The amended query now correctly groups matches by tournament name and filters for tournaments with more than 10 matches using proper HAVING clause syntax, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for tournament names: use the exact column name \"tourney_name\" instead of \"tournament_name\" from the matches table.",
            "When counting matches per tournament: group by \"tourney_name\" and count all rows using count(*) to get the total number of matches per tournament.",
            "When filtering for tournaments with more than 10 matches: use a having condition count(*) > 10 after grouping by \"tourney_name\".",
            "When the question asks for tournament names, When counting matches per tournament, When filtering for tournaments with more than 10 matches, When querying about tournament matches: use the matches table as the primary source instead of the tournaments table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT tournament_name FROM tournaments WHERE COUNT(matches) > 10",
            "SELECT tourney_name FROM matches GROUP BY tourney_name HAVING COUNT(*) > 10"
        ],
        "rule_sql": [
            "SELECT tourney_name FROM matches GROUP BY tourney_name HAVING COUNT(*) > 10"
        ]
    },
    "447": {
        "db_id": "wta_1",
        "question": "List the names of all winners who played in both 2013 and 2016.",
        "ground_truth": "SELECT winner_name FROM matches WHERE YEAR  =  2013 INTERSECT SELECT winner_name FROM matches WHERE YEAR  =  2016",
        "amends": [
            "Do use `INTERSECT` to find common winners across years instead of incorrect `AND` logic that cannot match both conditions simultaneously. Do query from `matches` table instead of non-existent `winners` table. Do select `winner_name` column instead of `name`. Do use separate queries for each year condition with proper `YEAR = 2013` and `YEAR = 2016` filters instead of the impossible `year = 2013 AND year = 2016` predicate. The amended query now correctly identifies winners who won in both 2013 and 2016 by intersecting the results from two separate year queries."
        ],
        "rules": [
            "When the question asks for winners who played in both 2013 and 2016: use INTERSECT to find common winners across years instead of AND logic that cannot match both conditions simultaneously.",
            "When querying about winners: use the \"matches\" table instead of non-existent \"winners\" table.",
            "When selecting winner names: use \"winner_name\" column instead of \"name\".",
            "When the question asks for winners who played in both 2013 and 2016, When querying about winners, When selecting winner names, When filtering by year: use separate queries for each year condition with proper \"YEAR = 2013\" and \"YEAR = 2016\" filters instead of the impossible \"year = 2013 AND year = 2016\" predicate."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM winners WHERE year = 2013 AND year = 2016;",
            "SELECT winner_name FROM matches WHERE year = 2013\nINTERSECT\nSELECT winner_name FROM matches WHERE year = 2016"
        ],
        "rule_sql": [
            "SELECT winner_name FROM matches WHERE year = 2013\nINTERSECT\nSELECT winner_name FROM matches WHERE year = 2016"
        ]
    },
    "448": {
        "db_id": "wta_1",
        "question": "What are the names of players who won in both 2013 and 2016?",
        "ground_truth": "SELECT winner_name FROM matches WHERE YEAR  =  2013 INTERSECT SELECT winner_name FROM matches WHERE YEAR  =  2016",
        "amends": [
            "Do use `INTERSECT` to find common `winner_name` values instead of using `AND` with the same column which would always return empty results. Do query from the `matches` table instead of the `players` table to access the correct data source. Do add a second query with `YEAR = 2016` instead of trying to filter for both years simultaneously in a single condition. Do remove the incorrect `year = 2013 AND year = 2016` predicate instead of keeping the logically impossible condition. The amended query now correctly identifies players who won matches in both 2013 and 2016 by using set intersection instead of the contradictory WHERE clause."
        ],
        "rules": [
            "When the question asks for players who won in multiple specific years: use set intersection to find common winner_name values instead of using AND conditions on the same year column.",
            "When answering about match winners: query from the \"matches\" table instead of the \"players\" table to access the correct data source.",
            "When filtering for specific years like 2013 and 2016: create separate queries for each year condition instead of trying to filter for both years simultaneously in a single condition.",
            "When identifying winners in a particular year: use the exact literal values \"2013\" and \"2016\" as shown in the question.",
            "When the question asks for players who won in multiple specific years, When answering about match winners, When filtering for specific years like 2013 and 2016, When identifying winners in a particular year, When selecting player names from match results: use the exact column token \"winner_name\" from the matches table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM players WHERE year = 2013 AND year = 2016;",
            "SELECT winner_name FROM matches WHERE year = 2013\nINTERSECT\nSELECT winner_name FROM matches WHERE year = 2016;"
        ],
        "rule_sql": [
            "SELECT winner_name\nFROM matches\nWHERE year = 2013\nINTERSECT\nSELECT winner_name\nFROM matches\nWHERE year = 2016;"
        ]
    },
    "449": {
        "db_id": "wta_1",
        "question": "List the number of all matches who played in years of 2013 or 2016.",
        "ground_truth": "SELECT count(*) FROM matches WHERE YEAR  =  2013 OR YEAR  =  2016",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE year = 2013 OR year = 2016;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM matches WHERE year IN (2013, 2016)"
        ]
    },
    "450": {
        "db_id": "wta_1",
        "question": "How many matches were played in 2013 or 2016?",
        "ground_truth": "SELECT count(*) FROM matches WHERE YEAR  =  2013 OR YEAR  =  2016",
        "amends": [
            "Do use `OR` operator between year conditions instead of `AND` operator, changing `year = 2013 AND year = 2016` to `YEAR = 2013 OR YEAR = 2016` to correctly count matches from either 2013 or 2016 instead of incorrectly requiring both conditions simultaneously. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for matches in multiple years using \"or\" logic: use OR operator between year conditions instead of AND operator to include matches from either year.",
            "When counting matches: count all rows that satisfy the year condition using COUNT(*).",
            "When the question asks for matches in multiple years using \"or\" logic, When counting matches, When handling year literals: use exact numeric values 2013 and 2016 without quotes as shown in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE year = 2013 AND year = 2016;",
            "SELECT COUNT(*) FROM matches WHERE year = 2013 OR year = 2016"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM matches WHERE year = 2013 OR year = 2016"
        ]
    },
    "451": {
        "db_id": "wta_1",
        "question": "What are the country code and first name of the players who won in both tourney WTA Championships and Australian Open?",
        "ground_truth": "SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'WTA Championships' INTERSECT SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'Australian Open'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.country_code, p.first_name \nFROM players p\nJOIN matches m1 ON p.player_id = m1.winner_id\nJOIN matches m2 ON p.player_id = m2.winner_id\nWHERE m1.tourney_name = 'WTA Championships' \nAND m2.tourney_name = 'Australian Open';"
        ],
        "rule_sql": [
            "SELECT DISTINCT p.country_code, p.first_name\nFROM players p\nJOIN matches m ON p.player_id = m.winner_id\nWHERE m.tourney_name IN ('WTA Championships', 'Australian Open')\nGROUP BY p.player_id, p.country_code, p.first_name\nHAVING COUNT(DISTINCT m.tourney_name) = 2;"
        ]
    },
    "452": {
        "db_id": "wta_1",
        "question": "What are the first names and country codes for players who won both the WTA Championships and the Australian Open?",
        "ground_truth": "SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'WTA Championships' INTERSECT SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'Australian Open'",
        "amends": [
            "Do use `JOIN matches` on `player_id = winner_id` instead of querying only the `players` table. Do filter with `tourney_name = 'WTA Championships'` and `tourney_name = 'Australian Open'` in separate queries instead of using `LIKE` on a single column. Do use `INTERSECT` to find players who won both tournaments instead of trying to match both patterns in the same row. Do include proper table aliases `T1` and `T2` instead of unaliased references. Do query from the matches table to find tournament winners instead of relying on a text search in the players table. The amended query now correctly identifies players who have won both the WTA Championships and Australian Open tournaments by joining with match results.",
            "Do remove `DISTINCT` instead of keeping it. Do use `INTERSECT` instead of joining the same table twice with different conditions. Do change the join condition to use `T1.player_id = T2.winner_id` consistently instead of mixing table aliases. Do move the tourney name filters to separate `WHERE` clauses for each `INTERSECT` branch instead of combining them in a single query with multiple joins. Do restructure the query to find players who participated in both tournaments using set intersection logic instead of self-joining the matches table. The amended query now correctly identifies players who won matches in both the WTA Championships and Australian Open tournaments using proper set operations.",
            "Do use consistent table aliases `T1` for players and `T2` for matches instead of mixing `p` and `T1`/`T2` aliases. Do maintain the same column order `country_code, first_name` in both INTERSECT clauses instead of having `first_name, country_code` in the wrong query. Do use identical table aliasing patterns in both parts of the INTERSECT operation instead of having inconsistent alias usage between the two SELECT statements. The amended query now correctly uses consistent aliasing and column ordering throughout both INTERSECT components, ensuring proper set comparison behavior.",
            "Do use `JOIN` with `players AS T1` and `matches AS T2` on `T1.player_id = T2.winner_id` instead of a subquery with `INTERSECT`. Do include `T1.country_code` in the `SELECT` list instead of omitting it from the first query. Do filter directly in the `WHERE` clause with `T2.tourney_name = 'WTA Championships'` and `T2.tourney_name = 'Australian Open'` instead of using separate subqueries. Do apply `INTERSECT` between two complete `SELECT` statements that both return `country_code` and `first_name` instead of intersecting only `winner_id` values. The amended query now correctly finds players who won both tournaments by intersecting complete player records rather than just player IDs, matching the RIGHT_SQL's behavior.",
            "Do swap the column order in the SELECT list to `country_code, first_name` instead of `first_name, country_code` to ensure proper INTERSECT comparison semantics. The amended query now correctly identifies players who participated in both tournaments by maintaining consistent column ordering across both INTERSECT operands, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about players who won both WTA Championships and Australian Open: combine information from players table (T1) and matches table (T2) using player_id = winner_id to link tournament wins to players.",
            "When filtering for WTA Championships wins: use exact literal 'WTA Championships' for tourney_name column.",
            "When filtering for Australian Open wins: use exact literal 'Australian Open' for tourney_name column.",
            "When finding players who won both tournaments: use INTERSECT operation between the two separate tournament result sets instead of trying to match both patterns in the same row.",
            "When selecting output columns: include first_name and country_code from the players table (T1).",
            "When answering about players who won both WTA Championships and Australian Open, When filtering for WTA Championships wins, When filtering for Australian Open wins, When finding players who won both tournaments, When selecting output columns, When combining tables: use inner matches where T1.player_id = T2.winner_id to ensure only players with tournament wins are considered.",
            "When answering about players who won both WTA Championships and Australian Open: use INTERSECT operation instead of joining the same table multiple times to find players present in both tournament winner sets.",
            "When the question mentions \"won both the WTA Championships and the Australian Open\": this means finding players who have winner records in both tournaments using exact tournament name literals 'WTA Championships' and 'Australian Open'.",
            "When combining player information from matches table: use consistent join condition T1.player_id = T2.winner_id to link players to their winning matches.",
            "When filtering for specific tournaments: apply separate WHERE clauses for each tournament condition (T1.tourney_name = 'WTA Championships' and T2.tourney_name = 'Australian Open') in the INTERSECT branches.",
            "When answering about players who won both WTA Championships and Australian Open, When the question mentions \"won both the WTA Championships and the Australian Open\", When combining player information from matches table, When filtering for specific tournaments, When selecting output columns: return first_name and country_code from the players table without using DISTINCT since INTERSECT inherently returns unique results.",
            "When answering about players who won both tournaments: use consistent table aliases with T1 for players and T2 for matches throughout both INTERSECT components.",
            "When producing output columns: maintain the column order as country_code, first_name in both SELECT statements of the INTERSECT operation.",
            "When combining tables for tournament wins: link players and matches using the exact key equality T1.player_id = T2.winner_id as shown in the schema.",
            "When answering about players who won both tournaments, When producing output columns, When combining tables for tournament wins, When filtering for specific tournaments: use exact string literals 'WTA Championships' and 'Australian Open' for the tourney_name column with correct case and spacing.",
            "When combining players and matches tables: link rows where T1.player_id equals T2.winner_id exactly as shown in the amends (T1.player_id = T2.winner_id) and keep only matching pairs (inner match).",
            "When the question asks for players who won both specific tournaments: filter matches where T2.tourney_name equals 'WTA Championships' and also filter matches where T2.tourney_name equals 'Australian Open' using exact string literals.",
            "When finding players who won both tournaments: use INTERSECT between two complete SELECT statements that both return T1.first_name and T1.country_code instead of intersecting only winner_id values.",
            "When combining players and matches tables, When the question asks for players who won both specific tournaments, When finding players who won both tournaments, When answering about players who won both tournaments: make sure the output order includes T1.first_name and T1.country_code.",
            "When using INTERSECT to find common results between two queries: ensure the column order in both SELECT clauses is identical, with country_code appearing before first_name.",
            "When using INTERSECT to find common results between two queries, When answering about players who won both specific tournaments: maintain consistent output column ordering (country_code, first_name) across both sides of the INTERSECT operation for proper comparison semantics."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, country_code \nFROM players \nWHERE tournament_wins LIKE '%WTA Championships%' \nAND tournament_wins LIKE '%Australian Open%';",
            "SELECT DISTINCT p.first_name, p.country_code\nFROM players p\nJOIN matches T1 ON p.player_id = T1.winner_id\nJOIN matches T2 ON p.player_id = T2.winner_id\nWHERE T1.tourney_name = 'WTA Championships'\nAND T2.tourney_name = 'Australian Open';",
            "SELECT p.first_name, p.country_code\nFROM players p\nJOIN matches T1 ON p.player_id = T1.winner_id\nWHERE T1.tourney_name = 'WTA Championships'\nINTERSECT\nSELECT p.first_name, p.country_code\nFROM players p\nJOIN matches T2 ON p.player_id = T2.winner_id\nWHERE T2.tourney_name = 'Australian Open'",
            "SELECT first_name, country_code\nFROM players\nWHERE player_id IN (\n    SELECT winner_id\n    FROM matches\n    WHERE tourney_name = 'WTA Championships'\n    INTERSECT\n    SELECT winner_id\n    FROM matches\n    WHERE tourney_name = 'Australian Open'\n)",
            "SELECT T1.first_name, T1.country_code\nFROM players AS T1\nJOIN matches AS T2 ON T1.player_id = T2.winner_id\nWHERE T2.tourney_name = 'WTA Championships'\nINTERSECT\nSELECT T1.first_name, T1.country_code\nFROM players AS T1\nJOIN matches AS T2 ON T1.player_id = T2.winner_id\nWHERE T2.tourney_name = 'Australian Open'",
            "SELECT T1.country_code, T1.first_name\nFROM players AS T1\nJOIN matches AS T2 ON T1.player_id = T2.winner_id\nWHERE T2.tourney_name = 'WTA Championships'\nINTERSECT\nSELECT T1.country_code, T1.first_name\nFROM players AS T1\nJOIN matches AS T2 ON T1.player_id = T2.winner_id\nWHERE T2.tourney_name = 'Australian Open'"
        ],
        "rule_sql": [
            "SELECT T1.country_code, T1.first_name\nFROM players T1\nINNER JOIN matches T2 ON T1.player_id = T2.winner_id\nWHERE T2.tourney_name = 'WTA Championships'\nINTERSECT\nSELECT T1.country_code, T1.first_name\nFROM players T1\nINNER JOIN matches T2 ON T1.player_id = T2.winner_id\nWHERE T2.tourney_name = 'Australian Open'"
        ]
    },
    "453": {
        "db_id": "wta_1",
        "question": "Find the first name and country code of the oldest player.",
        "ground_truth": "SELECT first_name ,  country_code FROM players ORDER BY birth_date LIMIT 1",
        "amends": [
            "Do order by `birth_date` instead of `age` in the ORDER BY clause. The amended query now matches the RIGHT_SQL's behavior by correctly sorting based on birth date rather than age."
        ],
        "rules": [
            "When the question asks for the \"oldest player\": use the \"birth_date\" column from the players table to determine age, ordering by birth_date in ascending order to find the earliest birth date.",
            "When the question asks for the \"oldest player\", When answering about \"first name and country code of the oldest player\": make sure the output order: first_name, country_code."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, country_code FROM players ORDER BY age ASC LIMIT 1;",
            "SELECT first_name, country_code FROM players ORDER BY birth_date ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT first_name, country_code FROM players ORDER BY birth_date ASC LIMIT 1;"
        ]
    },
    "454": {
        "db_id": "wta_1",
        "question": "What is the first name and country code of the oldest player?",
        "ground_truth": "SELECT first_name ,  country_code FROM players ORDER BY birth_date LIMIT 1",
        "amends": [
            "Do order by `birth_date` instead of `age` in the ORDER BY clause, as the correct logic requires sorting by birth date rather than age to achieve the intended result. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for the \"oldest player\": sort players by birth_date in ascending order (earliest birth date first) to find the oldest player.",
            "When ordering results to find the oldest player: use the \"birth_date\" column instead of \"age\" for accurate chronological ordering.",
            "When the question asks for the \"oldest player\", When ordering results to find the oldest player, When selecting output columns for player information: include \"first_name\" and \"country_code\" as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, country_code FROM players ORDER BY age ASC LIMIT 1;",
            "SELECT first_name, country_code FROM players ORDER BY birth_date ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT first_name, country_code FROM players ORDER BY birth_date ASC LIMIT 1;"
        ]
    },
    "455": {
        "db_id": "wta_1",
        "question": "List the first and last name of all players in the order of birth date.",
        "ground_truth": "SELECT first_name ,  last_name FROM players ORDER BY birth_date",
        "amends": [
            "Do order by `birth_date` instead of `name` in the ORDER BY clause, as the original `name` column does not exist in the SELECT list or table schema. This amendment ensures proper sorting by the available birth_date field rather than attempting to sort by a non-existent column, which would cause an error. The amended query now correctly sorts players by their birth date instead of referencing an invalid column name."
        ],
        "rules": [
            "When the question asks to list players in order of birth date: sort the results by the \"birth_date\" column from the players table.",
            "When the question mentions \"birth date\": this corresponds to the exact column \"birth_date\" in the players table.",
            "When the question asks to list players in order of birth date, When the question mentions \"birth date\", When ordering results: use the exact column name \"birth_date\" as shown in the schema, not alternative names like \"name\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM players ORDER BY name;",
            "SELECT first_name, last_name FROM players ORDER BY birth_date;"
        ],
        "rule_sql": [
            "SELECT first_name, last_name FROM players ORDER BY birth_date;"
        ]
    },
    "456": {
        "db_id": "wta_1",
        "question": "What are the full names of all players, sorted by birth date?",
        "ground_truth": "SELECT first_name ,  last_name FROM players ORDER BY birth_date",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM players ORDER BY birth_date DESC;"
        ],
        "rule_sql": [
            "SELECT first_name, last_name FROM players ORDER BY birth_date;"
        ]
    },
    "457": {
        "db_id": "wta_1",
        "question": "List the first and last name of all players who are left / L hand in the order of birth date.",
        "ground_truth": "SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date",
        "amends": [
            "Do filter on `hand = 'L'` instead of `hand = 'right'` in the WHERE clause, changing the condition value from right-handed to left-handed players. The amended query now correctly selects left-handed players instead of right-handed players while maintaining the same column selection and ordering by birth_date."
        ],
        "rules": [
            "When filtering players by handedness: use the exact literal 'L' for left-handed players instead of 'right'",
            "When ordering results by birth date: sort the output in ascending order of birth_date",
            "When filtering players by handedness, When ordering results by birth date, When selecting player information: include both first_name and last_name columns in the output"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM players WHERE hand = 'right' ORDER BY birth_date;",
            "SELECT first_name, last_name FROM players WHERE hand = 'L' ORDER BY birth_date;"
        ],
        "rule_sql": [
            "SELECT first_name, last_name FROM players WHERE hand = 'L' ORDER BY birth_date ASC;"
        ]
    },
    "458": {
        "db_id": "wta_1",
        "question": "What are the full names of all left handed players, in order of birth date?",
        "ground_truth": "SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date",
        "amends": [
            "Do reference column `hand` instead of `handedness` in the WHERE clause. Do use filter value `'L'` instead of `'right'` for the hand condition. Do remove `DESC` from the ORDER BY clause instead of keeping descending order. The amended query now correctly filters for left-handed players and sorts by birth date in ascending order, matching the intended behavior."
        ],
        "rules": [
            "When the question mentions \"left handed players\": filter rows where the exact column \"hand\" equals the exact literal 'L'.",
            "When ordering by birth date: sort rows in ascending order (earliest to latest) using the \"birth_date\" column.",
            "When the question mentions \"left handed players\", When ordering by birth date, When selecting player names: output both \"first_name\" and \"last_name\" columns to get full names."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM players WHERE handedness = 'right' ORDER BY birth_date DESC;",
            "SELECT first_name, last_name FROM players WHERE hand = 'L' ORDER BY birth_date;"
        ],
        "rule_sql": [
            "SELECT first_name, last_name FROM players WHERE hand = 'L' ORDER BY birth_date ASC;"
        ]
    },
    "459": {
        "db_id": "wta_1",
        "question": "Find the first name and country code of the player who did the most number of tours.",
        "ground_truth": "SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT 1",
        "amends": [
            "Do add `rankings` table with `JOIN` on `players.player_id = rankings.player_id` instead of querying only the `players` table. Do reference `T2.tours` in the `ORDER BY` clause instead of `tours` which would be ambiguous. Do include table aliases `T1` and `T2` for clarity instead of using unqualified column names. Do maintain the `LIMIT 1` clause to return only the top result. The amended query now correctly joins player and ranking data to find the player with the highest number of tours.",
            "Do place `T1.country_code` before `T1.first_name` in the SELECT list instead of the reverse order. Do add the `AS` keyword for table aliases instead of omitting it. Do use consistent spacing around the equals operator in the JOIN condition instead of inconsistent spacing. The amended query now correctly matches the RIGHT_SQL's behavior with identical column ordering and proper syntax formatting."
        ],
        "rules": [
            "When answering about \"the player who did the most number of tours\": make sure the output order: first_name, country_code.",
            "When the question mentions \"tours\": \"tours\" actually means \"T2.tours in schema\".",
            "When the question mentions \"most number of tours\": rank rows by T2.tours in descending direction and keep the first 1 row.",
            "When combining players and rankings tables: link rows where players.player_id = rankings.player_id exactly as shown in the amends; keep only matching pairs (inner match).",
            "When answering about \"the player who did the most number of tours\", When the question mentions \"tours\", When the question mentions \"most number of tours\", When combining players and rankings tables, When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms.",
            "When answering about \"the first name and country code of the player who did the most number of tours\": make sure the output order: T1.country_code, T1.first_name",
            "When combining players and rankings tables for shared entities: link rows where T1.player_id = T2.player_id exactly as shown; keep only matching pairs (inner match)",
            "When answering about \"the first name and country code of the player who did the most number of tours\", When combining players and rankings tables for shared entities, When the question mentions \"most number of tours\": rank rows by T2.tours in descending order and keep the first 1 row"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, country_code FROM players ORDER BY tours DESC LIMIT 1;",
            "SELECT T1.first_name, T1.country_code\nFROM players T1\nJOIN rankings T2 ON T1.player_id = T2.player_id\nORDER BY T2.tours DESC\nLIMIT 1",
            "SELECT T1.country_code, T1.first_name\nFROM players AS T1\nJOIN rankings AS T2 ON T1.player_id = T2.player_id\nORDER BY T2.tours DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.country_code\nFROM players T1\nINNER JOIN rankings T2 ON T1.player_id = T2.player_id\nORDER BY T2.tours DESC\nLIMIT 1"
        ]
    },
    "460": {
        "db_id": "wta_1",
        "question": "What is the first name and country code of the player with the most tours?",
        "ground_truth": "SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT 1",
        "amends": [
            "Do add `rankings` table with `JOIN` on `T1.player_id = T2.player_id` instead of querying only `players` table. Do reference `T2.tours` in `ORDER BY` instead of `tours` which would cause ambiguity. Do include table aliases `T1` and `T2` for clarity instead of omitting them. Do specify `T1.country_code` and `T1.first_name` with explicit table references instead of bare column names. The amended query now correctly joins player data with ranking information to find the player with the highest tours count, matching the intended behavior.",
            "Do reverse the column order in the SELECT list to `country_code, first_name` instead of `first_name, country_code`. Do add the `AS` keyword for table aliases by specifying `players AS T1` and `rankings AS T2` instead of omitting it. Do maintain the same join condition `T1.player_id = T2.player_id` and ordering by `T2.tours DESC` with `LIMIT 1`. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [
            "When answering about \"player with the most tours\": make sure to join the players table (T1) with the rankings table (T2) using T1.player_id = T2.player_id to access tour information.",
            "When ordering by tours count: use T2.tours instead of ambiguous column references.",
            "When selecting player attributes: use explicit table references T1.first_name and T1.country_code instead of bare column names.",
            "When answering about \"player with the most tours\", When ordering by tours count, When selecting player attributes, When finding the top player: rank rows by T2.tours in descending order and keep only the first row.",
            "When answering about \"first name and country code of the player with the most tours\": make sure the output order: country_code, first_name.",
            "When combining players and rankings tables for shared entities: link rows where T1.player_id = T2.player_id exactly as shown; keep only matching pairs (inner match).",
            "When answering about \"first name and country code of the player with the most tours\", When combining players and rankings tables for shared entities, When the question mentions \"most tours\": rank rows by T2.tours in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, country_code FROM players ORDER BY tours DESC LIMIT 1;",
            "SELECT T1.first_name, T1.country_code\nFROM players T1\nJOIN rankings T2 ON T1.player_id = T2.player_id\nORDER BY T2.tours DESC\nLIMIT 1",
            "SELECT T1.country_code, T1.first_name\nFROM players AS T1\nJOIN rankings AS T2 ON T1.player_id = T2.player_id\nORDER BY T2.tours DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.country_code, T1.first_name\nFROM players T1\nJOIN rankings T2 ON T1.player_id = T2.player_id\nORDER BY T2.tours DESC\nLIMIT 1"
        ]
    },
    "461": {
        "db_id": "wta_1",
        "question": "Find the year that has the most number of matches.",
        "ground_truth": "SELECT YEAR FROM matches GROUP BY YEAR ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `YEAR` instead of both `year` and `COUNT(*) as match_count`. Do order by `count(*) DESC` instead of `match_count ASC` to find the year with the most matches rather than the fewest. The amended query now correctly identifies the year with the highest match count by ordering in descending order and returns only the year column as specified."
        ],
        "rules": [
            "When answering about \"the year that has the most number of matches\": make sure the output order includes only the \"year\" column.",
            "When the question asks for \"most number of matches\": rank rows by count of matches in descending order and keep the first 1 row.",
            "When answering about \"the year that has the most number of matches\", When the question asks for \"most number of matches\", When counting matches: compute the number of rows using the canonical key for matches (year)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, COUNT(*) as match_count FROM matches GROUP BY year ORDER BY match_count ASC LIMIT 1;",
            "SELECT year FROM matches GROUP BY year ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT year FROM matches GROUP BY year ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "462": {
        "db_id": "wta_1",
        "question": "Which year had the most matches?",
        "ground_truth": "SELECT YEAR FROM matches GROUP BY YEAR ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `YEAR` instead of selecting both `year` and `COUNT(*) as match_count`. Do order by `count(*) DESC` instead of `match_count ASC` to find the year with the most matches rather than the fewest. Do remove the alias `match_count` from the ORDER BY clause since it's no longer selected. The amended query now correctly identifies the year with the highest number of matches by using descending order on the count aggregation."
        ],
        "rules": [
            "When answering about \"which year had the most matches\": make sure the output order: YEAR.",
            "When counting matches: compute the number of rows using the canonical key for matches (year).",
            "When the question asks for \"most matches\": rank years by count of matches in descending order and keep the first 1 row.",
            "When answering about \"which year had the most matches\", When counting matches, When the question asks for \"most matches\", When handling text literals: do not change case, spacing, or punctuation for column names like \"year\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, COUNT(*) as match_count FROM matches GROUP BY year ORDER BY match_count ASC LIMIT 1;",
            "SELECT year FROM matches GROUP BY year ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT year FROM matches GROUP BY year ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "463": {
        "db_id": "wta_1",
        "question": "Find the name and rank points of the winner who won the most times.",
        "ground_truth": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `winner_name` and `winner_rank_points` instead of `name` and `rank_points`. Do add `GROUP BY winner_name` instead of omitting it, as aggregation requires grouping. Do keep `ORDER BY count(*) DESC` and `LIMIT 1` unchanged. The amended query now correctly aggregates match counts per winner before ordering and limiting, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for \"name and rank points\": select \"winner_name\" and \"winner_rank_points\" from the matches table.",
            "When counting the number of wins per winner: group the results by \"winner_name\" to aggregate match counts for each distinct winner.",
            "When the question asks for \"name and rank points\", When counting the number of wins per winner, When finding the winner with the most wins: order the results by the count of matches in descending order and keep only the first row (top result)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, rank_points FROM winners ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT winner_name, winner_rank_points FROM matches GROUP BY winner_name ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT winner_name, winner_rank_points FROM matches GROUP BY winner_name ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "464": {
        "db_id": "wta_1",
        "question": "What is the name of the winner who has won the most matches, and how many rank points does this player have?",
        "ground_truth": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference `winner_rank_points` instead of `rank_points` in the SELECT list to correctly access the intended column from the matches table. The amended query now matches RIGHT_SQL's behavior by properly selecting the winner's rank points while maintaining the same grouping, ordering, and limiting logic.",
            "Do group by only `winner_name` instead of grouping by `winner_id`, `winner_name`, and `winner_rank_points`. Do maintain the same `SELECT` list with `winner_name` and `winner_rank_points` instead of changing it. Do keep the same `ORDER BY COUNT(*) DESC` and `LIMIT 1` instead of modifying them. The amended query now correctly aggregates by winner name only while preserving the selection of winner rank points, matching the right SQL's behavior."
        ],
        "rules": [
            "When the question asks for \"rank points\" of a player: use the exact column name \"winner_rank_points\" from the matches table to access the winner's rank points.",
            "When counting matches won by players: count using the \"winner_name\" column to determine the number of wins per player.",
            "When the question asks for \"rank points\" of a player, When counting matches won by players, When finding the player with the most wins: rank players by their win count in descending order and keep only the top-ranked player.",
            "When grouping by winner name to count matches won: group only by \"winner_name\" instead of including \"winner_id\" and \"winner_rank_points\" in the grouping.",
            "When selecting columns after grouping by winner name: maintain the selection of both \"winner_name\" and \"winner_rank_points\" without changing the output columns.",
            "When ordering results to find the player with most wins: order by the count of matches won in descending order and keep only the top result using LIMIT 1.",
            "When grouping by winner name to count matches won, When selecting columns after grouping by winner name, When ordering results to find the player with most wins, When counting matches won per player: count all rows for each winner name to determine the number of matches won."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT winner_name, rank_points FROM matches GROUP BY winner_name ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT winner_name, winner_rank_points\nFROM matches\nGROUP BY winner_id, winner_name, winner_rank_points\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT winner_name, winner_rank_points\nFROM matches\nGROUP BY winner_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT winner_name, winner_rank_points\nFROM matches\nGROUP BY winner_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "465": {
        "db_id": "wta_1",
        "question": "Find the name of the winner who has the highest rank points and participated in the Australian Open tourney.",
        "ground_truth": "SELECT winner_name FROM matches WHERE tourney_name  =  'Australian Open' ORDER BY winner_rank_points DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT winner_name FROM matches WHERE tourney_name = 'Australian Open' ORDER BY winner_rank_points DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT winner_name\nFROM matches\nWHERE tourney_name = 'Australian Open'\nORDER BY winner_rank_points DESC\nLIMIT 1;"
        ]
    },
    "466": {
        "db_id": "wta_1",
        "question": "What is the name of the winner with the most rank points who participated in the Australian Open tournament?",
        "ground_truth": "SELECT winner_name FROM matches WHERE tourney_name  =  'Australian Open' ORDER BY winner_rank_points DESC LIMIT 1",
        "amends": [
            "Do filter on `tourney_name` instead of `tournament` in the WHERE clause, as the correct column name for identifying the Australian Open tournament is `tourney_name` rather than the non-existent `tournament` column. This amendment ensures the query correctly identifies matches from the Australian Open tournament before selecting the winner with the highest ranking points."
        ],
        "rules": [
            "When the question mentions \"Australian Open tournament\": use the exact literal value 'Australian Open' to filter the \"tourney_name\" column.",
            "When answering about \"winner with the most rank points\": order results by \"winner_rank_points\" in descending order and take the first row.",
            "When the question mentions \"Australian Open tournament\", When answering about \"winner with the most rank points\", When selecting the winner's name: output the \"winner_name\" column from the matches table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT winner_name FROM matches WHERE tournament = 'Australian Open' ORDER BY winner_rank_points DESC LIMIT 1;",
            "SELECT winner_name \nFROM matches \nWHERE tourney_name = 'Australian Open' \nORDER BY winner_rank_points DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT winner_name FROM matches WHERE tourney_name = 'Australian Open' ORDER BY winner_rank_points DESC LIMIT 1;"
        ]
    },
    "467": {
        "db_id": "wta_1",
        "question": "find the names of loser and winner who played in the match with greatest number of minutes.",
        "ground_truth": "SELECT winner_name ,  loser_name FROM matches ORDER BY minutes DESC LIMIT 1",
        "amends": [
            "Do select `winner_name` and `loser_name` columns instead of `loser` and `winner`. The amended query now correctly retrieves the specified name columns while maintaining the same ordering and limiting behavior."
        ],
        "rules": [
            "When the question asks for \"names of loser and winner\": use the exact column tokens \"loser_name\" and \"winner_name\" from the matches table instead of \"loser\" and \"winner\".",
            "When the question asks for \"names of loser and winner\", When the question asks for the match with the \"greatest number of minutes\": order the results by the \"minutes\" column in descending order and take only the first row."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT loser, winner FROM matches ORDER BY minutes DESC LIMIT 1;",
            "SELECT winner_name, loser_name FROM matches ORDER BY minutes DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT loser_name, winner_name FROM matches ORDER BY minutes DESC LIMIT 1;"
        ]
    },
    "468": {
        "db_id": "wta_1",
        "question": "What are the names of the winner and loser who played in the longest match?",
        "ground_truth": "SELECT winner_name ,  loser_name FROM matches ORDER BY minutes DESC LIMIT 1",
        "amends": [
            "Do reference the `minutes` column instead of `duration` in the ORDER BY clause. The amended query now correctly sorts by match length using the appropriate column name and matches the intended behavior."
        ],
        "rules": [
            "When the question asks about the \"longest match\": use the \"minutes\" column from the matches table to determine match length and sort in descending order.",
            "When answering about names of winner and loser in the longest match: make sure the output order includes \"winner_name\" and \"loser_name\" columns.",
            "When the question asks about the \"longest match\", When answering about names of winner and loser in the longest match, When ranking to find the single longest match: take only the first row after sorting by \"minutes\" in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT winner_name, loser_name \nFROM matches \nORDER BY duration DESC \nLIMIT 1;",
            "SELECT winner_name, loser_name FROM matches ORDER BY minutes DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT winner_name, loser_name FROM matches ORDER BY minutes DESC LIMIT 1;"
        ]
    },
    "469": {
        "db_id": "wta_1",
        "question": "Find the average ranking for each player and their first name.",
        "ground_truth": "SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name",
        "amends": [
            "Do add the `rankings` table with a `JOIN` on `T1.player_id = T2.player_id` instead of querying only the `players` table. Do change the GROUP BY clause to use `T1.first_name` instead of `player_id`. Do move the `first_name` column to the SELECT list after the aggregate function instead of placing it first. Do reference the `first_name` column with table alias `T1` instead of without qualification. The amended query now correctly joins the necessary tables and groups by the appropriate non-aggregated column to match the intended behavior.",
            "Do place `T1.first_name` after the aggregate function instead of listing it first in the SELECT clause. Do use lowercase `avg(ranking)` without an alias instead of `AVG(T2.ranking) AS average_ranking`. Do maintain the same `JOIN` on `T1.player_id = T2.player_id` and `GROUP BY T1.first_name` structure. The amended query now correctly calculates the average ranking per first name while maintaining the same logical behavior."
        ],
        "rules": [
            "When answering about \"average ranking for each player and their first name\": make sure the output order: average ranking first, then first name.",
            "When combining players table (T1) and rankings table (T2): link rows where T1.player_id = T2.player_id and keep only matching pairs (inner match).",
            "When grouping by player first name: organize results by T1.first_name and compute average ranking per group.",
            "When answering about \"average ranking for each player and their first name\", When combining players table (T1) and rankings table (T2), When grouping by player first name, When selecting columns: place the aggregate function AVG(ranking) before T1.first_name in the output.",
            "When answering about \"average ranking for each player and their first name\": make sure the output order: average ranking calculation first, then first name.",
            "When computing average ranking: use lowercase avg(ranking) without an alias instead of AVG(T2.ranking) AS average_ranking.",
            "When combining players T1 and rankings T2: link rows where T1.player_id = T2.player_id and keep only matching pairs (inner match).",
            "When answering about \"average ranking for each player and their first name\", When computing average ranking, When combining players T1 and rankings T2, When grouping by first name: organize results by T1.first_name and compute the average ranking per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, AVG(ranking) FROM players GROUP BY player_id;",
            "SELECT T1.first_name, AVG(T2.ranking) AS average_ranking\nFROM players T1\nJOIN rankings T2 ON T1.player_id = T2.player_id\nGROUP BY T1.first_name",
            "SELECT AVG(T2.ranking), T1.first_name FROM players T1 JOIN rankings T2 ON T1.player_id = T2.player_id GROUP BY T1.first_name"
        ],
        "rule_sql": [
            "SELECT avg(ranking), first_name FROM players JOIN rankings ON players.player_id = rankings.player_id GROUP BY first_name"
        ]
    },
    "470": {
        "db_id": "wta_1",
        "question": "What are the first names of all players, and their average rankings?",
        "ground_truth": "SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name",
        "amends": [
            "Do add the `rankings` table with a `JOIN` on `T1.player_id = T2.player_id` instead of querying only the `players` table. Do reference `avg(ranking)` from the joined `rankings` table instead of attempting to average a column that doesn't exist in the original table. Do use table aliases `T1` and `T2` with qualified column references instead of unqualified column names. Do group by the qualified `T1.first_name` instead of the unqualified `first_name`. The amended query now correctly calculates average rankings by joining the necessary tables and matches the RIGHT_SQL's behavior.",
            "Do place `T1.first_name` after the aggregate function instead of listing it first in the SELECT clause. Do use lowercase `avg(ranking)` without an alias instead of `AVG(T2.ranking) AS average_ranking`. Do maintain the same `JOIN` on `T1.player_id = T2.player_id` and `GROUP BY T1.first_name` structure. The amended query now correctly calculates the average ranking per first name while maintaining the same logical behavior.",
            "Do place `avg(ranking)` first in the SELECT list instead of `T1.first_name`, and do remove the table alias from `first_name` instead of keeping it as `T1.first_name`. Do add the `AS` keyword for table aliases instead of omitting it, and do use consistent spacing around the equals operator in the join condition instead of inconsistent spacing. The grouping logic remains identical with `GROUP BY T1.first_name` in both queries. The amended query now correctly calculates the average ranking while maintaining proper SQL syntax and formatting to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"first names of all players and their average rankings\": make sure the output order: T1.first_name, avg(T2.ranking).",
            "When combining players table (T1) and rankings table (T2): link rows where T1.player_id = T2.player_id and keep only matching pairs (inner match).",
            "When the question asks for \"average rankings\": compute the average of T2.ranking values per group.",
            "When the question says \"by first names\": organize results by T1.first_name and compute requested aggregates per group.",
            "When answering about \"first names of all players and their average rankings\", When combining players table (T1) and rankings table (T2), When the question asks for \"average rankings\", When the question says \"by first names\", When using table aliases: use T1 for players table and T2 for rankings table with qualified column references.",
            "When answering about \"first names of all players and their average rankings\": make sure the output order: average ranking first, then first name.",
            "When computing average rankings: use lowercase \"avg(ranking)\" without an alias instead of \"AVG(T2.ranking) AS average_ranking\".",
            "When combining players table T1 and rankings table T2: link rows where T1.player_id = T2.player_id and keep only matching pairs (inner match).",
            "When answering about \"first names of all players and their average rankings\", When computing average rankings, When combining players table T1 and rankings table T2, When grouping by first name: organize results by T1.first_name and compute average ranking per group.",
            "When answering about \"first names of all players and their average rankings\": make sure the output order: average ranking first, then first name.",
            "When selecting columns from the players table: use \"first_name\" without table alias instead of \"T1.first_name\".",
            "When calculating average rankings: use \"avg(ranking)\" as the first output column.",
            "When joining players and rankings tables: use consistent spacing around the equals operator in the join condition \"T1.player_id = T2.player_id\".",
            "When answering about \"first names of all players and their average rankings\", When selecting columns from the players table, When calculating average rankings, When joining players and rankings tables, When grouping results by first name: use \"GROUP BY T1.first_name\" to organize results by player first names."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, AVG(ranking) FROM players GROUP BY first_name;",
            "SELECT T1.first_name, AVG(T2.ranking) AS average_ranking\nFROM players T1\nJOIN rankings T2 ON T1.player_id = T2.player_id\nGROUP BY T1.first_name",
            "SELECT T1.first_name, avg(T2.ranking) FROM players T1 JOIN rankings T2 ON T1.player_id = T2.player_id GROUP BY T1.first_name",
            "SELECT avg(ranking), T1.first_name\nFROM players AS T1\nJOIN rankings AS T2 ON T1.player_id = T2.player_id\nGROUP BY T1.first_name"
        ],
        "rule_sql": [
            "SELECT avg(ranking), first_name FROM players T1 JOIN rankings T2 ON T1.player_id = T2.player_id GROUP BY T1.first_name"
        ]
    },
    "471": {
        "db_id": "wta_1",
        "question": "Find the total ranking points for each player and their first name.",
        "ground_truth": "SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name",
        "amends": [
            "Do add the `rankings` table with a `JOIN` on `T1.player_id = T2.player_id` instead of querying only the `players` table. Do change the GROUP BY clause to use `T1.first_name` instead of `player_id`. Do include the table alias `T1` for `first_name` in the SELECT list instead of referencing it directly. Do remove the explicit column `first_name` from the SELECT list and instead include only the aggregate function `sum(ranking_points)` with the correct table alias. The amended query now correctly joins the players and rankings tables to calculate total ranking points per player name.",
            "Do place the aggregate function `sum(ranking_points)` first in the SELECT list instead of placing `T1.first_name` first, and do remove the alias `total_ranking_points` instead of keeping it, while maintaining the same FROM clause with `JOIN` on `T1.player_id = T2.player_id` and GROUP BY `T1.first_name`. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"total ranking points for each player and their first name\": make sure the output order: first_name, sum(ranking_points)",
            "When combining players table (T1) and rankings table (T2) for shared entities: link rows where T1.player_id = T2.player_id exactly as shown in the amends; keep only matching pairs (inner match)",
            "When the question says \"per player\": organize results by T1.first_name and compute sum of ranking_points per group",
            "When the question asks for \"total ranking points\": compute the sum of T2.ranking_points for each group",
            "When answering about \"total ranking points for each player and their first name\", When combining players table (T1) and rankings table (T2) for shared entities, When the question says \"per player\", When the question asks for \"total ranking points\", When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms",
            "When answering about \"total ranking points for each player and their first name\": make sure the output order: SUM(T2.ranking_points) first, then T1.first_name.",
            "When computing aggregate values: do not assign aliases to aggregate functions like SUM(T2.ranking_points).",
            "When combining players T1 and rankings T2: link rows where T1.player_id = T2.player_id and keep only matching pairs (inner match).",
            "When answering about \"total ranking points for each player and their first name\", When computing aggregate values, When combining players T1 and rankings T2, When grouping by player attributes: organize results by T1.first_name and compute the sum of ranking_points per group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, SUM(ranking_points) FROM players GROUP BY player_id",
            "SELECT T1.first_name, SUM(T2.ranking_points) AS total_ranking_points FROM players T1 JOIN rankings T2 ON T1.player_id = T2.player_id GROUP BY T1.first_name",
            "SELECT sum(T2.ranking_points), T1.first_name FROM players T1 JOIN rankings T2 ON T1.player_id = T2.player_id GROUP BY T1.first_name"
        ],
        "rule_sql": [
            "SELECT T1.first_name, SUM(T2.ranking_points) FROM players T1 INNER JOIN rankings T2 ON T1.player_id = T2.player_id GROUP BY T1.first_name"
        ]
    },
    "472": {
        "db_id": "wta_1",
        "question": "What are the first names of all players, and their total ranking points?",
        "ground_truth": "SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name",
        "amends": [
            "Do add `sum(ranking_points)` and `T1.first_name` instead of `first_name, ranking_points` in the SELECT list. Do add `FROM players AS T1 JOIN rankings AS T2 ON T1.player_id = T2.player_id` instead of just `FROM players` to include the rankings table with a proper join condition. Do add `GROUP BY T1.first_name` instead of omitting grouping to aggregate ranking points by player name. Do remove the direct selection of individual ranking points instead of keeping them, replacing with an aggregate sum. The amended query now correctly aggregates ranking points by player name through proper table joining and grouping.",
            "Do place the aggregate function `sum(ranking_points)` first in the SELECT list instead of starting with `T1.first_name`. Do remove the alias `total_ranking_points` from the SUM expression instead of keeping it. Do maintain the same FROM clause with `JOIN` on `T1.player_id = T2.player_id` and identical GROUP BY `T1.first_name`. The amended query now correctly calculates total ranking points by player first name without unnecessary aliasing."
        ],
        "rules": [
            "When answering about \"first names of all players and their total ranking points\": make sure the output order: T1.first_name, sum(ranking_points).",
            "When combining players and rankings tables: link rows where T1.player_id = T2.player_id and keep only matching pairs (inner match).",
            "When the question asks for \"total ranking points\": compute the sum of ranking_points values for each player.",
            "When answering about \"first names of all players and their total ranking points\", When combining players and rankings tables, When the question asks for \"total ranking points\", When grouping by player names: organize results by T1.first_name and compute the requested aggregate per group.",
            "When the question asks for \"first names of all players and their total ranking points\": make sure the output order starts with the aggregate function sum(ranking_points) before T1.first_name.",
            "When calculating total ranking points: do not add an alias like total_ranking_points to the SUM expression.",
            "When combining players and rankings tables: link rows where T1.player_id = T2.player_id and keep only matching pairs (inner match).",
            "When the question asks for \"first names of all players and their total ranking points\", When calculating total ranking points, When combining players and rankings tables, When grouping by player first names: organize results by T1.first_name and compute the sum of ranking_points per group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, ranking_points FROM players;",
            "SELECT T1.first_name, SUM(T2.ranking_points) AS total_ranking_points\nFROM players AS T1\nJOIN rankings AS T2 ON T1.player_id = T2.player_id\nGROUP BY T1.first_name",
            "SELECT sum(ranking_points), T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id = T2.player_id GROUP BY T1.first_name"
        ],
        "rule_sql": [
            "SELECT T1.first_name, SUM(ranking_points) FROM players T1 INNER JOIN rankings T2 ON T1.player_id = T2.player_id GROUP BY T1.first_name"
        ]
    },
    "473": {
        "db_id": "wta_1",
        "question": "find the number of players for each country.",
        "ground_truth": "SELECT count(*) ,  country_code FROM players GROUP BY country_code",
        "amends": [
            "Do use `country_code` instead of `country` in both the SELECT list and GROUP BY clause. Do place the aggregate function `count(*)` first in the SELECT list instead of second. The amended query now correctly groups by and selects the country_code column, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for \"number of players for each country\": use \"country_code\" instead of \"country\" in both the output and grouping.",
            "When counting players: place the count result first in the output order before the country_code.",
            "When the question asks for \"number of players for each country\", When counting players, When grouping by country: use the exact column token \"country_code\" for grouping and output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country, COUNT(*) FROM players GROUP BY country;",
            "SELECT count(*) as player_count, country_code FROM players GROUP BY country_code;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS count, country_code FROM players GROUP BY country_code ORDER BY count DESC;"
        ]
    },
    "474": {
        "db_id": "wta_1",
        "question": "How many players are from each country?",
        "ground_truth": "SELECT count(*) ,  country_code FROM players GROUP BY country_code",
        "amends": [
            "Do use `country_code` instead of `country` in both the SELECT list and GROUP BY clause. Do place the aggregate function `count(*)` first in the SELECT list instead of second. The amended query now correctly groups by and selects the country_code field, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for \"players from each country\": use \"country_code\" instead of \"country\" in both the output and grouping.",
            "When counting players per country: place the count result first in the output order before the country_code.",
            "When the question asks for \"players from each country\", When counting players per country, When grouping by country: use the exact token \"country_code\" for grouping and output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country, COUNT(*) FROM players GROUP BY country;",
            "SELECT count(*) as player_count, country_code FROM players GROUP BY country_code;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS player_count, country_code FROM players GROUP BY country_code ORDER BY player_count DESC;"
        ]
    },
    "475": {
        "db_id": "wta_1",
        "question": "find the code of the country where has the greatest number of players.",
        "ground_truth": "SELECT country_code FROM players GROUP BY country_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do aggregate with `GROUP BY country_code` and order by `count(*) DESC` instead of selecting individual records with `ORDER BY player_id DESC`. Do add the grouping operation to count occurrences per country instead of retrieving a single random country code. Do change the ordering criteria to frequency-based ranking instead of arbitrary player ID ordering. The amended query now correctly identifies the most frequent country code by count rather than returning an arbitrary country from the last player record.",
            "Do remove `COUNT(*) as player_count` from the SELECT list instead of including it, and do reference `count(*)` directly in the ORDER BY clause instead of using the alias `player_count`. Do keep the same GROUP BY on `country_code` and maintain the DESC ordering with LIMIT 1. The amended query now correctly returns only the country_code with the highest player count while matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for the country with the greatest number of players: group results by the exact token \"country_code\" from the players table.",
            "When counting players per country: count the number of rows using the canonical key for players (player_id) to determine frequency.",
            "When ranking countries by player count: order the results by the count of players in descending order to find the highest count.",
            "When the question asks for the country with the greatest number of players, When counting players per country, When ranking countries by player count, When selecting the top result: return only the first row after ordering by count to get the country with the greatest number of players.",
            "When counting players per country: use the exact column token \"country_code\" for grouping and count all rows using count(*)",
            "When finding the country with the greatest number of players: order the results by count(*) in descending direction and keep only the first row",
            "When counting players per country, When finding the country with the greatest number of players, When outputting results: include only the \"country_code\" column in the output, not the count value"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country_code FROM players ORDER BY player_id DESC LIMIT 1;",
            "SELECT country_code, COUNT(*) as player_count FROM players GROUP BY country_code ORDER BY player_count DESC LIMIT 1;",
            "SELECT country_code FROM players GROUP BY country_code ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT country_code FROM players GROUP BY country_code ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "476": {
        "db_id": "wta_1",
        "question": "What is the code of the country with the most players?",
        "ground_truth": "SELECT country_code FROM players GROUP BY country_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do aggregate with `GROUP BY country_code` and order by `count(*) DESC` instead of selecting individual records ordered by `player_id DESC`. Do include the grouping and aggregation logic to find the most frequent country code instead of simply retrieving the last player's country. The amended query now correctly identifies the country with the highest number of players rather than just the most recent player's country, matching the intended behavior.",
            "Do remove `COUNT(*) as player_count` from the SELECT list instead of including it, and do reference `count(*)` directly in the ORDER BY clause instead of using the alias `player_count`. Do maintain the same GROUP BY on `country_code` and LIMIT 1, but now the query correctly returns only the country_code with the highest count of players rather than including both the country_code and the count value in the results. The amended query now matches RIGHT_SQL's behavior by returning just the country code with the maximum player count."
        ],
        "rules": [
            "When answering about \"the country with the most players\": group rows by the exact token \"country_code\" and count the number of players per group.",
            "When counting players: use the canonical key \"player_id\" to count the number of distinct players.",
            "When finding the country with the highest count: order the results by the count in descending direction and keep only the first row.",
            "When answering about \"the country with the most players\", When counting players, When finding the country with the highest count, When producing output: return only the \"country_code\" column for the result.",
            "When answering about \"the country with the most players\": make sure the output order: only include the country_code column.",
            "When counting players per country: use count(*) directly in the ORDER BY clause instead of creating an alias for it.",
            "When grouping by country_code: organize results by the exact token \"country_code\" and compute the count of players per group.",
            "When the question asks for \"the most players\": rank rows by count(*) in descending order and keep only the first 1 row.",
            "When answering about \"the country with the most players\", When counting players per country, When grouping by country_code, When the question asks for \"the most players\", When producing output for this question: do not include the count value in the results, only return the country_code."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country_code FROM players ORDER BY player_id DESC LIMIT 1;",
            "SELECT country_code, COUNT(*) as player_count FROM players GROUP BY country_code ORDER BY player_count DESC LIMIT 1;",
            "SELECT country_code FROM players GROUP BY country_code ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT country_code FROM players GROUP BY country_code ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "477": {
        "db_id": "wta_1",
        "question": "Find the codes of countries that have more than 50 players.",
        "ground_truth": "SELECT country_code FROM players GROUP BY country_code HAVING count(*)  >  50",
        "amends": [
            "Do add `GROUP BY country_code` and move the aggregate filter to `HAVING count(*) > 50` instead of incorrectly placing `COUNT(*) > 50` in the `WHERE` clause where aggregate functions cannot be used. This properly groups the results by country code and applies the count condition after grouping rather than attempting to filter individual rows with an aggregate function, which would cause a syntax error. The amended query now correctly returns only those country codes that have more than 50 players, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for \"codes of countries that have more than 50 players\": group rows by \"country_code\" and count the number of players per group.",
            "When counting players per country: use the count of all rows in each group to determine the number of players.",
            "When filtering for groups with more than 50 players: apply the condition \"count(*) > 50\" after grouping rather than before grouping.",
            "When the question asks for \"codes of countries that have more than 50 players\", When counting players per country, When filtering for groups with more than 50 players, When answering about country codes with player counts: make sure the output order includes only \"country_code\" for groups that satisfy the count condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country_code FROM players WHERE COUNT(*) > 50",
            "SELECT country_code FROM players GROUP BY country_code HAVING COUNT(*) > 50"
        ],
        "rule_sql": [
            "SELECT country_code FROM players GROUP BY country_code HAVING COUNT(*) > 50"
        ]
    },
    "478": {
        "db_id": "wta_1",
        "question": "What are the codes of countries with more than 50 players?",
        "ground_truth": "SELECT country_code FROM players GROUP BY country_code HAVING count(*)  >  50",
        "amends": [
            "Do add `GROUP BY country_code` and move the aggregate filter to `HAVING count(*) > 50` instead of incorrectly placing `COUNT(*) > 50` in the `WHERE` clause where aggregate functions are not allowed. Do use the correct aggregate function syntax `count(*)` instead of `COUNT(*)` for consistency with the right query's style. The amended query now correctly groups by country code and filters groups with more than 50 players, matching the right SQL's behavior."
        ],
        "rules": [
            "When the question asks for \"codes of countries with more than 50 players\": group results by country_code and count players per group.",
            "When filtering on aggregate counts like \"more than 50 players\": apply the count(*) > 50 condition in a HAVING clause after grouping, not in a WHERE clause.",
            "When the question asks for \"codes of countries with more than 50 players\", When filtering on aggregate counts like \"more than 50 players\", When counting players: use count(*) to count all rows in each country group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country_code FROM players WHERE COUNT(*) > 50",
            "SELECT country_code FROM players GROUP BY country_code HAVING count(*) > 50"
        ],
        "rule_sql": [
            "SELECT country_code FROM players GROUP BY country_code HAVING COUNT(*) > 50"
        ]
    },
    "479": {
        "db_id": "wta_1",
        "question": "Find the total number of tours for each ranking date.",
        "ground_truth": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date",
        "amends": [
            "Do select `sum(tours)` and `ranking_date` instead of `ranking_date` and `COUNT(*)`. Do use `FROM rankings` instead of `FROM tours`. Do group by `ranking_date` instead of grouping by `tour_id`. The amended query now correctly aggregates tour counts by ranking date from the rankings table rather than incorrectly counting records from the tours table grouped by tour ID.",
            "Do place the `ranking_date` column after the aggregate function instead of listing it first in the SELECT clause. Do use the same aggregate expression `SUM(tours)` but with different formatting instead of changing the aggregation logic. Do maintain the same `GROUP BY ranking_date` clause instead of altering the grouping structure. The amended query now correctly calculates total tours grouped by ranking date while maintaining identical output behavior."
        ],
        "rules": [
            "When answering about \"total number of tours for each ranking date\": make sure the output order: ranking_date, sum(tours).",
            "When the question asks for \"total number of tours\": use the exact column token \"sum(tours)\" from the rankings table.",
            "When the question says \"for each ranking date\": organize results by the exact token \"ranking_date\" from the rankings table.",
            "When answering about \"total number of tours for each ranking date\", When the question asks for \"total number of tours\", When the question says \"for each ranking date\", When selecting data: use FROM rankings instead of FROM tours to access the correct table containing ranking_date and tour count information.",
            "When answering about \"total number of tours for each ranking date\": make sure the output order: SUM(tours) first, then ranking_date.",
            "When the question asks for \"total number of tours\": compute the sum of the tours column.",
            "When answering about \"total number of tours for each ranking date\", When the question asks for \"total number of tours\", When the question says \"for each ranking date\": organize results by the ranking_date column and compute the requested aggregate per group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ranking_date, COUNT(*) FROM tours GROUP BY tour_id;",
            "SELECT ranking_date, SUM(tours) AS total_tours FROM rankings GROUP BY ranking_date;",
            "SELECT SUM(tours) AS total_tours, ranking_date FROM rankings GROUP BY ranking_date"
        ],
        "rule_sql": [
            "SELECT ranking_date, SUM(tours) FROM rankings GROUP BY ranking_date ORDER BY ranking_date, SUM(tours);"
        ]
    },
    "480": {
        "db_id": "wta_1",
        "question": "How many total tours were there for each ranking date?",
        "ground_truth": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date",
        "amends": [
            "Do select `sum(tours)` and `ranking_date` instead of `ranking_date` and `COUNT(*)`. Do query from `rankings` table instead of `tours` table. Do group by `ranking_date` instead of grouping by the same column but with different underlying data. The amended query now correctly aggregates tour counts from the rankings table instead of counting records from the tours table, matching the intended behavior.",
            "Do place the `ranking_date` column after the aggregate function instead of before it in the SELECT list. Do use the unaliased `sum(tours)` expression instead of aliasing it as `total_tours`. The amended query now correctly groups by ranking_date while maintaining the same aggregation logic and output behavior."
        ],
        "rules": [
            "When answering about \"total tours for each ranking date\": make sure the output order: ranking_date, sum(tours).",
            "When the question mentions \"total tours\": \"total tours\" actually means \"sum(tours) in schema\".",
            "When the question asks for \"each ranking date\": organize results by ranking_date and compute requested aggregates per group.",
            "When answering about \"total tours for each ranking date\", When the question mentions \"total tours\", When the question asks for \"each ranking date\", When querying for tour data: use the rankings table instead of the tours table as the source of data.",
            "When answering about \"total tours for each ranking date\": make sure the output order: sum(tours) first, then ranking_date.",
            "When the question asks for \"total tours\": compute the sum of the exact column \"tours\" from the rankings table.",
            "When the question says \"for each ranking date\": organize results by the exact column \"ranking_date\" from the rankings table.",
            "When answering about \"total tours for each ranking date\", When the question asks for \"total tours\", When the question says \"for each ranking date\", When producing output: do not alias the sum(tours) expression as \"total_tours\" - use the unaliased expression directly."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ranking_date, COUNT(*) FROM tours GROUP BY ranking_date;",
            "SELECT ranking_date, SUM(tours) AS total_tours FROM rankings GROUP BY ranking_date;",
            "SELECT sum(tours), ranking_date FROM rankings GROUP BY ranking_date"
        ],
        "rule_sql": [
            "SELECT ranking_date, SUM(tours) FROM rankings GROUP BY ranking_date ORDER BY SUM(tours), ranking_date;"
        ]
    },
    "481": {
        "db_id": "wta_1",
        "question": "Find the number of matches happened in each year.",
        "ground_truth": "SELECT count(*) ,  YEAR FROM matches GROUP BY YEAR",
        "amends": [
            "Do place the aggregate function `count(*)` first in the SELECT list instead of placing `year` first. Do use uppercase `YEAR` for the column reference instead of lowercase `year` in both the SELECT list and GROUP BY clause. The amended query now correctly groups by the year column and counts matches per year, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"number of matches happened in each year\": make sure the output order: COUNT(*) first, then YEAR.",
            "When the question mentions \"year\": \"year\" actually means \"YEAR\" in schema (uppercase).",
            "When the question asks for \"count of matches\": compute the number of rows using the canonical key for matches (implied by COUNT(*)).",
            "When answering about \"number of matches happened in each year\", When the question mentions \"year\", When the question asks for \"count of matches\", When the question says \"per year\"/\"each year\": organize results by YEAR and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, COUNT(*) FROM matches GROUP BY year",
            "SELECT COUNT(*), YEAR FROM matches GROUP BY YEAR"
        ],
        "rule_sql": [
            "SELECT COUNT(*), YEAR FROM matches GROUP BY YEAR ORDER BY COUNT(*) DESC, YEAR;"
        ]
    },
    "482": {
        "db_id": "wta_1",
        "question": "How many matches were played in each year?",
        "ground_truth": "SELECT count(*) ,  YEAR FROM matches GROUP BY YEAR",
        "amends": [
            "Do place the `COUNT(*)` column first in the SELECT list instead of placing `year` first. Do use uppercase `YEAR` for both the column reference and GROUP BY clause instead of lowercase `year`. The amended query now correctly groups by and returns the year column while maintaining the same aggregation logic."
        ],
        "rules": [
            "When answering about \"matches played in each year\": make sure the output order: COUNT(*) first, then YEAR.",
            "When referring to the year column: use uppercase \"YEAR\" for both column reference and grouping instead of lowercase \"year\".",
            "When answering about \"matches played in each year\", When referring to the year column, When counting matches per year: compute the number of rows using COUNT(*) while grouping by YEAR."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, COUNT(*) FROM matches GROUP BY year;",
            "SELECT COUNT(*), YEAR FROM matches GROUP BY YEAR"
        ],
        "rule_sql": [
            "SELECT COUNT(*), YEAR FROM matches GROUP BY YEAR ORDER BY COUNT(*) DESC, YEAR;"
        ]
    },
    "483": {
        "db_id": "wta_1",
        "question": "Find the name and rank of the 3 youngest winners across all matches.",
        "ground_truth": "SELECT DISTINCT winner_name ,  winner_rank FROM matches ORDER BY winner_age LIMIT 3",
        "amends": [
            "Do `SELECT DISTINCT winner_name, winner_rank` instead of `SELECT name, rank` to use the correct column names and add distinct filtering. Do `FROM matches` instead of the omitted table reference to specify the correct source table. Do `ORDER BY winner_age` instead of `ORDER BY age` to use the properly named age column. Do maintain `LIMIT 3` as it remains unchanged. The amended query now correctly retrieves distinct winner names and ranks from the matches table ordered by winner age."
        ],
        "rules": [
            "When the question asks for \"name and rank of winners\": use columns \"winner_name\" and \"winner_rank\" from table \"matches\".",
            "When the question asks for \"youngest winners\": order results by \"winner_age\" in ascending order.",
            "When the question asks for \"3 youngest winners\": limit results to the first 3 rows after ordering by \"winner_age\".",
            "When the question asks for \"name and rank of winners\", When the question asks for \"youngest winners\", When the question asks for \"3 youngest winners\", When retrieving results from the \"matches\" table: ensure distinct values are returned for winner_name and winner_rank to avoid duplicates."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, rank FROM winners ORDER BY age ASC LIMIT 3;",
            "SELECT DISTINCT winner_name, winner_rank FROM matches ORDER BY winner_age LIMIT 3"
        ],
        "rule_sql": [
            "SELECT DISTINCT winner_name, winner_rank FROM matches ORDER BY winner_age ASC LIMIT 3;"
        ]
    },
    "484": {
        "db_id": "wta_1",
        "question": "What are the names and ranks of the three youngest winners across all matches?",
        "ground_truth": "SELECT DISTINCT winner_name ,  winner_rank FROM matches ORDER BY winner_age LIMIT 3",
        "amends": [
            "Do `SELECT DISTINCT winner_name, winner_rank` instead of `SELECT name, rank` to use the correct column names and add distinctness. Do `FROM matches` instead of `FROM winners` to query from the appropriate table. Do `ORDER BY winner_age` instead of `ORDER BY age` to use the correct age column name while maintaining the ascending sort order. The amended query now correctly retrieves distinct winner names and ranks from the matches table ordered by winner age with a limit of 3, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for \"names and ranks of winners\": use the exact column tokens \"winner_name\" and \"winner_rank\" from the matches table.",
            "When the question asks for \"three youngest winners\": order rows by \"winner_age\" in ascending order and keep the first 3 rows.",
            "When retrieving winner information: ensure distinct values are returned for winner_name and winner_rank to avoid duplicates.",
            "When the question asks for \"names and ranks of winners\", When the question asks for \"three youngest winners\", When retrieving winner information, When querying about winners: use the \"matches\" table as the source table, not a \"winners\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, rank FROM winners ORDER BY age ASC LIMIT 3;",
            "SELECT DISTINCT winner_name, winner_rank FROM matches ORDER BY winner_age ASC LIMIT 3"
        ],
        "rule_sql": [
            "SELECT DISTINCT winner_name, winner_rank FROM matches ORDER BY winner_age ASC LIMIT 3"
        ]
    },
    "485": {
        "db_id": "wta_1",
        "question": "How many different winners both participated in the WTA Championships and were left handed?",
        "ground_truth": "SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  'WTA Championships' AND winner_hand  =  'L'",
        "amends": [
            "Do count `DISTINCT winner_name` instead of `COUNT(*)` to count unique winners rather than all records. Do select from `matches` table instead of joining `players` and `championships` tables to use the correct data source. Do filter on `tourney_name = 'WTA Championships'` instead of `c.tournament = 'WTA Championships'` to use the proper tournament column name. Do filter on `winner_hand = 'L'` instead of `p.handedness = 'left'` to use the correct hand designation column and value. The amended query now correctly counts distinct left-handed winners of the WTA Championships tournament."
        ],
        "rules": [
            "When counting different winners: count distinct \"winner_name\" values instead of counting all records.",
            "When answering about WTA Championships participants: use the \"matches\" table as the data source instead of joining \"players\" and \"championships\" tables.",
            "When filtering for WTA Championships tournament: use \"tourney_name = 'WTA Championships'\" as the filter condition.",
            "When counting different winners, When answering about WTA Championships participants, When filtering for WTA Championships tournament, When filtering for left-handed players: use \"winner_hand = 'L'\" as the filter condition instead of 'left'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM players p\nJOIN championships c ON p.player_id = c.player_id\nWHERE p.handedness = 'left' AND c.tournament = 'WTA Championships';",
            "SELECT COUNT(DISTINCT winner_name) \nFROM matches \nWHERE tourney_name = 'WTA Championships' \nAND winner_hand = 'L'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT winner_name) \nFROM matches \nWHERE tourney_name = 'WTA Championships' \nAND winner_hand = 'L'"
        ]
    },
    "486": {
        "db_id": "wta_1",
        "question": "Find the number of left handed winners who participated in the WTA Championships.",
        "ground_truth": "SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  'WTA Championships' AND winner_hand  =  'L'",
        "amends": [
            "Do count `DISTINCT winner_name` instead of `COUNT(*)` to count unique winners rather than all matches. Do use table `matches` instead of `winners` to access the correct data source. Do filter on `tourney_name = 'WTA Championships'` instead of `tournament = 'WTA Championships'` to use the correct column name. Do filter on `winner_hand = 'L'` instead of `handed = 'left'` to use both the correct column name and abbreviated value format. The amended query now correctly counts distinct winners from the matches table with proper filtering conditions."
        ],
        "rules": [
            "When counting winners: count distinct \"winner_name\" instead of all rows to get unique winners rather than all matches.",
            "When accessing match data: use table \"matches\" instead of \"winners\" as the correct data source.",
            "When filtering by tournament name: use \"tourney_name = 'WTA Championships'\" instead of \"tournament = 'WTA Championships'\" to use the correct column name.",
            "When counting winners, When accessing match data, When filtering by tournament name, When filtering by handedness: use \"winner_hand = 'L'\" instead of \"handed = 'left'\" to use both the correct column name and abbreviated value format."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM winners WHERE handed = 'left' AND tournament = 'WTA Championships';",
            "SELECT COUNT(DISTINCT winner_name) \nFROM matches \nWHERE tourney_name = 'WTA Championships' \nAND winner_hand = 'L'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT winner_name) \nFROM matches \nWHERE tourney_name = 'WTA Championships' \nAND winner_hand = 'L'"
        ]
    },
    "487": {
        "db_id": "wta_1",
        "question": "Find the first name, country code and birth date of the winner who has the highest rank points in all matches.",
        "ground_truth": "SELECT T1.first_name ,  T1.country_code ,  T1.birth_date FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id ORDER BY T2.winner_rank_points DESC LIMIT 1",
        "amends": [
            "Do specify table aliases `T1.first_name`, `T1.country_code`, and `T1.birth_date` instead of unqualified column references. Do add `FROM players AS T1 JOIN matches AS T2` instead of the single table `winners`. Do use join condition `ON T1.player_id = T2.winner_id` instead of no join. Do order by `T2.winner_rank_points DESC` instead of `rank_points DESC`. The amended query now correctly joins player and match data to find the winner with the highest rank points."
        ],
        "rules": [
            "When answering about \"first name, country code and birth date of the winner who has the highest rank points\": make sure the output order: T1.first_name, T1.country_code, T1.birth_date.",
            "When combining players and matches tables: link rows where T1.player_id = T2.winner_id and keep only matching pairs (inner match).",
            "When the question mentions \"highest rank points\": rank rows by T2.winner_rank_points in descending order and keep the first 1 row.",
            "When answering about \"first name, country code and birth date of the winner who has the highest rank points\", When combining players and matches tables, When the question mentions \"highest rank points\", When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, country_code, birth_date FROM winners ORDER BY rank_points DESC LIMIT 1;",
            "SELECT T1.first_name, T1.country_code, T1.birth_date\nFROM players AS T1\nJOIN matches AS T2 ON T1.player_id = T2.winner_id\nORDER BY T2.winner_rank_points DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.country_code, T1.birth_date\nFROM players T1\nINNER JOIN matches T2 ON T1.player_id = T2.winner_id\nORDER BY T2.winner_rank_points DESC\nLIMIT 1;"
        ]
    },
    "488": {
        "db_id": "wta_1",
        "question": "What is the first name, country code, and birth date of the player with the most winner rank points across all matches?",
        "ground_truth": "SELECT T1.first_name ,  T1.country_code ,  T1.birth_date FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id ORDER BY T2.winner_rank_points DESC LIMIT 1",
        "amends": [
            "Do add `JOIN matches AS T2 ON T1.player_id = T2.winner_id` instead of querying only the `players` table without any join. Do reference columns with table aliases `T1.first_name`, `T1.country_code`, and `T1.birth_date` instead of unqualified column names. Do use `T2.winner_rank_points` in the `ORDER BY` clause instead of `winner_rank_points` which doesn't exist in the players table. The amended query now correctly joins players with matches to access winner ranking points and returns the intended result matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about player information with winner rank points: combine players table (T1) and matches table (T2) by linking rows where T1.player_id equals T2.winner_id, keeping only matching pairs.",
            "When the question asks for \"most winner rank points\": rank rows by T2.winner_rank_points in descending order and keep the first 1 row.",
            "When selecting output columns: return T1.first_name, T1.country_code, and T1.birth_date in that order.",
            "When answering about player information with winner rank points, When the question asks for \"most winner rank points\", When selecting output columns, When referring to columns: always use table aliases T1 for players table and T2 for matches table with exact column names as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, country_code, birth_date \nFROM players \nORDER BY winner_rank_points DESC \nLIMIT 1;",
            "SELECT T1.first_name, T1.country_code, T1.birth_date\nFROM players AS T1\nJOIN matches AS T2 ON T1.player_id = T2.winner_id\nORDER BY T2.winner_rank_points DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.country_code, T1.birth_date FROM players T1 JOIN matches T2 ON T1.player_id = T2.winner_id ORDER BY T2.winner_rank_points DESC LIMIT 1"
        ]
    },
    "489": {
        "db_id": "wta_1",
        "question": "Find the number of players for each hand type.",
        "ground_truth": "SELECT count(*) ,  hand FROM players GROUP BY hand",
        "amends": [
            "Do place the `hand` column after the aggregate function instead of before it in the SELECT list. Do maintain the same `COUNT(*)` aggregate function and `GROUP BY hand` clause without changes. The amended query now correctly follows standard SQL syntax where non-aggregated columns should appear after aggregate functions in the SELECT list when using GROUP BY, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"number of players for each hand type\": make sure the output order: count first, then hand type.",
            "When the question asks for \"number of players\": compute the count of rows using the canonical key for players.",
            "When the question says \"for each hand type\": organize results by the exact token \"hand\" and compute the count per group.",
            "When answering about \"number of players for each hand type\", When the question asks for \"number of players\", When the question says \"for each hand type\", When producing output: place the aggregate count column before the grouping column \"hand\" in the result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT hand, COUNT(*) FROM players GROUP BY hand;",
            "SELECT COUNT(*), hand FROM players GROUP BY hand"
        ],
        "rule_sql": [
            "SELECT COUNT(player_id) AS count, hand FROM players GROUP BY hand ORDER BY count DESC, hand;"
        ]
    },
    "490": {
        "db_id": "wta_1",
        "question": "How many players are there for each hand type?",
        "ground_truth": "SELECT count(*) ,  hand FROM players GROUP BY hand",
        "amends": [
            "Do use `hand` instead of `hand_type` as the grouping column. Do place `count(*)` as the first column in the SELECT list instead of second. Do remove the alias `hand_type` and use the actual column name `hand` instead. The amended query now correctly groups by the actual column name and presents the count as the first result column, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for \"hand type\": use the exact column token \"hand\" from the players table.",
            "When grouping by hand type: organize results by the \"hand\" column and compute counts per group.",
            "When counting players: compute the number of rows using the canonical key for players.",
            "When the question asks for \"hand type\", When grouping by hand type, When counting players, When presenting results for \"how many players are there for each hand type\": place the count result as the first output column followed by the hand type column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT hand_type, COUNT(*) FROM players GROUP BY hand_type;",
            "SELECT COUNT(*), hand FROM players GROUP BY hand;"
        ],
        "rule_sql": [
            "SELECT COUNT(player_id) AS player_count, hand FROM players GROUP BY hand;"
        ]
    },
    "491": {
        "db_id": "battle_death",
        "question": "How many ships ended up being 'Captured'?",
        "ground_truth": "SELECT count(*) FROM ship WHERE disposition_of_ship  =  'Captured'",
        "amends": [
            "Do reference table `ship` instead of `ships` and use filter condition `disposition_of_ship = 'Captured'` instead of `status = 'Sunk'`."
        ],
        "rules": [
            "When the question asks about ships: use the exact table name \"ship\" instead of \"ships\".",
            "When the question asks about ships that ended up being 'Captured': use the exact column name \"disposition_of_ship\" with the exact literal value 'Captured' instead of using \"status\" with 'Sunk'.",
            "When the question asks about ships, When the question asks about ships that ended up being 'Captured', When counting ships: count all rows from the \"ship\" table that match the condition disposition_of_ship = 'Captured'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM ships WHERE status = 'Sunk';",
            "SELECT COUNT(*) FROM ship WHERE disposition_of_ship = 'Captured';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM ship WHERE disposition_of_ship = 'Captured';"
        ]
    },
    "492": {
        "db_id": "battle_death",
        "question": "List the name and tonnage ordered by in descending alphaetical order for the names.",
        "ground_truth": "SELECT name ,  tonnage FROM ship ORDER BY name DESC",
        "amends": [
            "Do use table name `ship` instead of `ships` in the FROM clause. Do change the sort direction to `DESC` instead of `ASC` in the ORDER BY clause. The amended query now correctly references the intended table and sorts results in descending order by name."
        ],
        "rules": [
            "When the question asks for ships information: use the table name \"ship\" exactly as specified in the schema.",
            "When ordering by name in descending alphabetical order: sort the \"name\" column in descending direction (Z to A).",
            "When the question asks for ships information, When ordering by name in descending alphabetical order, When selecting output columns: include both \"name\" and \"tonnage\" columns in the result set."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, tonnage FROM ships ORDER BY name ASC;",
            "SELECT name, tonnage FROM ship ORDER BY name DESC;"
        ],
        "rule_sql": [
            "SELECT name, tonnage FROM ship ORDER BY name DESC;"
        ]
    },
    "493": {
        "db_id": "battle_death",
        "question": "List the name, date and result of each battle.",
        "ground_truth": "SELECT name ,  date FROM battle",
        "amends": [
            "Do reference the table as `battle` instead of `battles` to ensure the query targets the correct database table. The amended query now correctly retrieves data from the intended table structure.",
            "Do remove `result` from the SELECT list instead of including it, which eliminates an unnecessary column from the output. The amended query now matches RIGHT_SQL's behavior by selecting only the required columns."
        ],
        "rules": [
            "When the question asks for \"name, date and result of each battle\": include the exact column \"result\" from table \"battle\" in the output.",
            "When referencing the table containing battle information: use the exact table name \"battle\" instead of \"battles\".",
            "When the question asks for \"name, date and result of each battle\", When referencing the table containing battle information, When answering about battle details: make sure the output order includes name, date, and result columns.",
            "When the question asks for specific columns \"name\", \"date\", and \"result\": include only those exact columns in the output.",
            "When the question asks for specific columns \"name\", \"date\", and \"result\", When the amends specify to remove a column from the SELECT list: eliminate that unnecessary column from the output to match the required behavior."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, date FROM battles;",
            "SELECT name, date, result FROM battle;",
            "SELECT name, date FROM battle;"
        ],
        "rule_sql": [
            "SELECT name, date, result FROM battle;"
        ]
    },
    "494": {
        "db_id": "battle_death",
        "question": "What is maximum and minimum death toll caused each time?",
        "ground_truth": "SELECT max(killed) ,  min(killed) FROM death",
        "amends": [
            "Do reference `max(killed)` and `min(killed)` instead of `MAX(death_toll)` and `MIN(death_toll)` for the aggregate functions. Do query from table `death` instead of table `events` as the data source. Do remove the `GROUP BY event_id` clause instead of including it, as the query should return overall maximum and minimum values rather than per-event aggregates. The amended query now correctly calculates the global maximum and minimum killed values from the death table without unnecessary grouping."
        ],
        "rules": [
            "When the question asks for maximum and minimum death toll: use \"max(killed)\" and \"min(killed)\" as the aggregate functions instead of \"MAX(death_toll)\" and \"MIN(death_toll)\".",
            "When querying for death toll information: use the \"death\" table as the data source instead of the \"events\" table.",
            "When the question asks for maximum and minimum death toll, When querying for death toll information, When calculating overall maximum and minimum values: do not include any GROUP BY clause, as the aggregates should be computed across all rows rather than per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(death_toll), MIN(death_toll) FROM events GROUP BY event_id;",
            "SELECT MAX(killed) AS max_death_toll, MIN(killed) AS min_death_toll FROM death;"
        ],
        "rule_sql": [
            "SELECT MAX(killed) AS max_death_toll, MIN(killed) AS min_death_toll FROM death;"
        ]
    },
    "495": {
        "db_id": "battle_death",
        "question": "What is the average number of injuries caused each time?",
        "ground_truth": "SELECT avg(injured) FROM death",
        "amends": [
            "Do reference the `death` table instead of the `incidents` table. Do aggregate the `injured` column instead of the `injuries` column. Do remove the `WHERE injuries > 0` filter instead of keeping it. The amended query now correctly calculates the average of injured individuals from the death table without unnecessary filtering."
        ],
        "rules": [
            "When answering about \"average number of injuries\": use the \"injured\" column from the \"death\" table instead of the \"injuries\" column from the \"incidents\" table.",
            "When calculating the average: compute the average of all values in the \"injured\" column without applying any filter for positive values.",
            "When answering about \"average number of injuries\", When calculating the average, When referencing the table: use the \"death\" table as the source table instead of the \"incidents\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(injuries) FROM incidents WHERE injuries > 0;",
            "SELECT AVG(injured) AS average_injuries FROM death;"
        ],
        "rule_sql": [
            "SELECT AVG(injured) AS average_injuries FROM death;"
        ]
    },
    "496": {
        "db_id": "battle_death",
        "question": "What are the death and injury situations caused by the ship with tonnage 't'?",
        "ground_truth": "SELECT T1.killed ,  T1.injured FROM death AS T1 JOIN ship AS t2 ON T1.caused_by_ship_id  =  T2.id WHERE T2.tonnage  =  't'",
        "amends": [
            "Do select specific columns `T1.killed` and `T1.injured` instead of using `SELECT *`. Do join tables `death AS T1` and `ship AS t2` with an `INNER JOIN` on `T1.caused_by_ship_id = T2.id` instead of querying only the `accidents` table. Do filter on `T2.tonnage = 't'` in the `WHERE` clause instead of filtering `tonnage` directly from a single table. The amended query now correctly retrieves accident data by joining related tables and filtering based on ship tonnage, matching the intended behavior."
        ],
        "rules": [
            "When answering about death and injury situations: make sure the output order: T1.killed, T1.injured",
            "When the question mentions \"ship with tonnage 't'\": filter rows where T2.tonnage = 't' exactly",
            "When combining death and ship tables: link rows where T1.caused_by_ship_id = T2.id and keep only matching pairs (inner match)",
            "When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms",
            "When answering about death and injury situations, When the question mentions \"ship with tonnage 't'\", When combining death and ship tables, When choosing identifier delimiters, When handling text literals: do not change case, spacing, or punctuation of 't'"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM accidents WHERE tonnage = 't';",
            "SELECT T1.killed, T1.injured FROM death AS T1 INNER JOIN ship AS T2 ON T1.caused_by_ship_id = T2.id WHERE T2.tonnage = 't'"
        ],
        "rule_sql": [
            "SELECT T1.killed, T1.injured FROM death T1 INNER JOIN ship T2 ON T1.caused_by_ship_id = T2.id WHERE T2.tonnage = 't'"
        ]
    },
    "497": {
        "db_id": "battle_death",
        "question": "What are the name and results of the battles when the bulgarian commander is not 'Boril'",
        "ground_truth": "SELECT name ,  RESULT FROM battle WHERE bulgarian_commander != 'Boril'",
        "amends": [
            "Do select `RESULT` instead of `results` and use table `battle` instead of `battles`. Do change the filter to `bulgarian_commander != 'Boril'` instead of `commander = 'Boril' AND nationality = 'Bulgarian'`, removing the nationality condition entirely. The amended query now correctly excludes battles where Boril was the Bulgarian commander rather than selecting only those where he commanded with Bulgarian nationality."
        ],
        "rules": [
            "When the question asks for battle results: use the exact column name \"RESULT\" instead of \"results\".",
            "When referring to the battles table: use the exact table name \"battle\" instead of \"battles\".",
            "When filtering for Bulgarian commander not being 'Boril': use the exact condition \"bulgarian_commander != 'Boril'\" and do not include any nationality condition.",
            "When the question asks for battle results, When referring to the battles table, When filtering for Bulgarian commander not being 'Boril', When selecting output columns: maintain the order \"name, RESULT\" as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, results FROM battles WHERE commander = 'Boril' AND nationality = 'Bulgarian';",
            "SELECT name, result FROM battle WHERE bulgarian_commander != 'Boril';"
        ],
        "rule_sql": [
            "SELECT name, result FROM battle WHERE bulgarian_commander != 'Boril';"
        ]
    },
    "498": {
        "db_id": "battle_death",
        "question": "What are the different ids and names of the battles that lost any 'Brig' type shipes?",
        "ground_truth": "SELECT DISTINCT T1.id ,  T1.name FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.ship_type  =  'Brig'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate battle records. Do select `T1.id` and `T1.name` instead of `battle_id` and `name` with explicit table aliases. Do join `ship AS T2` instead of querying only the `battles` table to access ship information. Do use `ON T1.id = T2.lost_in_battle` instead of filtering directly on `battles` to properly relate ships to battles they were lost in. Do filter on `T2.ship_type = 'Brig'` instead of `ship_type = 'Brig'` to correctly reference the ship table's column. Do remove the `result = 'lost'` filter instead of keeping it since the ship's presence in lost_in_battle already indicates the loss. The amended query now correctly identifies battles where Brig-type ships were lost by properly joining the relevant tables."
        ],
        "rules": [
            "When answering about battles that lost ships: join table battles as T1 with table ship as T2 using T1.id = T2.lost_in_battle to properly relate ships to battles they were lost in.",
            "When the question asks for \"different ids and names\": use DISTINCT to eliminate duplicate battle records.",
            "When selecting battle information: select T1.id and T1.name instead of generic battle_id and name with explicit table aliases.",
            "When filtering for 'Brig' type ships: filter on T2.ship_type = 'Brig' to correctly reference the ship table's column.",
            "When answering about battles that lost ships, When the question asks for \"different ids and names\", When selecting battle information, When filtering for 'Brig' type ships, When determining lost ships: do not use result = 'lost' filter since the ship's presence in lost_in_battle already indicates the loss."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT battle_id, name FROM battles WHERE ship_type = 'Brig' AND result = 'lost';",
            "SELECT DISTINCT T1.id, T1.name\nFROM battle AS T1\nJOIN ship AS T2 ON T1.id = T2.lost_in_battle\nWHERE T2.ship_type = 'Brig'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.id, T1.name\nFROM battle AS T1\nJOIN ship AS T2 ON T1.id = T2.lost_in_battle\nWHERE T2.ship_type = 'Brig'"
        ]
    },
    "499": {
        "db_id": "battle_death",
        "question": "What are the ids and names of the battles that led to more than 10 people killed in total.",
        "ground_truth": "SELECT T1.id ,  T1.name FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle JOIN death AS T3 ON T2.id  =  T3.caused_by_ship_id GROUP BY T1.id HAVING sum(T3.killed)  >  10",
        "amends": [
            "Do select `T1.id` and `T1.name` instead of `battle_id` and `battle_name`. Do use `FROM battle AS T1` with joins to `ship AS T2` and `death AS T3` instead of just `FROM battles`. Do add `JOIN ship AS T2 ON T1.id = T2.lost_in_battle` and `JOIN death AS T3 ON T2.id = T3.caused_by_ship_id` instead of no joins. Do add `GROUP BY T1.id` instead of omitting grouping. Do move the filter to `HAVING sum(T3.killed) > 10` instead of `WHERE killed > 10` to properly aggregate deaths per battle. The amended query now correctly calculates total deaths per battle by joining through ship relationships and aggregates the sum before filtering."
        ],
        "rules": [
            "When selecting battle identifiers and names: use \"T1.id\" and \"T1.name\" instead of \"battle_id\" and \"battle_name\".",
            "When calculating total deaths per battle: join \"battle AS T1\" with \"ship AS T2\" using \"T1.id = T2.lost_in_battle\" and then join with \"death AS T3\" using \"T2.id = T3.caused_by_ship_id\" to establish the relationship chain.",
            "When aggregating deaths across multiple ships: group the results by \"T1.id\" to get per-battle totals.",
            "When selecting battle identifiers and names, When calculating total deaths per battle, When aggregating deaths across multiple ships, When filtering for battles with more than 10 total deaths: apply the condition \"sum(T3.killed) > 10\" after aggregation using HAVING instead of WHERE."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT battle_id, battle_name FROM battles WHERE killed > 10;",
            "SELECT T1.id, T1.name\nFROM battle AS T1\nJOIN ship AS T2 ON T1.id = T2.lost_in_battle\nJOIN death AS T3 ON T2.id = T3.caused_by_ship_id\nGROUP BY T1.id\nHAVING SUM(T3.killed) > 10"
        ],
        "rule_sql": [
            "SELECT T1.id, T1.name\nFROM battle AS T1\nJOIN ship AS T2 ON T1.id = T2.lost_in_battle\nJOIN death AS T3 ON T2.id = T3.caused_by_ship_id\nGROUP BY T1.id\nHAVING SUM(T3.killed) > 10"
        ]
    },
    "500": {
        "db_id": "battle_death",
        "question": "What is the ship id and name that caused most total injuries?",
        "ground_truth": "SELECT T2.id ,  T2.name FROM death AS T1 JOIN ship AS t2 ON T1.caused_by_ship_id  =  T2.id GROUP BY T2.id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.id` and `T2.name` instead of `ship_id` and `name`. Do use `FROM death AS T1 JOIN ship AS t2` instead of `FROM ships`. Do add `ON T1.caused_by_ship_id = T2.id` join condition instead of omitting it. Do add `GROUP BY T2.id` instead of omitting grouping. Do order by `count(*) DESC` instead of `total_injuries DESC`. The amended query now correctly identifies the ship with the most deaths by joining death records to ship data and counting occurrences, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"ship id and name that caused most total injuries\": make sure the output order: T2.id, T2.name.",
            "When the question mentions \"ship id\" and \"name\": \"ship id\" actually means \"T2.id in schema\" and \"name\" actually means \"T2.name in schema\".",
            "When combining death AS T1 and ship AS T2 for shared entities: link rows where T1.caused_by_ship_id = T2.id exactly as shown; keep only matching pairs (inner match).",
            "When the question asks for \"most total injuries\" (which means deaths): organize results by T2.id and compute count(*) per group.",
            "When answering about \"ship id and name that caused most total injuries\", When the question mentions \"ship id\" and \"name\", When combining death AS T1 and ship AS T2 for shared entities, When the question asks for \"most total injuries\" (which means deaths), When the question mentions \"most\" or \"highest\": rank rows by count(*) in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ship_id, name FROM ships ORDER BY total_injuries DESC LIMIT 1;",
            "SELECT T2.id, T2.name\nFROM death AS T1\nJOIN ship AS T2 ON T1.caused_by_ship_id = T2.id\nGROUP BY T2.id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.id, T2.name\nFROM death AS T1\nINNER JOIN ship AS T2 ON T1.caused_by_ship_id = T2.id\nGROUP BY T2.id, T2.name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "501": {
        "db_id": "battle_death",
        "question": "What are the distinct battle names which are between bulgarian commander 'Kaloyan' and latin commander 'Baldwin I'?",
        "ground_truth": "SELECT name FROM battle WHERE bulgarian_commander  =  'Kaloyan' AND latin_commander  =  'Baldwin I'",
        "amends": [
            "Do select `name` from the `battle` table instead of `battle_name` from `battles`. Do use filter conditions `bulgarian_commander = 'Kaloyan'` and `latin_commander = 'Baldwin I'` instead of `commander1 = 'Kaloyan'` and `commander2 = 'Baldwin I'`. Do remove `DISTINCT` instead of keeping it since the query now correctly references the proper table structure and column names. The amended query now matches the intended behavior of filtering battles by specific commanders from different factions."
        ],
        "rules": [
            "When the question asks for battle names: use the column \"name\" from the \"battle\" table instead of \"battle_name\" from \"battles\".",
            "When filtering for bulgarian commander 'Kaloyan': use the condition \"bulgarian_commander = 'Kaloyan'\" exactly as specified.",
            "When filtering for latin commander 'Baldwin I': use the condition \"latin_commander = 'Baldwin I'\" exactly as specified.",
            "When the question asks for battle names, When filtering for bulgarian commander 'Kaloyan', When filtering for latin commander 'Baldwin I', When the question asks for distinct battle names: do not use DISTINCT since the query correctly references the proper table structure and column names without needing deduplication."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT battle_name FROM battles WHERE commander1 = 'Kaloyan' AND commander2 = 'Baldwin I';",
            "SELECT name FROM battle WHERE bulgarian_commander = 'Kaloyan' AND latin_commander = 'Baldwin I'"
        ],
        "rule_sql": [
            "SELECT name FROM battle WHERE bulgarian_commander = 'Kaloyan' AND latin_commander = 'Baldwin I'"
        ]
    },
    "502": {
        "db_id": "battle_death",
        "question": "How many different results are there for the battles?",
        "ground_truth": "SELECT count(DISTINCT RESULT) FROM battle",
        "amends": [
            "Do `count(DISTINCT RESULT)` instead of `COUNT(*)` to count distinct result values rather than all rows. Do reference table `battle` instead of `battles` to use the correct table name. The amended query now correctly counts distinct battle results from the proper table."
        ],
        "rules": [
            "When the question asks for \"different results\" or \"distinct results\": count the number of unique values in the \"RESULT\" column.",
            "When counting distinct values: use the exact column name \"RESULT\" as shown in the schema.",
            "When the question asks for \"different results\" or \"distinct results\", When counting distinct values, When referencing the table containing battle information: use the exact table name \"battle\" (not \"battles\") as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM battles;",
            "SELECT COUNT(DISTINCT result) FROM battle;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT result) FROM battle;"
        ]
    },
    "503": {
        "db_id": "battle_death",
        "question": "How many battles did not lose any ship with tonnage '225'?",
        "ground_truth": "SELECT count(*) FROM battle WHERE id NOT IN ( SELECT lost_in_battle FROM ship WHERE tonnage  =  '225' );",
        "amends": [
            "Do reference the `battle` table instead of `battles` in the FROM clause. Do use a subquery with `NOT IN` filtering on `id` against `lost_in_battle` values from the `ship` table instead of a direct `WHERE ship_tonnage != '225'` filter. Do check for ships with `tonnage = '225'` in the subquery instead of comparing battle attributes directly. Do remove the incorrect `ship_tonnage` column reference since this attribute belongs to ships rather than battles. The amended query now correctly counts battles where no ship of 225 tonnage was lost, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"battles that did not lose any ship with tonnage '225'\": use the \"battle\" table instead of \"battles\" as the main data source.",
            "When counting battles where no ship of 225 tonnage was lost: use a subquery with NOT IN filtering on battle id against lost_in_battle values from the ship table.",
            "When checking for ships with specific tonnage: verify ships with tonnage = '225' exactly (preserving the literal value) in the subquery instead of comparing battle attributes directly.",
            "When answering about \"battles that did not lose any ship with tonnage '225'\", When counting battles where no ship of 225 tonnage was lost, When checking for ships with specific tonnage, When referencing ship attributes: do not use ship_tonnage column reference from the battle table since this attribute belongs to ships rather than battles."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM battles WHERE ship_tonnage != '225';",
            "SELECT COUNT(*) \nFROM battle \nWHERE id NOT IN (\n    SELECT lost_in_battle \n    FROM ship \n    WHERE tonnage = '225'\n)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM battle \nWHERE id NOT IN (\n    SELECT lost_in_battle \n    FROM ship \n    WHERE tonnage = '225'\n)"
        ]
    },
    "504": {
        "db_id": "battle_death",
        "question": "List the name and date the battle that has lost the ship named 'Lettice' and the ship named 'HMS Atalanta'",
        "ground_truth": "SELECT T1.name ,  T1.date FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.name  =  'Lettice' INTERSECT SELECT T1.name ,  T1.date FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.name  =  'HMS Atalanta'",
        "amends": [
            "Do join `battle AS T1` with `ship AS T2` on `T1.id = T2.lost_in_battle` instead of querying only the `battles` table. Do filter for ships named `'Lettice'` in one branch and `'HMS Atalanta'` in another instead of incorrectly applying both conditions to the same `ship_lost` column. Do use `INTERSECT` to find battles where both ships were lost instead of using `AND` with impossible conditions. Do select from properly aliased tables `T1.name` and `T1.date` instead of unqualified column names. The amended query now correctly identifies battles where both specified ships were lost by using proper table joins and set intersection logic."
        ],
        "rules": [
            "When answering about battles where multiple specific ships were lost: join the battle table (as T1) with the ship table (as T2) using the key relationship T1.id = T2.lost_in_battle to connect battles to the ships lost in them.",
            "When filtering for ships with exact names 'Lettice' and 'HMS Atalanta': create separate conditions for each ship name using the exact literals 'Lettice' and 'HMS Atalanta' with proper case and spacing.",
            "When finding battles where both specific ships were lost: use set intersection logic instead of AND conditions on the same column, since a single battle cannot have multiple ship_lost values simultaneously.",
            "When answering about battles where multiple specific ships were lost, When filtering for ships with exact names 'Lettice' and 'HMS Atalanta', When finding battles where both specific ships were lost, When selecting battle information: use qualified column references T1.name and T1.date from the battle table (T1) rather than unqualified column names."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, date FROM battles WHERE ship_lost = 'Lettice' AND ship_lost = 'HMS Atalanta'",
            "SELECT T1.name, T1.date\nFROM battle AS T1\nJOIN ship AS T2 ON T1.id = T2.lost_in_battle\nWHERE T2.name = 'Lettice'\nINTERSECT\nSELECT T1.name, T1.date\nFROM battle AS T1\nJOIN ship AS T2 ON T1.id = T2.lost_in_battle\nWHERE T2.name = 'HMS Atalanta'"
        ],
        "rule_sql": [
            "SELECT T1.name, T1.date\nFROM battle T1\nJOIN ship T2 ON T1.id = T2.lost_in_battle\nWHERE T2.name = 'Lettice'\nINTERSECT\nSELECT T1.name, T1.date\nFROM battle T1\nJOIN ship T2 ON T1.id = T2.lost_in_battle\nWHERE T2.name = 'HMS Atalanta'"
        ]
    },
    "505": {
        "db_id": "battle_death",
        "question": "Show names, results and bulgarian commanders of the battles with no ships lost in the 'English Channel'.",
        "ground_truth": "SELECT name ,  RESULT ,  bulgarian_commander FROM battle EXCEPT SELECT T1.name ,  T1.result ,  T1.bulgarian_commander FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.location  =  'English Channel'",
        "amends": [
            "Do use `EXCEPT` to exclude records instead of a simple `WHERE` filter. Do change the table name to `battle` instead of `battles`. Do add a join with `ship` table on `T1.id = T2.lost_in_battle` instead of omitting this relationship. Do move the location filter to the `ship` table condition `T2.location = 'English Channel'` instead of applying it directly to the battle table. Do remove the `ships_lost = 0` condition instead of keeping it, as the EXCEPT operation now properly handles the exclusion logic. The amended query now correctly excludes battles where ships were lost in the English Channel, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks about battles with no ships lost: use EXCEPT operation to exclude battles where ships were lost instead of a simple WHERE filter.",
            "When referring to the battles table: use the exact table name \"battle\" instead of \"battles\".",
            "When combining battle and ship information: join tables where T1.id = T2.lost_in_battle to link ships to the battles they were lost in.",
            "When filtering for location 'English Channel': apply the condition T2.location = 'English Channel' to the ship table instead of the battle table.",
            "When the question asks about battles with no ships lost, When referring to the battles table, When combining battle and ship information, When filtering for location 'English Channel', When determining ships lost: remove the ships_lost = 0 condition since the EXCEPT operation properly handles the exclusion logic for battles where ships were lost."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, result, bulgarian_commander FROM battles WHERE location = 'English Channel' AND ships_lost = 0;",
            "SELECT name, result, bulgarian_commander FROM battle\nEXCEPT\nSELECT T1.name, T1.result, T1.bulgarian_commander FROM battle T1\nJOIN ship T2 ON T1.id = T2.lost_in_battle\nWHERE T2.location = 'English Channel'"
        ],
        "rule_sql": [
            "SELECT name, result, bulgarian_commander FROM battle\nEXCEPT\nSELECT b.name, b.result, b.bulgarian_commander\nFROM battle b\nJOIN ship s ON b.id = s.lost_in_battle\nWHERE s.location = 'English Channel'"
        ]
    },
    "506": {
        "db_id": "battle_death",
        "question": "What are the notes of the death events which has substring 'East'?",
        "ground_truth": "SELECT note FROM death WHERE note LIKE '%East%'",
        "amends": [
            "Do reference the `note` column instead of `notes` in the SELECT list. Do query from the `death` table instead of `death_events` as the FROM source. Do filter on `note LIKE '%East%'` instead of `location LIKE '%East%'` in the WHERE clause. The amended query now correctly retrieves notes containing 'East' from the appropriate table and column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for \"notes\" of death events: use the exact column name \"note\" from the death table instead of \"notes\".",
            "When querying death events: use the \"death\" table instead of \"death_events\" as the data source.",
            "When the question asks for \"notes\" of death events, When querying death events, When filtering for events containing 'East': apply the filter condition \"note LIKE '%East%'\" instead of filtering on location columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT notes FROM death_events WHERE location LIKE '%East%';",
            "SELECT note FROM death WHERE note LIKE '%East%'"
        ],
        "rule_sql": [
            "SELECT note FROM death WHERE note LIKE '%East%'"
        ]
    },
    "507": {
        "db_id": "student_transcripts_tracking",
        "question": "what are all the addresses including line 1 and line 2?",
        "ground_truth": "SELECT line_1 ,  line_2 FROM addresses",
        "amends": [
            "Do select `line_1` and `line_2` columns instead of `address_line1`. Do add `line_2` instead of omitting it. The amended query now correctly retrieves both address line components as specified in the target output."
        ],
        "rules": [
            "When the question asks for \"addresses including line 1 and line 2\": select both \"line_1\" and \"line_2\" columns from the Addresses table.",
            "When the question specifies \"all the addresses\": return all rows from the Addresses table without filtering.",
            "When the question asks for \"addresses including line 1 and line 2\", When the question specifies \"all the addresses\", When the question mentions \"line 1\" and \"line 2\": these correspond exactly to the \"line_1\" and \"line_2\" column names in the Addresses table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT address_line1 FROM addresses;",
            "SELECT line_1, line_2 FROM Addresses;"
        ],
        "rule_sql": [
            "SELECT line_1, line_2 FROM Addresses;"
        ]
    },
    "508": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the first and second line for all addresses?",
        "ground_truth": "SELECT line_1 ,  line_2 FROM addresses",
        "amends": [
            "Do select `line_1` and `line_2` instead of `first_line` and `second_line` to use the correct column names from the addresses table schema. Do maintain the same WHERE filter condition `id = 1 OR id = 2` to retrieve the specific address records. The amended query now correctly references the actual column names while preserving the same record selection behavior.",
            "Do use lowercase `addresses` instead of uppercase `Addresses` for the table name. Do remove the `WHERE address_id = 1 OR address_id = 2` filter instead of keeping it, as the right query selects all records from the addresses table without any filtering conditions. The amended query now matches RIGHT_SQL's behavior by returning all address lines without restrictions."
        ],
        "rules": [
            "When the question mentions \"first line\" for addresses: use the exact column name \"line_1\" from the addresses table.",
            "When the question mentions \"second line\" for addresses: use the exact column name \"line_2\" from the addresses table.",
            "When the question mentions \"first line\" for addresses, When the question mentions \"second line\" for addresses, When the question asks for specific address records with IDs 1 and 2: maintain the filter condition id = 1 OR id = 2 to retrieve only those specific records.",
            "When referring to the addresses table: use lowercase \"addresses\" instead of uppercase \"Addresses\" for the table name.",
            "When referring to the addresses table, When the question asks for all addresses without filtering conditions: do not apply any WHERE clause filters like \"address_id = 1 OR address_id = 2\" and return all records from the addresses table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_line, second_line FROM addresses WHERE id = 1 OR id = 2;",
            "SELECT line_1, line_2 FROM Addresses WHERE address_id = 1 OR address_id = 2",
            "SELECT line_1, line_2 FROM addresses"
        ],
        "rule_sql": [
            "SELECT line_1, line_2 FROM addresses;"
        ]
    },
    "509": {
        "db_id": "student_transcripts_tracking",
        "question": "How many courses in total are listed?",
        "ground_truth": "SELECT count(*) FROM Courses",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS total_courses FROM Courses;"
        ]
    },
    "510": {
        "db_id": "student_transcripts_tracking",
        "question": "How many courses are there?",
        "ground_truth": "SELECT count(*) FROM Courses",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Courses;"
        ]
    },
    "511": {
        "db_id": "student_transcripts_tracking",
        "question": "How is the math course described?",
        "ground_truth": "SELECT course_description FROM Courses WHERE course_name  =  'math'",
        "amends": [
            "Do select `course_description` instead of `description` to reference the correct column name. Do reference table `Courses` with proper capitalization instead of `courses` to match the actual table name. Do use filter `'math'` with lowercase instead of `'Math'` to ensure case-sensitive matching works correctly. The amended query now correctly retrieves the course description from the Courses table where the course name matches 'math' exactly as specified in the RIGHT_SQL."
        ],
        "rules": [
            "When the question asks for a course description: use the exact column name \"course_description\" from the Courses table.",
            "When filtering by course name: use the exact literal value 'math' (lowercase) for case-sensitive matching.",
            "When the question asks for a course description, When filtering by course name, When referencing the Courses table: use the exact table name \"Courses\" with proper capitalization."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description FROM courses WHERE course_name = 'Math';",
            "SELECT course_description FROM Courses WHERE course_name = 'math';"
        ],
        "rule_sql": [
            "SELECT course_description FROM Courses WHERE course_name = 'math';"
        ]
    },
    "512": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the descriptions for all the math courses?",
        "ground_truth": "SELECT course_description FROM Courses WHERE course_name  =  'math'",
        "amends": [
            "Do select `course_description` instead of `*` from the SELECT list. Do reference table `Courses` instead of `courses` in the FROM clause. Do filter on `course_name = 'math'` instead of `subject = 'math'` in the WHERE clause. The amended query now correctly retrieves only the course description for math courses from the properly referenced Courses table."
        ],
        "rules": [
            "When answering about \"descriptions for math courses\": make sure the output order: course_description.",
            "When the question mentions \"math courses\": \"math\" actually means \"course_name = 'math'\" in schema.",
            "When selecting from the courses table: reference the table as \"Courses\" (with exact case and quotes) instead of \"courses\".",
            "When answering about \"descriptions for math courses\", When the question mentions \"math courses\", When selecting from the courses table, When filtering for specific courses: use the exact literal value 'math' (lowercase) for the course_name condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM courses WHERE subject = 'math';",
            "SELECT course_description FROM Courses WHERE course_name = 'math'"
        ],
        "rule_sql": [
            "SELECT course_description FROM \"Courses\" WHERE course_name = 'math'"
        ]
    },
    "513": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the zip code of the address in the city Port Chelsea?",
        "ground_truth": "SELECT zip_postcode FROM Addresses WHERE city  =  'Port Chelsea'",
        "amends": [
            "Do reference column `zip_postcode` instead of `zip_code` and table `Addresses` instead of `addresses` while maintaining the same filter condition `city = 'Port Chelsea'` without any changes to the WHERE clause, join logic, or other query components, confirming the amended query now correctly retrieves postal codes from the Addresses table."
        ],
        "rules": [
            "When the question asks for \"zip code\": use the exact column token \"zip_postcode\" from the Addresses table instead of \"zip_code\".",
            "When referencing the table containing address information: use the exact table name \"Addresses\" (with capital A) instead of \"addresses\".",
            "When the question asks for \"zip code\", When referencing the table containing address information, When filtering for the city \"Port Chelsea\": maintain the exact literal value 'Port Chelsea' with the same case and spacing in the condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT zip_code FROM addresses WHERE city = 'Port Chelsea';",
            "SELECT zip_postcode FROM Addresses WHERE city = 'Port Chelsea';"
        ],
        "rule_sql": [
            "SELECT zip_postcode FROM Addresses WHERE city = 'Port Chelsea';"
        ]
    },
    "514": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the zip code for Port Chelsea?",
        "ground_truth": "SELECT zip_postcode FROM Addresses WHERE city  =  'Port Chelsea'",
        "amends": [
            "Do select `zip_postcode` instead of `zip_code` from the `Addresses` table instead of the `cities` table, and filter on `city = 'Port Chelsea'` instead of `city_name = 'Port Chelsea'`. The amended query now correctly retrieves postal codes from the appropriate address table using the correct column names."
        ],
        "rules": [
            "When the question asks for \"zip code\": use the exact column \"zip_postcode\" from the \"Addresses\" table.",
            "When filtering for city \"Port Chelsea\": use the exact literal 'Port Chelsea' with the column \"city\" from the \"Addresses\" table.",
            "When the question asks for \"zip code\", When filtering for city \"Port Chelsea\", When selecting from the database: use the \"Addresses\" table instead of any \"cities\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT zip_code FROM cities WHERE city_name = 'Port Chelsea';",
            "SELECT zip_postcode FROM Addresses WHERE city = 'Port Chelsea';"
        ],
        "rule_sql": [
            "SELECT zip_postcode FROM Addresses WHERE city = 'Port Chelsea';"
        ]
    },
    "515": {
        "db_id": "student_transcripts_tracking",
        "question": "Which department offers the most number of degrees? List department name and id.",
        "ground_truth": "SELECT T2.department_name ,  T1.department_id FROM Degree_Programs AS T1 JOIN Departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T1.department_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `Departments` as `T2` instead of omitting it, and use `Degree_Programs` as `T1` instead of `degrees`. Do specify `T2.department_name` and `T1.department_id` in the SELECT list instead of `department_name` and `department_id` without table aliases. Do use `JOIN` with `ON T1.department_id = T2.department_id` instead of querying only the degrees table. Do group by `T1.department_id` instead of `department_id` without table qualification. Do order by `count(*)` instead of `degree_count` alias. The amended query now correctly joins department information and matches the intended behavior.",
            "Do remove `COUNT(*) as degree_count` from the SELECT list instead of including it, and do remove the alias from `Departments T2` instead of keeping it as `T2`. Do change the GROUP BY clause to include only `T1.department_id` instead of including additional columns, and do ensure the ORDER BY uses `count(*)` (lowercase) instead of `COUNT(*)` (uppercase). The amended query now correctly returns only the department name and ID without the count aggregation in the SELECT list while maintaining the same grouping and ordering logic to identify the department with the most degree programs."
        ],
        "rules": [
            "When answering about \"most number of degrees per department\": make sure the output order: department name, department id, count of degrees.",
            "When the question mentions \"department\": use \"T2.department_name\" for department name and \"T1.department_id\" for department id.",
            "When combining Degree_Programs as T1 and Departments as T2: link rows where T1.department_id = T2.department_id and keep only matching pairs (inner match).",
            "When counting degrees per department: count using all rows from T1 (Degree_Programs) grouped by T1.department_id.",
            "When answering about \"most number of degrees per department\", When the question mentions \"department\", When combining Degree_Programs as T1 and Departments as T2, When counting degrees per department, When the question asks for \"most number of degrees\": rank departments by count of degrees in descending order and keep only the top 1 row.",
            "When answering about \"which department offers the most number of degrees\": make sure the output order: department_name, department_id.",
            "When the question asks for \"most number of degrees\": rank departments by count of degree programs in descending order and keep the first 1 row.",
            "When counting degree programs: compute the number of rows using the canonical key T1.department_id.",
            "When combining Degree_Programs T1 and Departments T2: link rows where T1.department_id = T2.department_id and keep only matching pairs (inner match).",
            "When grouping by department: organize results by T1.department_id and compute count per group.",
            "When answering about \"which department offers the most number of degrees\", When the question asks for \"most number of degrees\", When counting degree programs, When combining Degree_Programs T1 and Departments T2, When grouping by department, When producing output: do not include the count aggregation in the SELECT list, only include department_name and department_id."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department_name, department_id, COUNT(*) as degree_count \nFROM degrees \nGROUP BY department_id \nORDER BY degree_count DESC \nLIMIT 1;",
            "SELECT T2.department_name, T1.department_id, COUNT(*) as degree_count\nFROM Degree_Programs T1\nJOIN Departments T2 ON T1.department_id = T2.department_id\nGROUP BY T1.department_id\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT T2.department_name, T1.department_id\nFROM Degree_Programs T1\nJOIN Departments T2 ON T1.department_id = T2.department_id\nGROUP BY T1.department_id\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.department_name, T1.department_id\nFROM Degree_Programs T1\nINNER JOIN Departments T2 ON T1.department_id = T2.department_id\nGROUP BY T1.department_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "516": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the name and id of the department with the most number of degrees ?",
        "ground_truth": "select t2.department_name ,  t1.department_id from degree_programs as t1 join departments as t2 on t1.department_id  =  t2.department_id group by t1.department_id order by count(*) desc limit 1",
        "amends": [
            "Do join `degree_programs as t1` with `departments as t2` on `t1.department_id = t2.department_id` instead of querying only the `departments` table. Do add `GROUP BY t1.department_id` to aggregate by department instead of omitting grouping. Do use `count(*)` to count all degree programs instead of `COUNT(degrees)` which references an undefined column. Do select `t2.department_name` and `t1.department_id` from the joined tables instead of selecting columns directly from a single table. The amended query now correctly counts degree programs per department and returns the department with the most programs, matching the intended behavior.",
            "Do remove `COUNT(*) as degree_count` from the SELECT list instead of including it, and do move the `COUNT(*)` expression to the ORDER BY clause instead of keeping it in SELECT. Do keep `t2.department_name` and `t1.department_id` in SELECT instead of removing them. Do maintain the same FROM clause with `JOIN` on `t1.department_id = t2.department_id` instead of changing it. Do preserve the GROUP BY on `t1.department_id` instead of modifying it. Do change ORDER BY to use `COUNT(*) desc` instead of `degree_count DESC` to properly sort by the aggregate count. Do keep LIMIT 1 instead of changing it. The amended query now correctly returns the department with the most degree programs by counting records in the grouping rather than selecting the count value."
        ],
        "rules": [
            "When answering about \"department with the most number of degrees\": join degree_programs as T1 with departments as T2 on T1.department_id = T2.department_id using inner match.",
            "When counting degree programs per department: use count(*) to count all rows in T1 grouped by T1.department_id.",
            "When selecting department information: output T2.department_name and T1.department_id from the joined tables.",
            "When answering about \"department with the most number of degrees\", When counting degree programs per department, When selecting department information, When finding the department with the most degrees: order results by the count in descending order and keep only the top 1 row.",
            "When counting degree programs per department: use COUNT(*) to count the number of rows in each group instead of selecting the count value in the output.",
            "When ordering by the count of degree programs: use COUNT(*) DESC in the ORDER BY clause instead of referencing an alias from the SELECT list.",
            "When selecting department information: include t2.department_name and t1.department_id in the output columns.",
            "When grouping by department: use GROUP BY t1.department_id to organize results by department identifier.",
            "When finding the department with the most degrees: use LIMIT 1 to return only the top result after ordering by count in descending order.",
            "When counting degree programs per department, When ordering by the count of degree programs, When selecting department information, When grouping by department, When finding the department with the most degrees, When joining Degree_Programs and Departments: link tables using t1.department_id = t2.department_id to match department records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department_name, department_id FROM departments ORDER BY COUNT(degrees) DESC LIMIT 1;",
            "SELECT t2.department_name, t1.department_id, COUNT(*) as degree_count\nFROM Degree_Programs as t1\nJOIN Departments as t2 ON t1.department_id = t2.department_id\nGROUP BY t1.department_id\nORDER BY degree_count DESC\nLIMIT 1;",
            "SELECT t2.department_name, t1.department_id\nFROM Degree_Programs AS t1\nJOIN Departments AS t2 ON t1.department_id = t2.department_id\nGROUP BY t1.department_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT t2.department_name, t1.department_id\nFROM Degree_Programs t1\nINNER JOIN Departments t2 ON t1.department_id = t2.department_id\nGROUP BY t1.department_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "517": {
        "db_id": "student_transcripts_tracking",
        "question": "How many departments offer any degree?",
        "ground_truth": "SELECT count(DISTINCT department_id) FROM Degree_Programs",
        "amends": [
            "Do count `DISTINCT department_id` from the `Degree_Programs` table instead of counting all rows from the `departments` table. Do remove the `WHERE degree IS NOT NULL` filter instead of keeping it, as the distinct count inherently handles null values appropriately. The amended query now correctly counts unique department IDs from the Degree_Programs table, matching the intended behavior."
        ],
        "rules": [
            "When counting departments that offer degrees: count distinct \"department_id\" values from the \"Degree_Programs\" table instead of counting all rows from the \"departments\" table.",
            "When counting departments that offer degrees, When handling null values in degree programs: do not apply a \"degree IS NOT NULL\" filter as the distinct count inherently handles null values appropriately."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM departments WHERE degree IS NOT NULL;",
            "SELECT COUNT(DISTINCT department_id) FROM Degree_Programs;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT department_id) FROM Degree_Programs;"
        ]
    },
    "518": {
        "db_id": "student_transcripts_tracking",
        "question": "How many different departments offer degrees?",
        "ground_truth": "SELECT count(DISTINCT department_id) FROM Degree_Programs",
        "amends": [
            "Do select `count(DISTINCT department_id)` instead of `COUNT(*)` to count unique departments rather than all rows. Do query from `Degree_Programs` table instead of `departments` to access the correct source data. Do remove the `WHERE degree_offered = 'yes'` filter instead of keeping it since the Degree_Programs table inherently contains only degree-offering programs. The amended query now correctly counts distinct department IDs from the appropriate table without needing explicit filtering."
        ],
        "rules": [
            "When counting different departments: count distinct values of \"department_id\" instead of counting all rows.",
            "When accessing degree-offering data: use the \"Degree_Programs\" table instead of the \"departments\" table, as it inherently contains only degree-offering programs.",
            "When counting different departments, When accessing degree-offering data, When filtering for degree-offering programs: do not apply a WHERE clause with \"degree_offered = 'yes'\" since the Degree_Programs table already contains only relevant programs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM departments WHERE degree_offered = 'yes';",
            "SELECT COUNT(DISTINCT department_id) FROM Degree_Programs;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT department_id) AS department_count FROM Degree_Programs;"
        ]
    },
    "519": {
        "db_id": "student_transcripts_tracking",
        "question": "How many different degree names are offered?",
        "ground_truth": "SELECT count(DISTINCT degree_summary_name) FROM Degree_Programs",
        "amends": [
            "Do select `count(DISTINCT degree_summary_name)` instead of `COUNT(*)` to count distinct degree names rather than all rows. Do query from `Degree_Programs` instead of `degrees` to use the correct table source. The amended query now correctly counts unique degree program names from the appropriate table, matching the intended behavior."
        ],
        "rules": [
            "When counting different degree names: count distinct values of \"degree_summary_name\" column.",
            "When the question asks about degree names: use the \"Degree_Programs\" table as the source.",
            "When counting different degree names, When the question asks about degree names, When selecting from Degree_Programs table: use the exact identifier \"Degree_Programs\" with proper case and no quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM degrees;",
            "SELECT COUNT(DISTINCT degree_summary_name) FROM Degree_Programs;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT degree_summary_name) FROM Degree_Programs;"
        ]
    },
    "520": {
        "db_id": "student_transcripts_tracking",
        "question": "How many different degrees are offered?",
        "ground_truth": "SELECT count(DISTINCT degree_summary_name) FROM Degree_Programs",
        "amends": [
            "Do select `count(DISTINCT degree_summary_name)` instead of `COUNT(*)`. Do query from `Degree_Programs` instead of `degrees`. The amended query now correctly counts distinct degree summary names from the Degree_Programs table instead of counting all rows from the degrees table."
        ],
        "rules": [
            "When answering about \"different degrees offered\": count distinct values of \"degree_summary_name\" column.",
            "When querying for degree information: use the \"Degree_Programs\" table instead of \"degrees\" table.",
            "When answering about \"different degrees offered\", When querying for degree information, When counting distinct values: use the exact column token \"degree_summary_name\" with DISTINCT operation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM degrees;",
            "SELECT COUNT(DISTINCT degree_summary_name) FROM Degree_Programs;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT degree_summary_name) FROM Degree_Programs;"
        ]
    },
    "521": {
        "db_id": "student_transcripts_tracking",
        "question": "How many degrees does the engineering department offer?",
        "ground_truth": "SELECT count(*) FROM Departments AS T1 JOIN Degree_Programs AS T2 ON T1.department_id  =  T2.department_id WHERE T1.department_name  =  'engineer'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM departments WHERE department_name = 'engineering';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS degree_count FROM Degree_Programs dp JOIN Departments d ON dp.department_id = d.department_id WHERE d.department_name = 'engineering';"
        ]
    },
    "522": {
        "db_id": "student_transcripts_tracking",
        "question": "How many degrees does the engineering department have?",
        "ground_truth": "SELECT count(*) FROM Departments AS T1 JOIN Degree_Programs AS T2 ON T1.department_id  =  T2.department_id WHERE T1.department_name  =  'engineer'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM departments WHERE department_name = 'engineering';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS degree_count\nFROM Degree_Programs dp\nJOIN Departments d ON dp.department_id = d.department_id\nWHERE d.department_name = 'Engineering';"
        ]
    },
    "523": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the names and descriptions of all the sections?",
        "ground_truth": "SELECT section_name ,  section_description FROM Sections",
        "amends": [
            "Do use `section_name` and `section_description` instead of `name` and `description` for column selection. Do reference the table as `Sections` instead of `sections` for proper case sensitivity. Do remove the `WHERE id > 100` filter instead of keeping it, as the right query retrieves all records without filtering. The amended query now correctly selects all section names and descriptions from the Sections table without unnecessary filtering."
        ],
        "rules": [
            "When answering about \"names and descriptions of all sections\": make sure the output order: section_name, section_description.",
            "When the question mentions \"names\": \"names\" actually means \"section_name in schema\".",
            "When the question mentions \"descriptions\": \"descriptions\" actually means \"section_description in schema\".",
            "When the question asks for \"all sections\": retrieve all records without any filtering conditions.",
            "When answering about \"names and descriptions of all sections\", When the question mentions \"names\", When the question mentions \"descriptions\", When the question asks for \"all sections\", When referencing the table containing sections: use the exact identifier \"Sections\" with proper case sensitivity as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, description FROM sections WHERE id > 100;",
            "SELECT section_name, section_description FROM Sections;"
        ],
        "rule_sql": [
            "SELECT section_name, section_description FROM Sections;"
        ]
    },
    "524": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the names and descriptions for all the sections?",
        "ground_truth": "SELECT section_name ,  section_description FROM Sections",
        "amends": [
            "Do use `section_name` and `section_description` instead of `name` and `description` for the column selection. Do reference the table as `Sections` instead of `sections` for proper case sensitivity. Do remove the `WHERE id > 0` filter instead of keeping it, as the right query retrieves all records without filtering. The amended query now correctly selects all section names and descriptions from the Sections table without unnecessary filtering."
        ],
        "rules": [
            "When selecting columns from the Sections table: use \"section_name\" and \"section_description\" instead of \"name\" and \"description\".",
            "When referencing the Sections table: use \"Sections\" with proper case sensitivity instead of \"sections\".",
            "When selecting columns from the Sections table, When referencing the Sections table, When retrieving all records from a table: do not apply any WHERE filter like \"id > 0\" unless explicitly required by the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, description FROM sections WHERE id > 0",
            "SELECT section_name, section_description FROM Sections;"
        ],
        "rule_sql": [
            "SELECT section_name, section_description FROM Sections;"
        ]
    },
    "525": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the names and id of courses having at most 2 sections?",
        "ground_truth": "SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  2",
        "amends": [
            "Do use explicit table aliases `T1.course_name` and `T1.course_id` instead of bare column names `course_id, name`. Do add a `JOIN` to the `Sections` table `AS T2` instead of omitting it. Do use the correct join condition `T1.course_id = T2.course_id` instead of the incorrect `COUNT(sections)` filter. Do move the count filter to `HAVING count(*) <= 2` instead of placing it in the `WHERE` clause. Do add `GROUP BY T1.course_id` instead of omitting the grouping. The amended query now correctly counts sections per course and filters courses with two or fewer sections, matching the intended behavior.",
            "Do maintain the same `SELECT` list with `course_name, course_id` instead of changing the column order from `course_id, course_name`. Do keep the same `FROM` clause with `JOIN Sections AS T2` on `T1.course_id = T2.course_id` instead of altering the join condition. Do preserve the identical `GROUP BY T1.course_id` and `HAVING count(*) <= 2` clauses instead of modifying the aggregation logic. The amended query now correctly maintains the original behavior while fixing only the column ordering in the SELECT clause to match the RIGHT_SQL's output structure."
        ],
        "rules": [
            "When answering about courses and their sections: combine tables \"courses\" as T1 and \"Sections\" as T2 using the exact join condition T1.course_id = T2.course_id, keeping only matching pairs (inner match).",
            "When the question asks for courses with \"at most 2 sections\": organize results by T1.course_id and compute count of sections per course, then filter to keep only groups where count(*) <= 2.",
            "When selecting output columns: use explicit table aliases T1.course_id and T1.course_name instead of bare column names.",
            "When grouping results: include GROUP BY T1.course_id to ensure proper aggregation by course.",
            "When answering about courses and their sections, When the question asks for courses with \"at most 2 sections\", When selecting output columns, When grouping results, When filtering aggregated results: place the count filter count(*) <= 2 in the HAVING clause instead of the WHERE clause.",
            "When answering about \"names and id of courses having at most 2 sections\": make sure the output order: course_name, course_id",
            "When combining Courses as T1 and Sections as T2: link rows where T1.course_id = T2.course_id and keep only matching pairs (inner match)",
            "When grouping by course: organize results by T1.course_id and compute requested aggregates per group",
            "When answering about \"names and id of courses having at most 2 sections\", When combining Courses as T1 and Sections as T2, When grouping by course, When counting sections per course: compute the number of rows using the join relationship and ensure the count is less than or equal to 2"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_id, name FROM courses WHERE COUNT(sections) <= 2;",
            "SELECT T1.course_id, T1.course_name\nFROM Courses AS T1\nJOIN Sections AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_id\nHAVING COUNT(*) <= 2",
            "SELECT T1.course_name, T1.course_id\nFROM Courses AS T1\nJOIN Sections AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_id\nHAVING COUNT(*) <= 2"
        ],
        "rule_sql": [
            "SELECT T1.course_name, T1.course_id\nFROM Courses AS T1\nINNER JOIN Sections AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_id\nHAVING COUNT(*) <= 2\nORDER BY T1.course_name, T1.course_id"
        ]
    },
    "526": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the names and ids of every course with less than 2 sections?",
        "ground_truth": "SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  2",
        "amends": [
            "Do select `T1.course_name` and `T1.course_id` with explicit table aliases instead of `course_id` and `name` without table qualification. Do join `Sections AS T2` on `T1.course_id = T2.course_id` instead of querying only the `courses` table. Do group by `T1.course_id` and use `HAVING count(*) <= 2` to filter courses with at most two sections instead of using `WHERE section_count > 2` to filter courses with more than two sections. The amended query now correctly identifies courses with exactly two or fewer sections by counting actual section records rather than relying on a potentially incorrect section_count column.",
            "Do maintain the same `SELECT` list order with `course_name` first instead of `course_id` first, though this is purely cosmetic. Do keep the same `FROM` source with `Courses AS T1` and the same `JOIN` type with `Sections AS T2` on the same predicate `T1.course_id = T2.course_id`. Do preserve the identical `GROUP BY T1.course_id` and `HAVING COUNT(*) <= 2` clause. The amended query now matches RIGHT_SQL's behavior with only insignificant formatting differences."
        ],
        "rules": [
            "When answering about course names and ids: make sure the output order: T1.course_id, T1.course_name.",
            "When the question mentions \"course with less than 2 sections\": this means courses having at most 2 sections, requiring counting actual section records rather than using a section_count column.",
            "When combining Courses as T1 and Sections as T2: link rows where T1.course_id = T2.course_id and keep only matching pairs (inner match).",
            "When counting sections per course: group by T1.course_id and count the number of section records using count(*).",
            "When answering about course names and ids, When the question mentions \"course with less than 2 sections\", When combining Courses as T1 and Sections as T2, When counting sections per course, When filtering for courses with less than 2 sections: use having count(*) <= 2 to include courses with exactly two or fewer sections.",
            "When answering about \"names and ids of every course with less than 2 sections\": make sure the output order: course_name first, then course_id.",
            "When combining Courses (T1) and Sections (T2) for shared entities: link rows where T1.course_id = T2.course_id and keep only matching pairs (inner match).",
            "When the question asks for courses with \"less than 2 sections\": organize results by T1.course_id and compute the count of sections per course, keeping only those groups where the count is less than or equal to 2.",
            "When answering about \"names and ids of every course with less than 2 sections\", When combining Courses (T1) and Sections (T2) for shared entities, When the question asks for courses with \"less than 2 sections\", When counting sections per course: use the canonical key T1.course_id for grouping and count all matching rows from T2."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_id, name FROM courses WHERE section_count > 2;",
            "SELECT T1.course_id, T1.course_name\nFROM Courses AS T1\nJOIN Sections AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_id\nHAVING COUNT(*) <= 2",
            "SELECT T1.course_name, T1.course_id\nFROM Courses AS T1\nJOIN Sections AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_id\nHAVING COUNT(*) <= 2"
        ],
        "rule_sql": [
            "SELECT T1.course_name, T1.course_id\nFROM Courses T1\nINNER JOIN Sections T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_id\nHAVING COUNT(*) <= 2\nORDER BY T1.course_name, T1.course_id"
        ]
    },
    "527": {
        "db_id": "student_transcripts_tracking",
        "question": "List the section_name in reversed lexicographical order.",
        "ground_truth": "SELECT section_name FROM Sections ORDER BY section_name DESC",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT section_name FROM sections ORDER BY section_name ASC;"
        ],
        "rule_sql": [
            "SELECT section_name FROM Sections ORDER BY section_name DESC;"
        ]
    },
    "528": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the names of the sections in reverse alphabetical order?",
        "ground_truth": "SELECT section_name FROM Sections ORDER BY section_name DESC",
        "amends": [
            "Do select `section_name` instead of `name` from the `Sections` table instead of `sections`. Do order by `section_name DESC` instead of `name ASC`."
        ],
        "rules": [
            "When selecting section names from the Sections table: use the exact column name \"section_name\" instead of \"name\".",
            "When ordering sections in reverse alphabetical order: sort by \"section_name\" in descending order instead of ascending order.",
            "When selecting section names from the Sections table, When ordering sections in reverse alphabetical order, When referring to the table containing section information: use the exact table name \"Sections\" instead of \"sections\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM sections ORDER BY name ASC;",
            "SELECT section_name FROM Sections ORDER BY section_name DESC;"
        ],
        "rule_sql": [
            "SELECT section_name FROM Sections ORDER BY section_name DESC;"
        ]
    },
    "529": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the semester which most student registered in? Show both the name and the id.",
        "ground_truth": "SELECT T1.semester_name ,  T1.semester_id FROM Semesters AS T1 JOIN Student_Enrolment AS T2 ON T1.semester_id  =  T2.semester_id GROUP BY T1.semester_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `s` and `r`. Do reference `T1.semester_name` and `T1.semester_id` in SELECT instead of unqualified `semester_name` and `semester_id`. Do join `Semesters AS T1` with `Student_Enrolment AS T2` instead of `students s` with `registrations r`. Do use join condition `T1.semester_id = T2.semester_id` instead of `s.student_id = r.student_id`. Do remove the `COUNT(*) as student_count` column from SELECT instead of including it. Do GROUP BY only `T1.semester_id` instead of both `semester_name` and `semester_id`. Do ORDER BY `count(*) DESC` instead of `student_count DESC`. The amended query now correctly identifies the semester with the most student enrollments by joining the appropriate tables and counting enrollments per semester."
        ],
        "rules": [
            "When answering about \"the semester which most student registered in\": make sure the output order: T1.semester_name, T1.semester_id",
            "When combining Semesters as T1 and Student_Enrolment as T2: link rows where T1.semester_id = T2.semester_id and keep only matching pairs (inner match)",
            "When the question asks for \"most student registered\": count the number of rows using T2.semester_id as the counting key per semester group",
            "When grouping by semester: organize results by T1.semester_id only instead of both semester_name and semester_id",
            "When ranking to find the semester with most registrations: rank rows by count(*) in descending order and keep the first 1 row",
            "When answering about \"the semester which most student registered in\", When combining Semesters as T1 and Student_Enrolment as T2, When the question asks for \"most student registered\", When grouping by semester, When ranking to find the semester with most registrations, When producing output: do not include the count column in the final result, only show T1.semester_name and T1.semester_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT semester_name, semester_id, COUNT(*) as student_count\nFROM students s\nJOIN registrations r ON s.student_id = r.student_id\nGROUP BY semester_name, semester_id\nORDER BY student_count DESC\nLIMIT 1;",
            "SELECT T1.semester_name, T1.semester_id\nFROM Semesters AS T1\nJOIN Student_Enrolment AS T2 ON T1.semester_id = T2.semester_id\nGROUP BY T1.semester_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.semester_name, T1.semester_id\nFROM Semesters AS T1\nINNER JOIN Student_Enrolment AS T2 ON T1.semester_id = T2.semester_id\nGROUP BY T1.semester_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "530": {
        "db_id": "student_transcripts_tracking",
        "question": "For each semester, what is the name and id of the one with the most students registered?",
        "ground_truth": "SELECT T1.semester_name ,  T1.semester_id FROM Semesters AS T1 JOIN Student_Enrolment AS T2 ON T1.semester_id  =  T2.semester_id GROUP BY T1.semester_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of no aliases. Do reference `T1.semester_name` and `T1.semester_id` in SELECT instead of `semester_id, semester_name`. Do remove the `student_count` alias and aggregate function instead of keeping them. Do join with `Student_Enrolment AS T2` instead of `registrations`. Do use `ON T1.semester_id = T2.semester_id` instead of `semesters.semester_id = registrations.semester_id`. Do remove `semester_name` from GROUP BY instead of including it. Do use `ORDER BY count(*) DESC` instead of `ORDER BY student_count DESC`. The amended query now correctly identifies the semester with the most student enrollments by counting records in the Student_Enrolment table rather than using a potentially incorrect registrations table.",
            "Do place `T1.semester_name` before `T1.semester_id` in the SELECT list instead of the reverse order. Do maintain the same FROM clause with `JOIN` on `T1.semester_id = T2.semester_id` instead of changing it. Do keep the `GROUP BY T1.semester_id` and `ORDER BY count(*) DESC LIMIT 1` unchanged as they correctly identify the semester with the highest enrollment count. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [
            "When answering about \"semester with the most students registered\": make sure the output order: T1.semester_id, T1.semester_name",
            "When the question mentions \"most students registered\": count the number of enrollment records using T2.semester_id as the counting key",
            "When combining T1 and T2 for shared entities: link rows where T1.semester_id = T2.semester_id and keep only matching pairs (inner match)",
            "When organizing results by semester: group by T1.semester_id only",
            "When ranking semesters by enrollment count: order by count(*) in descending direction and keep only the first row (top result)",
            "When answering about \"semester with the most students registered\", When the question mentions \"most students registered\", When combining T1 and T2 for shared entities, When organizing results by semester, When ranking semesters by enrollment count, When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms",
            "When answering about \"the one with the most students registered\": rank semesters by enrollment count in descending order and keep only the first 1 row.",
            "When combining Semesters and Student_Enrolment tables: link rows where T1.semester_id = T2.semester_id and keep only matching pairs (inner match).",
            "When counting students registered: compute the number of rows using the enrollment records.",
            "When answering about \"the one with the most students registered\", When combining Semesters and Student_Enrolment tables, When counting students registered, When producing output columns: place T1.semester_name before T1.semester_id in the result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT semester_id, semester_name, COUNT(student_id) as student_count\nFROM semesters\nJOIN registrations ON semesters.semester_id = registrations.semester_id\nGROUP BY semester_id, semester_name\nORDER BY student_count DESC\nLIMIT 1;",
            "SELECT T1.semester_id, T1.semester_name\nFROM Semesters AS T1\nJOIN Student_Enrolment AS T2 ON T1.semester_id = T2.semester_id\nGROUP BY T1.semester_id\nORDER BY count(*) DESC\nLIMIT 1;",
            "SELECT T1.semester_name, T1.semester_id\nFROM Semesters AS T1\nJOIN Student_Enrolment AS T2 ON T1.semester_id = T2.semester_id\nGROUP BY T1.semester_id\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.semester_name, T1.semester_id\nFROM Semesters T1\nINNER JOIN Student_Enrolment T2 ON T1.semester_id = T2.semester_id\nGROUP BY T1.semester_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "531": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the description of the department whose name has the substring the computer?",
        "ground_truth": "SELECT department_description FROM Departments WHERE department_name LIKE '%computer%'",
        "amends": [
            "Do reference `department_description` in the SELECT list instead of `description`. Do reference `Departments` as the FROM source instead of `departments`. Do filter on `department_name LIKE '%computer%'` instead of `name LIKE '%computer%'`. The amended query now correctly matches the intended table structure and column names to produce the expected results."
        ],
        "rules": [
            "When the question asks for \"description of the department\": use the exact column token \"department_description\" instead of \"description\".",
            "When referencing the departments table: use the exact table name \"Departments\" with proper capitalization.",
            "When filtering for department names containing \"computer\": use the exact column token \"department_name\" with the pattern '%computer%' to find substring matches.",
            "When the question asks for \"description of the department\", When referencing the departments table, When filtering for department names containing \"computer\", When answering about department descriptions: make sure the output order contains only the department_description column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description FROM departments WHERE name LIKE '%computer%';",
            "SELECT department_description FROM Departments WHERE department_name LIKE '%computer%'"
        ],
        "rule_sql": [
            "SELECT department_description FROM Departments WHERE department_name LIKE '%computer%'"
        ]
    },
    "532": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the department description for the one whose name has the word computer?",
        "ground_truth": "SELECT department_description FROM Departments WHERE department_name LIKE '%computer%'",
        "amends": [
            "Do reference `department_description` instead of `description` in the SELECT list. Do use `department_name` instead of `name` in the WHERE filter condition. Do capitalize the table name as `Departments` instead of `departments` for consistency with the schema. The amended query now correctly retrieves department descriptions by filtering on department names containing 'computer'."
        ],
        "rules": [
            "When selecting department description information: use \"department_description\" as the output column instead of \"description\".",
            "When filtering by department name containing the word \"computer\": use \"department_name\" as the filter column instead of \"name\".",
            "When referencing the departments table: use the exact table name \"Departments\" with proper capitalization instead of \"departments\".",
            "When selecting department description information, When filtering by department name containing the word \"computer\", When referencing the departments table, When searching for names containing the word \"computer\": use the pattern '%computer%' to match any text containing that word."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description FROM departments WHERE name LIKE '%computer%';",
            "SELECT department_description FROM Departments WHERE department_name LIKE '%computer%'"
        ],
        "rule_sql": [
            "SELECT department_description FROM Departments WHERE department_name LIKE '%computer%'"
        ]
    },
    "533": {
        "db_id": "student_transcripts_tracking",
        "question": "Who are enrolled in 2 degree programs in one semester? List the first name, middle name and last name and the id.",
        "ground_truth": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2",
        "amends": [
            "Do add `Student_Enrolment` table with `JOIN` on `T1.student_id = T2.student_id` instead of omitting it. Do change the aggregation to group by `T1.student_id` instead of `semester`. Do move the count condition to `HAVING count(*) = 2` instead of placing it in `WHERE COUNT(degree_program) = 2`. Do remove the `degree_program` column reference and use `count(*)` instead. Do add table aliases `T1` and `T2` with proper qualification instead of using unqualified column names. The amended query now correctly identifies students with exactly two enrollments by joining the enrollment table and using proper aggregation with HAVING clause.",
            "Do include only `T1.student_id` in the GROUP BY clause instead of grouping by both `s.student_id` and `se.semester_id`. Do use `count(*) = 2` in the HAVING clause instead of `COUNT(DISTINCT se.degree_program_id) = 2` to count total enrollment records rather than distinct degree programs. Do remove the unnecessary `se.semester_id` from the GROUP BY since the aggregation logic focuses on student-level enrollment counts rather than semester-based degree program analysis. The amended query now correctly identifies students with exactly two enrollment records regardless of semester or degree program, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about students enrolled in 2 degree programs: make sure to join the Student_Enrolment table using T1.student_id = T2.student_id instead of using only the students table.",
            "When grouping for enrollment counts: group by T1.student_id instead of semester.",
            "When filtering for exactly 2 enrollments: use HAVING count(*) = 2 instead of WHERE COUNT(degree_program) = 2.",
            "When counting enrollments: use count(*) instead of count(degree_program).",
            "When answering about students enrolled in 2 degree programs, When grouping for enrollment counts, When filtering for exactly 2 enrollments, When counting enrollments, When using multiple tables: add table aliases T1 and T2 with proper qualification instead of using unqualified column names.",
            "When grouping students by their enrollment records: use only \"T1.student_id\" in the grouping clause, not additional columns like semester_id.",
            "When counting enrollment records for students: use count(*) = 2 to count total enrollment records rather than counting distinct degree programs.",
            "When grouping students by their enrollment records, When counting enrollment records for students, When the question asks about students enrolled in 2 degree programs: interpret this as students having exactly two enrollment records total across all semesters and degree programs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, middle_name, last_name, student_id \nFROM students \nWHERE COUNT(degree_program) = 2 \nGROUP BY semester;",
            "SELECT s.first_name, s.middle_name, s.last_name, s.student_id\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nGROUP BY s.student_id, se.semester_id\nHAVING COUNT(DISTINCT se.degree_program_id) = 2",
            "SELECT s.first_name, s.middle_name, s.last_name, s.student_id\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nGROUP BY s.student_id\nHAVING COUNT(*) = 2"
        ],
        "rule_sql": [
            "SELECT s.first_name, s.middle_name, s.last_name, s.student_id\nFROM Students s\nJOIN Student_Enrolment T1 ON s.student_id = T1.student_id\nJOIN Student_Enrolment T2 ON s.student_id = T2.student_id\nWHERE T1.student_enrolment_id != T2.student_enrolment_id\nGROUP BY s.student_id\nHAVING COUNT(*) = 2"
        ]
    },
    "534": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the first, middle, and last names, along with the ids, of all students who enrolled in 2 degree programs in one semester?",
        "ground_truth": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2",
        "amends": [
            "Do use `T1.student_id` instead of `s.id` in the SELECT list and GROUP BY clause. Do reference `Student_Enrolment AS T2` instead of `enrollments e` as the joined table. Do use `count(*) = 2` instead of `COUNT(DISTINCT e.degree_program_id) = 2` in the HAVING clause to count enrollment records rather than distinct degree programs. Do remove the `DISTINCT` modifier from the count aggregation instead of including it. The amended query now correctly counts the number of enrollment records per student rather than distinct degree programs, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about students who enrolled in 2 degree programs: use T1.student_id instead of s.id in both SELECT list and GROUP BY clause.",
            "When joining with enrollment data: reference Student_Enrolment as T2 instead of enrollments e.",
            "When counting enrollment records per student: use count(*) = 2 instead of COUNT(DISTINCT e.degree_program_id) = 2 to count enrollment records rather than distinct degree programs.",
            "When answering about students who enrolled in 2 degree programs, When joining with enrollment data, When counting enrollment records per student, When aggregating enrollment counts: remove the DISTINCT modifier from the count aggregation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.first_name, s.middle_name, s.last_name, s.id\nFROM students s\nJOIN enrollments e ON s.id = e.student_id\nGROUP BY s.id\nHAVING COUNT(DISTINCT e.degree_program_id) = 2;",
            "SELECT s.first_name, s.middle_name, s.last_name, s.student_id\nFROM Students s\nJOIN Student_Enrolment T2 ON s.student_id = T2.student_id\nGROUP BY s.student_id, s.first_name, s.middle_name, s.last_name\nHAVING count(*) = 2"
        ],
        "rule_sql": [
            "SELECT s.first_name, s.middle_name, s.last_name, T1.student_id\nFROM Students s\nJOIN Student_Enrolment T1 ON s.student_id = T1.student_id\nGROUP BY T1.student_id\nHAVING count(*) = 2"
        ]
    },
    "535": {
        "db_id": "student_transcripts_tracking",
        "question": "Who is enrolled in a Bachelor degree program? List the first name, middle name, last name.",
        "ground_truth": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do change the `FROM` clause to use explicit table aliases `Students AS T1` instead of just `students`. Do add `JOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id` and `JOIN Degree_Programs AS T3 ON T2.degree_program_id = T3.degree_program_id` instead of querying only the students table. Do change the `WHERE` filter to `T3.degree_summary_name = 'Bachelor'` instead of `degree_program = 'Bachelor'` to properly reference the joined degree programs table. The amended query now correctly joins through the enrollment relationship to identify bachelor's degree students and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"Who is enrolled in a Bachelor degree program?\": make sure the output order: first_name, middle_name, last_name.",
            "When the question mentions \"Bachelor\": \"Bachelor\" actually means \"degree_summary_name = 'Bachelor'\" in schema.",
            "When combining T1 (Students) and T2 (Student_Enrolment) for shared entities: link rows where T1.student_id = T2.student_id and keep only matching pairs (inner match).",
            "When combining T2 (Student_Enrolment) and T3 (Degree_Programs) for shared entities: link rows where T2.degree_program_id = T3.degree_program_id and keep only matching pairs (inner match).",
            "When answering about \"Who is enrolled in a Bachelor degree program?\", When the question mentions \"Bachelor\", When combining T1 (Students) and T2 (Student_Enrolment) for shared entities, When combining T2 (Student_Enrolment) and T3 (Degree_Programs) for shared entities, When listing student names: use DISTINCT to ensure each student appears only once in the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, middle_name, last_name FROM students WHERE degree_program = 'Bachelor'",
            "SELECT DISTINCT T1.first_name, T1.middle_name, T1.last_name\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nJOIN Degree_Programs AS T3 ON T2.degree_program_id = T3.degree_program_id\nWHERE T3.degree_summary_name = 'Bachelor'"
        ],
        "rule_sql": [
            "SELECT DISTINCT s.first_name, s.middle_name, s.last_name\nFROM Students s\nINNER JOIN Student_Enrolment se ON s.student_id = se.student_id\nINNER JOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nWHERE dp.degree_summary_name = 'Bachelor';"
        ]
    },
    "536": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the first, middle, and last names for everybody enrolled in a Bachelors program?",
        "ground_truth": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do change the FROM clause to include `Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id = T3.degree_program_id` instead of just `students`. Do change the WHERE filter to `T3.degree_summary_name = 'Bachelor'` instead of `program = 'Bachelors'`. Do add table aliases `T1.` prefix to all columns instead of using unqualified column names. The amended query now correctly filters students enrolled in Bachelor programs through proper table relationships rather than relying on a potentially incorrect program field."
        ],
        "rules": [
            "When answering about \"everybody enrolled in a Bachelors program\": make sure the output order: T1.first_name, T1.middle_name, T1.last_name.",
            "When the question mentions \"Bachelors program\": \"Bachelors\" actually means \"T3.degree_summary_name = 'Bachelor'\" in schema.",
            "When combining tables for student enrollment information: link rows where T1.student_id = T2.student_id and T2.degree_program_id = T3.degree_program_id; keep only matching pairs (inner match).",
            "When selecting names from multiple students: use DISTINCT to ensure each person appears only once in the results.",
            "When answering about \"everybody enrolled in a Bachelors program\", When the question mentions \"Bachelors program\", When combining tables for student enrollment information, When selecting names from multiple students, When referring to table columns: always use the exact table aliases T1. for Students table columns, T2. for Student_Enrolment table columns, and T3. for Degree_Programs table columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, middle_name, last_name FROM students WHERE program = 'Bachelors';",
            "SELECT DISTINCT T1.first_name, T1.middle_name, T1.last_name\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nJOIN Degree_Programs AS T3 ON T2.degree_program_id = T3.degree_program_id\nWHERE T3.degree_summary_name = 'Bachelor'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.first_name, T1.middle_name, T1.last_name\nFROM Students T1\nINNER JOIN Student_Enrolment T2 ON T1.student_id = T2.student_id\nINNER JOIN Degree_Programs T3 ON T2.degree_program_id = T3.degree_program_id\nWHERE T3.degree_summary_name = 'Bachelor'\nORDER BY T1.first_name, T1.middle_name, T1.last_name;"
        ]
    },
    "537": {
        "db_id": "student_transcripts_tracking",
        "question": "Find the kind of program which most number of students are enrolled in?",
        "ground_truth": "SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.degree_summary_name` instead of `program_type` and remove the `student_count` alias instead of keeping it. Do join `Degree_Programs AS T1` with `Student_Enrolment AS T2` on `T1.degree_program_id = T2.degree_program_id` instead of querying only the `students` table. Do group by `T1.degree_summary_name` instead of `program_type` and order by `count(*) DESC` instead of `student_count ASC` while keeping the `LIMIT 1`. The amended query now correctly identifies the most popular degree program by enrollment count rather than counting students by program type."
        ],
        "rules": [
            "When answering about \"the kind of program which most number of students are enrolled in\": use \"T1.degree_summary_name\" instead of \"program_type\" and do not include \"student_count\" alias in the output.",
            "When combining Degree_Programs and Student_Enrolment tables: link rows where \"T1.degree_program_id = T2.degree_program_id\" and keep only matching pairs (inner match).",
            "When grouping by program type: organize results by \"T1.degree_summary_name\" and count the number of enrollment records.",
            "When finding the most popular program: rank programs by enrollment count in descending order and keep only the top 1 result.",
            "When answering about \"the kind of program which most number of students are enrolled in\", When combining Degree_Programs and Student_Enrolment tables, When grouping by program type, When finding the most popular program, When counting students enrolled: compute the number of rows using the enrollment records from Student_Enrolment table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT program_type, COUNT(*) as student_count FROM students GROUP BY program_type ORDER BY student_count ASC LIMIT 1;",
            "SELECT T1.degree_summary_name\nFROM Degree_Programs AS T1\nJOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id\nGROUP BY T1.degree_summary_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.degree_summary_name\nFROM Degree_Programs T1\nINNER JOIN Student_Enrolment T2 ON T1.degree_program_id = T2.degree_program_id\nGROUP BY T1.degree_summary_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "538": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the degree summary name that has the most number of students enrolled?",
        "ground_truth": "SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.degree_summary_name` instead of `degree_summary_name` and remove the `student_count` alias instead of keeping it. Do join `Degree_Programs AS T1` with `Student_Enrolment AS T2` on `T1.degree_program_id = T2.degree_program_id` instead of querying `students` table directly without any joins. Do order by `count(*) DESC` instead of `student_count ASC` to find the most popular degree instead of the least popular. The amended query now correctly identifies the degree program with the highest enrollment count by joining the relevant tables and using descending order aggregation."
        ],
        "rules": [
            "When answering about \"degree summary name with most students enrolled\": make sure the output order: T1.degree_summary_name, count(*)",
            "When the question mentions \"most number of students enrolled\": rank rows by count(*) in descending direction and keep the first 1 row.",
            "When combining Degree_Programs AS T1 and Student_Enrolment AS T2: link rows where T1.degree_program_id = T2.degree_program_id; keep only matching pairs (inner match).",
            "When counting students enrolled: compute the number of rows using the join relationship between Degree_Programs and Student_Enrolment tables.",
            "When answering about \"degree summary name with most students enrolled\", When the question mentions \"most number of students enrolled\", When combining Degree_Programs AS T1 and Student_Enrolment AS T2, When counting students enrolled, When choosing identifier delimiters: do not replace unquoted identifiers with quoted forms unless specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT degree_summary_name, COUNT(*) as student_count FROM students GROUP BY degree_summary_name ORDER BY student_count ASC LIMIT 1;",
            "SELECT T1.degree_summary_name\nFROM Degree_Programs AS T1\nJOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id\nGROUP BY T1.degree_summary_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.degree_summary_name, COUNT(*) \nFROM Degree_Programs AS T1\nINNER JOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id\nGROUP BY T1.degree_summary_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "539": {
        "db_id": "student_transcripts_tracking",
        "question": "Find the program which most number of students are enrolled in. List both the id and the summary.",
        "ground_truth": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do specify `T1.degree_program_id` and `T1.degree_summary_name` instead of `program_id` and `summary`. Do add `FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id` instead of just `FROM programs`. Do add `GROUP BY T1.degree_program_id` instead of omitting it. Do use `count(*)` in the `ORDER BY` instead of `COUNT(student_id)`. The amended query now correctly joins the necessary tables, groups by program ID, and counts all enrolled students to identify the most popular degree program."
        ],
        "rules": [
            "When answering about \"most number of students enrolled in a program\": make sure the output order: T1.degree_program_id, T1.degree_summary_name.",
            "When combining Degree_Programs and Student_Enrolment tables: link rows where T1.degree_program_id = T2.degree_program_id and keep only matching pairs (inner match).",
            "When counting enrolled students per program: organize results by T1.degree_program_id and compute count(*) per group.",
            "When answering about \"most number of students enrolled in a program\", When combining Degree_Programs and Student_Enrolment tables, When counting enrolled students per program, When finding the program with most students: rank rows by count(*) in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT program_id, summary FROM programs ORDER BY COUNT(student_id) DESC LIMIT 1;",
            "SELECT T1.degree_program_id, T1.degree_summary_name\nFROM Degree_Programs AS T1\nJOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id\nGROUP BY T1.degree_program_id\nORDER BY count(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.degree_program_id, T1.degree_summary_name\nFROM Degree_Programs T1\nINNER JOIN Student_Enrolment T2 ON T1.degree_program_id = T2.degree_program_id\nGROUP BY T1.degree_program_id, T1.degree_summary_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "540": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the program id and the summary of the degree that has the most students enrolled?",
        "ground_truth": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.degree_program_id` and `T1.degree_summary_name` instead of `program_id` and `summary`. Do join `Degree_Programs AS T1` with `Student_Enrolment AS T2` on `T1.degree_program_id = T2.degree_program_id` instead of querying only the `degrees` table. Do add `GROUP BY T1.degree_program_id` to aggregate by program instead of omitting grouping. Do order by `count(*) DESC` to sort by actual student count instead of `enrolled_students DESC`. The amended query now correctly identifies the program with the most enrolled students by counting actual enrollment records rather than relying on a potentially incorrect stored count value."
        ],
        "rules": [
            "When answering about \"program id and summary of the degree with most students enrolled\": make sure the output order: T1.degree_program_id, T1.degree_summary_name.",
            "When the question mentions \"program id\": \"program id\" actually means \"T1.degree_program_id\" in schema.",
            "When the question mentions \"summary\": \"summary\" actually means \"T1.degree_summary_name\" in schema.",
            "When combining Degree_Programs AS T1 and Student_Enrolment AS T2 for shared entities: link rows where T1.degree_program_id = T2.degree_program_id; keep only matching pairs (inner match).",
            "When the question asks for \"most students enrolled\" and implies grouping by program: organize results by T1.degree_program_id and compute count(*) per group.",
            "When the question asks for \"the most students enrolled\": rank rows by count(*) in descending direction and keep the first 1 row.",
            "When answering about \"program id and summary of the degree with most students enrolled\", When the question mentions \"program id\", When the question mentions \"summary\", When combining Degree_Programs AS T1 and Student_Enrolment AS T2 for shared entities, When the question asks for \"most students enrolled\" and implies grouping by program, When the question asks for \"the most students enrolled\", When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT program_id, summary FROM degrees ORDER BY enrolled_students DESC LIMIT 1;",
            "SELECT T1.degree_program_id, T1.degree_summary_name\nFROM Degree_Programs AS T1\nJOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id\nGROUP BY T1.degree_program_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.degree_program_id, T1.degree_summary_name\nFROM Degree_Programs AS T1\nINNER JOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id\nGROUP BY T1.degree_program_id, T1.degree_summary_name\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "541": {
        "db_id": "student_transcripts_tracking",
        "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.",
        "ground_truth": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use `JOIN` on `T1.student_id = T2.student_id` instead of `LEFT JOIN` on `s.id = e.student_id`. Do reference `T1.student_id` instead of `s.id` in the SELECT list and GROUP BY. Do use `count(*)` instead of `COUNT(e.program_id)` for enrollment counting. Do reference `Student_Enrolment AS T2` instead of `enrollments e` as the join table. Do include `T1.student_id` in the SELECT list instead of `s.student_id`. The amended query now correctly counts enrollments using an inner join and proper column references to match the intended behavior.",
            "Do remove `T1.first_name`, `T1.middle_name`, and `T1.last_name` from the GROUP BY clause instead of including them, since they are functionally dependent on `T1.student_id`. Do change the ORDER BY to reference `count(*)` directly instead of using the alias `enrollment_count`, as the alias is not available at that point in query processing. The amended query now correctly groups only by the primary key and orders by the aggregate function directly, matching the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, as it must be present when used in GROUP BY. Do use the same column reference `T1.student_id` in both SELECT and GROUP BY instead of having inconsistent column usage. Do maintain the aggregate function `count(*)` without an alias instead of adding `AS enrollment_count`, as the RIGHT_SQL uses the unaliased version. The amended query now correctly includes all necessary columns for grouping and matches the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the GROUP BY column is properly included in the output while maintaining the same join condition using `T1.student_id = T2.student_id` and preserving the aggregation count with GROUP BY on `T1.student_id` and ORDER BY on `count(*) DESC` with LIMIT 1. The amended query now correctly includes all necessary columns and matches the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, as the GROUP BY clause groups by this column and it must be included in the selection. The amended query now correctly includes all necessary columns and matches the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the grouped column is properly included in the output while maintaining the same JOIN condition on `T1.student_id = T2.student_id`, GROUP BY on `T1.student_id`, ORDER BY on `count(*) DESC`, and LIMIT 1. The amended query now correctly includes all necessary columns and matches the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, as it must be included when using GROUP BY on that column to ensure proper aggregation behavior. The amended query now correctly includes all necessary columns in both SELECT and GROUP BY clauses to match the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the GROUP BY column is properly included in the output. The amended query now correctly includes all necessary columns while maintaining the same join condition, grouping, ordering, and limit behavior as the RIGHT_SQL.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the GROUP BY column is properly included in the output for consistency and clarity. The amended query now correctly includes all referenced columns in the SELECT clause while maintaining the same join logic, grouping, ordering, and limit behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the grouped column is properly included in the output while maintaining the same join condition using `JOIN` on `T1.student_id = T2.student_id` and grouping by `T1.student_id` with ordering by `count(*) DESC` and limiting to 1 result. The amended query now correctly includes all necessary columns while preserving the original logic and matching the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the GROUP BY column is properly included in the output while maintaining the same join condition using `T1.student_id = T2.student_id` and preserving the aggregation count with GROUP BY on `T1.student_id` and ORDER BY on `count(*) DESC` with LIMIT 1. The amended query now correctly includes all necessary columns and matches the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the grouped column is properly included in the output while maintaining the same join condition on `T1.student_id = T2.student_id` and preserving the GROUP BY on `T1.student_id` with ORDER BY `count(*) DESC` and LIMIT 1. The amended query now matches RIGHT_SQL's behavior by including the grouped column in the result set.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, as the GROUP BY clause groups by this column and it must be included in the selection. The amended query now correctly includes all necessary columns and matches the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the GROUP BY column is properly included in the output while maintaining the same join condition using `T1.student_id = T2.student_id` and preserving the aggregation count with GROUP BY on `T1.student_id` and ORDER BY on `count(*) DESC` with LIMIT 1. The amended query now matches RIGHT_SQL's behavior by including all necessary columns in the selection.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, as the GROUP BY clause groups by `T1.student_id` but the original SELECT list did not include this grouped column which would cause an error in strict SQL mode. The amended query now correctly includes all non-aggregated columns from the GROUP BY clause in the SELECT list, maintaining the same join condition, grouping, ordering, and limit behavior while fixing the column reference issue.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the grouped column is properly included in the output while maintaining the same JOIN condition on `T1.student_id = T2.student_id`, GROUP BY on `T1.student_id`, ORDER BY on `count(*) DESC`, and LIMIT 1. The amended query now correctly includes all necessary columns and matches the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the grouped column is properly included in the output while maintaining the same join condition using `JOIN` on `T1.student_id = T2.student_id`, the same grouping by `T1.student_id`, the same ordering by `count(*) DESC`, and the same limit of `1` record. The amended query now correctly includes all necessary columns in the SELECT clause while preserving the original logic and matching the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the GROUP BY column is properly included in the output while maintaining the same join condition using `JOIN` on `T1.student_id = T2.student_id` and grouping by `T1.student_id` with ordering by `count(*) DESC` and limiting to 1 result. The amended query now correctly includes all necessary columns while preserving the original logic and matching the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the grouped column is properly included in the output while maintaining the same join condition on `T1.student_id = T2.student_id` and preserving the grouping by `T1.student_id` with count aggregation and descending order by count with limit 1. The amended query now matches RIGHT_SQL's behavior by including the grouped column in the result set.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the grouped column is properly included in the output while maintaining the same join condition on `T1.student_id = T2.student_id` and preserving the GROUP BY on `T1.student_id` with ORDER BY `count(*) DESC` and LIMIT 1. The amended query now matches RIGHT_SQL's behavior by including the grouped column in the selection."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.id, s.first_name, s.middle_name, s.last_name, COUNT(e.program_id) as enrollment_count, s.student_id\nFROM students s\nLEFT JOIN enrollments e ON s.id = e.student_id\nGROUP BY s.id\nORDER BY enrollment_count DESC\nLIMIT 1;",
            "SELECT \n    T1.student_id,\n    T1.first_name,\n    T1.middle_name,\n    T1.last_name,\n    COUNT(*) AS enrollment_count,\n    T1.student_id\nFROM \n    Students AS T1\nJOIN \n    Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY \n    T1.student_id, T1.first_name, T1.middle_name, T1.last_name\nORDER BY \n    enrollment_count DESC\nLIMIT 1",
            "SELECT \n    T1.student_id,\n    T1.first_name,\n    T1.middle_name,\n    T1.last_name,\n    COUNT(*) AS enrollment_count\nFROM \n    Students AS T1\nJOIN \n    Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY \n    T1.student_id\nORDER BY \n    COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "542": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the first, middle, and last name, along with the id and number of enrollments, for the student who enrolled the most in any program?",
        "ground_truth": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `s` and `e` for consistency. Do reference `T1.student_id` in both SELECT and GROUP BY instead of `s.id` to match the actual column name. Do use `count(*)` instead of `COUNT(e.program_id)` to count all enrollments rather than just those with program_id values. Do include `T1.student_id` twice in the SELECT list instead of omitting the redundant inclusion. Do reference `Student_Enrolment` table instead of `enrollments` to use the correct table name. Do maintain the same join condition `T1.student_id = T2.student_id` instead of changing the join predicate. The amended query now correctly counts all student enrollments and matches the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` only once in the SELECT list instead of duplicating it twice. Do use `count(*)` directly in the ORDER BY clause instead of referencing the alias `enrollment_count`. Do remove the alias `enrollment_count` from the COUNT(*) expression instead of keeping it. The amended query now correctly returns the student with the highest enrollment count by ordering directly on the count value without redundant column duplication.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, as it is required for proper grouping and result display. Do maintain the same `JOIN` on `T1.student_id=T2.student_id` instead of changing the join condition. Do keep the `GROUP BY T1.student_id` and `ORDER BY count(*) DESC LIMIT 1` structure instead of altering the aggregation and ordering logic. The amended query now correctly includes all necessary columns while preserving the original join, grouping, and ranking behavior to match the right SQL's output.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, which ensures the grouped column is properly selected. Do use `AS` for table aliases instead of omitting the keyword, though this is a cosmetic difference. The amended query now correctly includes the grouped column in the output while maintaining the same join logic, grouping, ordering, and limit behavior.",
            "Do include `T1.student_id` twice in the SELECT list instead of omitting the second occurrence. Do maintain the same `JOIN` on `T1.student_id=T2.student_id` instead of changing it. Do preserve the `GROUP BY T1.student_id` instead of modifying it. Do keep the `ORDER BY count(*) DESC` and `LIMIT 1` unchanged instead of altering them. The amended query now correctly includes all required columns in the SELECT list while maintaining the same aggregation logic and result ordering.",
            "Do include `T1.student_id` twice in the SELECT list instead of omitting the second occurrence. Do maintain the same `JOIN` on `T1.student_id=T2.student_id` instead of changing it. Do preserve the `GROUP BY T1.student_id` instead of modifying it. Do keep the `ORDER BY count(*) DESC` and `LIMIT 1` unchanged instead of altering them. The amended query now correctly includes all required columns in the SELECT list while maintaining the same aggregation logic to identify the student with the most enrollments.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, and do remove the alias `enrollment_count` from the count expression instead of keeping it. The amended query now matches RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, as it is required for proper grouping and result display. Do maintain the same `JOIN` condition on `T1.student_id = T2.student_id` instead of changing it. Do preserve the `GROUP BY T1.student_id` clause instead of altering the grouping logic. Do keep the `ORDER BY count(*) DESC` and `LIMIT 1` structure instead of modifying the sorting and limiting behavior. The amended query now correctly includes all necessary columns in the SELECT list while maintaining the same join, grouping, and ordering logic to match the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, as it must be explicitly included when using GROUP BY. Do keep all other elements unchanged including the `JOIN` on `T1.student_id = T2.student_id`, `GROUP BY T1.student_id`, `ORDER BY count(*) DESC`, and `LIMIT 1`. The amended query now correctly includes the grouped column in the output and matches the right SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, which ensures the grouped column is properly selected alongside the aggregate count. The amended query now correctly preserves all original logic while ensuring the student_id is available in the result set, matching the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, as it must be present when using GROUP BY on that column. The amended query now correctly matches RIGHT_SQL's behavior by ensuring all non-aggregated columns in SELECT are either grouped or functionally dependent.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, as it is required for proper grouping and result display. Do use explicit table aliases with `AS` keyword for better readability instead of omitting the `AS` keyword. The amended query now correctly includes all necessary columns in both SELECT and GROUP BY clauses while maintaining the same aggregation logic and result ordering.",
            "Do include `T1.student_id` twice in the SELECT list instead of omitting the second occurrence. Do reduce the GROUP BY clause to only `T1.student_id` instead of including `T1.first_name, T1.middle_name, T1.last_name`. Do maintain the same `JOIN` condition on `T1.student_id = T2.student_id` and keep the `ORDER BY count(*) DESC` with `LIMIT 1`. The amended query now correctly groups only by student_id while selecting all required columns and matches the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, which ensures the GROUP BY column is properly projected in the results. The amended query now correctly displays all student information including the student_id alongside the enrollment count, maintaining the same logic of finding the student with the most enrollments while fixing the missing column projection.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, and do use `count(*)` without an alias instead of `COUNT(*) AS enrollment_count`. Do maintain the same `JOIN` on `T1.student_id = T2.student_id` and `GROUP BY T1.student_id` with `ORDER BY count(*) DESC LIMIT 1`. The amended query now correctly returns the student_id in the result set while preserving the aggregation logic to find the student with the highest enrollment count.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, which ensures the grouped student identifier is properly displayed alongside the count. The amended query now correctly preserves all original logic while adding the necessary student_id field to match the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, which ensures the grouped student identifier is properly returned alongside the count. The amended query now correctly preserves all original logic while including the necessary student_id field in the output, matching the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, which ensures the grouped student identifier is properly displayed alongside the count. The amended query now correctly preserves all original logic while adding the necessary student_id field to match the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, which ensures the grouped student identifier is properly displayed alongside the count. The amended query now correctly returns both the student details and their enrollment count while maintaining the same JOIN condition, GROUP BY logic, ORDER BY sorting, and LIMIT constraint, matching the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, which ensures the grouped student identifier is properly displayed alongside the count. The amended query now correctly preserves all original logic while adding the missing student_id column to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.first_name, s.middle_name, s.last_name, s.id, COUNT(e.program_id) as enrollment_count\nFROM students s\nJOIN enrollments e ON s.id = e.student_id\nGROUP BY s.id\nORDER BY enrollment_count DESC\nLIMIT 1;",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, T1.student_id, COUNT(*) AS enrollment_count\nFROM Students T1\nJOIN Student_Enrolment T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY enrollment_count DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) \nFROM Students T1\nJOIN Student_Enrolment T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) \nFROM Students T1\nJOIN Student_Enrolment T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) \nFROM Students AS T1 \nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id \nGROUP BY T1.student_id \nORDER BY COUNT(*) DESC \nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) \nFROM Students AS T1 \nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id \nGROUP BY T1.student_id \nORDER BY COUNT(*) DESC \nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) AS enrollment_count\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) \nFROM Students T1\nJOIN Student_Enrolment T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, COUNT(*) \nFROM Students AS T1 \nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id \nGROUP BY T1.student_id \nORDER BY COUNT(*) DESC \nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) \nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, COUNT(*) \nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) \nFROM Students T1\nJOIN Student_Enrolment T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, COUNT(*) AS enrollment_count\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id, T1.first_name, T1.middle_name, T1.last_name\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) \nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) AS enrollment_count\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "543": {
        "db_id": "student_transcripts_tracking",
        "question": "Which semesters do not have any student enrolled? List the semester name.",
        "ground_truth": "SELECT semester_name FROM Semesters WHERE semester_id NOT IN( SELECT semester_id FROM Student_Enrolment )",
        "amends": [
            "Do use a subquery with `NOT IN` to filter `semester_id` values that don't exist in the `Student_Enrolment` table instead of checking for `student_count = 0`, which may not accurately reflect enrollment status. Do reference the correct table name `Semesters` (with capital S) instead of `semesters` to match the schema. The amended query now correctly identifies semesters with no student enrollments by checking for the absence of related records in the enrollment table rather than relying on a potentially incorrect count field."
        ],
        "rules": [
            "When the question asks about semesters without enrolled students: use a NOT IN condition with semester_id values from the Student_Enrolment table instead of checking student_count = 0.",
            "When referencing the Semesters table: use the exact table name \"Semesters\" (with capital S) instead of \"semesters\".",
            "When the question asks about semesters without enrolled students, When referencing the Semesters table, When identifying semesters with no enrollments: check for absence of related records in Student_Enrolment table using semester_id as the linking key."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT semester_name FROM semesters WHERE student_count = 0;",
            "SELECT semester_name FROM Semesters WHERE semester_id NOT IN (SELECT DISTINCT semester_id FROM Student_Enrolment)"
        ],
        "rule_sql": [
            "SELECT semester_name FROM Semesters WHERE semester_id NOT IN (SELECT DISTINCT semester_id FROM Student_Enrolment)"
        ]
    },
    "544": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the name of the semester with no students enrolled?",
        "ground_truth": "SELECT semester_name FROM Semesters WHERE semester_id NOT IN( SELECT semester_id FROM Student_Enrolment )",
        "amends": [
            "Do select `semester_name` instead of `name` and change the table reference to `Semesters` instead of `semesters`. Do use a `NOT IN` subquery condition with `semester_id` instead of a direct `student_count = 0` filter. Do add a subquery that references `Student_Enrolment` table to check for enrollment existence instead of relying on a potentially incorrect count column. The amended query now correctly identifies semesters without any student enrollments by checking against the enrollment records rather than using a count that may not be properly maintained."
        ],
        "rules": [
            "When the question asks for the name of a semester: select \"semester_name\" from the \"Semesters\" table instead of \"name\".",
            "When identifying semesters with no students enrolled: use a NOT IN condition with \"semester_id\" against the \"Student_Enrolment\" table rather than checking a student_count column.",
            "When the question asks for the name of a semester, When identifying semesters with no students enrolled, When checking for enrollment existence: reference the \"Student_Enrolment\" table to verify that no records exist for a given semester_id, ensuring accurate identification of semesters without enrollments."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM semesters WHERE student_count = 0;",
            "SELECT semester_name \nFROM Semesters \nWHERE semester_id NOT IN (\n    SELECT DISTINCT semester_id \n    FROM Student_Enrolment\n)"
        ],
        "rule_sql": [
            "SELECT semester_name FROM Semesters WHERE semester_id NOT IN (SELECT DISTINCT semester_id FROM Student_Enrolment);"
        ]
    },
    "545": {
        "db_id": "student_transcripts_tracking",
        "question": "What are all the course names of the courses which ever have students enrolled in?",
        "ground_truth": "SELECT DISTINCT T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id",
        "amends": [
            "Do use `DISTINCT` on `T1.course_name` instead of omitting it. Do join `Courses AS T1` with `Student_Enrolment_Courses AS T2` on `T1.course_id = T2.course_id` instead of querying `courses` alone. Do remove the `WHERE student_id IS NULL` filter instead of keeping it, as the correct logic requires finding courses that have enrollments rather than those with null student IDs. The amended query now correctly identifies distinct courses that have student enrollments by joining the relevant tables."
        ],
        "rules": [
            "When answering about \"course names of courses which ever have students enrolled in\": make sure the output order: T1.course_name.",
            "When the question asks for distinct course names: compute the number of unique values of T1.course_name.",
            "When combining Courses as T1 and Student_Enrolment_Courses as T2: link rows where T1.course_id = T2.course_id exactly as shown; keep only matching pairs (inner match).",
            "When answering about \"course names of courses which ever have students enrolled in\", When the question asks for distinct course names, When combining Courses as T1 and Student_Enrolment_Courses as T2, When the question implies finding courses with enrollments: do not filter for student_id IS NULL, instead include all courses that have matching enrollment records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_name FROM courses WHERE student_id IS NULL;",
            "SELECT DISTINCT T1.course_name\nFROM Courses AS T1\nJOIN Student_Enrolment_Courses AS T2 ON T1.course_id = T2.course_id"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.course_name\nFROM Courses AS T1\nINNER JOIN Student_Enrolment_Courses AS T2 ON T1.course_id = T2.course_id\nORDER BY T1.course_name;"
        ]
    },
    "546": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the names of all courses that have some students enrolled?",
        "ground_truth": "SELECT DISTINCT T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id",
        "amends": [
            "Do add `DISTINCT` modifier and join `Student_Enrolment_Courses` table instead of querying only the `courses` table. Do use `JOIN` with `T1.course_id = T2.course_id` predicate instead of filtering by `student_count = 0`. Do remove the `WHERE` clause condition instead of keeping the incorrect filter that doesn't account for enrollment relationships. The amended query now correctly identifies courses with student enrollments by joining the enrollment table rather than relying on a potentially incorrect student_count field."
        ],
        "rules": [
            "When answering about courses with enrolled students: join the courses table (T1) with the Student_Enrolment_Courses table (T2) using the exact key equality T1.course_id = T2.course_id to find matching enrollment records.",
            "When the question asks for course names with enrollments: use DISTINCT modifier on course_name to return each course only once, regardless of how many students are enrolled.",
            "When combining T1 and T2 for shared entities: perform an inner match to keep only courses that have at least one enrollment record in the Student_Enrolment_Courses table.",
            "When answering about courses with enrolled students, When the question asks for course names with enrollments, When combining T1 and T2 for shared entities, When the original query incorrectly filters by student_count = 0: remove any WHERE clause conditions that filter based on student_count field since enrollment relationships are determined through the join with Student_Enrolment_Courses table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_name FROM courses WHERE student_count = 0;",
            "SELECT DISTINCT c.course_name\nFROM Courses c\nJOIN Student_Enrolment_Courses sec ON c.course_id = sec.course_id"
        ],
        "rule_sql": [
            "SELECT DISTINCT c.course_name\nFROM Courses c\nINNER JOIN Student_Enrolment_Courses sec ON c.course_id = sec.course_id;"
        ]
    },
    "547": {
        "db_id": "student_transcripts_tracking",
        "question": "What's the name of the course with most number of enrollments?",
        "ground_truth": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `JOIN Student_Enrolment_Courses AS T2 ON T1.course_id = T2.course_id` instead of querying only the `courses` table. Do add `GROUP BY T1.course_name` instead of omitting grouping. Do change `ORDER BY count(*) DESC` instead of `ORDER BY enrollment_count ASC` to order by actual enrollment count rather than a static column. Do use `count(*)` instead of `enrollment_count` to dynamically calculate enrollments from the join. Do add table alias `T1` for `Courses` instead of using the table name directly. The amended query now correctly identifies the most popular course by counting actual student enrollments rather than relying on a potentially outdated static enrollment_count column."
        ],
        "rules": [
            "When answering about \"course with most number of enrollments\": make sure to join Courses as T1 with Student_Enrolment_Courses as T2 using T1.course_id = T2.course_id to get actual enrollment data.",
            "When counting enrollments per course: use count(*) instead of a static enrollment_count column to dynamically calculate enrollments from the join.",
            "When grouping results by course: use GROUP BY T1.course_name to organize results by each course.",
            "When ordering by enrollment count: use ORDER BY count(*) DESC instead of ASC to find the course with the highest enrollment.",
            "When answering about \"course with most number of enrollments\", When counting enrollments per course, When grouping results by course, When ordering by enrollment count, When selecting the top course: use LIMIT 1 to return only the course with the most enrollments."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_name FROM courses ORDER BY enrollment_count ASC LIMIT 1;",
            "SELECT T1.course_name\nFROM Courses AS T1\nJOIN Student_Enrolment_Courses AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_name\nORDER BY count(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.course_name\nFROM Courses AS T1\nJOIN Student_Enrolment_Courses AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "548": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the name of the course with the most students enrolled?",
        "ground_truth": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `JOIN Student_Enrolment_Courses AS T2 ON T1.course_id = T2.course_id` instead of querying only the `courses` table. Do add `GROUP BY T1.course_name` instead of omitting grouping. Do change `ORDER BY count(*) DESC` instead of `ORDER BY student_count ASC` to order by enrollment count rather than student count. Do change `LIMIT 1` to return the course with the highest enrollment instead of the lowest student count. The amended query now correctly identifies the most popular course by enrollment count rather than relying on potentially incorrect student_count data."
        ],
        "rules": [
            "When answering about \"course with the most students enrolled\": make sure the output order: T1.course_name.",
            "When the question mentions \"most students enrolled\": actually means \"count of students per course\" in schema.",
            "When combining T1 (courses) and T2 (Student_Enrolment_Courses) for shared entities: link rows where T1.course_id = T2.course_id; keep only matching pairs (inner match).",
            "When the question asks for \"count of students enrolled per course\": compute the number of rows using the canonical key from the join (T2.course_id).",
            "When the question asks for \"most\" or \"highest\": rank rows by count(*) in descending direction and keep the first 1 row.",
            "When answering about \"course with the most students enrolled\", When the question mentions \"most students enrolled\", When combining T1 (courses) and T2 (Student_Enrolment_Courses) for shared entities, When the question asks for \"count of students enrolled per course\", When the question asks for \"most\" or \"highest\", When producing output: include only T1.course_name as the result."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT course_name FROM courses ORDER BY student_count ASC LIMIT 1;",
            "SELECT T1.course_name\nFROM Courses AS T1\nJOIN Student_Enrolment_Courses AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_name\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.course_name\nFROM Courses T1\nINNER JOIN Student_Enrolment_Courses T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_id, T1.course_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "549": {
        "db_id": "student_transcripts_tracking",
        "question": "Find the last name of the students who currently live in the state of North Carolina but have not registered in any degree program.",
        "ground_truth": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id",
        "amends": [
            "Do add `JOIN Addresses AS T2 ON T1.current_address_id = T2.address_id` instead of querying only the `students` table. Do change the state filter to `T2.state_province_county = 'NorthCarolina'` instead of `state = 'NorthCarolina'` since the state information now comes from the joined Addresses table. Do remove the `degree_program IS NOT NULL` filter instead of keeping it, as the right query uses a different exclusion logic. Do add `EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id = T4.student_id` instead of omitting this exclusion clause, which removes students who are enrolled in programs. Do use table aliases `T1`, `T2`, `T3`, and `T4` instead of direct table references for clarity and to handle multiple table instances. The amended query now correctly identifies students from North Carolina who are not currently enrolled in any programs, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about students who live in North Carolina: join the students table (T1) with the Addresses table (T2) using T1.current_address_id = T2.address_id to get address information.",
            "When filtering for students in North Carolina: use T2.state_province_county = 'NorthCarolina' (exact literal) instead of the students table's state column.",
            "When excluding students registered in degree programs: use EXCEPT with a subquery that joins Students (T3) with Student_Enrolment (T4) on T3.student_id = T4.student_id to find enrolled students and remove them from results.",
            "When selecting output columns: return only last_name from the students table.",
            "When answering about students who live in North Carolina, When filtering for students in North Carolina, When excluding students registered in degree programs, When selecting output columns, When using table aliases: maintain T1 for the main students table, T2 for Addresses, T3 for the Students table in the exclusion subquery, and T4 for Student_Enrolment table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM students WHERE state = 'North Carolina' AND degree_program IS NOT NULL;",
            "SELECT DISTINCT T1.last_name \nFROM Students AS T1 \nJOIN Addresses AS T2 ON T1.current_address_id = T2.address_id \nWHERE T2.state_province_county = 'NorthCarolina'\nEXCEPT \nSELECT DISTINCT T3.last_name \nFROM Students AS T3 \nJOIN Student_Enrolment AS T4 ON T3.student_id = T4.student_id"
        ],
        "rule_sql": [
            "SELECT T1.last_name\nFROM Students T1\nJOIN Addresses T2 ON T1.current_address_id = T2.address_id\nWHERE T2.state_province_county = 'NorthCarolina'\nEXCEPT\nSELECT T3.last_name\nFROM Students T3\nJOIN Student_Enrolment T4 ON T3.student_id = T4.student_id"
        ]
    },
    "550": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?",
        "ground_truth": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id",
        "amends": [
            "Do add `JOIN Addresses AS T2 ON T1.current_address_id = T2.address_id` instead of querying only the students table. Do change the state filter to `T2.state_province_county = 'NorthCarolina'` instead of `state = 'North Carolina'` since the state information is in the Addresses table. Do remove the `degree_program IS NULL` filter instead of keeping it, as the right query uses a different approach to filter students. Do add an `EXCEPT` clause with a subquery `SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id = T4.student_id` instead of omitting it, which excludes enrolled students from the results. Do use table aliases `T1`, `T2`, `T3`, and `T4` instead of direct table references for clarity and to handle multiple table instances. The amended query now correctly identifies North Carolina students who are not enrolled in any programs, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about students who live in North Carolina: use the Addresses table (T2) with state_province_county = 'NorthCarolina' instead of the students table for location filtering.",
            "When combining students and addresses: link rows where T1.current_address_id = T2.address_id and keep only matching pairs (inner match).",
            "When filtering for students not registered in any degree programs: exclude students who appear in the Student_Enrolment table by using an EXCEPT clause with SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id = T4.student_id.",
            "When handling the state value: use the exact literal 'NorthCarolina' (without space) as shown in the schema, not 'North Carolina'.",
            "When answering about students who live in North Carolina, When combining students and addresses, When filtering for students not registered in any degree programs, When handling the state value, When using multiple table instances: maintain the alias plan where base students table is T1, addresses table is T2, and the exclusion subquery uses T3 for students and T4 for Student_Enrolment."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM students WHERE state = 'North Carolina' AND degree_program IS NULL;",
            "SELECT T1.last_name \nFROM Students AS T1 \nJOIN Addresses AS T2 ON T1.current_address_id = T2.address_id \nWHERE T2.state_province_county = 'NorthCarolina'\nEXCEPT\nSELECT DISTINCT T3.last_name \nFROM Students AS T3 \nJOIN Student_Enrolment AS T4 ON T3.student_id = T4.student_id"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.last_name\nFROM Students AS T1\nJOIN Addresses AS T2 ON T1.current_address_id = T2.address_id\nWHERE T2.state_province_county = 'NorthCarolina'\nEXCEPT\nSELECT DISTINCT T3.last_name\nFROM Students AS T3\nJOIN Student_Enrolment AS T4 ON T3.student_id = T4.student_id"
        ]
    },
    "551": {
        "db_id": "student_transcripts_tracking",
        "question": "Show the date and id of the transcript with at least 2 course results.",
        "ground_truth": "SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id HAVING count(*)  >=  2",
        "amends": [
            "Do select `T2.transcript_date` and `T1.transcript_id` instead of `date` and `id`. Do join `Transcript_Contents AS T1` and `Transcripts AS T2` with `ON T1.transcript_id = T2.transcript_id` instead of querying only `transcript` table. Do add `GROUP BY T1.transcript_id` instead of omitting grouping. Do move the count condition to `HAVING count(*) >= 2` instead of placing it in `WHERE COUNT(course_result) >= 2`. Do use `count(*)` instead of `COUNT(course_result)` for proper aggregation. The amended query now correctly aggregates transcript contents and filters groups with multiple entries, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"transcript with at least 2 course results\": make sure the output order: T2.transcript_date, T1.transcript_id.",
            "When combining Transcript_Contents as T1 and Transcripts as T2: link rows where T1.transcript_id = T2.transcript_id and keep only matching pairs (inner match).",
            "When the question asks for transcripts with at least 2 course results: organize results by T1.transcript_id and compute count(*) per group, then keep only groups where count(*) >= 2.",
            "When answering about \"transcript with at least 2 course results\", When combining Transcript_Contents as T1 and Transcripts as T2, When the question asks for transcripts with at least 2 course results, When counting course results for transcripts: use count(*) to count all rows in the Transcript_Contents table per transcript_id group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT date, id FROM transcript WHERE COUNT(course_result) >= 2",
            "SELECT T2.transcript_date, T1.transcript_id\nFROM Transcript_Contents AS T1\nJOIN Transcripts AS T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nHAVING count(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T2.transcript_date, T1.transcript_id\nFROM Transcript_Contents T1\nINNER JOIN Transcripts T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nHAVING COUNT(*) >= 2\nORDER BY T2.transcript_date, T1.transcript_id"
        ]
    },
    "552": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the date and id of the transcript with at least 2 courses listed?",
        "ground_truth": "SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id HAVING count(*)  >=  2",
        "amends": [
            "Do use explicit table aliases `T2.transcript_date` and `T1.transcript_id` instead of ambiguous column names `date` and `id`. Do join tables `Transcript_Contents AS T1` and `Transcripts AS T2` with `ON T1.transcript_id = T2.transcript_id` instead of querying a single table. Do add `GROUP BY T1.transcript_id` instead of omitting grouping. Do move the count condition to `HAVING count(*) >= 2` instead of using `WHERE COUNT(course_id) >= 2` which is invalid syntax. Do remove the incorrect `course_id` reference and use `count(*)` instead. The amended query now correctly counts transcripts with multiple entries by joining the related tables and using proper grouping with HAVING.",
            "Do select `T1.transcript_id` and `T2.transcript_date` instead of `T2.transcript_id` and `T2.transcript_date`. Do maintain the same `FROM` clause with `Transcript_Contents AS T1` and `JOIN Transcripts AS T2` on `T1.transcript_id = T2.transcript_id`. Do preserve the `GROUP BY T1.transcript_id` and `HAVING COUNT(*) >= 2` clauses without changes. The amended query now correctly selects the transcript_id from the grouping table T1 instead of T2, ensuring proper grouping semantics while maintaining the same filtering logic for transcripts with at least two contents.",
            "Do include `T2.transcript_date` in the SELECT list instead of omitting it, and do reorder the columns as `T2.transcript_date, T1.transcript_id` instead of `T1.transcript_id, T2.transcript_date`. The amended query now correctly includes all necessary columns while maintaining the same grouping and filtering logic to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"transcript with at least 2 courses listed\": make sure the output order: T2.transcript_date, T1.transcript_id.",
            "When combining Transcript_Contents as T1 and Transcripts as T2: link rows where T1.transcript_id = T2.transcript_id and keep only matching pairs (inner match).",
            "When counting courses per transcript: group results by T1.transcript_id and compute count(*) per group.",
            "When filtering for transcripts with at least 2 courses: apply the condition count(*) >= 2 after grouping (HAVING clause equivalent).",
            "When answering about \"transcript with at least 2 courses listed\", When combining Transcript_Contents as T1 and Transcripts as T2, When counting courses per transcript, When filtering for transcripts with at least 2 courses, When the question asks for \"date and id\": use T2.transcript_date for date and T1.transcript_id for id with exact identifier tokens.",
            "When answering about transcripts with at least 2 courses: select T1.transcript_id and T2.transcript_date as output columns.",
            "When combining Transcript_Contents and Transcripts tables: link rows where T1.transcript_id = T2.transcript_id using an inner match.",
            "When grouping by transcript_id: use T1.transcript_id as the grouping key.",
            "When answering about transcripts with at least 2 courses, When combining Transcript_Contents and Transcripts tables, When grouping by transcript_id, When filtering for transcripts with at least 2 courses: count all rows per group and keep only groups where the count is greater than or equal to 2.",
            "When answering about \"date and id of the transcript with at least 2 courses listed\": make sure the output order: T2.transcript_date, T1.transcript_id",
            "When the question asks for transcripts with at least 2 courses: count the number of courses per transcript using T1.transcript_id and keep only those transcripts where the count is 2 or more",
            "When answering about \"date and id of the transcript with at least 2 courses listed\", When the question asks for transcripts with at least 2 courses, When combining Transcript_Contents (T1) and Transcripts (T2): link rows where T1.transcript_id = T2.transcript_id and keep only matching pairs (inner match)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT date, id FROM transcript WHERE COUNT(course_id) >= 2",
            "SELECT T2.transcript_id, T2.transcript_date\nFROM Transcript_Contents AS T1\nJOIN Transcripts AS T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nHAVING COUNT(*) >= 2",
            "SELECT T1.transcript_id, T2.transcript_date\nFROM Transcript_Contents AS T1\nJOIN Transcripts AS T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nHAVING COUNT(*) >= 2",
            "SELECT T2.transcript_date, T1.transcript_id\nFROM Transcript_Contents AS T1\nJOIN Transcripts AS T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T2.transcript_date, T1.transcript_id\nFROM Transcript_Contents T1\nINNER JOIN Transcripts T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nHAVING COUNT(*) >= 2\nORDER BY T2.transcript_date, T1.transcript_id"
        ]
    },
    "553": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the phone number of the man with the first name Timmothy and the last name Ward?",
        "ground_truth": "SELECT cell_mobile_number FROM Students WHERE first_name  =  'Timmothy' AND last_name  =  'Ward'",
        "amends": [
            "Do select `cell_mobile_number` instead of `phone_number` and query the `Students` table instead of `people`. Do keep the same filter conditions `first_name = 'Timmothy'` and `last_name = 'Ward'` unchanged. The amended query now correctly retrieves the mobile number from the Students table instead of attempting to find a phone number in a non-existent people table, matching the right SQL's behavior."
        ],
        "rules": [
            "When the question asks for \"phone number\": use the exact column \"cell_mobile_number\" from the Students table instead of \"phone_number\".",
            "When querying for a person by name: use the \"Students\" table instead of \"people\" table.",
            "When filtering for first name \"Timmothy\": use the exact literal 'Timmothy' with the correct spelling and case.",
            "When the question asks for \"phone number\", When querying for a person by name, When filtering for first name \"Timmothy\", When filtering for last name \"Ward\": use the exact literal 'Ward' with the correct spelling and case."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT phone_number FROM people WHERE first_name = 'Timmothy' AND last_name = 'Ward';",
            "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward';"
        ],
        "rule_sql": [
            "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward';"
        ]
    },
    "554": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the mobile phone number of the student named Timmothy Ward ?",
        "ground_truth": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'",
        "amends": [
            "Do select `cell_mobile_number` instead of `phone_number` in the SELECT list. Do filter on both `first_name = 'timmothy'` and `last_name = 'ward'` instead of only `name = 'Timmothy Ward'` in the WHERE clause. The amended query now correctly retrieves the mobile number using separate first and last name fields instead of a combined name field.",
            "Do use lowercase column and table names `cell_mobile_number` and `students` instead of mixed case `cell_mobile_number` and `Students`. Do use lowercase string literals `'timmothy'` and `'ward'` instead of capitalized `'Timmothy'` and `'Ward'`. Do maintain the same WHERE filter structure with `first_name = 'timmothy' and last_name = 'ward'` instead of `first_name = 'Timmothy' AND last_name = 'Ward'`. The amended query now matches the right SQL's behavior with case-insensitive schema references and consistent lowercase string comparisons."
        ],
        "rules": [
            "When the question asks for a mobile phone number: select the exact column \"cell_mobile_number\" instead of \"phone_number\".",
            "When the question asks for a mobile phone number, When filtering for a student named Timmothy Ward: use both conditions \"first_name = 'timmothy'\" and \"last_name = 'ward'\" with exact lowercase literals, not a combined \"name\" field.",
            "When using table and column identifiers: use lowercase \"students\" and \"cell_mobile_number\" instead of mixed case versions.",
            "When filtering by first name \"Timmothy\": use lowercase literal 'timmothy' instead of capitalized 'Timmothy'.",
            "When filtering by last name \"Ward\": use lowercase literal 'ward' instead of capitalized 'Ward'.",
            "When using table and column identifiers, When filtering by first name \"Timmothy\", When filtering by last name \"Ward\", When answering about mobile phone number of student named Timmothy Ward: maintain the WHERE filter structure with first_name = 'timmothy' and last_name = 'ward'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT phone_number FROM students WHERE name = 'Timmothy Ward';",
            "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward';",
            "SELECT cell_mobile_number FROM students WHERE first_name = 'timmothy' AND last_name = 'ward'"
        ],
        "rule_sql": [
            "SELECT cell_mobile_number FROM students WHERE first_name = 'timmothy' AND last_name = 'ward'"
        ]
    },
    "555": {
        "db_id": "student_transcripts_tracking",
        "question": "Who is the first student to register? List the first name, middle name and last name.",
        "ground_truth": "SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1",
        "amends": [
            "Do reference the `date_first_registered` column instead of `registration_date` in the ORDER BY clause, as the correct column name differs from what was originally specified. The table name should be referenced as `Students` (with capital S) instead of `students` (with lowercase s) to match the correct schema. All other elements including the SELECT list columns (`first_name`, `middle_name`, `last_name`), the LIMIT 1 constraint, and the ascending sort order remain unchanged. The amended query now correctly sorts by the appropriate registration date column and references the proper table name, matching the intended behavior."
        ],
        "rules": [
            "When the question asks about the first student to register: sort by the exact column \"date_first_registered\" in ascending order to find the earliest registration.",
            "When referencing the student table: use the exact table name \"Students\" (with capital S) as shown in the schema.",
            "When selecting student name information: include the exact columns \"first_name\", \"middle_name\", and \"last_name\" in that order.",
            "When the question asks about the first student to register, When referencing the student table, When selecting student name information, When limiting to the first result: return only the single top row after sorting by registration date."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, middle_name, last_name FROM students ORDER BY registration_date ASC LIMIT 1;",
            "SELECT first_name, middle_name, last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT first_name, middle_name, last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1;"
        ]
    },
    "556": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the first, middle, and last name of the first student to register?",
        "ground_truth": "SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1",
        "amends": [
            "Do reference the `date_first_registered` column instead of `registration_date` in the ORDER BY clause, as the correct column name reflects the actual registration timestamp field in the Students table. The amended query now correctly sorts by the appropriate registration date column and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for the \"first student to register\": sort students by the exact column \"date_first_registered\" in ascending order and keep only the first row.",
            "When the question mentions \"first, middle, and last name\": output the columns \"first_name\", \"middle_name\", and \"last_name\" in that exact order.",
            "When the question asks for the \"first student to register\", When the question mentions \"first, middle, and last name\", When choosing the registration date column: use \"date_first_registered\" instead of \"registration_date\" as it is the correct column name in the Students table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, middle_name, last_name FROM students ORDER BY registration_date ASC LIMIT 1;",
            "SELECT first_name, middle_name, last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT first_name, middle_name, last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1;"
        ]
    },
    "557": {
        "db_id": "student_transcripts_tracking",
        "question": "Who is the earliest graduate of the school? List the first name, middle name and last name.",
        "ground_truth": "SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_left ASC LIMIT 1",
        "amends": [
            "Do query the `Students` table instead of the `graduates` table. Do order by `date_left` instead of `graduation_date`. The amended query now correctly retrieves student records from the appropriate table using the correct date field for ordering."
        ],
        "rules": [
            "When answering about \"earliest graduate\": use the \"Students\" table instead of \"graduates\" table.",
            "When ordering by graduation date to find the earliest graduate: order by \"date_left\" column in ascending order instead of \"graduation_date\".",
            "When answering about \"earliest graduate\", When ordering by graduation date to find the earliest graduate, When listing student names: include \"first_name\", \"middle_name\", and \"last_name\" columns from the \"Students\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, middle_name, last_name FROM graduates ORDER BY graduation_date ASC LIMIT 1;",
            "SELECT first_name, middle_name, last_name FROM Students WHERE date_left IS NOT NULL ORDER BY date_left ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT first_name, middle_name, last_name FROM Students WHERE date_left IS NOT NULL ORDER BY date_left ASC LIMIT 1;"
        ]
    },
    "558": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the first, middle, and last name of the earliest school graduate?",
        "ground_truth": "SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_left ASC LIMIT 1",
        "amends": [
            "Do query the `Students` table instead of the `graduates` table. Do order by `date_left` instead of `graduation_date`. The amended query now correctly retrieves student names from the appropriate table using the correct date column for ordering."
        ],
        "rules": [
            "When answering about \"earliest school graduate\": use the \"Students\" table instead of \"graduates\" table.",
            "When ordering by graduation date to find the earliest graduate: use the \"date_left\" column for ordering instead of \"graduation_date\".",
            "When retrieving student names: select \"first_name\", \"middle_name\", and \"last_name\" columns from the \"Students\" table.",
            "When answering about \"earliest school graduate\", When ordering by graduation date to find the earliest graduate, When retrieving student names, When finding the earliest record: order by \"date_left\" in ascending order and take the first row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, middle_name, last_name FROM graduates ORDER BY graduation_date ASC LIMIT 1;",
            "SELECT first_name, middle_name, last_name FROM Students WHERE date_left IS NOT NULL ORDER BY date_left ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT first_name, middle_name, last_name FROM Students ORDER BY date_left ASC LIMIT 1;"
        ]
    },
    "559": {
        "db_id": "student_transcripts_tracking",
        "question": "Whose permanent address is different from his or her current address? List his or her first name.",
        "ground_truth": "SELECT first_name FROM Students WHERE current_address_id != permanent_address_id",
        "amends": [
            "Do select from `Students` table instead of `people` table. Do filter with `current_address_id != permanent_address_id` instead of `permanent_address = current_address`. Do reference address ID columns instead of address value columns. The amended query now correctly identifies students whose current and permanent addresses differ by comparing their ID values rather than address content."
        ],
        "rules": [
            "When selecting from the database about students' addresses: use the \"Students\" table as the base table T1 instead of a \"people\" table.",
            "When comparing permanent and current addresses: compare using the ID columns \"current_address_id\" and \"permanent_address_id\" instead of address value columns.",
            "When filtering for different addresses: use the condition current_address_id != permanent_address_id to identify students whose permanent address differs from their current address.",
            "When selecting from the database about students' addresses, When comparing permanent and current addresses, When filtering for different addresses, When outputting results: include the \"first_name\" column from the Students table to list the student's first name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM people WHERE permanent_address = current_address;",
            "SELECT first_name FROM Students WHERE current_address_id != permanent_address_id"
        ],
        "rule_sql": [
            "SELECT first_name FROM Students WHERE current_address_id != permanent_address_id"
        ]
    },
    "560": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the first name of the student whose permanent address is different from his or her current one?",
        "ground_truth": "SELECT first_name FROM Students WHERE current_address_id != permanent_address_id",
        "amends": [
            "Do reference the correct table name `Students` instead of `students` to match the actual schema. Do compare the correct column identifiers `current_address_id` and `permanent_address_id` instead of `permanent_address` and `current_address` to properly evaluate address inequality using ID values rather than address text. The amended query now correctly filters students based on address ID mismatch and matches the intended behavior."
        ],
        "rules": [
            "When referencing table names from the schema: use exact case-sensitive identifier \"Students\" instead of lowercase \"students\".",
            "When comparing permanent and current addresses: use column identifiers \"permanent_address_id\" and \"current_address_id\" instead of \"permanent_address\" and \"current_address\" to properly evaluate address inequality using ID values.",
            "When referencing table names from the schema, When comparing permanent and current addresses, When filtering for students with different permanent and current addresses: compare \"Students\".\"permanent_address_id\" != \"Students\".\"current_address_id\" to identify address ID mismatches."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE permanent_address != current_address LIMIT 1;",
            "SELECT first_name FROM Students WHERE current_address_id != permanent_address_id"
        ],
        "rule_sql": [
            "SELECT first_name FROM Students WHERE permanent_address_id != current_address_id;"
        ]
    },
    "561": {
        "db_id": "student_transcripts_tracking",
        "question": "Which address holds the most number of students currently? List the address id and all lines.",
        "ground_truth": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do select `T1.line_1` and `T1.line_2` instead of `line1`, `line2`, and `line3`. Do remove the `student_count` alias and count aggregation from the SELECT list instead of including it. Do join on `T2.current_address_id` instead of `students.address_id`. Do remove the explicit column alias for the count instead of keeping `as student_count`. Do reference the count directly in ORDER BY instead of using the alias. The amended query now correctly retrieves address details with student counts using the proper join condition and ordering."
        ],
        "rules": [
            "When answering about \"which address holds the most number of students currently\": make sure the output order: address_id, line_1, line_2.",
            "When counting students per address: compute the number of rows using the join condition on T2.current_address_id.",
            "When combining addresses (T1) and students (T2) for shared entities: link rows where T1.address_id = T2.current_address_id and keep only matching pairs (inner match).",
            "When the question mentions \"most number of students\": rank addresses by student count in descending order and keep the first 1 row.",
            "When answering about \"which address holds the most number of students currently\", When counting students per address, When combining addresses (T1) and students (T2) for shared entities, When the question mentions \"most number of students\", When selecting address details: include T1.address_id, T1.line_1, and T1.line_2 instead of line1, line2, and line3."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT address_id, line1, line2, line3, COUNT(*) as student_count \nFROM addresses \nJOIN students ON addresses.address_id = students.address_id \nGROUP BY address_id \nORDER BY student_count DESC \nLIMIT 1;",
            "SELECT T1.address_id, T1.line_1, T1.line_2\nFROM Addresses T1\nJOIN Students T2 ON T1.address_id = T2.current_address_id\nGROUP BY T1.address_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT a.address_id, a.line_1, a.line_2\nFROM Addresses a\nINNER JOIN Students s ON a.address_id = s.current_address_id\nGROUP BY a.address_id, a.line_1, a.line_2\nORDER BY COUNT(s.student_id) DESC\nLIMIT 1;"
        ]
    },
    "562": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the id, line 1, and line 2 of the address with the most students?",
        "ground_truth": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `T1.address_id` and remove `id` in the SELECT list instead of using the original column name. Do add `FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id = T2.current_address_id` instead of just selecting from `addresses` without joining. Do add `GROUP BY T1.address_id` to aggregate by address instead of omitting grouping. Do change the ORDER BY to `count(*) DESC` instead of `student_count DESC` to count actual students per address. Do keep `LIMIT 1` to return the single address with the most students. The amended query now correctly identifies the address with the highest student count by joining and counting relationships instead of relying on a potentially non-existent student_count column."
        ],
        "rules": [
            "When answering about \"address with the most students\": make sure the output order: T1.address_id, T1.line_1, T1.line_2.",
            "When the question asks for \"most students\": count the number of students using T2.current_address_id as the counting key.",
            "When combining Addresses and Students tables: link rows where T1.address_id = T2.current_address_id and keep only matching pairs (inner match).",
            "When grouping by address: organize results by T1.address_id and compute the count of students per group.",
            "When answering about \"address with the most students\", When the question asks for \"most students\", When combining Addresses and Students tables, When grouping by address, When ranking addresses by student count: rank rows by count(*) in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, line_1, line_2 FROM addresses ORDER BY student_count DESC LIMIT 1;",
            "SELECT T1.address_id, T1.line_1, T1.line_2\nFROM Addresses AS T1\nJOIN Students AS T2 ON T1.address_id = T2.current_address_id\nGROUP BY T1.address_id\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.address_id, T1.line_1, T1.line_2\nFROM Addresses T1\nINNER JOIN Students T2 ON T1.address_id = T2.current_address_id\nGROUP BY T1.address_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "563": {
        "db_id": "student_transcripts_tracking",
        "question": "On average, when were the transcripts printed?",
        "ground_truth": "SELECT avg(transcript_date) FROM Transcripts",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(transcript_date) FROM transcripts;"
        ],
        "rule_sql": [
            "SELECT AVG(transcript_date) AS average_transcript_date FROM Transcripts;"
        ]
    },
    "564": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the average transcript date?",
        "ground_truth": "SELECT avg(transcript_date) FROM Transcripts",
        "amends": [
            "Do reference the correct table name `Transcripts` instead of `transcript` and use the proper column name `transcript_date` instead of `date` for the AVG function, as the original query referenced incorrect schema elements that would cause execution errors. The amended query now correctly calculates the average of transcript dates from the appropriate table, matching the intended behavior."
        ],
        "rules": [
            "When the question asks about \"transcript date\": use the exact column name \"transcript_date\" from table \"Transcripts\".",
            "When calculating average of transcript dates: compute the average of the \"transcript_date\" column from table \"Transcripts\".",
            "When the question asks about \"transcript date\", When calculating average of transcript dates, When referencing table names: use the exact table name \"Transcripts\" instead of variations like \"transcript\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(date) FROM transcript;",
            "SELECT AVG(transcript_date) AS average_transcript_date FROM Transcripts;"
        ],
        "rule_sql": [
            "SELECT AVG(transcript_date) AS average_transcript_date FROM Transcripts;"
        ]
    },
    "565": {
        "db_id": "student_transcripts_tracking",
        "question": "When is the first transcript released? List the date and details.",
        "ground_truth": "SELECT transcript_date ,  other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1",
        "amends": [
            "Do use column name `transcript_date` instead of `date` and `other_details` instead of `details` in the SELECT list. Do reference table `Transcripts` instead of `transcripts` in the FROM clause. The amended query now correctly matches the intended behavior with proper column and table names."
        ],
        "rules": [
            "When the question asks for \"date and details\" from transcripts: use column \"transcript_date\" for date and \"other_details\" for details in the SELECT list.",
            "When referencing the transcripts table: use table name \"Transcripts\" (case-sensitive) in the FROM clause.",
            "When the question asks for \"date and details\" from transcripts, When referencing the transcripts table, When finding the first transcript released: order by \"transcript_date\" in ascending order and take only the first row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT date, details FROM transcripts ORDER BY date ASC LIMIT 1;",
            "SELECT transcript_date, other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT transcript_date, other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1;"
        ]
    },
    "566": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the earliest date of a transcript release, and what details can you tell me?",
        "ground_truth": "SELECT transcript_date ,  other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1",
        "amends": [
            "Do select `transcript_date` and `other_details` instead of `MIN(release_date)`, `transcript_id`, and `content`. Do query from `Transcripts` instead of `transcripts`. Do remove the WHERE clause with subquery instead of filtering by maximum release date. Do add `ORDER BY transcript_date ASC` instead of omitting ordering. Do add `LIMIT 1` instead of omitting row limitation. Do remove the aggregate function and grouping semantics instead of using MIN with non-aggregated columns. The amended query now correctly retrieves the earliest transcript details by date ordering rather than attempting to find minimum release date with incorrect aggregation logic."
        ],
        "rules": [
            "When answering about the earliest date of a transcript release: select \"transcript_date\" and \"other_details\" from \"Transcripts\" instead of MIN(release_date), transcript_id, and content.",
            "When ordering by date to find the earliest transcript: order rows by \"transcript_date\" in ascending order and limit to the first 1 row.",
            "When the question asks for details about the earliest transcript: include \"other_details\" column to provide additional information about the transcript.",
            "When querying from the Transcripts table: use the exact table name \"Transcripts\" with proper capitalization as shown in the schema.",
            "When answering about the earliest date of a transcript release, When ordering by date to find the earliest transcript, When the question asks for details about the earliest transcript, When querying from the Transcripts table, When finding the earliest date: do not use aggregate functions with non-aggregated columns or subqueries for maximum dates, instead use direct ordering and limiting."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(release_date) AS earliest_date, transcript_id, content FROM transcripts WHERE release_date = (SELECT MAX(release_date) FROM transcripts);",
            "SELECT transcript_date, other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT transcript_date, other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1;"
        ]
    },
    "567": {
        "db_id": "student_transcripts_tracking",
        "question": "How many transcripts are released?",
        "ground_truth": "SELECT count(*) FROM Transcripts",
        "amends": [
            "Do use the correct table name `Transcripts` instead of the incorrect `transcripts` to match the actual schema. Do maintain the same `COUNT(*)` aggregation and `released = 'false'` filter condition as the original query. The amended query now correctly references the proper table name while preserving the same counting logic and filtering behavior.",
            "Do use lowercase `count(*)` instead of uppercase `COUNT(*)` to maintain consistent function casing. Do remove the `WHERE released = 'false'` filter instead of keeping it, as the right query counts all records without filtering. Do maintain the same table source `FROM Transcripts` without changes. The amended query now correctly counts all transcript records instead of only unreleased ones, matching the right SQL's behavior of returning the total count from the Transcripts table."
        ],
        "rules": [
            "When the question asks about \"transcripts\": use the exact table name \"Transcripts\" with proper capitalization.",
            "When counting transcripts: use COUNT(*) to count all rows.",
            "When the question asks about \"transcripts\", When counting transcripts, When filtering for released status: use the condition released = 'false' exactly as specified, maintaining the lowercase 'false' literal.",
            "When answering about \"how many transcripts are released\": count all records from the \"Transcripts\" table without any filtering conditions.",
            "When using aggregate functions: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" to maintain consistent function casing.",
            "When answering about \"how many transcripts are released\", When using aggregate functions, When counting records: do not apply any WHERE clause filters unless explicitly specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM transcripts WHERE released = 'false';",
            "SELECT COUNT(*) FROM Transcripts WHERE released = 'false';",
            "SELECT count(*) FROM Transcripts;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM Transcripts;"
        ]
    },
    "568": {
        "db_id": "student_transcripts_tracking",
        "question": "How many transcripts are listed?",
        "ground_truth": "SELECT count(*) FROM Transcripts",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Transcripts;"
        ]
    },
    "569": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the last transcript release date?",
        "ground_truth": "SELECT transcript_date FROM Transcripts ORDER BY transcript_date DESC LIMIT 1",
        "amends": [
            "Do select `transcript_date` instead of `MAX(release_date)` and remove the aggregate function. Do use a simple `FROM Transcripts` source instead of a subquery approach. Do remove the `WHERE` filter entirely instead of using a nested subquery. Do add `ORDER BY transcript_date DESC` instead of omitting ordering. Do add `LIMIT 1` instead of using maximum aggregation. Do reference the correct column name `transcript_date` instead of `release_date` and use proper table name casing `Transcripts` instead of `transcripts`. The amended query now correctly retrieves the most recent transcript date by direct ordering and limiting instead of using nested aggregation which could return incorrect results when transcript_id and date ordering don't align."
        ],
        "rules": [
            "When the question asks for the \"last transcript release date\": use the exact column name \"transcript_date\" from table \"Transcripts\" instead of \"release_date\".",
            "When retrieving the most recent date: order rows by \"transcript_date\" in descending order and take only the first row instead of using maximum aggregation.",
            "When selecting from the Transcripts table: use the exact table name \"Transcripts\" with proper casing instead of \"transcripts\".",
            "When the question asks for the \"last transcript release date\", When retrieving the most recent date, When selecting from the Transcripts table, When the question asks for a single most recent value: use a limit of 1 instead of subqueries or complex aggregation approaches."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(release_date) FROM transcripts WHERE transcript_id = (SELECT MAX(transcript_id) FROM transcripts);",
            "SELECT transcript_date FROM Transcripts ORDER BY transcript_date DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT transcript_date FROM Transcripts ORDER BY transcript_date DESC LIMIT 1;"
        ]
    },
    "570": {
        "db_id": "student_transcripts_tracking",
        "question": "When was the last transcript released?",
        "ground_truth": "SELECT transcript_date FROM Transcripts ORDER BY transcript_date DESC LIMIT 1",
        "amends": [
            "Do select `transcript_date` instead of `MAX(release_date)` and remove the aggregate function. Do use `FROM Transcripts` instead of `FROM transcripts` with proper table name casing. Do remove the `WHERE release_date > CURRENT_DATE` filter instead of keeping it since it incorrectly excludes all past records. Do add `ORDER BY transcript_date DESC LIMIT 1` instead of omitting ordering and limiting, which provides the most recent transcript date directly rather than attempting to find a maximum future date that doesn't exist. The amended query now correctly retrieves the latest transcript date from the table instead of looking for non-existent future dates."
        ],
        "rules": [
            "When answering about \"last transcript released\": make sure the output order: transcript_date.",
            "When the question asks for the most recent date: use ORDER BY transcript_date DESC LIMIT 1 to get the single latest date.",
            "When selecting from the Transcripts table: use the exact table name \"Transcripts\" with proper casing.",
            "When retrieving transcript dates: select the column \"transcript_date\" directly without aggregate functions.",
            "When answering about \"last transcript released\", When the question asks for the most recent date, When selecting from the Transcripts table, When retrieving transcript dates, When finding the latest transcript: do not apply filters that exclude past records like WHERE release_date > CURRENT_DATE."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(release_date) FROM transcripts WHERE release_date > CURRENT_DATE;",
            "SELECT transcript_date FROM Transcripts ORDER BY transcript_date DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT transcript_date FROM Transcripts ORDER BY transcript_date DESC LIMIT 1;"
        ]
    },
    "571": {
        "db_id": "student_transcripts_tracking",
        "question": "How many times at most can a course enrollment result show in different transcripts? Also show the course enrollment id.",
        "ground_truth": "SELECT count(*) ,  student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `count(*)` without an alias instead of aliasing as `max_count`, and do select `student_course_id` instead of `course_enrollment_id`. Do query from `Transcript_Contents` instead of `transcripts`. Do group by `student_course_id` instead of `course_enrollment_id`. Do order by `count(*)` instead of `max_count`. The amended query now correctly identifies the student course with the highest content count from the appropriate table.",
            "Do place `count(*)` before `student_course_id` in the SELECT list instead of listing `student_course_id` first, and do add a space after the comma in the SELECT list instead of omitting it. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks about \"course enrollment\": use the exact identifier \"student_course_id\" instead of \"course_enrollment_id\" as shown in the schema.",
            "When counting occurrences in different transcripts: query from the \"Transcript_Contents\" table instead of \"transcripts\".",
            "When grouping by course enrollment: group by \"student_course_id\" to count occurrences per enrollment.",
            "When finding the maximum count: order by the count value in descending order and take the first result.",
            "When the question asks about \"course enrollment\", When counting occurrences in different transcripts, When grouping by course enrollment, When finding the maximum count, When selecting output columns: include both \"student_course_id\" and the count value without aliasing the count.",
            "When answering about \"How many times at most can a course enrollment result show in different transcripts? Also show the course enrollment id\": make sure the output order: count(*) first, then student_course_id.",
            "When the question asks for \"course enrollment id\": \"course enrollment id\" actually means \"student_course_id in schema\".",
            "When the question asks for \"how many times at most\": rank rows by count(*) in descending order and keep the first 1 row.",
            "When answering about \"How many times at most can a course enrollment result show in different transcripts? Also show the course enrollment id\", When the question asks for \"course enrollment id\", When the question asks for \"how many times at most\", When counting occurrences of course enrollment results: compute the number of rows using the canonical key student_course_id."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_enrollment_id, COUNT(*) as max_count \nFROM transcripts \nGROUP BY course_enrollment_id \nORDER BY max_count DESC \nLIMIT 1;",
            "SELECT student_course_id, COUNT(*) \nFROM Transcript_Contents \nGROUP BY student_course_id \nORDER BY COUNT(*) DESC \nLIMIT 1",
            "SELECT count(*), student_course_id \nFROM Transcript_Contents \nGROUP BY student_course_id \nORDER BY count(*) DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS count, student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count DESC LIMIT 1;"
        ]
    },
    "572": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the maximum number of times that a course shows up in different transcripts and what is that course's enrollment id?",
        "ground_truth": "SELECT count(*) ,  student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `count(*)` and `student_course_id` instead of `MAX(COUNT(*))` and `enrollment_id`. Do use table `Transcript_Contents` instead of `transcripts`. Do group by `student_course_id` instead of `course_id`. Do remove the incorrect `MAX` aggregation around the count instead of keeping it. The amended query now correctly counts records per student course and returns the highest count with its corresponding student course ID, matching the intended behavior."
        ],
        "rules": [
            "When counting occurrences of courses in transcripts: use table \"Transcript_Contents\" instead of \"transcripts\" and count records per \"student_course_id\" instead of \"course_id\".",
            "When the question asks for the maximum number of times a course appears: count the number of records for each \"student_course_id\" and find the highest count value.",
            "When selecting the enrollment identifier: use \"student_course_id\" instead of \"enrollment_id\" to identify the course enrollment.",
            "When grouping for counting: group by \"student_course_id\" to count how many times each student course appears in transcripts.",
            "When counting occurrences of courses in transcripts, When the question asks for the maximum number of times a course appears, When selecting the enrollment identifier, When grouping for counting, When ordering results: order by the count in descending order to find the maximum occurrence first."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(COUNT(*)), enrollment_id \nFROM transcripts \nGROUP BY course_id \nORDER BY COUNT(*) DESC \nLIMIT 1;",
            "SELECT COUNT(*) AS count, student_course_id \nFROM Transcript_Contents \nGROUP BY student_course_id \nORDER BY count DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS max_count, student_course_id\nFROM Transcript_Contents\nGROUP BY student_course_id\nORDER BY max_count DESC\nLIMIT 1;"
        ]
    },
    "573": {
        "db_id": "student_transcripts_tracking",
        "question": "Show the date of the transcript which shows the least number of results, also list the id.",
        "ground_truth": "SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id ORDER BY count(*) ASC LIMIT 1",
        "amends": [
            "Do add table `Transcript_Contents AS T1` and `Transcripts AS T2` with a `JOIN` on `T1.transcript_id = T2.transcript_id` instead of querying only the `transcripts` table. Do change the SELECT list to include `T2.transcript_date` and `T1.transcript_id` instead of `transcript_date` and `transcript_id` without table qualification. Do add `GROUP BY T1.transcript_id` and change the ORDER BY to `count(*) ASC` instead of `results_count ASC`. The amended query now correctly aggregates transcript contents and orders by the count of records per transcript_id, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"the date of the transcript which shows the least number of results\": make sure the output order: T2.transcript_date, T1.transcript_id",
            "When the question asks for \"least number of results\": count the number of records per transcript using count(*) on T1.transcript_id and order by this count in ascending order",
            "When combining Transcript_Contents AS T1 and Transcripts AS T2: link rows where T1.transcript_id = T2.transcript_id and keep only matching pairs (inner match)",
            "When grouping results: organize by T1.transcript_id to compute the count of records per transcript",
            "When answering about \"the date of the transcript which shows the least number of results\", When the question asks for \"least number of results\", When combining Transcript_Contents AS T1 and Transcripts AS T2, When grouping results, When selecting the transcript with the minimum count: take only the first row after ordering by count(*) ASC"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT transcript_date, transcript_id FROM transcripts ORDER BY results_count ASC LIMIT 1;",
            "SELECT T2.transcript_date, T1.transcript_id\nFROM Transcript_Contents AS T1\nJOIN Transcripts AS T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nORDER BY COUNT(*) ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.transcript_date, T1.transcript_id\nFROM Transcript_Contents AS T1\nINNER JOIN Transcripts AS T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nORDER BY COUNT(*) ASC\nLIMIT 1;"
        ]
    },
    "574": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the date and id of the transcript with the least number of results?",
        "ground_truth": "SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id ORDER BY count(*) ASC LIMIT 1",
        "amends": [
            "Do select `T2.transcript_date` and `T1.transcript_id` instead of `date` and `id`. Do use `FROM Transcript_Contents AS T1 JOIN Transcripts AS T2` instead of `FROM transcript`. Do add `ON T1.transcript_id = T2.transcript_id` join condition instead of omitting it. Do add `GROUP BY T1.transcript_id` instead of omitting grouping. Do order by `count(*)` instead of `COUNT(results)`. Do maintain `ASC LIMIT 1` ordering and limiting. The amended query now correctly joins tables, groups by transcript_id, and counts records instead of attempting to aggregate results without grouping."
        ],
        "rules": [
            "When answering about \"date and id of the transcript with the least number of results\": make sure the output order: T2.transcript_date, T1.transcript_id.",
            "When the question mentions \"date\": \"date\" actually means \"T2.transcript_date\" in schema.",
            "When the question mentions \"id\": \"id\" actually means \"T1.transcript_id\" in schema.",
            "When combining Transcript_Contents as T1 and Transcripts as T2 for shared entities: link rows where T1.transcript_id = T2.transcript_id; keep only matching pairs (inner match).",
            "When the question asks for \"number of results\" per transcript: organize results by T1.transcript_id and compute count(*) per group.",
            "When answering about \"date and id of the transcript with the least number of results\", When the question mentions \"date\", When the question mentions \"id\", When combining Transcript_Contents as T1 and Transcripts as T2 for shared entities, When the question asks for \"number of results\" per transcript, When the question asks for the transcript with the \"least number of results\": rank rows by count(*) in ascending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT date, id FROM transcript ORDER BY COUNT(results) ASC LIMIT 1;",
            "SELECT T2.transcript_date, T1.transcript_id\nFROM Transcript_Contents AS T1\nJOIN Transcripts AS T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nORDER BY COUNT(*) ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.transcript_date, T1.transcript_id\nFROM Transcript_Contents T1\nINNER JOIN Transcripts T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nORDER BY COUNT(*) ASC\nLIMIT 1;"
        ]
    },
    "575": {
        "db_id": "student_transcripts_tracking",
        "question": "Find the semester when both Master students and Bachelor students got enrolled in.",
        "ground_truth": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'",
        "amends": [
            "Do use `DISTINCT T2.semester_id` from `Student_Enrolment` instead of `semester` from `students`. Do join `Degree_Programs AS T1` with `Student_Enrolment AS T2` on `T1.degree_program_id = T2.degree_program_id` instead of querying a single `students` table. Do filter with `degree_summary_name = 'Master'` and `degree_summary_name = 'Bachelor'` in separate queries instead of contradictory `degree = 'Master' AND degree = 'Bachelor'`. Do use `INTERSECT` to find common semesters instead of attempting to find rows that satisfy both degree conditions simultaneously. Do remove the impossible WHERE condition and instead use set intersection to properly identify semesters that contain both Master and Bachelor students. The amended query now correctly identifies semesters where both degree programs are offered by using proper table relationships and set operations."
        ],
        "rules": [
            "When answering about semesters where both Master and Bachelor students enrolled: use DISTINCT T2.semester_id from Student_Enrolment table instead of semester from students table.",
            "When combining Degree_Programs and Student_Enrolment tables: link rows where T1.degree_program_id = T2.degree_program_id and keep only matching pairs (inner match).",
            "When filtering for Master students: use condition degree_summary_name = 'Master' with exact case and spacing.",
            "When filtering for Bachelor students: use condition degree_summary_name = 'Bachelor' with exact case and spacing.",
            "When answering about semesters where both Master and Bachelor students enrolled, When combining Degree_Programs and Student_Enrolment tables, When filtering for Master students, When filtering for Bachelor students, When finding semesters with both degree programs: use INTERSECT operation between the Master student results and Bachelor student results instead of trying to satisfy both conditions in a single WHERE clause."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT semester FROM students WHERE degree = 'Master' AND degree = 'Bachelor';",
            "SELECT DISTINCT T2.semester_id\nFROM Student_Enrolment AS T2\nJOIN Degree_Programs AS T1 ON T1.degree_program_id = T2.degree_program_id\nWHERE T1.degree_summary_name = 'Master'\nINTERSECT\nSELECT DISTINCT T2.semester_id\nFROM Student_Enrolment AS T2\nJOIN Degree_Programs AS T1 ON T1.degree_program_id = T2.degree_program_id\nWHERE T1.degree_summary_name = 'Bachelor'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.semester_id\nFROM Degree_Programs T1\nINNER JOIN Student_Enrolment T2 ON T1.degree_program_id = T2.degree_program_id\nWHERE T1.degree_summary_name = 'Master'\nINTERSECT\nSELECT DISTINCT T2.semester_id\nFROM Degree_Programs T1\nINNER JOIN Student_Enrolment T2 ON T1.degree_program_id = T2.degree_program_id\nWHERE T1.degree_summary_name = 'Bachelor'"
        ]
    },
    "576": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the id of the semester that had both Masters and Bachelors students enrolled?",
        "ground_truth": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'",
        "amends": [
            "Do use `DISTINCT T2.semester_id` instead of `semester_id` without distinct. Do change the FROM clause to join `Degree_Programs AS T1` with `Student_Enrolment AS T2` on `T1.degree_program_id = T2.degree_program_id` instead of querying only `enrollments`. Do replace the WHERE condition with `degree_summary_name = 'Master'` in one branch and `degree_summary_name = 'Bachelor'` in another instead of the impossible `student_type = 'Masters' AND student_type = 'Bachelors'`. Do use `INTERSECT` between two queries to find common semester_ids instead of attempting to find rows that satisfy both conditions simultaneously. Do remove the incorrect table reference `enrollments` and add the correct tables `Degree_Programs` and `Student_Enrolment` with proper join conditions. The amended query now correctly finds semester IDs that have both Master's and Bachelor's students by intersecting results from two separate queries targeting each degree type."
        ],
        "rules": [
            "When answering about semesters with both Masters and Bachelors students: use DISTINCT T2.semester_id to avoid duplicate semester IDs in the output.",
            "When combining Degree_Programs and Student_Enrolment tables: link rows where T1.degree_program_id = T2.degree_program_id and keep only matching pairs (inner join).",
            "When filtering for Master's degree students: use condition degree_summary_name = 'Master' with exact case and spelling.",
            "When filtering for Bachelor's degree students: use condition degree_summary_name = 'Bachelor' with exact case and spelling.",
            "When answering about semesters with both Masters and Bachelors students, When combining Degree_Programs and Student_Enrolment tables, When filtering for Master's degree students, When filtering for Bachelor's degree students, When finding semesters with both degree types: use INTERSECT between two separate queries to find common semester_ids that satisfy both conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT semester_id FROM enrollments WHERE student_type = 'Masters' AND student_type = 'Bachelors';",
            "SELECT DISTINCT T2.semester_id\nFROM Degree_Programs AS T1\nJOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id\nWHERE T1.degree_summary_name = 'Master'\nINTERSECT\nSELECT DISTINCT T2.semester_id\nFROM Degree_Programs AS T1\nJOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id\nWHERE T1.degree_summary_name = 'Bachelor'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.semester_id\nFROM Degree_Programs T1\nINNER JOIN Student_Enrolment T2 ON T1.degree_program_id = T2.degree_program_id\nWHERE T1.degree_summary_name = 'Master'\nINTERSECT\nSELECT DISTINCT T2.semester_id\nFROM Degree_Programs T1\nINNER JOIN Student_Enrolment T2 ON T1.degree_program_id = T2.degree_program_id\nWHERE T1.degree_summary_name = 'Bachelor'"
        ]
    },
    "577": {
        "db_id": "student_transcripts_tracking",
        "question": "How many different addresses do the students currently live?",
        "ground_truth": "SELECT count(DISTINCT current_address_id) FROM Students",
        "amends": [
            "Do use `count(DISTINCT current_address_id)` instead of `COUNT(*)` to count unique addresses rather than all rows. Do reference the `current_address_id` column instead of checking `address IS NOT NULL` to properly identify distinct address records. Do remove the `WHERE address IS NOT NULL` filter instead of keeping it since the distinct count inherently handles null values appropriately. The amended query now correctly counts distinct address identifiers rather than all student records with non-null address fields, matching the intended behavior."
        ],
        "rules": [
            "When counting different addresses that students currently live: use count(DISTINCT current_address_id) instead of COUNT(*) to count unique addresses rather than all rows.",
            "When referencing address information: use the current_address_id column instead of checking address IS NOT NULL to properly identify distinct address records.",
            "When counting different addresses that students currently live, When referencing address information, When handling null values in address counting: remove any WHERE address IS NOT NULL filter since the distinct count inherently handles null values appropriately."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE address IS NOT NULL",
            "SELECT COUNT(DISTINCT current_address_id) FROM Students;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT current_address_id) FROM Students;"
        ]
    },
    "578": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the different addresses that have students living there?",
        "ground_truth": "SELECT count(DISTINCT current_address_id) FROM Students",
        "amends": [
            "Do use `count(DISTINCT current_address_id)` instead of `SELECT DISTINCT address` to count unique addresses rather than listing them. Do reference `current_address_id` instead of `address` to use the correct column identifier. Do remove the `WHERE student_id IS NOT NULL` filter instead of keeping it since the count should include all students regardless of student_id status. Do change from selecting distinct values to counting distinct values to return a single aggregate result instead of a list of individual addresses."
        ],
        "rules": [
            "When the question asks for \"different addresses that have students living there\": use count(DISTINCT current_address_id) instead of SELECT DISTINCT address to count unique addresses rather than listing them.",
            "When referencing addresses in the Students table: use current_address_id instead of address as the correct column identifier.",
            "When counting addresses with students: remove any WHERE student_id IS NOT NULL filter since the count should include all students regardless of student_id status.",
            "When the question asks for \"different addresses that have students living there\", When referencing addresses in the Students table, When counting addresses with students, When the question asks for a count of distinct addresses: change from selecting distinct values to counting distinct values to return a single aggregate result instead of a list of individual addresses."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT address FROM students WHERE student_id IS NOT NULL",
            "SELECT COUNT(DISTINCT current_address_id) FROM Students;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT current_address_id) FROM Students;"
        ]
    },
    "579": {
        "db_id": "student_transcripts_tracking",
        "question": "List all the student details in reversed lexicographical order.",
        "ground_truth": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC",
        "amends": [
            "Do select `other_student_details` instead of `*` to return only specific columns instead of all columns. Do order by `other_student_details DESC` instead of `name ASC` to sort by a different column in descending order instead of ascending order. The amended query now correctly returns only the other_student_details column sorted in descending order, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for \"student details\": select only the \"other_student_details\" column instead of all columns.",
            "When the question asks for \"student details\", When the question specifies \"reversed lexicographical order\": sort the results by \"other_student_details\" in descending order instead of ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM students ORDER BY name ASC;",
            "SELECT other_student_details FROM Students ORDER BY other_student_details DESC;"
        ],
        "rule_sql": [
            "SELECT other_student_details FROM Students ORDER BY other_student_details DESC;"
        ]
    },
    "580": {
        "db_id": "student_transcripts_tracking",
        "question": "What other details can you tell me about students in reverse alphabetical order?",
        "ground_truth": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC",
        "amends": [
            "Do select `other_student_details` instead of `*` to return only specific columns instead of all columns. Do order by `other_student_details DESC` instead of `name ASC` to sort by a different column in descending order instead of ascending order. The amended query now correctly returns only the other_student_details column sorted in descending order, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for \"other details\" about students: select only the \"other_student_details\" column instead of all columns.",
            "When ordering results in reverse alphabetical order: sort by \"other_student_details\" in descending order instead of ascending order.",
            "When the question asks for \"other details\" about students, When ordering results in reverse alphabetical order, When the question specifies reverse alphabetical order: use descending order on the text column rather than ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM students ORDER BY name ASC;",
            "SELECT other_student_details FROM Students ORDER BY other_student_details DESC;"
        ],
        "rule_sql": [
            "SELECT other_student_details FROM Students ORDER BY other_student_details DESC;"
        ]
    },
    "581": {
        "db_id": "student_transcripts_tracking",
        "question": "Describe the section h.",
        "ground_truth": "SELECT section_description FROM Sections WHERE section_name  =  'h'",
        "amends": [
            "Do select only `section_description` instead of all columns with `*`. Do reference the table as `Sections` (case-sensitive) instead of `sections`. The amended query now correctly retrieves only the section description from the specified table while maintaining the same filter condition."
        ],
        "rules": [
            "When the question asks to describe a specific section: select only the \"section_description\" column instead of all columns.",
            "When referencing the Sections table: use the exact case-sensitive identifier \"Sections\" instead of lowercase \"sections\".",
            "When the question asks to describe a specific section, When referencing the Sections table, When filtering for a specific section: use the exact literal value 'h' to match the section name condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM sections WHERE section_name = 'h';",
            "SELECT section_description FROM Sections WHERE section_name = 'h';"
        ],
        "rule_sql": [
            "SELECT section_description FROM Sections WHERE section_name = 'h';"
        ]
    },
    "582": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the description for the section named h?",
        "ground_truth": "SELECT section_description FROM Sections WHERE section_name  =  'h'",
        "amends": [
            "Do reference the column as `section_description` instead of `description` and use the table name `Sections` instead of `sections`. Do use the filter condition `section_name = 'h'` instead of `name = 'h'` to correctly match the column names in the schema. The amended query now properly selects from the Sections table with the correct column references."
        ],
        "rules": [
            "When the question asks for \"description\" of a section: use the exact column token \"section_description\" from the Sections table instead of \"description\".",
            "When filtering by section name: use the exact column token \"section_name\" with the literal value 'h' exactly as specified.",
            "When the question asks for \"description\" of a section, When filtering by section name, When referencing the table containing section information: use the exact table name \"Sections\" with proper capitalization as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description FROM sections WHERE name = 'h';",
            "SELECT section_description FROM Sections WHERE section_name = 'h'"
        ],
        "rule_sql": [
            "SELECT section_description FROM Sections WHERE section_name = 'h';"
        ]
    },
    "583": {
        "db_id": "student_transcripts_tracking",
        "question": "Find the first name of the students who permanently live in the country Haiti or have the cell phone number 09700166582 .",
        "ground_truth": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  'haiti' or t1.cell_mobile_number  =  '09700166582'",
        "amends": [
            "Do join `addresses as t2` instead of querying only the `students` table. Do use `ON t1.permanent_address_id = t2.address_id` instead of missing this join condition. Do change the WHERE clause to `t2.country = 'haiti' OR t1.cell_mobile_number = '09700166582'` instead of `country = 'Haiti' AND cell_phone = '09700166582'`, correcting both the column references and the logical operator from AND to OR. Do reference `t1.first_name` with table alias instead of just `first_name`. Do use lowercase 'haiti' instead of 'Haiti' for case consistency. The amended query now correctly joins the addresses table and uses proper OR logic to find records matching either condition."
        ],
        "rules": [
            "When answering about students who live in Haiti or have a specific phone number: join table \"students\" as T1 with table \"addresses\" as T2 using the condition T1.permanent_address_id = T2.address_id.",
            "When the question mentions \"permanently live in the country Haiti\": use T2.country = 'haiti' (lowercase) instead of 'Haiti'.",
            "When the question mentions \"cell phone number 09700166582\": use T1.cell_mobile_number = '09700166582' instead of cell_phone.",
            "When combining conditions with \"or\": use OR logical operator instead of AND.",
            "When answering about students who live in Haiti or have a specific phone number, When the question mentions \"permanently live in the country Haiti\", When the question mentions \"cell phone number 09700166582\", When combining conditions with \"or\", When selecting first names: reference T1.first_name with table alias instead of just first_name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE country = 'Haiti' AND cell_phone = '09700166582';",
            "SELECT t1.first_name \nFROM Students t1\nJOIN Addresses t2 ON t1.permanent_address_id = t2.address_id\nWHERE t2.country = 'haiti' OR t1.cell_mobile_number = '09700166582'"
        ],
        "rule_sql": [
            "SELECT T1.first_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.permanent_address_id = T2.address_id WHERE T2.country = 'haiti' OR T1.cell_mobile_number = '09700166582'"
        ]
    },
    "584": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the first names of the students who live in Haiti permanently or have the cell phone number 09700166582 ?",
        "ground_truth": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  'haiti' or t1.cell_mobile_number  =  '09700166582'",
        "amends": [
            "Do select `t1.first_name` from the `students` table with alias `t1` instead of `first_name` from `students` without an alias. Do add a `JOIN` with the `addresses` table as `t2` on `t1.permanent_address_id = t2.address_id` instead of querying only the `students` table. Do filter on `t2.country = 'haiti'` instead of `country = 'Haiti'` to reference the joined table's column with correct case. Do filter on `t1.cell_mobile_number = '09700166582'` instead of `phone_number = '09700166582'` to use the correct column name from the students table. The amended query now correctly joins address data and uses proper column references to match the intended logic."
        ],
        "rules": [
            "When selecting student first names: use t1.first_name from the students table with alias t1.",
            "When the question mentions students who live in Haiti permanently: join the addresses table as t2 on t1.permanent_address_id = t2.address_id and filter on t2.country = 'haiti' (lowercase).",
            "When the question mentions students with cell phone number 09700166582: filter on t1.cell_mobile_number = '09700166582' from the students table.",
            "When selecting student first names, When the question mentions students who live in Haiti permanently, When the question mentions students with cell phone number 09700166582, When combining both conditions: use OR logic between the permanent address condition and cell phone number condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE country = 'Haiti' OR phone_number = '09700166582';",
            "SELECT t1.first_name FROM Students t1 JOIN Addresses t2 ON t1.permanent_address_id = t2.address_id WHERE t2.country = 'haiti' OR t1.cell_mobile_number = '09700166582'"
        ],
        "rule_sql": [
            "SELECT t1.first_name\nFROM Students t1\nLEFT JOIN Addresses t2 ON t1.permanent_address_id = t2.address_id\nWHERE (t2.country = 'haiti') OR (t1.cell_mobile_number = '09700166582')"
        ]
    },
    "585": {
        "db_id": "tvshow",
        "question": "List the title of all cartoons in alphabetical order.",
        "ground_truth": "SELECT Title FROM Cartoon ORDER BY title",
        "amends": [
            "Do use the exact table name `Cartoon` instead of the pluralized `cartoons` to match the correct schema. Do use the exact column name `Title` with proper capitalization instead of lowercase `title` to match the column definition. Do remove the `DESC` modifier from the `ORDER BY` clause instead of keeping descending order, resulting in ascending alphabetical sorting by default. The amended query now correctly selects from the Cartoon table with proper column naming and sorting behavior."
        ],
        "rules": [
            "When answering about \"cartoons\": use the exact table name \"Cartoon\" instead of pluralized forms.",
            "When the question mentions \"title\": use the exact column name \"Title\" with proper capitalization.",
            "When answering about \"cartoons\", When the question mentions \"title\", When the question asks for alphabetical order: sort by the column in ascending order by default (do not use DESC modifier)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM cartoons ORDER BY title DESC;",
            "SELECT Title FROM Cartoon ORDER BY Title;"
        ],
        "rule_sql": [
            "SELECT Title FROM Cartoon ORDER BY Title ASC;"
        ]
    },
    "586": {
        "db_id": "tvshow",
        "question": "What are the titles of the cartoons sorted alphabetically?",
        "ground_truth": "SELECT Title FROM Cartoon ORDER BY title",
        "amends": [
            "Do reference the table as `Cartoon` instead of `cartoons` and use the column name `Title` instead of `title` in the SELECT clause. Do remove the `DESC` modifier from the `ORDER BY title` clause instead of keeping descending order. The amended query now correctly references the proper table and column names while maintaining ascending order by default."
        ],
        "rules": [
            "When answering about \"titles of the cartoons sorted alphabetically\": make sure the output order: \"Title\" in ascending alphabetical order.",
            "When the question mentions \"cartoons\": \"cartoons\" actually means table \"Cartoon\" in schema.",
            "When the question mentions \"titles\": \"titles\" actually means column \"Title\" in table \"Cartoon\".",
            "When answering about \"titles of the cartoons sorted alphabetically\", When the question mentions \"cartoons\", When the question mentions \"titles\", When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table \"Cartoon\" and column \"Title\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM cartoons ORDER BY title DESC;",
            "SELECT Title FROM Cartoon ORDER BY Title;"
        ],
        "rule_sql": [
            "SELECT \"Title\" FROM \"Cartoon\" ORDER BY \"Title\" ASC;"
        ]
    },
    "587": {
        "db_id": "tvshow",
        "question": "List all cartoon directed by \"Ben Jones\".",
        "ground_truth": "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\";",
        "amends": [
            "Do specify `Title` in the SELECT list instead of using `*` to select all columns. Do reference the table as `Cartoon` instead of `cartoons` in the FROM clause. Do use the column name `Directed_by` instead of `director` in the WHERE filter. Do use double quotes around the string literal \"Ben Jones\" instead of single quotes. The amended query now correctly retrieves only the Title column from the Cartoon table where Directed_by equals Ben Jones, matching the intended behavior."
        ],
        "rules": [
            "When the question asks to list cartoons: select only the \"Title\" column instead of all columns.",
            "When referencing the cartoon table: use the exact table name \"Cartoon\" with proper casing.",
            "When filtering by director: use the exact column name \"Directed_by\" instead of \"director\".",
            "When the question asks to list cartoons, When referencing the cartoon table, When filtering by director, When matching the director name \"Ben Jones\": use double quotes around the literal \"Ben Jones\" instead of single quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM cartoons WHERE director = 'Ben Jones';",
            "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\";"
        ],
        "rule_sql": [
            "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\";"
        ]
    },
    "588": {
        "db_id": "tvshow",
        "question": "What are the names of all cartoons directed by Ben Jones?",
        "ground_truth": "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\";",
        "amends": [
            "Do reference the table as `Cartoon` instead of `cartoons` and use the column `Directed_by` instead of `director` for the filter condition. Do use double quotes around the string literal \"Ben Jones\" instead of single quotes. Do capitalize the output column as `Title` instead of `title` to match the correct column name. The amended query now correctly references the proper table and column names while maintaining the same filtering logic for director Ben Jones."
        ],
        "rules": [
            "When the question asks about cartoons directed by Ben Jones: use the table name \"Cartoon\" instead of \"cartoons\".",
            "When filtering for director Ben Jones: use the column \"Directed_by\" instead of \"director\" and the exact string literal \"Ben Jones\" with double quotes.",
            "When the question asks about cartoons directed by Ben Jones, When filtering for director Ben Jones, When selecting cartoon titles: use the column \"Title\" instead of \"title\" for the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM cartoons WHERE director = 'Ben Jones';",
            "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\";"
        ],
        "rule_sql": [
            "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\";"
        ]
    },
    "589": {
        "db_id": "tvshow",
        "question": "How many cartoons were written by \"Joseph Kuhr\"?",
        "ground_truth": "SELECT count(*) FROM Cartoon WHERE Written_by = \"Joseph Kuhr\";",
        "amends": [
            "Do reference the table as `Cartoon` instead of `cartoons` to match the correct table name. Do use the column name `Written_by` instead of `writer` to properly identify the writer column. Do use double quotes `\"Joseph Kuhr\"` instead of single quotes `'Joseph Kuhr'` for the string literal format. The amended query now correctly counts records from the Cartoon table where Written_by equals Joseph Kuhr, matching the right SQL's behavior."
        ],
        "rules": [
            "When the question asks about cartoons: use the exact table name \"Cartoon\" with double quotes as shown in the schema.",
            "When the question mentions \"written by\": use the exact column name \"Written_by\" with double quotes to identify the writer column.",
            "When the question specifies the writer \"Joseph Kuhr\": use the exact literal format with double quotes as \"Joseph Kuhr\" to match the string value.",
            "When the question asks about cartoons, When the question mentions \"written by\", When the question specifies the writer \"Joseph Kuhr\", When counting cartoons: count the number of rows in the \"Cartoon\" table where \"Written_by\" equals \"Joseph Kuhr\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cartoons WHERE writer = 'Joseph Kuhr';",
            "SELECT COUNT(*) FROM Cartoon WHERE Written_by = \"Joseph Kuhr\";"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM \"Cartoon\" WHERE \"Written_by\" = \"Joseph Kuhr\""
        ]
    },
    "590": {
        "db_id": "tvshow",
        "question": "What is the number of cartoones written by Joseph Kuhr?",
        "ground_truth": "SELECT count(*) FROM Cartoon WHERE Written_by = \"Joseph Kuhr\";",
        "amends": [
            "Do reference the table as `Cartoon` instead of `cartoons` and use the column name `Written_by` instead of `writer` for the filter condition, while maintaining the same aggregate `count(*)` functionality. The amended query now correctly matches the RIGHT_SQL's behavior by using the proper table and column names from the schema."
        ],
        "rules": [
            "When the question mentions \"cartoons\": the exact table name is \"Cartoon\" with double quotes.",
            "When the question mentions \"written by Joseph Kuhr\": the exact column name is \"Written_by\" with double quotes and the exact literal value is 'Joseph Kuhr'.",
            "When the question mentions \"cartoons\", When the question mentions \"written by Joseph Kuhr\", When counting entities from table \"Cartoon\": use the canonical key \"Written_by\" for counting operations."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cartoons WHERE writer = 'Joseph Kuhr';",
            "SELECT COUNT(*) FROM Cartoon WHERE Written_by = 'Joseph Kuhr'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM \"Cartoon\" WHERE \"Written_by\" = 'Joseph Kuhr';"
        ]
    },
    "591": {
        "db_id": "tvshow",
        "question": "list all cartoon titles and their directors ordered by their air date",
        "ground_truth": "SELECT title ,  Directed_by FROM Cartoon ORDER BY Original_air_date",
        "amends": [
            "Do select `Directed_by` instead of `director` and order by `Original_air_date` instead of `title`. Do reference table `Cartoon` instead of `cartoons` and remove the column `title` from the SELECT list instead of including it. The amended query now correctly retrieves the directed by information ordered by original air date from the Cartoon table."
        ],
        "rules": [
            "When the question asks for cartoon titles and directors: select \"Directed_by\" from table \"Cartoon\" instead of \"director\" from \"cartoons\".",
            "When ordering by air date: order by \"Original_air_date\" instead of \"title\".",
            "When referencing the table: use \"Cartoon\" instead of \"cartoons\".",
            "When the question asks for cartoon titles and directors, When ordering by air date, When referencing the table, When selecting columns: do not include \"title\" in the output columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title, director FROM cartoons ORDER BY title;",
            "SELECT Title, Directed_by FROM Cartoon ORDER BY Original_air_date;"
        ],
        "rule_sql": [
            "SELECT Title, Directed_by FROM Cartoon ORDER BY Original_air_date;"
        ]
    },
    "592": {
        "db_id": "tvshow",
        "question": "What is the name and directors of all the cartoons that are ordered by air date?",
        "ground_truth": "SELECT title ,  Directed_by FROM Cartoon ORDER BY Original_air_date",
        "amends": [
            "Do use column names `title` and `Directed_by` instead of `name` and `directors`. Do reference table `Cartoon` instead of `cartoons`. Do order by `Original_air_date` instead of `release_date`. The amended query now correctly matches the intended schema and behavior."
        ],
        "rules": [
            "When the question asks for \"name\" of cartoons: use column \"title\" from table \"Cartoon\" instead.",
            "When the question asks for \"directors\" of cartoons: use column \"Directed_by\" from table \"Cartoon\" instead.",
            "When the question mentions ordering by \"air date\": use column \"Original_air_date\" from table \"Cartoon\" for ordering.",
            "When the question asks for \"name\" of cartoons, When the question asks for \"directors\" of cartoons, When the question mentions ordering by \"air date\", When answering about cartoons ordered by air date: make sure the output order includes \"title\" and \"Directed_by\" columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, directors FROM cartoons ORDER BY release_date;",
            "SELECT Title, Directed_by FROM Cartoon ORDER BY Original_air_date;"
        ],
        "rule_sql": [
            "SELECT Title, Directed_by FROM Cartoon ORDER BY Original_air_date;"
        ]
    },
    "593": {
        "db_id": "tvshow",
        "question": "List the title of all cartoon directed by \"Ben Jones\" or \"Brandon Vietti\".",
        "ground_truth": "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\" OR Directed_by = \"Brandon Vietti\";",
        "amends": [
            "Do use `OR` instead of `AND` for the director condition to find records matching either director instead of requiring both simultaneously. Do reference the correct table name `Cartoon` instead of `cartoons` and use the correct column name `Directed_by` instead of `director`. Do use proper column casing `Title` instead of `title` and maintain consistent quotation style with double quotes around director names instead of single quotes. The amended query now correctly returns cartoons directed by either Ben Jones or Brandon Vietti instead of incorrectly requiring both directors simultaneously, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for cartoons directed by multiple directors: use OR instead of AND to find records matching any of the specified directors rather than requiring all simultaneously.",
            "When referencing the cartoon table: use the exact table name \"Cartoon\" instead of variations like \"cartoons\".",
            "When selecting the director column: use the exact column name \"Directed_by\" instead of \"director\".",
            "When selecting the title column: use the exact column name \"Title\" instead of \"title\".",
            "When the question asks for cartoons directed by multiple directors, When referencing the cartoon table, When selecting the director column, When selecting the title column, When specifying director names in conditions: use double quotes around literal values like \"Ben Jones\" and \"Brandon Vietti\" to maintain consistent quotation style."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM cartoons WHERE director = 'Ben Jones' AND director = 'Brandon Vietti'",
            "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\" OR Directed_by = \"Brandon Vietti\""
        ],
        "rule_sql": [
            "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\" OR Directed_by = \"Brandon Vietti\";"
        ]
    },
    "594": {
        "db_id": "tvshow",
        "question": "What are the titles of all cartoons directed by Ben Jones or Brandon Vietti?",
        "ground_truth": "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\" OR Directed_by = \"Brandon Vietti\";",
        "amends": [
            "Do reference the table as `Cartoon` instead of `cartoons` and use column `Directed_by` instead of `director`. Do use `OR` logic between the director conditions instead of `AND` which would return no results since a director cannot be both people simultaneously. Do use proper column name `Title` instead of `title` and maintain the correct table and column casing. The amended query now correctly returns cartoons directed by either Ben Jones or Brandon Vietti instead of incorrectly requiring both conditions to be true."
        ],
        "rules": [
            "When the question asks for cartoon titles: use the exact column name \"Title\" from table \"Cartoon\".",
            "When the question mentions directors \"Ben Jones\" or \"Brandon Vietti\": use the exact column name \"Directed_by\" and match the exact literal values 'Ben Jones' or 'Brandon Vietti'.",
            "When the question uses \"or\" logic between multiple director conditions: use OR operator instead of AND to find cartoons directed by either person.",
            "When the question asks for cartoon titles, When the question mentions directors \"Ben Jones\" or \"Brandon Vietti\", When the question uses \"or\" logic between multiple director conditions, When referencing the table containing cartoon information: use the exact table name \"Cartoon\" instead of variations like \"cartoons\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM cartoons WHERE director = 'Ben Jones' AND director = 'Brandon Vietti';",
            "SELECT Title FROM Cartoon WHERE Directed_by = 'Ben Jones' OR Directed_by = 'Brandon Vietti';"
        ],
        "rule_sql": [
            "SELECT Title FROM Cartoon WHERE Directed_by = 'Ben Jones' OR Directed_by = 'Brandon Vietti'"
        ]
    },
    "595": {
        "db_id": "tvshow",
        "question": "Which country has the most of TV Channels? List the country and number of TV Channels it has.",
        "ground_truth": "SELECT Country ,  count(*) FROM TV_Channel GROUP BY Country ORDER BY count(*) DESC LIMIT 1;",
        "amends": [
            "Do `ORDER BY count(*) DESC` instead of `ORDER BY channel_count ASC` to sort by descending count rather than ascending. Do use `TV_Channel` as the table name instead of `tv_channels` to match the correct source. Do remove the alias `as channel_count` instead of keeping it since the right query uses the raw aggregate expression. Do use `Country` with proper capitalization instead of `country` to match the column name exactly. The amended query now correctly identifies the country with the highest number of TV channels by sorting in descending order and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for \"most TV Channels\" or \"highest number\": rank countries by count of TV channels in descending order and keep only the top 1 country.",
            "When counting TV channels per country: count using the canonical key from TV_Channel table and group by the exact column \"Country\".",
            "When ordering results: sort by the count in descending order rather than ascending to get the highest count first.",
            "When referring to the table: use the exact table name \"TV_Channel\" with proper capitalization instead of variations like \"tv_channels\".",
            "When referring to the country column: use the exact column name \"Country\" with proper capitalization instead of lowercase \"country\".",
            "When the question asks for \"most TV Channels\" or \"highest number\", When counting TV channels per country, When ordering results, When referring to the table, When referring to the country column, When outputting results: include both the country name and the count value without using aliases for the aggregate expression."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country, COUNT(*) as channel_count FROM tv_channels GROUP BY country ORDER BY channel_count ASC LIMIT 1;",
            "SELECT Country, COUNT(*) FROM TV_Channel GROUP BY Country ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Country, COUNT(id) FROM TV_Channel GROUP BY Country ORDER BY COUNT(id) DESC LIMIT 1;"
        ]
    },
    "596": {
        "db_id": "tvshow",
        "question": "What is the country with the most number of TV Channels and how many does it have?",
        "ground_truth": "SELECT Country ,  count(*) FROM TV_Channel GROUP BY Country ORDER BY count(*) DESC LIMIT 1;",
        "amends": [
            "Do use `count(*)` without an alias instead of `COUNT(*) as channel_count` in the SELECT list. Do reference the table as `TV_Channel` instead of `tv_channels` in the FROM clause. Do use `Country` with proper case instead of `country` in both SELECT and GROUP BY clauses. Do order by `count(*)` directly instead of the aliased `channel_count` in the ORDER BY clause. The amended query now correctly counts channels per country and returns the country with the highest count, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"country with the most number of TV Channels\": make sure the output order: Country, count(*)",
            "When the question mentions \"country\": \"country\" actually means \"Country in schema\"",
            "When the question mentions \"most number\" or \"highest count\": rank rows by count(*) in descending direction and keep the first 1 row.",
            "When the question asks for \"count of TV Channels\" per country: compute the number of rows using the canonical key for TV_Channel (Country).",
            "When the question says \"per country\"/\"by country\": organize results by Country and compute count(*) per group.",
            "When choosing identifier delimiters: do not replace proper case identifiers with lowercase forms.",
            "When answering about \"country with the most number of TV Channels\", When the question mentions \"country\", When the question mentions \"most number\" or \"highest count\", When the question asks for \"count of TV Channels\" per country, When the question says \"per country\"/\"by country\", When choosing identifier delimiters, When referring to table roles: use TV_Channel as the base table with no alias needed."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country, COUNT(*) as channel_count FROM tv_channels GROUP BY country ORDER BY channel_count DESC LIMIT 1;",
            "SELECT Country, count(*) FROM TV_Channel GROUP BY Country ORDER BY count(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Country, COUNT(*) FROM TV_Channel GROUP BY Country ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "597": {
        "db_id": "tvshow",
        "question": "List the number of different series names and contents in the TV Channel table.",
        "ground_truth": "SELECT count(DISTINCT series_name) ,  count(DISTINCT content) FROM TV_Channel;",
        "amends": [
            "Do use `count(DISTINCT series_name)` instead of `COUNT(series_name)` to count unique values rather than all non-null values. Do use `count(DISTINCT content)` instead of `COUNT(contents)` to count distinct values and reference the correct column name `content` instead of `contents`. The amended query now correctly counts distinct series names and distinct content values, matching the intended behavior of the RIGHT_SQL."
        ],
        "rules": [
            "When counting different series names: count the number of unique values in the \"series_name\" column using count(DISTINCT series_name).",
            "When counting different contents: count the number of unique values in the \"content\" column using count(DISTINCT content) and ensure the exact column name \"content\" is used instead of \"contents\".",
            "When counting different series names, When counting different contents, When answering about number of different series names and contents: make sure the output order shows count of distinct series names first, followed by count of distinct content values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(series_name), COUNT(contents) FROM TV_Channel",
            "SELECT COUNT(DISTINCT series_name), COUNT(DISTINCT content) FROM TV_Channel;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT series_name) AS distinct_series_names, COUNT(DISTINCT Content) AS distinct_contents FROM TV_Channel;"
        ]
    },
    "598": {
        "db_id": "tvshow",
        "question": "How many different series and contents are listed in the TV Channel table?",
        "ground_truth": "SELECT count(DISTINCT series_name) ,  count(DISTINCT content) FROM TV_Channel;",
        "amends": [
            "Do select `count(DISTINCT series_name)` and `count(DISTINCT content)` instead of just `COUNT(*)`. Do add distinct counting for both `series_name` and `content` columns instead of counting all rows without distinction. The amended query now correctly counts unique series names and unique content values separately instead of providing a single total row count, matching the right SQL's behavior."
        ],
        "rules": [
            "When the question asks for \"different series and contents\": count distinct values for both \"series_name\" and \"content\" columns separately instead of counting all rows.",
            "When counting distinct entities: use DISTINCT counting for each specified column (\"series_name\" and \"content\") rather than a single COUNT(*) that counts total rows.",
            "When the question asks for \"different series and contents\", When counting distinct entities, When the question mentions \"series\" and \"contents\": these refer to the exact column tokens \"series_name\" and \"content\" in the TV_Channel table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM TV_Channel;",
            "SELECT COUNT(DISTINCT series_name) AS unique_series_count, COUNT(DISTINCT Content) AS unique_content_count FROM TV_Channel;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT series_name) AS distinct_series, COUNT(DISTINCT Content) AS distinct_contents FROM TV_Channel;"
        ]
    },
    "599": {
        "db_id": "tvshow",
        "question": "What is the content of TV Channel with serial name \"Sky Radio\"?",
        "ground_truth": "SELECT Content FROM TV_Channel WHERE series_name = \"Sky Radio\";",
        "amends": [
            "Do select `Content` instead of `*` for all columns. Do reference table `TV_Channel` instead of `tv_channels`. Do filter on `series_name` instead of `channel_name`. Do use double quotes `\"Sky Radio\"` instead of single quotes for the string literal. The amended query now correctly retrieves the specified content from the TV_Channel table based on the series name rather than channel name."
        ],
        "rules": [
            "When answering about \"content of TV Channel with serial name\": make sure the output order: Content.",
            "When the question mentions \"serial name\": \"serial name\" actually means \"series_name in schema\".",
            "When the question mentions \"TV Channel\": use table \"TV_Channel\" instead of \"tv_channels\".",
            "When filtering for the literal \"Sky Radio\": use double quotes \"Sky Radio\" exactly as specified.",
            "When answering about \"content of TV Channel with serial name\", When the question mentions \"serial name\", When the question mentions \"TV Channel\", When filtering for the literal \"Sky Radio\", When selecting content from TV_Channel: select only the \"Content\" column instead of all columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM tv_channels WHERE channel_name = 'Sky Radio';",
            "SELECT Content FROM TV_Channel WHERE series_name = \"Sky Radio\";"
        ],
        "rule_sql": [
            "SELECT Content FROM TV_Channel WHERE series_name = \"Sky Radio\";"
        ]
    },
    "600": {
        "db_id": "tvshow",
        "question": "What is the content of the series Sky Radio?",
        "ground_truth": "SELECT Content FROM TV_Channel WHERE series_name = \"Sky Radio\";",
        "amends": [
            "Do select `Content` instead of `*` to specify the exact column needed. Do query from `TV_Channel` instead of `series` to access the correct table containing the content data. Do filter on `series_name` instead of `title` to use the appropriate column name for series identification. Do use double quotes `\"Sky Radio\"` instead of single quotes for string literal consistency. The amended query now correctly retrieves content from the TV_Channel table filtered by series name, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"content of the series\": make sure the output order: \"Content\"",
            "When the question mentions \"series\": \"series\" actually means \"series_name in TV_Channel table\"",
            "When filtering for a specific series name: use double quotes for string literals exactly as shown (e.g., \"Sky Radio\")",
            "When selecting from the TV_Channel table: use the exact column name \"Content\" to retrieve the content data",
            "When answering about \"content of the series\", When the question mentions \"series\", When filtering for a specific series name, When selecting from the TV_Channel table, When handling text literals: do not change case, spacing, or punctuation from the exact value \"Sky Radio\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM series WHERE title = 'Sky Radio';",
            "SELECT Content FROM TV_Channel WHERE series_name = \"Sky Radio\";"
        ],
        "rule_sql": [
            "SELECT Content FROM TV_Channel WHERE series_name = \"Sky Radio\";"
        ]
    },
    "601": {
        "db_id": "tvshow",
        "question": "What is the Package Option of TV Channel with serial name \"Sky Radio\"?",
        "ground_truth": "SELECT Package_Option FROM TV_Channel WHERE series_name = \"Sky Radio\";",
        "amends": [
            "Do reference table `TV_Channel` instead of `TV_Channels` and use column `series_name` instead of `serial_name` while maintaining the same filter value for 'Sky Radio'."
        ],
        "rules": [
            "When the question mentions \"serial name\": \"serial name\" actually means \"series_name\" in schema.",
            "When the question asks about TV Channel: use table \"TV_Channel\" instead of \"TV_Channels\".",
            "When filtering for channel with name \"Sky Radio\": use exact literal value 'Sky Radio' with correct case and spacing.",
            "When the question mentions \"serial name\", When the question asks about TV Channel, When filtering for channel with name \"Sky Radio\", When answering about \"Package Option of TV Channel\": make sure the output order: Package_Option."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Package_Option FROM TV_Channels WHERE serial_name = 'Sky Radio';",
            "SELECT Package_Option FROM TV_Channel WHERE series_name = 'Sky Radio';"
        ],
        "rule_sql": [
            "SELECT Package_Option FROM TV_Channel WHERE series_name = 'Sky Radio';"
        ]
    },
    "602": {
        "db_id": "tvshow",
        "question": "What are the Package Options of the TV Channels whose series names are Sky Radio?",
        "ground_truth": "SELECT Package_Option FROM TV_Channel WHERE series_name = \"Sky Radio\";",
        "amends": [
            "Do reference the column as `Package_Option` instead of `Package_Options` to match the correct column name. Do reference the table as `TV_Channel` instead of `TV_Channels` to use the correct singular table name. Do use double quotes `\"Sky Radio\"` instead of single quotes `'Sky Radio'` for the string literal format. The amended query now correctly retrieves the package option from the TV channel table for the specified series."
        ],
        "rules": [
            "When the question asks about \"Package Options\": use the exact column name \"Package_Option\" from table \"TV_Channel\".",
            "When the question refers to \"TV Channels\": use the exact table name \"TV_Channel\" (singular form).",
            "When filtering for series names equal to \"Sky Radio\": use double quotes around the literal value as \"Sky Radio\" exactly.",
            "When the question asks about \"Package Options\", When the question refers to \"TV Channels\", When filtering for series names equal to \"Sky Radio\", When answering about package options for TV channels with specific series names: make sure the output order shows only the Package_Option column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Package_Options FROM TV_Channels WHERE Series_Name = 'Sky Radio';",
            "SELECT \"Package_Option\" FROM \"TV_Channel\" WHERE \"series_name\" = \"Sky Radio\";"
        ],
        "rule_sql": [
            "SELECT Package_Option FROM TV_Channel WHERE series_name = \"Sky Radio\";"
        ]
    },
    "603": {
        "db_id": "tvshow",
        "question": "How many TV Channel using language English?",
        "ground_truth": "SELECT count(*) FROM TV_Channel WHERE LANGUAGE = \"English\";",
        "amends": [
            "Do use table name `TV_Channel` instead of `tv_channels` to reference the correct table. Do use double quotes `\"English\"` instead of single quotes `'English'` for the string literal, though this may be database-specific. The amended query now correctly counts records from the TV_Channel table where the language is English, matching the intended behavior."
        ],
        "rules": [
            "When referencing the TV Channel table: use the exact table name \"TV_Channel\" instead of \"tv_channels\".",
            "When filtering for language \"English\": use the exact string literal \"English\" with double quotes instead of single quotes.",
            "When referencing the TV Channel table, When filtering for language \"English\", When counting TV channels using English language: count all records from the \"TV_Channel\" table where the \"language\" column equals \"English\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM tv_channels WHERE language = 'English';",
            "SELECT COUNT(*) FROM \"TV_Channel\" WHERE \"Language\" = \"English\";"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM \"TV_Channel\" WHERE \"Language\" = \"English\";"
        ]
    },
    "604": {
        "db_id": "tvshow",
        "question": "How many TV Channels use the English language?",
        "ground_truth": "SELECT count(*) FROM TV_Channel WHERE LANGUAGE = \"English\";",
        "amends": [
            "Do reference table `TV_Channel` instead of `channels` while keeping the same count aggregation and English language filter, maintaining identical query behavior with the amended table name."
        ],
        "rules": [
            "When answering about \"TV Channels\": use table \"TV_Channel\" instead of \"channels\".",
            "When the question mentions \"English language\": filter for rows where \"language\" equals exactly 'English'.",
            "When answering about \"TV Channels\", When the question mentions \"English language\", When the question asks for \"how many TV Channels\": count the number of rows in \"TV_Channel\" that satisfy the language condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM channels WHERE language = 'English';",
            "SELECT COUNT(*) FROM TV_Channel WHERE Language = 'English';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM TV_Channel WHERE Language = 'English';"
        ]
    },
    "605": {
        "db_id": "tvshow",
        "question": "List the language used least number of TV Channel. List language and number of TV Channel.",
        "ground_truth": "SELECT LANGUAGE ,  count(*) FROM TV_Channel GROUP BY LANGUAGE ORDER BY count(*) ASC LIMIT 1;",
        "amends": [
            "Do use `count(*)` without an alias instead of `COUNT(*) as channel_count` in the SELECT list. Do change the ORDER BY to `count(*) ASC` instead of `channel_count DESC`. Do remove the alias reference in ORDER BY and change the sort direction to ascending instead of descending. The amended query now correctly orders by the actual count in ascending order instead of using an aliased column reference with descending order."
        ],
        "rules": [
            "When counting TV Channels: use count(*) without an alias instead of COUNT(*) as channel_count.",
            "When ordering by the count of TV Channels: order by count(*) in ascending order instead of descending order.",
            "When counting TV Channels, When ordering by the count of TV Channels, When finding the language used least number of TV Channels: use ascending order on the count to get the minimum count value."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language, COUNT(*) as channel_count FROM TV_Channel GROUP BY language ORDER BY channel_count DESC LIMIT 1;",
            "SELECT Language, count(*) FROM TV_Channel GROUP BY Language ORDER BY count(*) ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Language, count(*) FROM TV_Channel GROUP BY Language ORDER BY count(*) ASC;"
        ]
    },
    "606": {
        "db_id": "tvshow",
        "question": "What are the languages used by the least number of TV Channels and how many channels use it?",
        "ground_truth": "SELECT LANGUAGE ,  count(*) FROM TV_Channel GROUP BY LANGUAGE ORDER BY count(*) ASC LIMIT 1;",
        "amends": [
            "Do use `count(*)` without an alias instead of `COUNT(*) as channel_count`. Do order by `count(*) ASC` instead of `channel_count DESC`. Do reference table `TV_Channel` instead of `tv_channels`. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for languages used by the least number of TV Channels: order the results by count in ascending order instead of descending.",
            "When counting TV Channels: use count(*) without an alias instead of COUNT(*) as channel_count.",
            "When the question asks for languages used by the least number of TV Channels, When counting TV Channels, When referencing the TV Channels table: use the exact table name TV_Channel instead of tv_channels."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language, COUNT(*) as channel_count FROM tv_channels GROUP BY language ORDER BY channel_count DESC LIMIT 1;",
            "SELECT Language, COUNT(*) FROM TV_Channel GROUP BY Language ORDER BY COUNT(*) ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Language, count(*) FROM TV_Channel GROUP BY Language ORDER BY count(*) ASC;"
        ]
    },
    "607": {
        "db_id": "tvshow",
        "question": "List each language and the number of TV Channels using it.",
        "ground_truth": "SELECT LANGUAGE ,  count(*) FROM TV_Channel GROUP BY LANGUAGE",
        "amends": [
            "Do use consistent case `LANGUAGE` instead of mixed case `language` for the column name. Do use consistent table name `TV_Channel` instead of `tv_channels` for the source table. The amended query now correctly counts records by language from the TV_Channel table with consistent naming conventions."
        ],
        "rules": [
            "When the question asks for languages and TV channel counts: use the exact column name \"LANGUAGE\" from the TV_Channel table.",
            "When counting TV channels per language: count the number of records using the canonical key from the TV_Channel table.",
            "When grouping results by language: organize the output by the \"LANGUAGE\" column and compute the count per group.",
            "When the question asks for languages and TV channel counts, When counting TV channels per language, When grouping results by language, When referring to the source table: use the exact table name \"TV_Channel\" with consistent case as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT language, COUNT(*) FROM tv_channels GROUP BY language;",
            "SELECT LANGUAGE, COUNT(*) AS number_of_channels FROM TV_Channel GROUP BY LANGUAGE;"
        ],
        "rule_sql": [
            "SELECT LANGUAGE, COUNT(id) AS number_of_channels FROM TV_Channel GROUP BY LANGUAGE;"
        ]
    },
    "608": {
        "db_id": "tvshow",
        "question": "For each language, list the number of TV Channels that use it.",
        "ground_truth": "SELECT LANGUAGE ,  count(*) FROM TV_Channel GROUP BY LANGUAGE",
        "amends": [
            "Do use the exact table name `TV_Channel` instead of `tv_channels` to match the correct schema. Do maintain the same column name `LANGUAGE` and aggregation `count(*)` with identical `GROUP BY LANGUAGE` logic, as there are no substantive differences in the SELECT list, aggregates, or grouping between the queries. The amended query now matches RIGHT_SQL's behavior by using the correct table reference while preserving identical query logic and results."
        ],
        "rules": [
            "When the question asks for \"number of TV Channels\" per language: count the rows using the canonical table \"TV_Channel\" and group by the exact column \"LANGUAGE\".",
            "When choosing table identifiers: use the exact table name \"TV_Channel\" with double quotes as shown in the schema, not alternative names like \"tv_channels\".",
            "When the question asks for \"number of TV Channels\" per language, When choosing table identifiers, When counting entities: use count(*) to count all rows in each language group rather than counting specific columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT language, COUNT(*) FROM tv_channels GROUP BY language;",
            "SELECT Language, COUNT(*) FROM TV_Channel GROUP BY Language"
        ],
        "rule_sql": [
            "SELECT \"Language\", COUNT(*) AS number_of_tv_channels FROM \"TV_Channel\" GROUP BY \"Language\""
        ]
    },
    "609": {
        "db_id": "tvshow",
        "question": "What is the TV Channel that shows the cartoon \"The Rise of the Blue Beetle!\"? List the TV Channel's series name.",
        "ground_truth": "SELECT T1.series_name FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Title = \"The Rise of the Blue Beetle!\";",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference `T2.Channel` instead of `cartoon.channel_id` in the join condition. Do reference `T2.Title` instead of `cartoon.title` in the WHERE filter. Do use double quotes around the string literal instead of single quotes. The amended query now correctly joins on the proper column names and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When joining tables tv_channel and cartoon: use table aliases T1 for tv_channel and T2 for cartoon instead of full table names.",
            "When linking T1 and T2: match rows where T1.id = T2.Channel (not cartoon.channel_id).",
            "When filtering for the cartoon title \"The Rise of the Blue Beetle!\": use T2.Title (not cartoon.title) with double quotes around the literal.",
            "When joining tables tv_channel and cartoon, When linking T1 and T2, When filtering for the cartoon title \"The Rise of the Blue Beetle!\", When outputting results: return T1.series_name as the TV Channel's series name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT tv_channel.series_name FROM tv_channel JOIN cartoon ON tv_channel.id = cartoon.channel_id WHERE cartoon.title = 'The Rise of the Blue Beetle!'",
            "SELECT T1.series_name FROM TV_Channel T1 JOIN Cartoon T2 ON T1.id = T2.Channel WHERE T2.Title = \"The Rise of the Blue Beetle!\""
        ],
        "rule_sql": [
            "SELECT T1.series_name FROM TV_Channel T1 JOIN Cartoon T2 ON T1.id = T2.Channel WHERE T2.Title = \"The Rise of the Blue Beetle!\""
        ]
    },
    "610": {
        "db_id": "tvshow",
        "question": "What is the series name of the TV Channel that shows the cartoon \"The Rise of the Blue Beetle\"?",
        "ground_truth": "SELECT T1.series_name FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Title = \"The Rise of the Blue Beetle!\";",
        "amends": [
            "Do join `TV_Channel AS T1` with `Cartoon AS T2` on `T1.id = T2.Channel` instead of querying only `tv_channels` table. Do filter on `T2.Title = \"The Rise of the Blue Beetle!\"` instead of `cartoon_name = 'The Rise of the Blue Beetle'`. Do select `T1.series_name` with table alias qualification instead of just `series_name`. The amended query now correctly joins the related tables and filters on the appropriate column to match the intended behavior."
        ],
        "rules": [
            "When the question asks about a TV Channel showing a specific cartoon: join TV_Channel AS T1 with Cartoon AS T2 on T1.id = T2.Channel to link channels with their cartoons.",
            "When filtering for a specific cartoon title \"The Rise of the Blue Beetle!\": use T2.Title = \"The Rise of the Blue Beetle!\" with exact punctuation and double quotes as shown.",
            "When selecting the series name of the TV Channel: use T1.series_name with table alias qualification instead of just series_name.",
            "When the question asks about a TV Channel showing a specific cartoon, When filtering for a specific cartoon title \"The Rise of the Blue Beetle!\", When selecting the series name of the TV Channel, When combining tables for shared entities: perform an inner match where T1.id = T2.Channel to keep only channels that actually show the specified cartoon."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT series_name FROM tv_channels WHERE cartoon_name = 'The Rise of the Blue Beetle';",
            "SELECT T1.series_name FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Title = 'The Rise of the Blue Beetle!'"
        ],
        "rule_sql": [
            "SELECT T1.series_name FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Title = \"The Rise of the Blue Beetle!\""
        ]
    },
    "611": {
        "db_id": "tvshow",
        "question": "List the title of all  Cartoons showed on TV Channel with series name \"Sky Radio\".",
        "ground_truth": "SELECT T2.Title FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T1.series_name = \"Sky Radio\";",
        "amends": [
            "Do select `T2.Title` instead of `title` and specify the table alias. Do join `TV_Channel AS T1` to `Cartoon AS T2` instead of querying only `Cartoons` table. Do use `ON T1.id = T2.Channel` for the join condition instead of a simple WHERE filter. Do filter on `T1.series_name = \"Sky Radio\"` instead of `channel = 'Sky Radio'` to properly reference the channel table. The amended query now correctly joins the channel table to retrieve cartoons associated with the specified channel series name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"Cartoons showed on TV Channel with series name 'Sky Radio'\": make sure the output order: T2.Title",
            "When the question mentions \"TV Channel with series name 'Sky Radio'\": \"series name\" actually means \"T1.series_name in schema\" and the literal value must be exactly \"Sky Radio\"",
            "When combining TV_Channel (T1) and Cartoon (T2) for shared entities: link rows where T1.id = T2.Channel exactly as shown in the amends; keep only matching pairs (inner match)",
            "When answering about \"Cartoons showed on TV Channel with series name 'Sky Radio'\", When the question mentions \"TV Channel with series name 'Sky Radio'\", When combining TV_Channel (T1) and Cartoon (T2) for shared entities, When selecting the title of cartoons: use T2.Title as the exact column token from the Cartoon table"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM Cartoons WHERE channel = 'Sky Radio';",
            "SELECT T2.Title \nFROM TV_Channel AS T1 \nJOIN Cartoon AS T2 ON T1.id = T2.Channel \nWHERE T1.series_name = 'Sky Radio'"
        ],
        "rule_sql": [
            "SELECT T2.Title FROM TV_Channel T1 INNER JOIN Cartoon T2 ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio' ORDER BY T2.Title"
        ]
    },
    "612": {
        "db_id": "tvshow",
        "question": "What is the title of all the cartools that are on the TV Channel with the series name \"Sky Radio\"?",
        "ground_truth": "SELECT T2.Title FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T1.series_name = \"Sky Radio\";",
        "amends": [
            "Do select `T2.Title` instead of `title` and specify the table alias. Do use `FROM TV_Channel AS T1 JOIN Cartoon AS T2` instead of `FROM cartools` to reference the correct tables with proper aliases. Do add the join condition `ON T1.id = T2.Channel` instead of omitting any join relationship. Do apply the filter `T1.series_name = \"Sky Radio\"` on the TV_Channel table instead of applying it directly to a non-existent table. The amended query now correctly joins the TV_Channel and Cartoon tables to retrieve titles from the appropriate source based on the channel relationship."
        ],
        "rules": [
            "When answering about \"cartools that are on the TV Channel with the series name 'Sky Radio'\": make sure the output order: T2.Title.",
            "When the question mentions \"cartools\": \"cartools\" actually means \"Cartoon in schema\" and should be referenced as T2.",
            "When the question mentions \"TV Channel\": \"TV Channel\" actually means \"TV_Channel in schema\" and should be referenced as T1.",
            "When combining T1 and T2 for shared entities: link rows where T1.id = T2.Channel exactly as shown in the amends; keep only matching pairs (inner match).",
            "When answering about \"cartools that are on the TV Channel with the series name 'Sky Radio'\", When the question mentions \"cartools\", When the question mentions \"TV Channel\", When combining T1 and T2 for shared entities, When filtering for series name \"Sky Radio\": apply the condition T1.series_name = \"Sky Radio\" exactly as specified with double quotes and proper case."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM cartools WHERE series_name = 'Sky Radio';",
            "SELECT T2.Title FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio'"
        ],
        "rule_sql": [
            "SELECT T2.Title FROM TV_Channel T1 INNER JOIN Cartoon T2 ON T1.id = T2.Channel WHERE T1.series_name = \"Sky Radio\" ORDER BY T2.Title;"
        ]
    },
    "613": {
        "db_id": "tvshow",
        "question": "List the Episode of all TV series sorted by rating.",
        "ground_truth": "SELECT Episode FROM TV_series ORDER BY rating",
        "amends": [
            "Do select specific column `Episode` instead of all columns `*` from the `TV_series` table instead of the `episodes` table. Do order by `rating` in ascending order instead of descending order. The amended query now correctly retrieves only the Episode column from the TV_series table sorted by rating in ascending order."
        ],
        "rules": [
            "When answering about \"List the Episode of all TV series sorted by rating\": make sure the output order: \"Episode\" only.",
            "When selecting from the TV series data: use table \"TV_series\" instead of \"episodes\".",
            "When answering about \"List the Episode of all TV series sorted by rating\", When selecting from the TV series data, When ordering by rating: sort in ascending order instead of descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM episodes ORDER BY rating DESC;",
            "SELECT Episode FROM TV_series ORDER BY Rating ASC;"
        ],
        "rule_sql": [
            "SELECT Episode FROM TV_series ORDER BY Rating ASC;"
        ]
    },
    "614": {
        "db_id": "tvshow",
        "question": "What are all of the episodes ordered by ratings?",
        "ground_truth": "SELECT Episode FROM TV_series ORDER BY rating",
        "amends": [
            "Do select `Episode` instead of `*` for all columns. Do source from `TV_series` instead of `episodes` table. Do order by `rating` instead of `title DESC`."
        ],
        "rules": [
            "When selecting all columns from the TV_series table: use \"Episode\" instead of * to get only the episode column.",
            "When querying episodes data: source from the \"TV_series\" table instead of an \"episodes\" table.",
            "When selecting all columns from the TV_series table, When querying episodes data, When ordering episodes by ratings: order by the \"rating\" column instead of \"title DESC\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM episodes ORDER BY title DESC;",
            "SELECT Episode FROM TV_series ORDER BY Rating;"
        ],
        "rule_sql": [
            "SELECT Episode FROM TV_series ORDER BY Rating;"
        ]
    },
    "615": {
        "db_id": "tvshow",
        "question": "List top 3 highest Rating  TV series. List the TV series's Episode and Rating.",
        "ground_truth": "SELECT Episode ,  Rating FROM TV_series ORDER BY Rating DESC LIMIT 3;",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Episode, Rating FROM TV_series ORDER BY Rating DESC LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT Episode, Rating FROM TV_series ORDER BY CAST(Rating AS REAL) DESC LIMIT 3;"
        ]
    },
    "616": {
        "db_id": "tvshow",
        "question": "What are 3 most highly rated episodes in the TV series table and what were those ratings?",
        "ground_truth": "SELECT Episode ,  Rating FROM TV_series ORDER BY Rating DESC LIMIT 3;",
        "amends": [
            "Do use column name `Episode` instead of `title` in the SELECT list. Do use column name `Rating` instead of `rating` in both the SELECT list and ORDER BY clause. The amended query now correctly selects and orders by the intended columns, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for \"most highly rated episodes\": rank rows by \"Rating\" in descending order and keep the first 3 rows.",
            "When the question mentions \"episodes\": \"episodes\" actually means \"Episode\" in schema.",
            "When the question mentions \"ratings\": \"ratings\" actually means \"Rating\" in schema.",
            "When the question asks for \"most highly rated episodes\", When the question mentions \"episodes\", When the question mentions \"ratings\", When answering about \"3 most highly rated episodes and their ratings\": make sure the output order: Episode, Rating."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title, rating FROM tv_series ORDER BY rating DESC LIMIT 3;",
            "SELECT Episode, Rating FROM TV_series ORDER BY Rating DESC LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT Episode, Rating FROM TV_series ORDER BY Rating DESC LIMIT 3"
        ]
    },
    "617": {
        "db_id": "tvshow",
        "question": "What is minimum and maximum share of TV series?",
        "ground_truth": "SELECT max(SHARE) , min(SHARE) FROM TV_series;",
        "amends": [
            "Do use table name `TV_series` instead of `movies` with filter `WHERE type = 'TV Series'`. Do swap the column order by placing `max(SHARE)` first instead of `MIN(share) AS min_share` first. Do remove the column aliases `min_share` and `max_share` instead of keeping them. Do use uppercase function names `max` and `min` instead of mixed case `MIN` and `MAX`. The amended query now correctly selects from the dedicated TV_series table and matches the right SQL's behavior."
        ],
        "rules": [
            "When answering about minimum and maximum share of TV series: use the table name \"TV_series\" instead of \"movies\".",
            "When computing aggregate values for TV series: use uppercase function names \"max\" and \"min\" instead of mixed case \"MIN\" and \"MAX\".",
            "When ordering output columns for minimum and maximum share: place \"max(SHARE)\" first instead of \"MIN(share)\" first.",
            "When answering about minimum and maximum share of TV series, When computing aggregate values for TV series, When ordering output columns for minimum and maximum share, When selecting aggregate values: remove column aliases \"min_share\" and \"max_share\" instead of keeping them."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(share) AS min_share, MAX(share) AS max_share FROM movies WHERE type = 'TV Series';",
            "SELECT max(Share), min(Share) FROM TV_series"
        ],
        "rule_sql": [
            "SELECT max(Share), min(Share) FROM TV_series"
        ]
    },
    "618": {
        "db_id": "tvshow",
        "question": "What is the maximum and minimum share for the TV series?",
        "ground_truth": "SELECT max(SHARE) , min(SHARE) FROM TV_series;",
        "amends": [
            "Do reference table `TV_series` instead of `series` in the FROM clause. Do remove the WHERE filter `type = 'Movie'` instead of keeping it. Do use uppercase column names `SHARE` instead of lowercase `share` in the aggregate functions. The amended query now correctly aggregates from the TV_series table without unnecessary filtering."
        ],
        "rules": [
            "When answering about maximum and minimum share for TV series: use table \"TV_series\" as the data source.",
            "When the question mentions \"TV series\": do not apply any type filtering conditions.",
            "When computing aggregate functions on share values: use the exact column name \"SHARE\" in uppercase.",
            "When answering about maximum and minimum share for TV series, When the question mentions \"TV series\", When computing aggregate functions on share values, When calculating maximum and minimum values: compute MAX(\"SHARE\") and MIN(\"SHARE\") without any additional filtering conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(share), MIN(share) FROM series WHERE type = 'Movie';",
            "SELECT MAX(Share) AS max_share, MIN(Share) AS min_share FROM TV_series;"
        ],
        "rule_sql": [
            "SELECT MAX(\"SHARE\") AS max_share, MIN(\"SHARE\") AS min_share FROM \"TV_series\";"
        ]
    },
    "619": {
        "db_id": "tvshow",
        "question": "What is the air date of TV series with Episode \"A Love of a Lifetime\"?",
        "ground_truth": "SELECT Air_Date FROM TV_series WHERE Episode = \"A Love of a Lifetime\";",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT air_date FROM tv_series WHERE episode = 'A Love of a Lifetime';"
        ],
        "rule_sql": [
            "SELECT Air_Date FROM TV_series WHERE Episode = 'A Love of a Lifetime';"
        ]
    },
    "620": {
        "db_id": "tvshow",
        "question": "When did the episode \"A Love of a Lifetime\" air?",
        "ground_truth": "SELECT Air_Date FROM TV_series WHERE Episode = \"A Love of a Lifetime\";",
        "amends": [
            "Do select `Air_Date` instead of `episode_name` and do query from `TV_series` instead of `episodes`. Do filter on `Episode` column with value \"A Love of a Lifetime\" instead of filtering on `air_date` column with value 'A Love of a Lifetime'. The amended query now correctly retrieves the air date for the specified episode rather than incorrectly trying to find episode names matching a date value."
        ],
        "rules": [
            "When the question asks about when an episode aired: select the \"Air_Date\" column instead of episode names.",
            "When querying for episode information: use the \"TV_series\" table instead of an \"episodes\" table.",
            "When the question asks about when an episode aired, When querying for episode information, When filtering for a specific episode title: filter on the \"Episode\" column with the exact literal value \"A Love of a Lifetime\" instead of filtering on date columns with episode titles."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT episode_name FROM episodes WHERE air_date = 'A Love of a Lifetime';",
            "SELECT Air_Date FROM TV_series WHERE Episode = 'A Love of a Lifetime';"
        ],
        "rule_sql": [
            "SELECT Air_Date FROM TV_series WHERE Episode = 'A Love of a Lifetime';"
        ]
    },
    "621": {
        "db_id": "tvshow",
        "question": "What is Weekly Rank of TV series with Episode \"A Love of a Lifetime\"?",
        "ground_truth": "SELECT Weekly_Rank FROM TV_series WHERE Episode = \"A Love of a Lifetime\";",
        "amends": [
            "Do select only `Weekly_Rank` instead of both `title` and `weekly_rank`. Do filter on `Episode` column instead of `episode_title` column. Do use double quotes around the string literal instead of single quotes. Do remove the `ORDER BY weekly_rank DESC` clause instead of keeping it. The amended query now matches the RIGHT_SQL's behavior by selecting the correct column and filtering on the appropriate episode identifier without unnecessary sorting."
        ],
        "rules": [
            "When the question asks for \"Weekly Rank\": select only the \"Weekly_Rank\" column from table TV_series.",
            "When filtering for Episode \"A Love of a Lifetime\": use the exact string literal \"A Love of a Lifetime\" with double quotes and filter on the \"Episode\" column.",
            "When the question asks for \"Weekly Rank\", When filtering for Episode \"A Love of a Lifetime\", When the question does not specify ordering: do not include any sorting clause in the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title, weekly_rank FROM tv_series WHERE episode_title = 'A Love of a Lifetime' ORDER BY weekly_rank DESC;",
            "SELECT Weekly_Rank FROM TV_series WHERE Episode = \"A Love of a Lifetime\""
        ],
        "rule_sql": [
            "SELECT Weekly_Rank FROM TV_series WHERE Episode = \"A Love of a Lifetime\";"
        ]
    },
    "622": {
        "db_id": "tvshow",
        "question": "What is the weekly rank for the episode \"A Love of a Lifetime\"?",
        "ground_truth": "SELECT Weekly_Rank FROM TV_series WHERE Episode = \"A Love of a Lifetime\";",
        "amends": [
            "Do reference table `TV_series` instead of `episodes` and use column `Episode` instead of `episode_title` for the filter condition. Do use double quotes around the string literal \"A Love of a Lifetime\" instead of single quotes. Do use column name `Weekly_Rank` with proper capitalization instead of `weekly_rank`. The amended query now correctly references the appropriate table and column names to match the intended behavior."
        ],
        "rules": [
            "When answering about the weekly rank for a specific episode: use table \"TV_series\" (not \"episodes\") and output column \"Weekly_Rank\" with proper capitalization.",
            "When filtering by episode title: use column \"Episode\" (not \"episode_title\") for the condition.",
            "When answering about the weekly rank for a specific episode, When filtering by episode title, When specifying the literal episode title \"A Love of a Lifetime\": use double quotes around the exact string literal (not single quotes)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT weekly_rank FROM episodes WHERE episode_title = 'A Love of a Lifetime';",
            "SELECT Weekly_Rank FROM TV_series WHERE Episode = \"A Love of a Lifetime\";"
        ],
        "rule_sql": [
            "SELECT Weekly_Rank FROM TV_series WHERE Episode = \"A Love of a Lifetime\";"
        ]
    },
    "623": {
        "db_id": "tvshow",
        "question": "What is the TV Channel of TV series with Episode \"A Love of a Lifetime\"? List the TV Channel's series name.",
        "ground_truth": "SELECT T1.series_name FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T2.Episode = \"A Love of a Lifetime\";",
        "amends": [
            "Do select `series_name` from the `TV_Channel` table instead of `tv_channel` from the `tv_series` table. Do add a `JOIN` between `TV_Channel AS T1` and `TV_series AS T2` on `T1.id = T2.Channel` instead of querying only the `tv_series` table. Do filter on `T2.Episode = \"A Love of a Lifetime\"` instead of `episode = 'A Love of a Lifetime'` to maintain the correct table reference in the WHERE clause. The amended query now correctly retrieves the series name from the TV_Channel table by joining with TV_series where the specific episode matches, ensuring the result matches the intended behavior."
        ],
        "rules": [
            "When the question asks for \"TV Channel of TV series\": the TV Channel's series name is stored in the \"TV_Channel\" table as \"series_name\" column, not in the \"tv_series\" table.",
            "When combining information about TV series and TV channels: link rows where \"TV_Channel\".id equals \"TV_series\".Channel to find matching records between the two tables.",
            "When filtering for a specific episode \"A Love of a Lifetime\": use the exact literal \"A Love of a Lifetime\" with double quotes and filter on the \"TV_series\" table's \"Episode\" column.",
            "When the question asks for \"TV Channel of TV series\", When combining information about TV series and TV channels, When filtering for a specific episode \"A Love of a Lifetime\", When the question asks to list the TV Channel's series name: output the \"series_name\" column from the \"TV_Channel\" table as the final result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT tv_channel FROM tv_series WHERE episode = 'A Love of a Lifetime';",
            "SELECT T1.series_name FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T2.Episode = 'A Love of a Lifetime'"
        ],
        "rule_sql": [
            "SELECT TV_Channel.series_name FROM TV_Channel JOIN TV_series ON TV_Channel.id = TV_series.Channel WHERE TV_series.Episode = \"A Love of a Lifetime\""
        ]
    },
    "624": {
        "db_id": "tvshow",
        "question": "What is the name of the series that has the episode \"A Love of a Lifetime\"?",
        "ground_truth": "SELECT T1.series_name FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T2.Episode = \"A Love of a Lifetime\";",
        "amends": [
            "Do add `TV_Channel AS T1` and `TV_series AS T2` as FROM sources instead of only `episodes`. Do use `JOIN` with `ON T1.id = T2.Channel` instead of querying a single table. Do reference `T1.series_name` instead of just `series_name`. Do filter on `T2.Episode = \"A Love of a Lifetime\"` instead of `episode_title = 'A Love of a Lifetime'`. The amended query now correctly joins the channel and series tables to find the series name for the specified episode, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks about a series name for a specific episode: use TV_Channel as T1 and TV_series as T2 as FROM sources instead of only episodes.",
            "When combining T1 and T2: link rows where T1.id = T2.Channel and keep only matching pairs (inner match).",
            "When referencing the series name: use T1.series_name instead of just series_name.",
            "When the question asks about a series name for a specific episode, When combining T1 and T2, When referencing the series name, When filtering for the episode \"A Love of a Lifetime\": use T2.Episode = \"A Love of a Lifetime\" with exact case and punctuation as shown."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT series_name FROM episodes WHERE episode_title = 'A Love of a Lifetime'",
            "SELECT T1.series_name FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T2.Episode = 'A Love of a Lifetime'"
        ],
        "rule_sql": [
            "SELECT T1.series_name FROM TV_Channel AS T1 INNER JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T2.Episode = 'A Love of a Lifetime'"
        ]
    },
    "625": {
        "db_id": "tvshow",
        "question": "List the Episode of all  TV series showed on TV Channel with series name \"Sky Radio\".",
        "ground_truth": "SELECT T2.Episode FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T1.series_name = \"Sky Radio\";",
        "amends": [
            "Do select `T2.Episode` instead of `*` to return only the episode column rather than all columns. Do use `TV_Channel AS T1 JOIN TV_series AS T2` instead of `episodes` to properly join the channel and series tables. Do apply the join condition `ON T1.id = T2.Channel` instead of no join condition to correctly relate the tables. Do filter on `T1.series_name = \"Sky Radio\"` instead of `channel = 'Sky Radio'` to use the appropriate column name and table reference. The amended query now correctly retrieves episodes from the specified series by joining the related tables with proper relationships."
        ],
        "rules": [
            "When answering about \"List the Episode of all TV series showed on TV Channel with series name 'Sky Radio'\": make sure the output order: T2.Episode",
            "When the question mentions \"TV series showed on TV Channel\": use TV_Channel AS T1 JOIN TV_series AS T2 with join condition T1.id = T2.Channel to properly relate the tables",
            "When the question mentions \"series name 'Sky Radio'\": filter on T1.series_name = \"Sky Radio\" exactly as specified with double quotes",
            "When answering about \"List the Episode of all TV series showed on TV Channel with series name 'Sky Radio'\", When the question mentions \"TV series showed on TV Channel\", When the question mentions \"series name 'Sky Radio'\", When combining T1 and T2 for shared entities: link rows where T1.id = T2.Channel exactly as shown in the amends; keep only matching pairs (inner match)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM episodes WHERE channel = 'Sky Radio';",
            "SELECT T2.Episode FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T1.series_name = \"Sky Radio\""
        ],
        "rule_sql": [
            "SELECT T2.Episode\nFROM TV_Channel AS T1\nJOIN TV_series AS T2 ON T1.id = T2.Channel\nWHERE T1.series_name = \"Sky Radio\""
        ]
    },
    "626": {
        "db_id": "tvshow",
        "question": "What is the episode for the TV series named \"Sky Radio\"?",
        "ground_truth": "SELECT T2.Episode FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T1.series_name = \"Sky Radio\";",
        "amends": [
            "Do select only `T2.Episode` instead of selecting all columns with `*`. Do join `TV_Channel AS T1` with `TV_series AS T2` instead of querying only `tv_series` alone. Do use the join condition `T1.id = T2.Channel` instead of no join condition. Do filter on `T1.series_name = \"Sky Radio\"` instead of filtering on `name = 'Sky Radio'`. The amended query now correctly retrieves episodes from the specific channel series rather than incorrectly querying the series table directly."
        ],
        "rules": [
            "When answering about \"the episode for the TV series named 'Sky Radio'\": make sure the output order: T2.Episode.",
            "When the question mentions \"TV series named 'Sky Radio'\": \"Sky Radio\" actually means T1.series_name in schema.",
            "When combining T1 and T2 for shared entities: link rows where T1.id = T2.Channel exactly as shown in the amends; keep only matching pairs (inner match).",
            "When answering about \"the episode for the TV series named 'Sky Radio'\", When the question mentions \"TV series named 'Sky Radio'\", When combining T1 and T2 for shared entities, When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for \"Sky Radio\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM tv_series WHERE name = 'Sky Radio';",
            "SELECT T2.Episode FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio'"
        ],
        "rule_sql": [
            "SELECT T2.Episode FROM TV_Channel T1 JOIN TV_series T2 ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio'"
        ]
    },
    "627": {
        "db_id": "tvshow",
        "question": "Find the number of cartoons directed by each of the listed directors.",
        "ground_truth": "SELECT count(*) ,  Directed_by FROM cartoon GROUP BY Directed_by",
        "amends": [
            "Do use column name `Directed_by` instead of `director` and place `count(*)` first instead of second in the SELECT list. Do reference table `cartoon` instead of `cartoons` in the FROM clause. Do group by `Directed_by` instead of `director` to match the corrected column name. The amended query now correctly counts cartoons grouped by their director using the proper table and column names."
        ],
        "rules": [
            "When the question asks for \"number of cartoons directed by each director\": count the rows using the canonical key from the cartoon table and group by the exact column token \"Directed_by\".",
            "When the question mentions \"directed by\": the exact column token is \"Directed_by\" from the cartoon table.",
            "When producing output columns: place the count result first followed by the director name.",
            "When referring to the table containing cartoon data: use the exact table name \"cartoon\" (not \"cartoons\").",
            "When the question asks for \"number of cartoons directed by each director\", When the question mentions \"directed by\", When producing output columns, When referring to the table containing cartoon data, When grouping by director: use the exact column token \"Directed_by\" for grouping."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT director, COUNT(*) FROM cartoons GROUP BY director;",
            "SELECT count(*), Directed_by FROM Cartoon GROUP BY Directed_by"
        ],
        "rule_sql": [
            "SELECT COUNT(id), Directed_by FROM Cartoon GROUP BY Directed_by;"
        ]
    },
    "628": {
        "db_id": "tvshow",
        "question": "How many cartoons did each director create?",
        "ground_truth": "SELECT count(*) ,  Directed_by FROM cartoon GROUP BY Directed_by",
        "amends": [
            "Do use the column name `Directed_by` instead of `director` in both the SELECT list and GROUP BY clause. Do place the aggregate function `count(*)` first in the SELECT list instead of second. Do reference the table name `cartoon` instead of `cartoons` in the FROM clause. The amended query now correctly counts records grouped by the director column using the proper table and column names from the schema."
        ],
        "rules": [
            "When the question asks about \"director\": use the exact column name \"Directed_by\" from the schema instead of \"director\".",
            "When counting records per director: place the count result first in the output order before the director name.",
            "When referencing the cartoon table: use the exact table name \"cartoon\" instead of \"cartoons\".",
            "When the question asks about \"director\", When counting records per director, When referencing the cartoon table, When grouping by director: use the exact column name \"Directed_by\" in both the grouping and output columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT director, COUNT(*) FROM cartoons GROUP BY director;",
            "SELECT count(*), Directed_by FROM Cartoon GROUP BY Directed_by"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS count, Directed_by FROM Cartoon GROUP BY Directed_by ORDER BY count DESC;"
        ]
    },
    "629": {
        "db_id": "tvshow",
        "question": "Find the production code and channel of the most recently aired cartoon .",
        "ground_truth": "select production_code ,  channel from cartoon order by original_air_date desc limit 1",
        "amends": [
            "Do reference the `cartoon` table instead of the `cartoons` table. Do use the `original_air_date` column for ordering instead of `air_date`. The amended query now correctly references the proper table name and date column to match the intended behavior."
        ],
        "rules": [
            "When answering about \"the most recently aired cartoon\": use the \"cartoon\" table instead of \"cartoons\" table.",
            "When ordering by air date to find the most recent: use the \"original_air_date\" column for ordering instead of \"air_date\" column.",
            "When answering about \"the most recently aired cartoon\", When ordering by air date to find the most recent, When finding the most recent record: order by date in descending order and keep only the first row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT production_code, channel FROM cartoons ORDER BY air_date DESC LIMIT 1;",
            "SELECT production_code, channel FROM Cartoon ORDER BY original_air_date DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT production_code, channel FROM Cartoon ORDER BY original_air_date DESC LIMIT 1;"
        ]
    },
    "630": {
        "db_id": "tvshow",
        "question": "What is the produdction code and channel of the most recent cartoon ?",
        "ground_truth": "select production_code ,  channel from cartoon order by original_air_date desc limit 1",
        "amends": [
            "Do reference table `cartoon` instead of `cartoons` and use column `original_air_date` instead of `air_date` for ordering, while keeping the same `SELECT` list with `production_code` and `channel`, maintaining the `DESC` ordering and `LIMIT 1` clause. The amended query now correctly references the proper table name and date column to match the intended behavior."
        ],
        "rules": [
            "When the question asks about \"cartoons\": use the exact table name \"cartoon\" instead of \"cartoons\".",
            "When ordering by the most recent episode: use the column \"original_air_date\" instead of \"air_date\" and sort in descending order.",
            "When selecting the most recent cartoon: keep only the top 1 row after ordering by original_air_date in descending order.",
            "When the question asks about \"cartoons\", When ordering by the most recent episode, When selecting the most recent cartoon, When outputting results: include the columns \"production_code\" and \"channel\" in that exact order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT production_code, channel FROM cartoons ORDER BY air_date DESC LIMIT 1;",
            "SELECT production_code, channel FROM Cartoon ORDER BY original_air_date DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT production_code, channel FROM cartoon ORDER BY original_air_date DESC LIMIT 1;"
        ]
    },
    "631": {
        "db_id": "tvshow",
        "question": "Find the package choice and series name of the TV channel that has high definition TV.",
        "ground_truth": "SELECT package_option ,  series_name FROM TV_Channel WHERE hight_definition_TV  =  \"yes\"",
        "amends": [
            "Do use `package_option` instead of `package_choice` in the SELECT list. Do reference table `TV_Channel` instead of `tv_channels` in the FROM clause. Do filter on `hight_definition_TV = \"yes\"` instead of `high_definition = 'yes'` in the WHERE clause, correcting both the column name and using double quotes instead of single quotes for the string literal. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for \"package choice\": use the exact column token \"package_option\" from table \"TV_Channel\".",
            "When filtering for high definition TV: use the exact column token \"hight_definition_TV\" and the exact string literal \"yes\" with double quotes.",
            "When the question asks for \"package choice\", When filtering for high definition TV, When referencing the TV channels table: use the exact table name \"TV_Channel\" with the correct case and quotes as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT package_choice, series_name FROM tv_channels WHERE high_definition = 'yes';",
            "SELECT package_option, series_name FROM TV_Channel WHERE hight_definition_TV = \"yes\""
        ],
        "rule_sql": [
            "SELECT \"Package_Option\", \"series_name\" FROM \"TV_Channel\" WHERE \"Hight_definition_TV\" = \"yes\";"
        ]
    },
    "632": {
        "db_id": "tvshow",
        "question": "What are the package options and the name of the series for the TV Channel that supports high definition TV?",
        "ground_truth": "SELECT package_option ,  series_name FROM TV_Channel WHERE hight_definition_TV  =  \"yes\"",
        "amends": [
            "Do reference the table as `TV_Channel` instead of `tv_channels` to match the correct table name. Do use the column name `package_option` instead of `package_options` to select the correct singular column. Do filter on `hight_definition_TV = \"yes\"` instead of `supports_hd = 'yes'` to use the proper column name and double quotes for the string literal. The amended query now correctly retrieves package options and series names from the TV_Channel table where high definition TV is supported."
        ],
        "rules": [
            "When referencing the TV channels table: use the exact table name \"TV_Channel\" with double quotes and proper capitalization.",
            "When selecting package options: use the column name \"package_option\" (singular) with double quotes.",
            "When filtering for high definition TV support: use the column name \"hight_definition_TV\" with double quotes and the literal value \"yes\" with double quotes.",
            "When referencing the TV channels table, When selecting package options, When filtering for high definition TV support, When answering about TV channels that support high definition: make sure the output order includes \"package_option\" followed by \"series_name\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT package_options, series_name FROM tv_channels WHERE supports_hd = 'yes';",
            "SELECT Package_Option, series_name FROM TV_Channel WHERE Hight_definition_TV = \"yes\";"
        ],
        "rule_sql": [
            "SELECT \"package_option\", \"series_name\" FROM \"TV_Channel\" WHERE \"hight_definition_TV\" = \"yes\""
        ]
    },
    "633": {
        "db_id": "tvshow",
        "question": "which countries' tv channels are playing some cartoon written by Todd Casey?",
        "ground_truth": "SELECT T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.written_by  =  'Todd Casey'",
        "amends": [
            "Do select `T1.country` instead of `country` and remove `DISTINCT` instead of keeping it. Do add `cartoon AS T2` table instead of omitting it and use `JOIN` on `T1.id = T2.Channel` instead of querying only `tv_channels`. Do move the filter to `T2.written_by = 'Todd Casey'` instead of `cartoon_writer = 'Todd Casey'` and remove the `WHERE` clause entirely. The amended query now correctly joins tables and filters on the cartoon writer attribute, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about countries' tv channels playing cartoons: combine tv_channels as T1 and cartoon as T2 tables using T1.id = T2.Channel to find matching pairs.",
            "When the question mentions \"cartoon written by Todd Casey\": filter for rows where T2.written_by = 'Todd Casey' exactly.",
            "When selecting countries from tv_channels: output T1.country without using DISTINCT.",
            "When answering about countries' tv channels playing cartoons, When the question mentions \"cartoon written by Todd Casey\", When selecting countries from tv_channels, When combining T1 and T2: perform an inner match where T1.id equals T2.Channel to keep only channels that have cartoons."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT country FROM tv_channels WHERE cartoon_writer = 'Todd Casey';",
            "SELECT T1.Country FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Written_by = 'Todd Casey'"
        ],
        "rule_sql": [
            "SELECT T1.Country FROM TV_Channel AS T1 INNER JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Written_by = 'Todd Casey'"
        ]
    },
    "634": {
        "db_id": "tvshow",
        "question": "What are the countries that have cartoons on TV that were written by Todd Casey?",
        "ground_truth": "SELECT T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.written_by  =  'Todd Casey'",
        "amends": [
            "Do select `T1.country` from the `TV_Channel` table instead of selecting `country` directly from a non-existent `cartoons` table. Do join `TV_Channel AS T1` with `cartoon AS T2` on `T1.id = T2.Channel` instead of querying a single table. Do filter on `T2.written_by = 'Todd Casey'` instead of `writer = 'Todd Casey'` to use the correct column name and table reference. The amended query now correctly retrieves country information by joining the appropriate tables and using the proper column references, matching the intended behavior."
        ],
        "rules": [
            "When the question asks about countries with cartoons on TV: select \"T1.country\" from the \"TV_Channel\" table as T1 instead of from a non-existent \"cartoons\" table.",
            "When combining TV channel and cartoon information: join \"TV_Channel AS T1\" with \"cartoon AS T2\" where \"T1.id = T2.Channel\" to link channels with their cartoons.",
            "When the question asks about countries with cartoons on TV, When combining TV channel and cartoon information, When filtering for cartoons written by Todd Casey: use \"T2.written_by = 'Todd Casey'\" instead of \"writer = 'Todd Casey'\" to match the exact column name and literal value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM cartoons WHERE writer = 'Todd Casey'",
            "SELECT DISTINCT T1.Country FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Written_by = 'Todd Casey'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Country\nFROM TV_Channel AS T1\nJOIN Cartoon AS T2 ON T1.id = T2.Channel\nWHERE T2.Written_by = 'Todd Casey'"
        ]
    },
    "635": {
        "db_id": "tvshow",
        "question": "which countries' tv channels are not playing any cartoon written by Todd Casey?",
        "ground_truth": "SELECT country FROM TV_Channel EXCEPT SELECT T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.written_by  =  'Todd Casey'",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` subquery. Do reference table as `TV_Channel` instead of `tv_channels`. Do add explicit table alias `T1` for the TV_Channel table instead of omitting it. Do join with `cartoon` table instead of filtering `programs` table for program_type. Do use join condition `T1.id = T2.Channel` instead of subquery correlation. Do filter on `written_by` column instead of `writer` column. Do remove `DISTINCT` modifier since `EXCEPT` inherently eliminates duplicates. The amended query now correctly identifies countries without cartoons written by Todd Casey using proper table relationships and set operations."
        ],
        "rules": [
            "When answering about \"countries' tv channels not playing any cartoon written by Todd Casey\": use the TV_Channel table as T1 and the cartoon table as T2.",
            "When combining T1 and T2 for shared entities: link rows where T1.id = T2.Channel exactly as shown and keep only matching pairs (inner match).",
            "When filtering for cartoons written by Todd Casey: use the written_by column with exact literal 'Todd Casey' (case-sensitive).",
            "When using set operations to find countries without cartoons by Todd Casey: use EXCEPT operation instead of NOT IN subqueries.",
            "When selecting output columns: return only the country column from T1.",
            "When answering about \"countries' tv channels not playing any cartoon written by Todd Casey\", When combining T1 and T2 for shared entities, When filtering for cartoons written by Todd Casey, When using set operations to find countries without cartoons by Todd Casey, When selecting output columns, When handling duplicates: do not use DISTINCT modifier since EXCEPT inherently eliminates duplicates."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT country \nFROM tv_channels \nWHERE channel_id NOT IN (\n    SELECT channel_id \n    FROM programs \n    WHERE program_type = 'cartoon' \n    AND writer = 'Todd Casey'\n);",
            "SELECT T1.Country\nFROM TV_Channel T1\nEXCEPT\nSELECT T1.Country\nFROM TV_Channel T1\nJOIN Cartoon T2 ON T1.id = T2.Channel\nWHERE T2.Written_by = 'Todd Casey'"
        ],
        "rule_sql": [
            "SELECT Country FROM TV_Channel AS T1\nINNER JOIN Cartoon AS T2 ON T1.id = T2.Channel\nWHERE T2.written_by = 'Todd Casey'\nEXCEPT\nSELECT Country FROM TV_Channel"
        ]
    },
    "636": {
        "db_id": "tvshow",
        "question": "What are the countries that are not playing cartoons written by Todd Casey?",
        "ground_truth": "SELECT country FROM TV_Channel EXCEPT SELECT T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.written_by  =  'Todd Casey'",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do query from `TV_Channel` table instead of `countries` table. Do join `cartoon` table on `T1.id = T2.Channel` instead of joining multiple tables through `movies` and `writers`. Do filter on `T2.written_by = 'Todd Casey'` instead of checking `m.genre = 'Cartoon' AND p.name = 'Todd Casey'`. Do remove `DISTINCT` from the main query since `EXCEPT` inherently eliminates duplicates. Do remove the subquery structure entirely in favor of the set operation approach. The amended query now correctly identifies countries from TV_Channel that don't have cartoons written by Todd Casey, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about countries not playing cartoons written by Todd Casey: query from the \"TV_Channel\" table instead of \"countries\" table.",
            "When combining TV_Channel and cartoon tables: link rows where T1.id = T2.Channel and keep only matching pairs (inner match).",
            "When filtering for cartoons written by Todd Casey: use the exact literal 'Todd Casey' for T2.written_by.",
            "When using set operations to find countries not in a set: use EXCEPT operation instead of NOT IN with subqueries.",
            "When eliminating duplicates in set operations: do not use DISTINCT since EXCEPT inherently eliminates duplicates.",
            "When answering about countries not playing cartoons written by Todd Casey, When combining TV_Channel and cartoon tables, When filtering for cartoons written by Todd Casey, When using set operations to find countries not in a set, When eliminating duplicates in set operations, When producing output: return the country column from TV_Channel table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT country \nFROM countries \nWHERE country NOT IN (\n    SELECT DISTINCT c.country \n    FROM countries c\n    JOIN movies m ON c.movie_id = m.id\n    JOIN writers w ON m.id = w.movie_id\n    JOIN people p ON w.person_id = p.id\n    WHERE m.genre = 'Cartoon' AND p.name = 'Todd Casey'\n)",
            "SELECT Country FROM TV_Channel\nEXCEPT\nSELECT T1.Country FROM TV_Channel T1\nJOIN Cartoon T2 ON T1.id = T2.Channel\nWHERE T2.Written_by = 'Todd Casey'"
        ],
        "rule_sql": [
            "SELECT Country FROM TV_Channel\nEXCEPT\nSELECT T1.Country\nFROM TV_Channel T1\nINNER JOIN Cartoon T2 ON T1.id = T2.Channel\nWHERE T2.Written_by = 'Todd Casey'"
        ]
    },
    "637": {
        "db_id": "tvshow",
        "question": "Find the series name and country of the tv channel that is playing some cartoons directed by Ben Jones and Michael Chang?",
        "ground_truth": "SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Michael Chang' INTERSECT SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Ben Jones'",
        "amends": [
            "Do use `JOIN` with `cartoon` table on `T1.id = T2.Channel` instead of querying only `tv_channels` table. Do reference `directed_by` column from the joined `cartoon` table instead of `director` column from the base table. Do use `INTERSECT` to find series directed by both 'Michael Chang' and 'Ben Jones' instead of using `OR` logic that would return series directed by either. Do split into two separate queries with specific `directed_by` filters instead of combining conditions with mixed `AND/OR` precedence. Do add table aliases `T1` and `T2` for clarity instead of using unqualified column references. The amended query now correctly finds series directed by both specified directors through set intersection."
        ],
        "rules": [
            "When answering about TV channels playing cartoons: combine the tv_channels table (as T1) with the cartoon table (as T2) by linking rows where T1.id equals T2.Channel.",
            "When the question mentions \"directed by Ben Jones and Michael Chang\": use the directed_by column from T2 (cartoon table) instead of any director column from T1.",
            "When finding series directed by both specified directors: use INTERSECT to find the intersection of series directed by 'Michael Chang' and series directed by 'Ben Jones' instead of using OR logic.",
            "When answering about TV channels playing cartoons, When the question mentions \"directed by Ben Jones and Michael Chang\", When finding series directed by both specified directors, When outputting results: return series_name and country columns from the tv_channels table (T1)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT series_name, country FROM tv_channels WHERE director = 'Ben Jones' OR director = 'Michael Chang' AND genre = 'cartoon';",
            "SELECT T1.series_name, T1.Country\nFROM TV_Channel T1\nJOIN Cartoon T2 ON T1.id = T2.Channel\nWHERE T2.directed_by = 'Ben Jones'\nINTERSECT\nSELECT T1.series_name, T1.Country\nFROM TV_Channel T1\nJOIN Cartoon T2 ON T1.id = T2.Channel\nWHERE T2.directed_by = 'Michael Chang'"
        ],
        "rule_sql": [
            "SELECT T1.series_name, T1.Country\nFROM TV_Channel AS T1\nJOIN Cartoon AS T2 ON T1.id = T2.Channel\nWHERE T2.Directed_by = 'Ben Jones'\nINTERSECT\nSELECT T1.series_name, T1.Country\nFROM TV_Channel AS T1\nJOIN Cartoon AS T2 ON T1.id = T2.Channel\nWHERE T2.Directed_by = 'Michael Chang'"
        ]
    },
    "638": {
        "db_id": "tvshow",
        "question": "What is the series name and country of all TV channels that are playing cartoons directed by Ben Jones and cartoons directed by Michael Chang?",
        "ground_truth": "SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Michael Chang' INTERSECT SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Ben Jones'",
        "amends": [
            "Do add `cartoon` table with `JOIN` on `T1.id = T2.Channel` instead of querying only `tv_channels`. Do change filter condition to use `T2.directed_by` instead of `director`. Do use `INTERSECT` to find common results between two separate queries instead of `OR` condition. Do specify table aliases `T1` and `T2` instead of unqualified column references. Do remove the direct filter on `tv_channels.director` instead of keeping it. The amended query now correctly finds series that have cartoons directed by both specified directors using set intersection logic."
        ],
        "rules": [
            "When answering about TV channels playing cartoons directed by multiple directors: use the cartoon table (T2) joined with tv_channels table (T1) where T1.id = T2.Channel.",
            "When the question mentions \"directed by Ben Jones\" and \"directed by Michael Chang\": use T2.directed_by column with exact literals 'Ben Jones' and 'Michael Chang'.",
            "When finding channels that have cartoons from both directors: use INTERSECT operation between results for each director instead of OR condition.",
            "When selecting output columns: return series_name and country from T1 table.",
            "When answering about TV channels playing cartoons directed by multiple directors, When the question mentions \"directed by Ben Jones\" and \"directed by Michael Chang\", When finding channels that have cartoons from both directors, When selecting output columns, When combining tables for shared entities: link rows where T1.id = T2.Channel exactly and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT series_name, country FROM tv_channels WHERE director = 'Ben Jones' OR director = 'Michael Chang';",
            "SELECT T1.series_name, T1.Country\nFROM TV_Channel T1\nJOIN Cartoon T2 ON T1.id = T2.Channel\nWHERE T2.Directed_by = 'Ben Jones'\nINTERSECT\nSELECT T1.series_name, T1.Country\nFROM TV_Channel T1\nJOIN Cartoon T2 ON T1.id = T2.Channel\nWHERE T2.Directed_by = 'Michael Chang'"
        ],
        "rule_sql": [
            "SELECT T1.series_name, T1.Country\nFROM TV_Channel T1\nJOIN Cartoon T2 ON T1.id = T2.Channel\nWHERE T2.Directed_by = 'Ben Jones'\nINTERSECT\nSELECT T1.series_name, T1.Country\nFROM TV_Channel T1\nJOIN Cartoon T2 ON T1.id = T2.Channel\nWHERE T2.Directed_by = 'Michael Chang'"
        ]
    },
    "639": {
        "db_id": "tvshow",
        "question": "find the pixel aspect ratio and nation of the tv channels that do not use English.",
        "ground_truth": "SELECT Pixel_aspect_ratio_PAR ,  country FROM tv_channel WHERE LANGUAGE != 'English'",
        "amends": [
            "Do use column alias `Pixel_aspect_ratio_PAR` instead of `pixel_aspect_ratio`, and select `country` instead of `nation`. Do reference table `tv_channel` instead of `tv_channels`. Do apply filter `LANGUAGE != 'English'` instead of `language = 'English'` to exclude English language records rather than including them. The amended query now correctly retrieves non-English TV channel data with the specified column names and table reference."
        ],
        "rules": [
            "When the question mentions \"pixel aspect ratio\": use the exact column name \"Pixel_aspect_ratio_PAR\" from the TV_Channel table.",
            "When the question mentions \"nation\": use the exact column name \"country\" from the TV_Channel table instead.",
            "When the question asks for TV channels that do not use English: apply the filter condition where LANGUAGE != 'English' to exclude English language records.",
            "When referencing the TV channels table: use the exact table name \"tv_channel\" instead of \"tv_channels\".",
            "When the question mentions \"pixel aspect ratio\", When the question mentions \"nation\", When the question asks for TV channels that do not use English, When referencing the TV channels table, When selecting output columns: maintain the order Pixel_aspect_ratio_PAR followed by country as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pixel_aspect_ratio, nation FROM tv_channels WHERE language = 'English';",
            "SELECT Pixel_aspect_ratio_PAR, Country FROM TV_Channel WHERE Language != 'English';"
        ],
        "rule_sql": [
            "SELECT Pixel_aspect_ratio_PAR, Country FROM TV_Channel WHERE Language != 'English';"
        ]
    },
    "640": {
        "db_id": "tvshow",
        "question": "What is the pixel aspect ratio and country of origin for all TV channels that do not use English?",
        "ground_truth": "SELECT Pixel_aspect_ratio_PAR ,  country FROM tv_channel WHERE LANGUAGE != 'English'",
        "amends": [
            "Do use column name `Pixel_aspect_ratio_PAR` instead of `pixel_aspect_ratio` and `country` instead of `country_of_origin` in the SELECT list. Do reference table `tv_channel` instead of `tv_channels` in the FROM clause. The amended query now correctly matches the intended schema and behavior."
        ],
        "rules": [
            "When selecting pixel aspect ratio information: use column name \"Pixel_aspect_ratio_PAR\" exactly as shown in the schema.",
            "When selecting country information: use column name \"country\" instead of \"country_of_origin\".",
            "When referencing the TV channels table: use table name \"tv_channel\" instead of \"tv_channels\".",
            "When selecting pixel aspect ratio information, When selecting country information, When referencing the TV channels table, When filtering for non-English language channels: use condition language != 'English' with exact literal 'English'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pixel_aspect_ratio, country_of_origin FROM tv_channels WHERE language != 'English';",
            "SELECT Pixel_aspect_ratio_PAR, Country FROM TV_Channel WHERE Language != 'English';"
        ],
        "rule_sql": [
            "SELECT Pixel_aspect_ratio_PAR, Country FROM tv_channel WHERE Language != 'English';"
        ]
    },
    "641": {
        "db_id": "tvshow",
        "question": "find id of the tv channels that from the countries where have more than two tv channels.",
        "ground_truth": "SELECT id FROM tv_channel GROUP BY country HAVING count(*)  >  2",
        "amends": [
            "Do use `GROUP BY country` with `HAVING count(*) > 2` instead of the subquery approach with `WHERE country IN (SELECT country FROM tv_channels GROUP BY country HAVING COUNT(*) > 2)`. Do remove the redundant subquery structure and instead apply the grouping and filtering directly in the main query. Do change the table reference from `tv_channels` to `tv_channel` to match the correct schema. The amended query now correctly identifies channels from countries with more than two channels by using direct grouping and filtering instead of the inefficient subquery approach."
        ],
        "rules": [
            "When the question asks for TV channels from countries with more than two channels: use the table name \"tv_channel\" instead of \"tv_channels\" to match the schema.",
            "When filtering for countries with more than two channels: group by the \"country\" column and apply a condition to count all rows greater than 2.",
            "When the question asks for TV channels from countries with more than two channels, When filtering for countries with more than two channels, When using grouping and filtering: apply the grouping and filtering directly in the main query instead of using a subquery structure for efficiency."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM tv_channels WHERE country IN (SELECT country FROM tv_channels GROUP BY country HAVING COUNT(*) > 2);",
            "SELECT id FROM TV_Channel GROUP BY Country HAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT id FROM TV_Channel GROUP BY Country HAVING COUNT(*) > 2"
        ]
    },
    "642": {
        "db_id": "tvshow",
        "question": "What are the ids of all tv channels that have more than 2 TV channels?",
        "ground_truth": "SELECT id FROM tv_channel GROUP BY country HAVING count(*)  >  2",
        "amends": [
            "Do select `id` from `tv_channel` instead of `tv_channels`. Do add `GROUP BY country` and `HAVING count(*) > 2` instead of using `WHERE id > 2`. Do remove the incorrect table name `tv_channels` and replace it with `tv_channel`. The amended query now correctly aggregates by country and filters groups with more than 2 records instead of filtering individual records by ID value, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for \"ids of all tv channels that have more than 2 TV channels\": group results by \"country\" and count the number of records per group.",
            "When counting TV channels per country: use the count of all records in each group.",
            "When filtering groups: only include groups where the count is greater than 2.",
            "When selecting output: return the \"id\" column from the \"tv_channel\" table.",
            "When the question asks for \"ids of all tv channels that have more than 2 TV channels\", When counting TV channels per country, When filtering groups, When selecting output, When referring to table names: use exact identifier \"tv_channel\" instead of \"tv_channels\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM tv_channels WHERE id > 2;",
            "SELECT id FROM TV_Channel GROUP BY Country HAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT id FROM tv_channel GROUP BY Country HAVING COUNT(*) > 2"
        ]
    },
    "643": {
        "db_id": "tvshow",
        "question": "find the id of tv channels that do not play any cartoon directed by Ben Jones.",
        "ground_truth": "SELECT id FROM TV_Channel EXCEPT SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones'",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do reference table `TV_Channel` instead of `tv_channels` and column `channel` instead of `channel_id`. Do use table `cartoon` instead of `cartoons` and filter on `directed_by = 'Ben Jones'` instead of `director = 'Ben Jones'`. The amended query now correctly uses set-based exclusion and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"tv channels that do not play any cartoon directed by Ben Jones\": make sure the output order: id from TV_Channel table.",
            "When the question mentions \"tv channels\": \"tv channels\" actually means \"TV_Channel table in schema\".",
            "When the question mentions \"channel_id\": \"channel_id\" actually means \"channel column in cartoon table\".",
            "When the question mentions \"cartoons\": \"cartoons\" actually means \"cartoon table in schema\".",
            "When the question mentions \"director = 'Ben Jones'\": \"director = 'Ben Jones'\" actually means \"directed_by = 'Ben Jones' in cartoon table\".",
            "When answering about \"tv channels that do not play any cartoon directed by Ben Jones\", When the question mentions \"tv channels\", When the question mentions \"channel_id\", When the question mentions \"cartoons\", When the question mentions \"director = 'Ben Jones'\", When excluding channels that play cartoons directed by Ben Jones: use EXCEPT set operation to subtract channels that appear in the cartoon table with directed_by = 'Ben Jones' from all channels in TV_Channel table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM tv_channels WHERE id NOT IN (SELECT channel_id FROM cartoons WHERE director = 'Ben Jones')",
            "SELECT id FROM TV_Channel\nEXCEPT\nSELECT Channel FROM Cartoon WHERE Directed_by = 'Ben Jones';"
        ],
        "rule_sql": [
            "SELECT id FROM TV_Channel\nEXCEPT\nSELECT Channel FROM Cartoon WHERE Directed_by = 'Ben Jones';"
        ]
    },
    "644": {
        "db_id": "tvshow",
        "question": "What are the ids of the TV channels that do not have any cartoons directed by Ben Jones?",
        "ground_truth": "SELECT id FROM TV_Channel EXCEPT SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones'",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do reference table `TV_Channel` instead of `tv_channels` and `cartoon` instead of `cartoons`. Do select from column `channel` in the second query instead of `channel_id`. Do use filter condition `directed_by = 'Ben Jones'` instead of `director = 'Ben Jones'`. The amended query now correctly uses set-based exclusion and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about TV channels without cartoons directed by Ben Jones: use EXCEPT set operation instead of NOT IN with a subquery.",
            "When referring to the TV channels table: use exact table name \"TV_Channel\" instead of \"tv_channels\".",
            "When referring to the cartoons table: use exact table name \"cartoon\" instead of \"cartoons\".",
            "When selecting channel identifiers from the cartoon table: use exact column name \"channel\" instead of \"channel_id\".",
            "When filtering for cartoons directed by Ben Jones: use exact condition \"directed_by = 'Ben Jones'\" instead of \"director = 'Ben Jones'\".",
            "When answering about TV channels without cartoons directed by Ben Jones, When referring to the TV channels table, When referring to the cartoons table, When selecting channel identifiers from the cartoon table, When filtering for cartoons directed by Ben Jones, When combining results from TV_Channel and cartoon tables: perform set-based exclusion using EXCEPT operation to find channels that don't have matching cartoons directed by Ben Jones."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM tv_channels WHERE id NOT IN (SELECT channel_id FROM cartoons WHERE director = 'Ben Jones')",
            "SELECT id FROM TV_Channel\nEXCEPT\nSELECT Channel FROM Cartoon WHERE directed_by = 'Ben Jones';"
        ],
        "rule_sql": [
            "SELECT id FROM TV_Channel\nEXCEPT\nSELECT Channel FROM Cartoon WHERE Directed_by = 'Ben Jones'"
        ]
    },
    "645": {
        "db_id": "tvshow",
        "question": "find the package option of the tv channel that do not have any cartoon directed by Ben Jones.",
        "ground_truth": "SELECT package_option FROM TV_Channel WHERE id NOT IN (SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones')",
        "amends": [
            "Do reference table `TV_Channel` instead of `tv_channels` and column `id` instead of `channel_id` in the main query. Do reference table `cartoon` instead of `cartoons` and column `channel` instead of `channel_id` in the subquery. Do use filter condition `directed_by = 'Ben Jones'` instead of `director = 'Ben Jones'` in the subquery's WHERE clause. The amended query now correctly matches the intended logic by using the proper table and column names from the schema."
        ],
        "rules": [
            "When answering about \"package option of the tv channel that do not have any cartoon directed by Ben Jones\": make sure the output order: package_option from TV_Channel",
            "When the question mentions \"tv channel\": \"tv channel\" actually means \"TV_Channel in schema\"",
            "When the question mentions \"cartoon directed by Ben Jones\": \"directed by Ben Jones\" actually means \"directed_by = 'Ben Jones' in cartoon table\"",
            "When combining TV_Channel and cartoon for shared entities: link rows where TV_Channel.id = cartoon.channel; keep only matching pairs (inner match)",
            "When answering about \"package option of the tv channel that do not have any cartoon directed by Ben Jones\", When the question mentions \"tv channel\", When the question mentions \"cartoon directed by Ben Jones\", When combining TV_Channel and cartoon for shared entities, When filtering for channels without cartoons directed by Ben Jones: exclude channels where there exists a cartoon with directed_by = 'Ben Jones' and matching channel id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT package_option FROM tv_channels WHERE channel_id NOT IN (SELECT channel_id FROM cartoons WHERE director = 'Ben Jones')",
            "SELECT Package_Option FROM TV_Channel WHERE id NOT IN (SELECT Channel FROM Cartoon WHERE directed_by = 'Ben Jones')"
        ],
        "rule_sql": [
            "SELECT DISTINCT tc.Package_Option\nFROM TV_Channel tc\nWHERE tc.id NOT IN (\n    SELECT DISTINCT c.Channel\n    FROM Cartoon c\n    WHERE c.Directed_by = 'Ben Jones'\n)\nORDER BY tc.Package_Option;"
        ]
    },
    "646": {
        "db_id": "tvshow",
        "question": "What are the package options of all tv channels that are not playing any cartoons directed by Ben Jones?",
        "ground_truth": "SELECT package_option FROM TV_Channel WHERE id NOT IN (SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones')",
        "amends": [
            "Do select `package_option` instead of `package_options` and remove `DISTINCT` instead of keeping it. Do reference table `TV_Channel` instead of `tv_channels` and use column `id` instead of `channel_id`. Do use subquery from table `cartoon` instead of `programs` with column `channel` instead of `channel_id`. Do filter on `directed_by = 'Ben Jones'` instead of `genre = 'cartoon' AND director = 'Ben Jones'` and remove the genre condition entirely. The amended query now correctly filters channels not associated with cartoons directed by Ben Jones."
        ],
        "rules": [
            "When the question asks for \"package options\": use the exact column name \"package_option\" from table \"TV_Channel\" instead of \"package_options\".",
            "When selecting from the main table: reference table \"TV_Channel\" instead of \"tv_channels\" and use column \"id\" instead of \"channel_id\".",
            "When filtering channels not playing cartoons directed by Ben Jones: use a subquery from table \"cartoon\" instead of \"programs\" with column \"channel\" instead of \"channel_id\".",
            "When filtering for cartoons directed by Ben Jones: use condition \"directed_by = 'Ben Jones'\" and remove any genre condition entirely.",
            "When the question asks for \"package options\", When selecting from the main table, When filtering channels not playing cartoons directed by Ben Jones, When filtering for cartoons directed by Ben Jones, When selecting package options: do not use DISTINCT, return all matching package_option values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT package_options \nFROM tv_channels \nWHERE channel_id NOT IN (\n    SELECT channel_id \n    FROM programs \n    WHERE genre = 'cartoon' AND director = 'Ben Jones'\n)",
            "SELECT package_option FROM TV_Channel WHERE id NOT IN (SELECT Channel FROM Cartoon WHERE directed_by = 'Ben Jones')"
        ],
        "rule_sql": [
            "SELECT package_option FROM TV_Channel WHERE id NOT IN (SELECT Channel FROM Cartoon WHERE directed_by = 'Ben Jones')"
        ]
    },
    "647": {
        "db_id": "poker_player",
        "question": "How many poker players are there?",
        "ground_truth": "SELECT count(*) FROM poker_player",
        "amends": [
            "Do reference the `poker_player` table instead of the `players` table. Do remove the `WHERE game_type = 'blackjack'` filter instead of keeping it. The amended query now correctly counts all records in the poker_player table without any filtering conditions."
        ],
        "rules": [
            "When answering about \"how many poker players\": use the \"poker_player\" table instead of the \"players\" table.",
            "When counting poker players: count all records in the \"poker_player\" table without any filtering conditions.",
            "When answering about \"how many poker players\", When counting poker players, When the question asks for count of poker players: remove any WHERE clause that filters by game_type = 'blackjack'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE game_type = 'blackjack';",
            "SELECT COUNT(*) FROM poker_player;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM poker_player;"
        ]
    },
    "648": {
        "db_id": "poker_player",
        "question": "Count the number of poker players.",
        "ground_truth": "SELECT count(*) FROM poker_player",
        "amends": [
            "Do reference the `poker_player` table instead of the `players` table. Do remove the `WHERE game_type = 'blackjack'` filter instead of keeping it. The amended query now correctly counts all records from the poker_player table without any filtering conditions."
        ],
        "rules": [
            "When counting poker players: use the \"poker_player\" table instead of the \"players\" table.",
            "When counting all poker players: do not apply any filtering conditions like \"game_type = 'blackjack'\".",
            "When counting poker players, When counting all poker players, When counting entities: count all records from the specified table without any restrictions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE game_type = 'blackjack';",
            "SELECT COUNT(*) FROM poker_player;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM poker_player;"
        ]
    },
    "649": {
        "db_id": "poker_player",
        "question": "List the earnings of poker players in descending order.",
        "ground_truth": "SELECT Earnings FROM poker_player ORDER BY Earnings DESC",
        "amends": [
            "Do select `Earnings` instead of `player_name, earnings` and remove the player_name column. Do reference table `poker_player` instead of `poker_players` with the correct table name. Do order by `Earnings DESC` instead of `earnings ASC` with the correct column name and descending order instead of ascending. The amended query now correctly selects only earnings from the poker_player table in descending order."
        ],
        "rules": [
            "When the question asks for \"earnings of poker players\": select only the \"Earnings\" column from the \"poker_player\" table.",
            "When ordering earnings in descending order: sort the results by \"Earnings\" in descending direction (highest to lowest).",
            "When the question asks for \"earnings of poker players\", When ordering earnings in descending order, When the schema shows column names with exact case: use \"Earnings\" exactly as shown in the schema, not \"earnings\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_name, earnings FROM poker_players ORDER BY earnings ASC;",
            "SELECT Earnings FROM poker_player ORDER BY Earnings DESC;"
        ],
        "rule_sql": [
            "SELECT Earnings FROM poker_player ORDER BY Earnings DESC;"
        ]
    },
    "650": {
        "db_id": "poker_player",
        "question": "What are the earnings of poker players, ordered descending by value?",
        "ground_truth": "SELECT Earnings FROM poker_player ORDER BY Earnings DESC",
        "amends": [
            "Do select only `Earnings` instead of both `name` and `earnings`. Do reference table `poker_player` instead of `poker_players`. Do order by `Earnings DESC` instead of `earnings ASC`. The amended query now matches the intended behavior of selecting earnings from the poker_player table in descending order."
        ],
        "rules": [
            "When answering about \"earnings of poker players\": make sure the output order: \"Earnings\" only.",
            "When the question mentions \"poker players\": \"poker players\" actually means table \"poker_player\" in schema.",
            "When answering about \"earnings of poker players\", When the question mentions \"poker players\", When the question says \"ordered descending by value\": order rows by \"Earnings\" in descending direction."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, earnings FROM poker_players ORDER BY earnings ASC;",
            "SELECT Earnings FROM poker_player ORDER BY Earnings DESC;"
        ],
        "rule_sql": [
            "SELECT Earnings FROM poker_player ORDER BY Earnings DESC;"
        ]
    },
    "651": {
        "db_id": "poker_player",
        "question": "List the final tables made and the best finishes of poker players.",
        "ground_truth": "SELECT Final_Table_Made ,  Best_Finish FROM poker_player",
        "amends": [
            "Do select `Final_Table_Made` and `Best_Finish` instead of `player_name`, `final_table`, and `best_finish`. Do query from `poker_player` instead of `poker_players`. Do remove the `ORDER BY player_name` clause instead of keeping it. The amended query now correctly selects the specified columns from the appropriate table without unnecessary ordering."
        ],
        "rules": [
            "When the question asks for \"final tables made\": select the exact column \"Final_Table_Made\" from table \"poker_player\".",
            "When the question asks for \"best finishes\": select the exact column \"Best_Finish\" from table \"poker_player\".",
            "When the question asks for \"final tables made\", When the question asks for \"best finishes\", When the question does not specify any ordering requirement: do not apply any sorting to the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_name, final_table, best_finish FROM poker_players ORDER BY player_name;",
            "SELECT Final_Table_Made, Best_Finish FROM poker_player;"
        ],
        "rule_sql": [
            "SELECT Final_Table_Made, Best_Finish FROM poker_player"
        ]
    },
    "652": {
        "db_id": "poker_player",
        "question": "What are the final tables made and best finishes for all poker players?",
        "ground_truth": "SELECT Final_Table_Made ,  Best_Finish FROM poker_player",
        "amends": [
            "Do reference the correct table name `poker_player` instead of the incorrect `poker_players`. Do use the correct column names `Final_Table_Made` and `Best_Finish` instead of the incorrect `player_name`, `final_table`, and `best_finish`. Do maintain the `ORDER BY Best_Finish DESC` clause as it correctly sorts the results. The amended query now correctly selects the intended columns from the proper table while preserving the sorting logic."
        ],
        "rules": [
            "When the question asks about poker players: use the exact table name \"poker_player\" instead of any variations like \"poker_players\".",
            "When selecting final tables made: use the exact column name \"Final_Table_Made\" with the correct case and spelling.",
            "When selecting best finishes: use the exact column name \"Best_Finish\" with the correct case and spelling.",
            "When the question asks about poker players, When selecting final tables made, When selecting best finishes, When ordering results by best finish: sort by \"Best_Finish\" in descending order (highest to lowest values)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_name, final_table, best_finish FROM poker_players ORDER BY best_finish DESC;",
            "SELECT Final_Table_Made, Best_Finish FROM poker_player ORDER BY Best_Finish DESC;"
        ],
        "rule_sql": [
            "SELECT Final_Table_Made, Best_Finish FROM poker_player ORDER BY Best_Finish DESC;"
        ]
    },
    "653": {
        "db_id": "poker_player",
        "question": "What is the average earnings of poker players?",
        "ground_truth": "SELECT avg(Earnings) FROM poker_player",
        "amends": [
            "Do reference table `poker_player` instead of `players` and use column `Earnings` instead of `earnings`. Do remove the `WHERE sport = 'basketball'` filter instead of keeping it, as the query should calculate average earnings across all poker players rather than filtering for basketball players. The amended query now correctly calculates the average earnings from the poker_player table without any sport-based filtering."
        ],
        "rules": [
            "When answering about \"average earnings of poker players\": use table \"poker_player\" and column \"Earnings\" exactly as shown in the schema.",
            "When the question mentions \"poker players\": this refers to all records in the \"poker_player\" table without any sport-based filtering.",
            "When answering about \"average earnings of poker players\", When the question mentions \"poker players\", When calculating average earnings: compute the average of the \"Earnings\" column across all rows in the \"poker_player\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(earnings) FROM players WHERE sport = 'basketball';",
            "SELECT AVG(Earnings) FROM poker_player"
        ],
        "rule_sql": [
            "SELECT AVG(Earnings) FROM poker_player;"
        ]
    },
    "654": {
        "db_id": "poker_player",
        "question": "Return the average earnings across all poker players.",
        "ground_truth": "SELECT avg(Earnings) FROM poker_player",
        "amends": [
            "Do reference the table as `poker_player` instead of `poker_players` to match the correct table name. Do use the column name `Earnings` with proper capitalization instead of lowercase `earnings` to match the actual column definition. Do remove the `WHERE earnings > 1000000` filter instead of keeping it, as the correct query calculates the overall average without filtering. The amended query now correctly calculates the average earnings across all poker players without unnecessary filtering."
        ],
        "rules": [
            "When the question asks for average earnings across all poker players: use the table name \"poker_player\" exactly as specified in the schema.",
            "When referring to the earnings column: use the exact column name \"Earnings\" with proper capitalization as shown in the schema.",
            "When the question asks for average earnings across all poker players, When referring to the earnings column, When calculating overall average without filtering: do not apply any WHERE clause conditions like earnings > 1000000, as the question requires including all records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(earnings) FROM poker_players WHERE earnings > 1000000;",
            "SELECT AVG(Earnings) FROM poker_player"
        ],
        "rule_sql": [
            "SELECT AVG(Earnings) FROM poker_player"
        ]
    },
    "655": {
        "db_id": "poker_player",
        "question": "What is the money rank of the poker player with the highest earnings?",
        "ground_truth": "SELECT Money_Rank FROM poker_player ORDER BY Earnings DESC LIMIT 1",
        "amends": [
            "Do use `Money_Rank` as the column alias instead of `money_rank`. Do select from `poker_player` instead of `poker_players`. Do remove the window function `RANK() OVER (ORDER BY earnings DESC)` and instead use a simple `ORDER BY Earnings DESC` with `LIMIT 1` to get the top-ranked player. Do eliminate the subquery `(SELECT MAX(earnings) FROM poker_players)` that was incorrectly filtering for only maximum earnings records. Do remove the `WHERE` clause entirely instead of using it to filter for maximum earnings. The amended query now correctly retrieves the top-ranked player by earnings using proper ordering and limiting instead of the complex window function approach with incorrect filtering."
        ],
        "rules": [
            "When the question asks for the \"money rank\" of a poker player: use the exact column name \"Money_Rank\" from the poker_player table.",
            "When the question asks for the player with the highest earnings: order the results by \"Earnings\" in descending order and take only the first row.",
            "When retrieving the top-ranked player: do not use window functions or subqueries for maximum earnings filtering, instead use simple ordering and limiting.",
            "When the question asks for the \"money rank\" of a poker player, When the question asks for the player with the highest earnings, When retrieving the top-ranked player, When selecting from the poker players table: use the exact table name \"poker_player\" (not \"poker_players\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT RANK() OVER (ORDER BY earnings DESC) as money_rank FROM poker_players WHERE earnings = (SELECT MAX(earnings) FROM poker_players);",
            "SELECT Money_Rank FROM poker_player ORDER BY Earnings DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Money_Rank FROM poker_player ORDER BY Earnings DESC LIMIT 1;"
        ]
    },
    "656": {
        "db_id": "poker_player",
        "question": "Return the money rank of the player with the greatest earnings.",
        "ground_truth": "SELECT Money_Rank FROM poker_player ORDER BY Earnings DESC LIMIT 1",
        "amends": [
            "Do select `Money_Rank` directly instead of using `MAX(money_rank)` aggregation. Do query from `poker_player` table instead of `players` table. Do remove the WHERE clause with subquery that finds maximum earnings instead of keeping it. Do add `ORDER BY Earnings DESC` to sort by highest earnings instead of omitting ordering. Do add `LIMIT 1` to return only the top row instead of using aggregation and subquery. The amended query now correctly retrieves the money rank of the player with the highest earnings by sorting and limiting rather than using complex aggregation with subqueries."
        ],
        "rules": [
            "When answering about \"money rank of the player with the greatest earnings\": make sure the output order: Money_Rank.",
            "When the question mentions \"players\": \"players\" actually means \"poker_player\" in schema.",
            "When the question asks for the player with \"greatest earnings\": sort rows by Earnings in descending order and keep the first 1 row.",
            "When answering about \"money rank of the player with the greatest earnings\", When the question mentions \"players\", When the question asks for the player with \"greatest earnings\", When selecting the money rank: select Money_Rank directly without aggregation functions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(money_rank) FROM players WHERE earnings = (SELECT MAX(earnings) FROM players);",
            "SELECT Money_Rank FROM poker_player ORDER BY Earnings DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Money_Rank FROM poker_player ORDER BY Earnings DESC LIMIT 1"
        ]
    },
    "657": {
        "db_id": "poker_player",
        "question": "What is the maximum number of final tables made among poker players with earnings less than 200000?",
        "ground_truth": "SELECT max(Final_Table_Made) FROM poker_player WHERE Earnings  <  200000",
        "amends": [
            "Do use the correct table name `poker_player` instead of the incorrect `poker_players`. Do reference the correct column `Final_Table_Made` instead of the non-existent `final_tables`. Do change the aggregate function to `max` (lowercase) instead of `MAX` (uppercase) for consistency. Do correct the filter condition to use `< 200000` instead of `> 200000` to select players with earnings below the threshold rather than above it. Do reference the correct earnings column `Earnings` instead of the incorrect `earnings`. The amended query now correctly selects the maximum number of final tables made by poker players with earnings less than 200,000, matching the intended behavior."
        ],
        "rules": [
            "When the question mentions \"poker players\": use the exact table name \"poker_player\" instead of any pluralized or alternative forms.",
            "When the question asks about \"final tables made\": use the exact column name \"Final_Table_Made\" from the poker_player table.",
            "When the question specifies \"earnings less than 200000\": filter rows where the \"Earnings\" column value is less than 200000 using the exact comparison operator \"<\".",
            "When the question asks for the \"maximum number\": compute the maximum value of the \"Final_Table_Made\" column using the lowercase \"max\" function.",
            "When the question mentions \"poker players\", When the question asks about \"final tables made\", When the question specifies \"earnings less than 200000\", When the question asks for the \"maximum number\", When producing output: ensure the result contains only the maximum value of Final_Table_Made for players meeting the earnings criteria."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(final_tables) FROM poker_players WHERE earnings > 200000;",
            "SELECT max(Final_Table_Made) FROM poker_player WHERE Earnings < 200000"
        ],
        "rule_sql": [
            "SELECT MAX(Final_Table_Made) FROM poker_player WHERE Earnings < 200000"
        ]
    },
    "658": {
        "db_id": "poker_player",
        "question": "Return the maximum final tables made across all poker players who have earnings below 200000.",
        "ground_truth": "SELECT max(Final_Table_Made) FROM poker_player WHERE Earnings  <  200000",
        "amends": [
            "Do use the correct table name `poker_player` instead of the incorrect `poker_players`. Do use the correct column name `Final_Table_Made` instead of the incorrect `final_tables`. Do use the correct aggregate function `max` (lowercase) instead of `MAX` (uppercase). Do use the correct comparison operator `<` instead of `>` to filter for earnings less than 200000 instead of greater than 200000. Do use the correct column name `Earnings` instead of `earnings` for the filter condition. The amended query now correctly retrieves the maximum number of final tables made by poker players with earnings below 200000, matching the intended behavior."
        ],
        "rules": [
            "When referring to poker players in the database: use the exact table name \"poker_player\" instead of \"poker_players\".",
            "When the question mentions \"final tables made\": this corresponds to the exact column name \"Final_Table_Made\" in the poker_player table.",
            "When filtering for players with earnings below 200000: use the exact column name \"Earnings\" with the comparison operator < 200000, not > 200000.",
            "When computing the maximum value: use the aggregate function \"max\" (lowercase) on the \"Final_Table_Made\" column.",
            "When referring to poker players in the database, When the question mentions \"final tables made\", When filtering for players with earnings below 200000, When computing the maximum value, When answering about maximum final tables across players with earnings below 200000: compute max(\"Final_Table_Made\") from \"poker_player\" where \"Earnings\" < 200000."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(final_tables) FROM poker_players WHERE earnings > 200000;",
            "SELECT max(Final_Table_Made) FROM poker_player WHERE Earnings < 200000"
        ],
        "rule_sql": [
            "SELECT MAX(\"Final_Table_Made\") FROM \"poker_player\" WHERE \"Earnings\" < 200000;"
        ]
    },
    "659": {
        "db_id": "poker_player",
        "question": "What are the names of poker players?",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID",
        "amends": [
            "Do select `T1.Name` from the `people` table instead of `player_name` from `poker_players`. Do join `poker_player` as `T2` on `T1.People_ID = T2.People_ID` instead of querying `poker_players` directly with a `WHERE player_id = 1` filter. Do use proper table aliases `T1` and `T2` instead of no aliases. The amended query now correctly retrieves player names by joining the people table with poker player information through the proper relationship."
        ],
        "rules": [
            "When answering about \"names of poker players\": make sure the output order: T1.Name.",
            "When the question mentions \"poker players\": \"poker players\" actually means \"people who are poker players in schema\" requiring joining people table with poker_player table.",
            "When combining T1 (people) and T2 (poker_player) for shared entities: link rows where T1.People_ID = T2.People_ID exactly as shown; keep only matching pairs (inner match).",
            "When answering about \"names of poker players\", When the question mentions \"poker players\", When combining T1 (people) and T2 (poker_player) for shared entities, When the wrong query uses a specific player_id filter (player_id = 1): do not apply any player_id filter since the question asks for all poker players."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_name FROM poker_players WHERE player_id = 1;",
            "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM people T1 INNER JOIN poker_player T2 ON T1.People_ID = T2.People_ID ORDER BY T1.Name;"
        ]
    },
    "660": {
        "db_id": "poker_player",
        "question": "Return the names of all the poker players.",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID",
        "amends": [
            "Do select `T1.Name` instead of `player_id` and do add `people AS T1` and `poker_player AS T2` as joined tables instead of only `poker_players`. Do use `INNER JOIN` with predicate `T1.People_ID = T2.People_ID` instead of no join condition. The amended query now correctly retrieves player names from the people table by joining with poker_player on their relationship key instead of attempting to select player_id directly from a non-existent or incorrect table structure."
        ],
        "rules": [
            "When answering about \"names of all the poker players\": make sure the output order: T1.Name",
            "When the question mentions \"poker players\": \"poker players\" actually means \"people who are poker players in schema\"",
            "When combining T1 and T2 for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (T1.People_ID = T2.People_ID); keep only matching pairs (inner match)",
            "When answering about \"names of all the poker players\", When the question mentions \"poker players\", When combining T1 and T2 for shared entities, When selecting from multiple tables: use people AS T1 and poker_player AS T2 as joined tables instead of only poker_players"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_id FROM poker_players;",
            "SELECT T1.Name \nFROM people AS T1 \nINNER JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM people AS T1 INNER JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T1.Name;"
        ]
    },
    "661": {
        "db_id": "poker_player",
        "question": "What are the names of poker players whose earnings is higher than 300000?",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID WHERE T2.Earnings  >  300000",
        "amends": [
            "Do reference the `people` table as `T1` and select `T1.Name` instead of selecting `name` from a non-existent `poker_players` table. Do add a `JOIN` with `poker_player` as `T2` on the predicate `T1.People_ID = T2.People_ID` instead of querying a single table. Do filter on `T2.Earnings > 300000` instead of filtering on a non-existent `earnings` column from the wrong table. The amended query now correctly joins the people and poker_player tables to find players with earnings exceeding 300000, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks about poker players' names: select \"T1.Name\" from the \"people\" table as T1 instead of selecting \"name\" from a non-existent table.",
            "When combining information about poker players and their earnings: join \"people\" as T1 with \"poker_player\" as T2 using the condition \"T1.People_ID = T2.People_ID\" to link player identities.",
            "When the question asks about poker players' names, When combining information about poker players and their earnings, When filtering for earnings higher than 300000: apply the filter \"T2.Earnings > 300000\" using the exact column from the poker_player table instead of a non-existent earnings column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM poker_players WHERE earnings > 300000",
            "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID WHERE T2.Earnings > 300000"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID WHERE T2.Earnings > 300000"
        ]
    },
    "662": {
        "db_id": "poker_player",
        "question": "Give the names of poker players who have earnings above 300000.",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID WHERE T2.Earnings  >  300000",
        "amends": [
            "Do reference the `Name` column from the `people` table instead of `name` from `poker_players`. Do join `people AS T1` with `poker_player AS T2` using `T1.People_ID = T2.People_ID` instead of querying a single `poker_players` table. Do filter on `T2.Earnings > 300000` instead of `earnings > 300000` to correctly reference the joined table's column. The amended query now properly relates player information from the people table with earnings data from the poker_player table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about poker players' names: make sure the output order: T1.\"Name\"",
            "When the question mentions \"poker players\": \"poker players\" actually means \"people in schema\"",
            "When combining T1 and T2 for shared entities: link rows where T1.People_ID = T2.People_ID exactly as shown in the amends; keep only matching pairs (inner match)",
            "When answering about poker players' names, When the question mentions \"poker players\", When combining T1 and T2 for shared entities, When filtering on earnings above 300000: use T2.Earnings > 300000 to correctly reference the joined table's column"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM poker_players WHERE earnings > 300000",
            "SELECT T1.Name \nFROM people AS T1 \nJOIN poker_player AS T2 ON T1.People_ID = T2.People_ID \nWHERE T2.Earnings > 300000"
        ],
        "rule_sql": [
            "SELECT T1.Name \nFROM people T1 \nINNER JOIN poker_player T2 ON T1.People_ID = T2.People_ID \nWHERE T2.Earnings > 300000 \nORDER BY T1.Name"
        ]
    },
    "663": {
        "db_id": "poker_player",
        "question": "List the names of poker players ordered by the final tables made in ascending order.",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Final_Table_Made",
        "amends": [
            "Do join `people AS T1` with `poker_player AS T2` on `T1.People_ID = T2.People_ID` instead of querying only `poker_players` without any join. Do select `T1.Name` instead of just `name` to specify the table source. Do order by `T2.Final_Table_Made` instead of `final_tables` to use the correct column name from the joined table. The amended query now correctly retrieves player names from the people table joined with poker player data and orders by the appropriate final tables column."
        ],
        "rules": [
            "When answering about poker players' names ordered by final tables: make sure the output order is T1.Name.",
            "When combining people and poker_player tables: link rows where T1.People_ID = T2.People_ID and keep only matching pairs (inner match).",
            "When ordering by final tables made: use T2.Final_Table_Made column in ascending order instead of descending.",
            "When answering about poker players' names ordered by final tables, When combining people and poker_player tables, When ordering by final tables made, When selecting player names: use T1.Name from the people table instead of just name to specify the table source."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM poker_players ORDER BY final_tables DESC;",
            "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Final_Table_Made ASC"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM people T1 INNER JOIN poker_player T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Final_Table_Made ASC"
        ]
    },
    "664": {
        "db_id": "poker_player",
        "question": "What are the names of poker players, ordered ascending by the number of final tables they have made?",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Final_Table_Made",
        "amends": [
            "Do select `T1.Name` instead of `name, COUNT(final_table)` and remove the aggregate function and alias. Do use `FROM people AS T1 JOIN poker_player AS T2` instead of `FROM poker_players` with a proper join instead of a single table. Do specify the join condition `ON T1.People_ID = T2.People_ID` instead of omitting join predicates. Do remove the `COUNT` aggregation and `GROUP BY` implication instead of including them. Do order by `T2.Final_Table_Made` instead of `final_tables DESC` using the actual column rather than an aggregate result. The amended query now correctly retrieves player names joined with poker player data and orders by final tables made."
        ],
        "rules": [
            "When answering about poker players' names ordered by final tables made: make sure the output order includes T1.Name and T2.Final_Table_Made.",
            "When the question mentions \"poker players\": use \"people AS T1 JOIN poker_player AS T2\" with join condition T1.People_ID = T2.People_ID instead of a single table.",
            "When ordering by number of final tables: use T2.Final_Table_Made column directly instead of counting or aggregating.",
            "When selecting player names: use T1.Name instead of generic name column.",
            "When answering about poker players' names ordered by final tables made, When the question mentions \"poker players\", When ordering by number of final tables, When selecting player names, When the question asks for ascending order: order by T2.Final_Table_Made in ascending direction instead of descending."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, COUNT(final_table) as final_tables FROM poker_players ORDER BY final_tables DESC;",
            "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Final_Table_Made ASC"
        ],
        "rule_sql": [
            "SELECT T1.Name, T2.Final_Table_Made FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Final_Table_Made ASC"
        ]
    },
    "665": {
        "db_id": "poker_player",
        "question": "What is the birth date of the poker player with the lowest earnings?",
        "ground_truth": "SELECT T1.Birth_Date FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Earnings ASC LIMIT 1",
        "amends": [
            "Do join `people AS T1` with `poker_player AS T2` on `T1.People_ID = T2.People_ID` instead of querying only `poker_players` table. Do select `T1.Birth_Date` from the joined people table instead of `birth_date` from the poker_players table. Do order by `T2.Earnings` from the joined poker_player table instead of `earnings` from the original table. The amended query now correctly retrieves birth dates by joining related tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"birth date of poker player\": make sure to join \"people AS T1\" with \"poker_player AS T2\" on \"T1.People_ID = T2.People_ID\" and keep only matching pairs (inner match).",
            "When selecting the birth date: use \"T1.Birth_Date\" from the people table instead of any other column.",
            "When ordering by earnings to find the lowest: use \"T2.Earnings\" from the poker_player table in ascending order.",
            "When answering about \"birth date of poker player\", When selecting the birth date, When ordering by earnings to find the lowest, When limiting to the single result with lowest earnings: take only the first row after ordering by earnings ascending."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT birth_date FROM poker_players ORDER BY earnings ASC LIMIT 1;",
            "SELECT T1.Birth_Date FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Birth_Date FROM people AS T1 INNER JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings ASC LIMIT 1"
        ]
    },
    "666": {
        "db_id": "poker_player",
        "question": "Return the birth date of the poker player with the lowest earnings.",
        "ground_truth": "SELECT T1.Birth_Date FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Earnings ASC LIMIT 1",
        "amends": [
            "Do join `people AS T1` with `poker_player AS T2` on `T1.People_ID = T2.People_ID` instead of querying only `poker_players` table. Do select `T1.Birth_Date` from the joined people table instead of `birth_date` from the poker_players table. Do order by `T2.Earnings` from the joined poker_player table instead of `earnings` from the poker_players table. The amended query now correctly retrieves birth dates by joining related tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"the poker player with the lowest earnings\": join table \"people AS T1\" with table \"poker_player AS T2\" where T1.People_ID equals T2.People_ID to combine player information with earnings data.",
            "When selecting the birth date: use T1.Birth_Date from the people table instead of birth_date from poker_players table.",
            "When ordering by earnings to find the lowest: use T2.Earnings from the poker_player table in ascending order to identify the player with minimum earnings.",
            "When answering about \"the poker player with the lowest earnings\", When selecting the birth date, When ordering by earnings to find the lowest, When combining tables for shared entities: link rows where T1.People_ID = T2.People_ID exactly and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT birth_date FROM poker_players ORDER BY earnings ASC LIMIT 1;",
            "SELECT T1.Birth_Date FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Birth_Date FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings ASC LIMIT 1;"
        ]
    },
    "667": {
        "db_id": "poker_player",
        "question": "What is the money rank of the tallest poker player?",
        "ground_truth": "SELECT T2.Money_Rank FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T1.Height DESC LIMIT 1",
        "amends": [
            "Do select `T2.Money_Rank` from the joined table instead of `money_rank` directly from the poker_players table. Do join `people AS T1` with `poker_player AS T2` on `T1.People_ID = T2.People_ID` instead of querying only the poker_players table. Do order by `T1.Height` from the people table instead of `height` from the poker_players table. The amended query now correctly retrieves money rank by joining the people and poker_player tables and ordering by height from the people table, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"money rank of the tallest poker player\": make sure the output order: T2.Money_Rank.",
            "When combining people and poker_player tables: link rows where T1.People_ID = T2.People_ID exactly as shown; keep only matching pairs (inner match).",
            "When answering about \"money rank of the tallest poker player\", When combining people and poker_player tables, When the question mentions \"tallest\": rank rows by T1.Height in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT money_rank FROM poker_players ORDER BY height DESC LIMIT 1;",
            "SELECT T2.Money_Rank \nFROM people AS T1 \nJOIN poker_player AS T2 ON T1.People_ID = T2.People_ID \nORDER BY T1.Height DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Money_Rank FROM people T1 INNER JOIN poker_player T2 ON T1.People_ID = T2.People_ID ORDER BY T1.Height DESC LIMIT 1"
        ]
    },
    "668": {
        "db_id": "poker_player",
        "question": "Return the money rank of the poker player with the greatest height.",
        "ground_truth": "SELECT T2.Money_Rank FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T1.Height DESC LIMIT 1",
        "amends": [
            "Do select `T2.Money_Rank` from the joined table instead of `money_rank` from a single table. Do join `people AS T1` with `poker_player AS T2` on `T1.People_ID = T2.People_ID` instead of querying only `poker_players`. Do order by `T1.Height` from the people table instead of `height` from poker_players. The amended query now correctly retrieves money rank by joining related tables and ordering by the appropriate height column, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"money rank of the poker player with the greatest height\": make sure the output order: T2.Money_Rank.",
            "When combining people AS T1 and poker_player AS T2 for shared entities: link rows where T1.People_ID = T2.People_ID exactly as shown; keep only matching pairs (inner match).",
            "When answering about \"money rank of the poker player with the greatest height\", When combining people AS T1 and poker_player AS T2 for shared entities, When the question mentions \"greatest height\": rank rows by T1.Height in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT money_rank FROM poker_players ORDER BY height DESC LIMIT 1;",
            "SELECT T2.Money_Rank FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T1.Height DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Money_Rank FROM people AS T1 INNER JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T1.Height DESC LIMIT 1"
        ]
    },
    "669": {
        "db_id": "poker_player",
        "question": "What is the average earnings of poker players with height higher than 200?",
        "ground_truth": "SELECT avg(T2.Earnings) FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Height  >  200",
        "amends": [
            "Do use table alias `T2` for `poker_player` instead of directly referencing `poker_players`. Do add explicit `JOIN` between `people AS T1` and `poker_player AS T2` instead of querying a single table. Do specify join condition `ON T1.People_ID = T2.People_ID` instead of omitting the relationship. Do reference `T1.Height` in the WHERE clause instead of `height` from the wrong table. Do use column name `Earnings` instead of `earnings` with proper table qualification. The amended query now correctly joins related tables and filters on the appropriate height column from the people table."
        ],
        "rules": [
            "When answering about average earnings of poker players: use table alias T2 for poker_player table and compute average of T2.Earnings.",
            "When filtering by height higher than 200: reference T1.Height from the people table instead of height from poker_player table.",
            "When combining people and poker_player tables: link rows where T1.People_ID = T2.People_ID using an inner join.",
            "When answering about average earnings of poker players, When filtering by height higher than 200, When combining people and poker_player tables, When using column names: use exact case as shown in schema - Earnings (not earnings) and People_ID (not People_ID)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(earnings) FROM poker_players WHERE height > 200;",
            "SELECT AVG(T2.Earnings) \nFROM people AS T1 \nJOIN poker_player AS T2 ON T1.People_ID = T2.People_ID \nWHERE T1.Height > 200"
        ],
        "rule_sql": [
            "SELECT AVG(T2.Earnings) FROM poker_player T2 INNER JOIN people T1 ON T1.People_ID = T2.People_ID WHERE T1.Height > 200"
        ]
    },
    "670": {
        "db_id": "poker_player",
        "question": "Give average earnings of poker players who are taller than 200.",
        "ground_truth": "SELECT avg(T2.Earnings) FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Height  >  200",
        "amends": [
            "Do join `people AS T1` and `poker_player AS T2` on `T1.People_ID = T2.People_ID` instead of querying only `poker_players` table. Do reference `T2.Earnings` instead of `earnings` from the wrong table. Do filter on `T1.Height > 200` instead of `height > 200` from the incorrect table. The amended query now correctly joins related tables and references the appropriate columns to match the intended behavior."
        ],
        "rules": [
            "When answering about \"average earnings of poker players\": make sure the output order: average of T2.Earnings.",
            "When combining people and poker_player tables: link rows where T1.People_ID = T2.People_ID and keep only matching pairs (inner match).",
            "When the question mentions \"poker players who are taller than 200\": filter rows where T1.Height > 200.",
            "When answering about \"average earnings of poker players\", When combining people and poker_player tables, When the question mentions \"poker players who are taller than 200\", When computing average earnings: use T2.Earnings from the poker_player table, not earnings from the poker_players table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(earnings) FROM poker_players WHERE height > 200",
            "SELECT AVG(T2.Earnings) FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID WHERE T1.Height > 200"
        ],
        "rule_sql": [
            "SELECT AVG(T2.Earnings) FROM people T1 INNER JOIN poker_player T2 ON T1.People_ID = T2.People_ID WHERE T1.Height > 200"
        ]
    },
    "671": {
        "db_id": "poker_player",
        "question": "What are the names of poker players in descending order of earnings?",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Earnings DESC",
        "amends": [
            "Do select `T1.Name` from the `people` table instead of `name` from `poker_players`. Do join `poker_player` as `T2` on `T1.People_ID = T2.People_ID` instead of querying only the `poker_players` table. Do order by `T2.Earnings DESC` instead of `earnings ASC`, changing both the sort direction and the source table for the earnings column. The amended query now correctly joins the people and poker_player tables to retrieve player names with their corresponding earnings data and sorts them in descending order by earnings, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about poker player names: select \"T1.Name\" from the \"people\" table instead of \"name\" from \"poker_players\".",
            "When combining people and poker_player tables: link rows where \"T1.People_ID = T2.People_ID\" and keep only matching pairs (inner match).",
            "When answering about poker player names, When combining people and poker_player tables, When ordering by earnings in descending order: sort by \"T2.Earnings DESC\" instead of \"earnings ASC\", changing both the sort direction and the source table for the earnings column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM poker_players ORDER BY earnings ASC;",
            "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings DESC"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM people T1 INNER JOIN poker_player T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings DESC"
        ]
    },
    "672": {
        "db_id": "poker_player",
        "question": "Return the names of poker players sorted by their earnings descending.",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Earnings DESC",
        "amends": [
            "Do select `T1.Name` from the `people` table instead of `name` from `poker_players`. Do join `people AS T1` with `poker_player AS T2` on `T1.People_ID = T2.People_ID` instead of querying only the `poker_players` table. Do order by `T2.Earnings DESC` instead of `earnings ASC` to sort in descending order. The amended query now correctly retrieves player names from the people table joined with poker player data and sorts by earnings in descending order, matching the intended behavior."
        ],
        "rules": [
            "When answering about poker player names: select \"T1.Name\" from the \"people\" table instead of \"name\" from \"poker_players\".",
            "When combining people and poker player data: join \"people AS T1\" with \"poker_player AS T2\" on \"T1.People_ID = T2.People_ID\" using exact key equality and keep only matching pairs.",
            "When answering about poker player names, When combining people and poker player data, When sorting by earnings: order by \"T2.Earnings DESC\" instead of ascending to sort in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM poker_players ORDER BY earnings ASC;",
            "SELECT T1.Name \nFROM people AS T1\nJOIN poker_player AS T2 ON T1.People_ID = T2.People_ID\nORDER BY T2.Earnings DESC"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings DESC"
        ]
    },
    "673": {
        "db_id": "poker_player",
        "question": "What are different nationalities of people and the corresponding number of people from each nation?",
        "ground_truth": "SELECT Nationality ,  COUNT(*) FROM people GROUP BY Nationality",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT nationality, COUNT(*) FROM people GROUP BY nationality ORDER BY COUNT(*) DESC;"
        ],
        "rule_sql": [
            "SELECT Nationality, COUNT(*) AS Number_of_People FROM people GROUP BY Nationality ORDER BY Number_of_People DESC;"
        ]
    },
    "674": {
        "db_id": "poker_player",
        "question": "How many people are there of each nationality?",
        "ground_truth": "SELECT Nationality ,  COUNT(*) FROM people GROUP BY Nationality",
        "amends": [
            "Do group by `Nationality` instead of `name` to correctly aggregate counts by nationality rather than by individual names. Do capitalize `Nationality` in the SELECT list instead of using lowercase `nationality` for consistency with the GROUP BY clause. The amended query now correctly counts people by their nationality rather than by name, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for counts by nationality: group by the exact column \"Nationality\" from the people table.",
            "When counting people per group: use the canonical key for counting (typically the primary key or unique identifier) to count distinct individuals.",
            "When selecting the nationality column: use the exact capitalization \"Nationality\" as shown in the schema to match the GROUP BY clause.",
            "When the question asks for counts by nationality, When counting people per group, When selecting the nationality column, When the question asks \"how many people are there of each nationality\": organize results by \"Nationality\" and compute the count of people per nationality group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT nationality, COUNT(*) FROM people GROUP BY name;",
            "SELECT Nationality, COUNT(*) AS count FROM people GROUP BY Nationality;"
        ],
        "rule_sql": [
            "SELECT Nationality, COUNT(People_ID) AS count_people FROM people GROUP BY Nationality;"
        ]
    },
    "675": {
        "db_id": "poker_player",
        "question": "What is the most common nationality of people?",
        "ground_truth": "SELECT Nationality FROM people GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do use `Nationality` instead of `nationality` for the column name in both the SELECT list and GROUP BY clause. Do order by `COUNT(*) DESC` instead of `ASC` to get the nationality with the highest count instead of the lowest. Do remove the `count` alias from the SELECT list instead of keeping it since it's not needed in the ORDER BY clause. The amended query now correctly identifies the most common nationality by counting occurrences in descending order.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, as the query only needs to return the Nationality with the highest count rather than both the Nationality and its count value. The amended query now correctly returns just the Nationality column while maintaining the same grouping, ordering, and limiting logic to identify the most frequent nationality."
        ],
        "rules": [
            "When the question asks for the most common nationality: use the exact column name \"Nationality\" from the people table.",
            "When counting occurrences of nationality: count all rows using COUNT(*) and group by \"Nationality\".",
            "When ordering to find the most common: order the results by the count in descending order to get the highest count first.",
            "When the question asks for the most common nationality, When counting occurrences of nationality, When ordering to find the most common, When the question asks for the most common nationality: return only the top result (limit 1).",
            "When the question asks for the most common nationality of people: identify the nationality with the highest count of occurrences.",
            "When counting occurrences of nationalities: count the number of rows for each distinct Nationality value.",
            "When determining the most common value: rank nationalities by their count in descending order and take the first result.",
            "When the question asks for the most common nationality of people, When counting occurrences of nationalities, When determining the most common value, When the question asks for only the nationality value (not the count): return only the Nationality column in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT nationality, COUNT(*) as count FROM people GROUP BY nationality ORDER BY count ASC LIMIT 1;",
            "SELECT Nationality, COUNT(*) FROM people GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT Nationality FROM people GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Nationality FROM people GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "676": {
        "db_id": "poker_player",
        "question": "Give the nationality that is most common across all people.",
        "ground_truth": "SELECT Nationality FROM people GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do reference the column as `Nationality` (case-sensitive) instead of `nationality` in both the SELECT list and GROUP BY clause. Do order by the aggregate expression `COUNT(*)` directly instead of referencing the alias `count`. Do remove the alias `count` from the SELECT list instead of including it. Do maintain the same GROUP BY and LIMIT logic while correcting the column reference case and ordering approach. The amended query now correctly identifies the most common nationality by counting occurrences directly in the ORDER BY clause without an intermediate alias."
        ],
        "rules": [
            "When the question asks for nationality: use the exact column token \"Nationality\" with proper case sensitivity from the schema.",
            "When counting occurrences of nationality: count all rows using COUNT(*) and group by \"Nationality\".",
            "When finding the most common value: order the results by the count in descending order and take only the first result.",
            "When ordering by aggregate results: order directly by the aggregate expression COUNT(*) instead of using an alias.",
            "When the question asks for nationality, When counting occurrences of nationality, When finding the most common value, When ordering by aggregate results, When selecting output columns: include only \"Nationality\" in the SELECT list, not the count alias."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT nationality, COUNT(*) as count FROM people GROUP BY nationality ORDER BY count DESC LIMIT 1;",
            "SELECT Nationality FROM people GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Nationality FROM people GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "677": {
        "db_id": "poker_player",
        "question": "What are the nationalities that are shared by at least two people?",
        "ground_truth": "SELECT Nationality FROM people GROUP BY Nationality HAVING COUNT(*)  >=  2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT nationality FROM people GROUP BY nationality HAVING COUNT(*) >= 2;"
        ],
        "rule_sql": [
            "SELECT Nationality FROM people GROUP BY Nationality HAVING COUNT(*) >= 2"
        ]
    },
    "678": {
        "db_id": "poker_player",
        "question": "Return the nationalities for which there are two or more people.",
        "ground_truth": "SELECT Nationality FROM people GROUP BY Nationality HAVING COUNT(*)  >=  2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT nationality FROM people GROUP BY nationality HAVING COUNT(*) > 1;"
        ],
        "rule_sql": [
            "SELECT Nationality FROM people GROUP BY Nationality HAVING COUNT(*) >= 2"
        ]
    },
    "679": {
        "db_id": "poker_player",
        "question": "List the names and birth dates of people in ascending alphabetical order of name.",
        "ground_truth": "SELECT Name ,  Birth_Date FROM people ORDER BY Name ASC",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, birth_date FROM people ORDER BY name DESC;"
        ],
        "rule_sql": [
            "SELECT Name, Birth_Date FROM people ORDER BY Name ASC;"
        ]
    },
    "680": {
        "db_id": "poker_player",
        "question": "What are the names and birth dates of people, ordered by their names in alphabetical order?",
        "ground_truth": "SELECT Name ,  Birth_Date FROM people ORDER BY Name ASC",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, birth_date FROM people ORDER BY birth_date DESC;"
        ],
        "rule_sql": [
            "SELECT Name, Birth_Date FROM people ORDER BY Name ASC;"
        ]
    },
    "681": {
        "db_id": "poker_player",
        "question": "Show names of people whose nationality is not \"Russia\".",
        "ground_truth": "SELECT Name FROM people WHERE Nationality != \"Russia\"",
        "amends": [
            "Do use `Name` instead of `name` for the column selection to match the correct case sensitivity. Do use `!=` instead of `=` in the WHERE clause to filter for people who are not from Russia instead of those who are from Russia. Do use double quotes `\"Russia\"` instead of single quotes `'Russia'` for the string literal. The amended query now correctly excludes Russian nationals instead of including them, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When selecting the name column from the people table: use the exact column name \"Name\" with proper case sensitivity instead of \"name\".",
            "When filtering for people whose nationality is not \"Russia\": use the inequality operator (!=) instead of equality operator (=) to exclude Russian nationals.",
            "When selecting the name column from the people table, When filtering for people whose nationality is not \"Russia\", When using the string literal \"Russia\": use double quotes \"Russia\" instead of single quotes 'Russia' to match the required literal format."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM people WHERE nationality = 'Russia';",
            "SELECT Name FROM people WHERE Nationality != \"Russia\""
        ],
        "rule_sql": [
            "SELECT Name FROM people WHERE Nationality != \"Russia\";"
        ]
    },
    "682": {
        "db_id": "poker_player",
        "question": "What are the names of people who are not from Russia?",
        "ground_truth": "SELECT Name FROM people WHERE Nationality != \"Russia\"",
        "amends": [
            "Do select `Name` instead of `name` to match the correct column casing. Do use `!=` operator with `Nationality` column instead of `=` operator with `country` column to filter for non-Russian nationalities rather than Russian countries. Do use double quotes around `Russia` instead of single quotes for consistent string literal formatting. The amended query now correctly filters for people whose nationality is not Russia, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for \"names of people\": select the exact column token \"Name\" from the people table.",
            "When filtering for people who are \"not from Russia\": use the exact column token \"Nationality\" with the != operator and the exact string literal \"Russia\" (with double quotes).",
            "When the question asks for \"names of people\", When filtering for people who are \"not from Russia\", When the question mentions \"people\": use the table \"people\" as the base table T1."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM people WHERE country = 'Russia';",
            "SELECT Name FROM people WHERE Nationality != \"Russia\""
        ],
        "rule_sql": [
            "SELECT Name FROM people WHERE Nationality != \"Russia\""
        ]
    },
    "683": {
        "db_id": "poker_player",
        "question": "List the names of people that are not poker players.",
        "ground_truth": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM poker_player)",
        "amends": [
            "Do select `Name` instead of `name` to match the correct column case. Do use a subquery with `NOT IN` to filter out poker players instead of the incorrect direct filter `poker_player = 1`. Do reference `People_ID` in both the main query and subquery instead of the non-existent `poker_player` column. The amended query now correctly identifies non-poker players by excluding those whose IDs exist in the poker_player table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for \"names of people\": select the exact column \"Name\" from the people table.",
            "When filtering for people who are not poker players: exclude people whose \"People_ID\" exists in the poker_player table using a NOT IN subquery.",
            "When the question asks for \"names of people\", When filtering for people who are not poker players, When comparing identifiers between tables: use the exact column \"People_ID\" for matching between the main query and subquery."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM people WHERE poker_player = 1;",
            "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM poker_player)"
        ],
        "rule_sql": [
            "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM poker_player)"
        ]
    },
    "684": {
        "db_id": "poker_player",
        "question": "What are the names of people who do not play poker?",
        "ground_truth": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM poker_player)",
        "amends": [
            "Do select `Name` instead of `name` to match the correct column casing. Do use a subquery with `NOT IN` to filter by `People_ID` values that exist in the `poker_player` table instead of directly comparing `game != 'poker'` which incorrectly assumes the game type is stored as a string value in the people table. Do reference the correct join key `People_ID` in both the main query and subquery instead of attempting to filter by a non-existent `game` column. The amended query now correctly identifies people who are not poker players by checking their ID against the poker_player table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for names of people who do not play poker: select \"Name\" from the people table instead of \"name\" to match the correct column casing.",
            "When filtering people who do not play poker: use a subquery with NOT IN to filter by \"People_ID\" values that exist in the poker_player table instead of comparing to a non-existent \"game\" column.",
            "When the question asks for names of people who do not play poker, When filtering people who do not play poker, When joining between people and poker_player tables: reference the correct join key \"People_ID\" in both the main query and subquery to properly identify poker players."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM people WHERE game != 'poker';",
            "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM poker_player)"
        ],
        "rule_sql": [
            "SELECT \"Name\" FROM people WHERE \"People_ID\" NOT IN (SELECT \"People_ID\" FROM poker_player)"
        ]
    },
    "685": {
        "db_id": "poker_player",
        "question": "How many distinct nationalities are there?",
        "ground_truth": "SELECT count(DISTINCT Nationality) FROM people",
        "amends": [
            "Do use `count(DISTINCT Nationality)` instead of `COUNT(*)` to count distinct nationalities rather than all rows. Do add the `Nationality` column reference instead of omitting it in the aggregate function. The amended query now correctly counts unique nationalities instead of total rows, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for \"distinct nationalities\": count the number of unique values in the \"Nationality\" column using count(DISTINCT Nationality) instead of counting all rows.",
            "When the question asks for \"distinct nationalities\", When counting distinct values: include the specific column reference \"Nationality\" in the aggregate function rather than omitting it."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM people;",
            "SELECT COUNT(DISTINCT Nationality) FROM people;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Nationality) FROM people;"
        ]
    },
    "686": {
        "db_id": "poker_player",
        "question": "Count the number of different nationalities.",
        "ground_truth": "SELECT count(DISTINCT Nationality) FROM people",
        "amends": [
            "Do use `count(DISTINCT Nationality)` instead of `COUNT(*)` to count distinct nationalities rather than all rows. Do include the `Nationality` column in the aggregate function instead of omitting it from the SELECT list. Do remove the `WHERE nationality IS NOT NULL` filter instead of keeping it, as counting distinct values inherently excludes NULLs. The amended query now correctly counts distinct nationalities and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When counting the number of different nationalities: use count(DISTINCT Nationality) instead of COUNT(*) to count distinct values rather than all rows.",
            "When the question asks for \"different nationalities\": include the Nationality column in the aggregate function instead of omitting it from the output.",
            "When counting the number of different nationalities, When the question asks for \"different nationalities\", When counting distinct values: remove any WHERE Nationality IS NOT NULL filter as counting distinct values inherently excludes NULLs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM people WHERE nationality IS NOT NULL;",
            "SELECT COUNT(DISTINCT Nationality) FROM people;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Nationality) FROM people;"
        ]
    },
    "687": {
        "db_id": "voter_1",
        "question": "How many states are there?",
        "ground_truth": "SELECT count(*) FROM area_code_state",
        "amends": [
            "Do query the `area_code_state` table instead of the `cities` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the area_code_state table instead of cities, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"how many states\": query the \"area_code_state\" table instead of the \"cities\" table.",
            "When answering about \"how many states\", When counting records: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" for consistency."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities;",
            "SELECT count(*) FROM area_code_state;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM AREA_CODE_STATE"
        ]
    },
    "688": {
        "db_id": "voter_1",
        "question": "List the contestant numbers and names, ordered by contestant name descending.",
        "ground_truth": "SELECT contestant_number ,  contestant_name FROM contestants ORDER BY contestant_name DESC",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT contestant_number, contestant_name FROM contestants ORDER BY contestant_name ASC;"
        ],
        "rule_sql": [
            "SELECT contestant_number, contestant_name FROM CONTESTANTS ORDER BY contestant_name DESC;"
        ]
    },
    "689": {
        "db_id": "voter_1",
        "question": "List the vote ids, phone numbers and states of all votes.",
        "ground_truth": "SELECT vote_id ,  phone_number ,  state FROM votes",
        "amends": [
            "Do add `state` to the SELECT list instead of omitting it. The amended query now matches the right SQL's behavior by including all required columns."
        ],
        "rules": [
            "When the question asks to list vote ids, phone numbers and states: include all three columns \"vote_id\", \"phone_number\", and \"state\" in the output in the order specified by the question.",
            "When the schema shows column \"state\" as a varchar(2) in table VOTES: use the exact column name \"state\" with the correct data type and format.",
            "When the question asks to list vote ids, phone numbers and states, When the schema shows column \"state\" as a varchar(2) in table VOTES, When the question specifies output columns: maintain the exact column order of vote id, phone number, then state as requested."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT vote_id, phone_number FROM votes;",
            "SELECT vote_id, phone_number, state FROM VOTES;"
        ],
        "rule_sql": [
            "SELECT vote_id, phone_number, state FROM VOTES;"
        ]
    },
    "690": {
        "db_id": "voter_1",
        "question": "What are the maximum and minimum values of area codes?",
        "ground_truth": "SELECT max(area_code) ,  min(area_code) FROM area_code_state",
        "amends": [
            "Do reference the `area_code_state` table instead of the `customers` table to ensure the correct data source for area code statistics. The amended query now correctly aggregates area codes from the appropriate table, matching the intended behavior."
        ],
        "rules": [
            "When answering about maximum and minimum values of area codes: use the \"area_code_state\" table as the data source instead of the \"customers\" table.",
            "When answering about maximum and minimum values of area codes, When computing maximum and minimum values of area codes: aggregate the \"area_code\" column from the \"area_code_state\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(area_code), MIN(area_code) FROM customers;",
            "SELECT MAX(area_code) AS max_area_code, MIN(area_code) AS min_area_code FROM AREA_CODE_STATE"
        ],
        "rule_sql": [
            "SELECT MAX(area_code) AS max_area_code, MIN(area_code) AS min_area_code FROM AREA_CODE_STATE"
        ]
    },
    "691": {
        "db_id": "voter_1",
        "question": "What is last date created of votes from the state 'CA'?",
        "ground_truth": "SELECT max(created) FROM votes WHERE state  =  'CA'",
        "amends": [
            "Do use the column name `created` instead of `created_at` in the MAX function. Do maintain the same filter condition `state = 'CA'` without changes. The amended query now correctly references the actual column name and matches the behavior of the RIGHT_SQL."
        ],
        "rules": [
            "When the question asks for \"last date created\": use the MAX function on the exact column name \"created\" to find the most recent timestamp.",
            "When filtering for votes from the state 'CA': use the exact literal value 'CA' with the state column filter.",
            "When the question asks for \"last date created\", When filtering for votes from the state 'CA', When referring to column names in the schema: use the exact token \"created\" instead of \"created_at\" as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(created_at) FROM votes WHERE state = 'CA';",
            "SELECT MAX(created) FROM VOTES WHERE state = 'CA';"
        ],
        "rule_sql": [
            "SELECT MAX(created) FROM VOTES WHERE state = 'CA';"
        ]
    },
    "692": {
        "db_id": "voter_1",
        "question": "What are the names of the contestants whose names are not 'Jessie Alloway'",
        "ground_truth": "SELECT contestant_name FROM contestants WHERE contestant_name != 'Jessie Alloway'",
        "amends": [
            "Do reference `contestant_name` instead of `name` in the SELECT list and WHERE clause. Do use inequality filter `!= 'Jessie Alloway'` instead of equality filter `= 'Jessie Alloway'` to exclude rather than include that specific record. The amended query now correctly selects all contestants except Jessie Alloway instead of only selecting Jessie Alloway, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for contestant names excluding 'Jessie Alloway': use inequality filter != 'Jessie Alloway' instead of equality filter = 'Jessie Alloway' to exclude rather than include that specific record.",
            "When selecting contestant names: use the exact column token \"contestant_name\" instead of \"name\" in both the SELECT list and WHERE clause.",
            "When the question asks for contestant names excluding 'Jessie Alloway', When selecting contestant names, When handling the literal value 'Jessie Alloway': preserve the exact case, spacing, and punctuation as shown in the question and amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM contestants WHERE name = 'Jessie Alloway';",
            "SELECT contestant_name FROM CONTESTANTS WHERE contestant_name != 'Jessie Alloway'"
        ],
        "rule_sql": [
            "SELECT contestant_name FROM CONTESTANTS WHERE contestant_name != 'Jessie Alloway'"
        ]
    },
    "693": {
        "db_id": "voter_1",
        "question": "What are the distinct states and create time of all votes?",
        "ground_truth": "SELECT DISTINCT state ,  created FROM votes",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do select column `created` instead of `created_at` to match the correct column name. The amended query now correctly returns unique combinations of state and created date values from the votes table."
        ],
        "rules": [
            "When the question asks for \"distinct states and create time\": use DISTINCT to eliminate duplicate combinations of state and created values.",
            "When the question mentions \"create time\": \"create time\" actually means the \"created\" column in the votes table.",
            "When the question asks for \"distinct states and create time\", When the question mentions \"create time\", When selecting output columns: maintain the order state then created as implied by the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT state, created_at FROM votes;",
            "SELECT DISTINCT state, created FROM VOTES;"
        ],
        "rule_sql": [
            "SELECT DISTINCT state, created FROM VOTES ORDER BY state, created;"
        ]
    },
    "694": {
        "db_id": "voter_1",
        "question": "What are the contestant numbers and names of the contestants who had at least two votes?",
        "ground_truth": "SELECT T1.contestant_number , T1.contestant_name FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number GROUP BY T1.contestant_number HAVING count(*)  >=  2",
        "amends": [
            "Do add a `JOIN` with the `votes` table on `contestant_number` instead of querying only the `contestants` table. Do add `GROUP BY contestant_number` to aggregate votes per contestant instead of lacking any grouping. Do move the vote count filter to `HAVING count(*) >= 2` instead of using `WHERE votes >= 2` which incorrectly references a non-existent column. Do qualify columns with table aliases `T1.contestant_number` and `T1.contestant_name` instead of using unqualified column names. The amended query now correctly counts votes from the votes table and filters contestants with at least two votes, matching the intended behavior."
        ],
        "rules": [
            "When answering about contestants with at least two votes: combine data from both contestants and votes tables using T1.contestant_number = T2.contestant_number to link matching records.",
            "When counting votes per contestant: group results by T1.contestant_number to aggregate votes for each contestant.",
            "When filtering for contestants with at least two votes: apply the condition count(*) >= 2 after grouping instead of before.",
            "When answering about contestants with at least two votes, When counting votes per contestant, When filtering for contestants with at least two votes, When selecting contestant information: use qualified column names T1.contestant_number and T1.contestant_name instead of unqualified column names."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT contestant_number, contestant_name FROM contestants WHERE votes >= 2;",
            "SELECT T1.contestant_number, T1.contestant_name\nFROM CONTESTANTS T1\nJOIN VOTES T2 ON T1.contestant_number = T2.contestant_number\nGROUP BY T1.contestant_number, T1.contestant_name\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T1.contestant_number, T1.contestant_name FROM CONTESTANTS T1 JOIN VOTES T2 ON T1.contestant_number = T2.contestant_number GROUP BY T1.contestant_number, T1.contestant_name HAVING COUNT(*) >= 2"
        ]
    },
    "695": {
        "db_id": "voter_1",
        "question": "Of all the contestants who got voted, what is the contestant number and name of the contestant who got least votes?",
        "ground_truth": "SELECT T1.contestant_number , T1.contestant_name FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number GROUP BY T1.contestant_number ORDER BY count(*) ASC LIMIT 1",
        "amends": [
            "Do add `JOIN votes AS T2 ON T1.contestant_number = T2.contestant_number` instead of querying only the contestants table. Do add `GROUP BY T1.contestant_number` instead of omitting grouping. Do change `ORDER BY count(*) ASC` instead of `ORDER BY votes DESC` to sort by vote count ascending rather than descending. Do remove the direct reference to `votes` column instead of including it since votes are now aggregated. The amended query now correctly joins with the votes table, groups by contestant, and orders by the count of votes to find the contestant with the fewest votes, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about contestants who got voted: combine contestants table (T1) with votes table (T2) by linking rows where T1.contestant_number equals T2.contestant_number and keep only matching pairs (inner match).",
            "When counting votes per contestant: organize results by T1.contestant_number and compute the number of votes using count(*) per group.",
            "When finding the contestant with least votes: rank rows by the vote count in ascending order and keep the first 1 row.",
            "When answering about contestants who got voted, When counting votes per contestant, When finding the contestant with least votes, When producing output: return contestant_number and contestant_name from T1 in that order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT contestant_number, contestant_name FROM contestants ORDER BY votes DESC LIMIT 1;",
            "SELECT T1.contestant_number, T1.contestant_name\nFROM CONTESTANTS AS T1\nJOIN VOTES AS T2 ON T1.contestant_number = T2.contestant_number\nGROUP BY T1.contestant_number\nORDER BY COUNT(*) ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.contestant_number, T1.contestant_name\nFROM CONTESTANTS T1\nINNER JOIN VOTES T2 ON T1.contestant_number = T2.contestant_number\nGROUP BY T1.contestant_number, T1.contestant_name\nORDER BY COUNT(*) ASC\nLIMIT 1;"
        ]
    },
    "696": {
        "db_id": "voter_1",
        "question": "What are the number of votes from state 'NY' or 'CA'?",
        "ground_truth": "SELECT count(*) FROM votes WHERE state  =  'NY' OR state  =  'CA'",
        "amends": [
            "Do use `OR` operator between state conditions instead of `AND` operator, as a record cannot simultaneously have both 'NY' and 'CA' values for the state column. Do maintain the same `COUNT(*)` aggregation and table source without changes to other clauses. The amended query now correctly counts records where state is either 'NY' or 'CA' instead of incorrectly requiring both values simultaneously, matching the right SQL's behavior."
        ],
        "rules": [
            "When the question asks for records matching multiple state values with 'or' logic: use OR operator between state conditions instead of AND operator, as a record cannot simultaneously have both 'NY' and 'CA' values for the state column.",
            "When counting votes from specific states: maintain the COUNT(*) aggregation and table source without changes to other clauses.",
            "When the question asks for records matching multiple state values with 'or' logic, When counting votes from specific states, When filtering for state values 'NY' or 'CA': ensure the condition correctly counts records where state is either 'NY' or 'CA' instead of requiring both values simultaneously."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM votes WHERE state = 'NY' AND state = 'CA';",
            "SELECT COUNT(*) FROM VOTES WHERE state = 'NY' OR state = 'CA'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM VOTES WHERE state = 'NY' OR state = 'CA'"
        ]
    },
    "697": {
        "db_id": "voter_1",
        "question": "How many contestants did not get voted?",
        "ground_truth": "SELECT count(*) FROM contestants WHERE contestant_number NOT IN ( SELECT contestant_number FROM votes )",
        "amends": [
            "Do filter with `contestant_number NOT IN` subquery instead of checking `votes IS NULL`. Do remove the direct column check `votes IS NULL` instead of keeping it, and do add a correlated subquery against the `votes` table instead of omitting it. The amended query now correctly identifies contestants without any votes by checking their absence in the votes table rather than relying on a potentially incorrect NULL check in the contestants table."
        ],
        "rules": [
            "When counting contestants who did not get voted: use contestant_number as the counting key instead of checking for NULL values in a votes column.",
            "When identifying contestants without votes: check for contestants whose contestant_number does not appear in the votes table rather than checking for NULL values.",
            "When counting contestants who did not get voted, When identifying contestants without votes, When filtering contestants without votes: use a NOT IN subquery against the votes table to find contestants with no corresponding vote records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM contestants WHERE votes IS NULL;",
            "SELECT COUNT(*) \nFROM CONTESTANTS c \nWHERE c.contestant_number NOT IN (SELECT DISTINCT contestant_number FROM VOTES)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM CONTESTANTS \nWHERE contestant_number NOT IN (SELECT DISTINCT contestant_number FROM VOTES)"
        ]
    },
    "698": {
        "db_id": "voter_1",
        "question": "What is the area code in which the most voters voted?",
        "ground_truth": "SELECT T1.area_code FROM area_code_state AS T1 JOIN votes AS T2 ON T1.state  =  T2.state GROUP BY T1.area_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `area_code` instead of selecting both `area_code` and `COUNT(*) as voter_count`. Do join `area_code_state AS T1` with `votes AS T2` on `T1.state = T2.state` instead of querying only the `voters` table. Do group by `T1.area_code` instead of grouping by `area_code` from a single table. Do order by `count(*) DESC` instead of ordering by `voter_count ASC`. The amended query now correctly joins the area code and votes tables to find the area code with the highest vote count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"area code with the most voters\": make sure the output order: T1.area_code only",
            "When combining area_code_state and votes tables: link rows where T1.state = T2.state and keep only matching pairs (inner match)",
            "When grouping by area code: organize results by T1.area_code and compute count per group",
            "When answering about \"area code with the most voters\", When combining area_code_state and votes tables, When grouping by area code, When the question mentions \"most voters voted\": rank rows by count(*) in descending order and keep the first 1 row"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT area_code, COUNT(*) as voter_count FROM voters GROUP BY area_code ORDER BY voter_count ASC LIMIT 1;",
            "SELECT T1.area_code\nFROM AREA_CODE_STATE AS T1\nJOIN VOTES AS T2 ON T1.state = T2.state\nGROUP BY T1.area_code\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.area_code\nFROM AREA_CODE_STATE T1\nINNER JOIN VOTES T2 ON T1.state = T2.state\nGROUP BY T1.area_code\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "699": {
        "db_id": "voter_1",
        "question": "What are the create dates, states, and phone numbers of the votes that were for the contestant named 'Tabatha Gehling'?",
        "ground_truth": "SELECT T2.created ,  T2.state ,  T2.phone_number FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number WHERE T1.contestant_name  =  'Tabatha Gehling'",
        "amends": [
            "Do join `contestants AS T1` to `votes AS T2` instead of querying only the `votes` table. Do use the join condition `T1.contestant_number = T2.contestant_number` instead of filtering directly on `contestant_name` in the votes table. Do reference columns `T2.created`, `T2.state`, and `T2.phone_number` instead of `create_date`, `state`, and `phone_number` from a single table. Do filter on `T1.contestant_name = 'Tabatha Gehling'` in the WHERE clause instead of applying the contestant name filter directly to the votes table. The amended query now correctly joins the contestants table to access contestant information and properly filters based on the relational connection between tables, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about votes for a specific contestant: join contestants table as T1 to votes table as T2 using the condition T1.contestant_number = T2.contestant_number instead of querying only the votes table.",
            "When filtering by contestant name: apply the filter T1.contestant_name = 'Tabatha Gehling' to the contestants table rather than directly to the votes table.",
            "When answering about votes for a specific contestant, When filtering by contestant name, When selecting vote information: reference columns T2.created, T2.state, and T2.phone_number from the votes table instead of create_date, state, and phone_number from a single table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT create_date, state, phone_number FROM votes WHERE contestant_name = 'Tabatha Gehling';",
            "SELECT T2.created, T2.state, T2.phone_number FROM CONTESTANTS AS T1 JOIN VOTES AS T2 ON T1.contestant_number = T2.contestant_number WHERE T1.contestant_name = 'Tabatha Gehling'"
        ],
        "rule_sql": [
            "SELECT T2.created, T2.state, T2.phone_number FROM CONTESTANTS AS T1 JOIN VOTES AS T2 ON T1.contestant_number = T2.contestant_number WHERE T1.contestant_name = 'Tabatha Gehling'"
        ]
    },
    "700": {
        "db_id": "voter_1",
        "question": "List the area codes in which voters voted both for the contestant 'Tabatha Gehling' and the contestant 'Kelly Clauss'.",
        "ground_truth": "SELECT T3.area_code FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number JOIN area_code_state AS T3 ON T2.state  =  T3.state WHERE T1.contestant_name  =  'Tabatha Gehling' INTERSECT SELECT T3.area_code FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number JOIN area_code_state AS T3 ON T2.state  =  T3.state WHERE T1.contestant_name  =  'Kelly Clauss'",
        "amends": [
            "Do use `INTERSECT` between two complete query blocks instead of a single query with `JOIN` on `area_code`. Do join `contestants` table with `votes` on `contestant_number` instead of filtering `votes` directly by contestant names. Do add `area_code_state` table join on `state` instead of selecting `area_code` directly from `votes`. Do reference `contestant_name` from `contestants` table instead of `contestant` from `votes` table. Do remove `DISTINCT` since `INTERSECT` inherently returns unique results. The amended query now correctly finds area codes where both contestants received votes by properly joining through the normalized schema structure."
        ],
        "rules": [
            "When the question asks for area codes where voters voted for both 'Tabatha Gehling' and 'Kelly Clauss': use INTERSECT between two complete query blocks instead of a single query with JOIN on area_code.",
            "When filtering by contestant names 'Tabatha Gehling' and 'Kelly Clauss': join the contestants table with votes on contestant_number instead of filtering votes directly by contestant names.",
            "When selecting area codes: join area_code_state table on state instead of selecting area_code directly from votes.",
            "When referencing contestant names: use contestant_name from contestants table instead of contestant from votes table.",
            "When using INTERSECT: remove DISTINCT since INTERSECT inherently returns unique results.",
            "When combining tables for shared entities: link votes and contestants using votes.contestant_number = contestants.contestant_number exactly as shown in the schema.",
            "When the question asks for area codes where voters voted for both 'Tabatha Gehling' and 'Kelly Clauss', When filtering by contestant names 'Tabatha Gehling' and 'Kelly Clauss', When selecting area codes, When referencing contestant names, When using INTERSECT, When combining tables for shared entities, When combining tables for area codes: link votes and area_code_state using votes.state = area_code_state.state exactly as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT v1.area_code \nFROM votes v1 \nJOIN votes v2 ON v1.area_code = v2.area_code \nWHERE v1.contestant = 'Tabatha Gehling' \nAND v2.contestant = 'Kelly Clauss'",
            "SELECT acs.area_code\nFROM VOTES v\nJOIN CONTESTANTS c ON v.contestant_number = c.contestant_number\nJOIN AREA_CODE_STATE acs ON v.state = acs.state\nWHERE c.contestant_name = 'Tabatha Gehling'\nINTERSECT\nSELECT acs.area_code\nFROM VOTES v\nJOIN CONTESTANTS c ON v.contestant_number = c.contestant_number\nJOIN AREA_CODE_STATE acs ON v.state = acs.state\nWHERE c.contestant_name = 'Kelly Clauss'"
        ],
        "rule_sql": [
            "SELECT acs.area_code\nFROM VOTES v\nJOIN CONTESTANTS c ON v.contestant_number = c.contestant_number\nJOIN AREA_CODE_STATE acs ON v.state = acs.state\nWHERE c.contestant_name = 'Tabatha Gehling'\nINTERSECT\nSELECT acs.area_code\nFROM VOTES v\nJOIN CONTESTANTS c ON v.contestant_number = c.contestant_number\nJOIN AREA_CODE_STATE acs ON v.state = acs.state\nWHERE c.contestant_name = 'Kelly Clauss'"
        ]
    },
    "701": {
        "db_id": "voter_1",
        "question": "Return the names of the contestants whose names contain the substring 'Al' .",
        "ground_truth": "select contestant_name from contestants where contestant_name like \"%al%\"",
        "amends": [
            "Do reference `contestant_name` instead of `name` in the SELECT list and WHERE clause. Do use lowercase `\"%al%\"` pattern matching instead of uppercase `'%Al%'` for case-insensitive matching. The amended query now correctly matches the RIGHT_SQL's behavior by using the proper column name and case-insensitive pattern matching."
        ],
        "rules": [
            "When the question asks for contestant names containing 'Al': use the exact column name \"contestant_name\" from the CONTESTANTS table.",
            "When performing substring matching for 'Al': use the lowercase pattern \"%al%\" for case-insensitive matching instead of the uppercase 'Al' literal.",
            "When the question asks for contestant names containing 'Al', When performing substring matching for 'Al', When selecting output columns: return only the \"contestant_name\" column in the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM contestants WHERE name LIKE '%Al%';",
            "SELECT contestant_name FROM CONTESTANTS WHERE contestant_name LIKE '%al%'"
        ],
        "rule_sql": [
            "SELECT contestant_name FROM CONTESTANTS WHERE contestant_name LIKE '%al%'"
        ]
    },
    "702": {
        "db_id": "world_1",
        "question": "What are the names of all the countries that became independent after 1950?",
        "ground_truth": "SELECT Name FROM country WHERE IndepYear  >  1950",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the `country` table instead of `countries`. Do use the `IndepYear` column instead of `independence_year` while maintaining the same filter condition `> 1950`. The amended query now correctly references the proper table and column names to match the intended schema structure."
        ],
        "rules": [
            "When the question asks about countries: use the \"country\" table instead of \"countries\" table.",
            "When the question mentions \"names\": use the \"Name\" column instead of \"name\" column.",
            "When the question asks about independence year: use the \"IndepYear\" column instead of \"independence_year\" column.",
            "When the question asks about countries, When the question mentions \"names\", When the question asks about independence year, When filtering for countries that became independent after 1950: apply the condition IndepYear > 1950."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM countries WHERE independence_year > 1950;",
            "SELECT Name FROM country WHERE IndepYear > 1950"
        ],
        "rule_sql": [
            "SELECT Name FROM country WHERE IndepYear > 1950;"
        ]
    },
    "703": {
        "db_id": "world_1",
        "question": "Give the names of the nations that were founded after 1950.",
        "ground_truth": "SELECT Name FROM country WHERE IndepYear  >  1950",
        "amends": [
            "Do select `Name` instead of `name` and use table `country` instead of `nations`. Do filter on `IndepYear > 1950` instead of `founded_year < 1950`, changing both the column reference and the comparison operator direction. The amended query now correctly retrieves countries with independence years after 1950 from the appropriate table."
        ],
        "rules": [
            "When the question asks for \"nations\": use table \"country\" instead of \"nations\" as the main data source.",
            "When the question asks for \"names\": select column \"Name\" from table \"country\" instead of \"name\".",
            "When the question asks for \"nations\", When the question asks for \"names\", When the question asks for nations \"founded after 1950\": filter using column \"IndepYear > 1950\" instead of \"founded_year < 1950\", changing both the column reference and comparison operator direction to get values greater than 1950."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM nations WHERE founded_year < 1950;",
            "SELECT Name FROM country WHERE IndepYear > 1950"
        ],
        "rule_sql": [
            "SELECT Name FROM country WHERE IndepYear > 1950"
        ]
    },
    "704": {
        "db_id": "world_1",
        "question": "How many countries have a republic as their form of government?",
        "ground_truth": "SELECT count(*) FROM country WHERE GovernmentForm  =  \"Republic\"",
        "amends": [
            "Do reference table `country` instead of `countries` and use column `GovernmentForm` instead of `government_form` while maintaining the same filter condition for Republic. Do use double quotes `\"Republic\"` instead of single quotes `'Republic'` for the string literal, though this is a cosmetic difference that doesn't affect functionality. The amended query now correctly counts records from the proper table with the accurate column name while preserving the intended filtering logic."
        ],
        "rules": [
            "When answering about \"countries with a republic form of government\": reference table \"country\" instead of \"countries\".",
            "When filtering for republic form of government: use column \"GovernmentForm\" instead of \"government_form\".",
            "When answering about \"countries with a republic form of government\", When filtering for republic form of government, When specifying the literal value for republic: use double quotes \"Republic\" instead of single quotes 'Republic'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE government_form = 'Republic';",
            "SELECT COUNT(*) FROM country WHERE GovernmentForm = \"Republic\";"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM country WHERE GovernmentForm = \"Republic\";"
        ]
    },
    "705": {
        "db_id": "world_1",
        "question": "How many countries have governments that are republics?",
        "ground_truth": "SELECT count(*) FROM country WHERE GovernmentForm  =  \"Republic\"",
        "amends": [
            "Do reference table `country` instead of `countries` and use column `GovernmentForm` instead of `government`. Do use filter value `\"Republic\"` instead of `'republic'` while maintaining the same case-insensitive logic for counting records where the government form is a republic. The amended query now correctly counts from the proper table and column with the appropriate filter value to match the intended behavior."
        ],
        "rules": [
            "When answering about \"countries with governments that are republics\": use table \"country\" instead of \"countries\" and column \"GovernmentForm\" instead of \"government\".",
            "When filtering for republic governments: use the exact literal value \"Republic\" (with capital R) instead of 'republic'.",
            "When answering about \"countries with governments that are republics\", When filtering for republic governments, When counting countries: compute the number of rows where \"GovernmentForm\" equals \"Republic\" in table \"country\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE government = 'republic';",
            "SELECT COUNT(*) FROM country WHERE GovernmentForm = 'Republic';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM country WHERE GovernmentForm = 'Republic';"
        ]
    },
    "706": {
        "db_id": "world_1",
        "question": "What is the total surface area of the countries in the Caribbean region?",
        "ground_truth": "SELECT sum(SurfaceArea) FROM country WHERE Region  =  \"Caribbean\"",
        "amends": [
            "Do reference the `SurfaceArea` column instead of `area` and use the correct table name `country` instead of `countries`. Do use the correct column name `Region` instead of `region` and maintain proper string literal syntax with double quotes instead of single quotes around 'Caribbean'. The amended query now correctly calculates the total surface area for Caribbean countries using the proper schema elements."
        ],
        "rules": [
            "When the question asks about \"surface area\": use the exact column name \"SurfaceArea\" from table \"country\" instead of \"area\".",
            "When the question refers to \"countries\": use the exact table name \"country\" instead of \"countries\".",
            "When the question mentions \"Caribbean region\": use the exact column name \"Region\" instead of \"region\" and the exact string literal 'Caribbean' with single quotes.",
            "When the question asks about \"surface area\", When the question refers to \"countries\", When the question mentions \"Caribbean region\", When calculating total surface area: sum the \"SurfaceArea\" values for rows where \"Region\" equals 'Caribbean'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(area) FROM countries WHERE region = 'Caribbean';",
            "SELECT SUM(SurfaceArea) FROM country WHERE Region = 'Caribbean';"
        ],
        "rule_sql": [
            "SELECT SUM(SurfaceArea) FROM country WHERE Region = 'Caribbean';"
        ]
    },
    "707": {
        "db_id": "world_1",
        "question": "How much surface area do the countires in the Carribean cover together?",
        "ground_truth": "SELECT sum(SurfaceArea) FROM country WHERE Region  =  \"Caribbean\"",
        "amends": [
            "Do reference the `SurfaceArea` column instead of `surface_area` to match the correct column name. Do reference the `country` table instead of `countries` to use the correct table name. Do use double quotes around 'Caribbean' instead of single quotes to match the correct string literal format. The amended query now correctly calculates the total surface area for Caribbean countries using the proper table and column references."
        ],
        "rules": [
            "When answering about \"surface area of countries in the Caribbean\": use the exact column name \"SurfaceArea\" from the country table.",
            "When the question mentions \"Caribbean\": use the exact string literal \"Caribbean\" with double quotes.",
            "When calculating total surface area: sum the \"SurfaceArea\" values for all matching rows.",
            "When answering about \"surface area of countries in the Caribbean\", When the question mentions \"Caribbean\", When calculating total surface area, When filtering by region: use the condition where region equals \"Caribbean\" to select Caribbean countries."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(surface_area) FROM countries WHERE region = 'Caribbean';",
            "SELECT SUM(SurfaceArea) FROM country WHERE Region = \"Caribbean\";"
        ],
        "rule_sql": [
            "SELECT SUM(SurfaceArea) FROM country WHERE Region = \"Caribbean\";"
        ]
    },
    "708": {
        "db_id": "world_1",
        "question": "Which continent is Anguilla in?",
        "ground_truth": "SELECT Continent FROM country WHERE Name  =  \"Anguilla\"",
        "amends": [
            "Do reference table `country` instead of `countries` in the FROM clause. Do use column `Continent` instead of `continent` in the SELECT list. Do use column `Name` instead of `name` in the WHERE filter. Do use double quotes `\"Anguilla\"` instead of single quotes for the string literal. The amended query now correctly references the proper table and column names to match the intended schema."
        ],
        "rules": [
            "When answering about \"which continent is Anguilla in\": make sure the output order: \"Continent\".",
            "When the question mentions \"Anguilla\": \"Anguilla\" actually means \"Name\" in schema and must be matched exactly as \"Anguilla\".",
            "When selecting from the country table: use double quotes for column names \"Name\" and \"Continent\" exactly as shown in the schema.",
            "When answering about \"which continent is Anguilla in\", When the question mentions \"Anguilla\", When selecting from the country table, When filtering for a specific country name: use the exact string literal \"Anguilla\" with double quotes as specified in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT continent FROM countries WHERE name = 'Anguilla';",
            "SELECT Continent FROM country WHERE Name = \"Anguilla\";"
        ],
        "rule_sql": [
            "SELECT \"Continent\" FROM country WHERE \"Name\" = \"Anguilla\";"
        ]
    },
    "709": {
        "db_id": "world_1",
        "question": "What is the continent name which Anguilla belongs to?",
        "ground_truth": "SELECT Continent FROM country WHERE Name  =  \"Anguilla\"",
        "amends": [
            "Do reference the table as `country` instead of `countries` and use column `Name` instead of `country_name` for the filter condition. Do use column `Continent` instead of `continent` in the SELECT list. Do use double quotes `\"Anguilla\"` instead of single quotes for the string literal. The amended query now correctly references the schema elements and matches the intended behavior."
        ],
        "rules": [
            "When the question asks about a country's continent: use table \"country\" with column \"Name\" for filtering and column \"Continent\" for the output.",
            "When filtering for a specific country name: use the exact string literal \"Anguilla\" with double quotes.",
            "When the question asks about a country's continent, When filtering for a specific country name, When selecting the continent name: output only the \"Continent\" column from the matching row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT continent FROM countries WHERE country_name = 'Anguilla';",
            "SELECT Continent FROM country WHERE Name = \"Anguilla\";"
        ],
        "rule_sql": [
            "SELECT Continent FROM country WHERE Name = \"Anguilla\";"
        ]
    },
    "710": {
        "db_id": "world_1",
        "question": "Which region is the city Kabul located in?",
        "ground_truth": "SELECT Region FROM country AS T1 JOIN city AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Name  =  \"Kabul\"",
        "amends": [
            "Do join `country AS T1` and `city AS T2` instead of querying only `cities` table. Do use `LEFT JOIN` on `T1.Code = T2.CountryCode` instead of no join condition. Do select `Region` from the joined table instead of `region` from a single table. Do filter on `T2.Name = \"Kabul\"` instead of `city = 'Kabul'`. Do use proper table aliases and qualified column references instead of unqualified column names. The amended query now correctly retrieves the region by joining country and city tables with proper relationship mapping."
        ],
        "rules": [
            "When the question asks about a city's region: join table \"country\" as T1 and table \"city\" as T2 using LEFT JOIN on T1.Code = T2.CountryCode instead of querying a single table.",
            "When filtering for a specific city name: use T2.Name = \"Kabul\" with exact case and double quotes instead of city = 'Kabul'.",
            "When selecting the region information: use T1.Region from the joined country table instead of region from a cities table.",
            "When the question asks about a city's region, When filtering for a specific city name, When selecting the region information, When combining country and city tables: use the exact join condition T1.Code = T2.CountryCode to link countries with their cities."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT region FROM cities WHERE city = 'Kabul';",
            "SELECT T1.Region FROM country AS T1 LEFT JOIN city AS T2 ON T1.Code = T2.CountryCode WHERE T2.Name = 'Kabul'"
        ],
        "rule_sql": [
            "SELECT T1.Region FROM country AS T1 LEFT JOIN city AS T2 ON T1.Code = T2.CountryCode WHERE T2.Name = \"Kabul\""
        ]
    },
    "711": {
        "db_id": "world_1",
        "question": "What region is Kabul in?",
        "ground_truth": "SELECT Region FROM country AS T1 JOIN city AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Name  =  \"Kabul\"",
        "amends": [
            "Do select `Region` from table `country` instead of `region` from table `cities`. Do join table `city` with `country` using `ON T1.Code = T2.CountryCode` instead of querying only the `cities` table. Do filter on `T2.Name = \"Kabul\"` instead of `name = 'Kabul'`. Do use proper table aliases `T1` and `T2` instead of no aliases. The amended query now correctly retrieves the region from the country table by joining with the city table to find Kabul's corresponding country code."
        ],
        "rules": [
            "When the question asks about a city's region: retrieve the \"Region\" column from table \"country\" (T1) instead of from table \"cities\".",
            "When joining tables for city-country relationships: link table \"city\" (T2) with table \"country\" (T1) using the condition T1.Code = T2.CountryCode.",
            "When filtering for a specific city name: use the exact literal \"Kabul\" with the column T2.Name instead of 'Kabul' with name.",
            "When the question asks about a city's region, When joining tables for city-country relationships, When filtering for a specific city name, When using table aliases: assign T1 to table \"country\" and T2 to table \"city\" consistently throughout the query."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT region FROM cities WHERE name = 'Kabul';",
            "SELECT T1.Region FROM country T1 JOIN city T2 ON T1.Code = T2.CountryCode WHERE T2.Name = 'Kabul'"
        ],
        "rule_sql": [
            "SELECT T1.Region FROM country T1 JOIN city T2 ON T1.Code = T2.CountryCode WHERE T2.Name = 'Kabul';"
        ]
    },
    "712": {
        "db_id": "world_1",
        "question": "Which language is the most popular in Aruba?",
        "ground_truth": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Aruba\" ORDER BY Percentage DESC LIMIT 1",
        "amends": [
            "Do select `T2.Language` instead of `language, COUNT(*) as count`. Do join `country AS T1` and `countrylanguage AS T2` instead of querying only `languages`. Do use `ON T1.Code = T2.CountryCode` for the join condition instead of no explicit join. Do filter with `WHERE T1.Name = \"Aruba\"` instead of `WHERE country = 'Aruba'`. Do order by `Percentage DESC` instead of `count DESC`. Do remove the `GROUP BY` clause and aggregate function instead of keeping them. The amended query now correctly retrieves the language with the highest percentage for Aruba instead of counting language occurrences."
        ],
        "rules": [
            "When answering about \"most popular language in Aruba\": make sure the output order: T2.Language, T2.Percentage.",
            "When the question mentions \"Aruba\": \"Aruba\" actually means \"T1.Name = 'Aruba'\" in schema.",
            "When combining country AS T1 and countrylanguage AS T2: link rows where T1.Code = T2.CountryCode exactly as shown; keep only matching pairs (inner match).",
            "When the question asks for \"most popular\" language: rank rows by T2.Percentage in descending order and keep the first 1 row.",
            "When answering about \"most popular language in Aruba\", When the question mentions \"Aruba\", When combining country AS T1 and countrylanguage AS T2, When the question asks for \"most popular\" language, When handling text literals: do not change case, spacing, or punctuation - use exact value 'Aruba'."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language, COUNT(*) as count FROM languages WHERE country = 'Aruba' GROUP BY language ORDER BY count DESC LIMIT 1;",
            "SELECT T2.Language\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nWHERE T1.Name = 'Aruba'\nORDER BY T2.Percentage DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Language, T2.Percentage \nFROM country AS T1 \nINNER JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'Aruba' \nORDER BY T2.Percentage DESC \nLIMIT 1"
        ]
    },
    "713": {
        "db_id": "world_1",
        "question": "What language is predominantly spoken in Aruba?",
        "ground_truth": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Aruba\" ORDER BY Percentage DESC LIMIT 1",
        "amends": [
            "Do select `T2.Language` from the joined table instead of `language` from a single table. Do join `country AS T1` with `countrylanguage AS T2` on `T1.Code = T2.CountryCode` instead of querying only the `countries` table. Do add a filter on `T1.Name = \"Aruba\"` instead of `name = 'Aruba'` with proper table qualification. Do add `ORDER BY Percentage DESC` and `LIMIT 1` to get the highest percentage language instead of returning all matching records without ordering or limiting. The amended query now correctly retrieves the most spoken language in Aruba by joining the country and countrylanguage tables and selecting the top result by percentage."
        ],
        "rules": [
            "When answering about \"predominantly spoken language\": make sure the output order: T2.Language.",
            "When the question mentions \"Aruba\": \"Aruba\" actually means T1.Name = \"Aruba\" in schema.",
            "When combining T1 and T2 for shared entities: link rows where T1.Code = T2.CountryCode exactly as shown in the amends; keep only matching pairs (inner match).",
            "When answering about \"predominantly spoken language\", When the question mentions \"Aruba\", When combining T1 and T2 for shared entities, When the question mentions \"predominantly\" or asks for the most spoken language: rank rows by T2.Percentage in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT language FROM countries WHERE name = 'Aruba';",
            "SELECT T2.Language \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'Aruba' \nORDER BY T2.Percentage DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Language \nFROM country T1 \nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'Aruba' \nORDER BY T2.Percentage DESC \nLIMIT 1"
        ]
    },
    "714": {
        "db_id": "world_1",
        "question": "What are the population and life expectancies in Brazil?",
        "ground_truth": "SELECT Population ,  LifeExpectancy FROM country WHERE Name  =  \"Brazil\"",
        "amends": [
            "Do select `Population` and `LifeExpectancy` instead of `population` and `life_expectancy`. Do use table `country` instead of `countries`. Do filter on `Name = \"Brazil\"` instead of `name = 'Brazil'` with proper column name and quote style. The amended query now correctly retrieves population and life expectancy data for Brazil from the country table."
        ],
        "rules": [
            "When the question asks about population and life expectancy: select \"Population\" and \"LifeExpectancy\" columns from the country table.",
            "When filtering for Brazil: use the condition Name = \"Brazil\" with exact case and double quotes.",
            "When the question asks about population and life expectancy, When filtering for Brazil, When referring to the countries table: use the exact table name \"country\" instead of \"countries\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, population, life_expectancy FROM countries WHERE name = 'Brazil';",
            "SELECT Population, LifeExpectancy FROM country WHERE Name = \"Brazil\";"
        ],
        "rule_sql": [
            "SELECT Population, LifeExpectancy FROM country WHERE Name = \"Brazil\";"
        ]
    },
    "715": {
        "db_id": "world_1",
        "question": "Give me Brazil\u2019s population and life expectancies.",
        "ground_truth": "SELECT Population ,  LifeExpectancy FROM country WHERE Name  =  \"Brazil\"",
        "amends": [
            "Do select `Population` and `LifeExpectancy` instead of `population` and `life_expectancy`. Do use table `country` instead of `countries`. Do filter on `Name = \"Brazil\"` instead of `name = 'Brazil'`. Do omit the `name` column from the SELECT list instead of including it. The amended query now correctly retrieves population and life expectancy data for Brazil from the country table."
        ],
        "rules": [
            "When answering about \"Brazil's population and life expectancies\": make sure the output order: \"Population\", \"LifeExpectancy\".",
            "When the question mentions \"Brazil\": \"Brazil\" actually means \"Name = \\\"Brazil\\\"\" in schema.",
            "When selecting columns: use exact column tokens \"Population\" and \"LifeExpectancy\" instead of similar names.",
            "When referring to the table: use table \"country\" instead of similar table names.",
            "When answering about \"Brazil's population and life expectancies\", When the question mentions \"Brazil\", When selecting columns, When referring to the table, When filtering for specific country: omit the name column from output and only return the requested population and life expectancy data."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, population, life_expectancy FROM countries WHERE name = 'Brazil';",
            "SELECT Population, LifeExpectancy FROM country WHERE Name = \"Brazil\";"
        ],
        "rule_sql": [
            "SELECT Population, LifeExpectancy FROM country WHERE Name = \"Brazil\";"
        ]
    },
    "716": {
        "db_id": "world_1",
        "question": "What are the region and population of Angola?",
        "ground_truth": "SELECT Population ,  Region FROM country WHERE Name  =  \"Angola\"",
        "amends": [
            "Do use table name `country` instead of `countries` and column names `Name`, `Population`, and `Region` instead of `name`, `population`, and `region` to match the correct schema. Do use double quotes `\"Angola\"` instead of single quotes `'Angola'` for the string literal in the WHERE filter. The amended query now correctly retrieves the population and region data for Angola from the proper table structure.",
            "Do maintain the same column selection `Region, Population` instead of changing the order, but do reverse the column order in the SELECT list to `Population, Region` instead of `Region, Population`. Do keep the same table source `country` and identical WHERE filter `Name = \"Angola\"` instead of making any changes to these elements. The amended query now correctly matches the RIGHT_SQL's behavior with the specified column ordering."
        ],
        "rules": [
            "When the question asks about a country's region and population: use table \"country\" with columns \"Name\", \"Population\", and \"Region\"",
            "When filtering for a specific country name: use double quotes around the literal value exactly as shown (e.g., \"Angola\")",
            "When the question asks about a country's region and population, When filtering for a specific country name, When selecting output columns: maintain the order of \"Region\" followed by \"Population\" as specified in the question",
            "When answering about \"region and population of Angola\": make sure the output order: Population, Region instead of Region, Population.",
            "When the question mentions \"Angola\": \"Angola\" actually means \"Name = 'Angola'\" in the country table.",
            "When answering about \"region and population of Angola\", When the question mentions \"Angola\", When selecting from the country table: use the exact table name \"country\" without quotes as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region, population FROM countries WHERE name = 'Angola';",
            "SELECT Region, Population FROM country WHERE Name = \"Angola\";",
            "SELECT Population, Region FROM country WHERE Name = \"Angola\""
        ],
        "rule_sql": [
            "SELECT Region, Population FROM country WHERE Name = 'Angola';"
        ]
    },
    "717": {
        "db_id": "world_1",
        "question": "What region does Angola belong to and what is its population?",
        "ground_truth": "SELECT Population ,  Region FROM country WHERE Name  =  \"Angola\"",
        "amends": [
            "Do use table name `country` instead of `countries` and column names `Name`, `Population`, and `Region` instead of `name`, `population`, and `region` to match the correct schema. Do use double quotes `\"Angola\"` instead of single quotes `'Angola'` for the string literal in the WHERE filter. The amended query now correctly retrieves the population and region data for Angola from the proper table structure.",
            "Do reverse the column order to `Population, Region` instead of `Region, Population` while maintaining the same `WHERE Name = \"Angola\"` filter. The amended query now matches RIGHT_SQL's behavior by preserving all logical elements while adjusting the presentation order of columns in the SELECT list."
        ],
        "rules": [
            "When the question asks about a country's region and population: use table \"country\" with columns \"Name\", \"Population\", and \"Region\"",
            "When filtering for a specific country name: use exact string literal \"Angola\" with double quotes for the WHERE condition",
            "When the question asks about a country's region and population, When filtering for a specific country name, When selecting output columns: maintain the order of \"Region\" first then \"Population\" as implied by the question",
            "When the question asks about a country's region and population: make sure the output order is Population first, then Region.",
            "When filtering for a specific country name: use the exact literal \"Angola\" with double quotes and match case exactly.",
            "When the question asks about a country's region and population, When filtering for a specific country name, When selecting columns from the country table: use the exact column names Region and Population as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region, population FROM countries WHERE name = 'Angola';",
            "SELECT Region, Population FROM country WHERE Name = \"Angola\";",
            "SELECT Population, Region FROM country WHERE Name = \"Angola\";"
        ],
        "rule_sql": [
            "SELECT Region, Population FROM country WHERE Name = \"Angola\";"
        ]
    },
    "718": {
        "db_id": "world_1",
        "question": "What is the average expected life expectancy for countries in the region of Central Africa?",
        "ground_truth": "SELECT avg(LifeExpectancy) FROM country WHERE Region  =  \"Central Africa\"",
        "amends": [
            "Do use table name `country` instead of `countries` and column name `LifeExpectancy` instead of `life_expectancy` to match the correct schema. Do use the correct region filter value `\"Central Africa\"` instead of `'Central Africa'` while maintaining the same filtering logic. Do use lowercase `avg` function instead of `AVG` for the aggregate calculation, though this is purely cosmetic. The amended query now correctly calculates the average life expectancy for the Central Africa region using the proper table and column names."
        ],
        "rules": [
            "When answering about average life expectancy: use the exact column name \"LifeExpectancy\" from table \"country\" with the aggregate function avg.",
            "When filtering by region \"Central Africa\": use the exact literal value \"Central Africa\" with double quotes.",
            "When answering about average life expectancy, When filtering by region \"Central Africa\", When referring to the table containing life expectancy data: use the exact table name \"country\" instead of \"countries\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(life_expectancy) FROM countries WHERE region = 'Central Africa';",
            "SELECT avg(LifeExpectancy) FROM country WHERE Region = \"Central Africa\""
        ],
        "rule_sql": [
            "SELECT AVG(LifeExpectancy) FROM country WHERE Region = \"Central Africa\""
        ]
    },
    "719": {
        "db_id": "world_1",
        "question": "How long is the people\u2019s average life expectancy in Central Africa?",
        "ground_truth": "SELECT avg(LifeExpectancy) FROM country WHERE Region  =  \"Central Africa\"",
        "amends": [
            "Do reference the `LifeExpectancy` column instead of `life_expectancy`, use the `country` table instead of `countries`, and filter on `Region` instead of `region` while maintaining the same aggregate function and filter logic. The amended query now correctly references the schema elements and matches the intended behavior."
        ],
        "rules": [
            "When the question asks about \"life expectancy\": use the exact column name \"LifeExpectancy\" from the country table.",
            "When the question mentions \"Central Africa\": use the exact literal value 'Central Africa' with the exact column name \"Region\" from the country table.",
            "When the question asks for \"average life expectancy\": compute the average of the \"LifeExpectancy\" column values.",
            "When the question asks about \"life expectancy\", When the question mentions \"Central Africa\", When the question asks for \"average life expectancy\", When filtering by region: only include rows where the \"Region\" column equals exactly 'Central Africa'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(life_expectancy) FROM countries WHERE region = 'Central Africa';",
            "SELECT AVG(LifeExpectancy) FROM country WHERE Region = 'Central Africa';"
        ],
        "rule_sql": [
            "SELECT AVG(LifeExpectancy) FROM country WHERE Region = 'Central Africa'"
        ]
    },
    "720": {
        "db_id": "world_1",
        "question": "What is the name of country that has the shortest life expectancy in Asia?",
        "ground_truth": "SELECT Name FROM country WHERE Continent  =  \"Asia\" ORDER BY LifeExpectancy LIMIT 1",
        "amends": [
            "Do use `Name` instead of `name` for the column selection to match the correct case sensitivity. Do use `Continent` instead of `continent` for the WHERE filter column reference. Do use double quotes `\"Asia\"` instead of single quotes for the string literal. Do use `LifeExpectancy` instead of `lifeexpectancy` in the ORDER BY clause. Do remove the `DESC` modifier from the ORDER BY clause to sort in ascending order instead of descending order. The amended query now correctly selects the country with the lowest life expectancy in Asia rather than the highest."
        ],
        "rules": [
            "When the question asks for a country name: use the exact column token \"Name\" from table country (not \"name\").",
            "When filtering for countries in Asia: use the exact column token \"Continent\" and the exact literal value \"Asia\" with double quotes.",
            "When ordering by life expectancy to find the shortest: use the exact column token \"LifeExpectancy\" and sort in ascending order (lowest values first).",
            "When the question asks for a country name, When filtering for countries in Asia, When ordering by life expectancy to find the shortest, When finding the single country with the shortest life expectancy: take only the first row after ordering by LifeExpectancy in ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM country WHERE continent = 'Asia' ORDER BY lifeexpectancy DESC LIMIT 1;",
            "SELECT Name FROM country WHERE Continent = \"Asia\" ORDER BY LifeExpectancy ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Name FROM country WHERE Continent = \"Asia\" ORDER BY LifeExpectancy ASC LIMIT 1"
        ]
    },
    "721": {
        "db_id": "world_1",
        "question": "Give the name of the country in Asia with the lowest life expectancy.",
        "ground_truth": "SELECT Name FROM country WHERE Continent  =  \"Asia\" ORDER BY LifeExpectancy LIMIT 1",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the correct table name `country` instead of `countries`. Do use the correct column name `Continent` instead of `continent` and use double quotes around the string literal \"Asia\" instead of single quotes. Do order by `LifeExpectancy` in ascending order (default) instead of descending order with `DESC`, and use the correct column name `LifeExpectancy` instead of `life_expectancy`. The amended query now correctly retrieves the country with the lowest life expectancy in Asia, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for country names: use the exact column \"Name\" from table \"country\" (not \"name\" from other tables).",
            "When filtering for countries in Asia: use the exact column \"Continent\" with the exact string literal \"Asia\" (with double quotes).",
            "When finding the lowest life expectancy: order by \"LifeExpectancy\" in ascending order (default) to get the minimum value.",
            "When the question asks for country names, When filtering for countries in Asia, When finding the lowest life expectancy, When retrieving a single result: take only the first row after ordering to get the country with the lowest life expectancy."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM countries WHERE continent = 'Asia' ORDER BY life_expectancy DESC LIMIT 1;",
            "SELECT Name FROM country WHERE Continent = \"Asia\" ORDER BY LifeExpectancy ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name FROM country WHERE Continent = \"Asia\" ORDER BY LifeExpectancy ASC LIMIT 1"
        ]
    },
    "722": {
        "db_id": "world_1",
        "question": "What is the total population and maximum GNP in Asia?",
        "ground_truth": "SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  \"Asia\"",
        "amends": [
            "Do use table name `country` instead of `countries` in the FROM clause. Do remove the column aliases `TotalPopulation` and `MaxGNP` instead of keeping them. Do use lowercase function names `sum` and `max` instead of uppercase `SUM` and `MAX`. Do use double quotes `\"Asia\"` instead of single quotes `'Asia'` for the string literal in the WHERE filter. The amended query now correctly references the proper table and uses consistent function casing while maintaining the same aggregation logic and filtering behavior."
        ],
        "rules": [
            "When the question asks about countries: use the exact table name \"country\" instead of \"countries\".",
            "When computing aggregates like total population and maximum GNP: use lowercase function names \"sum\" and \"max\" instead of uppercase versions.",
            "When filtering for the continent Asia: use double quotes \"Asia\" instead of single quotes for the string literal.",
            "When the question asks about countries, When computing aggregates like total population and maximum GNP, When filtering for the continent Asia, When producing output columns: do not use column aliases like \"TotalPopulation\" and \"MaxGNP\" - return the raw aggregate expressions directly."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(Population) AS TotalPopulation, MAX(GNP) AS MaxGNP FROM countries WHERE Continent = 'Asia';",
            "SELECT sum(Population), max(GNP) FROM country WHERE Continent = \"Asia\""
        ],
        "rule_sql": [
            "SELECT sum(Population), max(GNP) FROM country WHERE Continent = \"Asia\""
        ]
    },
    "723": {
        "db_id": "world_1",
        "question": "How many people live in Asia, and what is the largest GNP among them?",
        "ground_truth": "SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  \"Asia\"",
        "amends": [
            "Do use `sum(Population)` instead of `COUNT(*)` to calculate total population instead of counting rows. Do reference `Continent` instead of `continent` for case-sensitive column name matching. Do use double quotes `\"Asia\"` instead of single quotes `'Asia'` for string literal syntax. Do remove the `AS population` and `AS largest_gnp` aliases instead of keeping them. The amended query now correctly sums population values and matches the right SQL's behavior."
        ],
        "rules": [
            "When calculating total population: use sum(Population) instead of counting rows with COUNT(*).",
            "When referencing the continent column: use exact case-sensitive identifier \"Continent\" instead of \"continent\".",
            "When using string literals for continent values: use double quotes \"Asia\" instead of single quotes 'Asia'.",
            "When calculating total population, When referencing the continent column, When using string literals for continent values, When producing output columns: do not include AS aliases like \"AS population\" or \"AS largest_gnp\" in the final result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS population, MAX(GNP) AS largest_gnp FROM country WHERE continent = 'Asia';",
            "SELECT SUM(country.Population), MAX(country.GNP) FROM country WHERE country.Continent = \"Asia\""
        ],
        "rule_sql": [
            "SELECT SUM(country.Population), MAX(country.GNP) FROM country WHERE country.Continent = \"Asia\";"
        ]
    },
    "724": {
        "db_id": "world_1",
        "question": "What is the average life expectancy in African countries that are republics?",
        "ground_truth": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  \"Africa\" AND GovernmentForm  =  \"Republic\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(LifeExpectancy) FROM country WHERE Continent = 'Africa' AND GovernmentForm = 'Republic';"
        ],
        "rule_sql": [
            "SELECT AVG(LifeExpectancy) AS AverageLifeExpectancy FROM country WHERE Continent = 'Africa' AND GovernmentForm LIKE '%Republic%'",
            "SELECT AVG(LifeExpectancy) FROM country WHERE Continent = 'Africa' AND GovernmentForm = 'Republic';"
        ]
    },
    "725": {
        "db_id": "world_1",
        "question": "Give the average life expectancy for countries in Africa which are republics?",
        "ground_truth": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  \"Africa\" AND GovernmentForm  =  \"Republic\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(lifeexpectancy) FROM country WHERE continent = 'Africa' AND governmentform = 'Republic';"
        ],
        "rule_sql": [
            "SELECT AVG(LifeExpectancy) AS AverageLifeExpectancy FROM country WHERE Continent = 'Africa' AND GovernmentForm LIKE '%Republic%';",
            "SELECT AVG(LifeExpectancy) FROM country WHERE Continent = 'Africa' AND GovernmentForm LIKE '%Republic%'"
        ]
    },
    "726": {
        "db_id": "world_1",
        "question": "What is the total surface area of the continents Asia and Europe?",
        "ground_truth": "SELECT sum(SurfaceArea) FROM country WHERE Continent  =  \"Asia\" OR Continent  =  \"Europe\"",
        "amends": [
            "Do reference the `SurfaceArea` column instead of `surface_area` and use the `sum` aggregate function instead of `SUM`. Do query from the `country` table instead of the `continents` table. Do filter on the `Continent` column with values \"Asia\" and \"Europe\" instead of filtering on the `name` column. The amended query now correctly calculates the total surface area for Asian and European countries as specified in the target query."
        ],
        "rules": [
            "When answering about total surface area of continents: use the \"SurfaceArea\" column from the \"country\" table with the sum aggregate function.",
            "When the question mentions \"continents Asia and Europe\": filter on the \"Continent\" column with exact values \"Asia\" and \"Europe\".",
            "When answering about total surface area of continents, When the question mentions \"continents Asia and Europe\", When combining data from the country table: ensure you are querying from the \"country\" table, not the \"continents\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(surface_area) FROM continents WHERE name = 'Asia' OR name = 'Europe';",
            "SELECT sum(SurfaceArea) FROM country WHERE Continent IN ('Asia', 'Europe')"
        ],
        "rule_sql": [
            "SELECT SUM(SurfaceArea) AS TotalSurfaceArea FROM country WHERE Continent IN ('Asia', 'Europe')"
        ]
    },
    "727": {
        "db_id": "world_1",
        "question": "Give the total surface area covered by countries in Asia or Europe.",
        "ground_truth": "SELECT sum(SurfaceArea) FROM country WHERE Continent  =  \"Asia\" OR Continent  =  \"Europe\"",
        "amends": [
            "Do reference the `SurfaceArea` column instead of `surface_area` to match the correct column name. Do reference the `Continent` column instead of `continent` to match the correct column name. Do reference the `country` table instead of `countries` to match the correct table name. Do use double quotes around string literals \"Asia\" and \"Europe\" instead of single quotes to match the correct string formatting. The amended query now correctly calculates the sum of surface areas for Asian and European countries from the proper table with accurate column references and string formatting."
        ],
        "rules": [
            "When the question asks about surface area: use the exact column name \"SurfaceArea\" from the country table.",
            "When the question mentions continents: use the exact column name \"Continent\" from the country table.",
            "When the question refers to countries: use the exact table name \"country\" instead of \"countries\".",
            "When filtering for specific continents \"Asia\" or \"Europe\": use double quotes around the literal values \"Asia\" and \"Europe\" exactly as shown.",
            "When the question asks about surface area, When the question mentions continents, When the question refers to countries, When filtering for specific continents \"Asia\" or \"Europe\", When calculating total surface area for multiple continents: sum the \"SurfaceArea\" values where \"Continent\" equals either \"Asia\" or \"Europe\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(surface_area) FROM countries WHERE continent = 'Asia' OR continent = 'Europe';",
            "SELECT SUM(SurfaceArea) FROM country WHERE Continent = \"Asia\" OR Continent = \"Europe\";"
        ],
        "rule_sql": [
            "SELECT SUM(SurfaceArea) FROM country WHERE Continent = \"Asia\" OR Continent = \"Europe\";"
        ]
    },
    "728": {
        "db_id": "world_1",
        "question": "How many people live in Gelderland district?",
        "ground_truth": "SELECT sum(Population) FROM city WHERE District  =  \"Gelderland\"",
        "amends": [
            "Do use `sum(Population)` instead of `COUNT(*)` to aggregate population values rather than counting rows. Do reference table `city` instead of `people` as the data source. Do use double quotes `\"Gelderland\"` instead of single quotes for the district filter value. The amended query now correctly calculates the total population in the Gelderland district rather than counting records."
        ],
        "rules": [
            "When answering about population count: use sum(\"Population\") instead of COUNT(*) to aggregate population values.",
            "When the question mentions \"people\": the data actually comes from table \"city\" instead of \"people\".",
            "When answering about population count, When the question mentions \"people\", When filtering for district values: use double quotes \"Gelderland\" instead of single quotes for the exact literal value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM people WHERE district = 'Gelderland';",
            "SELECT SUM(Population) FROM city WHERE District = \"Gelderland\";"
        ],
        "rule_sql": [
            "SELECT SUM(\"Population\") FROM city WHERE District = \"Gelderland\";"
        ]
    },
    "729": {
        "db_id": "world_1",
        "question": "What is the total population of Gelderland district?",
        "ground_truth": "SELECT sum(Population) FROM city WHERE District  =  \"Gelderland\"",
        "amends": [
            "Do query the `city` table instead of the `districts` table. Do use the `District` column filter instead of the `name` column filter. Do use the exact string value \"Gelderland\" instead of 'Gelderland'. Do use lowercase `sum` function instead of uppercase `SUM`. The amended query now correctly aggregates population data from cities within the Gelderland district rather than incorrectly attempting to sum population from a districts table."
        ],
        "rules": [
            "When answering about \"total population of Gelderland district\": query the \"city\" table instead of the \"districts\" table.",
            "When filtering for Gelderland district: use the \"District\" column filter instead of the \"name\" column filter.",
            "When specifying the literal value for Gelderland: use the exact string value \"Gelderland\" instead of 'Gelderland'.",
            "When answering about \"total population of Gelderland district\", When filtering for Gelderland district, When specifying the literal value for Gelderland, When performing aggregation: use lowercase \"sum\" function instead of uppercase \"SUM\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(population) FROM districts WHERE name = 'Gelderland';",
            "SELECT sum(Population) FROM city WHERE District = 'Gelderland'"
        ],
        "rule_sql": [
            "SELECT sum(Population) FROM city WHERE District = \"Gelderland\""
        ]
    },
    "730": {
        "db_id": "world_1",
        "question": "What is the average GNP and total population in all nations whose government is US territory?",
        "ground_truth": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  \"US Territory\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(GNP), SUM(Population) FROM country WHERE GovernmentForm = 'US Territory';"
        ],
        "rule_sql": [
            "SELECT AVG(GNP) as AverageGNP, SUM(Population) as TotalPopulation FROM country WHERE GovernmentForm = 'US Territory';"
        ]
    },
    "731": {
        "db_id": "world_1",
        "question": "Give the mean GNP and total population of nations which are considered US territory.",
        "ground_truth": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  \"US Territory\"",
        "amends": [
            "Do reference `GovernmentForm` in the WHERE filter instead of `Region`. Do use double quotes around the string literal \"US Territory\" instead of single quotes. The amended query now correctly filters by government form rather than region and matches the intended behavior."
        ],
        "rules": [
            "When the question mentions \"US territory\": \"US territory\" actually means \"GovernmentForm\" in schema with exact literal value \"US Territory\"",
            "When filtering for nations considered US territory: use condition where \"GovernmentForm\" equals \"US Territory\" exactly as specified",
            "When the question mentions \"US territory\", When filtering for nations considered US territory, When computing mean GNP and total population: calculate average of GNP and sum of Population for the filtered nations"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(GNP), SUM(Population) FROM country WHERE Region = 'US Territory';",
            "SELECT AVG(GNP) AS mean_gnp, SUM(Population) AS total_population FROM country WHERE GovernmentForm = \"US Territory\";"
        ],
        "rule_sql": [
            "SELECT AVG(GNP) AS mean_gnp, SUM(Population) AS total_population FROM country WHERE GovernmentForm = 'US Territory';"
        ]
    },
    "732": {
        "db_id": "world_1",
        "question": "How many unique languages are spoken in the world?",
        "ground_truth": "SELECT count(DISTINCT LANGUAGE) FROM countrylanguage",
        "amends": [
            "Do select `count(DISTINCT LANGUAGE)` instead of `COUNT(*)`. Do query from `countrylanguage` table instead of `languages` table. The amended query now correctly counts distinct languages from the appropriate table, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"unique languages spoken in the world\": count distinct values of the LANGUAGE column.",
            "When the question mentions \"languages\": use the \"countrylanguage\" table instead of \"languages\" table.",
            "When answering about \"unique languages spoken in the world\", When the question mentions \"languages\", When counting distinct languages: use the exact column token \"LANGUAGE\" from the countrylanguage table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM languages;",
            "SELECT COUNT(DISTINCT Language) FROM countrylanguage;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Language) FROM countrylanguage;"
        ]
    },
    "733": {
        "db_id": "world_1",
        "question": "What is the number of distinct languages used around the world?",
        "ground_truth": "SELECT count(DISTINCT LANGUAGE) FROM countrylanguage",
        "amends": [
            "Do select `count(DISTINCT LANGUAGE)` instead of `COUNT(*)`. Do query from `countrylanguage` table instead of `languages` table. The amended query now correctly counts distinct languages from the appropriate table, matching the intended behavior."
        ],
        "rules": [
            "When counting distinct languages: use the exact column token \"LANGUAGE\" from the countrylanguage table.",
            "When the question asks for \"distinct languages\": compute the number of unique values in the \"LANGUAGE\" column.",
            "When counting distinct languages, When the question asks for \"distinct languages\", When querying language data: use the \"countrylanguage\" table instead of any other table name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM languages;",
            "SELECT COUNT(DISTINCT Language) FROM countrylanguage;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Language) FROM countrylanguage;"
        ]
    },
    "734": {
        "db_id": "world_1",
        "question": "How many type of governments are in Africa?",
        "ground_truth": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  \"Africa\"",
        "amends": [
            "Do use `count(DISTINCT GovernmentForm)` instead of `COUNT(*)` to count distinct government forms rather than all rows. Do reference table `country` instead of `countries` as the correct table name. Do use column `Continent` instead of `continent` with proper capitalization. Do use double quotes `\"Africa\"` instead of single quotes `'Africa'` for the continent filter value. The amended query now correctly counts distinct government forms in African countries rather than counting all rows, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for \"type of governments\": use \"GovernmentForm\" column to count distinct government forms rather than counting all rows.",
            "When referencing the table containing country data: use table name \"country\" instead of \"countries\".",
            "When filtering by continent: use column \"Continent\" with exact capitalization.",
            "When filtering for African countries: use literal value \"Africa\" with double quotes exactly as specified.",
            "When the question asks for \"type of governments\", When referencing the table containing country data, When filtering by continent, When filtering for African countries, When counting distinct government forms: use count(DISTINCT GovernmentForm) to count unique government types rather than total rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE continent = 'Africa';",
            "SELECT COUNT(DISTINCT GovernmentForm) FROM country WHERE Continent = \"Africa\";"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT GovernmentForm) FROM country WHERE Continent = 'Africa';"
        ]
    },
    "735": {
        "db_id": "world_1",
        "question": "How many different forms of governments are there in Africa?",
        "ground_truth": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  \"Africa\"",
        "amends": [
            "Do use `count(DISTINCT GovernmentForm)` instead of `COUNT(*)` to count distinct government forms rather than all rows. Do reference table `country` instead of `countries` as the correct table name. Do use column `Continent` instead of `continent` with proper capitalization. Do use double quotes `\"Africa\"` instead of single quotes for the string literal. Do remove the unnecessary aggregation of all rows and instead count distinct government forms specifically for African countries."
        ],
        "rules": [
            "When answering about \"different forms of governments in Africa\": count distinct values of \"GovernmentForm\" instead of counting all rows.",
            "When the question mentions \"Africa\": use the exact literal \"Africa\" with double quotes for comparison.",
            "When referring to the table containing country data: use table name \"country\" instead of \"countries\".",
            "When accessing the continent column: use exact column name \"Continent\" with proper capitalization.",
            "When answering about \"different forms of governments in Africa\", When the question mentions \"Africa\", When referring to the table containing country data, When accessing the continent column, When counting distinct government forms: apply the count to \"GovernmentForm\" column specifically for rows where \"Continent\" equals \"Africa\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE continent = 'Africa';",
            "SELECT COUNT(DISTINCT GovernmentForm) FROM country WHERE Continent = \"Africa\";"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT GovernmentForm) FROM country WHERE Continent = 'Africa';"
        ]
    },
    "736": {
        "db_id": "world_1",
        "question": "What is the total number of languages used in Aruba?",
        "ground_truth": "SELECT COUNT(T2.Language) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Aruba\"",
        "amends": [
            "Do join `country AS T1` and `countrylanguage AS T2` instead of querying only `languages` table. Do use `ON T1.Code = T2.CountryCode` for the join condition instead of no join. Do filter on `T1.Name = \"Aruba\"` instead of `country = 'Aruba'`. Do select `COUNT(T2.Language)` instead of `COUNT(*)` to count specific language records. Do use proper table aliases and qualified column references instead of unqualified column names. The amended query now correctly counts languages by joining country and countrylanguage tables with proper relationship mapping."
        ],
        "rules": [
            "When answering about \"total number of languages used in Aruba\": make sure the output order: COUNT(T2.Language)",
            "When the question mentions \"Aruba\": \"Aruba\" actually means \"T1.Name = 'Aruba'\" in schema",
            "When combining T1 and T2 for shared entities: link rows where T1.Code = T2.CountryCode exactly as shown in the amends; keep only matching pairs (inner match)",
            "When answering about \"total number of languages used in Aruba\", When the question mentions \"Aruba\", When combining T1 and T2 for shared entities, When the question asks for \"count of languages\": compute the number of rows using T2.Language as the counting key"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM languages WHERE country = 'Aruba';",
            "SELECT COUNT(T2.Language) \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'Aruba'"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.Language) \nFROM country T1 \nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'Aruba'"
        ]
    },
    "737": {
        "db_id": "world_1",
        "question": "How many languages are spoken in Aruba?",
        "ground_truth": "SELECT COUNT(T2.Language) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Aruba\"",
        "amends": [
            "Do join `country AS T1` and `countrylanguage AS T2` instead of querying only `languages` table. Do use `ON T1.Code = T2.CountryCode` for the join condition instead of no join. Do filter on `T1.Name = \"Aruba\"` instead of `country = 'Aruba'`. Do count `T2.Language` instead of `COUNT(*)`. The amended query now correctly counts languages by joining country and countrylanguage tables and filtering by country name instead of a non-existent country column."
        ],
        "rules": [
            "When answering about \"languages spoken in Aruba\": make sure the output order: count of languages",
            "When the question mentions \"Aruba\": \"Aruba\" actually means \"T1.Name = 'Aruba'\" in schema",
            "When combining T1 and T2 for shared entities: link rows where T1.Code = T2.CountryCode exactly as shown in the amends; keep only matching pairs (inner match)",
            "When answering about \"languages spoken in Aruba\", When the question mentions \"Aruba\", When combining T1 and T2 for shared entities, When the question asks for \"count of languages\": compute the number of unique values of T2.Language using the exact token from the amends"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM languages WHERE country = 'Aruba';",
            "SELECT COUNT(T2.Language) \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'Aruba'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T2.Language) \nFROM country T1 \nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'Aruba'"
        ]
    },
    "738": {
        "db_id": "world_1",
        "question": "How many official languages does Afghanistan have?",
        "ground_truth": "SELECT COUNT(*) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Afghanistan\" AND IsOfficial  =  \"T\"",
        "amends": [
            "Do join `country AS T1` and `countrylanguage AS T2` on `T1.Code = T2.CountryCode` instead of querying only the `languages` table. Do filter on `T1.Name = \"Afghanistan\"` instead of `country = 'Afghanistan'` and use `IsOfficial = \"T\"` instead of `status = 'official'`. Do remove the incorrect table reference and add the proper join condition to establish the relationship between country and language data. The amended query now correctly counts official languages for Afghanistan by joining the appropriate tables with proper key relationships."
        ],
        "rules": [
            "When answering about \"How many official languages does Afghanistan have?\": make sure the output order: count of official languages for Afghanistan.",
            "When the question mentions \"Afghanistan\": \"Afghanistan\" actually means \"T1.Name = 'Afghanistan'\" in schema.",
            "When the question mentions \"official languages\": \"official languages\" actually means \"T2.IsOfficial = 'T'\" in schema.",
            "When combining T1 and T2 for shared entities: link rows where T1.Code = T2.CountryCode exactly as shown in the amends; keep only matching pairs (inner match).",
            "When answering about \"How many official languages does Afghanistan have?\", When the question mentions \"Afghanistan\", When the question mentions \"official languages\", When combining T1 and T2 for shared entities, When the question asks for \"count of official languages\": compute the number of rows using the canonical key relationship established by T1.Code = T2.CountryCode where T1.Name = 'Afghanistan' and T2.IsOfficial = 'T'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM languages WHERE country = 'Afghanistan' AND status = 'official';",
            "SELECT COUNT(*) \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'Afghanistan' AND T2.IsOfficial = 'T'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T1.Name = 'Afghanistan' AND T2.IsOfficial = 'T'"
        ]
    },
    "739": {
        "db_id": "world_1",
        "question": "How many official languages are spoken in Afghanistan?",
        "ground_truth": "SELECT COUNT(*) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Afghanistan\" AND IsOfficial  =  \"T\"",
        "amends": [
            "Do join `country` and `countrylanguage` tables with `INNER JOIN` on `T1.Code = T2.CountryCode` instead of querying only the `languages` table. Do filter on `T1.Name = \"Afghanistan\"` and `IsOfficial = \"T\"` instead of filtering only on `country = 'Afghanistan'`. Do use table aliases `T1` and `T2` instead of no aliases. The amended query now correctly counts official languages for Afghanistan by properly joining the country and language tables with appropriate filtering conditions."
        ],
        "rules": [
            "When answering about \"official languages in Afghanistan\": make sure the output order: count of official languages.",
            "When the question mentions \"Afghanistan\": \"Afghanistan\" actually means \"T1.Name\" in schema.",
            "When the question mentions \"official languages\": \"official languages\" actually means \"T2.IsOfficial = 'T'\" in schema.",
            "When combining T1 and T2 for shared entities: link rows where T1.Code = T2.CountryCode exactly as shown in the amends; keep only matching pairs (inner match).",
            "When answering about \"official languages in Afghanistan\", When the question mentions \"Afghanistan\", When the question mentions \"official languages\", When combining T1 and T2 for shared entities, When the question asks for \"count of official languages\": compute the number of rows using the canonical key token for languages (e.g., T2.CountryCode and T2.Language)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM languages WHERE country = 'Afghanistan';",
            "SELECT COUNT(*) \nFROM country T1 \nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'Afghanistan' AND T2.IsOfficial = 'T'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM country T1 \nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'Afghanistan' AND T2.IsOfficial = 'T'"
        ]
    },
    "740": {
        "db_id": "world_1",
        "question": "What is name of the country that speaks the largest number of languages?",
        "ground_truth": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.Name` instead of `country.name` and use table aliases `T1` and `T2` instead of full table names. Do join on `T1.Code = T2.CountryCode` instead of `country.code = countrylanguage.countrycode` with proper table alias references. Do group by `T1.Name` instead of `country.code` to match the selected column. Do order by `COUNT(*) DESC` instead of `COUNT(countrylanguage.language) ASC` to get the highest count rather than the lowest. The amended query now correctly identifies the country with the most languages by counting all language records and sorting in descending order, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"name of the country that speaks the largest number of languages\": make sure the output order: T1.Name",
            "When combining T1 (country) and T2 (countrylanguage) for shared entities: link rows where T1.Code = T2.CountryCode and keep only matching pairs (inner match)",
            "When the question asks for \"largest number of languages\": rank rows by COUNT(*) in descending direction and keep the first 1 row",
            "When the question says \"by country\": organize results by T1.Name and compute requested aggregates per group",
            "When answering about \"name of the country that speaks the largest number of languages\", When combining T1 (country) and T2 (countrylanguage) for shared entities, When the question asks for \"largest number of languages\", When the question says \"by country\", When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country.name \nFROM country \nJOIN countrylanguage ON country.code = countrylanguage.countrycode \nGROUP BY country.code \nORDER BY COUNT(countrylanguage.language) ASC \nLIMIT 1;",
            "SELECT T1.Name\nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Name\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Name\nFROM country T1\nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Name\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "741": {
        "db_id": "world_1",
        "question": "Give the name of the nation that uses the greatest amount of languages.",
        "ground_truth": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do use `T1.Name` in the SELECT list instead of `n.name` and group by `T1.Name` instead of `n.nation_id`. Do join `country AS T1` and `countrylanguage AS T2` instead of `nation` and `language` tables. Do use the join condition `T1.Code = T2.CountryCode` instead of `n.nation_id = l.nation_id`. Do order by `COUNT(*)` instead of `COUNT(l.language_id)` while maintaining the same DESC ordering and LIMIT 1. The amended query now correctly counts languages per country and returns the country with the most languages, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"the nation that uses the greatest amount of languages\": make sure the output order: T1.Name",
            "When the question mentions \"nation\": \"nation\" actually means \"country AS T1\" in schema",
            "When combining T1 and T2 for shared entities: link rows where T1.Code = T2.CountryCode exactly as shown; keep only matching pairs (inner match)",
            "When the question asks for \"count of languages\": compute the number of rows using COUNT(*) per country group",
            "When the question mentions \"greatest amount\" or \"most\": rank rows by COUNT(*) in descending order and keep the first 1 row",
            "When answering about \"the nation that uses the greatest amount of languages\", When the question mentions \"nation\", When combining T1 and T2 for shared entities, When the question asks for \"count of languages\", When the question mentions \"greatest amount\" or \"most\", When grouping by country: organize results by T1.Name and compute requested aggregates per group"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT n.name \nFROM nation n \nJOIN language l ON n.nation_id = l.nation_id \nGROUP BY n.nation_id \nORDER BY COUNT(l.language_id) DESC \nLIMIT 1;",
            "SELECT T1.Name\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Name\nFROM country AS T1\nINNER JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Name\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "742": {
        "db_id": "world_1",
        "question": "Which continent has the most diverse languages?",
        "ground_truth": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do use `T1.Continent` instead of `continent` and reference the `country` table instead of `countries`. Do add a `JOIN` with `countrylanguage AS T2` on `T1.Code = T2.CountryCode` instead of querying a single table. Do count all rows with `COUNT(*)` instead of counting `language` specifically. Do order by `COUNT(*) DESC` instead of `language_count DESC` while keeping the same `LIMIT 1` logic. The amended query now correctly identifies the continent with the most languages by joining the country and countrylanguage tables and counting all language records per continent.",
            "Do remove `COUNT(*) as language_count` from the SELECT list instead of including it, as the RIGHT_SQL only needs to return the continent with the highest language count rather than both the continent and the count value. The amended query now correctly returns just the continent name while maintaining the same grouping, ordering, and limit logic to identify the continent with the most languages, matching RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"continent with the most diverse languages\": use T1.Continent for continent information and join with countrylanguage as T2 on T1.Code = T2.CountryCode.",
            "When counting languages per continent: count all rows using COUNT(*) instead of counting specific language column.",
            "When ordering results to find the continent with most languages: order by the count in descending order and keep only the top result with LIMIT 1.",
            "When combining country and countrylanguage tables: link rows where T1.Code equals T2.CountryCode and keep only matching pairs (inner match).",
            "When answering about \"continent with the most diverse languages\", When counting languages per continent, When ordering results to find the continent with most languages, When combining country and countrylanguage tables, When grouping results: organize by T1.Continent to compute aggregates per continent.",
            "When answering about \"which continent has the most diverse languages\": make sure the output order: only return the continent name without the count value.",
            "When the question asks for the continent with the most languages: rank continents by language count in descending order and keep the first 1 row.",
            "When counting languages per continent: compute the number of rows using the canonical key for languages (T2.CountryCode + T2.Language) or count distinct language names if specified in schema.",
            "When combining country and countrylanguage tables: link rows where T1.Code = T2.CountryCode and keep only matching pairs (inner match).",
            "When answering about \"which continent has the most diverse languages\", When the question asks for the continent with the most languages, When counting languages per continent, When combining country and countrylanguage tables, When grouping by continent: organize results by T1.Continent and compute language count per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT continent, COUNT(language) as language_count FROM countries GROUP BY continent ORDER BY language_count DESC LIMIT 1;",
            "SELECT T1.Continent, COUNT(*) as language_count\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Continent\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT T1.Continent\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Continent\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Continent\nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Continent\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "743": {
        "db_id": "world_1",
        "question": "Which continent speaks the most languages?",
        "ground_truth": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do reference the `country` table as `T1` and `countrylanguage` as `T2` instead of using `country_languages`. Do join `T1.Code = T2.CountryCode` instead of grouping by `continent` directly. Do select `T1.Continent` instead of both `continent` and `language_count`. Do use `COUNT(*)` in the ORDER BY instead of the aliased `language_count`. Do remove the explicit column alias `language_count` instead of keeping it. The amended query now correctly joins the country and countrylanguage tables to count languages per continent and returns the continent with the highest count, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"which continent speaks the most languages\": make sure the output order: T1.Continent.",
            "When combining T1 (country) and T2 (countrylanguage) for shared entities: link rows where T1.Code = T2.CountryCode exactly as shown; keep only matching pairs (inner match).",
            "When the question asks for \"count of languages per continent\": compute the number of rows using COUNT(*) and organize results by T1.Continent.",
            "When the question mentions \"most languages\": rank rows by COUNT(*) in descending direction and keep the first 1 row.",
            "When answering about \"which continent speaks the most languages\", When combining T1 (country) and T2 (countrylanguage) for shared entities, When the question asks for \"count of languages per continent\", When the question mentions \"most languages\", When producing output: do not include explicit column aliases like language_count; only include T1.Continent."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT continent, COUNT(language) as language_count FROM country_languages GROUP BY continent ORDER BY language_count DESC LIMIT 1;",
            "SELECT T1.Continent\nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Continent\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Continent\nFROM country T1\nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Continent\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "744": {
        "db_id": "world_1",
        "question": "How many countries speak both English and Dutch?",
        "ground_truth": "SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"Dutch\")",
        "amends": [
            "Do use `INTERSECT` to find countries with both languages instead of counting cross-joined language pairs. Do reference `country` and `countrylanguage` tables instead of `countries` and `languages`. Do join on `Code` and `CountryCode` instead of `country_id` to `country_id`. Do filter for \"English\" and \"Dutch\" in separate subqueries instead of joining the same table twice with both conditions. Do select `Name` from the subqueries instead of counting all matches. Do remove the double join structure and WHERE clause combining both language conditions, instead using set intersection logic to correctly identify countries that have both languages specified."
        ],
        "rules": [
            "When the question asks for countries speaking both English and Dutch: use set intersection logic with separate subqueries instead of double joins to find countries that have both languages.",
            "When referencing tables: use \"country\" as T1 and \"countrylanguage\" as T2 instead of \"countries\" and \"languages\".",
            "When joining tables: link rows where T1.\"Code\" equals T2.\"CountryCode\" instead of country_id to country_id.",
            "When filtering for languages: create separate subqueries for \"English\" and \"Dutch\" language conditions instead of combining both in WHERE clause.",
            "When selecting country identifiers: use T1.\"Name\" from the subqueries instead of counting all matches.",
            "When the question asks for countries speaking both English and Dutch, When referencing tables, When joining tables, When filtering for languages, When selecting country identifiers, When counting countries that speak both languages: use INTERSECT operation between the two language-specific subqueries to correctly identify countries with both languages specified."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM countries c\nJOIN languages l1 ON c.country_id = l1.country_id\nJOIN languages l2 ON c.country_id = l2.country_id\nWHERE l1.language = 'English' AND l2.language = 'Dutch';",
            "SELECT COUNT(*) \nFROM (\n    SELECT CountryCode \n    FROM countrylanguage \n    WHERE Language = 'English'\n    INTERSECT\n    SELECT CountryCode \n    FROM countrylanguage \n    WHERE Language = 'Dutch'\n) AS countries_with_both_languages"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM (\n    SELECT T1.Name \n    FROM country T1 \n    JOIN countrylanguage T2 ON T1.Code = T2.CountryCode \n    WHERE T2.Language = 'English'\n    INTERSECT\n    SELECT T1.Name \n    FROM country T1 \n    JOIN countrylanguage T2 ON T1.Code = T2.CountryCode \n    WHERE T2.Language = 'Dutch'\n)"
        ]
    },
    "745": {
        "db_id": "world_1",
        "question": "What is the number of nations that use English and Dutch?",
        "ground_truth": "SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"Dutch\")",
        "amends": [
            "Do use a subquery with `INTERSECT` to find countries that speak both English and Dutch instead of a single `WHERE` clause with conflicting `language = 'English' AND language = 'Dutch'` conditions. Do join `country` and `countrylanguage` tables on `Code = CountryCode` instead of querying only the `nations` table. Do filter for English in one branch and Dutch in another branch with separate queries instead of trying to match both languages simultaneously in one condition. Do select `Name` from the `country` table instead of counting directly from an unspecified source. Do use proper table aliases `T1` and `T2` instead of unspecified table references. The amended query now correctly identifies countries where both languages are spoken by intersecting two separate queries for each language."
        ],
        "rules": [
            "When the question asks for nations that use both English and Dutch: use an intersection approach with separate queries for each language instead of a single condition with conflicting language requirements.",
            "When combining country and countrylanguage tables: link rows where T1.Code = T2.CountryCode to connect countries with their languages.",
            "When filtering for English language: use the exact literal 'English' in the condition for one branch of the intersection.",
            "When filtering for Dutch language: use the exact literal 'Dutch' in the condition for the other branch of the intersection.",
            "When selecting country names: use T1.Name from the country table as the identifier for nations.",
            "When the question asks for nations that use both English and Dutch, When combining country and countrylanguage tables, When filtering for English language, When filtering for Dutch language, When selecting country names, When counting distinct nations: count the number of unique T1.Name values that appear in both language groups after the intersection operation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM nations WHERE language = 'English' AND language = 'Dutch';",
            "SELECT COUNT(*) \nFROM (\n    SELECT c.Name \n    FROM country c \n    JOIN countrylanguage cl1 ON c.Code = cl1.CountryCode \n    WHERE cl1.Language = 'English'\n    INTERSECT\n    SELECT c.Name \n    FROM country c \n    JOIN countrylanguage cl2 ON c.Code = cl2.CountryCode \n    WHERE cl2.Language = 'Dutch'\n) AS T1"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS NumberOfNations\nFROM (\n    SELECT c.Name\n    FROM country c\n    JOIN countrylanguage cl ON c.Code = cl.CountryCode\n    WHERE cl.Language = 'English'\n    INTERSECT\n    SELECT c.Name\n    FROM country c\n    JOIN countrylanguage cl ON c.Code = cl.CountryCode\n    WHERE cl.Language = 'Dutch'\n)"
        ]
    },
    "746": {
        "db_id": "world_1",
        "question": "What are the names of nations speak both English and French?",
        "ground_truth": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"French\"",
        "amends": [
            "Do use `INTERSECT` to find countries that speak both English and French instead of using `OR` which finds countries that speak either language. Do join on `T1.Code = T2.CountryCode` instead of `n.id = l1.nation_id` with proper table aliases. Do filter for `T2.Language = \"English\"` in one branch and `T2.Language = \"French\"` in the other instead of using `OR` conditions that don't ensure both languages are spoken. Do use explicit table aliases `T1` and `T2` instead of `n`, `l1`, and `l2`. Do structure the query as two separate SELECT statements with INTERSECT instead of a single query with multiple joins and OR conditions. The amended query now correctly identifies countries that speak both English and French by intersecting the results of two separate queries."
        ],
        "rules": [
            "When the question asks for nations that speak both English and French: use INTERSECT to find countries that appear in both the English-speaking and French-speaking sets instead of using OR conditions.",
            "When joining tables for language information: use the exact join condition T1.Code = T2.CountryCode as specified in the schema.",
            "When filtering for English speakers: use the exact literal filter T2.Language = \"English\" with proper double quotes and capitalization.",
            "When filtering for French speakers: use the exact literal filter T2.Language = \"French\" with proper double quotes and capitalization.",
            "When using table aliases: use T1 for the nations table and T2 for the languages table consistently throughout the query.",
            "When the question asks for nations that speak both English and French, When joining tables for language information, When filtering for English speakers, When filtering for French speakers, When using table aliases, When structuring the query: create two separate SELECT statements that find English-speaking countries and French-speaking countries respectively, then intersect them."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT n.name FROM nations n \nJOIN languages l1 ON n.id = l1.nation_id \nJOIN languages l2 ON n.id = l2.nation_id \nWHERE l1.language = 'English' OR l2.language = 'French';",
            "SELECT T1.Name \nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = 'English'\nINTERSECT\nSELECT T1.Name \nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = 'French'"
        ],
        "rule_sql": [
            "SELECT T1.Name \nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = \"English\"\nINTERSECT\nSELECT T1.Name \nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = \"French\""
        ]
    },
    "747": {
        "db_id": "world_1",
        "question": "Give the names of nations that speak both English and French.",
        "ground_truth": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"French\"",
        "amends": [
            "Do use `INTERSECT` to find countries that speak both English and French instead of using `OR` which finds countries that speak either language. Do join `country` table as `T1` with `countrylanguage` as `T2` on `T1.Code = T2.CountryCode` instead of joining `nations` with `languages` twice on `n.id = l1.nation_id` and `n.id = l2.nation_id`. Do filter for `T2.Language = \"English\"` in the first branch and `T2.Language = \"French\"` in the second branch instead of using `WHERE l1.language = 'English' OR l2.language = 'French'`. Do select `T1.Name` from the `country` table instead of `n.name` from `nations`. The amended query now correctly identifies countries that speak both English and French by using intersection logic instead of union logic."
        ],
        "rules": [
            "When answering about \"nations that speak both English and French\": use the INTERSECT operation to find countries that speak both languages instead of using OR which finds countries that speak either language.",
            "When combining country and countrylanguage tables: join T1 (country) with T2 (countrylanguage) on T1.Code = T2.CountryCode.",
            "When filtering for English language: use T2.Language = \"English\" exactly as specified.",
            "When filtering for French language: use T2.Language = \"French\" exactly as specified.",
            "When selecting output: use T1.Name from the country table instead of n.name from nations.",
            "When answering about \"nations that speak both English and French\", When combining country and countrylanguage tables, When filtering for English language, When filtering for French language, When selecting output, When finding countries that speak both languages: use intersection logic with two separate queries - one for English speakers and one for French speakers - then intersect the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT n.name \nFROM nations n\nJOIN languages l1 ON n.id = l1.nation_id\nJOIN languages l2 ON n.id = l2.nation_id\nWHERE l1.language = 'English' OR l2.language = 'French';",
            "SELECT T1.Name \nFROM country T1 \nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = 'English'\nINTERSECT\nSELECT T1.Name \nFROM country T1 \nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = 'French'"
        ],
        "rule_sql": [
            "SELECT T1.Name \nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = 'English'\nINTERSECT\nSELECT T1.Name \nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = 'French'"
        ]
    },
    "748": {
        "db_id": "world_1",
        "question": "What are the names of nations where both English and French are official languages?",
        "ground_truth": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" AND T2.IsOfficial  =  \"T\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"French\" AND T2.IsOfficial  =  \"T\"",
        "amends": [
            "Do use `INTERSECT` with two separate queries instead of a single `WHERE` clause with conflicting conditions. Do join `country AS T1` with `countrylanguage AS T2` on `T1.Code = T2.CountryCode` instead of querying only the `nations` table. Do filter for `T2.Language = \"English\"` and `T2.IsOfficial = \"T\"` in the first query instead of checking `official_languages = 'English'`. Do filter for `T2.Language = \"French\"` and `T2.IsOfficial = \"T\"` in the second query instead of checking `official_languages = 'French'`. Do select `T1.Name` from the joined tables instead of just `name` from a single table. The amended query now correctly identifies countries where both English and French are official languages by using an intersection of two separate queries with proper table joins and official language status checks."
        ],
        "rules": [
            "When answering about nations where both English and French are official languages: use an INTERSECT operation with two separate queries instead of a single WHERE clause with conflicting conditions.",
            "When combining country and countrylanguage tables: join T1 (country) with T2 (countrylanguage) where T1.Code = T2.CountryCode.",
            "When filtering for English as an official language: check T2.Language = \"English\" and T2.IsOfficial = \"T\".",
            "When filtering for French as an official language: check T2.Language = \"French\" and T2.IsOfficial = \"T\".",
            "When answering about nations where both English and French are official languages, When combining country and countrylanguage tables, When filtering for English as an official language, When filtering for French as an official language, When selecting the output: return T1.Name from the joined tables."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM nations WHERE official_languages = 'English' AND official_languages = 'French';",
            "SELECT T1.Name \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = 'English' AND T2.IsOfficial = 'T'\nINTERSECT\nSELECT T1.Name \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = 'French' AND T2.IsOfficial = 'T'"
        ],
        "rule_sql": [
            "SELECT T1.Name \nFROM country T1 \nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = 'English' AND T2.IsOfficial = 'T'\nINTERSECT\nSELECT T1.Name \nFROM country T1 \nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = 'French' AND T2.IsOfficial = 'T'"
        ]
    },
    "749": {
        "db_id": "world_1",
        "question": "Give the names of countries with English and French as official languages.",
        "ground_truth": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" AND T2.IsOfficial  =  \"T\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"French\" AND T2.IsOfficial  =  \"T\"",
        "amends": [
            "Do use an INTERSECT operation to find countries that have both English and French as official languages instead of using a single query with conflicting WHERE conditions. Do change the WHERE clause to filter for `T2.Language = \"English\"` and `T2.IsOfficial = \"T\"` in the first SELECT, and `T2.Language = \"French\"` and `T2.IsOfficial = \"T\"` in the second SELECT instead of trying to filter for both languages simultaneously in a single condition. Do add table aliases `T1` for country and `T2` for countrylanguage instead of using unaliased table names. Do remove the impossible condition requiring the same row to have both `language = 'English'` and `language = 'French'` instead of keeping this logical contradiction. The amended query now correctly identifies countries where both English and French are official languages by intersecting two separate queries, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for countries with both English AND French as official languages: use an INTERSECT operation to combine results from two separate queries instead of trying to filter for both languages in a single condition.",
            "When filtering for English as an official language: use the exact conditions T2.Language = \"English\" AND T2.IsOfficial = \"T\".",
            "When filtering for French as an official language: use the exact conditions T2.Language = \"French\" AND T2.IsOfficial = \"T\".",
            "When combining tables country and countrylanguage: use table aliases T1 for country and T2 for countrylanguage, and link them using T1.code = T2.countrycode.",
            "When the question asks for countries with both English AND French as official languages, When filtering for English as an official language, When filtering for French as an official language, When combining tables country and countrylanguage, When selecting country names: output T1.name from the country table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country.name \nFROM country \nJOIN countrylanguage ON country.code = countrylanguage.countrycode \nWHERE countrylanguage.language = 'English' \nAND countrylanguage.language = 'French' \nAND countrylanguage.isofficial = 'T';",
            "SELECT T1.Name \nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = 'English' AND T2.IsOfficial = 'T'\nINTERSECT\nSELECT T1.Name \nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = 'French' AND T2.IsOfficial = 'T'"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM country T1 JOIN countrylanguage T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND T2.IsOfficial = 'T' INTERSECT SELECT T1.Name FROM country T1 JOIN countrylanguage T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'French' AND T2.IsOfficial = 'T'"
        ]
    },
    "750": {
        "db_id": "world_1",
        "question": "What is the number of distinct continents where Chinese is spoken?",
        "ground_truth": "SELECT COUNT( DISTINCT Continent) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"Chinese\"",
        "amends": [
            "Do add `COUNT(DISTINCT Continent)` instead of `COUNT(*)` to count distinct continents rather than all rows. Do add `FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode` instead of just `FROM countrylanguage` to join the country table and access continent data. Do keep `WHERE T2.Language = 'Chinese'` but move it to reference the joined table instead of the standalone table. Do remove the standalone countrylanguage table reference and instead use the joined relationship between country and countrylanguage tables. The amended query now correctly counts distinct continents where Chinese is spoken instead of counting all Chinese language records, matching the intended behavior."
        ],
        "rules": [
            "When counting distinct continents where Chinese is spoken: use COUNT(DISTINCT T1.Continent) instead of COUNT(*) to count unique continent values.",
            "When accessing continent data from countrylanguage records: join country table as T1 with countrylanguage table as T2 using T1.Code = T2.CountryCode to link language records to their respective countries.",
            "When filtering for Chinese language: use WHERE T2.Language = 'Chinese' with exact literal 'Chinese' to identify Chinese language records.",
            "When counting distinct continents where Chinese is spoken, When accessing continent data from countrylanguage records, When filtering for Chinese language, When combining country and countrylanguage tables: perform an inner join where T1.Code equals T2.CountryCode to ensure only matching country-language pairs are considered."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM countrylanguage WHERE language = 'Chinese';",
            "SELECT COUNT(DISTINCT T1.Continent) \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = 'Chinese'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.Continent) \nFROM country AS T1 \nINNER JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = 'Chinese'"
        ]
    },
    "751": {
        "db_id": "world_1",
        "question": "How many continents speak Chinese?",
        "ground_truth": "SELECT COUNT( DISTINCT Continent) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"Chinese\"",
        "amends": [
            "Do use `COUNT(DISTINCT Continent)` instead of `COUNT(*)` to count distinct continents rather than all rows. Do add `JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode` instead of querying only the countries table to properly relate countries with their languages. Do reference `T2.Language = \"Chinese\"` instead of `language = 'Chinese'` to filter by language in the correct joined table. Do specify `FROM country AS T1` instead of `FROM countries` to use the correct table name and alias. The amended query now correctly counts distinct continents where Chinese is spoken by properly joining the country and countrylanguage tables."
        ],
        "rules": [
            "When counting distinct continents: use COUNT(DISTINCT T1.Continent) instead of COUNT(*) to count unique continents rather than all rows.",
            "When combining country and countrylanguage tables: link rows where T1.Code = T2.CountryCode and keep only matching pairs (inner match).",
            "When filtering by Chinese language: use T2.Language = \"Chinese\" with exact case and double quotes as shown in the schema.",
            "When referring to the country table: use the exact table name \"country\" with alias T1 instead of \"countries\".",
            "When counting distinct continents, When combining country and countrylanguage tables, When filtering by Chinese language, When referring to the country table, When answering about continents that speak Chinese: make sure the output order is a single count of distinct continents."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE language = 'Chinese';",
            "SELECT COUNT(DISTINCT T1.Continent) \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = 'Chinese'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.Continent) \nFROM country T1 \nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = \"Chinese\""
        ]
    },
    "752": {
        "db_id": "world_1",
        "question": "What are the regions that use English or Dutch?",
        "ground_truth": "SELECT DISTINCT T1.Region FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" OR T2.Language  =  \"Dutch\"",
        "amends": [
            "Do select `DISTINCT T1.Region` instead of `region` without distinct. Do join `country AS T1` with `countrylanguage AS T2` instead of querying only `countries`. Do use `LEFT JOIN` on `T1.Code = T2.CountryCode` instead of no join condition. Do filter with `T2.Language = \"English\" OR T2.Language = \"Dutch\"` instead of `language = 'English' AND language = 'Dutch'` which would never return results. The amended query now correctly finds regions where either English or Dutch is spoken, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"regions that use English or Dutch\": make sure the output order: T1.Region",
            "When the question mentions \"regions\": \"regions\" actually means \"T1.Region in schema\"",
            "When combining T1 and T2 for shared entities: link rows where T1.Code = T2.CountryCode exactly as shown in the amends; keep only matching pairs (inner match).",
            "When filtering for languages: use T2.Language = \"English\" OR T2.Language = \"Dutch\" with exact literals \"English\" and \"Dutch\" as shown in the amends.",
            "When answering about \"regions that use English or Dutch\", When the question mentions \"regions\", When combining T1 and T2 for shared entities, When filtering for languages, When selecting regions: use DISTINCT T1.Region to ensure each region appears only once in the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT region FROM countries WHERE language = 'English' AND language = 'Dutch';",
            "SELECT DISTINCT T1.Region FROM country AS T1 LEFT JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' OR T2.Language = 'Dutch'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Region\nFROM country T1\nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = 'English' OR T2.Language = 'Dutch'\nORDER BY T1.Region"
        ]
    },
    "753": {
        "db_id": "world_1",
        "question": "Which regions speak Dutch or English?",
        "ground_truth": "SELECT DISTINCT T1.Region FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" OR T2.Language  =  \"Dutch\"",
        "amends": [
            "Do use `DISTINCT T1.Region` instead of `region` without distinct. Do join `country AS T1` and `countrylanguage AS T2` instead of querying only `countries`. Do specify `ON T1.Code = T2.CountryCode` instead of missing the join condition. Do filter on `T2.Language = \"English\" OR T2.Language = \"Dutch\"` instead of filtering on a single table's `language` column. The amended query now correctly retrieves distinct regions from joined tables where the language condition is properly applied through the relationship between country and countrylanguage tables."
        ],
        "rules": [
            "When answering about \"regions that speak Dutch or English\": make sure the output order: T1.Region.",
            "When the question asks for distinct regions: compute unique values of T1.Region.",
            "When combining country as T1 and countrylanguage as T2: link rows where T1.Code = T2.CountryCode and keep only matching pairs (inner match).",
            "When answering about \"regions that speak Dutch or English\", When the question asks for distinct regions, When combining country as T1 and countrylanguage as T2, When filtering for languages: use exact literals T2.Language = \"English\" OR T2.Language = \"Dutch\" with exact case and punctuation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT region FROM countries WHERE language = 'Dutch' OR language = 'English';",
            "SELECT DISTINCT T1.Region FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' OR T2.Language = 'Dutch'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Region \nFROM country AS T1 \nINNER JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = \"English\" OR T2.Language = \"Dutch\" \nORDER BY T1.Region"
        ]
    },
    "754": {
        "db_id": "world_1",
        "question": "What are the countries where either English or Dutch is the official language ?",
        "ground_truth": "select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  \"english\" and isofficial  =  \"t\" union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  \"dutch\" and isofficial  =  \"t\"",
        "amends": [
            "Do select `t1.name` from `country` instead of `country` from `languages`. Do use `JOIN` with `countrylanguage` on `t1.code = t2.countrycode` instead of querying a single table. Do filter for `language = \"english\"` and `isofficial = \"t\"` in separate UNION branches instead of impossible `language = 'English' AND language = 'Dutch'` condition. Do add `UNION` to combine results for English and Dutch official languages instead of attempting to find both languages in one row. Do remove the incorrect table reference and impossible WHERE condition instead of keeping them. The amended query now correctly finds countries with English or Dutch as official languages through proper table joins and union operation.",
            "Do use double quotes `\"english\"` and `\"dutch\"` instead of single quotes `'English'` and `'Dutch'` for string literals. Do reference `isofficial` directly instead of qualifying it with `t2.` as `t2.IsOfficial`. Do add explicit `AS` keyword for table aliases as `country AS t1` instead of omitting it. Do use consistent lowercase for column names like `name` and `code` instead of mixed case. The amended query now correctly matches the RIGHT_SQL's behavior with proper string quoting and unqualified column reference."
        ],
        "rules": [
            "When answering about countries where English or Dutch is the official language: select \"t1\".\"name\" from the \"country\" table instead of \"country\" from \"languages\".",
            "When combining country and language information: use JOIN with \"countrylanguage\" table on \"t1\".\"code\" = \"t2\".\"countrycode\" to link countries with their languages.",
            "When filtering for official languages: check for \"language\" = \"english\" and \"isofficial\" = \"t\" in separate UNION branches instead of trying to find both languages in one row.",
            "When the question asks for countries with either English or Dutch as official language: use UNION to combine results for both language conditions instead of using AND between different language values.",
            "When answering about countries where English or Dutch is the official language, When combining country and language information, When filtering for official languages, When the question asks for countries with either English or Dutch as official language, When handling text literals: use exact values \"english\" (lowercase) and \"t\" for the official status indicator as shown in the schema.",
            "When the question mentions \"English\" or \"Dutch\" as languages: use exact string literals \"english\" and \"dutch\" in lowercase with double quotes.",
            "When checking if a language is official: reference the column \"isofficial\" directly without table qualification.",
            "When joining tables: use explicit AS keyword for table aliases as \"country AS t1\" instead of omitting it.",
            "When the question mentions \"English\" or \"Dutch\" as languages, When checking if a language is official, When joining tables, When referencing column names: use consistent lowercase for columns like \"name\" and \"code\" instead of mixed case."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM languages WHERE language = 'English' AND language = 'Dutch';",
            "SELECT t1.Name \nFROM country t1\nJOIN countrylanguage t2 ON t1.Code = t2.CountryCode\nWHERE t2.Language = 'English' AND t2.IsOfficial = 'T'\nUNION\nSELECT t1.Name \nFROM country t1\nJOIN countrylanguage t2 ON t1.Code = t2.CountryCode\nWHERE t2.Language = 'Dutch' AND t2.IsOfficial = 'T'",
            "SELECT t1.name \nFROM country AS t1 \nJOIN countrylanguage AS t2 ON t1.code = t2.countrycode \nWHERE t2.language = \"english\" AND t2.isofficial = \"T\"\nUNION\nSELECT t1.name \nFROM country AS t1 \nJOIN countrylanguage AS t2 ON t1.code = t2.countrycode \nWHERE t2.language = \"dutch\" AND t2.isofficial = \"T\""
        ],
        "rule_sql": [
            "SELECT t1.name \nFROM country AS t1 \nJOIN countrylanguage AS t2 ON t1.code = t2.countrycode \nWHERE t2.language = \"english\" AND t2.isofficial = \"t\"\nUNION\nSELECT t1.name \nFROM country AS t1 \nJOIN countrylanguage AS t2 ON t1.code = t2.countrycode \nWHERE t2.language = \"dutch\" AND t2.isofficial = \"t\""
        ]
    },
    "755": {
        "db_id": "world_1",
        "question": "Which countries have either English or Dutch as an official language?",
        "ground_truth": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" AND IsOfficial  =  \"T\" UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"Dutch\" AND IsOfficial  =  \"T\"",
        "amends": [
            "Do select all columns from joined tables instead of selecting only `country` from a single table. Do join `country` and `countrylanguage` tables on `Code=CountryCode` instead of querying only the `languages` table. Do filter for `Language=\"English\"` and `IsOfficial=\"T\"` in one branch instead of using contradictory `language='English' AND language='Dutch'` conditions. Do add a UNION with a second branch for `Language=\"Dutch\"` and `IsOfficial=\"T\"` instead of attempting to find both languages in a single row. Do use proper table aliases `T1` and `T2` instead of no aliases. The amended query now correctly finds countries where either English or Dutch is an official language through separate UNION branches instead of the impossible single-row condition."
        ],
        "rules": [
            "When answering about countries with official languages: select all columns from joined tables instead of selecting only country from a single table.",
            "When combining country and countrylanguage tables: join them on T1.Code = T2.CountryCode instead of querying only one table.",
            "When filtering for English as an official language: use conditions T2.Language=\"English\" AND T2.IsOfficial=\"T\" instead of contradictory single-row conditions.",
            "When filtering for Dutch as an official language: use conditions T2.Language=\"Dutch\" AND T2.IsOfficial=\"T\" in a separate UNION branch.",
            "When handling multiple language conditions: use UNION with separate branches for each language instead of attempting to find both languages in a single row.",
            "When answering about countries with official languages, When combining country and countrylanguage tables, When filtering for English as an official language, When filtering for Dutch as an official language, When handling multiple language conditions, When referring to tables: use proper aliases T1 for country table and T2 for countrylanguage table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM languages WHERE language = 'English' AND language = 'Dutch';",
            "SELECT T1.*, T2.*\nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = 'English' AND T2.IsOfficial = 'T'\nUNION\nSELECT T1.*, T2.*\nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = 'Dutch' AND T2.IsOfficial = 'T'"
        ],
        "rule_sql": [
            "SELECT T1.*, T2.* FROM country T1 JOIN countrylanguage T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND T2.IsOfficial = 'T' UNION SELECT T1.*, T2.* FROM country T1 JOIN countrylanguage T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'Dutch' AND T2.IsOfficial = 'T'"
        ]
    },
    "756": {
        "db_id": "world_1",
        "question": "Which language is the most popular on the Asian continent?",
        "ground_truth": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Continent  =  \"Asia\" GROUP BY T2.Language ORDER BY COUNT (*) DESC LIMIT 1",
        "amends": [
            "Do use `T2.Language` in the SELECT list instead of `language` and remove the `count` alias. Do join `country AS T1` with `countrylanguage AS T2` on `T1.Code = T2.CountryCode` instead of querying a single `countries` table. Do filter on `T1.Continent = \"Asia\"` instead of `continent = 'Asia'`. Do group by `T2.Language` instead of `language`. Do order by `COUNT(*) DESC` instead of `count DESC`. The amended query now correctly joins the country and countrylanguage tables to find the most spoken language in Asia."
        ],
        "rules": [
            "When answering about \"most popular language on the Asian continent\": make sure the output order: T2.Language, COUNT(*).",
            "When the question mentions \"Asian continent\": \"Asia\" actually means T1.Continent = \"Asia\" in schema.",
            "When combining T1 (country) and T2 (countrylanguage) for shared entities: link rows where T1.Code = T2.CountryCode; keep only matching pairs (inner match).",
            "When the question asks for \"most popular language\": rank rows by COUNT(*) in descending direction and keep the first 1 row.",
            "When answering about \"most popular language on the Asian continent\", When the question mentions \"Asian continent\", When combining T1 (country) and T2 (countrylanguage) for shared entities, When the question asks for \"most popular language\", When the question asks for \"count of languages per language group\": compute the number of rows using T2.Language as the grouping key and count all matching rows per group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language, COUNT(*) as count FROM countries WHERE continent = 'Asia' GROUP BY language ORDER BY count DESC LIMIT 1;",
            "SELECT T2.Language\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nWHERE T1.Continent = 'Asia'\nGROUP BY T2.Language\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Language, COUNT(*) \nFROM country T1 \nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T1.Continent = 'Asia' \nGROUP BY T2.Language \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ]
    },
    "757": {
        "db_id": "world_1",
        "question": "What is the language that is used by the largest number of Asian nations?",
        "ground_truth": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Continent  =  \"Asia\" GROUP BY T2.Language ORDER BY COUNT (*) DESC LIMIT 1",
        "amends": [
            "Do use `T2.Language` from the `countrylanguage` table instead of `language` from a non-existent column. Do join `country AS T1` and `countrylanguage AS T2` with `ON T1.Code = T2.CountryCode` instead of querying a single `countries` table. Do filter on `T1.Continent = \"Asia\"` instead of `continent = 'Asia'` to reference the correct table. Do group by `T2.Language` instead of `language` to match the selected column. Do order by `COUNT(*) DESC` instead of `count DESC` to reference the aggregate function directly rather than an alias. The amended query now correctly identifies the most spoken language in Asia by joining the appropriate tables and properly referencing schema elements.",
            "Do remove `COUNT(*) AS count` from the SELECT list instead of including it, as the RIGHT_SQL only selects `T2.Language`. Do use double quotes `\"Asia\"` for the string literal instead of single quotes `'Asia'` in the WHERE clause. Do remove the space between `COUNT` and `(*)` in the ORDER BY clause instead of having a space, making it `COUNT(*)` instead of `COUNT (*)`. The amended query now correctly returns only the language column while maintaining the same grouping, ordering, and limiting behavior to match RIGHT_SQL's output."
        ],
        "rules": [
            "When answering about \"language used by Asian nations\": make sure the output order: T2.Language, COUNT(*) as count",
            "When the question mentions \"Asian nations\": \"Asian nations\" actually means \"T1.Continent = 'Asia' in schema\"",
            "When combining T1 (country) and T2 (countrylanguage) for shared entities: link rows where T1.Code = T2.CountryCode exactly as shown in the amends; keep only matching pairs (inner match)",
            "When the question asks for \"largest number\": rank rows by COUNT(*) in descending direction and keep the first 1 row",
            "When the question says \"by language\": organize results by T2.Language and compute COUNT(*) per group",
            "When counting entities: compute the number of rows using the join relationship T1.Code = T2.CountryCode",
            "When answering about \"language used by Asian nations\", When the question mentions \"Asian nations\", When combining T1 (country) and T2 (countrylanguage) for shared entities, When the question asks for \"largest number\", When the question says \"by language\", When counting entities, When handling text literals: do not change case, spacing, or punctuation - use exact value 'Asia'",
            "When answering about \"the language that is used by the largest number of Asian nations\": make sure the output order: T2.Language only.",
            "When the question mentions \"Asian nations\": \"Asia\" actually means \"Asia\" in schema and must be written with double quotes as \"Asia\".",
            "When the question asks for \"largest number\": rank rows by COUNT(*) in descending order and keep the first 1 row.",
            "When counting entities: use COUNT(*) without any space between COUNT and (*).",
            "When combining country AS T1 and countrylanguage AS T2: link rows where T1.Code = T2.CountryCode and keep only matching pairs (inner match).",
            "When answering about \"the language that is used by the largest number of Asian nations\", When the question mentions \"Asian nations\", When the question asks for \"largest number\", When counting entities, When combining country AS T1 and countrylanguage AS T2, When the question says \"by Asian nations\": filter rows where T1.Continent = \"Asia\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT language, COUNT(*) as count FROM countries WHERE continent = 'Asia' GROUP BY language ORDER BY count DESC LIMIT 1;",
            "SELECT T2.Language, COUNT(*) AS count\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nWHERE T1.Continent = 'Asia'\nGROUP BY T2.Language\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T2.Language\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nWHERE T1.Continent = \"Asia\"\nGROUP BY T2.Language\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Language\nFROM country AS T1\nINNER JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nWHERE T1.Continent = 'Asia'\nGROUP BY T2.Language\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "758": {
        "db_id": "world_1",
        "question": "Which languages are spoken by only one country in republic governments?",
        "ground_truth": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  \"Republic\" GROUP BY T2.Language HAVING COUNT(*)  =  1",
        "amends": [
            "Do use table alias `T2` for the language table instead of `cl` and reference `T2.Language` in SELECT instead of `language`. Do join `country AS T1` instead of `country c` and use `T1.Code = T2.CountryCode` instead of `cl.country_code = c.code` for the join condition. Do reference `T1.GovernmentForm` instead of `c.government` in the WHERE filter while keeping the same 'Republic' value. Do maintain the same GROUP BY on language and HAVING COUNT(*) = 1 condition. The amended query now correctly matches the RIGHT_SQL's behavior with proper table references and join conditions."
        ],
        "rules": [
            "When answering about languages spoken by only one country in republic governments: make sure the output order: T2.Language",
            "When combining country table (T1) and language table (T2): link rows where T1.Code = T2.CountryCode and keep only matching pairs (inner match)",
            "When filtering for republic governments: use T1.GovernmentForm = 'Republic' exactly as specified",
            "When grouping by language: organize results by T2.Language and compute aggregates per language group",
            "When answering about languages spoken by only one country in republic governments, When combining country table (T1) and language table (T2), When filtering for republic governments, When grouping by language, When counting countries per language: compute the number of rows using the canonical key and ensure the count equals exactly 1"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT language, COUNT(*) as country_count \nFROM country_language cl \nJOIN country c ON cl.country_code = c.code \nWHERE c.government = 'Republic' \nGROUP BY language \nHAVING COUNT(*) = 1;",
            "SELECT T2.Language\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nWHERE T1.GovernmentForm = 'Republic'\nGROUP BY T2.Language\nHAVING COUNT(*) = 1"
        ],
        "rule_sql": [
            "SELECT T2.Language\nFROM country T1\nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T1.GovernmentForm = 'Republic'\nGROUP BY T2.Language\nHAVING COUNT(T1.Code) = 1\nORDER BY T2.Language"
        ]
    },
    "759": {
        "db_id": "world_1",
        "question": "What languages are only used by a single country with a republic government?",
        "ground_truth": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  \"Republic\" GROUP BY T2.Language HAVING COUNT(*)  =  1",
        "amends": [
            "Do use `T2.Language` instead of `language` for the SELECT column. Do reference `countrylanguage` as `T2` instead of `country_language cl` as the table source. Do use `JOIN` with `T1.Code = T2.CountryCode` instead of `JOIN` with `cl.country_code = c.code` for the join condition. Do filter with `T1.GovernmentForm = \"Republic\"` instead of `c.government = 'Republic'` in the WHERE clause. Do use `COUNT(*) = 1` instead of `COUNT(DISTINCT c.code) > 1` in the HAVING clause to find languages spoken in exactly one republic instead of multiple republics. Do remove `DISTINCT` from the SELECT instead of keeping it since the GROUP BY already ensures uniqueness. The amended query now correctly identifies languages spoken in exactly one republic country."
        ],
        "rules": [
            "When referencing the language column: use \"T2.Language\" instead of \"language\" for the output column.",
            "When joining country and countrylanguage tables: link rows where \"T1.Code = T2.CountryCode\" exactly as shown.",
            "When filtering for republic government form: use \"T1.GovernmentForm = \\\"Republic\\\"\" with exact case and quotes.",
            "When counting countries per language: use \"COUNT(*) = 1\" to find languages spoken in exactly one republic country.",
            "When referencing the language column, When joining country and countrylanguage tables, When filtering for republic government form, When counting countries per language, When selecting languages: do not use DISTINCT since GROUP BY already ensures uniqueness per language group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT language \nFROM country_language cl\nJOIN country c ON cl.country_code = c.code\nWHERE c.government = 'Republic'\nGROUP BY language\nHAVING COUNT(DISTINCT c.code) > 1;",
            "SELECT T2.Language\nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T1.GovernmentForm = \"Republic\"\nGROUP BY T2.Language\nHAVING COUNT(*) = 1"
        ],
        "rule_sql": [
            "SELECT T2.Language\nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T1.GovernmentForm = \"Republic\"\nGROUP BY T2.Language\nHAVING COUNT(*) = 1"
        ]
    },
    "760": {
        "db_id": "world_1",
        "question": "Find the city with the largest population that uses English.",
        "ground_truth": "SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  \"English\" ORDER BY T1.Population DESC LIMIT 1",
        "amends": [
            "Do select `T1.Name` and `T1.Population` instead of just `city` from the SELECT list. Do join `city AS T1` with `countrylanguage AS T2` on `T1.CountryCode = T2.CountryCode` instead of querying only the `cities` table. Do filter on `T2.Language = \"English\"` instead of `language = 'English'` in the WHERE clause. Do order by `T1.Population DESC` instead of `population ASC` for descending order. The amended query now correctly retrieves city names with their populations where English is spoken, ordered by population in descending order to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"city with the largest population that uses English\": make sure the output order: T1.Name, T1.Population.",
            "When the question mentions \"city\": \"city\" actually means \"T1.Name in schema\".",
            "When the question mentions \"largest population\": rank rows by T1.Population in descending direction and keep the first 1 row.",
            "When combining T1 and T2 for shared entities: link rows where T1.CountryCode = T2.CountryCode; keep only matching pairs (inner match).",
            "When answering about \"city with the largest population that uses English\", When the question mentions \"city\", When the question mentions \"largest population\", When combining T1 and T2 for shared entities, When filtering for English language: use T2.Language = \"English\" exactly as specified with double quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city FROM cities WHERE language = 'English' ORDER BY population ASC LIMIT 1;",
            "SELECT T1.Name, T1.Population \nFROM city AS T1 \nJOIN countrylanguage AS T2 ON T1.CountryCode = T2.CountryCode \nWHERE T2.Language = \"English\" \nORDER BY T1.Population DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Name, T1.Population\nFROM city T1\nINNER JOIN countrylanguage T2 ON T1.CountryCode = T2.CountryCode\nWHERE T2.Language = \"English\"\nORDER BY T1.Population DESC\nLIMIT 1"
        ]
    },
    "761": {
        "db_id": "world_1",
        "question": "What is the most populace city that speaks English?",
        "ground_truth": "SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  \"English\" ORDER BY T1.Population DESC LIMIT 1",
        "amends": [
            "Do select `T1.Name` and `T1.Population` instead of `city` and `population`. Do join `city AS T1` with `countrylanguage AS T2` on `T1.CountryCode = T2.CountryCode` instead of querying a single `cities` table. Do filter on `T2.Language = \"English\"` instead of `language = 'English'`. Do order by `T1.Population DESC` instead of `population ASC`. The amended query now correctly joins tables to filter by language and returns the city with the highest English-speaking population instead of the lowest."
        ],
        "rules": [
            "When the question asks about \"city\" and \"population\": select \"T1\".\"Name\" and \"T1\".\"Population\" as output columns.",
            "When combining city and countrylanguage tables: join \"city\" AS \"T1\" with \"countrylanguage\" AS \"T2\" on \"T1\".\"CountryCode\" = \"T2\".\"CountryCode\" using inner match.",
            "When filtering for English language: apply condition \"T2\".\"Language\" = \"English\".",
            "When the question asks about \"city\" and \"population\", When combining city and countrylanguage tables, When filtering for English language, When the question asks for the \"most populace city\": order results by \"T1\".\"Population\" in descending direction and keep only the first row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, population FROM cities WHERE language = 'English' ORDER BY population ASC LIMIT 1;",
            "SELECT T1.Name, T1.Population \nFROM city AS T1 \nJOIN countrylanguage AS T2 ON T1.CountryCode = T2.CountryCode \nWHERE T2.Language = \"English\" \nORDER BY T1.Population DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Name, T1.Population FROM city AS T1 INNER JOIN countrylanguage AS T2 ON T1.CountryCode = T2.CountryCode WHERE T2.Language = 'English' ORDER BY T1.Population DESC LIMIT 1;"
        ]
    },
    "762": {
        "db_id": "world_1",
        "question": "Find the name, population and expected life length of asian country with the largest area?",
        "ground_truth": "SELECT Name ,  Population ,  LifeExpectancy FROM country WHERE Continent  =  \"Asia\" ORDER BY SurfaceArea DESC LIMIT 1",
        "amends": [
            "Do reference table `country` instead of `countries` and use exact column names `Name`, `Population`, and `LifeExpectancy` instead of `name`, `population`, and `life_expectancy`. Do filter on `Continent = \"Asia\"` instead of `continent = 'Asia'` using double quotes for the string literal. Do order by `SurfaceArea DESC` instead of `area DESC` to match the correct column name. The amended query now correctly references the proper table schema and column names to match the intended behavior."
        ],
        "rules": [
            "When answering about \"asian country with the largest area\": make sure the output order: Name, Population, LifeExpectancy",
            "When the question mentions \"name\": \"name\" actually means \"Name in schema\"",
            "When the question mentions \"population\": \"population\" actually means \"Population in schema\"",
            "When the question mentions \"expected life length\": \"expected life length\" actually means \"LifeExpectancy in schema\"",
            "When the question mentions \"largest area\": \"area\" actually means \"SurfaceArea in schema\"",
            "When the question mentions \"asian country\": filter rows where Continent = \"Asia\" exactly",
            "When answering about \"asian country with the largest area\", When the question mentions \"name\", When the question mentions \"population\", When the question mentions \"expected life length\", When the question mentions \"largest area\", When the question mentions \"asian country\", When the question asks for \"largest area\": rank rows by SurfaceArea in descending order and keep the first 1 row"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, population, life_expectancy FROM countries WHERE continent = 'Asia' ORDER BY area DESC LIMIT 1;",
            "SELECT Name, Population, LifeExpectancy FROM country WHERE Continent = \"Asia\" ORDER BY SurfaceArea DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Name, Population, LifeExpectancy FROM country WHERE Continent = 'Asia' ORDER BY SurfaceArea DESC LIMIT 1"
        ]
    },
    "763": {
        "db_id": "world_1",
        "question": "What are the name, population, and life expectancy of the largest Asian country by land?",
        "ground_truth": "SELECT Name ,  Population ,  LifeExpectancy FROM country WHERE Continent  =  \"Asia\" ORDER BY SurfaceArea DESC LIMIT 1",
        "amends": [
            "Do reference table `country` instead of `countries` and use exact column names `Name`, `Population`, and `LifeExpectancy` instead of `name`, `population`, and `life_expectancy`. Do use double quotes around `\"Asia\"` instead of single quotes for the continent filter. Do order by `SurfaceArea` instead of `land_area` for the area-based sorting. The amended query now correctly references the schema and matches the intended behavior."
        ],
        "rules": [
            "When answering about \"largest Asian country by land\": make sure the output order: Name, Population, LifeExpectancy.",
            "When the question mentions \"largest by land\": rank rows by SurfaceArea in descending order and keep the first 1 row.",
            "When filtering for Asian countries: use the exact literal \"Asia\" for the continent filter.",
            "When answering about \"largest Asian country by land\", When the question mentions \"largest by land\", When filtering for Asian countries, When referencing table and columns: use table \"country\" with columns \"Name\", \"Population\", and \"LifeExpectancy\" exactly as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, population, life_expectancy FROM countries WHERE continent = 'Asia' ORDER BY land_area DESC LIMIT 1;",
            "SELECT Name, Population, LifeExpectancy FROM country WHERE Continent = \"Asia\" ORDER BY SurfaceArea DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name, Population, LifeExpectancy FROM country WHERE Continent = 'Asia' ORDER BY SurfaceArea DESC LIMIT 1"
        ]
    },
    "764": {
        "db_id": "world_1",
        "question": "What is average life expectancy in the countries where English is not the official language?",
        "ground_truth": "SELECT avg(LifeExpectancy) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" AND T2.IsOfficial  =  \"T\")",
        "amends": [
            "Do use `avg(LifeExpectancy)` instead of `AVG(life_expectancy)` to reference the correct column name. Do reference table `country` instead of `countries` with the proper table name. Do replace the simple `WHERE official_language != 'English'` filter with a subquery that checks `Name NOT IN` a correlated subquery instead of using a direct column comparison. Do implement a subquery that joins `country AS T1` with `countrylanguage AS T2` on `T1.Code = T2.CountryCode` instead of assuming language data exists in the main table. Do add the condition `T2.Language = \"English\" AND T2.IsOfficial = \"T\"` to properly filter for countries where English is an official language, instead of just checking for any non-English language presence. The amended query now correctly calculates average life expectancy for countries where English is not an official language by properly correlating country data with language information through the appropriate join relationship."
        ],
        "rules": [
            "When answering about average life expectancy: use avg(LifeExpectancy) to reference the correct column name.",
            "When referencing the countries table: use table country instead of countries with the proper table name.",
            "When filtering for countries where English is not the official language: implement a subquery that checks Name NOT IN a correlated subquery instead of using a direct column comparison.",
            "When combining country and language data: join country AS T1 with countrylanguage AS T2 on T1.Code = T2.CountryCode instead of assuming language data exists in the main table.",
            "When answering about average life expectancy, When referencing the countries table, When filtering for countries where English is not the official language, When combining country and language data, When identifying countries where English is an official language: add the condition T2.Language = \"English\" AND T2.IsOfficial = \"T\" to properly filter for official English language status."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(life_expectancy) FROM countries WHERE official_language != 'English';",
            "SELECT AVG(LifeExpectancy) \nFROM country \nWHERE Name NOT IN (\n    SELECT T1.Name \n    FROM country AS T1 \n    JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \n    WHERE T2.Language = 'English' AND T2.IsOfficial = 'T'\n)"
        ],
        "rule_sql": [
            "SELECT AVG(LifeExpectancy) \nFROM country \nWHERE Name NOT IN (\n    SELECT T1.Name \n    FROM country AS T1 \n    JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \n    WHERE T2.Language = 'English' AND T2.IsOfficial = 'T'\n)"
        ]
    },
    "765": {
        "db_id": "world_1",
        "question": "Give the mean life expectancy of countries in which English is not the official language.",
        "ground_truth": "SELECT avg(LifeExpectancy) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" AND T2.IsOfficial  =  \"T\")",
        "amends": [
            "Do use `avg(LifeExpectancy)` with lowercase function instead of `AVG(LifeExpectancy)` with uppercase. Do replace the simple `WHERE Language != 'English'` filter with a subquery condition `WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = \"English\" AND T2.IsOfficial = \"T\")` that properly checks for countries where English is an official language through a join between country and countrylanguage tables instead of incorrectly filtering on a non-existent Language column in the Country table. Do add the additional condition `AND T2.IsOfficial = \"T\"` to ensure only officially recognized English languages are considered instead of omitting this official status check. The amended query now correctly identifies countries without English as an official language by properly joining related tables and checking language official status."
        ],
        "rules": [
            "When answering about mean life expectancy of countries where English is not the official language: use lowercase avg(LifeExpectancy) instead of uppercase AVG(LifeExpectancy).",
            "When the question mentions \"official language\": this requires checking both T2.Language = \"English\" AND T2.IsOfficial = \"T\" in the countrylanguage table.",
            "When combining country (T1) and countrylanguage (T2) tables: link rows where T1.Code = T2.CountryCode and keep only matching pairs (inner match).",
            "When answering about mean life expectancy of countries where English is not the official language, When the question mentions \"official language\", When combining country (T1) and countrylanguage (T2) tables, When filtering for countries without English as official language: use a subquery condition WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = \"English\" AND T2.IsOfficial = \"T\") instead of filtering on a non-existent Language column in the Country table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(LifeExpectancy) FROM Country WHERE Language != 'English';",
            "SELECT avg(LifeExpectancy) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = \"English\" AND T2.IsOfficial = \"T\")"
        ],
        "rule_sql": [
            "SELECT avg(LifeExpectancy) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = \"English\" AND T2.IsOfficial = \"T\")"
        ]
    },
    "766": {
        "db_id": "world_1",
        "question": "What is the total number of people living in the nations that do not use English?",
        "ground_truth": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\")",
        "amends": [
            "Do reference the `country` table instead of `nations` and use `sum(Population)` instead of `SUM(population)`. Do replace the simple `WHERE language != 'English'` filter with a subquery that checks `Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = \"English\")` instead of the incorrect direct column reference. Do add the necessary join between `country` and `countrylanguage` tables on `T1.Code = T2.CountryCode` instead of omitting this relationship. The amended query now correctly identifies countries where English is not an official language by properly joining through the countrylanguage table instead of incorrectly assuming the language column exists directly in the country table."
        ],
        "rules": [
            "When answering about \"total number of people living in nations that do not use English\": make sure the output order: sum(Population)",
            "When the question mentions \"nations\": \"nations\" actually means \"country table\" in schema",
            "When the question mentions \"do not use English\": this means countries where \"English\" is not listed as a language in the countrylanguage table",
            "When combining country (T1) and countrylanguage (T2) for shared entities: link rows where T1.Code = T2.CountryCode exactly as shown in the amends; keep only matching pairs (inner match)",
            "When filtering for countries without English: use the condition T1.Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = \"English\") instead of direct column filtering",
            "When answering about \"total number of people living in nations that do not use English\", When the question mentions \"nations\", When the question mentions \"do not use English\", When combining country (T1) and countrylanguage (T2) for shared entities, When filtering for countries without English, When computing total population: use sum(Population) with exact case and spelling as shown in the amends"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(population) FROM nations WHERE language != 'English';",
            "SELECT SUM(Population) \nFROM country \nWHERE Name NOT IN (\n    SELECT T1.Name \n    FROM country AS T1 \n    JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \n    WHERE T2.Language = 'English'\n)"
        ],
        "rule_sql": [
            "SELECT SUM(Population) \nFROM country AS T1 \nWHERE T1.Name NOT IN (\n    SELECT T1.Name \n    FROM country AS T1 \n    JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \n    WHERE T2.Language = 'English'\n)"
        ]
    },
    "767": {
        "db_id": "world_1",
        "question": "How many people live in countries that do not speak English?",
        "ground_truth": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\")",
        "amends": [
            "Do use `sum(Population)` instead of `COUNT(*)` to aggregate population data rather than counting rows. Do query from `country` table instead of joining `people`, `countries`, and `languages` tables. Do use a `WHERE Name NOT IN` subquery filter instead of a direct join condition with `l.name != 'English'`. Do implement a correlated subquery with `country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode` instead of the three-table join structure. Do filter for `T2.Language = \"English\"` in the subquery instead of excluding English language directly. Do remove the explicit table aliases `p`, `c`, and `l` since they are no longer needed in the simplified structure. The amended query now correctly calculates total population of countries where English is not spoken, matching the intended behavior."
        ],
        "rules": [
            "When calculating population counts: use sum(\"Population\") instead of counting rows to aggregate population data.",
            "When answering about countries that do not speak English: use a correlated subquery with WHERE \"Name\" NOT IN instead of direct join conditions with != 'English'.",
            "When combining country and countrylanguage tables: link rows where T1.\"Code\" = T2.\"CountryCode\" exactly as shown and keep only matching pairs (inner match).",
            "When filtering for English language: use the exact literal \"English\" with correct case and quotes in the condition T2.\"Language\" = \"English\".",
            "When calculating population counts, When answering about countries that do not speak English, When combining country and countrylanguage tables, When filtering for English language, When the question asks for population of countries: use the \"Population\" column from the country table as the aggregation source."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM people p \nJOIN countries c ON p.country_id = c.id \nJOIN languages l ON c.language_id = l.id \nWHERE l.name != 'English';",
            "SELECT SUM(Population) \nFROM country \nWHERE Name NOT IN (\n    SELECT T1.Name \n    FROM country AS T1 \n    JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \n    WHERE T2.Language = 'English'\n)"
        ],
        "rule_sql": [
            "SELECT SUM(\"Population\") \nFROM country \nWHERE \"Name\" NOT IN (\n    SELECT c.\"Name\" \n    FROM country c \n    JOIN countrylanguage cl ON c.\"Code\" = cl.\"CountryCode\" \n    WHERE cl.\"Language\" = \"English\"\n)"
        ]
    },
    "768": {
        "db_id": "world_1",
        "question": "What is the official language spoken in the country whose head of state is Beatrix?",
        "ground_truth": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.HeadOfState  =  \"Beatrix\" AND T2.IsOfficial  =  \"T\"",
        "amends": [
            "Do select `T2.Language` from the joined table instead of `language` from a single table. Do join `country AS T1` with `countrylanguage AS T2` on `T1.Code = T2.CountryCode` instead of querying only the `countries` table. Do add the filter `T2.IsOfficial = \"T\"` to ensure only official languages are returned instead of omitting this condition. Do use the correct table aliases and column references throughout the query instead of the simplified single-table approach. The amended query now correctly retrieves official languages from the joined tables matching the specified head of state condition."
        ],
        "rules": [
            "When answering about \"official language spoken in a country\": make sure the output order: T2.Language.",
            "When the question mentions \"head of state is Beatrix\": \"head of state\" actually means \"T1.HeadOfState = 'Beatrix'\" in schema.",
            "When combining T1 (country) and T2 (countrylanguage) for shared entities: link rows where T1.Code = T2.CountryCode and keep only matching pairs (inner match).",
            "When answering about \"official language spoken in a country\", When the question mentions \"head of state is Beatrix\", When combining T1 (country) and T2 (countrylanguage) for shared entities, When the question specifies \"official language\": add the filter T2.IsOfficial = \"T\" to ensure only official languages are returned."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT language FROM countries WHERE head_of_state = 'Beatrix';",
            "SELECT T2.Language \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T1.HeadOfState = 'Beatrix' \nAND T2.IsOfficial = 'T'"
        ],
        "rule_sql": [
            "SELECT T2.Language \nFROM country T1 \nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T1.HeadOfState = 'Beatrix' \nAND T2.IsOfficial = 'T'"
        ]
    },
    "769": {
        "db_id": "world_1",
        "question": "What is the official language used in the country the name of whose head of state is Beatrix.",
        "ground_truth": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.HeadOfState  =  \"Beatrix\" AND T2.IsOfficial  =  \"T\"",
        "amends": [
            "Do select `T2.Language` from the countrylanguage table instead of `language` from the countries table. Do join `country AS T1` with `countrylanguage AS T2` on `T1.Code = T2.CountryCode` instead of querying a single table. Do add the filter `T2.IsOfficial = \"T\"` to only include official languages instead of omitting this condition. Do reference the correct column name `HeadOfState` instead of `head_of_state`. The amended query now correctly retrieves official languages for countries where the head of state is Beatrix, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks about \"official language\": select \"T2.Language\" from the countrylanguage table instead of \"language\" from the countries table.",
            "When combining country and countrylanguage tables: join \"country AS T1\" with \"countrylanguage AS T2\" on \"T1.Code = T2.CountryCode\" to link countries with their languages.",
            "When filtering for official languages: add the condition \"T2.IsOfficial = \\\"T\\\"\" to only include official languages.",
            "When referencing the head of state: use the exact column name \"HeadOfState\" instead of \"head_of_state\".",
            "When the question asks about \"official language\", When combining country and countrylanguage tables, When filtering for official languages, When referencing the head of state, When filtering for head of state named Beatrix: use the exact literal value \"Beatrix\" with the correct case."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT language FROM countries WHERE head_of_state = 'Beatrix';",
            "SELECT T2.Language \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T1.HeadOfState = 'Beatrix' \nAND T2.IsOfficial = 'T'"
        ],
        "rule_sql": [
            "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T1.HeadOfState = 'Beatrix' AND T2.IsOfficial = 'T'"
        ]
    },
    "770": {
        "db_id": "world_1",
        "question": "What is the total number of unique official languages spoken in the countries that are founded before 1930?",
        "ground_truth": "SELECT count(DISTINCT T2.Language) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE  IndepYear  <  1930 AND T2.IsOfficial  =  \"T\"",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference `T2.Language` instead of `language` in the SELECT clause. Do join on `T1.Code = T2.CountryCode` instead of `countries.country_id = languages.country_id`. Do filter on `IndepYear < 1930` instead of `founded_year < 1930`. Do add the condition `T2.IsOfficial = \"T\"` instead of omitting it. The amended query now correctly counts distinct official languages for countries gaining independence before 1930, matching the intended behavior."
        ],
        "rules": [
            "When joining tables for countries and languages: link rows where T1.Code = T2.CountryCode and keep only matching pairs (inner match).",
            "When filtering for countries founded before 1930: use T1.IndepYear < 1930 instead of founded_year.",
            "When counting official languages: only include languages where T2.IsOfficial = \"T\".",
            "When counting unique languages: count distinct values of T2.Language.",
            "When joining tables for countries and languages, When filtering for countries founded before 1930, When counting official languages, When counting unique languages, When answering about \"total number of unique official languages\": make sure the output is a single count value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT language) FROM countries JOIN languages ON countries.country_id = languages.country_id WHERE founded_year < 1930;",
            "SELECT COUNT(DISTINCT T2.Language) \nFROM country T1 \nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T1.IndepYear < 1930 \nAND T2.IsOfficial = 'T'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT cl.Language) \nFROM country c\nINNER JOIN countrylanguage cl ON c.Code = cl.CountryCode\nWHERE c.IndepYear < 1930 \nAND cl.IsOfficial = 'T';"
        ]
    },
    "771": {
        "db_id": "world_1",
        "question": "For the countries founded before 1930, what is the total number of distinct official languages?",
        "ground_truth": "SELECT count(DISTINCT T2.Language) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE  IndepYear  <  1930 AND T2.IsOfficial  =  \"T\"",
        "amends": [
            "Do join `country` and `countrylanguage` tables with `INNER JOIN` on `T1.Code = T2.CountryCode` instead of querying only the `countries` table. Do filter on `IndepYear < 1930` instead of `year_founded < 1930` and add the condition `T2.IsOfficial = \"T\"` instead of omitting it. Do select `count(DISTINCT T2.Language)` from the joined table structure instead of `COUNT(DISTINCT language)` from a single table. The amended query now correctly counts distinct official languages for countries founded before 1930 by properly joining the relevant tables and applying the official language filter."
        ],
        "rules": [
            "When answering about \"countries founded before 1930\": use the condition \"T1.IndepYear < 1930\" instead of \"year_founded < 1930\".",
            "When counting distinct official languages: join \"country\" table as T1 and \"countrylanguage\" table as T2 using \"T1.Code = T2.CountryCode\" with inner match.",
            "When filtering for official languages: add the condition \"T2.IsOfficial = \\\"T\\\"\" to only count languages marked as official.",
            "When answering about \"countries founded before 1930\", When counting distinct official languages, When filtering for official languages, When counting distinct languages: use \"count(DISTINCT T2.Language)\" from the joined table structure."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT language) FROM countries WHERE year_founded < 1930;",
            "SELECT COUNT(DISTINCT T2.Language) \nFROM country T1 \nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T1.IndepYear < 1930 \nAND T2.IsOfficial = 'T'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T2.Language) \nFROM country T1 \nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T1.IndepYear < 1930 \nAND T2.IsOfficial = \"T\""
        ]
    },
    "772": {
        "db_id": "world_1",
        "question": "What are the countries that have greater surface area than any country in Europe?",
        "ground_truth": "SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  \"Europe\")",
        "amends": [
            "Do use `Name` instead of `name` for the column selection to match the correct case. Do use `SurfaceArea` instead of `surface_area` for the column reference in both the main query and subquery. Do use `Continent` instead of `continent` for the column reference in the subquery filter. Do use double quotes `\"Europe\"` instead of single quotes `'Europe'` for the string literal. Do use `MIN(SurfaceArea)` instead of `MAX(SurfaceArea)` in the subquery to find the minimum surface area instead of the maximum. The amended query now correctly identifies countries with surface area greater than the minimum surface area of European countries instead of the maximum, matching the intended behavior."
        ],
        "rules": [
            "When selecting country names: use \"Name\" instead of \"name\" to match the correct case.",
            "When referencing surface area: use \"SurfaceArea\" instead of \"surface_area\" for column references.",
            "When filtering by continent: use \"Continent\" instead of \"continent\" for column references.",
            "When using string literals for continents: use double quotes \"Europe\" instead of single quotes 'Europe'.",
            "When selecting country names, When referencing surface area, When filtering by continent, When using string literals for continents, When comparing surface areas to European countries: use MIN(SurfaceArea) instead of MAX(SurfaceArea) to find countries with surface area greater than the minimum surface area of European countries."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM country WHERE surface_area > (SELECT MAX(surface_area) FROM country WHERE continent = 'Europe')",
            "SELECT Name FROM country WHERE SurfaceArea > (SELECT MIN(SurfaceArea) FROM country WHERE Continent = \"Europe\")"
        ],
        "rule_sql": [
            "SELECT Name FROM country WHERE SurfaceArea > (SELECT MIN(SurfaceArea) FROM country WHERE Continent = \"Europe\")"
        ]
    },
    "773": {
        "db_id": "world_1",
        "question": "Which countries have greater area than that of any country in Europe?",
        "ground_truth": "SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  \"Europe\")",
        "amends": [
            "Do reference the correct table name `country` instead of `countries` in both the main query and subquery. Do use the correct column name `Name` instead of `name` for the country name. Do use the correct column name `SurfaceArea` instead of `area` for the surface area measurement. Do use the correct column name `Continent` instead of `continent` for the continent designation. Do use double quotes `\"Europe\"` instead of single quotes `'Europe'` for the string literal. Do use the `MIN` aggregate function `min(SurfaceArea)` instead of `MAX(area)` to find the smallest European country's surface area instead of the largest. The amended query now correctly identifies countries with surface area greater than the smallest European country rather than the largest."
        ],
        "rules": [
            "When the question asks about countries: use the table name \"country\" instead of \"countries\" and the column name \"Name\" for country names.",
            "When the question mentions \"area\": use the column name \"SurfaceArea\" for surface area measurements.",
            "When the question refers to \"Europe\": use the literal value \"Europe\" with double quotes for continent designation.",
            "When finding countries with greater area than any country in Europe: use the MIN aggregate function on \"SurfaceArea\" to find the smallest European country's surface area rather than the largest.",
            "When the question asks about countries, When the question mentions \"area\", When the question refers to \"Europe\", When finding countries with greater area than any country in Europe, When comparing surface areas: ensure the comparison is against the minimum surface area of European countries rather than the maximum."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM countries WHERE area > (SELECT MAX(area) FROM countries WHERE continent = 'Europe')",
            "SELECT Name FROM country WHERE SurfaceArea > (SELECT MIN(SurfaceArea) FROM country WHERE Continent = \"Europe\")"
        ],
        "rule_sql": [
            "SELECT Name FROM country WHERE SurfaceArea > (SELECT MIN(SurfaceArea) FROM country WHERE Continent = 'Europe')"
        ]
    },
    "774": {
        "db_id": "world_1",
        "question": "What are the African countries that have a  population less than any country in Asia?",
        "ground_truth": "SELECT Name FROM country WHERE Continent  =  \"Africa\"  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  \"Asia\")",
        "amends": [
            "Do use `max(population)` in the subquery instead of `MIN(population)` to compare African countries against the maximum population in Asia rather than the minimum. Do maintain the same column references `Name` and `Continent` with consistent capitalization and quotation style. Do preserve the same table structure and WHERE clause conditions with identical join semantics and filter logic. The amended query now correctly identifies African countries with populations smaller than the largest Asian country rather than comparing against the smallest Asian country, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for countries with population less than any country in Asia: compare against the maximum population in Asia rather than the minimum population in Asia.",
            "When referencing the continent column: use exact literal values 'Africa' and 'Asia' with the exact case and spelling as shown in the schema.",
            "When selecting country names: use the exact column name \"Name\" with the exact capitalization shown in the schema.",
            "When the question asks for countries with population less than any country in Asia, When referencing the continent column, When selecting country names, When comparing populations: use the population column from the country table to perform the comparison against the maximum Asian population."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM country WHERE continent = 'Africa' AND population < (SELECT MIN(population) FROM country WHERE continent = 'Asia')",
            "SELECT c.Name \nFROM country c \nWHERE c.Continent = 'Africa' \nAND c.Population < (SELECT MAX(Population) FROM country WHERE Continent = 'Asia')"
        ],
        "rule_sql": [
            "SELECT c.Name \nFROM country c \nWHERE c.Continent = 'Africa' \nAND c.Population < (SELECT MAX(Population) FROM country WHERE Continent = 'Asia')"
        ]
    },
    "775": {
        "db_id": "world_1",
        "question": "Which African countries have a smaller population than that of any country in Asia?",
        "ground_truth": "SELECT Name FROM country WHERE Continent  =  \"Africa\"  AND population  <  (SELECT min(population) FROM country WHERE Continent  =  \"Asia\")",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c1.name \nFROM country c1 \nWHERE c1.continent = 'Africa' \nAND c1.population < (SELECT MIN(population) FROM country WHERE continent = 'Asia')"
        ],
        "rule_sql": [
            "SELECT c.Name \nFROM country c \nWHERE c.Continent = 'Africa' \nAND c.Population < (\n    SELECT MIN(Population) \n    FROM country \n    WHERE Continent = 'Asia'\n)"
        ]
    },
    "776": {
        "db_id": "world_1",
        "question": "Which Asian countries have a population that is larger than any country in Africa?",
        "ground_truth": "SELECT Name FROM country WHERE Continent  =  \"Asia\"  AND population  >  (SELECT max(population) FROM country WHERE Continent  =  \"Africa\")",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM country WHERE continent = 'Asia' AND population > (SELECT MAX(population) FROM country WHERE continent = 'Africa')"
        ],
        "rule_sql": [
            "SELECT c.Name \nFROM country c \nWHERE c.Continent = 'Asia' \nAND c.Population > (SELECT MAX(africa.Population) FROM country africa WHERE africa.Continent = 'Africa')"
        ]
    },
    "777": {
        "db_id": "world_1",
        "question": "What are the Asian countries which have a population larger than that of any country in Africa?",
        "ground_truth": "SELECT Name FROM country WHERE Continent  =  \"Asia\"  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  \"Africa\")",
        "amends": [
            "Do use `min(population)` in the subquery instead of `MAX(population)` to find the smallest African country population rather than the largest. Do capitalize column names `Name` and `Continent` instead of lowercase `name` and `continent` to match the schema. Do use double quotes `\"Asia\"` and `\"Africa\"` instead of single quotes for string literals. The amended query now correctly identifies Asian countries with population greater than the smallest African country population rather than the largest, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for countries with population larger than any country in Africa: use the minimum population of African countries as the comparison threshold instead of the maximum population.",
            "When referring to the country name column: use the exact column name \"Name\" with double quotes and proper capitalization instead of lowercase \"name\".",
            "When referring to the continent column: use the exact column name \"Continent\" with double quotes and proper capitalization instead of lowercase \"continent\".",
            "When using continent string literals: use double quotes around \"Asia\" and \"Africa\" instead of single quotes to match the schema format.",
            "When the question asks for countries with population larger than any country in Africa, When referring to the country name column, When referring to the continent column, When using continent string literals, When comparing Asian countries to African population threshold: select countries where continent equals \"Asia\" and population is greater than the minimum population of countries where continent equals \"Africa\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM country WHERE continent = 'Asia' AND population > (SELECT MAX(population) FROM country WHERE continent = 'Africa')",
            "SELECT Name \nFROM country \nWHERE Continent = \"Asia\" \nAND Population > (SELECT MIN(Population) FROM country WHERE Continent = \"Africa\")"
        ],
        "rule_sql": [
            "SELECT \"Name\" FROM country WHERE \"Continent\" = \"Asia\" AND \"Population\" > (SELECT MIN(\"Population\") FROM country WHERE \"Continent\" = \"Africa\")"
        ]
    },
    "778": {
        "db_id": "world_1",
        "question": "What are the country codes for countries that do not speak English?",
        "ground_truth": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  \"English\"",
        "amends": [
            "Do query the `countrylanguage` table instead of the `countries` table. Do use `EXCEPT` to exclude English-speaking countries instead of a simple inequality filter. Do reference `CountryCode` instead of `country_code` and `LANGUAGE` instead of `language`. Do use double quotes around 'English' instead of single quotes. The amended query now correctly identifies country codes where English is not spoken by excluding those where it is spoken, matching the RIGHT_SQL's set-based logic."
        ],
        "rules": [
            "When answering about countries that do not speak English: query the \"countrylanguage\" table instead of the \"countries\" table.",
            "When excluding English-speaking countries: use EXCEPT to exclude countries where \"LANGUAGE\" equals \"English\" instead of a simple inequality filter.",
            "When referencing country codes: use \"CountryCode\" instead of \"country_code\" as the column name.",
            "When referencing languages: use \"LANGUAGE\" instead of \"language\" as the column name.",
            "When answering about countries that do not speak English, When excluding English-speaking countries, When referencing country codes, When referencing languages, When using the literal value for English: use double quotes around \"English\" instead of single quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country_code FROM countries WHERE language != 'English';",
            "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE Language = \"English\""
        ],
        "rule_sql": [
            "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE \"LANGUAGE\" = \"English\""
        ]
    },
    "779": {
        "db_id": "world_1",
        "question": "Return the country codes for countries that do not speak English.",
        "ground_truth": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  \"English\"",
        "amends": [
            "Do use `EXCEPT` to exclude countries where English is spoken instead of selecting countries where English is spoken. Do reference `CountryCode` with proper case instead of `countrycode` with lowercase. Do use double quotes for string literal `\"English\"` instead of single quotes. Do remove the `WHERE` clause filtering for English language instead of keeping it, as the logic now excludes rather than includes English-speaking countries. The amended query correctly identifies countries where English is not spoken by excluding those where it is spoken, matching the intended behavior.",
            "Do select `CountryCode` from `countrylanguage` instead of `Code` from `country` in the first query. Do remove the incorrect table reference to `country` and instead use `countrylanguage` as the source table for the initial selection. Do maintain the `EXCEPT` operation with the subquery that filters for `Language = \"English\"` from the same `countrylanguage` table instead of mixing different tables. The amended query now correctly identifies countries that don't speak English by comparing within the same dataset rather than across unrelated tables, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about countries that do not speak English: use EXCEPT to exclude countries where English is spoken instead of selecting countries where English is spoken.",
            "When referring to the country code column: use \"CountryCode\" with proper case instead of lowercase \"countrycode\".",
            "When handling the English language literal: use double quotes for \"English\" instead of single quotes.",
            "When answering about countries that do not speak English, When referring to the country code column, When handling the English language literal, When excluding English-speaking countries: remove the WHERE clause filtering for English language as the logic now excludes rather than includes English-speaking countries.",
            "When answering about countries that do not speak English: select \"CountryCode\" from \"countrylanguage\" table.",
            "When filtering for countries that don't speak English: use EXCEPT operation with a subquery that filters for \"Language\" = \"English\" from the same \"countrylanguage\" table.",
            "When comparing country codes: ensure both parts of the EXCEPT operation use the same \"CountryCode\" column from the \"countrylanguage\" table rather than mixing different tables.",
            "When answering about countries that do not speak English, When filtering for countries that don't speak English, When comparing country codes, When handling text literals: use exact literal \"English\" with proper case and double quotes for the language comparison."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT countrycode FROM countrylanguage WHERE language = 'English';",
            "SELECT Code FROM country EXCEPT SELECT CountryCode FROM countrylanguage WHERE Language = \"English\"",
            "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE Language = \"English\""
        ],
        "rule_sql": [
            "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE Language = \"English\""
        ]
    },
    "780": {
        "db_id": "world_1",
        "question": "What are the country codes of countries where people use languages other than English?",
        "ground_truth": "SELECT DISTINCT CountryCode FROM countrylanguage WHERE LANGUAGE != \"English\"",
        "amends": [
            "Do select `DISTINCT CountryCode` instead of `country_code` without distinct. Do use table `countrylanguage` instead of `countries`. Do filter with `LANGUAGE != \"English\"` instead of `language = 'English'`. The amended query now correctly returns unique country codes where the language is not English, matching the intended behavior."
        ],
        "rules": [
            "When answering about country codes where languages other than English are used: select distinct \"CountryCode\" from the countrylanguage table.",
            "When filtering for languages other than English: use the condition LANGUAGE != \"English\" with exact case and double quotes.",
            "When answering about country codes where languages other than English are used, When filtering for languages other than English, When the question asks for country codes: use the exact identifier \"CountryCode\" from the countrylanguage table, not country_code from countries."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country_code FROM countries WHERE language = 'English';",
            "SELECT DISTINCT CountryCode FROM countrylanguage WHERE Language != 'English';"
        ],
        "rule_sql": [
            "SELECT DISTINCT \"CountryCode\" FROM countrylanguage WHERE \"Language\" != \"English\""
        ]
    },
    "781": {
        "db_id": "world_1",
        "question": "Give the country codes for countries in which people speak langauges that are not English.",
        "ground_truth": "SELECT DISTINCT CountryCode FROM countrylanguage WHERE LANGUAGE != \"English\"",
        "amends": [
            "Do select `DISTINCT CountryCode` instead of `country_code` without distinct. Do query from `countrylanguage` table instead of `countries` table. Do filter with `LANGUAGE != \"English\"` instead of `language = 'English'`. Do use double quotes around string literal instead of single quotes. The amended query now correctly selects distinct country codes from the countrylanguage table where the language is not English, matching the intended behavior."
        ],
        "rules": [
            "When selecting country codes from the countrylanguage table: use DISTINCT \"CountryCode\" to get unique values.",
            "When filtering for languages that are not English: use LANGUAGE != \"English\" with double quotes around the literal.",
            "When selecting country codes from the countrylanguage table, When filtering for languages that are not English, When the question asks for countries where people speak languages that are not English: query from the countrylanguage table instead of the countries table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country_code FROM countries WHERE language = 'English';",
            "SELECT DISTINCT CountryCode FROM countrylanguage WHERE Language != \"English\""
        ],
        "rule_sql": [
            "SELECT DISTINCT \"CountryCode\" FROM countrylanguage WHERE \"Language\" != \"English\""
        ]
    },
    "782": {
        "db_id": "world_1",
        "question": "What are the codes of the countries that do not speak English and whose government forms are not Republic?",
        "ground_truth": "SELECT Code FROM country WHERE GovernmentForm != \"Republic\" EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  \"English\"",
        "amends": [
            "Do select `Code` from `country` instead of `CountryCode` from `CountryLanguage`. Do use `EXCEPT` to exclude countries with English language instead of filtering with `Language != 'English'`. Do move the `GovernmentForm != 'Republic'` filter to the first SELECT clause instead of including it in the WHERE clause of a single query. Do remove the incorrect join logic between country and countrylanguage tables instead of attempting to query them together without proper joins. Do add proper table separation with EXCEPT instead of combining filters in a single WHERE clause that creates incorrect semantics. The amended query now correctly identifies countries that are not republics and exclude those where English is spoken, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about country codes: select \"Code\" from the \"country\" table instead of \"CountryCode\" from \"countrylanguage\".",
            "When excluding countries that speak English: use EXCEPT to remove countries where English is spoken rather than filtering with Language != 'English'.",
            "When filtering for non-republic government forms: apply GovernmentForm != 'Republic' directly in the first SELECT clause.",
            "When combining country and countrylanguage data: use proper table separation with EXCEPT instead of incorrect join logic between tables.",
            "When answering about country codes, When excluding countries that speak English, When filtering for non-republic government forms, When combining country and countrylanguage data, When handling text literals: preserve exact case and spelling for 'English' and 'Republic'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT CountryCode FROM CountryLanguage WHERE Language != 'English' AND GovernmentForm != 'Republic';",
            "SELECT Code FROM country WHERE GovernmentForm != 'Republic'\nEXCEPT\nSELECT CountryCode FROM countrylanguage WHERE Language = 'English'"
        ],
        "rule_sql": [
            "SELECT Code FROM country WHERE GovernmentForm != 'Republic'\nEXCEPT\nSELECT CountryCode FROM countrylanguage WHERE Language = 'English'"
        ]
    },
    "783": {
        "db_id": "world_1",
        "question": "Return the codes of countries that do not speak English and do not have Republics for governments.",
        "ground_truth": "SELECT Code FROM country WHERE GovernmentForm != \"Republic\" EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  \"English\"",
        "amends": [
            "Do select `Code` instead of `code` and use `EXCEPT` to exclude English-speaking countries instead of filtering with `language != 'English'`. Do reference table `country` instead of `countries` and use `GovernmentForm` instead of `government`. Do remove the direct `language` filter from the WHERE clause and instead use a subquery with `EXCEPT` that selects from `countrylanguage` where `LANGUAGE = 'English'`. Do use proper column references `CountryCode` in the EXCEPT clause instead of attempting to filter language directly in the main query. The amended query now correctly excludes countries where English is spoken while maintaining the government form filter, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about country codes: make sure the output order: \"Code\" from table \"country\".",
            "When the question mentions \"countries\": use table \"country\" instead of \"countries\".",
            "When the question mentions \"speak English\": this means countries that appear in table \"countrylanguage\" where \"Language\" = 'English'.",
            "When excluding English-speaking countries: use EXCEPT operation to remove countries where \"CountryCode\" in \"countrylanguage\" matches \"Code\" in \"country\" and \"Language\" = 'English'.",
            "When the question mentions \"Republics for governments\": this means \"GovernmentForm\" = 'Republic' in table \"country\".",
            "When answering about country codes, When the question mentions \"countries\", When the question mentions \"speak English\", When excluding English-speaking countries, When the question mentions \"Republics for governments\", When filtering by government form: include only rows where \"GovernmentForm\" != 'Republic'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT code FROM countries WHERE language != 'English' AND government != 'Republic';",
            "SELECT Code FROM country WHERE GovernmentForm != 'Republic' EXCEPT SELECT CountryCode FROM countrylanguage WHERE Language = 'English'"
        ],
        "rule_sql": [
            "SELECT Code FROM country WHERE GovernmentForm != 'Republic' EXCEPT SELECT c.Code FROM country c JOIN countrylanguage cl ON c.Code = cl.CountryCode WHERE cl.Language = 'English'"
        ]
    },
    "784": {
        "db_id": "world_1",
        "question": "Which cities are in European countries where English is not the official language?",
        "ground_truth": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')",
        "amends": [
            "Do use `DISTINCT` on `T2.Name` instead of selecting `city_name` without deduplication. Do join `country AS T1` with `city AS T2` on `T2.CountryCode = T1.Code` instead of using a subquery with `IN` condition. Do filter with `T1.Continent = 'Europe'` instead of checking continent in a subquery. Do use `T1.Name NOT IN` with a correlated subquery checking official English language status through `countrylanguage` table instead of simple `official_language != 'English'` condition. Do add explicit table aliases `T1`, `T2`, `T3`, and `T4` instead of using unaliased table references. The amended query now correctly identifies European cities in countries where English is not an official language, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about cities in European countries where English is not the official language: make sure the output order includes T2.Name as the city name.",
            "When combining country table as T1 and city table as T2: link rows where T2.CountryCode = T1.Code and keep only matching pairs (inner match).",
            "When filtering for European countries: use T1.Continent = 'Europe' exactly as specified.",
            "When checking for English not being an official language: use T1.Name NOT IN with a correlated subquery through countrylanguage table instead of simple official_language comparison.",
            "When answering about cities in European countries where English is not the official language, When combining country table as T1 and city table as T2, When filtering for European countries, When checking for English not being an official language, When selecting city names: use DISTINCT on T2.Name to remove duplicate city entries."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city_name FROM cities WHERE country IN (SELECT country FROM countries WHERE continent = 'Europe' AND official_language != 'English')",
            "SELECT DISTINCT T2.Name\nFROM country AS T1\nJOIN city AS T2 ON T2.CountryCode = T1.Code\nWHERE T1.Continent = 'Europe'\nAND T1.Code NOT IN (\n    SELECT T3.CountryCode\n    FROM countrylanguage AS T3\n    WHERE T3.Language = 'English' AND T3.IsOfficial = 'T'\n)"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.Name \nFROM country T1 \nINNER JOIN city T2 ON T2.CountryCode = T1.Code \nWHERE T1.Continent = 'Europe' \nAND T1.Name NOT IN (\n    SELECT CountryCode \n    FROM countrylanguage \n    WHERE Language = 'English' AND IsOfficial = 'T'\n)\nORDER BY T2.Name"
        ]
    },
    "785": {
        "db_id": "world_1",
        "question": "What are the names of cities in Europe for which English is not the official language?",
        "ground_truth": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')",
        "amends": [
            "Do select `DISTINCT T2.Name` instead of `city_name` and use table `country AS T1` joined with `city AS T2` on `T2.CountryCode = T1.Code` instead of querying `cities` directly. Do filter with `T1.Continent = 'Europe'` instead of `continent = 'Europe'` and add a subquery condition `T1.Name NOT IN` instead of checking `official_language = 'English'`. The subquery correctly identifies countries where English is an official language by joining `country AS T3` with `countrylanguage AS T4` on `T3.Code = T4.CountryCode` and filtering for `T4.IsOfficial = 'T' AND T4.Language = 'English'`, ensuring only cities in European countries without English as an official language are returned. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about city names in Europe where English is not the official language: make sure the output order: T2.Name.",
            "When the question mentions \"cities\": \"cities\" actually means \"city AS T2\" in schema.",
            "When the question mentions \"Europe\": \"Europe\" actually means \"T1.Continent = 'Europe'\" in schema.",
            "When combining T1 and T2 for shared entities: link rows where T2.CountryCode = T1.Code exactly as shown in the amends; keep only matching pairs (inner match).",
            "When filtering for countries where English is not the official language: use a subquery condition T1.Name NOT IN (select T3.Name from country AS T3 join countrylanguage AS T4 on T3.Code = T4.CountryCode where T4.IsOfficial = 'T' AND T4.Language = 'English').",
            "When answering about city names in Europe where English is not the official language, When the question mentions \"cities\", When the question mentions \"Europe\", When combining T1 and T2 for shared entities, When filtering for countries where English is not the official language, When selecting city names: use DISTINCT T2.Name to ensure unique city names are returned."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city_name FROM cities WHERE continent = 'Europe' AND official_language = 'English';",
            "SELECT DISTINCT T2.Name \nFROM country AS T1 \nJOIN city AS T2 ON T2.CountryCode = T1.Code \nWHERE T1.Continent = 'Europe' \nAND T1.Name NOT IN (\n    SELECT T3.Name \n    FROM country AS T3 \n    JOIN countrylanguage AS T4 ON T3.Code = T4.CountryCode \n    WHERE T4.IsOfficial = 'T' AND T4.Language = 'English'\n)"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.Name \nFROM country AS T1 \nJOIN city AS T2 ON T2.CountryCode = T1.Code \nWHERE T1.Continent = 'Europe' \nAND T1.Name NOT IN (\n    SELECT T3.Name \n    FROM country AS T3 \n    JOIN countrylanguage AS T4 ON T3.Code = T4.CountryCode \n    WHERE T4.IsOfficial = 'T' AND T4.Language = 'English'\n)\nORDER BY T2.Name"
        ]
    },
    "786": {
        "db_id": "world_1",
        "question": "Which unique cities are in Asian countries where Chinese is the official language ?",
        "ground_truth": "select distinct t3.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode join city as t3 on t1.code  =  t3.countrycode where t2.isofficial  =  't' and t2.language  =  'chinese' and t1.continent  =  \"asia\"",
        "amends": [
            "Do select `t3.name` from the `city` table instead of `city` from the `cities` table. Do join three tables with `country as t1 JOIN countrylanguage as t2 ON t1.code = t2.countrycode JOIN city as t3 ON t1.code = t3.countrycode` instead of querying a single table. Do add filters for `t2.isofficial = 't'` and `t2.language = 'chinese'` instead of just `language = 'Chinese'`. Do use `t1.continent = \"asia\"` instead of `continent = 'Asia'`. The amended query now correctly retrieves city names where Chinese is an official language in Asian countries, matching the RIGHT_SQL's behavior.",
            "Do remove the `t1.Continent = 'Asia'` filter from the `WHERE` clause instead of keeping it there, and do add `t1.continent = \"asia\"` to the end of the `WHERE` clause instead of omitting it, while maintaining the same join structure with `JOIN countrylanguage as t2 ON t1.Code = t2.CountryCode` and `JOIN city as t3 ON t1.Code = t3.CountryCode`. The amended query now correctly filters for Asian countries while preserving the distinct city names where Chinese is an official language, matching the right SQL's behavior.",
            "Do use double quotes `\"asia\"` instead of single quotes `'Asia'` for the continent filter to match the case-sensitive value. The amended query now correctly returns distinct city names where Chinese is an official language in Asian countries, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"unique cities in Asian countries where Chinese is the official language\": make sure the output order: t3.name.",
            "When the question mentions \"cities\": \"cities\" actually means \"t3.name in city table\".",
            "When combining tables for shared entities: link rows where t1.code = t2.countrycode and t1.code = t3.countrycode; keep only matching pairs (inner match).",
            "When filtering for Asian countries: use t1.continent = \"asia\" exactly as specified.",
            "When filtering for official Chinese language: use t2.isofficial = 't' and t2.language = 'chinese' exactly as specified.",
            "When answering about \"unique cities in Asian countries where Chinese is the official language\", When the question mentions \"cities\", When combining tables for shared entities, When filtering for Asian countries, When filtering for official Chinese language, When selecting unique cities: return distinct values of t3.name.",
            "When the question asks for cities in Asian countries where Chinese is the official language: use \"asia\" (lowercase) as the continent filter value instead of 'Asia' (title case).",
            "When filtering by continent in the country table: use the exact identifier \"continent\" (lowercase) instead of \"Continent\" (title case).",
            "When combining country, countrylanguage, and city tables: link rows where country.Code equals countrylanguage.CountryCode and country.Code equals city.CountryCode, keeping only matching pairs (inner match).",
            "When filtering for official languages: use the exact literal 'T' for the IsOfficial column and 'Chinese' for the Language column.",
            "When the question asks for cities in Asian countries where Chinese is the official language, When filtering by continent in the country table, When combining country, countrylanguage, and city tables, When filtering for official languages, When selecting unique city names: use DISTINCT on the city.Name column to return only distinct city names.",
            "When filtering by continent in the country table: use the exact literal value \"asia\" (lowercase) instead of 'Asia' to match case-sensitive data.",
            "When answering about unique cities in Asian countries where Chinese is the official language: make sure the output order includes only distinct city names from the city table.",
            "When combining country, countrylanguage, and city tables: link rows where country.Code equals countrylanguage.CountryCode and country.Code equals city.CountryCode, keeping only matching pairs (inner match).",
            "When filtering for official languages: use the exact literal value 'T' for the IsOfficial column in countrylanguage table.",
            "When filtering by continent in the country table, When answering about unique cities in Asian countries where Chinese is the official language, When combining country, countrylanguage, and city tables, When filtering for official languages, When filtering for Chinese language: use the exact literal value 'Chinese' for the Language column in countrylanguage table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT city FROM cities WHERE continent = 'Asia' AND language = 'Chinese';",
            "SELECT DISTINCT t3.Name \nFROM country as t1 \nJOIN countrylanguage as t2 ON t1.Code = t2.CountryCode \nJOIN city as t3 ON t1.Code = t3.CountryCode \nWHERE t1.Continent = 'Asia' \nAND t2.IsOfficial = 'T' \nAND t2.Language = 'Chinese'",
            "SELECT DISTINCT t3.Name \nFROM country as t1 \nJOIN countrylanguage as t2 ON t1.Code = t2.CountryCode \nJOIN city as t3 ON t1.Code = t3.CountryCode \nWHERE t2.IsOfficial = 'T' \nAND t2.Language = 'Chinese' \nAND t1.Continent = 'Asia'",
            "SELECT DISTINCT t3.Name \nFROM country as t1 \nJOIN countrylanguage as t2 ON t1.Code = t2.CountryCode \nJOIN city as t3 ON t1.Code = t3.CountryCode \nWHERE t2.IsOfficial = 'T' \nAND t2.Language = 'Chinese' \nAND t1.Continent = \"asia\""
        ],
        "rule_sql": [
            "SELECT DISTINCT t3.Name \nFROM country t1 \nINNER JOIN countrylanguage t2 ON t1.Code = t2.CountryCode \nINNER JOIN city t3 ON t1.Code = t3.CountryCode \nWHERE t1.continent = 'asia' \nAND t2.IsOfficial = 'T' \nAND t2.Language = 'Chinese' \nORDER BY t3.Name;"
        ]
    },
    "787": {
        "db_id": "world_1",
        "question": "Return the different names of cities that are in Asia and for which Chinese is the official language.",
        "ground_truth": "SELECT DISTINCT T3.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode JOIN city AS T3 ON T1.Code  =  T3.CountryCode WHERE T2.IsOfficial  =  'T' AND T2.Language  =  'Chinese' AND T1.Continent  =  \"Asia\"",
        "amends": [
            "Do select `DISTINCT T3.Name` instead of `city_name` to return unique city names. Do join three tables `country AS T1`, `countrylanguage AS T2`, and `city AS T3` instead of querying only `cities` table. Do use `JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode` with condition `T2.IsOfficial = 'T'` instead of filtering by `official_language = 'Chinese'` to properly identify official languages. Do add `JOIN city AS T3 ON T1.Code = T3.CountryCode` to connect cities to countries instead of assuming city table contains all necessary data. Do filter with `T1.Continent = 'Asia'` instead of `continent = 'Asia'` to use the correct table's continent field. Do add condition `T2.Language = 'Chinese'` to specifically filter for Chinese language instead of relying on a single language filter. The amended query now correctly identifies Asian cities where Chinese is an official language by properly joining country, language, and city tables with appropriate filtering conditions."
        ],
        "rules": [
            "When answering about cities in Asia with Chinese as official language: join three tables using country as T1, countrylanguage as T2, and city as T3.",
            "When combining T1 and T2: link rows where T1.Code = T2.CountryCode and T2.IsOfficial = 'T' to identify official languages.",
            "When combining T1 and T3: link rows where T1.Code = T3.CountryCode to connect cities to countries.",
            "When filtering for Asian countries: use T1.Continent = 'Asia' to identify Asian countries.",
            "When filtering for Chinese language: use T2.Language = 'Chinese' to specifically identify Chinese language.",
            "When answering about cities in Asia with Chinese as official language, When combining T1 and T2, When combining T1 and T3, When filtering for Asian countries, When filtering for Chinese language, When returning city names: select DISTINCT T3.Name to return unique city names instead of city_name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city_name FROM cities WHERE continent = 'Asia' AND official_language = 'Chinese';",
            "SELECT DISTINCT T3.Name \nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nJOIN city AS T3 ON T1.Code = T3.CountryCode\nWHERE T1.Continent = 'Asia' \nAND T2.Language = 'Chinese' \nAND T2.IsOfficial = 'T'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T3.Name\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode AND T2.IsOfficial = 'T'\nJOIN city AS T3 ON T1.Code = T3.CountryCode\nWHERE T1.Continent = 'Asia'\nAND T2.Language = 'Chinese'"
        ]
    },
    "788": {
        "db_id": "world_1",
        "question": "What are the name, independence year, and surface area of the country with the smallest population?",
        "ground_truth": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1",
        "amends": [
            "Do select `Name`, `SurfaceArea`, and `IndepYear` instead of `name`, `indep_year`, and `surface_area` to match the correct column names. Do order by `Population` in ascending order instead of `population DESC` to get the smallest population record. Do use table name `country` instead of `countries` to reference the correct source table. The amended query now correctly retrieves the country with the smallest population using the proper table and column names.",
            "Do reorder the SELECT list to `Name, SurfaceArea, IndepYear` instead of `Name, IndepYear, SurfaceArea`. Do remove the `ASC` keyword from the ORDER BY clause instead of keeping it, as ASC is the default sort order. The amended query now correctly matches the RIGHT_SQL's behavior with the proper column sequence and simplified ordering."
        ],
        "rules": [
            "When selecting country information: use the exact column names \"Name\", \"SurfaceArea\", and \"IndepYear\" from the country table.",
            "When finding the country with the smallest population: order by \"Population\" in ascending order to get the minimum value.",
            "When selecting country information, When finding the country with the smallest population, When referencing the source table: use the exact table name \"country\" instead of any variations like \"countries\".",
            "When answering about \"the country with the smallest population\": rank rows by \"Population\" in ascending order and keep the first 1 row.",
            "When producing output columns: make sure the output order is \"Name\", \"SurfaceArea\", \"IndepYear\" exactly as specified in the question sequence.",
            "When answering about \"the country with the smallest population\", When producing output columns, When ordering by population: do not explicitly specify ASC as it is the default sort order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, indep_year, surface_area FROM countries ORDER BY population DESC LIMIT 1;",
            "SELECT Name, IndepYear, SurfaceArea FROM country ORDER BY Population ASC LIMIT 1;",
            "SELECT Name, SurfaceArea, IndepYear FROM country ORDER BY Population LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name, SurfaceArea, IndepYear FROM country ORDER BY Population LIMIT 1;"
        ]
    },
    "789": {
        "db_id": "world_1",
        "question": "Give the name, year of independence, and surface area of the country that has the lowest population.",
        "ground_truth": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1",
        "amends": [
            "Do use column names `Name`, `SurfaceArea`, and `IndepYear` instead of `name`, `surfacearea`, and `indepyear` to match the correct case sensitivity. Do order by `Population` in ascending order instead of `population DESC` to get the smallest population instead of the largest. The amended query now correctly retrieves the country with the smallest population while maintaining the same column selection and limit behavior.",
            "Do reorder the SELECT list to `Name, SurfaceArea, IndepYear` instead of `Name, IndepYear, SurfaceArea`. Do remove the explicit `ASC` direction from `ORDER BY Population` instead of keeping it, as ASC is the default ordering. The amended query now correctly matches the RIGHT_SQL's behavior with the proper column sequence and simplified ordering syntax."
        ],
        "rules": [
            "When choosing column names: use exact case-sensitive identifiers \"Name\", \"IndepYear\", and \"SurfaceArea\" instead of lowercase versions.",
            "When ordering by population to find the lowest value: sort by \"Population\" in ascending order instead of descending order.",
            "When choosing column names, When ordering by population to find the lowest value, When retrieving the country with the smallest population: maintain the limit of 1 row to get only the single result with the minimum population value.",
            "When answering about \"name, year of independence, and surface area\": make sure the output order: Name, SurfaceArea, IndepYear.",
            "When the question asks for the country with the lowest population: rank rows by Population in ascending order and keep the first 1 row.",
            "When answering about \"name, year of independence, and surface area\", When the question asks for the country with the lowest population, When ordering by Population: do not specify ASC direction explicitly as it is the default ordering."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, indepyear, surfacearea FROM country ORDER BY population DESC LIMIT 1;",
            "SELECT Name, IndepYear, SurfaceArea FROM country ORDER BY Population ASC LIMIT 1;",
            "SELECT Name, SurfaceArea, IndepYear FROM country ORDER BY Population LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name, SurfaceArea, IndepYear FROM country ORDER BY Population LIMIT 1;"
        ]
    },
    "790": {
        "db_id": "world_1",
        "question": "What are the population, name and leader of the country with the largest area?",
        "ground_truth": "SELECT Name ,  population ,  HeadOfState FROM country ORDER BY SurfaceArea DESC LIMIT 1",
        "amends": [
            "Do select `Name`, `population`, and `HeadOfState` instead of `population`, `name`, and `leader`. Do reference table `country` instead of `countries`. Do order by `SurfaceArea` instead of `area`. The amended query now correctly selects the appropriate columns from the right table with proper column names and ordering criteria."
        ],
        "rules": [
            "When answering about \"country with the largest area\": use table \"country\" instead of \"countries\".",
            "When selecting columns for population, name, and leader: use exact column tokens \"Name\", \"population\", and \"HeadOfState\" respectively.",
            "When ordering by area to find the largest: use column \"SurfaceArea\" instead of \"area\" and order in descending direction.",
            "When answering about \"country with the largest area\", When selecting columns for population, name, and leader, When ordering by area to find the largest, When retrieving the top result: keep only the first row after ordering by \"SurfaceArea\" in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT population, name, leader FROM countries ORDER BY area DESC LIMIT 1;",
            "SELECT Name, Population, HeadOfState FROM country ORDER BY SurfaceArea DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name, Population, HeadOfState FROM country ORDER BY SurfaceArea DESC LIMIT 1;"
        ]
    },
    "791": {
        "db_id": "world_1",
        "question": "Give the name, population, and head of state for the country that has the largest area.",
        "ground_truth": "SELECT Name ,  population ,  HeadOfState FROM country ORDER BY SurfaceArea DESC LIMIT 1",
        "amends": [
            "Do use column `Name` instead of `name`, `HeadOfState` instead of `head_of_state`, and `SurfaceArea` instead of `area` in the ORDER BY clause, while keeping the same SELECT list structure and LIMIT 1. The amended query now correctly references the proper column names and ordering criteria to match the intended behavior."
        ],
        "rules": [
            "When the question asks for \"name\": use the exact column token \"Name\" from table country.",
            "When the question asks for \"head of state\": use the exact column token \"HeadOfState\" from table country.",
            "When the question asks for the country with \"largest area\": use the exact column token \"SurfaceArea\" for ordering in descending direction and keep only the first row.",
            "When the question asks for \"name\", When the question asks for \"head of state\", When the question asks for the country with \"largest area\", When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for column names like \"Name\", \"HeadOfState\", and \"SurfaceArea\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, population, head_of_state FROM country ORDER BY area DESC LIMIT 1;",
            "SELECT Name, Population, HeadOfState FROM country ORDER BY SurfaceArea DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT \"Name\", \"Population\", \"HeadOfState\" FROM country ORDER BY \"SurfaceArea\" DESC LIMIT 1;"
        ]
    },
    "792": {
        "db_id": "world_1",
        "question": "Return the country name and the numbers of languages spoken for each country that speaks at least 3 languages.",
        "ground_truth": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2",
        "amends": [
            "Do use `COUNT(T2.Language)` instead of `COUNT(language.language)` to reference the joined table correctly. Do use table aliases `T1` and `T2` instead of full table names for clarity. Do reference `T1.Name` in the SELECT list instead of `country.name` to match the aliased table. Do group by `T1.Name` instead of `country.code` to ensure proper aggregation with the selected column. Do change the HAVING condition to `COUNT(*) > 2` instead of `num_languages >= 3` to use the actual count value rather than the alias. The amended query now correctly counts languages per country and filters for countries with more than 2 languages, matching the RIGHT_SQL's behavior.",
            "Do place `T1.Name` after the aggregate in the SELECT list instead of before it, maintaining the same column order as the original. Do use explicit table aliases with `AS` for both tables instead of omitting them. Do keep the same join condition `T1.Code = T2.CountryCode`, grouping by `T1.Name`, and HAVING clause `COUNT(*) > 2` unchanged. The amended query now correctly matches the RIGHT_SQL's behavior with proper column ordering and explicit alias syntax.",
            "Do place `COUNT(T2.Language)` before `T1.Name` in the SELECT list instead of the reverse order. Do maintain the same JOIN condition `T1.Code = T2.CountryCode` and GROUP BY `T1.Name` with the identical HAVING clause `COUNT(*) > 2`. The amended query now matches RIGHT_SQL's behavior with the correct column ordering while preserving all logical operations."
        ],
        "rules": [
            "When answering about \"country name and number of languages spoken\": make sure the output order: T1.Name, COUNT(T2.Language).",
            "When the question mentions \"country\": use table T1 (country) with column T1.Name for country names.",
            "When the question mentions \"languages spoken\": use table T2 (countrylanguage) with column T2.Language for languages.",
            "When combining T1 and T2 for shared entities: link rows where T1.code = T2.countrycode and keep only matching pairs (inner match).",
            "When the question asks for \"count of languages\": compute the number of rows using T2.Language.",
            "When the question says \"per country\": organize results by T1.Name and compute COUNT(T2.Language) per group.",
            "When the question specifies \"at least 3 languages\": filter groups where COUNT(*) > 2.",
            "When answering about \"country name and number of languages spoken\", When the question mentions \"country\", When the question mentions \"languages spoken\", When combining T1 and T2 for shared entities, When the question asks for \"count of languages\", When the question says \"per country\", When the question specifies \"at least 3 languages\", When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms.",
            "When answering about \"country name and numbers of languages spoken for each country that speaks at least 3 languages\": make sure the output order: T1.Name, COUNT(T2.Language) AS num_languages.",
            "When combining country T1 and countrylanguage T2 for shared entities: link rows where T1.Code = T2.CountryCode exactly as shown in the amends; keep only matching pairs (inner match).",
            "When the question asks for \"count of languages spoken per country\": organize results by T1.Name and compute COUNT(T2.Language) per group.",
            "When the question specifies \"at least 3 languages\": apply the condition COUNT(*) > 2 to filter groups.",
            "When answering about \"country name and numbers of languages spoken for each country that speaks at least 3 languages\", When combining country T1 and countrylanguage T2 for shared entities, When the question asks for \"count of languages spoken per country\", When the question specifies \"at least 3 languages\", When using table aliases: use explicit aliases with AS for both tables (T1 AS country, T2 AS countrylanguage) instead of omitting them.",
            "When answering about \"Return the country name and the numbers of languages spoken for each country that speaks at least 3 languages\": make sure the output order: COUNT(T2.Language) before T1.Name.",
            "When combining T1 and T2 for shared entities: link rows where T1.Code = T2.CountryCode; keep only matching pairs (inner match).",
            "When the question says \"per country\"/\"by country\": organize results by T1.Name and compute requested aggregates per group.",
            "When the question asks for \"numbers of languages spoken\": compute the number of rows using T2.Language.",
            "When answering about \"Return the country name and the numbers of languages spoken for each country that speaks at least 3 languages\", When combining T1 and T2 for shared entities, When the question says \"per country\"/\"by country\", When the question asks for \"numbers of languages spoken\", When the question specifies \"at least 3 languages\": filter groups where COUNT(*) > 2."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country.name, COUNT(language.language) as num_languages \nFROM country \nJOIN countrylanguage ON country.code = countrylanguage.countrycode \nGROUP BY country.code \nHAVING num_languages >= 3;",
            "SELECT T1.Name, COUNT(T2.Language) AS num_languages\nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Name\nHAVING COUNT(*) > 2",
            "SELECT T1.Name, COUNT(T2.Language) \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nGROUP BY T1.Name \nHAVING COUNT(*) > 2",
            "SELECT COUNT(T2.Language), T1.Name \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nGROUP BY T1.Name \nHAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT T1.Name, COUNT(T2.Language) AS num_languages\nFROM country AS T1\nINNER JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Name\nHAVING COUNT(*) > 2\nORDER BY COUNT(T2.Language), T1.Name"
        ]
    },
    "793": {
        "db_id": "world_1",
        "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?",
        "ground_truth": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2",
        "amends": [
            "Do use `COUNT(T2.Language)` instead of `COUNT(language.language)` to reference the correct table alias. Do use table aliases `T1` and `T2` instead of full table names throughout the query. Do reference `T1.Name` in the SELECT list instead of `country.name` for consistency with aliases. Do specify `T1.Code = T2.CountryCode` in the JOIN condition instead of `country.code = countrylanguage.countrycode` using proper aliases. Do use `COUNT(*) > 2` in the HAVING clause instead of `language_count > 2` to directly reference the aggregate function rather than the column alias. The amended query now correctly counts languages per country using proper table aliases and direct aggregate references in the HAVING clause.",
            "Do place `COUNT(T2.Language)` before `T1.Name` in the SELECT list instead of the reverse order. Do remove the `AS language_count` alias instead of keeping it. Do remove the `ORDER BY language_count DESC` clause instead of including it. The amended query now matches RIGHT_SQL's behavior by maintaining the same logical grouping and filtering while removing the ordering and column alias.",
            "Do place `COUNT(T2.Language)` first in the SELECT list instead of `T1.Name` first. Do use `COUNT(*)` in the HAVING clause instead of `COUNT(T2.Language)` to count all rows rather than non-null language values specifically. The amended query now correctly counts all country-language relationships and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"names of countries that speak more than 2 languages\": make sure the output order: T1.Name, COUNT(T2.Language)",
            "When combining T1 and T2 for shared entities: link rows where T1.Code = T2.CountryCode; keep only matching pairs (inner match)",
            "When the question asks for \"how many languages they speak\": compute the number of rows using COUNT(T2.Language)",
            "When the question says \"per country\"/\"by country\": organize results by T1.Name and compute COUNT(T2.Language) per group",
            "When answering about \"names of countries that speak more than 2 languages\", When combining T1 and T2 for shared entities, When the question asks for \"how many languages they speak\", When the question says \"per country\"/\"by country\", When filtering for countries that speak more than 2 languages: apply the condition COUNT(*) > 2 after grouping",
            "When answering about \"names of countries that speak more than 2 languages, as well as how many languages they speak\": make sure the output order: COUNT(T2.Language) first, then T1.Name.",
            "When the question asks for \"how many languages they speak\": compute the count of T2.Language without using an alias.",
            "When answering about \"names of countries that speak more than 2 languages, as well as how many languages they speak\", When the question asks for \"how many languages they speak\", When the question asks for results without ordering: do not include any ORDER BY clause in the output.",
            "When answering about \"names of countries that speak more than 2 languages, as well as how many languages they speak\": make sure the output order: COUNT(T2.Language) first, then T1.Name.",
            "When answering about \"names of countries that speak more than 2 languages, as well as how many languages they speak\", When counting languages spoken by countries: use COUNT(*) in the HAVING clause instead of COUNT(T2.Language) to count all rows rather than non-null language values specifically."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country.name, COUNT(language.language) as language_count \nFROM country \nJOIN countrylanguage ON country.code = countrylanguage.countrycode \nGROUP BY country.name \nHAVING language_count > 2;",
            "SELECT T1.Name, COUNT(T2.Language) AS language_count\nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Name\nHAVING COUNT(*) > 2\nORDER BY language_count DESC;",
            "SELECT T1.Name, COUNT(T2.Language) \nFROM country T1 \nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nGROUP BY T1.Name \nHAVING COUNT(T2.Language) > 2",
            "SELECT COUNT(T2.Language), T1.Name \nFROM country T1 \nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nGROUP BY T1.Code \nHAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT COUNT(*), country.Name FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode GROUP BY country.Name HAVING COUNT(*) > 2"
        ]
    },
    "794": {
        "db_id": "world_1",
        "question": "Find the number of cities in each district whose population is greater than the average population of cities?",
        "ground_truth": "SELECT count(*) ,  District FROM city WHERE Population  >  (SELECT avg(Population) FROM city) GROUP BY District",
        "amends": [
            "Do use `count(*)` without an alias instead of `COUNT(*) AS city_count`. Do capitalize `District` in the SELECT list instead of lowercase `district`. Do capitalize `Population` in the WHERE clause instead of lowercase `population`. Do capitalize `avg(Population)` in the subquery instead of `AVG(population)`. Do capitalize `District` in the GROUP BY clause instead of lowercase `district`. The amended query now correctly matches the RIGHT_SQL's behavior with proper column capitalization and alias handling.",
            "Do place `count(*)` before `District` in the SELECT list instead of having `District` first. Do use lowercase `avg(Population)` in the subquery instead of uppercase `AVG(Population)`. Do maintain the same WHERE filter using `Population >` with the subquery calculating the average population, and preserve the GROUP BY `District` clause. The amended query now correctly returns the count of cities by district where population exceeds the average, matching the right SQL's behavior."
        ],
        "rules": [
            "When the question asks for \"number of cities in each district\": organize results by the exact token \"District\" and compute the count of cities per group.",
            "When the question mentions \"population is greater than the average population\": filter rows where the exact token \"Population\" is greater than the average value of \"Population\" across all cities.",
            "When counting cities: use count(*) without an alias to count the number of rows.",
            "When the question asks for \"number of cities in each district\", When the question mentions \"population is greater than the average population\", When counting cities, When referring to column identifiers: capitalize \"District\" in both SELECT and GROUP BY clauses, and capitalize \"Population\" in both WHERE clause and subquery.",
            "When answering about \"number of cities in each district whose population is greater than average\": make sure the output order: count(*) first, then District.",
            "When calculating average population: use lowercase avg(Population) instead of uppercase AVG(Population).",
            "When filtering cities by population: use Population > (subquery calculating average population) to find cities with population greater than the average.",
            "When answering about \"number of cities in each district whose population is greater than average\", When calculating average population, When filtering cities by population, When grouping results by district: use GROUP BY District to organize counts per district."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT district, COUNT(*) AS city_count\nFROM city\nWHERE population > (SELECT AVG(population) FROM city)\nGROUP BY district;",
            "SELECT District, COUNT(*) FROM city WHERE Population > (SELECT AVG(Population) FROM city) GROUP BY District;",
            "SELECT count(*), District FROM city WHERE Population > (SELECT avg(Population) FROM city) GROUP BY District"
        ],
        "rule_sql": [
            "SELECT count(*), District FROM city WHERE Population > (SELECT avg(Population) FROM city) GROUP BY District"
        ]
    },
    "795": {
        "db_id": "world_1",
        "question": "How many cities in each district have a population that is above the average population across all cities?",
        "ground_truth": "SELECT count(*) ,  District FROM city WHERE Population  >  (SELECT avg(Population) FROM city) GROUP BY District",
        "amends": [
            "Do use `count(*)` without an alias instead of `COUNT(*) as city_count`. Do capitalize `District` in the SELECT list instead of lowercase `district`. Do capitalize `Population` in the WHERE clause instead of lowercase `population`. Do capitalize `avg(Population)` in the subquery instead of `AVG(population)`. Do capitalize `District` in the GROUP BY clause instead of lowercase `district`. The amended query now correctly matches the behavior of the RIGHT_SQL with proper column capitalization while maintaining the same logical structure for counting cities by district where population exceeds the average.",
            "Do place `count(*)` before `District` in the SELECT list instead of the reverse order. Do maintain the same aggregate function `COUNT(*)` and grouping column `District` instead of changing them. Do keep the same FROM source `city` instead of modifying it. Do preserve the WHERE filter comparing `Population` to the subquery result instead of altering it. Do retain the identical subquery calculating `avg(Population)` from `city` instead of modifying it. Do maintain the GROUP BY clause on `District` instead of changing it. The amended query now matches RIGHT_SQL's behavior with identical logic despite the column ordering difference in the SELECT clause."
        ],
        "rules": [
            "When the question asks for \"cities in each district\": organize results by the exact column token \"District\" from table city and compute counts per group.",
            "When the question mentions \"population\": \"population\" actually means column \"Population\" in table country.",
            "When combining city and country tables for population data: link rows where the canonical keys are equal as shown in the schema (city and country join condition); keep only matching pairs (inner match).",
            "When counting cities: compute the number of rows using the canonical key for cities.",
            "When filtering for population above average: compare \"Population\" values against the average of all \"Population\" values from country table.",
            "When the question asks for \"cities in each district\", When the question mentions \"population\", When combining city and country tables for population data, When counting cities, When filtering for population above average, When producing output: make sure the output order is \"District\" followed by the count.",
            "When answering about \"How many cities in each district have a population that is above the average population across all cities?\": make sure the output order: count(*) before District.",
            "When the question asks for \"count of cities\": compute the number of rows using the canonical key for cities.",
            "When the question says \"per district\"/\"by district\": organize results by the token for District and compute requested aggregates per group.",
            "When answering about \"How many cities in each district have a population that is above the average population across all cities?\", When the question asks for \"count of cities\", When the question says \"per district\"/\"by district\", When the question asks for cities with population above average: filter rows where Population > (SELECT AVG(Population) FROM city) instead of altering this condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT district, COUNT(*) as city_count\nFROM city\nWHERE population > (SELECT AVG(population) FROM city)\nGROUP BY district;",
            "SELECT District, COUNT(*) \nFROM city \nWHERE Population > (SELECT AVG(Population) FROM city) \nGROUP BY District",
            "SELECT count(*), District FROM city WHERE Population > (SELECT avg(Population) FROM city) GROUP BY District"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS city_count, c.District \nFROM city c\nJOIN country co ON c.CountryCode = co.Code\nWHERE c.Population > (SELECT AVG(Population) FROM city)\nGROUP BY c.District\nORDER BY city_count DESC, c.District;"
        ]
    },
    "796": {
        "db_id": "world_1",
        "question": "Find the government form name and total population for each government form whose average life expectancy is longer than 72.",
        "ground_truth": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72",
        "amends": [
            "Do use `HAVING avg(LifeExpectancy) > 72` instead of `WHERE lifeexpectancy > 72` to filter after aggregation rather than before. Do place `GovernmentForm` after the aggregate instead of before it in the SELECT list. Do remove the alias `total_population` instead of keeping it. Do use uppercase column names `Population` and `GovernmentForm` instead of lowercase versions. The amended query now correctly filters groups based on average life expectancy rather than filtering individual rows, matching the RIGHT_SQL's behavior.",
            "Do place `GovernmentForm` after the aggregate function instead of before it in the SELECT list. Do use lowercase `sum` and `avg` functions instead of uppercase `SUM` and `AVG`. The amended query now correctly calculates the total population by government form while filtering for those with average life expectancy exceeding 72, matching the intended behavior.",
            "Do place `GovernmentForm` after `sum(Population)` in the SELECT list instead of before it, maintaining the same aggregation logic and HAVING clause with `avg(LifeExpectancy) > 72` unchanged. The amended query now matches RIGHT_SQL's behavior with identical column ordering."
        ],
        "rules": [
            "When the question asks for average life expectancy by government form: use HAVING avg(LifeExpectancy) > 72 instead of WHERE lifeexpectancy > 72 to filter after aggregation rather than before.",
            "When selecting output columns: place GovernmentForm after the aggregate instead of before it in the output order.",
            "When computing total population: use SUM(Population) without an alias instead of using total_population.",
            "When the question asks for average life expectancy by government form, When selecting output columns, When computing total population, When referring to column names: use uppercase Population and GovernmentForm instead of lowercase versions to match the schema exactly.",
            "When the question asks for \"government form name and total population\": make sure the output order: total population first, then government form name.",
            "When using aggregate functions: use lowercase function names like \"sum\" and \"avg\" instead of uppercase \"SUM\" and \"AVG\".",
            "When the question asks for \"government form name and total population\", When using aggregate functions, When filtering groups by aggregate conditions: apply the condition \"avg(LifeExpectancy) > 72\" after grouping to only include government forms with average life expectancy longer than 72.",
            "When answering about \"government form name and total population for each government form whose average life expectancy is longer than 72\": make sure the output order: sum(Population) first, then GovernmentForm.",
            "When the question asks for \"total population\": compute the sum of Population values.",
            "When the question asks for \"average life expectancy is longer than 72\": filter groups where the average of LifeExpectancy is greater than 72.",
            "When answering about \"government form name and total population for each government form whose average life expectancy is longer than 72\", When the question asks for \"total population\", When the question asks for \"average life expectancy is longer than 72\", When the question says \"for each government form\": organize results by GovernmentForm and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT governmentform, SUM(population) as total_population \nFROM country \nWHERE lifeexpectancy > 72 \nGROUP BY governmentform;",
            "SELECT GovernmentForm, SUM(Population) FROM country GROUP BY GovernmentForm HAVING AVG(LifeExpectancy) > 72",
            "SELECT GovernmentForm, sum(Population) FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy) > 72",
            "SELECT sum(Population), GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy) > 72"
        ],
        "rule_sql": [
            "SELECT sum(Population), GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy) > 72"
        ]
    },
    "797": {
        "db_id": "world_1",
        "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?",
        "ground_truth": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72",
        "amends": [
            "Do move the LifeExpectancy filter to `HAVING avg(LifeExpectancy) > 72` instead of `WHERE LifeExpectancy > 72` to filter groups by average life expectancy rather than individual rows. Do change the SELECT clause order to `sum(Population), GovernmentForm` instead of `GovernmentForm, SUM(Population) as TotalPopulation`, removing the alias while maintaining the same aggregation logic. The amended query now correctly filters government forms based on their average life expectancy rather than excluding individual countries, matching the RIGHT_SQL's behavior.",
            "Do place `GovernmentForm` after the aggregate function instead of before it in the SELECT list. Do use lowercase `sum` and `avg` functions instead of uppercase `SUM` and `AVG`. Do maintain the same GROUP BY clause on `GovernmentForm` and HAVING condition checking `avg(LifeExpectancy) > 72`. The amended query now correctly matches the right SQL's behavior with identical logic and output."
        ],
        "rules": [
            "When the question asks for government forms with average life expectancy greater than 72: filter groups using HAVING avg(LifeExpectancy) > 72 instead of filtering individual rows.",
            "When computing total population per government form: use sum(Population) as the aggregation function.",
            "When ordering output columns: place sum(Population) before GovernmentForm in the result.",
            "When the question asks for government forms with average life expectancy greater than 72, When computing total population per government form, When ordering output columns, When grouping results by government form: use GovernmentForm as the grouping key without aliases in the output.",
            "When the question asks for different government forms and their total population: place \"GovernmentForm\" after the aggregate function in the output order.",
            "When computing total population: use lowercase \"sum\" function on \"Population\" column.",
            "When filtering by average life expectancy greater than 72: use lowercase \"avg\" function on \"LifeExpectancy\" column and compare with value 72.",
            "When grouping results by government form: group by \"GovernmentForm\" column.",
            "When the question asks for different government forms and their total population, When computing total population, When filtering by average life expectancy greater than 72, When grouping results by government form, When handling aggregate functions: use lowercase function names (sum, avg) instead of uppercase versions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT GovernmentForm, SUM(Population) as TotalPopulation \nFROM country \nWHERE LifeExpectancy > 72 \nGROUP BY GovernmentForm;",
            "SELECT GovernmentForm, SUM(Population) FROM country GROUP BY GovernmentForm HAVING AVG(LifeExpectancy) > 72",
            "SELECT sum(Population), GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy) > 72"
        ],
        "rule_sql": [
            "SELECT sum(Population), GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy) > 72 ORDER BY sum(Population) DESC, GovernmentForm;"
        ]
    },
    "798": {
        "db_id": "world_1",
        "question": "Find the average life expectancy and total population for each continent where the average life expectancy is shorter than 72?",
        "ground_truth": "SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  72",
        "amends": [
            "Do use `sum(Population)` and `avg(LifeExpectancy)` instead of `SUM(population) as total_population` and `AVG(life_expectancy) as avg_life_expectancy` with different column names and casing. Do place the `HAVING avg(LifeExpectancy) < 72` filter after `GROUP BY Continent` instead of incorrectly using `WHERE AVG(life_expectancy) < 72` before grouping. Do remove the column aliases `as avg_life_expectancy` and `as total_population` instead of keeping them. Do change the table name from `countries` to `country` instead of using the wrong table reference. Do reorder the SELECT list to `sum(Population), avg(LifeExpectancy), Continent` instead of `continent, AVG(life_expectancy), SUM(population)`. The amended query now correctly filters aggregated results using HAVING instead of the invalid WHERE clause with aggregate functions, matching the RIGHT_SQL's behavior.",
            "Do reorder the SELECT list to place `sum(Population)` first instead of `Continent`, and move `Continent` to the end instead of the beginning. Do keep the same `avg(LifeExpectancy)` aggregate and `GROUP BY Continent` clause. Do maintain the identical `HAVING avg(LifeExpectancy) < 72` filter instead of changing it. The amended query now matches RIGHT_SQL's behavior with identical logic but different column ordering in the output."
        ],
        "rules": [
            "When the question asks for average life expectancy and total population per continent: use sum(Population) and avg(LifeExpectancy) as the exact aggregate functions with the correct column names and casing.",
            "When filtering on aggregated results like average life expectancy: apply the condition avg(LifeExpectancy) < 72 using HAVING clause after GROUP BY instead of WHERE clause.",
            "When selecting columns for output: order the output columns as sum(Population), avg(LifeExpectancy), Continent instead of any other order.",
            "When referring to the table containing continent data: use the exact table name country instead of countries.",
            "When the question asks for average life expectancy and total population per continent, When filtering on aggregated results like average life expectancy, When selecting columns for output, When referring to the table containing continent data, When presenting results: do not use column aliases like as avg_life_expectancy or as total_population in the final output.",
            "When answering about \"average life expectancy and total population for each continent where average life expectancy is shorter than 72\": make sure the output order: sum(Population), avg(LifeExpectancy), Continent.",
            "When the question asks for \"average life expectancy\": compute the average of LifeExpectancy values.",
            "When the question asks for \"total population\": compute the sum of Population values.",
            "When the question says \"for each continent\": organize results by grouping on the Continent column.",
            "When answering about \"average life expectancy and total population for each continent where average life expectancy is shorter than 72\", When the question asks for \"average life expectancy\", When the question asks for \"total population\", When the question says \"for each continent\", When the question specifies \"where the average life expectancy is shorter than 72\": filter groups where the average LifeExpectancy is less than 72."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT continent, AVG(life_expectancy) as avg_life_expectancy, SUM(population) as total_population \nFROM countries \nWHERE AVG(life_expectancy) < 72 \nGROUP BY continent",
            "SELECT Continent, avg(LifeExpectancy), sum(Population) FROM country GROUP BY Continent HAVING avg(LifeExpectancy) < 72",
            "SELECT sum(Population), avg(LifeExpectancy), Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy) < 72"
        ],
        "rule_sql": [
            "SELECT SUM(Population), AVG(LifeExpectancy), Continent FROM country GROUP BY Continent HAVING AVG(LifeExpectancy) < 72"
        ]
    },
    "799": {
        "db_id": "world_1",
        "question": "What are the different continents and the total popuation and average life expectancy corresponding to each, for continents that have an average life expectancy less than 72?",
        "ground_truth": "SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  72",
        "amends": [
            "Do use `sum(Population)` and `avg(LifeExpectancy)` instead of `SUM(population)` and `AVG(life_expectancy)` with different column names. Do place `Continent` in the SELECT list instead of omitting it from the output. Do remove the `total_population` and `avg_life_expectancy` aliases instead of keeping them. Do use `HAVING avg(LifeExpectancy) < 72` instead of `WHERE avg_life_expectancy < 72` to properly filter aggregated results after grouping. Do reference table `country` instead of `countries`. The amended query now correctly filters on aggregated values using HAVING instead of WHERE and matches the RIGHT_SQL's behavior.",
            "Do place `Continent` at the end of the SELECT list instead of at the beginning. Do maintain the same aggregate functions `sum(Population)` and `avg(LifeExpectancy)` with identical GROUP BY and HAVING clauses using `avg(LifeExpectancy) < 72`. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [
            "When answering about continents with population and life expectancy: organize results by the exact column token \"Continent\" from table \"country\".",
            "When computing total population: use sum(\"Population\") instead of sum(population) with exact column name.",
            "When computing average life expectancy: use avg(\"LifeExpectancy\") instead of avg(life_expectancy) with exact column name.",
            "When filtering for continents with average life expectancy less than 72: apply the condition avg(\"LifeExpectancy\") < 72 after grouping using HAVING instead of WHERE.",
            "When referencing the table: use table name \"country\" instead of \"countries\" exactly as specified in the schema.",
            "When answering about continents with population and life expectancy, When computing total population, When computing average life expectancy, When filtering for continents with average life expectancy less than 72, When referencing the table, When producing output columns: include \"Continent\", sum(\"Population\"), and avg(\"LifeExpectancy\") without aliases total_population and avg_life_expectancy.",
            "When answering about \"different continents and the total population and average life expectancy\": make sure the output order: sum(Population), avg(LifeExpectancy), Continent",
            "When the question asks for \"continents that have an average life expectancy less than 72\": filter groups where avg(LifeExpectancy) < 72",
            "When answering about \"different continents and the total population and average life expectancy\", When the question asks for \"continents that have an average life expectancy less than 72\", When the question says \"per continent\"/\"by continent\": organize results by Continent and compute requested aggregates per group"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT continent, SUM(population) as total_population, AVG(life_expectancy) as avg_life_expectancy \nFROM countries \nWHERE avg_life_expectancy < 72 \nGROUP BY continent",
            "SELECT Continent, sum(Population), avg(LifeExpectancy) FROM country GROUP BY Continent HAVING avg(LifeExpectancy) < 72",
            "SELECT sum(Population), avg(LifeExpectancy), Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy) < 72"
        ],
        "rule_sql": [
            "SELECT Continent, sum(\"Population\"), avg(\"LifeExpectancy\") FROM country GROUP BY Continent HAVING avg(\"LifeExpectancy\") < 72 ORDER BY sum(\"Population\"), avg(\"LifeExpectancy\"), Continent"
        ]
    },
    "800": {
        "db_id": "world_1",
        "question": "What are the names and areas of countries with the top 5 largest area?",
        "ground_truth": "SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5",
        "amends": [
            "Do use column name `Name` instead of `name` and `SurfaceArea` instead of `area` in the SELECT list. Do reference table `country` instead of `countries` in the FROM clause. The amended query now correctly references the proper column names and table to match the intended behavior."
        ],
        "rules": [
            "When answering about \"names and areas of countries with the top 5 largest area\": make sure the output order: Name, SurfaceArea.",
            "When the question mentions \"countries\": \"countries\" actually means \"country\" in schema.",
            "When the question mentions \"name\": \"name\" actually means \"Name\" in schema.",
            "When the question mentions \"area\": \"area\" actually means \"SurfaceArea\" in schema.",
            "When answering about \"names and areas of countries with the top 5 largest area\", When the question mentions \"countries\", When the question mentions \"name\", When the question mentions \"area\", When the question mentions \"top 5 largest area\": rank rows by SurfaceArea in descending order and keep the first 5 rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, area FROM countries ORDER BY area DESC LIMIT 5;",
            "SELECT Name, SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5"
        ],
        "rule_sql": [
            "SELECT Name, SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5"
        ]
    },
    "801": {
        "db_id": "world_1",
        "question": "Return the names and surface areas of the 5 largest countries.",
        "ground_truth": "SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5",
        "amends": [
            "Do use column names `Name` and `SurfaceArea` instead of `name` and `surface_area` to match the actual schema. Do order by `SurfaceArea DESC` instead of `ASC` to sort in descending order rather than ascending. Do query from table `country` instead of `countries` to reference the correct table name. The amended query now correctly retrieves the top 5 countries by surface area in descending order."
        ],
        "rules": [
            "When the question asks for \"names and surface areas\": use the exact column tokens \"Name\" and \"SurfaceArea\" from the country table.",
            "When the question asks for the \"5 largest countries\": order by \"SurfaceArea\" in descending order and keep the first 5 rows.",
            "When the question asks for \"names and surface areas\", When the question asks for the \"5 largest countries\", When querying from the database: use the exact table name \"country\" instead of any other table name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, surface_area FROM countries ORDER BY surface_area ASC LIMIT 5;",
            "SELECT Name, SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5"
        ],
        "rule_sql": [
            "SELECT Name, SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5"
        ]
    },
    "802": {
        "db_id": "world_1",
        "question": "What are names of countries with the top 3 largest population?",
        "ground_truth": "SELECT Name FROM country ORDER BY Population DESC LIMIT 3",
        "amends": [
            "Do select `Name` instead of `name` to match the correct column case. Do order by `Population DESC` instead of `population ASC` to sort by descending population rather than ascending. Do use table `country` instead of `countries` to reference the correct table name. The amended query now correctly returns the top 3 countries by population in descending order."
        ],
        "rules": [
            "When the question asks for country names: use column \"Name\" from table \"country\" instead of \"name\" from other tables.",
            "When the question asks for \"top 3 largest population\": order by column \"Population\" in descending order to get the highest values first.",
            "When the question asks for country names, When the question asks for \"top 3 largest population\", When the question asks for top K results: limit the output to exactly 3 rows after proper ordering."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM countries ORDER BY population ASC LIMIT 3;",
            "SELECT Name FROM country ORDER BY Population DESC LIMIT 3"
        ],
        "rule_sql": [
            "SELECT Name FROM country ORDER BY Population DESC LIMIT 3"
        ]
    },
    "803": {
        "db_id": "world_1",
        "question": "Return the names of the 3 most populated countries.",
        "ground_truth": "SELECT Name FROM country ORDER BY Population DESC LIMIT 3",
        "amends": [
            "Do use `Name` instead of `name` for the column selection to match the correct case. Do order by `Population DESC` instead of `population ASC` to sort in descending order by the correct population column. Do reference table `country` instead of `countries` to use the correct table name. The amended query now correctly selects the top 3 countries by population in descending order."
        ],
        "rules": [
            "When the question asks for \"names of the 3 most populated countries\": use column \"Name\" from table \"country\" for output.",
            "When ordering by population to find the most populated: sort by column \"Population\" in descending order.",
            "When selecting the top 3 results: keep only the first 3 rows after sorting.",
            "When the question asks for \"names of the 3 most populated countries\", When ordering by population to find the most populated, When selecting the top 3 results, When referring to countries: use table \"country\" instead of \"countries\" as the correct table name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM countries ORDER BY population ASC LIMIT 3;",
            "SELECT Name FROM country ORDER BY Population DESC LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT Name FROM country ORDER BY Population DESC LIMIT 3"
        ]
    },
    "804": {
        "db_id": "world_1",
        "question": "What are the names of the nations with the 3 lowest populations?",
        "ground_truth": "SELECT Name FROM country ORDER BY Population ASC LIMIT 3",
        "amends": [
            "Do reference the `Name` column instead of `name` and the `Population` column instead of `population` to match the correct table schema. Do reference the `country` table instead of `nations` as the correct data source. The amended query now correctly retrieves the three countries with the smallest population from the appropriate table structure."
        ],
        "rules": [
            "When answering about \"nations with lowest populations\": use the table \"country\" instead of \"nations\" as the data source.",
            "When the question mentions \"names\": the exact column token is \"Name\" (not \"name\") from table \"country\".",
            "When the question mentions \"populations\": the exact column token is \"Population\" (not \"population\") from table \"country\".",
            "When answering about \"nations with lowest populations\", When the question mentions \"names\", When the question mentions \"populations\", When the question asks for \"3 lowest populations\": rank rows by \"Population\" in ascending order and keep the first 3 rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM nations ORDER BY population ASC LIMIT 3;",
            "SELECT Name FROM country ORDER BY Population ASC LIMIT 3"
        ],
        "rule_sql": [
            "SELECT Name FROM country ORDER BY Population ASC LIMIT 3"
        ]
    },
    "805": {
        "db_id": "world_1",
        "question": "Return the names of the 3 countries with the fewest people.",
        "ground_truth": "SELECT Name FROM country ORDER BY Population ASC LIMIT 3",
        "amends": [
            "Do use column name `Name` instead of `name` and `Population` instead of `population` to match the correct case sensitivity. Do use `ASC` ordering instead of `DESC` to sort by population in ascending order instead of descending. Do use table name `country` instead of `countries` to reference the correct table. The amended query now correctly selects from the proper table with accurate column names and ascending population ordering."
        ],
        "rules": [
            "When the question asks for country names: use column \"Name\" from table \"country\" instead of \"name\" from other tables.",
            "When the question asks about population counts: use column \"Population\" from table \"country\" to get accurate population data.",
            "When the question asks for countries with the fewest people: sort by \"Population\" in ascending order (ASC) instead of descending order (DESC).",
            "When the question specifies \"3 countries\": limit the results to exactly 3 rows.",
            "When the question asks for country names, When the question asks about population counts, When the question asks for countries with the fewest people, When the question specifies \"3 countries\", When referencing the country table: use table name \"country\" instead of \"countries\" to access the correct data source."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM countries ORDER BY population DESC LIMIT 3;",
            "SELECT Name FROM country ORDER BY Population ASC LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT Name FROM country ORDER BY Population ASC LIMIT 3"
        ]
    },
    "806": {
        "db_id": "world_1",
        "question": "how many countries are in Asia?",
        "ground_truth": "SELECT count(*) FROM country WHERE continent  =  \"Asia\"",
        "amends": [
            "Do reference table `country` instead of `countries` and filter on `continent = \"Asia\"` instead of `'Europe'`."
        ],
        "rules": [
            "When answering about \"how many countries are in Asia\": make sure the output order: COUNT(*)",
            "When the question mentions \"countries\": \"countries\" actually means \"country in schema\"",
            "When the question mentions \"Asia\": filter rows where continent = \"Asia\" exactly as specified",
            "When answering about \"how many countries are in Asia\", When the question mentions \"countries\", When the question mentions \"Asia\", When the question asks for \"count of countries\": compute the number of rows using the canonical key for country entities"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE continent = 'Europe';",
            "SELECT COUNT(*) FROM country WHERE Continent = 'Asia';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM country WHERE Continent = 'Asia';"
        ]
    },
    "807": {
        "db_id": "world_1",
        "question": "Count the number of countries in Asia.",
        "ground_truth": "SELECT count(*) FROM country WHERE continent  =  \"Asia\"",
        "amends": [
            "Do reference table `country` instead of `countries` and filter on `continent = \"Asia\"` instead of `continent = 'Europe'`."
        ],
        "rules": [
            "When answering about \"countries in Asia\": use table \"country\" instead of \"countries\".",
            "When answering about \"countries in Asia\", When filtering for countries in Asia: use condition continent = \"Asia\" instead of continent = 'Europe'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE continent = 'Europe';",
            "SELECT COUNT(*) FROM country WHERE Continent = 'Asia';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM country WHERE continent = 'Asia';"
        ]
    },
    "808": {
        "db_id": "world_1",
        "question": "What are the names of the countries that are in the continent of Europe and have a population of 80000?",
        "ground_truth": "SELECT Name FROM country WHERE continent  =  \"Europe\" AND Population  =  \"80000\"",
        "amends": [
            "Do reference the table as `country` instead of `countries` and use column names `Name` and `Population` instead of `name` and `population`. Do use double quotes around the string value \"80000\" instead of treating it as a numeric literal without quotes. The amended query now correctly references the proper table and column names with appropriate string formatting for the population value, matching the intended behavior."
        ],
        "rules": [
            "When the question asks about countries: use the table \"country\" instead of \"countries\" as the correct table name.",
            "When referring to country names: use the column \"Name\" (with exact case) instead of \"name\".",
            "When referring to population values: use the column \"Population\" (with exact case) instead of \"population\".",
            "When the question asks about countries, When referring to country names, When referring to population values, When filtering for a specific population value of 80000: use the string literal \"80000\" with double quotes instead of treating it as a numeric literal."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM countries WHERE continent = 'Europe' AND population = 80000;",
            "SELECT Name FROM country WHERE Continent = 'Europe' AND Population = \"80000\";"
        ],
        "rule_sql": [
            "SELECT Name FROM country WHERE Continent = 'Europe' AND Population = \"80000\""
        ]
    },
    "809": {
        "db_id": "world_1",
        "question": "Give the names of countries that are in Europe and have a population equal to 80000.",
        "ground_truth": "SELECT Name FROM country WHERE continent  =  \"Europe\" AND Population  =  \"80000\"",
        "amends": [
            "Do reference the table as `country` instead of `countries` and use column names `Name` and `Population` instead of `name` and `population`. Do use double quotes around the string value \"80000\" instead of treating it as a numeric literal without quotes. The amended query now correctly references the schema elements and properly handles the population value as a string, matching the intended behavior of the right SQL."
        ],
        "rules": [
            "When referencing the table containing country information: use the exact table name \"country\" instead of \"countries\".",
            "When selecting country names: use the exact column name \"Name\" with proper capitalization.",
            "When filtering by population: use the exact column name \"Population\" with proper capitalization.",
            "When comparing population values: treat the value \"80000\" as a string literal with double quotes instead of a numeric value.",
            "When referencing the table containing country information, When selecting country names, When filtering by population, When comparing population values, When filtering by continent: use the exact string literal \"Europe\" with proper capitalization and double quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM countries WHERE continent = 'Europe' AND population = 80000;",
            "SELECT Name FROM country WHERE Continent = 'Europe' AND Population = 80000"
        ],
        "rule_sql": [
            "SELECT Name FROM country WHERE Continent = \"Europe\" AND Population = \"80000\";"
        ]
    },
    "810": {
        "db_id": "world_1",
        "question": "What is the total population and average area of countries in the continent of North America whose area is bigger than 3000 ?",
        "ground_truth": "select sum(population) ,  avg(surfacearea) from country where continent  =  \"north america\" and surfacearea  >  3000",
        "amends": [
            "Do use `surfacearea` instead of `area` in both the aggregate function and filter condition. Do change the area filter to `> 3000` instead of `< 3000` to include larger countries rather than smaller ones. Do remove the column aliases `total_population` and `average_area` instead of keeping them. Do use lowercase table name `country` instead of `countries` and lowercase continent value `\"north america\"` instead of 'North America'. The amended query now correctly calculates population sum and surface area average for North American countries with surface area greater than 3000, matching the intended behavior."
        ],
        "rules": [
            "When the question mentions \"area\": \"area\" actually means \"surfacearea\" in the schema.",
            "When filtering for countries with area bigger than 3000: use surfacearea > 3000 instead of < 3000.",
            "When answering about total population and average area: make sure the output order: SUM(population), AVG(surfacearea).",
            "When the question mentions \"countries\": use table name \"country\" instead of \"countries\".",
            "When filtering for continent \"North America\": use exact literal value \"north america\" with lowercase letters.",
            "When the question mentions \"area\", When filtering for countries with area bigger than 3000, When answering about total population and average area, When the question mentions \"countries\", When filtering for continent \"North America\", When producing output columns: do not use column aliases total_population and average_area."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(population) AS total_population, AVG(area) AS average_area FROM countries WHERE continent = 'North America' AND area < 3000;",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = 'north america' AND SurfaceArea > 3000"
        ],
        "rule_sql": [
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = 'north america' AND SurfaceArea > 3000"
        ]
    },
    "811": {
        "db_id": "world_1",
        "question": "Give the total population and average surface area corresponding to countries in North America that have a surface area greater than 3000 .",
        "ground_truth": "select sum(population) ,  avg(surfacearea) from country where continent  =  \"north america\" and surfacearea  >  3000",
        "amends": [
            "Do use `surfacearea` column name instead of `surface_area` to match the actual schema. Do remove the `AS total_population` and `AS avg_surface_area` aliases instead of keeping them. Do use double quotes `\"north america\"` instead of single quotes for the string literal. Do reference the `country` table instead of `countries` to use the correct table name. The amended query now correctly calculates the total population and average surface area for North American countries with surface area greater than 3000, matching the intended behavior.",
            "Do maintain the exact same query structure with identical SELECT list containing `SUM(Population)` and `AVG(SurfaceArea)`, identical FROM source `country`, identical WHERE filters `Continent = \"North America\"` and `SurfaceArea > 3000`, and identical aggregation behavior instead of making any changes, as both queries are functionally equivalent despite minor formatting differences in spacing and case. The amended query now matches RIGHT_SQL's behavior with no substantive changes required.",
            "Do use identical `SUM(Population)` and `AVG(SurfaceArea)` expressions instead of changing them, maintain the same `FROM country` source instead of altering it, preserve the exact `WHERE Continent = \"North America\" AND SurfaceArea > 3000` filter conditions instead of modifying them, and keep the same aggregation structure without adding GROUP BY or HAVING clauses instead of introducing them. The amended query now matches RIGHT_SQL's behavior with identical logic and results.",
            "Do use identical SQL logic with the same `SUM(Population)` and `AVG(SurfaceArea)` aggregates instead of changing them. Do maintain the exact same `FROM country` source instead of altering it. Do preserve the identical `WHERE` filter conditions `Continent = \"North America\"` and `SurfaceArea > 3000` instead of modifying them. The amended query now matches RIGHT_SQL's behavior with no functional differences.",
            "Do use identical SQL logic with the same `SUM(Population)` and `AVG(SurfaceArea)` aggregates instead of changing them. Do maintain the same `FROM country` source instead of altering it. Do preserve the identical `WHERE` filter conditions `Continent = \"North America\"` and `SurfaceArea > 3000` instead of modifying them. The amended query now matches RIGHT_SQL's behavior as both queries are functionally equivalent despite minor formatting differences.",
            "Do maintain the exact same SELECT list with `SUM(Population)` and `AVG(SurfaceArea)` instead of changing any aggregate functions or column references. Do preserve the FROM clause with single table `country` instead of adding or removing any data sources. Do keep the WHERE filter conditions exactly as `Continent = \"North America\"` and `SurfaceArea > 3000` instead of modifying any predicate logic or values. Do maintain the same aggregation structure without GROUP BY/HAVING clauses instead of adding unnecessary grouping. The amended query now correctly matches the intended behavior by preserving all logical components unchanged from the original formulation.",
            "Do use identical SQL logic with the same `SUM(Population)` and `AVG(SurfaceArea)` aggregates instead of changing them. Do maintain the exact same `FROM country` source instead of altering it. Do preserve the identical `WHERE` filter conditions `Continent = \"North America\"` and `SurfaceArea > 3000` instead of modifying them. The amended query now matches RIGHT_SQL's behavior as both queries are functionally equivalent with only insignificant formatting differences.",
            "Do use identical SQL logic with the same `SUM(Population)` and `AVG(SurfaceArea)` aggregates instead of changing them. Do maintain the exact same `FROM country` source instead of altering it. Do preserve the identical `WHERE` filter conditions `Continent = \"North America\"` and `SurfaceArea > 3000` instead of modifying them. The amended query now matches RIGHT_SQL's behavior as both queries are functionally equivalent with only insignificant formatting differences."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(population) AS total_population, AVG(surface_area) AS avg_surface_area \nFROM countries \nWHERE continent = 'North America' AND surface_area > 3000;",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = \"North America\" AND SurfaceArea > 3000",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = \"North America\" AND SurfaceArea > 3000",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = \"North America\" AND SurfaceArea > 3000",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = \"North America\" AND SurfaceArea > 3000",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = \"North America\" AND SurfaceArea > 3000",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = \"North America\" AND SurfaceArea > 3000",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = \"North America\" AND SurfaceArea > 3000",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = \"North America\" AND SurfaceArea > 3000"
        ],
        "rule_sql": []
    },
    "812": {
        "db_id": "world_1",
        "question": "What are the cities whose population is between 160000 and 900000?",
        "ground_truth": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000",
        "amends": [
            "Do select `name` instead of `city` from the `city` table instead of `cities`. Do use `BETWEEN 160000 AND 900000` instead of separate `population > 160000 AND population < 900000` conditions to include both boundary values. The amended query now correctly retrieves city names within the specified population range using proper inclusive bounds."
        ],
        "rules": [
            "When the question asks for cities: select the \"name\" column from the \"city\" table instead of a \"city\" column.",
            "When filtering for population between 160000 and 900000: use inclusive bounds with BETWEEN 160000 AND 900000 to include both boundary values, not separate greater-than and less-than conditions.",
            "When the question asks for cities, When filtering for population between 160000 and 900000, When answering about cities with population ranges: make sure the output order shows city names that meet the population criteria."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city FROM cities WHERE population > 160000 AND population < 900000;",
            "SELECT Name FROM city WHERE Population BETWEEN 160000 AND 900000"
        ],
        "rule_sql": [
            "SELECT Name FROM city WHERE Population BETWEEN 160000 AND 900000 ORDER BY Name;"
        ]
    },
    "813": {
        "db_id": "world_1",
        "question": "Return the names of cities that have a population between 160000 and 900000 .",
        "ground_truth": "select name from city where population between 160000 and 900000",
        "amends": [
            "Do reference the table as `city` instead of `cities` to match the correct schema. Do use `BETWEEN 160000 AND 900000` instead of `< 160000 OR > 900000` to select cities within the population range rather than outside it, which completely reverses the logic from excluding to including the specified range. The amended query now correctly returns cities with populations between 160,000 and 900,000 instead of those outside this range."
        ],
        "rules": [
            "When the question asks for cities with population between 160000 and 900000: use the table name \"city\" instead of \"cities\" to match the schema.",
            "When selecting cities within a population range: use BETWEEN 160000 AND 900000 instead of population < 160000 OR population > 900000 to include the specified range rather than exclude it.",
            "When the question mentions \"cities\": the exact identifier in the schema is \"city\" table.",
            "When the question asks for cities with population between 160000 and 900000, When selecting cities within a population range, When the question mentions \"cities\", When the question asks for population between 160000 and 900000: use inclusive range checking with exact literals 160000 and 900000."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM cities WHERE population < 160000 OR population > 900000;",
            "SELECT Name FROM city WHERE Population BETWEEN 160000 AND 900000"
        ],
        "rule_sql": [
            "SELECT Name FROM city WHERE Population BETWEEN 160000 AND 900000"
        ]
    },
    "814": {
        "db_id": "world_1",
        "question": "Which language is spoken by the largest number of countries?",
        "ground_truth": "SELECT LANGUAGE FROM countrylanguage GROUP BY LANGUAGE ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `LANGUAGE` instead of `language, COUNT(*) as country_count` to return only the language column rather than both language and count. Do use table `countrylanguage` instead of `countries` to access the correct data source containing language information. Do group by `LANGUAGE` instead of `language` to maintain consistent case handling. Do order by `count(*) DESC` instead of `country_count DESC` to directly reference the aggregate function rather than an alias. The amended query now correctly identifies the most common language by counting occurrences in the appropriate table and returns only the language value itself."
        ],
        "rules": [
            "When answering about \"which language is spoken by the largest number of countries\": make sure the output order: only return the LANGUAGE column.",
            "When the question mentions \"countries\": \"countries\" actually means \"countrylanguage in schema\".",
            "When the question asks for \"largest number of countries\" for languages: rank rows by count(*) in descending direction and keep the first 1 row.",
            "When the question asks for \"count of countries\" per language: compute the number of rows using the canonical key for countries (not specified in amends, but use count(*) as shown).",
            "When the question says \"per language\"/\"by language\": organize results by the token for LANGUAGE and compute count(*) per group.",
            "When answering about \"which language is spoken by the largest number of countries\", When the question mentions \"countries\", When the question asks for \"largest number of countries\" for languages, When the question asks for \"count of countries\" per language, When the question says \"per language\"/\"by language\", When choosing identifier delimiters: do not replace the exact case shown in amends - use LANGUAGE (uppercase) not language (lowercase)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT language, COUNT(*) as country_count FROM countries GROUP BY language ORDER BY country_count DESC LIMIT 1;",
            "SELECT Language FROM countrylanguage GROUP BY Language ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT LANGUAGE FROM countrylanguage GROUP BY LANGUAGE ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "815": {
        "db_id": "world_1",
        "question": "Give the language that is spoken in the most countries.",
        "ground_truth": "SELECT LANGUAGE FROM countrylanguage GROUP BY LANGUAGE ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference the correct table name `countrylanguage` instead of the incorrect `country_languages`. Do maintain the same column reference `LANGUAGE` instead of `language` while preserving the same case sensitivity. Do keep the identical aggregation `COUNT(*)` and ordering `DESC` with the same `LIMIT 1` clause. The amended query now correctly references the actual table name while maintaining the same logical behavior to find the most frequently occurring language."
        ],
        "rules": [
            "When the question asks for the language spoken in the most countries: use the exact table name \"countrylanguage\" instead of \"country_languages\".",
            "When referencing the language column: use the exact column name \"LANGUAGE\" with the same case sensitivity as shown in the schema.",
            "When counting countries per language: use COUNT(*) to count all rows in each language group.",
            "When the question asks for the language spoken in the most countries, When referencing the language column, When counting countries per language, When finding the most frequently occurring language: order the results by the count in descending order and take only the top result with LIMIT 1."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT language FROM country_languages GROUP BY language ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT Language FROM countrylanguage GROUP BY Language ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT LANGUAGE FROM countrylanguage GROUP BY LANGUAGE ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "816": {
        "db_id": "world_1",
        "question": "What is the language spoken by the largest percentage of people in each country?",
        "ground_truth": "SELECT LANGUAGE ,  CountryCode ,  max(Percentage) FROM countrylanguage GROUP BY CountryCode",
        "amends": [
            "Do reference table `countrylanguage` instead of `country_languages` and use column `CountryCode` instead of `country` for grouping. Do use column `LANGUAGE` instead of `language` and `Percentage` instead of `percentage` in the aggregate function. Do include `CountryCode` in the SELECT list instead of omitting it, while maintaining the same MAX aggregation logic on percentage values grouped by country code.",
            "Do specify `Language` and `CountryCode` in the SELECT list without aliasing `Language` instead of using aliases for both columns. Do use `max(Percentage)` without an alias instead of `MAX(Percentage) AS MaxPercentage`. The amended query now correctly selects the maximum percentage for each language and country code combination without unnecessary aliasing.",
            "Do maintain the `Language` column in the SELECT list instead of omitting it, and do preserve the `CountryCode` column position instead of moving it to first position. Do keep the aggregate function `MAX(Percentage)` unchanged as it correctly calculates the maximum percentage for each group. Do maintain the GROUP BY clause on `CountryCode` to group results by country code. The amended query now correctly includes all necessary columns in the SELECT list while maintaining proper grouping semantics, matching the RIGHT_SQL's behavior.",
            "Do maintain the `Language` column in the SELECT list instead of omitting it, as it is required for proper grouping semantics. Do preserve the `CountryCode` column position as it appears in the GROUP BY clause instead of moving it. Do use consistent column ordering with `Language, CountryCode` instead of `CountryCode, Language` to match the logical grouping structure. The amended query now correctly includes all non-aggregated columns from the GROUP BY clause in the SELECT list and maintains proper column ordering to match RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks about languages spoken by percentage in countries: use table \"countrylanguage\" with exact column names \"CountryCode\", \"Language\", and \"Percentage\".",
            "When grouping by country: group by the exact column \"CountryCode\" from table \"countrylanguage\".",
            "When finding the largest percentage: compute the maximum value of \"Percentage\" for each group.",
            "When selecting output columns: include \"CountryCode\", \"Language\", and the maximum \"Percentage\" value in the results.",
            "When the question asks about languages spoken by percentage in countries, When grouping by country, When finding the largest percentage, When selecting output columns, When handling text literals: preserve exact case and formatting of column names as shown in the schema (e.g., \"CountryCode\" not country, \"Language\" not language, \"Percentage\" not percentage).",
            "When the question asks for \"largest percentage of people in each country\": rank languages by Percentage in descending order for each CountryCode and keep only the top language per country.",
            "When the question asks for \"language spoken by the largest percentage\": include both CountryCode and Language columns in the output without aliasing Language.",
            "When computing the maximum percentage: use max(Percentage) without an alias instead of MAX(Percentage) AS MaxPercentage.",
            "When the question asks for \"largest percentage of people in each country\", When the question asks for \"language spoken by the largest percentage\", When computing the maximum percentage, When grouping by CountryCode: organize results by CountryCode and compute the maximum Percentage per group.",
            "When answering about \"language spoken by the largest percentage of people in each country\": make sure the output order: CountryCode, Language, MAX(Percentage).",
            "When the question mentions \"each country\": group results by the exact token \"CountryCode\".",
            "When the question mentions \"largest percentage\": calculate the maximum value of the exact token \"Percentage\" for each group.",
            "When answering about \"language spoken by the largest percentage of people in each country\", When the question mentions \"each country\", When the question mentions \"largest percentage\", When producing output: include both the grouping column \"CountryCode\" and the associated \"Language\" column that corresponds to the maximum percentage value.",
            "When the question asks for \"the language spoken by the largest percentage of people in each country\": include both the \"CountryCode\" and \"Language\" columns in the output to show which language has the maximum percentage for each country.",
            "When grouping by \"CountryCode\" to find the maximum percentage per country: maintain the \"Language\" column in the SELECT list to properly identify which language corresponds to the maximum percentage value.",
            "When organizing results by country: use consistent column ordering with \"Language, CountryCode\" to match the logical grouping structure and ensure proper semantic alignment.",
            "When the question asks for \"the language spoken by the largest percentage of people in each country\", When grouping by \"CountryCode\" to find the maximum percentage per country, When organizing results by country, When computing maximum percentage per country: use the MAX(Percentage) function to find the highest percentage value for each country group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, language, MAX(percentage) FROM country_languages GROUP BY country;",
            "SELECT CountryCode, Language, MAX(Percentage) AS MaxPercentage FROM countrylanguage GROUP BY CountryCode",
            "SELECT CountryCode, Language, MAX(Percentage) FROM countrylanguage GROUP BY CountryCode",
            "SELECT CountryCode, Language, MAX(Percentage) FROM countrylanguage GROUP BY CountryCode",
            "SELECT Language, CountryCode, MAX(Percentage) FROM countrylanguage GROUP BY CountryCode"
        ],
        "rule_sql": [
            "SELECT CountryCode, Language, MAX(Percentage) FROM countrylanguage GROUP BY CountryCode;"
        ]
    },
    "817": {
        "db_id": "world_1",
        "question": "What are the country codes of the different countries, and what are the languages spoken by the greatest percentage of people for each?",
        "ground_truth": "SELECT LANGUAGE ,  CountryCode ,  max(Percentage) FROM countrylanguage GROUP BY CountryCode",
        "amends": [
            "Do select `LANGUAGE`, `CountryCode`, and `max(Percentage)` instead of `country.code` and `countrylanguage.language`. Do use only the `countrylanguage` table instead of joining `country` and `countrylanguage` tables. Do add `GROUP BY CountryCode` instead of omitting grouping. Do remove the `ORDER BY` clause instead of keeping it. The amended query now correctly calculates the maximum percentage for each language by country code and matches the RIGHT_SQL's behavior.",
            "Do maintain the original column order `CountryCode, Language` instead of reordering to `Language, CountryCode`. Do keep the same aggregate function `MAX(Percentage)` and grouping clause `GROUP BY CountryCode` without changes. The amended query now correctly preserves the original column sequence while maintaining identical logical behavior to the RIGHT_SQL.",
            "Do maintain the original column order `CountryCode, Language` instead of reordering to `Language, CountryCode`. Do keep the same aggregate function `MAX(Percentage)` and grouping clause `GROUP BY CountryCode` without changes. The amended query now correctly preserves the original column sequence while maintaining identical logical behavior to the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country.code, countrylanguage.language \nFROM country \nJOIN countrylanguage ON country.code = countrylanguage.countrycode \nORDER BY country.code;",
            "SELECT CountryCode, Language, MAX(Percentage) FROM countrylanguage GROUP BY CountryCode",
            "SELECT CountryCode, Language, MAX(Percentage) FROM countrylanguage GROUP BY CountryCode",
            "SELECT CountryCode, Language, MAX(Percentage) FROM countrylanguage GROUP BY CountryCode"
        ],
        "rule_sql": []
    },
    "818": {
        "db_id": "world_1",
        "question": "What is the total number of countries where Spanish is spoken by the largest percentage of people?",
        "ground_truth": "SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  \"Spanish\" GROUP BY CountryCode",
        "amends": [
            "Do use `count(*)` and `max(Percentage)` in the SELECT list instead of just `COUNT(*)` with a subquery. Do reference table `countrylanguage` instead of `countries` and column `LANGUAGE` instead of `language`. Do add `GROUP BY CountryCode` instead of filtering with a subquery comparison. Do use double quotes around \"Spanish\" instead of single quotes. The amended query now correctly groups by country code to count Spanish-speaking countries and find the maximum percentage, matching the intended behavior.",
            "Do remove the HAVING clause with its correlated subquery that was incorrectly filtering for maximum percentage values instead of keeping the simple aggregate query. Do change the SELECT list to include both `count(*)` and `max(Percentage)` instead of only `count(*)`. Do maintain the `WHERE Language = \"Spanish\"` filter and `GROUP BY CountryCode` grouping without the unnecessary subquery logic. The amended query now correctly counts Spanish-speaking countries while also showing their maximum percentage values, matching the right SQL's behavior."
        ],
        "rules": [
            "When answering about \"countries where Spanish is spoken by the largest percentage\": make sure the output order: count of countries",
            "When the question mentions \"countries\": \"countries\" actually means \"CountryCode in countrylanguage table\"",
            "When the question mentions \"Spanish\": use the exact literal \"Spanish\" with double quotes",
            "When the question asks for \"total number of countries where Spanish is spoken by the largest percentage\": group by CountryCode and count the number of groups",
            "When computing the maximum percentage per country: use max(Percentage) for each CountryCode group",
            "When choosing identifier delimiters: use double quotes around \"Spanish\" and use exact column names LANGUAGE and Percentage as shown in the schema",
            "When answering about \"countries where Spanish is spoken by the largest percentage\", When the question mentions \"countries\", When the question mentions \"Spanish\", When the question asks for \"total number of countries where Spanish is spoken by the largest percentage\", When computing the maximum percentage per country, When choosing identifier delimiters, When referring to table roles: use countrylanguage as the base table (T1) for language data",
            "When answering about \"total number of countries where Spanish is spoken by the largest percentage of people\": make sure the output order: count of countries and maximum percentage values.",
            "When the question mentions \"Spanish\": \"Spanish\" actually means \"Language = 'Spanish'\" in schema.",
            "When the question asks for \"total number of countries\": compute the number of rows using the canonical key token for countries (CountryCode).",
            "When the question mentions \"largest percentage\": include the maximum percentage value for each country in the output.",
            "When answering about \"total number of countries where Spanish is spoken by the largest percentage of people\", When the question mentions \"Spanish\", When the question asks for \"total number of countries\", When the question mentions \"largest percentage\", When the question says \"per country\"/\"by country\": organize results by CountryCode and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE language = 'Spanish' AND percentage = (SELECT MAX(percentage) FROM countries WHERE language = 'Spanish');",
            "SELECT COUNT(*) \nFROM countrylanguage \nWHERE Language = \"Spanish\" \nGROUP BY CountryCode \nHAVING MAX(Percentage) = (SELECT MAX(Percentage) FROM countrylanguage cl2 WHERE cl2.CountryCode = countrylanguage.CountryCode)",
            "SELECT COUNT(*), MAX(Percentage) FROM countrylanguage WHERE Language = \"Spanish\" GROUP BY CountryCode;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS count_of_countries\nFROM (\n    SELECT CountryCode, MAX(Percentage) AS max_percentage\n    FROM countrylanguage\n    WHERE Language = 'Spanish'\n    GROUP BY CountryCode\n) AS spanish_max_percentage"
        ]
    },
    "819": {
        "db_id": "world_1",
        "question": "Count the number of countries for which Spanish is the predominantly spoken language.",
        "ground_truth": "SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  \"Spanish\" GROUP BY CountryCode",
        "amends": [
            "Do select both `count(*)` and `max(Percentage)` instead of only `COUNT(*)`. Do query from `countrylanguage` table instead of `countries` table. Do use `LANGUAGE = \"Spanish\"` filter instead of `language = 'Spanish'`. Do add `GROUP BY CountryCode` clause instead of omitting grouping. Do use double quotes around \"Spanish\" instead of single quotes for the string literal."
        ],
        "rules": [
            "When querying about language data: use the \"countrylanguage\" table instead of the \"countries\" table.",
            "When filtering for Spanish language: use the exact literal \"Spanish\" with double quotes instead of single quotes.",
            "When counting countries by language: group results by \"CountryCode\" to get counts per country.",
            "When querying about language data, When filtering for Spanish language, When counting countries by language, When determining predominant language: include both count and maximum percentage in the selection to identify the primary language per country."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE language = 'Spanish';",
            "SELECT COUNT(*), MAX(Percentage) FROM countrylanguage WHERE Language = \"Spanish\" GROUP BY CountryCode"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS country_count\nFROM (\n    SELECT CountryCode\n    FROM countrylanguage\n    GROUP BY CountryCode\n    HAVING MAX(Percentage) = (\n        SELECT MAX(Percentage)\n        FROM countrylanguage cl2\n        WHERE cl2.CountryCode = countrylanguage.CountryCode\n    )\n    AND (\n        SELECT Language\n        FROM countrylanguage cl3\n        WHERE cl3.CountryCode = countrylanguage.CountryCode\n        AND cl3.Percentage = (\n            SELECT MAX(Percentage)\n            FROM countrylanguage cl4\n            WHERE cl4.CountryCode = countrylanguage.CountryCode\n        )\n    ) = \"Spanish\"\n)"
        ]
    },
    "820": {
        "db_id": "world_1",
        "question": "What are the codes of countries where Spanish is spoken by the largest percentage of people?",
        "ground_truth": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  \"Spanish\" GROUP BY CountryCode",
        "amends": [
            "Do add `max(Percentage)` to the SELECT list and include `GROUP BY CountryCode` instead of using `ORDER BY Percentage DESC LIMIT 1` to find the maximum percentage. Do remove the `ORDER BY` and `LIMIT` clauses instead of keeping them, as the aggregate function with grouping achieves the same result more efficiently. Do keep the `WHERE Language = 'Spanish'` filter unchanged. The amended query now correctly returns each country's maximum Spanish speaking percentage rather than just the single highest percentage country, matching the RIGHT_SQL's behavior of showing all countries with their respective maximum percentages."
        ],
        "rules": [
            "When answering about \"codes of countries where Spanish is spoken by the largest percentage of people\": make sure the output order includes CountryCode and max(Percentage).",
            "When the question mentions \"Spanish\": \"Spanish\" actually means \"Language = 'Spanish'\" in the schema.",
            "When the question asks for \"largest percentage per country\": organize results by CountryCode and compute the maximum Percentage value per group.",
            "When answering about \"codes of countries where Spanish is spoken by the largest percentage of people\", When the question mentions \"Spanish\", When the question asks for \"largest percentage per country\", When computing maximum percentage: use max(Percentage) as the aggregate function for each CountryCode group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT CountryCode FROM countrylanguage WHERE Language = 'Spanish' ORDER BY Percentage DESC LIMIT 1;",
            "SELECT CountryCode, MAX(Percentage) FROM countrylanguage WHERE Language = 'Spanish' GROUP BY CountryCode"
        ],
        "rule_sql": [
            "SELECT CountryCode, MAX(Percentage) AS MaxPercentage FROM countrylanguage WHERE Language = 'Spanish' GROUP BY CountryCode ORDER BY MaxPercentage DESC;"
        ]
    },
    "821": {
        "db_id": "world_1",
        "question": "Return the codes of countries for which Spanish is the predominantly spoken language.",
        "ground_truth": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  \"Spanish\" GROUP BY CountryCode",
        "amends": [
            "Do select `CountryCode` and `max(Percentage)` instead of `country_code` alone. Do query from `countrylanguage` table instead of `countries` table. Do use aggregate function `max(Percentage)` with `GROUP BY CountryCode` instead of selecting individual rows without aggregation. Do filter on `LANGUAGE = \"Spanish\"` instead of `language = 'Spanish'` to match the correct column name and value format. The amended query now correctly retrieves the maximum Spanish language percentage for each country code from the appropriate table."
        ],
        "rules": [
            "When answering about country codes where Spanish is predominantly spoken: select \"CountryCode\" and the maximum \"Percentage\" value.",
            "When the question mentions \"countries\": the data actually comes from the \"countrylanguage\" table instead of the \"countries\" table.",
            "When the question asks for \"predominantly spoken language\": use aggregate function max(\"Percentage\") with GROUP BY \"CountryCode\" instead of selecting individual rows.",
            "When filtering for Spanish language: use the exact condition \"LANGUAGE\" = \"Spanish\" to match the correct column name and value format.",
            "When answering about country codes where Spanish is predominantly spoken, When the question mentions \"countries\", When the question asks for \"predominantly spoken language\", When filtering for Spanish language, When combining data for language analysis: group by \"CountryCode\" to get the maximum percentage per country."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country_code FROM countries WHERE language = 'Spanish';",
            "SELECT CountryCode, MAX(Percentage) FROM countrylanguage WHERE Language = \"Spanish\" GROUP BY CountryCode"
        ],
        "rule_sql": [
            "SELECT CountryCode, MAX(Percentage) FROM countrylanguage WHERE Language = 'Spanish' GROUP BY CountryCode"
        ]
    },
    "822": {
        "db_id": "orchestra",
        "question": "How many conductors are there?",
        "ground_truth": "SELECT count(*) FROM conductor",
        "amends": [
            "Do query the `conductor` table instead of the `employees` table. Do use the table name `conductor` instead of filtering `employees` with `WHERE job_title = 'conductor'`. The amended query now correctly counts records from the conductor table directly rather than filtering employees by job title, matching the right SQL's behavior."
        ],
        "rules": [
            "When answering about \"how many conductors\": query the \"conductor\" table directly instead of filtering another table.",
            "When answering about \"how many conductors\", When counting conductors: count all records from the \"conductor\" table using the canonical key for conductors."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE job_title = 'conductor';",
            "SELECT COUNT(*) FROM conductor;"
        ],
        "rule_sql": [
            "SELECT COUNT(Conductor_ID) FROM conductor;"
        ]
    },
    "823": {
        "db_id": "orchestra",
        "question": "Count the number of conductors.",
        "ground_truth": "SELECT count(*) FROM conductor",
        "amends": [
            "Do query the `conductor` table instead of the `employees` table. Do use the table name `conductor` instead of filtering `employees` with `WHERE job_title = 'conductor'`. The amended query now correctly counts records from the conductor table directly instead of filtering employees by job title, matching the right SQL's behavior."
        ],
        "rules": [
            "When counting conductors: use the \"conductor\" table directly instead of filtering another table by job title.",
            "When counting conductors, When the question asks for \"count of conductors\": compute the number of rows using the canonical key from the \"conductor\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE job_title = 'conductor';",
            "SELECT COUNT(*) FROM conductor;"
        ],
        "rule_sql": [
            "SELECT COUNT(Conductor_ID) FROM conductor;"
        ]
    },
    "824": {
        "db_id": "orchestra",
        "question": "List the names of conductors in ascending order of age.",
        "ground_truth": "SELECT Name FROM conductor ORDER BY Age ASC",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the `conductor` table instead of `conductors`. Do order by `Age` in ascending order instead of descending order. The amended query now correctly references the proper table and column names with the intended sort direction."
        ],
        "rules": [
            "When the question asks for conductor names: use the exact column token \"Name\" from table \"conductor\".",
            "When ordering by age in ascending order: use the exact column token \"Age\" from table \"conductor\" and sort from lowest to highest values.",
            "When the question asks for conductor names, When ordering by age in ascending order, When referencing the conductor table: use the exact table name \"conductor\" (not \"conductors\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM conductors ORDER BY age DESC;",
            "SELECT Name FROM conductor ORDER BY Age ASC;"
        ],
        "rule_sql": [
            "SELECT Name FROM conductor ORDER BY Age ASC;"
        ]
    },
    "825": {
        "db_id": "orchestra",
        "question": "What are the names of conductors, ordered by age?",
        "ground_truth": "SELECT Name FROM conductor ORDER BY Age ASC",
        "amends": [
            "Do select `Name` instead of `name` and order by `Age ASC` instead of `name`. Do use table `conductor` instead of `conductors`."
        ],
        "rules": [
            "When the question asks for conductor names: use the exact column token \"Name\" from table \"conductor\" instead of \"name\".",
            "When ordering conductors by age: order by column \"Age ASC\" instead of by name.",
            "When the question asks for conductor names, When ordering conductors by age, When referring to the conductors table: use table name \"conductor\" instead of \"conductors\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM conductors ORDER BY name;",
            "SELECT Name FROM conductor ORDER BY Age ASC;"
        ],
        "rule_sql": [
            "SELECT Name FROM conductor ORDER BY Age ASC;"
        ]
    },
    "826": {
        "db_id": "orchestra",
        "question": "What are the names of conductors whose nationalities are not \"USA\"?",
        "ground_truth": "SELECT Name FROM conductor WHERE Nationality != 'USA'",
        "amends": [
            "Do reference table `conductor` instead of `conductors`. Do use column `Name` instead of `name`. Do use column `Nationality` instead of `nationality`. Do use inequality filter `!= 'USA'` instead of equality filter `= 'USA'`. The amended query now correctly filters for non-USA conductors using the proper table and column names."
        ],
        "rules": [
            "When the question asks about conductors: use table \"conductor\" instead of \"conductors\".",
            "When the question mentions \"names\": use column \"Name\" instead of \"name\".",
            "When the question mentions \"nationalities\": use column \"Nationality\" instead of \"nationality\".",
            "When the question asks about conductors, When the question mentions \"names\", When the question mentions \"nationalities\", When filtering for conductors whose nationalities are not \"USA\": use inequality filter != 'USA' instead of equality filter = 'USA'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM conductors WHERE nationality = 'USA';",
            "SELECT Name FROM conductor WHERE Nationality != 'USA';"
        ],
        "rule_sql": [
            "SELECT Name FROM conductor WHERE Nationality != 'USA';"
        ]
    },
    "827": {
        "db_id": "orchestra",
        "question": "Return the names of conductors that do not have the nationality \"USA\".",
        "ground_truth": "SELECT Name FROM conductor WHERE Nationality != 'USA'",
        "amends": [
            "Do reference table `conductor` instead of `conductors` and use column `Name` instead of `name`. Do use filter condition `Nationality != 'USA'` instead of `nationality = 'USA'` to select non-US conductors instead of US conductors. The amended query now correctly references the proper table and column names while fixing the filter logic to match the intended behavior."
        ],
        "rules": [
            "When the question asks about conductors: use table \"conductor\" instead of \"conductors\" and column \"Name\" instead of \"name\".",
            "When the question asks for conductors that do not have USA nationality: use filter condition \"Nationality != 'USA'\" instead of \"nationality = 'USA'\".",
            "When the question asks about conductors, When the question asks for conductors that do not have USA nationality, When producing output: return only the \"Name\" column from the \"conductor\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM conductors WHERE nationality = 'USA';",
            "SELECT Name FROM conductor WHERE Nationality != 'USA';"
        ],
        "rule_sql": [
            "SELECT Name FROM conductor WHERE Nationality != 'USA';"
        ]
    },
    "828": {
        "db_id": "orchestra",
        "question": "What are the record companies of orchestras in descending order of years in which they were founded?",
        "ground_truth": "SELECT Record_Company FROM orchestra ORDER BY Year_of_Founded DESC",
        "amends": [
            "Do reference `Record_Company` instead of `o.record_company` and remove `o.founded_year` from the SELECT list instead of including it. Do reference table `orchestra` instead of `orchestras o` with alias. Do change ORDER BY to `Year_of_Founded DESC` instead of `o.founded_year ASC` by using a different column name and reversing the sort direction. The amended query now correctly selects only the record company column from the orchestra table and orders by year of founding in descending order."
        ],
        "rules": [
            "When answering about \"record companies of orchestras\": make sure the output order: \"Record_Company\" only.",
            "When the question mentions \"years in which they were founded\": \"years\" actually means \"Year_of_Founded in schema\".",
            "When the question asks for \"descending order\": rank rows by \"Year_of_Founded\" in descending direction.",
            "When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for \"Record_Company\" and \"Year_of_Founded\".",
            "When answering about \"record companies of orchestras\", When the question mentions \"years in which they were founded\", When the question asks for \"descending order\", When choosing identifier delimiters, When referring to table roles: use table \"orchestra\" as the base table without additional aliases."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT o.record_company, o.founded_year FROM orchestras o ORDER BY o.founded_year ASC;",
            "SELECT Record_Company FROM orchestra ORDER BY Year_of_Founded DESC;"
        ],
        "rule_sql": [
            "SELECT \"Record_Company\" FROM \"orchestra\" ORDER BY \"Year_of_Founded\" DESC;"
        ]
    },
    "829": {
        "db_id": "orchestra",
        "question": "Return the record companies of orchestras, sorted descending by the years in which they were founded.",
        "ground_truth": "SELECT Record_Company FROM orchestra ORDER BY Year_of_Founded DESC",
        "amends": [
            "Do reference the `Record_Company` column instead of `record_company` and remove the `founded_year` column instead of including it. Do use the `orchestra` table instead of `orchestras` as the data source. Do order by `Year_of_Founded` instead of `founded_year` and use `DESC` ordering instead of `ASC`. The amended query now correctly selects only the record company column from the orchestra table ordered by year of founding in descending order."
        ],
        "rules": [
            "When answering about \"record companies of orchestras\": make sure the output order: \"Record_Company\" only.",
            "When the question mentions \"record companies\": \"record companies\" actually means \"Record_Company\" in schema.",
            "When the question mentions \"years in which they were founded\": \"years in which they were founded\" actually means \"Year_of_Founded\" in schema.",
            "When the question says \"sorted descending by the years\": rank rows by \"Year_of_Founded\" in descending order.",
            "When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms.",
            "When answering about \"record companies of orchestras\", When the question mentions \"record companies\", When the question mentions \"years in which they were founded\", When the question says \"sorted descending by the years\", When choosing identifier delimiters, When handling text literals: do not change case, spacing, or punctuation for values like 'Mercury Records', 'Columbia Masterworks', 'Philips', 'Kultur', 'Decca Records'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT record_company, founded_year FROM orchestras ORDER BY founded_year ASC;",
            "SELECT Record_Company FROM orchestra ORDER BY Year_of_Founded DESC;"
        ],
        "rule_sql": [
            "SELECT \"Record_Company\" FROM \"orchestra\" ORDER BY \"Year_of_Founded\" DESC;"
        ]
    },
    "830": {
        "db_id": "orchestra",
        "question": "What is the average attendance of shows?",
        "ground_truth": "SELECT avg(Attendance) FROM SHOW",
        "amends": [
            "Do use the correct column name `Attendance` instead of the incorrect `show_name` column. Do reference the correct table name `SHOW` instead of the incorrect `shows` table. Do use lowercase `avg` function instead of uppercase `AVG` for consistency with the target query format. The amended query now correctly calculates the average attendance from the SHOW table instead of attempting to average an incorrect column name."
        ],
        "rules": [
            "When answering about \"average attendance of shows\": use the exact column name \"Attendance\" from the \"SHOW\" table.",
            "When computing the average: use the lowercase \"avg\" function for consistency with the target query format.",
            "When answering about \"average attendance of shows\", When computing the average, When referencing the table containing attendance data: use the exact table name \"SHOW\" instead of any variations like \"shows\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(show_name) FROM shows;",
            "SELECT avg(Attendance) FROM show;"
        ],
        "rule_sql": [
            "SELECT avg(Attendance) FROM show"
        ]
    },
    "831": {
        "db_id": "orchestra",
        "question": "Return the average attendance across all shows.",
        "ground_truth": "SELECT avg(Attendance) FROM SHOW",
        "amends": [
            "Do use the `avg` aggregate function instead of `SUM` to calculate the average attendance rather than the total sum. Do reference the column as `Attendance` with proper capitalization instead of lowercase `attendance`. Do query from the `SHOW` table instead of the plural `shows` table. The amended query now correctly calculates average attendance from the appropriate table with proper column reference."
        ],
        "rules": [
            "When calculating average attendance: use the avg aggregate function instead of sum to compute the average value.",
            "When referencing the attendance column: use exact column name \"Attendance\" with proper capitalization instead of lowercase \"attendance\".",
            "When calculating average attendance, When referencing the attendance column, When querying from the shows table: use the exact table name \"SHOW\" instead of the plural form \"shows\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(attendance) FROM shows;",
            "SELECT AVG(Attendance) FROM show;"
        ],
        "rule_sql": [
            "SELECT AVG(Attendance) FROM SHOW;"
        ]
    },
    "832": {
        "db_id": "orchestra",
        "question": "What are the maximum and minimum share of performances whose type is not \"Live final\".",
        "ground_truth": "SELECT max(SHARE) ,  min(SHARE) FROM performance WHERE TYPE != \"Live final\"",
        "amends": [
            "Do filter with `TYPE != \"Live final\"` instead of `type = 'Live final'` to exclude rather than include live final performances. Do reference table `performance` instead of `performances` to use the correct table name. The amended query now correctly excludes live final performances and uses the proper table name, matching the intended behavior."
        ],
        "rules": [
            "When the question asks about performances whose type is not \"Live final\": filter rows where \"TYPE\" is not equal to \"Live final\" exactly.",
            "When referencing the performances table: use the exact table name \"performance\" (not \"performances\").",
            "When the question asks about performances whose type is not \"Live final\", When referencing the performances table, When computing maximum and minimum share values: calculate MAX(\"share\") and MIN(\"share\") on the filtered dataset."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(share), MIN(share) FROM performances WHERE type = 'Live final';",
            "SELECT MAX(Share) AS max_share, MIN(Share) AS min_share FROM performance WHERE Type != 'Live final'"
        ],
        "rule_sql": [
            "SELECT MAX(\"Share\") AS max_share, MIN(\"Share\") AS min_share FROM performance WHERE \"Type\" != 'Live final'"
        ]
    },
    "833": {
        "db_id": "orchestra",
        "question": "Return the maximum and minimum shares for performances that do not have the type \"Live final\".",
        "ground_truth": "SELECT max(SHARE) ,  min(SHARE) FROM performance WHERE TYPE != \"Live final\"",
        "amends": [
            "Do reference column `SHARE` instead of `shares` in both aggregate functions. Do use table `performance` instead of `performances` as the FROM source. Do change the WHERE filter to `TYPE != \"Live final\"` instead of `type = 'Live final'` to exclude rather than include those records. Do correct the column case to `SHARE` and table name to `performance` to match the actual schema. The amended query now correctly calculates maximum and minimum share values from the performance table excluding Live final entries, matching the RIGHT_SQL behavior."
        ],
        "rules": [
            "When the question asks for maximum and minimum shares: use MAX(\"SHARE\") and MIN(\"SHARE\") as the aggregate functions.",
            "When the question specifies performances that do not have type \"Live final\": filter records using WHERE \"TYPE\" != \"Live final\" to exclude rather than include.",
            "When referencing the performance table: use the exact table name \"performance\" (not \"performances\").",
            "When the question asks for maximum and minimum shares, When the question specifies performances that do not have type \"Live final\", When referencing the performance table, When handling column names: use exact case-sensitive identifiers \"SHARE\" and \"TYPE\" with double quotes as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(shares), MIN(shares) FROM performances WHERE type = 'Live final';",
            "SELECT MAX(SHARE) AS max_share, MIN(SHARE) AS min_share FROM performance WHERE Type != 'Live final'"
        ],
        "rule_sql": [
            "SELECT MAX(\"SHARE\") AS max_share, MIN(\"SHARE\") AS min_share FROM \"performance\" WHERE \"TYPE\" != \"Live final\""
        ]
    },
    "834": {
        "db_id": "orchestra",
        "question": "How many different nationalities do conductors have?",
        "ground_truth": "SELECT count(DISTINCT Nationality) FROM conductor",
        "amends": [
            "Do use `count(DISTINCT Nationality)` instead of `COUNT(*)` to count distinct nationalities rather than all rows. Do reference table `conductor` instead of `conductors` with the correct table name. Do add the `DISTINCT` modifier to count unique values instead of including duplicates. The amended query now correctly counts distinct nationalities from the conductor table."
        ],
        "rules": [
            "When counting different nationalities: use count(DISTINCT Nationality) instead of COUNT(*) to count distinct values rather than all rows.",
            "When referencing the conductor table: use the exact table name \"conductor\" instead of \"conductors\".",
            "When counting different nationalities, When referencing the conductor table, When counting distinct values: add the DISTINCT modifier to count unique values instead of including duplicates."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM conductors;",
            "SELECT COUNT(DISTINCT Nationality) FROM conductor;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Nationality) FROM conductor;"
        ]
    },
    "835": {
        "db_id": "orchestra",
        "question": "Count the number of different nationalities of conductors.",
        "ground_truth": "SELECT count(DISTINCT Nationality) FROM conductor",
        "amends": [
            "Do `count(DISTINCT Nationality)` instead of `COUNT(*)` to count distinct nationalities rather than all rows. Do reference table `conductor` instead of `conductors` to use the correct table name. Do add the `DISTINCT` modifier instead of omitting it to ensure unique nationality counting. Do remove the asterisk wildcard instead of keeping it to specify the exact column for aggregation. The amended query now correctly counts distinct nationalities from the conductor table."
        ],
        "rules": [
            "When counting different nationalities of conductors: count distinct values of the \"Nationality\" column from the \"conductor\" table.",
            "When the question asks for \"number of different nationalities\": use the exact column name \"Nationality\" with the DISTINCT modifier to count unique values.",
            "When counting different nationalities of conductors, When the question asks for \"number of different nationalities\", When referencing the conductor table: use the exact table name \"conductor\" (not \"conductors\") as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM conductors;",
            "SELECT COUNT(DISTINCT Nationality) FROM conductor;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Nationality) FROM conductor;"
        ]
    },
    "836": {
        "db_id": "orchestra",
        "question": "List names of conductors in descending order of years of work.",
        "ground_truth": "SELECT Name FROM conductor ORDER BY Year_of_Work DESC",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the `conductor` table instead of `conductors`. Do order by `Year_of_Work DESC` instead of `years_of_work ASC`, changing both the column reference and sort direction. The amended query now correctly references the proper table and column names with the intended descending sort order."
        ],
        "rules": [
            "When answering about \"names of conductors\": use the exact column token \"Name\" from table conductor.",
            "When the question mentions \"conductors\": it actually means table \"conductor\" in the schema.",
            "When the question asks for \"descending order of years of work\": order by column \"Year_of_Work\" in descending direction.",
            "When answering about \"names of conductors\", When the question mentions \"conductors\", When the question asks for \"descending order of years of work\", When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM conductors ORDER BY years_of_work ASC;",
            "SELECT Name FROM conductor ORDER BY Year_of_Work DESC;"
        ],
        "rule_sql": [
            "SELECT \"Name\" FROM \"conductor\" ORDER BY \"Year_of_Work\" DESC;"
        ]
    },
    "837": {
        "db_id": "orchestra",
        "question": "What are the names of conductors, sorted descending by the number of years they have worked?",
        "ground_truth": "SELECT Name FROM conductor ORDER BY Year_of_Work DESC",
        "amends": [
            "Do select `Name` instead of `name, years_worked` and remove the `years_worked` column from the output. Do reference table `conductor` instead of `conductors` as the data source. Do order by `Year_of_Work DESC` instead of `years_worked ASC` to sort in descending order by the correct column name. The amended query now correctly selects only the name column from the conductor table ordered by years of work in descending order, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"names of conductors\": make sure the output order: \"Name\" from table \"conductor\".",
            "When the question mentions \"number of years they have worked\": \"years worked\" actually means \"Year_of_Work\" in schema.",
            "When the question asks for sorting \"descending by the number of years\": rank rows by \"Year_of_Work\" in descending direction.",
            "When answering about \"names of conductors\", When the question mentions \"number of years they have worked\", When the question asks for sorting \"descending by the number of years\", When selecting output columns: include only \"Name\" and remove \"Year_of_Work\" from the final output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, years_worked FROM conductors ORDER BY years_worked ASC;",
            "SELECT Name FROM conductor ORDER BY Year_of_Work DESC;"
        ],
        "rule_sql": [
            "SELECT Name FROM conductor ORDER BY Year_of_Work DESC;"
        ]
    },
    "838": {
        "db_id": "orchestra",
        "question": "List the name of the conductor with the most years of work.",
        "ground_truth": "SELECT Name FROM conductor ORDER BY Year_of_Work DESC LIMIT 1",
        "amends": [
            "Do reference table `conductor` instead of `conductors` and use column `Name` instead of `name` in the SELECT list. Do use column `Year_of_Work` for ordering instead of `years_worked` while maintaining the same DESC ordering and LIMIT 1 clause. The amended query now correctly references the intended table and column names to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"conductor with the most years of work\": make sure the output order: \"Name\" from table \"conductor\".",
            "When the question mentions \"most years of work\": use column \"Year_of_Work\" for ordering in descending direction and keep only the first 1 row.",
            "When answering about \"conductor with the most years of work\", When the question mentions \"most years of work\", When choosing identifier delimiters: use double quotes for column names exactly as shown in the schema (\"Name\", \"Year_of_Work\") and table name (\"conductor\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM conductors ORDER BY years_worked DESC LIMIT 1;",
            "SELECT Name FROM conductor ORDER BY Year_of_Work DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT \"Name\" FROM \"conductor\" ORDER BY \"Year_of_Work\" DESC LIMIT 1"
        ]
    },
    "839": {
        "db_id": "orchestra",
        "question": "What is the name of the conductor who has worked the greatest number of years?",
        "ground_truth": "SELECT Name FROM conductor ORDER BY Year_of_Work DESC LIMIT 1",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the `conductor` table instead of `conductors`. Do order by `Year_of_Work` instead of `years_worked` while maintaining the same DESC ordering and LIMIT 1 clause. The amended query now correctly references the proper table and column names to match the intended behavior."
        ],
        "rules": [
            "When the question asks about conductors: use the table \"conductor\" instead of \"conductors\".",
            "When selecting the conductor's name: use the column \"Name\" instead of \"name\".",
            "When ordering by years worked: use the column \"Year_of_Work\" instead of \"years_worked\" while maintaining descending order.",
            "When the question asks about conductors, When selecting the conductor's name, When ordering by years worked, When finding the conductor with the greatest number of years worked: keep only the top result using LIMIT 1."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM conductors ORDER BY years_worked DESC LIMIT 1;",
            "SELECT Name FROM conductor ORDER BY Year_of_Work DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name FROM conductor ORDER BY Year_of_Work DESC LIMIT 1;"
        ]
    },
    "840": {
        "db_id": "orchestra",
        "question": "Show the names of conductors and the orchestras they have conducted.",
        "ground_truth": "SELECT T1.Name ,  T2.Orchestra FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference column `Name` from table `T1` instead of `conductor_name`. Do reference column `Orchestra` from table `T2` instead of `orchestra_name`. Do use table name `conductor` instead of `conductors`. Do use table name `orchestra` instead of `orchestras`. Do use column name `Conductor_ID` instead of `conductor_id` in both join conditions. The amended query now correctly matches the intended behavior with proper table and column references."
        ],
        "rules": [
            "When answering about \"names of conductors and the orchestras they have conducted\": make sure the output order: T1.Name, T2.Orchestra.",
            "When the question mentions \"conductors\": use table \"conductor\" with alias T1 and column \"Name\" for conductor names.",
            "When the question mentions \"orchestras\": use table \"orchestra\" with alias T2 and column \"Orchestra\" for orchestra names.",
            "When combining T1 and T2 for shared entities: link rows where T1.Conductor_ID = T2.Conductor_ID; keep only matching pairs (inner match).",
            "When answering about \"names of conductors and the orchestras they have conducted\", When the question mentions \"conductors\", When the question mentions \"orchestras\", When combining T1 and T2 for shared entities, When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for column names like \"Name\" and \"Orchestra\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT conductor_name, orchestra_name FROM conductors JOIN orchestras ON conductors.conductor_id = orchestras.conductor_id;",
            "SELECT T1.Name, T2.Orchestra FROM conductor T1 JOIN orchestra T2 ON T1.Conductor_ID = T2.Conductor_ID"
        ],
        "rule_sql": [
            "SELECT T1.\"Name\", T2.\"Orchestra\" FROM conductor T1 INNER JOIN orchestra T2 ON T1.\"Conductor_ID\" = T2.\"Conductor_ID\""
        ]
    },
    "841": {
        "db_id": "orchestra",
        "question": "What are the names of conductors as well as the corresonding orchestras that they have conducted?",
        "ground_truth": "SELECT T1.Name ,  T2.Orchestra FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference column `Name` from table `T1` instead of `conductor_name`. Do reference column `Orchestra` from table `T2` instead of `orchestra_name`. Do join table `conductor AS T1` instead of `conductors`. Do join table `orchestra AS T2` instead of `orchestras`. Do use join condition `T1.Conductor_ID = T2.Conductor_ID` instead of `conductors.conductor_id = orchestras.conductor_id`. The amended query now correctly matches the intended behavior with proper table aliases and column references."
        ],
        "rules": [
            "When answering about conductor names and their corresponding orchestras: make sure the output order: T1.\"Name\", T2.\"Orchestra\"",
            "When combining conductor table as T1 and orchestra table as T2: link rows where T1.\"Conductor_ID\" = T2.\"Conductor_ID\" exactly and keep only matching pairs (inner match)",
            "When the question mentions \"names of conductors\": \"names of conductors\" actually means T1.\"Name\" in schema",
            "When answering about conductor names and their corresponding orchestras, When combining conductor table as T1 and orchestra table as T2, When the question mentions \"names of conductors\", When the question mentions \"orchestras that they have conducted\": \"orchestras that they have conducted\" actually means T2.\"Orchestra\" in schema"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT conductor_name, orchestra_name FROM conductors JOIN orchestras ON conductors.conductor_id = orchestras.conductor_id;",
            "SELECT T1.Name, T2.Orchestra FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID = T2.Conductor_ID;"
        ],
        "rule_sql": [
            "SELECT T1.\"Name\", T2.\"Orchestra\" FROM conductor T1 INNER JOIN orchestra T2 ON T1.\"Conductor_ID\" = T2.\"Conductor_ID\""
        ]
    },
    "842": {
        "db_id": "orchestra",
        "question": "Show the names of conductors that have conducted more than one orchestras.",
        "ground_truth": "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID GROUP BY T2.Conductor_ID HAVING COUNT(*)  >  1",
        "amends": [
            "Do select `T1.Name` with table alias qualification instead of unqualified `name`. Do use `JOIN` between `conductor AS T1` and `orchestra AS T2` with join condition `T1.Conductor_ID = T2.Conductor_ID` instead of querying only `conductors` table. Do add `GROUP BY T2.Conductor_ID` to group by the conductor identifier instead of no grouping. Do move the count filter to `HAVING COUNT(*) > 1` instead of using `WHERE orchestra_count > 1` with a direct column filter. The amended query now correctly identifies conductors who lead multiple orchestras by counting orchestra associations rather than relying on a pre-calculated count column."
        ],
        "rules": [
            "When answering about \"conductors that have conducted more than one orchestras\": make sure the output order: T1.Name",
            "When combining conductor table (T1) and orchestra table (T2) for shared entities: link rows where T1.Conductor_ID = T2.Conductor_ID; keep only matching pairs (inner match).",
            "When the question asks for conductors by orchestra count: organize results by T2.Conductor_ID and compute COUNT(*) per group.",
            "When filtering for conductors with more than one orchestra: apply the condition COUNT(*) > 1 in the grouping filter instead of using a direct column filter.",
            "When answering about \"conductors that have conducted more than one orchestras\", When combining conductor table (T1) and orchestra table (T2) for shared entities, When the question asks for conductors by orchestra count, When filtering for conductors with more than one orchestra, When selecting conductor names: use qualified identifier T1.Name instead of unqualified name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM conductors WHERE orchestra_count > 1;",
            "SELECT T1.Name \nFROM conductor AS T1 \nJOIN orchestra AS T2 ON T1.Conductor_ID = T2.Conductor_ID \nGROUP BY T2.Conductor_ID \nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM conductor T1 INNER JOIN orchestra T2 ON T1.Conductor_ID = T2.Conductor_ID GROUP BY T2.Conductor_ID HAVING COUNT(*) > 1 ORDER BY T1.Name;"
        ]
    },
    "843": {
        "db_id": "orchestra",
        "question": "What are the names of conductors who have conducted at more than one orchestra?",
        "ground_truth": "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID GROUP BY T2.Conductor_ID HAVING COUNT(*)  >  1",
        "amends": [
            "Do select `T1.Name` with table alias qualification instead of just `name` without source specification. Do join `conductor AS T1` with `orchestra AS T2` on `T1.Conductor_ID = T2.Conductor_ID` instead of querying only the `conductors` table without any join. Do add `GROUP BY T2.Conductor_ID` to group by the conductor identifier instead of missing aggregation grouping. Do move the count filter to `HAVING COUNT(*) > 1` instead of using `WHERE orchestra_count > 1` which incorrectly references a non-existent column. The amended query now correctly counts orchestra associations per conductor and filters for those conducting multiple orchestras, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"names of conductors who have conducted at more than one orchestra\": make sure the output order: T1.Name.",
            "When combining T1 and T2 for shared entities: link rows where T1.Conductor_ID = T2.Conductor_ID exactly as shown; keep only matching pairs (inner match).",
            "When the question asks for \"count of orchestra associations per conductor\": compute the number of orchestras using COUNT(*) grouped by T2.Conductor_ID.",
            "When filtering for conductors with more than one orchestra: apply the condition COUNT(*) > 1 in the HAVING clause instead of WHERE.",
            "When answering about \"names of conductors who have conducted at more than one orchestra\", When combining T1 and T2 for shared entities, When the question asks for \"count of orchestra associations per conductor\", When filtering for conductors with more than one orchestra, When selecting conductor names: use T1.Name with table alias qualification instead of unqualified name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM conductors WHERE orchestra_count > 1;",
            "SELECT T1.Name\nFROM conductor AS T1\nJOIN orchestra AS T2 ON T1.Conductor_ID = T2.Conductor_ID\nGROUP BY T1.Conductor_ID\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T1.Name\nFROM conductor T1\nINNER JOIN orchestra T2 ON T1.Conductor_ID = T2.Conductor_ID\nGROUP BY T1.Conductor_ID\nHAVING COUNT(*) > 1\nORDER BY T1.Name"
        ]
    },
    "844": {
        "db_id": "orchestra",
        "question": "Show the name of the conductor that has conducted the most number of orchestras.",
        "ground_truth": "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID GROUP BY T2.Conductor_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.Name` instead of `conductor_name` and remove the `COUNT(*) as orchestra_count` column from the SELECT list. Do join `orchestra AS T2` instead of querying only the `conductors` table, using `JOIN` on `T1.Conductor_ID = T2.Conductor_ID` instead of no join condition. Do group by `T2.Conductor_ID` instead of `conductor_name` to properly aggregate by conductor identifier. Do order by `COUNT(*) DESC` instead of the alias `orchestra_count` since the alias is no longer selected. The amended query now correctly retrieves conductor names by joining the conductor and orchestra tables and counting orchestras per conductor, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"conductor that has conducted the most number of orchestras\": make sure the output order: T1.Name only.",
            "When combining conductors table as T1 and orchestra table as T2: link rows where T1.Conductor_ID = T2.Conductor_ID and keep only matching pairs (inner match).",
            "When counting orchestras per conductor: compute the number of rows using T2.Conductor_ID as the grouping key.",
            "When answering about \"conductor that has conducted the most number of orchestras\", When combining conductors table as T1 and orchestra table as T2, When counting orchestras per conductor, When the question asks for \"most number of orchestras\": rank rows by COUNT(*) in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT conductor_name, COUNT(*) as orchestra_count \nFROM conductors \nGROUP BY conductor_name \nORDER BY orchestra_count DESC \nLIMIT 1;",
            "SELECT T1.Name\nFROM conductor AS T1\nJOIN orchestra AS T2 ON T1.Conductor_ID = T2.Conductor_ID\nGROUP BY T2.Conductor_ID\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Name\nFROM conductor AS T1\nINNER JOIN orchestra AS T2 ON T1.Conductor_ID = T2.Conductor_ID\nGROUP BY T2.Conductor_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "845": {
        "db_id": "orchestra",
        "question": "What is the name of the conductor who has conducted the most orchestras?",
        "ground_truth": "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID GROUP BY T2.Conductor_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do join `conductor` and `orchestra` tables with `INNER JOIN` on `T1.Conductor_ID = T2.Conductor_ID` instead of querying only `conductors` table. Do add `GROUP BY T2.Conductor_ID` to aggregate by conductor instead of ordering without grouping. Do use `COUNT(*)` in the `ORDER BY` clause to sort by orchestra count instead of using `orchestra_count` column. Do select `T1.Name` from the joined conductor table instead of selecting `name` from a single table. The amended query now correctly identifies the conductor with the most orchestras by joining and counting related records."
        ],
        "rules": [
            "When answering about \"conductor who has conducted the most orchestras\": make sure the output order: T1.Name.",
            "When combining conductor and orchestra tables: link rows where T1.Conductor_ID = T2.Conductor_ID exactly as shown; keep only matching pairs (inner match).",
            "When the question asks for \"most orchestras\" per conductor: organize results by T2.Conductor_ID and compute COUNT(*) per group.",
            "When the question mentions \"most\": rank rows by COUNT(*) in descending direction and keep the first 1 row.",
            "When answering about \"conductor who has conducted the most orchestras\", When combining conductor and orchestra tables, When the question asks for \"most orchestras\" per conductor, When the question mentions \"most\", When selecting the conductor name: use T1.Name from the conductor table instead of name from a single table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM conductors ORDER BY orchestra_count DESC LIMIT 1;",
            "SELECT T1.Name\nFROM conductor T1\nINNER JOIN orchestra T2 ON T1.Conductor_ID = T2.Conductor_ID\nGROUP BY T2.Conductor_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Name\nFROM conductor T1\nINNER JOIN orchestra T2 ON T1.Conductor_ID = T2.Conductor_ID\nGROUP BY T2.Conductor_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "846": {
        "db_id": "orchestra",
        "question": "Please show the name of the conductor that has conducted orchestras founded after 2008.",
        "ground_truth": "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID WHERE Year_of_Founded  >  2008",
        "amends": [
            "Do select `T1.Name` with table alias qualification instead of unqualified `name`. Do join `orchestra AS T2` on `T1.Conductor_ID = T2.Conductor_ID` instead of querying only the `conductors` table without any join. Do filter on `Year_of_Founded > 2008` instead of `orchestra_founded > 2008` since the founding year is in the orchestra table. The amended query now correctly retrieves conductor names by joining with the orchestra table and filtering on the orchestra's founding year, matching the intended behavior."
        ],
        "rules": [
            "When answering about conductors and orchestras founded after 2008: make sure to join conductors table (T1) with orchestra table (T2) using T1.Conductor_ID = T2.Conductor_ID to link conductors to their orchestras.",
            "When filtering for orchestras founded after 2008: use T2.Year_of_Founded > 2008 instead of orchestra_founded since the founding year is in the orchestra table.",
            "When answering about conductors and orchestras founded after 2008, When filtering for orchestras founded after 2008, When selecting conductor names: use T1.Name with table alias qualification instead of unqualified name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM conductors WHERE orchestra_founded > 2008;",
            "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID = T2.Conductor_ID WHERE T2.Year_of_Founded > 2008"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM conductor T1 JOIN orchestra T2 ON T1.Conductor_ID = T2.Conductor_ID WHERE T2.Year_of_Founded > 2008;"
        ]
    },
    "847": {
        "db_id": "orchestra",
        "question": "What are the names of conductors who have conducted orchestras founded after the year 2008?",
        "ground_truth": "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID WHERE Year_of_Founded  >  2008",
        "amends": [
            "Do use `T1.Name` with table alias instead of `name` without qualification. Do join `conductor AS T1` to `orchestra AS T2` on `T1.Conductor_ID = T2.Conductor_ID` instead of querying only the `conductors` table. Do filter on `Year_of_Founded > 2008` instead of `orchestra_founded_year > 2008`. The amended query now correctly joins the conductor and orchestra tables to find conductors leading orchestras founded after 2008, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"conductors who have conducted orchestras founded after the year 2008\": make sure the output order: T1.Name.",
            "When combining T1 (conductors) and T2 (orchestra) for shared entities: link rows where T1.Conductor_ID = T2.Conductor_ID exactly as shown; keep only matching pairs (inner match).",
            "When filtering orchestras by foundation year: use T2.Year_of_Founded > 2008 instead of orchestra_founded_year > 2008.",
            "When answering about \"conductors who have conducted orchestras founded after the year 2008\", When combining T1 (conductors) and T2 (orchestra) for shared entities, When filtering orchestras by foundation year, When selecting conductor names: use T1.Name with table alias qualification instead of unqualified name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM conductors WHERE orchestra_founded_year > 2008;",
            "SELECT T1.Name \nFROM conductor AS T1\nJOIN orchestra AS T2 ON T1.Conductor_ID = T2.Conductor_ID\nWHERE T2.Year_of_Founded > 2008;"
        ],
        "rule_sql": [
            "SELECT T1.Name \nFROM conductor T1\nINNER JOIN orchestra T2 ON T1.Conductor_ID = T2.Conductor_ID\nWHERE T2.Year_of_Founded > 2008\nORDER BY T1.Name;"
        ]
    },
    "848": {
        "db_id": "orchestra",
        "question": "Please show the different record companies and the corresponding number of orchestras.",
        "ground_truth": "SELECT Record_Company ,  COUNT(*) FROM orchestra GROUP BY Record_Company",
        "amends": [
            "Do reference the `Record_Company` column instead of `record_company` and use proper capitalization. Do group by `Record_Company` instead of `orchestra_name` to match the SELECT clause aggregation. Do reference the correct table name `orchestra` instead of `orchestras`. The amended query now correctly counts records grouped by record company rather than by orchestra name, matching the intended behavior."
        ],
        "rules": [
            "When the question asks about \"record companies\" and \"number of orchestras\": use the exact column token \"Record_Company\" from the orchestra table.",
            "When counting orchestras per record company: group by \"Record_Company\" and count using the canonical key for orchestras.",
            "When producing output: show \"Record_Company\" first followed by the count of orchestras.",
            "When the question asks about \"record companies\" and \"number of orchestras\", When counting orchestras per record company, When producing output, When referring to the table: use the exact table name \"orchestra\" (not \"orchestras\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT record_company, COUNT(*) FROM orchestras GROUP BY orchestra_name;",
            "SELECT Record_Company, COUNT(*) AS Number_of_Orchestras FROM orchestra GROUP BY Record_Company;"
        ],
        "rule_sql": [
            "SELECT Record_Company, COUNT(Orchestra_ID) AS Number_of_Orchestras FROM orchestra GROUP BY Record_Company;"
        ]
    },
    "849": {
        "db_id": "orchestra",
        "question": "How many orchestras does each record company manage?",
        "ground_truth": "SELECT Record_Company ,  COUNT(*) FROM orchestra GROUP BY Record_Company",
        "amends": [
            "Do reference the table as `orchestra` instead of `orchestras` and use the column name `Record_Company` with proper capitalization instead of `record_company` in both the SELECT clause and GROUP BY clause, while maintaining the same COUNT(*) aggregation logic. The amended query now correctly references the intended table and column names to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question mentions \"orchestras\": use the exact table name \"orchestra\" instead.",
            "When the question mentions \"record company\": use the exact column name \"Record_Company\" with proper capitalization.",
            "When the question mentions \"orchestras\", When the question mentions \"record company\", When counting orchestras per record company: count all rows using COUNT(*) aggregation and group by the exact column \"Record_Company\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT record_company, COUNT(*) FROM orchestras GROUP BY record_company;",
            "SELECT Record_Company, COUNT(*) FROM orchestra GROUP BY Record_Company"
        ],
        "rule_sql": [
            "SELECT Record_Company, COUNT(*) FROM orchestra GROUP BY Record_Company;"
        ]
    },
    "850": {
        "db_id": "orchestra",
        "question": "Please show the record formats of orchestras in ascending order of count.",
        "ground_truth": "SELECT Major_Record_Format FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*) ASC",
        "amends": [
            "Do select `Major_Record_Format` instead of `orchestra` and remove the alias `count`. Do group by `Major_Record_Format` instead of `orchestra`. Do order by `COUNT(*)` instead of the alias `count`. Do use table `orchestra` instead of `orchestras`. The amended query now correctly selects and groups by the Major_Record_Format column while ordering by the actual count aggregation rather than an alias reference.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, and do add `ASC` to the ORDER BY clause instead of omitting the sort direction specification. The amended query now correctly returns only the Major_Record_Format values grouped by that column while maintaining the count-based ordering with explicit ascending direction."
        ],
        "rules": [
            "When answering about \"record formats of orchestras\": make sure the output order: \"Major_Record_Format\" first, then the count.",
            "When the question mentions \"record formats\": \"record formats\" actually means \"Major_Record_Format\" in schema.",
            "When the question asks for \"count\": compute the number of rows using COUNT(*) without an alias.",
            "When the question says \"per record format\"/\"by record format\": organize results by \"Major_Record_Format\" and compute the count per group.",
            "When the question asks for \"ascending order of count\": order the results by COUNT(*) in ascending direction.",
            "When answering about \"record formats of orchestras\", When the question mentions \"record formats\", When the question asks for \"count\", When the question says \"per record format\"/\"by record format\", When the question asks for \"ascending order of count\", When choosing table names: use table \"orchestra\" instead of \"orchestras\".",
            "When answering about \"record formats of orchestras in ascending order of count\": make sure the output order: Major_Record_Format only without including the count value in the results.",
            "When ordering by count in ascending order: explicitly specify ASC direction in the ordering clause.",
            "When answering about \"record formats of orchestras in ascending order of count\", When ordering by count in ascending order, When grouping by Major_Record_Format: organize results by Major_Record_Format and compute counts per group for ordering purposes only, not for display in the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT orchestra, COUNT(*) as count FROM orchestras GROUP BY orchestra ORDER BY count ASC;",
            "SELECT Major_Record_Format, COUNT(*) FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*)",
            "SELECT Major_Record_Format FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*) ASC;"
        ],
        "rule_sql": [
            "SELECT Major_Record_Format FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*) ASC;"
        ]
    },
    "851": {
        "db_id": "orchestra",
        "question": "What are the major record formats of orchestras, sorted by their frequency?",
        "ground_truth": "SELECT Major_Record_Format FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*) ASC",
        "amends": [
            "Do use `Major_Record_Format` instead of `record_format` for the column name in the SELECT list and GROUP BY clause. Do use `orchestra` instead of `orchestras` for the table name. Do remove the explicit `COUNT(*) as frequency` column from the SELECT list instead of including it. Do change the ORDER BY direction to `ASC` instead of `DESC` for the count ordering. Do reference the count implicitly in ORDER BY instead of using an alias. The amended query now correctly selects and groups by the Major_Record_Format column from the orchestra table with ascending count ordering.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, and do remove the explicit `COUNT(*)` reference from the ORDER BY clause instead of keeping it, allowing the implicit count-based ordering to function correctly while only returning the grouped Major_Record_Format values."
        ],
        "rules": [
            "When the question mentions \"major record formats\": use the exact column name \"Major_Record_Format\" from the orchestra table.",
            "When counting entities in the orchestra table: count using the canonical key (implicit count of rows) rather than specifying an explicit count column.",
            "When the question asks for sorting by frequency: order the results by the count in ascending direction (ASC) rather than descending.",
            "When the question mentions \"major record formats\", When counting entities in the orchestra table, When the question asks for sorting by frequency, When producing output: include only the Major_Record_Format column in the results, not the count values themselves.",
            "When answering about \"major record formats of orchestras sorted by frequency\": make sure the output order: Major_Record_Format only without count values.",
            "When the question asks for sorting by frequency: order the results by the count of orchestras in descending frequency order.",
            "When grouping by Major_Record_Format: organize results by Major_Record_Format and compute the count per group.",
            "When answering about \"major record formats of orchestras sorted by frequency\", When the question asks for sorting by frequency, When grouping by Major_Record_Format, When producing output: do not include the count column in the final results, only show the Major_Record_Format values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT record_format, COUNT(*) as frequency FROM orchestras GROUP BY record_format ORDER BY frequency DESC;",
            "SELECT Major_Record_Format, COUNT(*) FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*) ASC;",
            "SELECT Major_Record_Format FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*) ASC;"
        ],
        "rule_sql": [
            "SELECT Major_Record_Format FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*) DESC;"
        ]
    },
    "852": {
        "db_id": "orchestra",
        "question": "List the record company shared by the most number of orchestras.",
        "ground_truth": "SELECT Record_Company FROM orchestra GROUP BY Record_Company ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select only `Record_Company` instead of selecting both `record_company` and `COUNT(*) as orchestra_count`. Do use the table name `orchestra` instead of `orchestras`. Do order by `COUNT(*) DESC` directly in the ORDER BY clause instead of ordering by the alias `orchestra_count DESC`. The amended query now correctly returns only the record company with the highest count of orchestras while matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"record company shared by the most number of orchestras\": make sure the output order: Record_Company only",
            "When the question mentions \"orchestras\": \"orchestras\" actually means \"orchestra in schema\"",
            "When the question asks for \"most number of orchestras\" per record company: organize results by Record_Company and compute count of orchestras per group, then rank groups by count in descending order and keep the first 1 row",
            "When counting orchestras: compute the number of rows using the table orchestra",
            "When answering about \"record company shared by the most number of orchestras\", When the question mentions \"orchestras\", When the question asks for \"most number of orchestras\" per record company, When counting orchestras, When ordering by count: order by COUNT(*) DESC directly instead of using an alias"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT record_company, COUNT(*) as orchestra_count \nFROM orchestras \nGROUP BY record_company \nORDER BY orchestra_count DESC \nLIMIT 1;",
            "SELECT Record_Company FROM orchestra GROUP BY Record_Company ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Record_Company FROM orchestra GROUP BY Record_Company ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "853": {
        "db_id": "orchestra",
        "question": "What is the record company used by the greatest number of orchestras?",
        "ground_truth": "SELECT Record_Company FROM orchestra GROUP BY Record_Company ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select only `Record_Company` instead of selecting both `record_company` and `COUNT(*) as orchestra_count`. Do use table name `orchestra` instead of `orchestras`. Do move the aggregate function `COUNT(*)` to the `ORDER BY` clause instead of including it in the `SELECT` list. Do capitalize `Record_Company` consistently instead of using lowercase `record_company`. The amended query now correctly returns only the record company with the highest count of orchestras while matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks about \"record company used by the greatest number of orchestras\": use the exact column token \"Record_Company\" from table \"orchestra\" instead of lowercase \"record_company\".",
            "When counting orchestras per record company: compute the count using all rows (COUNT(*)) but do not include the count in the output columns.",
            "When finding the record company with the greatest number of orchestras: order the results by the orchestra count in descending order and keep only the top result.",
            "When the question asks about \"record company used by the greatest number of orchestras\", When counting orchestras per record company, When finding the record company with the greatest number of orchestras, When referring to the table containing orchestras: use the exact table name \"orchestra\" instead of \"orchestras\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT record_company, COUNT(*) as orchestra_count \nFROM orchestras \nGROUP BY record_company \nORDER BY orchestra_count DESC \nLIMIT 1;",
            "SELECT Record_Company FROM orchestra GROUP BY Record_Company ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Record_Company FROM orchestra GROUP BY Record_Company ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "854": {
        "db_id": "orchestra",
        "question": "List the names of orchestras that have no performance.",
        "ground_truth": "SELECT Orchestra FROM orchestra WHERE Orchestra_ID NOT IN (SELECT Orchestra_ID FROM performance)",
        "amends": [
            "Do select `Orchestra` instead of `name` and use `orchestra` table instead of `orchestras`. Do use a `NOT IN` subquery checking for `Orchestra_ID` values that exist in the `performance` table instead of checking `performance_id IS NULL`. Do reference the correct table name `orchestra` instead of `orchestras` and use the proper column name `Orchestra` instead of `name`. The amended query now correctly identifies orchestras without performances by checking for missing entries in the performance table rather than relying on null values in a potentially incorrect column."
        ],
        "rules": [
            "When the question asks for orchestra names: use the exact column name \"Orchestra\" from the \"orchestra\" table.",
            "When identifying orchestras without performances: use a NOT IN subquery that checks for Orchestra_ID values that exist in the performance table rather than checking for NULL values.",
            "When referencing the orchestra table: use the exact table name \"orchestra\" instead of \"orchestras\".",
            "When the question asks for orchestra names, When identifying orchestras without performances, When referencing the orchestra table, When combining orchestra and performance tables: use Orchestra_ID as the linking key between the tables."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM orchestras WHERE performance_id IS NULL;",
            "SELECT Orchestra FROM orchestra WHERE Orchestra_ID NOT IN (SELECT DISTINCT Orchestra_ID FROM performance)"
        ],
        "rule_sql": [
            "SELECT Orchestra FROM orchestra WHERE Orchestra_ID NOT IN (SELECT Orchestra_ID FROM performance)"
        ]
    },
    "855": {
        "db_id": "orchestra",
        "question": "What are the orchestras that do not have any performances?",
        "ground_truth": "SELECT Orchestra FROM orchestra WHERE Orchestra_ID NOT IN (SELECT Orchestra_ID FROM performance)",
        "amends": [
            "Do select `Orchestra` instead of `name` and use table `orchestra` instead of `orchestras`. Do use a `NOT IN` subquery checking for `Orchestra_ID` values that exist in the `performance` table instead of checking `performance_id IS NULL`. Do remove the direct NULL check condition and instead implement the exclusion logic through the correlated subquery approach. The amended query now correctly identifies orchestras that have no associated performances by checking for Orchestra_ID values not present in the performance table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about orchestras without performances: select \"Orchestra\" from table \"orchestra\" (T1) instead of \"name\" from \"orchestras\".",
            "When checking for orchestras without performances: use a NOT IN subquery that checks for \"Orchestra_ID\" values that exist in the \"performance\" table instead of checking for NULL values.",
            "When answering about orchestras without performances, When checking for orchestras without performances, When implementing exclusion logic: use a correlated subquery approach to identify orchestras whose \"Orchestra_ID\" values are not present in the \"performance\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM orchestras WHERE performance_id IS NULL;",
            "SELECT Orchestra FROM orchestra WHERE Orchestra_ID NOT IN (SELECT Orchestra_ID FROM performance)"
        ],
        "rule_sql": [
            "SELECT Orchestra FROM orchestra WHERE Orchestra_ID NOT IN (SELECT DISTINCT Orchestra_ID FROM performance);"
        ]
    },
    "856": {
        "db_id": "orchestra",
        "question": "Show the record companies shared by orchestras founded before 2003 and after 2003.",
        "ground_truth": "SELECT Record_Company FROM orchestra WHERE Year_of_Founded  <  2003 INTERSECT SELECT Record_Company FROM orchestra WHERE Year_of_Founded  >  2003",
        "amends": [
            "Do use `INTERSECT` to find common record companies instead of using contradictory `WHERE` conditions that would return no results. Do reference `Year_of_Founded` instead of `year_founded` for the column name. Do add a second `SELECT` clause with the opposite condition instead of having both conditions in a single `WHERE` clause. Do remove the contradictory `year_founded < 2003 AND year_founded > 2003` filter instead of keeping it, as it would always return an empty set. Do use proper column naming with `Record_Company` instead of `orchestra.record_company` for consistency. The amended query now correctly identifies record companies that have orchestras founded both before and after 2003, matching the RIGHT_SQL's intersection behavior."
        ],
        "rules": [
            "When the question asks for record companies shared by orchestras from different founding periods: use INTERSECT to find common values between the two groups instead of contradictory WHERE conditions.",
            "When referencing the founding year column: use the exact column name \"Year_of_Founded\" instead of \"year_founded\".",
            "When selecting record companies: use the exact column name \"Record_Company\" without table prefix.",
            "When finding orchestras founded before 2003: select records where \"Year_of_Founded\" < 2003.",
            "When finding orchestras founded after 2003: select records where \"Year_of_Founded\" > 2003.",
            "When the question asks for record companies shared by orchestras from different founding periods, When referencing the founding year column, When selecting record companies, When finding orchestras founded before 2003, When finding orchestras founded after 2003, When combining results from both time periods: use INTERSECT to find record companies that appear in both the before-2003 and after-2003 groups."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT orchestra.record_company \nFROM orchestra \nWHERE orchestra.year_founded < 2003 \nAND orchestra.year_founded > 2003;",
            "SELECT Record_Company FROM orchestra WHERE Year_of_Founded < 2003\nINTERSECT\nSELECT Record_Company FROM orchestra WHERE Year_of_Founded > 2003"
        ],
        "rule_sql": [
            "SELECT Record_Company FROM orchestra WHERE Year_of_Founded < 2003\nINTERSECT\nSELECT Record_Company FROM orchestra WHERE Year_of_Founded > 2003"
        ]
    },
    "857": {
        "db_id": "orchestra",
        "question": "What are the record companies that are used by both orchestras founded before 2003 and those founded after 2003?",
        "ground_truth": "SELECT Record_Company FROM orchestra WHERE Year_of_Founded  <  2003 INTERSECT SELECT Record_Company FROM orchestra WHERE Year_of_Founded  >  2003",
        "amends": [
            "Do use `INTERSECT` to find common record companies instead of a self-join with distinct. Do reference `Year_of_Founded` instead of `founded_year` for the column name. Do filter with separate conditions in each branch instead of combining them in a single WHERE clause. Do use the table name `orchestra` instead of `orchestras`. Do remove the table aliases `o1` and `o2` instead of keeping them. Do select from the same table twice with different filters instead of joining on record_company. The amended query now correctly identifies record companies that have orchestras founded both before and after 2003 by finding the intersection between the two sets."
        ],
        "rules": [
            "When the question asks for record companies used by both orchestras founded before 2003 and after 2003: use INTERSECT to find common values between two sets instead of a self-join with DISTINCT.",
            "When referencing the founding year column: use the exact column name \"Year_of_Founded\" instead of \"founded_year\".",
            "When filtering orchestras by founding year: apply separate conditions in each branch of the INTERSECT operation instead of combining them in a single WHERE clause.",
            "When selecting from the orchestra table: use the exact table name \"orchestra\" instead of \"orchestras\".",
            "When the question asks for record companies used by both orchestras founded before 2003 and after 2003, When referencing the founding year column, When filtering orchestras by founding year, When selecting from the orchestra table, When constructing the query: do not use table aliases o1 and o2, instead select from the same table twice with different filters."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT r1.record_company\nFROM orchestras o1\nJOIN orchestras o2 ON o1.record_company = o2.record_company\nWHERE o1.founded_year < 2003 AND o2.founded_year > 2003;",
            "SELECT Record_Company FROM orchestra WHERE Year_of_Founded < 2003\nINTERSECT\nSELECT Record_Company FROM orchestra WHERE Year_of_Founded > 2003"
        ],
        "rule_sql": [
            "SELECT Record_Company FROM orchestra WHERE Year_of_Founded < 2003\nINTERSECT\nSELECT Record_Company FROM orchestra WHERE Year_of_Founded > 2003"
        ]
    },
    "858": {
        "db_id": "orchestra",
        "question": "Find the number of orchestras whose record format is \"CD\" or \"DVD\".",
        "ground_truth": "SELECT COUNT(*) FROM orchestra WHERE Major_Record_Format  =  \"CD\" OR Major_Record_Format  =  \"DVD\"",
        "amends": [
            "Do reference table `orchestra` instead of `orchestras`. Do use column `Major_Record_Format` instead of `record_format`. Do apply OR condition between `Major_Record_Format = \"CD\"` and `Major_Record_Format = \"DVD\"` instead of AND condition between `record_format = 'CD'` and `record_format = 'DVD'`. Do use double quotes around string literals \"CD\" and \"DVD\" instead of single quotes. The amended query now correctly counts records where the major record format is either CD or DVD, matching the intended behavior."
        ],
        "rules": [
            "When the question mentions \"orchestras\": use the exact table name \"orchestra\" instead.",
            "When the question mentions \"record format\": use the exact column name \"Major_Record_Format\" instead.",
            "When the question asks for records where format is \"CD\" or \"DVD\": use OR condition between \"Major_Record_Format = \\\"CD\\\"\" and \"Major_Record_Format = \\\"DVD\\\"\" instead of AND.",
            "When using string literals \"CD\" and \"DVD\": wrap them in double quotes exactly as shown in the schema.",
            "When the question mentions \"orchestras\", When the question mentions \"record format\", When the question asks for records where format is \"CD\" or \"DVD\", When using string literals \"CD\" and \"DVD\", When counting orchestras: count the number of rows in table \"orchestra\" where the condition is satisfied."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM orchestras WHERE record_format = 'CD' AND record_format = 'DVD';",
            "SELECT COUNT(*) FROM orchestra WHERE Major_Record_Format = \"CD\" OR Major_Record_Format = \"DVD\""
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM orchestra WHERE Major_Record_Format = \"CD\" OR Major_Record_Format = \"DVD\""
        ]
    },
    "859": {
        "db_id": "orchestra",
        "question": "Count the number of orchestras that have CD or DVD as their record format.",
        "ground_truth": "SELECT COUNT(*) FROM orchestra WHERE Major_Record_Format  =  \"CD\" OR Major_Record_Format  =  \"DVD\"",
        "amends": [
            "Do reference table `orchestra` instead of `orchestras` and use column `Major_Record_Format` instead of `record_format`. Do use double quotes `\"CD\"` and `\"DVD\"` instead of single quotes for string literals while maintaining the same OR logic for counting records in either format. The amended query now correctly counts records from the orchestra table where Major_Record_Format equals CD or DVD, matching the intended behavior."
        ],
        "rules": [
            "When the question mentions \"orchestras\": use table \"orchestra\" instead of \"orchestras\".",
            "When the question asks about \"record format\": use column \"Major_Record_Format\" instead of \"record_format\".",
            "When comparing string literals \"CD\" or \"DVD\": use double quotes \"CD\" and \"DVD\" instead of single quotes.",
            "When the question mentions \"orchestras\", When the question asks about \"record format\", When comparing string literals \"CD\" or \"DVD\", When counting orchestras with CD or DVD format: count rows where \"Major_Record_Format\" equals \"CD\" OR \"Major_Record_Format\" equals \"DVD\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM orchestras WHERE record_format = 'CD' OR record_format = 'DVD';",
            "SELECT COUNT(*) FROM orchestra WHERE \"Major_Record_Format\" = \"CD\" OR \"Major_Record_Format\" = \"DVD\""
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM orchestra WHERE Major_Record_Format = \"CD\" OR Major_Record_Format = \"DVD\""
        ]
    },
    "860": {
        "db_id": "orchestra",
        "question": "Show the years in which orchestras that have given more than one performance are founded.",
        "ground_truth": "SELECT Year_of_Founded FROM orchestra AS T1 JOIN performance AS T2 ON T1.Orchestra_ID  =  T2.Orchestra_ID GROUP BY T2.Orchestra_ID HAVING COUNT(*)  >  1",
        "amends": [
            "Do select `Year_of_Founded` instead of `year_founded`. Do join table `orchestra AS T1` with `performance AS T2` instead of querying only `orchestras`. Do use join condition `T1.Orchestra_ID = T2.Orchestra_ID` instead of missing the join entirely. Do group by `T2.Orchestra_ID` instead of `orchestra_id`. Do use `HAVING COUNT(*) > 1` instead of `WHERE COUNT(performance_id) > 1` to properly filter aggregated results. The amended query now correctly retrieves founding years for orchestras with multiple performances by joining the necessary tables and applying the count filter at the appropriate aggregation level."
        ],
        "rules": [
            "When the question asks about \"years\" for orchestras: use the exact column name \"Year_of_Founded\" from the orchestra table.",
            "When counting performances per orchestra: join table \"orchestra\" (as T1) with table \"performance\" (as T2) using the exact condition T1.Orchestra_ID = T2.Orchestra_ID.",
            "When grouping by orchestra: use T2.Orchestra_ID as the grouping key.",
            "When filtering for orchestras with more than one performance: apply the condition COUNT(*) > 1 after grouping (not before).",
            "When the question asks about \"years\" for orchestras, When counting performances per orchestra, When grouping by orchestra, When filtering for orchestras with more than one performance, When answering about orchestras that have given more than one performance: ensure the output includes only Year_of_Founded values for orchestras meeting the performance count condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year_founded FROM orchestras WHERE COUNT(performance_id) > 1 GROUP BY orchestra_id",
            "SELECT T1.Year_of_Founded \nFROM orchestra AS T1\nJOIN performance AS T2 ON T1.Orchestra_ID = T2.Orchestra_ID\nGROUP BY T2.Orchestra_ID\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT DISTINCT o.Year_of_Founded \nFROM orchestra o\nJOIN performance p ON o.Orchestra_ID = p.Orchestra_ID\nGROUP BY o.Orchestra_ID\nHAVING COUNT(*) > 1\nORDER BY o.Year_of_Founded;"
        ]
    },
    "861": {
        "db_id": "orchestra",
        "question": "What are years of founding for orchestras that have had more than a single performance?",
        "ground_truth": "SELECT Year_of_Founded FROM orchestra AS T1 JOIN performance AS T2 ON T1.Orchestra_ID  =  T2.Orchestra_ID GROUP BY T2.Orchestra_ID HAVING COUNT(*)  >  1",
        "amends": [
            "Do select `Year_of_Founded` instead of `year_of_founding` and do add table alias `T1` instead of omitting it. Do change FROM clause to join `orchestra AS T1` with `performance AS T2` instead of single table `orchestras` and do add `ON T1.Orchestra_ID = T2.Orchestra_ID` join condition instead of no join. Do add `GROUP BY T2.Orchestra_ID` instead of omitting grouping and do move filter to `HAVING COUNT(*) > 1` instead of `WHERE performance_count > 1`. The amended query now correctly identifies orchestras with multiple performances by joining the performance table and counting records per orchestra."
        ],
        "rules": [
            "When answering about \"years of founding for orchestras that have had more than a single performance\": make sure the output order: T1.Year_of_Founded.",
            "When the question mentions \"orchestras that have had more than a single performance\": join table \"orchestra AS T1\" with table \"performance AS T2\" using the condition T1.Orchestra_ID = T2.Orchestra_ID and keep only matching pairs (inner match).",
            "When counting performances per orchestra: group by T2.Orchestra_ID and count the number of rows using the canonical key.",
            "When filtering for orchestras with more than one performance: apply the condition COUNT(*) > 1 after grouping.",
            "When answering about \"years of founding for orchestras that have had more than a single performance\", When the question mentions \"orchestras that have had more than a single performance\", When counting performances per orchestra, When filtering for orchestras with more than one performance, When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for column names like Year_of_Founded."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year_of_founding FROM orchestras WHERE performance_count > 1",
            "SELECT T1.Year_of_Founded \nFROM orchestra AS T1 \nJOIN performance AS T2 ON T1.Orchestra_ID = T2.Orchestra_ID \nGROUP BY T2.Orchestra_ID \nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T1.\"Year_of_Founded\"\nFROM orchestra AS T1\nINNER JOIN performance AS T2 ON T1.\"Orchestra_ID\" = T2.\"Orchestra_ID\"\nGROUP BY T2.\"Orchestra_ID\"\nHAVING COUNT(*) > 1\nORDER BY T1.\"Year_of_Founded\""
        ]
    },
    "862": {
        "db_id": "network_1",
        "question": "How many high schoolers are there?",
        "ground_truth": "SELECT count(*) FROM Highschooler",
        "amends": [
            "Do reference the `Highschooler` table instead of the `students` table, and do use the correct table name `Highschooler` instead of filtering by `grade_level = 'high school'` which suggests the wrong table structure. The amended query now correctly counts all records from the Highschooler table, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"how many high schoolers\": use the \"Highschooler\" table to count all records.",
            "When counting entities from the Highschooler table: count using all records from that table without filtering by grade level.",
            "When answering about \"how many high schoolers\", When counting entities from the Highschooler table, When the question asks for count of high schoolers: the correct table structure uses a dedicated \"Highschooler\" table rather than filtering a general \"students\" table by grade level."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE grade_level = 'high school';",
            "SELECT COUNT(*) FROM Highschooler;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Highschooler;"
        ]
    },
    "863": {
        "db_id": "network_1",
        "question": "Count the number of high schoolers.",
        "ground_truth": "SELECT count(*) FROM Highschooler",
        "amends": [
            "Do reference the table as `Highschooler` instead of `students` and use the correct table name `count(*)` instead of `COUNT(*)` while maintaining the same aggregation logic. The amended query now correctly references the Highschooler table and uses consistent function casing to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When counting entities from the database: use the exact table name \"Highschooler\" instead of any other table reference like \"students\".",
            "When performing count aggregation: use the exact function name \"count(*)\" with lowercase 'c' to match the required function casing.",
            "When counting entities from the database, When performing count aggregation, When filtering by grade level: use the exact column name \"grade_level\" and the exact literal value 'high school' with the specified case and spacing."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE grade_level = 'high school';",
            "SELECT count(*) FROM Highschooler"
        ],
        "rule_sql": [
            "SELECT count(*) FROM Highschooler;"
        ]
    },
    "864": {
        "db_id": "network_1",
        "question": "Show the names and grades of each high schooler.",
        "ground_truth": "SELECT name ,  grade FROM Highschooler",
        "amends": [
            "Do reference the table as `Highschooler` instead of `high_schoolers` to match the correct table name. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for high schooler information: use the exact table name \"Highschooler\" instead of \"high_schoolers\".",
            "When selecting columns for high schoolers: include both \"name\" and \"grade\" columns in the output.",
            "When the question asks for high schooler information, When selecting columns for high schoolers, When filtering high schoolers by grade: do not apply any grade restrictions since the question asks for all high schoolers regardless of grade level."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, grade FROM high_schoolers WHERE grade > 12",
            "SELECT name, grade FROM Highschooler;"
        ],
        "rule_sql": [
            "SELECT name, grade FROM Highschooler;"
        ]
    },
    "865": {
        "db_id": "network_1",
        "question": "What are the names and grades for each high schooler?",
        "ground_truth": "SELECT name ,  grade FROM Highschooler",
        "amends": [
            "Do reference the table as `Highschooler` instead of `high_schoolers` to match the correct table name. The amended query now correctly selects from the Highschooler table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks about high schoolers: use the exact table name \"Highschooler\" instead of \"high_schoolers\".",
            "When the question asks about high schoolers, When selecting from the Highschooler table: include all rows without filtering by grade, as the question asks for each high schooler without grade restrictions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, grade FROM high_schoolers WHERE grade > 12;",
            "SELECT name, grade FROM Highschooler;"
        ],
        "rule_sql": [
            "SELECT name, grade FROM Highschooler;"
        ]
    },
    "866": {
        "db_id": "network_1",
        "question": "Show all the grades of the high schoolers.",
        "ground_truth": "SELECT grade FROM Highschooler",
        "amends": [
            "Do specify `grade` in the SELECT list instead of using `*` to select all columns. Do use the correct table name `Highschooler` instead of `high_schoolers`. The amended query now correctly returns only the grade column from the Highschooler table, matching the intended behavior."
        ],
        "rules": [
            "When the question asks to show grades of high schoolers: select only the \"grade\" column from the \"Highschooler\" table.",
            "When referring to the table containing high schooler information: use the exact table name \"Highschooler\" (not \"high_schoolers\").",
            "When the question asks to show grades of high schoolers, When referring to the table containing high schooler information, When selecting specific columns instead of all columns: explicitly list the required column \"grade\" rather than using the wildcard *."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM high_schoolers;",
            "SELECT grade FROM Highschooler;"
        ],
        "rule_sql": [
            "SELECT grade FROM Highschooler"
        ]
    },
    "867": {
        "db_id": "network_1",
        "question": "What is the grade of each high schooler?",
        "ground_truth": "SELECT grade FROM Highschooler",
        "amends": [
            "Do select only `grade` instead of both `name` and `grade`. Do reference the table as `Highschooler` instead of `high_schoolers`. Do remove the `WHERE grade > 12` filter instead of keeping it. The amended query now correctly selects only the grade column from the Highschooler table without any filtering conditions."
        ],
        "rules": [
            "When answering about \"grade of each high schooler\": make sure the output order: grade.",
            "When the question mentions \"high schooler\": \"high schooler\" actually means \"Highschooler\" in schema.",
            "When answering about \"grade of each high schooler\", When the question mentions \"high schooler\", When selecting from the Highschooler table: do not apply any filtering conditions unless explicitly specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, grade FROM high_schoolers WHERE grade > 12;",
            "SELECT grade FROM Highschooler;"
        ],
        "rule_sql": [
            "SELECT grade FROM Highschooler ORDER BY grade;"
        ]
    },
    "868": {
        "db_id": "network_1",
        "question": "What grade is Kyle in?",
        "ground_truth": "SELECT grade FROM Highschooler WHERE name  =  \"Kyle\"",
        "amends": [
            "Do reference the `Highschooler` table instead of the `students` table in the FROM clause. Do use double quotes `\"Kyle\"` instead of single quotes `'Kyle'` for the string literal in the WHERE filter. The amended query now correctly retrieves grades from the Highschooler table for students named Kyle."
        ],
        "rules": [
            "When answering about student grades: use the \"Highschooler\" table instead of any other table.",
            "When filtering for a student named Kyle: use the exact string literal \"Kyle\" with double quotes in the filter condition.",
            "When answering about student grades, When filtering for a student named Kyle, When selecting grade information: retrieve the grade column from the Highschooler table for matching students."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT grade FROM students WHERE name = 'Kyle';",
            "SELECT grade FROM Highschooler WHERE name = \"Kyle\";"
        ],
        "rule_sql": [
            "SELECT grade FROM Highschooler WHERE name = \"Kyle\";"
        ]
    },
    "869": {
        "db_id": "network_1",
        "question": "Return the grade for the high schooler named Kyle.",
        "ground_truth": "SELECT grade FROM Highschooler WHERE name  =  \"Kyle\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT grade FROM Highschooler WHERE name = 'Kyle';"
        ],
        "rule_sql": [
            "SELECT grade FROM Highschooler WHERE name = 'Kyle';"
        ]
    },
    "870": {
        "db_id": "network_1",
        "question": "Show the names of all high schoolers in grade 10.",
        "ground_truth": "SELECT name FROM Highschooler WHERE grade  =  10",
        "amends": [
            "Do reference table `Highschooler` instead of `high_schoolers` and filter on `grade = 10` instead of `grade = 9`."
        ],
        "rules": [
            "When answering about \"high schoolers\": use the exact table name \"Highschooler\" as shown in the schema.",
            "When filtering by grade 10: use the exact literal value 10 (not",
            "for the grade column.",
            "When answering about \"high schoolers\", When filtering by grade 10, for the grade column., When selecting names: output the \"name\" column from the Highschooler table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM high_schoolers WHERE grade = 9;",
            "SELECT name FROM Highschooler WHERE grade = 10;"
        ],
        "rule_sql": [
            "SELECT name FROM Highschooler WHERE grade = 10;"
        ]
    },
    "871": {
        "db_id": "network_1",
        "question": "What are the names of all high schoolers in grade 10?",
        "ground_truth": "SELECT name FROM Highschooler WHERE grade  =  10",
        "amends": [
            "Do reference the `Highschooler` table instead of the `students` table. Do remove the `school_type = 'college'` filter instead of keeping it, as high school students should not be filtered by college type. The amended query now correctly selects names from the Highschooler table for 10th grade students without the inappropriate college filter."
        ],
        "rules": [
            "When answering about high schoolers in grade 10: use the \"Highschooler\" table instead of the \"students\" table.",
            "When filtering for grade 10: use the condition grade = 10.",
            "When answering about high schoolers in grade 10, When filtering for grade 10, When the question asks for high schoolers: do not apply any school_type filter, especially not school_type = 'college'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM students WHERE grade = 10 AND school_type = 'college';",
            "SELECT name FROM Highschooler WHERE grade = 10;"
        ],
        "rule_sql": [
            "SELECT name FROM Highschooler WHERE grade = 10;"
        ]
    },
    "872": {
        "db_id": "network_1",
        "question": "Show the ID of the high schooler named Kyle.",
        "ground_truth": "SELECT ID FROM Highschooler WHERE name  =  \"Kyle\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM Highschooler WHERE name = 'Kyle';"
        ],
        "rule_sql": [
            "SELECT ID FROM Highschooler WHERE name = 'Kyle';"
        ]
    },
    "873": {
        "db_id": "network_1",
        "question": "What is Kyle's id?",
        "ground_truth": "SELECT ID FROM Highschooler WHERE name  =  \"Kyle\"",
        "amends": [
            "Do reference table `Highschooler` instead of `users` in the FROM clause. Do use column `ID` instead of `id` in the SELECT list. Do use double quotes `\"Kyle\"` instead of single quotes `'Kyle'` for the string literal in the WHERE filter. The amended query now correctly retrieves the ID from the Highschooler table where the name matches Kyle."
        ],
        "rules": [
            "When answering about \"Kyle's id\": make sure the output order: \"ID\" from table \"Highschooler\".",
            "When the question mentions \"id\": \"id\" actually means \"ID\" in schema.",
            "When the question mentions \"Kyle\": use the exact string literal \"Kyle\" with double quotes.",
            "When answering about \"Kyle's id\", When the question mentions \"id\", When the question mentions \"Kyle\", When filtering for a specific name: match rows where the name equals \"Kyle\" exactly."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM users WHERE name = 'Kyle';",
            "SELECT ID FROM Highschooler WHERE name = \"Kyle\""
        ],
        "rule_sql": [
            "SELECT ID FROM Highschooler WHERE name = \"Kyle\";"
        ]
    },
    "874": {
        "db_id": "network_1",
        "question": "How many high schoolers are there in grade 9 or 10?",
        "ground_truth": "SELECT count(*) FROM Highschooler WHERE grade  =  9 OR grade  =  10",
        "amends": [
            "Do reference the table as `Highschooler` instead of `high_schoolers` to match the correct table name. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks about high schoolers: use the exact table name \"Highschooler\" instead of \"high_schoolers\".",
            "When the question asks about high schoolers, When counting high schoolers in grades 9 or 10: count rows where the grade column equals 9 or equals 10."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM high_schoolers WHERE grade = 9 OR grade = 10;",
            "SELECT COUNT(*) FROM Highschooler WHERE grade = 9 OR grade = 10;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Highschooler WHERE grade = 9 OR grade = 10;"
        ]
    },
    "875": {
        "db_id": "network_1",
        "question": "Count the number of high schoolers in grades 9 or 10.",
        "ground_truth": "SELECT count(*) FROM Highschooler WHERE grade  =  9 OR grade  =  10",
        "amends": [
            "Do use the correct table name `Highschooler` instead of the incorrect `high_schoolers`. The amended query now matches RIGHT_SQL's behavior with the proper table reference."
        ],
        "rules": [
            "When the question asks about \"high schoolers\": use the exact table name \"Highschooler\" with the correct case and spelling.",
            "When counting entities from the Highschooler table: count using the canonical key for high schoolers (typically a primary key column, though not explicitly specified in this schema).",
            "When the question asks about \"high schoolers\", When counting entities from the Highschooler table, When filtering for grades 9 or 10: use the exact numeric values 9 and 10 without quotes since grade appears to be a numeric field."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM high_schoolers WHERE grade = 9 OR grade = 10;",
            "SELECT COUNT(*) FROM Highschooler WHERE grade IN (9, 10);"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Highschooler WHERE grade = 9 OR grade = 10;"
        ]
    },
    "876": {
        "db_id": "network_1",
        "question": "Show the number of high schoolers for each grade.",
        "ground_truth": "SELECT grade ,  count(*) FROM Highschooler GROUP BY grade",
        "amends": [
            "Do reference the table as `Highschooler` instead of `high_schoolers` to match the correct table name. Do add a space after `grade` in the SELECT clause instead of omitting it for proper formatting. Do remove the `ORDER BY grade` clause instead of keeping it since the grouping already provides the desired ordering. The amended query now correctly counts students by grade from the Highschooler table without unnecessary ordering."
        ],
        "rules": [
            "When answering about \"number of high schoolers for each grade\": make sure the output order: grade, count of students.",
            "When the question mentions \"high schoolers\": \"high schoolers\" actually means \"Highschooler\" in schema.",
            "When the question asks for \"count of high schoolers per grade\": compute the number of rows using the canonical key for students from the Highschooler table, grouped by grade.",
            "When grouping by grade: organize results by the exact token \"grade\" from the Highschooler table.",
            "When answering about \"number of high schoolers for each grade\", When the question mentions \"high schoolers\", When the question asks for \"count of high schoolers per grade\", When grouping by grade, When producing output: do not include unnecessary ordering clauses since grouping by grade already provides the desired ordering."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT grade, COUNT(*) FROM high_schoolers GROUP BY grade ORDER BY grade;",
            "SELECT grade, COUNT(*) FROM Highschooler GROUP BY grade;"
        ],
        "rule_sql": [
            "SELECT grade, COUNT(ID) FROM Highschooler GROUP BY grade;"
        ]
    },
    "877": {
        "db_id": "network_1",
        "question": "How many high schoolers are in each grade?",
        "ground_truth": "SELECT grade ,  count(*) FROM Highschooler GROUP BY grade",
        "amends": [
            "Do reference the `Highschooler` table instead of the `students` table. Do remove the `WHERE school_level = 'high school'` filter instead of keeping it, as the table name already implies the context. Do remove the `ORDER BY grade` clause instead of including it, as the grouping inherently organizes results. Do maintain the same `SELECT grade, COUNT(*)` and `GROUP BY grade` structure. The amended query now correctly focuses on the Highschooler table without redundant filtering and ordering."
        ],
        "rules": [
            "When answering about \"high schoolers in each grade\": use the \"Highschooler\" table instead of any other student table.",
            "When the table name already implies the context (like \"Highschooler\"): do not add redundant filtering conditions like WHERE school_level = 'high school'.",
            "When grouping results by grade: do not add ORDER BY grade as the grouping inherently organizes results.",
            "When answering about \"high schoolers in each grade\", When the table name already implies the context (like \"Highschooler\"), When grouping results by grade, When counting high schoolers per grade: maintain the structure SELECT grade, COUNT(*) FROM Highschooler GROUP BY grade."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT grade, COUNT(*) FROM students WHERE school_level = 'high school' GROUP BY grade ORDER BY grade;",
            "SELECT grade, COUNT(*) FROM Highschooler GROUP BY grade"
        ],
        "rule_sql": [
            "SELECT grade, COUNT(*) FROM Highschooler GROUP BY grade"
        ]
    },
    "878": {
        "db_id": "network_1",
        "question": "Which grade has the most high schoolers?",
        "ground_truth": "SELECT grade FROM Highschooler GROUP BY grade ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference the table as `Highschooler` instead of `students` and remove the explicit column alias `student_count` instead of keeping it. Do remove the `WHERE` filter `school_level = 'high school'` instead of including it since the table name already implies the context. Do use the aggregate function `count(*)` directly in the `ORDER BY` clause instead of referencing the alias `student_count`. The amended query now correctly identifies the most common grade among high school students by counting records per grade and ordering by the count in descending order.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, as the query only needs to return the grade with the highest count rather than both the grade and its count. Do keep the `GROUP BY grade` and `ORDER BY count(*) DESC LIMIT 1` unchanged since they correctly identify the grade with the maximum frequency. The amended query now matches RIGHT_SQL's behavior by returning only the grade value with the highest occurrence count."
        ],
        "rules": [
            "When answering about \"which grade has the most high schoolers\": use the table \"Highschooler\" instead of \"students\" since the table name implies the context.",
            "When counting high school students per grade: use count(*) directly without an explicit column alias in the output.",
            "When ordering results by count: use count(*) directly in the order by clause instead of referencing an alias.",
            "When answering about \"which grade has the most high schoolers\", When counting high school students per grade, When ordering results by count, When the question asks for \"the most\": rank rows by count(*) in descending order and keep only the first row.",
            "When answering about \"which grade has the most high schoolers\": make sure the output order: grade only without the count value.",
            "When the question asks for the grade with the highest count: rank rows by count of high schoolers in descending order and keep the first 1 row.",
            "When the question says \"per grade\"/\"by grade\": organize results by grade and compute the count of high schoolers per group.",
            "When answering about \"which grade has the most high schoolers\", When the question asks for the grade with the highest count, When the question says \"per grade\"/\"by grade\", When counting high schoolers: use the canonical counting method for entities in the database (typically counting rows or a primary key)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT grade, COUNT(*) as student_count FROM students WHERE school_level = 'high school' GROUP BY grade ORDER BY student_count DESC LIMIT 1;",
            "SELECT grade, COUNT(*) FROM Highschooler GROUP BY grade ORDER BY COUNT(*) DESC LIMIT 1",
            "SELECT grade FROM Highschooler GROUP BY grade ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT grade FROM Highschooler GROUP BY grade ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "879": {
        "db_id": "network_1",
        "question": "Return the grade that has the greatest number of high schoolers.",
        "ground_truth": "SELECT grade FROM Highschooler GROUP BY grade ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use `GROUP BY grade` instead of omitting it, as aggregation requires grouping by non-aggregated columns. Do move the `COUNT(*)` aggregate to the `ORDER BY` clause instead of placing it in the `SELECT` list without grouping. Do maintain the `DESC` ordering and `LIMIT 1` to find the grade with the highest count of students. The amended query now correctly groups by grade before counting and ordering, matching the intended behavior of finding the most common grade level."
        ],
        "rules": [
            "When answering about \"the grade that has the greatest number of high schoolers\": organize results by the token for grade and compute the count of students per group.",
            "When counting students: compute the number of rows using the canonical counting method (COUNT(*)).",
            "When the question mentions \"greatest number\" or \"highest count\": rank rows by the count in descending order and keep only the first row (top result).",
            "When answering about \"the grade that has the greatest number of high schoolers\", When counting students, When the question mentions \"greatest number\" or \"highest count\", When producing output: make sure the output order includes only the grade column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT grade FROM high_schoolers ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT grade FROM Highschooler GROUP BY grade ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT grade FROM Highschooler GROUP BY grade ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "880": {
        "db_id": "network_1",
        "question": "Show me all grades that have at least 4 students.",
        "ground_truth": "SELECT grade FROM Highschooler GROUP BY grade HAVING count(*)  >=  4",
        "amends": [
            "Do reference the `Highschooler` table instead of `students` in the FROM clause. Do use `HAVING count(*) >= 4` instead of `WHERE student_count >= 4` to filter aggregated results. Do remove the `COUNT(*) as student_count` column from the SELECT list instead of including it, since only the `grade` grouping column is needed. Do remove the alias `student_count` instead of keeping it as the filter condition now directly uses the aggregate function. The amended query now correctly filters groups based on aggregate conditions using HAVING instead of WHERE and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"grades that have at least 4 students\": use the \"Highschooler\" table instead of \"students\" table.",
            "When filtering groups based on aggregate conditions: use HAVING count(*) >= 4 instead of WHERE student_count >= 4.",
            "When the question asks for \"all grades\" with a condition: only include the \"grade\" column in the output, not the count column.",
            "When answering about \"grades that have at least 4 students\", When filtering groups based on aggregate conditions, When the question asks for \"all grades\" with a condition, When grouping by \"grade\": organize results by the \"grade\" column and compute the count of students per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT grade, COUNT(*) as student_count FROM students GROUP BY grade WHERE student_count >= 4;",
            "SELECT grade FROM Highschooler GROUP BY grade HAVING COUNT(*) >= 4"
        ],
        "rule_sql": [
            "SELECT grade FROM Highschooler GROUP BY grade HAVING COUNT(*) >= 4"
        ]
    },
    "881": {
        "db_id": "network_1",
        "question": "Which grades have 4 or more high schoolers?",
        "ground_truth": "SELECT grade FROM Highschooler GROUP BY grade HAVING count(*)  >=  4",
        "amends": [
            "Do select only `grade` instead of selecting both `grade` and `COUNT(*) as student_count`. Do use `FROM Highschooler` instead of `FROM students` as the table source. Do remove the `WHERE grade >= 9` filter instead of keeping it. Do keep the `GROUP BY grade` clause. Do keep the `HAVING count(*) >= 4` condition but use the exact syntax `count(*)  >=  4` instead of `COUNT(*) >= 4`. The amended query now correctly identifies grades with at least 4 students in the Highschooler table without unnecessary columns or filters."
        ],
        "rules": [
            "When answering about \"which grades have 4 or more high schoolers\": make sure the output order: grade.",
            "When the question mentions \"high schoolers\": \"high schoolers\" actually means \"records in the Highschooler table\".",
            "When counting students: use count(*) to count all rows in the Highschooler table.",
            "When grouping by grade: organize results by the grade column from the Highschooler table.",
            "When filtering for grades with 4 or more students: keep only groups where count(*) >= 4.",
            "When answering about \"which grades have 4 or more high schoolers\", When the question mentions \"high schoolers\", When counting students, When grouping by grade, When filtering for grades with 4 or more students, When handling the grade column: use the exact column name grade without any WHERE filtering conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT grade, COUNT(*) as student_count \nFROM students \nWHERE grade >= 9 \nGROUP BY grade \nHAVING COUNT(*) >= 4;",
            "SELECT grade FROM Highschooler GROUP BY grade HAVING count(*) >= 4"
        ],
        "rule_sql": [
            "SELECT grade FROM Highschooler GROUP BY grade HAVING COUNT(*) >= 4 ORDER BY grade;"
        ]
    },
    "882": {
        "db_id": "network_1",
        "question": "Show the student IDs and numbers of friends corresponding to each.",
        "ground_truth": "SELECT student_id ,  count(*) FROM Friend GROUP BY student_id",
        "amends": [
            "Do use table name `Friend` instead of `friends` to reference the correct table. The amended query now matches RIGHT_SQL's behavior with the proper table reference."
        ],
        "rules": [
            "When referencing the table containing friend relationships: use the exact table name \"Friend\" instead of \"friends\" to match the schema definition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id, COUNT(*) FROM friends GROUP BY student_id;",
            "SELECT student_id, COUNT(friend_id) AS number_of_friends FROM Friend GROUP BY student_id;"
        ],
        "rule_sql": [
            "SELECT student_id, COUNT(friend_id) AS number_of_friends FROM Friend GROUP BY student_id;"
        ]
    },
    "883": {
        "db_id": "network_1",
        "question": "How many friends does each student have?",
        "ground_truth": "SELECT student_id ,  count(*) FROM Friend GROUP BY student_id",
        "amends": [
            "Do use table name `Friend` instead of `friends` to reference the correct table. The amended query now matches RIGHT_SQL's behavior with the proper table reference."
        ],
        "rules": [
            "When the question asks about \"friends\": use the exact table name \"Friend\" instead of \"friends\" to reference the correct table.",
            "When the question asks about \"friends\", When counting friends per student: compute the number of rows using the canonical key \"student_id\" and group by \"student_id\" to get counts for each student."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id, COUNT(*) FROM friends GROUP BY student_id;",
            "SELECT student_id, COUNT(friend_id) AS friend_count FROM Friend GROUP BY student_id"
        ],
        "rule_sql": [
            "SELECT student_id, COUNT(friend_id) AS friend_count FROM Friend GROUP BY student_id;"
        ]
    },
    "884": {
        "db_id": "network_1",
        "question": "Show the names of high school students and their corresponding number of friends.",
        "ground_truth": "SELECT T2.name ,  count(*) FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id",
        "amends": [
            "Do select `T2.name` instead of `name` and maintain `count(*)` without change. Do use `FROM Friend AS T1 JOIN Highschooler AS T2` instead of `FROM students` with a single table. Do apply join condition `ON T1.student_id = T2.id` instead of a simple `WHERE grade = 'High School'` filter. Do group by `T1.student_id` instead of `name` to ensure proper aggregation. The amended query now correctly joins the Friend and Highschooler tables to count friends per student while matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for \"high school students\": use the \"Highschooler\" table (aliased as T2) to get student information.",
            "When combining Friend and Highschooler tables: link rows where T1.student_id = T2.id and keep only matching pairs (inner match).",
            "When counting \"number of friends\": count all rows per student using T1.student_id as the grouping key.",
            "When selecting output columns: include T2.name and the count of friends, maintaining this exact output order.",
            "When the question asks for \"high school students\", When combining Friend and Highschooler tables, When counting \"number of friends\", When selecting output columns, When grouping for aggregation: group by T1.student_id to ensure proper counting of friends per student."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, COUNT(*) FROM students WHERE grade = 'High School' GROUP BY name;",
            "SELECT T2.name, COUNT(*) \nFROM Friend AS T1 \nJOIN Highschooler AS T2 ON T1.student_id = T2.ID \nGROUP BY T1.student_id"
        ],
        "rule_sql": [
            "SELECT T2.name, COUNT(*) AS number_of_friends\nFROM Friend T1\nINNER JOIN Highschooler T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nORDER BY T1.student_id;"
        ]
    },
    "885": {
        "db_id": "network_1",
        "question": "What are the names of the high schoolers and how many friends does each have?",
        "ground_truth": "SELECT T2.name ,  count(*) FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id",
        "amends": [
            "Do specify `T2.name` from the `Highschooler` table instead of just `name` without table qualification. Do join `Friend AS T1` and `Highschooler AS T2` with an `INNER JOIN` on `T1.student_id = T2.id` instead of querying only the `high_schoolers` table. Do group by `T1.student_id` instead of grouping by `name` to ensure proper count aggregation per student. The amended query now correctly counts friends for each student by joining the Friend and Highschooler tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"names of high schoolers and how many friends each has\": make sure the output order: T2.name, COUNT(*)",
            "When the question mentions \"high schoolers\": \"high schoolers\" actually means \"T2.name in schema\" from the Highschooler table",
            "When combining Friend as T1 and Highschooler as T2 for shared entities: link rows where T1.student_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match)",
            "When the question asks for \"how many friends does each have\": compute the number of rows using T1.student_id as the grouping key to ensure proper count aggregation per student",
            "When answering about \"names of high schoolers and how many friends each has\", When the question mentions \"high schoolers\", When combining Friend as T1 and Highschooler as T2 for shared entities, When the question asks for \"how many friends does each have\", When producing output: do not reorder columns beyond T2.name followed by the count of friends"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, COUNT(*) FROM high_schoolers GROUP BY name;",
            "SELECT T2.name, COUNT(T1.friend_id) AS friend_count\nFROM Friend AS T1\nINNER JOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id"
        ],
        "rule_sql": [
            "SELECT T2.name, COUNT(*) \nFROM Friend AS T1 \nINNER JOIN Highschooler AS T2 ON T1.student_id = T2.ID \nGROUP BY T1.student_id \nORDER BY T2.name, COUNT(*)"
        ]
    },
    "886": {
        "db_id": "network_1",
        "question": "What is the name of the high schooler who has the greatest number of friends?",
        "ground_truth": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.name` from the joined table instead of `name` from a single table. Do join `Friend AS T1` with `Highschooler AS T2` on `T1.student_id = T2.id` instead of querying only the `highschooler` table. Do add `GROUP BY T1.student_id` to aggregate friend counts per student instead of attempting to aggregate without grouping. Do use `count(*)` to count friends instead of `COUNT(friend_id)` which would not work without proper grouping. The amended query now correctly identifies the student with the most friends by joining the Friend table with Highschooler, grouping by student, and counting friendships, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"the high schooler who has the greatest number of friends\": make sure the output order: T2.name.",
            "When the question mentions \"high schooler\": \"high schooler\" actually means \"T2.name in schema\".",
            "When combining T1 and T2 for shared entities: link rows where T1.student_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match).",
            "When the question asks for \"count of friends\": compute the number of rows using the canonical key token for friends (e.g., T1.student_id).",
            "When the question says \"per student\"/\"by student\": organize results by T1.student_id and compute requested aggregates per group.",
            "When answering about \"the high schooler who has the greatest number of friends\", When the question mentions \"high schooler\", When combining T1 and T2 for shared entities, When the question asks for \"count of friends\", When the question says \"per student\"/\"by student\", When the question mentions \"greatest number\" or \"top\": rank rows by count of friends in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM highschooler ORDER BY COUNT(friend_id) DESC LIMIT 1;",
            "SELECT T2.name\nFROM Friend AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.name\nFROM Friend T1\nJOIN Highschooler T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "887": {
        "db_id": "network_1",
        "question": "Return the name of the high school student with the most friends.",
        "ground_truth": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.name` from the `Highschooler` table instead of `name` from the `students` table. Do add `FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id` instead of omitting join relationships. Do add `GROUP BY T1.student_id` to aggregate by student instead of omitting grouping. Do change ordering to `ORDER BY count(*) DESC` based on friend count instead of `ORDER BY RANDOM()`. Do keep `LIMIT 1` to return one row but now based on highest friend count instead of random selection. The amended query now correctly identifies the student with the most friends by joining Friend and Highschooler tables, grouping by student, and ordering by friendship count descending."
        ],
        "rules": [
            "When answering about \"high school student with the most friends\": make sure the output order: T2.name.",
            "When the question mentions \"high school student\": \"high school student\" actually means \"T2.name in Highschooler table\".",
            "When combining T1 and T2 for shared entities: link rows where T1.student_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match).",
            "When the question asks for \"count of friends\": compute the number of rows using the canonical key token T1.student_id.",
            "When answering about \"high school student with the most friends\", When the question mentions \"high school student\", When combining T1 and T2 for shared entities, When the question asks for \"count of friends\", When the question mentions \"most friends\" or \"highest\": rank rows by count(*) in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM students ORDER BY RANDOM() LIMIT 1;",
            "SELECT T2.name\nFROM Friend AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.name\nFROM Friend T1\nJOIN Highschooler T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "888": {
        "db_id": "network_1",
        "question": "Show the names of high schoolers who have at least 3 friends.",
        "ground_truth": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id HAVING count(*)  >=  3",
        "amends": [
            "Do use `T1.student_id = T2.id` as the join condition instead of the incorrect `id IN (SELECT id1 FROM Friend)` subquery approach. Do reference the table as `Friend AS T1` and `Highschooler AS T2` instead of only using Highschooler in the main query. Do select `T2.name` from the joined Highschooler table instead of selecting `name` directly from Highschooler without proper joining. Do group by `T1.student_id` instead of grouping by `id1` in the subquery. The amended query now correctly joins the tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When joining tables Friend and Highschooler: use T1.student_id = T2.id as the join condition to match rows between tables.",
            "When counting friends per student: group by T1.student_id and count the number of friend relationships where count is at least 3.",
            "When selecting student names: retrieve T2.name from the Highschooler table after joining with Friend table.",
            "When joining tables Friend and Highschooler, When counting friends per student, When selecting student names, When organizing results: ensure only students with at least 3 friends are included in the final output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM Highschooler WHERE id IN (SELECT id1 FROM Friend GROUP BY id1 HAVING COUNT(*) >= 3);",
            "SELECT T2.name\nFROM Friend AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nHAVING COUNT(T1.friend_id) >= 3;"
        ],
        "rule_sql": [
            "SELECT T2.name \nFROM Friend T1 \nJOIN Highschooler T2 ON T1.student_id = T2.ID \nGROUP BY T1.student_id \nHAVING COUNT(T1.friend_id) >= 3"
        ]
    },
    "889": {
        "db_id": "network_1",
        "question": "What are the names of high schoolers who have 3 or more friends?",
        "ground_truth": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id HAVING count(*)  >=  3",
        "amends": [
            "Do use `JOIN` between `Friend` and `Highschooler` tables on `T1.student_id = T2.id` instead of querying only the `high_schoolers` table. Do add `GROUP BY T1.student_id` to aggregate friend counts per student instead of assuming a direct `friend_count` column exists. Do move the count filter to `HAVING count(*) >= 3` instead of using `WHERE friend_count >= 3` since the count is derived from aggregation. Do select `T2.name` from the joined Highschooler table instead of selecting `name` directly from the original table. The amended query now correctly identifies students with at least three friends by counting actual friendship records rather than relying on a potentially non-existent column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks about high schoolers with friends: combine the Highschooler table (as T2) and Friend table (as T1) by linking rows where T1.student_id equals T2.id, keeping only matching pairs.",
            "When counting friends per student: group the results by T1.student_id and count the number of friend records for each student.",
            "When filtering for students with 3 or more friends: only keep groups where the count of friend records is greater than or equal to 3.",
            "When the question asks about high schoolers with friends, When counting friends per student, When filtering for students with 3 or more friends, When selecting student names: output T2.name from the joined Highschooler table rather than from the original table directly."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM high_schoolers WHERE friend_count >= 3;",
            "SELECT T2.name \nFROM Friend T1 \nJOIN Highschooler T2 ON T1.student_id = T2.ID \nGROUP BY T1.student_id \nHAVING COUNT(*) >= 3"
        ],
        "rule_sql": [
            "SELECT T2.name \nFROM Friend AS T1 \nJOIN Highschooler AS T2 ON T1.student_id = T2.ID \nGROUP BY T1.student_id \nHAVING COUNT(*) >= 3"
        ]
    },
    "890": {
        "db_id": "network_1",
        "question": "Show the names of all of the high schooler Kyle's friends.",
        "ground_truth": "SELECT T3.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id JOIN Highschooler AS T3 ON T1.friend_id  =  T3.id WHERE T2.name  =  \"Kyle\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM Highschooler WHERE ID IN (SELECT friend_id FROM Friend WHERE student_id = (SELECT ID FROM Highschooler WHERE name = 'Kyle'))"
        ],
        "rule_sql": [
            "SELECT h.name \nFROM Highschooler h\nJOIN Friend f ON h.ID = f.friend_id\nJOIN Highschooler kyle ON f.student_id = kyle.ID\nWHERE kyle.name = 'Kyle';"
        ]
    },
    "891": {
        "db_id": "network_1",
        "question": "Return the names of friends of the high school student Kyle.",
        "ground_truth": "SELECT T3.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id JOIN Highschooler AS T3 ON T1.friend_id  =  T3.id WHERE T2.name  =  \"Kyle\"",
        "amends": [
            "Do use explicit table aliases `T3.name` instead of ambiguous `name`. Do add `FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id JOIN Highschooler AS T3 ON T1.friend_id = T3.id` instead of simple `FROM friends`. Do filter on `T2.name = 'Kyle'` instead of `student_name = 'Kyle'` to properly reference the student's name from the Highschooler table. The amended query now correctly joins through the relationship tables to find friends of the specified student."
        ],
        "rules": [
            "When answering about \"friends of the high school student Kyle\": make sure the output order: T3.name.",
            "When the question mentions \"Kyle\": \"Kyle\" actually means T2.name = 'Kyle' in schema.",
            "When combining tables for shared entities: link rows where T1.student_id = T2.id and T1.friend_id = T3.id; keep only matching pairs (inner match).",
            "When answering about \"friends of the high school student Kyle\", When the question mentions \"Kyle\", When combining tables for shared entities, When choosing identifier delimiters: do not replace explicit table aliases T3.name with ambiguous name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM friends WHERE student_name = 'Kyle';",
            "SELECT T3.name \nFROM Friend AS T1 \nJOIN Highschooler AS T2 ON T1.student_id = T2.ID \nJOIN Highschooler AS T3 ON T1.friend_id = T3.ID \nWHERE T2.name = 'Kyle'"
        ],
        "rule_sql": [
            "SELECT T3.name\nFROM Friend T1\nJOIN Highschooler T2 ON T1.student_id = T2.ID\nJOIN Highschooler T3 ON T1.friend_id = T3.ID\nWHERE T2.name = 'Kyle';"
        ]
    },
    "892": {
        "db_id": "network_1",
        "question": "How many friends does the high school student Kyle have?",
        "ground_truth": "SELECT count(*) FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.name  =  \"Kyle\"",
        "amends": [
            "Do join `Highschooler` table instead of omitting it, and do use `JOIN` with `T1.student_id = T2.id` instead of querying `friends` table directly. Do filter on `T2.name = 'Kyle'` instead of filtering on `student_name = 'Kyle'` and do remove the `school_level = 'high school'` filter instead of keeping it, since the join to `Highschooler` table inherently provides the correct high school context. The amended query now correctly counts friends by joining through proper table relationships rather than relying on potentially incorrect direct column references."
        ],
        "rules": [
            "When answering about \"how many friends does the high school student Kyle have\": make sure the output order: COUNT of friends.",
            "When the question mentions \"Kyle\": \"Kyle\" actually means \"T2.name = 'Kyle'\" in schema.",
            "When combining T1 and T2 for shared entities: link rows where T1.student_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match).",
            "When the question asks for \"count of friends\": compute the number of rows using the canonical key token for friends relationships.",
            "When answering about \"how many friends does the high school student Kyle have\", When the question mentions \"Kyle\", When combining T1 and T2 for shared entities, When the question asks for \"count of friends\", When the question mentions \"high school student\": this context is inherently provided by joining the Highschooler table (T2) and does not require an explicit school_level filter."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM friends WHERE student_name = 'Kyle' AND school_level = 'high school';",
            "SELECT COUNT(*) \nFROM Friend T1\nJOIN Highschooler T2 ON T1.student_id = T2.ID\nWHERE T2.name = 'Kyle'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Friend f\nJOIN Highschooler h ON f.student_id = h.ID\nWHERE h.name = 'Kyle'"
        ]
    },
    "893": {
        "db_id": "network_1",
        "question": "Count the number of friends Kyle has.",
        "ground_truth": "SELECT count(*) FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.name  =  \"Kyle\"",
        "amends": [
            "Do add `JOIN Highschooler AS T2 ON T1.student_id = T2.id` instead of querying only the `friends` table. Do change the filter to `T2.name = \"Kyle\"` instead of `name = 'Kyle'` since the name column exists in the Highschooler table rather than the friends table. Do use proper table aliasing with `Friend AS T1` instead of the bare table name. The amended query now correctly joins the necessary tables to access the name information and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"number of friends Kyle has\": make sure the output order: count of friends.",
            "When the question mentions \"friends\": \"friends\" actually means \"rows in the Friend table (T1)\".",
            "When the question mentions \"Kyle\": \"Kyle\" actually means \"T2.name = 'Kyle'\" in the Highschooler table.",
            "When combining T1 and T2 for shared entities: link rows where T1.student_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match).",
            "When answering about \"number of friends Kyle has\", When the question mentions \"friends\", When the question mentions \"Kyle\", When combining T1 and T2 for shared entities, When the question asks for \"count of friends\": compute the number of rows using the canonical key token for friends (T1.student_id)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM friends WHERE name = 'Kyle';",
            "SELECT COUNT(*) \nFROM Friend AS T1 \nJOIN Highschooler AS T2 ON T1.student_id = T2.ID \nWHERE T2.name = 'Kyle'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Friend T1\nJOIN Highschooler T2 ON T1.student_id = T2.ID\nWHERE T2.name = 'Kyle'"
        ]
    },
    "894": {
        "db_id": "network_1",
        "question": "Show ids of all students who do not have any friends.",
        "ground_truth": "SELECT id FROM Highschooler EXCEPT SELECT student_id FROM Friend",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do reference table `Highschooler` instead of `students` and table `Friend` instead of `friends`. Do remove the `WHERE` clause entirely instead of keeping the `NOT IN` predicate. The amended query now correctly uses set-based exclusion to find IDs in Highschooler that are not present in Friend, matching the RIGHT_SQL's behavior.",
            "Do select `id` instead of `ID` to match the correct column name. Do remove the second `UNION` clause with `SELECT friend_id FROM Friend` instead of including it, as the right query only needs to find students who are not in the Friend table at all rather than those who might appear as either student_id or friend_id. Do use proper case sensitivity for column names to ensure accurate data retrieval. The amended query now correctly identifies students who have no friends by excluding only those who appear as student_id in the Friend table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"students who do not have any friends\": use table \"Highschooler\" instead of \"students\" and table \"Friend\" instead of \"friends\".",
            "When finding IDs that are not present in another table: use EXCEPT set operation instead of NOT IN with a subquery.",
            "When selecting IDs from Highschooler that are not in Friend: remove the WHERE clause entirely and use set-based exclusion.",
            "When answering about \"students who do not have any friends\", When finding IDs that are not present in another table, When selecting IDs from Highschooler that are not in Friend, When referencing the student identifier: use the exact column \"ID\" from table \"Highschooler\" as the canonical key.",
            "When selecting student identifiers: use exact column name \"id\" instead of \"ID\" to match the correct case-sensitive column name in the Highschooler table.",
            "When finding students without friends: exclude only students who appear as \"student_id\" in the Friend table, not those who appear as \"friend_id\".",
            "When selecting student identifiers, When finding students without friends, When the question asks for students who do not have any friends: identify students who are completely absent from the Friend table's student_id column rather than considering both student_id and friend_id roles."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM students WHERE id NOT IN (SELECT student_id FROM friends)",
            "SELECT ID FROM Highschooler\nEXCEPT\nSELECT student_id FROM Friend\nUNION\nSELECT friend_id FROM Friend",
            "SELECT id FROM Highschooler\nEXCEPT\nSELECT student_id FROM Friend"
        ],
        "rule_sql": [
            "SELECT id FROM Highschooler EXCEPT SELECT student_id FROM Friend"
        ]
    },
    "895": {
        "db_id": "network_1",
        "question": "What are the ids of high school students who do not have friends?",
        "ground_truth": "SELECT id FROM Highschooler EXCEPT SELECT student_id FROM Friend",
        "amends": [
            "Do use a set operation with `EXCEPT` instead of a simple `WHERE` filter on `friend_count = 0`. Do query from the `Highschooler` table instead of `high_school_students`. Do exclude `student_id` values from the `Friend` table instead of checking for zero friend counts. Do remove the `WHERE` clause entirely instead of using it to filter for zero friendships. The amended query now correctly identifies students with no friends by excluding those who appear in the Friend table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"high school students who do not have friends\": use the table \"Highschooler\" instead of \"high_school_students\".",
            "When identifying students with no friends: use a set operation to exclude student_id values that appear in the \"Friend\" table rather than checking for zero friend counts.",
            "When combining data from multiple tables: remove any WHERE clause that filters for zero friendships and instead use the set difference approach.",
            "When answering about \"high school students who do not have friends\", When identifying students with no friends, When combining data from multiple tables, When referring to student identifiers: use \"student_id\" as the exact column name for identification purposes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM high_school_students WHERE friend_count = 0;",
            "SELECT ID FROM Highschooler EXCEPT SELECT student_id FROM Friend"
        ],
        "rule_sql": [
            "SELECT ID FROM Highschooler\nEXCEPT\nSELECT student_id FROM Friend;"
        ]
    },
    "896": {
        "db_id": "network_1",
        "question": "Show names of all high school students who do not have any friends.",
        "ground_truth": "SELECT name FROM Highschooler EXCEPT SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id",
        "amends": [
            "Do use `EXCEPT` set operation instead of filtering with `WHERE` conditions. Do change the data source to `Highschooler` instead of `students`. Do remove the `grade` filter condition instead of keeping it. Do remove the `friend_count` filter condition instead of keeping it. Do add a subquery with `JOIN` between `Friend` and `Highschooler` tables instead of omitting the friend relationship check. Do use `ON T1.student_id = T2.id` for the join condition instead of the previous filtering approach. The amended query now correctly identifies high school students without friends by using set operations rather than direct filtering, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"high school students who do not have any friends\": use the table \"Highschooler\" as the main data source instead of \"students\".",
            "When checking for students without friends: use an EXCEPT set operation to remove students who have friends rather than filtering with friend_count = 0.",
            "When identifying high school students: do not filter by grade condition since the question asks for all high school students.",
            "When checking friendship relationships: join the Friend table with Highschooler using the condition T1.student_id = T2.id to identify students who have friends.",
            "When answering about \"high school students who do not have any friends\", When checking for students without friends, When identifying high school students, When checking friendship relationships, When producing output: return only the name column from Highschooler for students who remain after excluding those with friends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM students WHERE grade = 'High School' AND friend_count = 0;",
            "SELECT name FROM Highschooler\nEXCEPT\nSELECT H.name \nFROM Highschooler H\nJOIN Friend F ON H.ID = F.student_id"
        ],
        "rule_sql": [
            "SELECT name FROM Highschooler\nEXCEPT\nSELECT H.name FROM Highschooler H\nJOIN Friend F ON H.ID = F.student_id"
        ]
    },
    "897": {
        "db_id": "network_1",
        "question": "What are the names of students who have no friends?",
        "ground_truth": "SELECT name FROM Highschooler EXCEPT SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id",
        "amends": [
            "Do use `EXCEPT` to find students without friends instead of filtering for `friend_count = 0`. Do add a subquery with `JOIN` between `Friend` and `Highschooler` tables on `T1.student_id = T2.id` instead of omitting this relationship entirely. Do reference the correct table `Highschooler` instead of the non-existent `students` table. Do remove the incorrect `WHERE friend_count = 0` filter instead of keeping it, as the right approach identifies students without entries in the Friend table rather than relying on a potentially missing or incorrect friend_count column. The amended query now correctly identifies students with no friends by excluding those who appear in the Friend relationship table.",
            "Do use `EXCEPT` with a join-based subquery instead of `NOT IN` with a union of two columns. Do reference `T2.name` from the joined `Highschooler` table instead of directly selecting from the main table. Do join `Friend AS T1` with `Highschooler AS T2` on `T1.student_id = T2.id` instead of using a union subquery that combines both sides of the friendship relationship. Do remove the union operation that was incorrectly treating both sides of the friendship symmetrically. The amended query now correctly identifies students who have no friends by excluding those who appear as either side in the Friend table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for students with no friends: use an EXCEPT operation to find students who are not present in the Friend relationship table instead of filtering on a friend_count column.",
            "When combining Highschooler and Friend tables: link rows where T1.student_id = T2.id to identify friendship relationships.",
            "When referencing student information: use the Highschooler table instead of a non-existent students table.",
            "When the question asks for students with no friends, When combining Highschooler and Friend tables, When referencing student information, When identifying students without friends: exclude those who appear in the Friend table rather than relying on a potentially missing or incorrect friend_count column.",
            "When answering about \"students who have no friends\": make sure the output order: T2.name",
            "When combining Friend table as T1 and Highschooler table as T2: link rows where T1.student_id = T2.id and keep only matching pairs (inner match)",
            "When identifying students with no friends: exclude students who appear in either T1.student_id or T1.friend_id from the Friend table using EXCEPT operation",
            "When answering about \"students who have no friends\", When combining Friend table as T1 and Highschooler table as T2, When identifying students with no friends, When selecting student names: reference T2.name from the joined Highschooler table instead of directly from the main table"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM students WHERE friend_count = 0;",
            "SELECT name FROM Highschooler WHERE ID NOT IN (SELECT student_id FROM Friend UNION SELECT friend_id FROM Friend)",
            "SELECT name FROM Highschooler\nEXCEPT\nSELECT T2.name \nFROM Friend AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID"
        ],
        "rule_sql": [
            "SELECT name FROM Highschooler\nEXCEPT\nSELECT T2.name \nFROM Friend AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.id"
        ]
    },
    "898": {
        "db_id": "network_1",
        "question": "Show the ids of high schoolers who have friends and are also liked by someone else.",
        "ground_truth": "SELECT student_id FROM Friend INTERSECT SELECT liked_id FROM Likes",
        "amends": [
            "Do use `INTERSECT` to find common IDs instead of complex joins and subqueries. Do select `student_id` from `Friend` instead of `h1.id` from multiple joined tables. Do select `liked_id` from `Likes` instead of filtering with `WHERE h1.id IN` subqueries. Do remove the `DISTINCT` keyword instead of keeping it since `INTERSECT` inherently returns unique values. Do eliminate the `Highschooler` table join instead of including unnecessary table relationships. Do remove the join conditions `h1.id = f.id1` and `h1.id = l.id2` instead of maintaining incorrect join logic. The amended query now correctly identifies students who are both friends and liked by someone, matching the RIGHT_SQL's behavior through set intersection rather than complex filtering."
        ],
        "rules": [
            "When answering about high schoolers who have friends and are also liked by someone else: use INTERSECT to find common IDs between the two conditions instead of complex joins and subqueries.",
            "When selecting students who have friends: select \"student_id\" from \"Friend\" table instead of using joined tables.",
            "When selecting students who are liked by someone: select \"liked_id\" from \"Likes\" table instead of filtering with WHERE subqueries.",
            "When using INTERSECT operation: do not use DISTINCT keyword since INTERSECT inherently returns unique values.",
            "When identifying students: eliminate unnecessary joins to the \"Highschooler\" table instead of including table relationships not needed for the intersection.",
            "When answering about high schoolers who have friends and are also liked by someone else, When selecting students who have friends, When selecting students who are liked by someone, When using INTERSECT operation, When identifying students, When combining results from \"Friend\" and \"Likes\" tables: do not use join conditions like \"h1.id = f.id1\" and \"h1.id = l.id2\" since INTERSECT handles the set operation without explicit joins."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT h1.id\nFROM Highschooler h1\nJOIN Friend f ON h1.id = f.id1\nJOIN Likes l ON h1.id = l.id2\nWHERE h1.id IN (SELECT id2 FROM Likes)\nAND h1.id IN (SELECT id1 FROM Friend);",
            "SELECT student_id FROM Friend\nINTERSECT\nSELECT liked_id FROM Likes"
        ],
        "rule_sql": [
            "SELECT student_id FROM Friend\nINTERSECT\nSELECT liked_id FROM Likes"
        ]
    },
    "899": {
        "db_id": "network_1",
        "question": "What are the ids of students who both have friends and are liked?",
        "ground_truth": "SELECT student_id FROM Friend INTERSECT SELECT liked_id FROM Likes",
        "amends": [
            "Do select `student_id` instead of `id` to match the column names in the source tables. Do use `INTERSECT` instead of multiple `IN` subqueries to find the intersection between friends and liked IDs more efficiently. Do reference tables `Friend` and `Likes` instead of `friends` and `likes` to use the correct table names. Do remove the redundant `WHERE` clause and subqueries instead of keeping the complex nested structure. The amended query now correctly identifies students who are both friends and liked by using set intersection semantics.",
            "Do reference `liked_id` from the Likes table instead of `student_id` in the second SELECT clause of the INTERSECT operation. This change correctly identifies the column containing the IDs of students who are liked rather than those who do the liking, ensuring the query properly intersects students who have friends with those who are liked by others. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for student IDs who are both friends and liked: use the exact table names \"Friend\" and \"Likes\" as specified in the schema.",
            "When combining data from multiple tables for set operations: use INTERSECT semantics to find the common student IDs efficiently.",
            "When selecting student identifiers: use the exact column name \"student_id\" from the Friend table to match the schema's column naming.",
            "When referencing the liked students: use the exact column name \"liked_id\" from the Likes table to match the schema's column naming.",
            "When the question asks for student IDs who are both friends and liked, When combining data from multiple tables for set operations, When selecting student identifiers, When referencing the liked students, When producing output: maintain the exact column order and naming as specified in the question (student IDs only).",
            "When the question asks for students who are liked: use the \"liked_id\" column from the Likes table instead of \"student_id\" to identify students who are liked by others.",
            "When the question asks for students who are liked, When combining results from Friend and Likes tables using INTERSECT: ensure both SELECT clauses reference the correct student identifier columns - \"student_id\" from Friend for students who have friends, and \"liked_id\" from Likes for students who are liked."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM students WHERE id IN (SELECT student_id FROM friends) AND id IN (SELECT liked_id FROM likes);",
            "SELECT student_id FROM Friend\nINTERSECT\nSELECT student_id FROM Likes",
            "SELECT student_id FROM Friend\nINTERSECT\nSELECT liked_id FROM Likes"
        ],
        "rule_sql": [
            "SELECT student_id FROM Friend\nINTERSECT\nSELECT liked_id FROM Likes"
        ]
    },
    "900": {
        "db_id": "network_1",
        "question": "Show name of all students who have some friends and also are liked by someone else.",
        "ground_truth": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id INTERSECT SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.liked_id  =  T2.id",
        "amends": [
            "Do use `INTERSECT` to find common names instead of `IN` and `NOT IN` subqueries. Do join `Friend` table with `Highschooler` on `student_id = id` instead of querying `students` table directly. Do join `Likes` table with `Highschooler` on `liked_id = id` instead of using a negative subquery condition. Do select from explicit table aliases `T1` and `T2` instead of assuming a single `students` table. Do use proper table names `Friend` and `Likes` instead of generic `friends` and `likes`. The amended query now correctly finds students who are both in the Friend table and liked in the Likes table using set intersection instead of incorrect exclusion logic."
        ],
        "rules": [
            "When the question asks for students who have friends and are liked by someone: use INTERSECT to find common students between those who have friends and those who are liked, instead of using IN and NOT IN subqueries.",
            "When joining the Friend table with Highschooler: link rows where Friend.student_id equals Highschooler.id.",
            "When joining the Likes table with Highschooler: link rows where Likes.liked_id equals Highschooler.id.",
            "When selecting from multiple tables: use explicit table aliases T1 and T2 instead of assuming a single students table.",
            "When referring to table names: use exact table names \"Friend\" and \"Likes\" instead of generic \"friends\" and \"likes\".",
            "When the question asks for students who have friends and are liked by someone, When joining the Friend table with Highschooler, When joining the Likes table with Highschooler, When selecting from multiple tables, When referring to table names, When producing output: select the name column from the intersected result set."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM students WHERE id IN (SELECT student_id FROM friends) AND id NOT IN (SELECT liked_id FROM likes);",
            "SELECT T1.name\nFROM Highschooler T1\nJOIN Friend ON T1.ID = Friend.student_id\nINTERSECT\nSELECT T2.name\nFROM Highschooler T2\nJOIN Likes ON T2.ID = Likes.liked_id"
        ],
        "rule_sql": [
            "SELECT T1.name\nFROM Highschooler T1\nWHERE T1.ID IN (\n    SELECT student_id FROM Friend\n)\nINTERSECT\nSELECT T2.name\nFROM Highschooler T2\nWHERE T2.ID IN (\n    SELECT liked_id FROM Likes\n)"
        ]
    },
    "901": {
        "db_id": "network_1",
        "question": "What are the names of high schoolers who both have friends and are liked?",
        "ground_truth": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id INTERSECT SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.liked_id  =  T2.id",
        "amends": [
            "Do use explicit `JOIN` syntax with table aliases instead of subqueries with `IN` clauses. Do reference `Friend.student_id` and `Likes.liked_id` instead of generic `id1` and `id2` columns. Do use `INTERSECT` to find the intersection of friends and liked students instead of multiple `IN` conditions. Do specify table aliases `T1` and `T2` for clarity instead of direct table references. Do join `Highschooler` on the appropriate foreign key columns (`student_id` and `liked_id`) instead of assuming generic `id` matches. The amended query now correctly identifies high schoolers who are both friends with someone and liked by someone using proper join semantics and set intersection."
        ],
        "rules": [
            "When combining tables for shared entities: link Highschooler rows with Friend rows where T1.ID = T2.student_id and keep only matching pairs (inner match).",
            "When combining tables for shared entities: link Highschooler rows with Likes rows where T1.ID = T3.liked_id and keep only matching pairs (inner match).",
            "When finding students who satisfy multiple conditions: use set intersection to find students who appear in both Friend and Likes relationships.",
            "When answering about \"names of high schoolers who both have friends and are liked\": make sure the output order: name from Highschooler table.",
            "When the question mentions \"have friends\": this means students who appear in the Friend.student_id column.",
            "When combining tables for shared entities, When combining tables for shared entities, When finding students who satisfy multiple conditions, When answering about \"names of high schoolers who both have friends and are liked\", When the question mentions \"have friends\", When the question mentions \"are liked\": this means students who appear in the Likes.liked_id column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM highschooler WHERE id IN (SELECT id1 FROM friend) AND id IN (SELECT id2 FROM likes)",
            "SELECT T1.name\nFROM Highschooler T1\nJOIN Friend F ON T1.ID = F.student_id\nINTERSECT\nSELECT T2.name\nFROM Highschooler T2\nJOIN Likes L ON T2.ID = L.liked_id"
        ],
        "rule_sql": [
            "SELECT DISTINCT h.name\nFROM Highschooler h\nWHERE h.ID IN (\n    SELECT student_id FROM Friend\n) \nAND h.ID IN (\n    SELECT liked_id FROM Likes\n)\nORDER BY h.name;"
        ]
    },
    "902": {
        "db_id": "network_1",
        "question": "Count the number of likes for each student id.",
        "ground_truth": "SELECT student_id ,  count(*) FROM Likes GROUP BY student_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id, COUNT(*) FROM likes GROUP BY student_id;"
        ],
        "rule_sql": [
            "SELECT student_id, COUNT(liked_id) AS like_count FROM Likes GROUP BY student_id;"
        ]
    },
    "903": {
        "db_id": "network_1",
        "question": "How many likes correspond to each student id?",
        "ground_truth": "SELECT student_id ,  count(*) FROM Likes GROUP BY student_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id, COUNT(*) FROM likes GROUP BY student_id;"
        ],
        "rule_sql": [
            "SELECT student_id, COUNT(liked_id) AS like_count FROM Likes GROUP BY student_id ORDER BY student_id;"
        ]
    },
    "904": {
        "db_id": "network_1",
        "question": "Show the names of high schoolers who have likes, and numbers of likes for each.",
        "ground_truth": "SELECT T2.name ,  count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id",
        "amends": [
            "Do use `T2.name` instead of `name` to explicitly reference the joined table's column. Do join `Likes AS T1` to `Highschooler AS T2` instead of joining `Highschooler` to `Likes` to establish the correct table relationship direction. Do use the join condition `T1.student_id = T2.id` instead of `Highschooler.id = Likes.student_id` to properly match the student ID from Likes to the ID in Highschooler. Do group by `T1.student_id` instead of `name` to ensure accurate count aggregation per student rather than potentially grouping by duplicate names. The amended query now correctly counts likes per student while properly handling the table relationships."
        ],
        "rules": [
            "When joining tables for high schoolers who have likes: link rows where T1.student_id = T2.id to match student IDs from Likes to IDs in Highschooler, keeping only matching pairs (inner match).",
            "When counting likes per student: group by T1.student_id to ensure accurate count aggregation per individual student rather than by potentially duplicate names.",
            "When selecting student names: use T2.name to explicitly reference the name column from the Highschooler table.",
            "When joining tables for high schoolers who have likes, When counting likes per student, When selecting student names, When the question asks for numbers of likes for each high schooler: count the number of likes using the student_id from the Likes table as the counting key."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, COUNT(*) FROM Highschooler JOIN Likes ON Highschooler.id = Likes.student_id GROUP BY name",
            "SELECT T2.name, COUNT(*) AS number_of_likes\nFROM Likes AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id"
        ],
        "rule_sql": [
            "SELECT T2.name, COUNT(T1.student_id) AS number_of_likes\nFROM Likes T1\nINNER JOIN Highschooler T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id"
        ]
    },
    "905": {
        "db_id": "network_1",
        "question": "What are the names of high schoolers who have likes, and how many likes does each have?",
        "ground_truth": "SELECT T2.name ,  count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id",
        "amends": [
            "Do select `T2.name` and `count(*)` without an alias instead of selecting `name` and `COUNT(*) as like_count`. Do join `Likes AS T1` with `Highschooler AS T2` on `T1.student_id = T2.id` instead of querying only `high_schoolers` table. Do group by `T1.student_id` instead of grouping by `name`. Do remove the `HAVING like_count > 0` condition instead of keeping it since all groups will have at least one count. Do remove the `ORDER BY like_count DESC` clause instead of including it. The amended query now correctly counts likes per student by joining the Likes table with Highschooler table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"names of high schoolers who have likes\": select \"T2\".\"name\" and count(*) without an alias.",
            "When combining Likes and Highschooler tables: link rows where \"T1\".\"student_id\" = \"T2\".\"id\" and keep only matching pairs (inner match).",
            "When counting likes per student: group by \"T1\".\"student_id\" instead of grouping by name.",
            "When all groups will have at least one count: do not include a HAVING condition to filter out zero counts.",
            "When answering about \"names of high schoolers who have likes\", When combining Likes and Highschooler tables, When counting likes per student, When all groups will have at least one count, When the question does not specify ordering: do not include an ORDER BY clause."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, COUNT(*) as like_count FROM high_schoolers GROUP BY name HAVING like_count > 0 ORDER BY like_count DESC;",
            "SELECT T2.name, COUNT(*)\nFROM Likes AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id"
        ],
        "rule_sql": [
            "SELECT T2.name, COUNT(*) FROM Likes T1 JOIN Highschooler T2 ON T1.student_id = T2.ID GROUP BY T1.student_id"
        ]
    },
    "906": {
        "db_id": "network_1",
        "question": "What is the name of the high schooler who has the greatest number of likes?",
        "ground_truth": "SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `T2.name` from the `Highschooler` table instead of selecting just `name` without a table reference. Do change the FROM clause to use `Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id` instead of querying only the `highschooler` table. Do add `GROUP BY T1.student_id` to aggregate by student instead of omitting grouping. Do change the ORDER BY to use `count(*) DESC` instead of `likes DESC` to order by the count of likes rather than a direct column value. Do remove the direct reference to `likes` column since the count is now derived from the join and aggregation. The amended query now correctly identifies the student with the most likes by counting relationships in the Likes table rather than relying on a potentially non-existent likes column."
        ],
        "rules": [
            "When answering about \"the high schooler who has the greatest number of likes\": make sure the output order: T2.name.",
            "When the question mentions \"number of likes\": this actually means \"count of relationships in the Likes table per student\".",
            "When combining T1 (Likes) and T2 (Highschooler) for shared entities: link rows where T1.student_id = T2.id and keep only matching pairs (inner match).",
            "When the question asks for \"count of likes per student\": compute the number of rows using T1.student_id as the grouping key and count each occurrence.",
            "When the question asks for \"greatest number\" or \"top 1\": rank rows by count(*) in descending order and keep the first 1 row.",
            "When answering about \"the high schooler who has the greatest number of likes\", When the question mentions \"number of likes\", When combining T1 (Likes) and T2 (Highschooler) for shared entities, When the question asks for \"count of likes per student\", When the question asks for \"greatest number\" or \"top 1\", When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for any identifiers."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM highschooler ORDER BY likes DESC LIMIT 1;",
            "SELECT T2.name\nFROM Likes AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.name\nFROM Likes T1\nJOIN Highschooler T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "907": {
        "db_id": "network_1",
        "question": "Give the name of the student with the most likes.",
        "ground_truth": "SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.name` from the `Highschooler` table instead of `name` from the `students` table. Do join `Likes AS T1` with `Highschooler AS T2` on `T1.student_id = T2.id` instead of querying a single table. Do add `GROUP BY T1.student_id` to aggregate likes per student instead of ordering individual records. Do order by `count(*) DESC` to rank by total like count instead of `likes DESC` which would sort by a single like value. Do remove the direct `ORDER BY likes` clause and instead use aggregate counting through grouping. The amended query now correctly identifies the student with the most likes by joining the Likes table with student information and counting occurrences per student."
        ],
        "rules": [
            "When answering about \"student with the most likes\": make sure the output order: T2.name",
            "When the question mentions \"student\": \"student\" actually means \"Highschooler\" in schema",
            "When combining T1 and T2 for shared entities: link rows where T1.student_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match)",
            "When the question asks for \"count of likes per student\": organize results by T1.student_id and compute count(*) per group",
            "When answering about \"student with the most likes\", When the question mentions \"student\", When combining T1 and T2 for shared entities, When the question asks for \"count of likes per student\", When the question mentions \"most likes\" or \"highest\": rank rows by count(*) in descending direction and keep the first 1 row"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM students ORDER BY likes DESC LIMIT 1;",
            "SELECT T2.name\nFROM Likes AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.name\nFROM Likes T1\nINNER JOIN Highschooler T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "908": {
        "db_id": "network_1",
        "question": "Show the names of students who have at least 2 likes.",
        "ground_truth": "SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id HAVING count(*)  >=  2",
        "amends": [
            "Do select `T2.name` from the joined table instead of `name` from a single table. Do use `FROM Likes AS T1 JOIN Highschooler AS T2` with an explicit join instead of querying only `FROM students`. Do add the join condition `ON T1.student_id = T2.id` instead of missing the table relationship. Do add `GROUP BY T1.student_id` to aggregate by student instead of no grouping. Do move the count filter to `HAVING count(*) >= 2` instead of using `WHERE likes >= 2` on a non-aggregated column. The amended query now correctly counts likes per student and filters those with at least two likes, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"students who have at least 2 likes\": make sure the output order: T2.name",
            "When the question mentions \"students\": \"students\" actually means \"Highschooler AS T2\" in schema",
            "When the question mentions \"likes\": \"likes\" actually means \"Likes AS T1\" in schema",
            "When combining T1 and T2 for shared entities: link rows where T1.student_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match)",
            "When the question asks for \"count of likes per student\": compute the number of rows using T1.student_id as the grouping key and count occurrences per student",
            "When answering about \"students who have at least 2 likes\", When the question mentions \"students\", When the question mentions \"likes\", When combining T1 and T2 for shared entities, When the question asks for \"count of likes per student\", When filtering for \"at least 2 likes\": apply the condition count(*) >= 2 after grouping instead of on individual rows"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM students WHERE likes >= 2;",
            "SELECT T2.name \nFROM Likes AS T1 \nJOIN Highschooler AS T2 ON T1.student_id = T2.ID \nGROUP BY T1.student_id \nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T2.name\nFROM Likes AS T1\nINNER JOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nHAVING COUNT(*) >= 2\nORDER BY T2.name"
        ]
    },
    "909": {
        "db_id": "network_1",
        "question": "What are the names of students who have 2 or more likes?",
        "ground_truth": "SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id HAVING count(*)  >=  2",
        "amends": [
            "Do select `T2.name` from the joined table instead of `name` from a single table. Do join `Likes AS T1` with `Highschooler AS T2` on `T1.student_id = T2.id` instead of querying a single `students` table. Do use `GROUP BY T1.student_id` with `HAVING count(*) >= 2` instead of a simple `WHERE likes >= 2` filter. Do completely restructure the query to properly count relationships through the Likes table instead of assuming a direct likes column. The amended query now correctly identifies students who have at least two likes by joining the appropriate tables and using aggregate counting."
        ],
        "rules": [
            "When answering about \"names of students who have 2 or more likes\": make sure the output order: T2.name.",
            "When the question mentions \"students\": \"students\" actually means \"Highschooler AS T2\" in schema.",
            "When the question mentions \"likes\": \"likes\" actually means \"relationships in Likes AS T1\" in schema.",
            "When combining T1 and T2 for shared entities: link rows where T1.student_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match).",
            "When the question asks for \"count of likes per student\": compute the number of rows using the canonical key T1.student_id with GROUP BY T1.student_id.",
            "When answering about \"names of students who have 2 or more likes\", When the question mentions \"students\", When the question mentions \"likes\", When combining T1 and T2 for shared entities, When the question asks for \"count of likes per student\", When filtering for \"2 or more likes\": use HAVING count(*) >= 2 instead of a simple WHERE condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM students WHERE likes >= 2",
            "SELECT T2.name \nFROM Likes AS T1 \nJOIN Highschooler AS T2 ON T1.student_id = T2.ID \nGROUP BY T1.student_id \nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.ID GROUP BY T1.student_id HAVING COUNT(*) >= 2 ORDER BY T2.name;"
        ]
    },
    "910": {
        "db_id": "network_1",
        "question": "Show the names of students who have a grade higher than 5 and have at least 2 friends.",
        "ground_truth": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.grade  >  5 GROUP BY T1.student_id HAVING count(*)  >=  2",
        "amends": [
            "Do select `T2.name` from the `Highschooler` table instead of `name` from the `students` table. Do use a `JOIN` between `Friend` as `T1` and `Highschooler` as `T2` on `T1.student_id = T2.id` instead of querying a single table. Do move the friends count filter to `HAVING count(*) >= 2` instead of using `friends >= 2` in the WHERE clause. Do add `GROUP BY T1.student_id` to support the aggregate count instead of omitting grouping. Do keep the grade filter `T2.grade > 5` in the WHERE clause but reference it through the joined table instead of directly. The amended query now correctly identifies students with at least two friends in grade above 5 by joining the Friend and Highschooler tables and using proper aggregation."
        ],
        "rules": [
            "When answering about student names: select \"T2\".\"name\" from the \"Highschooler\" table instead of \"name\" from a \"students\" table.",
            "When combining Friend and Highschooler tables: link rows where \"T1\".\"student_id\" = \"T2\".\"id\" and keep only matching pairs (inner match).",
            "When filtering by grade higher than 5: apply the condition \"T2\".\"grade\" > 5 in the WHERE clause.",
            "When counting friends per student: group by \"T1\".\"student_id\" and count the number of friend relationships.",
            "When answering about student names, When combining Friend and Highschooler tables, When filtering by grade higher than 5, When counting friends per student, When requiring at least 2 friends: filter groups using HAVING count(*) >= 2 instead of using a direct column comparison."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM students WHERE grade > 5 AND friends >= 2;",
            "SELECT T2.name \nFROM Friend AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID\nWHERE T2.grade > 5\nGROUP BY T1.student_id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T2.name \nFROM Friend T1\nINNER JOIN Highschooler T2 ON T1.student_id = T2.ID\nWHERE T2.grade > 5\nGROUP BY T1.student_id\nHAVING COUNT(*) >= 2"
        ]
    },
    "911": {
        "db_id": "network_1",
        "question": "What are the names of high schoolers who have a grade of over 5 and have 2 or more friends?",
        "ground_truth": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.grade  >  5 GROUP BY T1.student_id HAVING count(*)  >=  2",
        "amends": [
            "Do use explicit `JOIN` syntax with `Friend AS T1 JOIN Highschooler AS T2` instead of a subquery in the WHERE clause. Do reference the joined table alias `T2.name` instead of the original table name `name`. Do move the grade filter to the `WHERE` clause with `T2.grade > 5` instead of keeping it in the main query's WHERE. Do add `GROUP BY T1.student_id` instead of omitting grouping. Do move the count condition to `HAVING count(*) >= 2` instead of using a correlated subquery. Do use proper table aliases `T1` and `T2` throughout instead of direct table references. The amended query now correctly identifies high schoolers with at least two friends using proper join and aggregation semantics."
        ],
        "rules": [
            "When combining Friend and Highschooler tables: link rows where T1.student_id equals T2.id using an inner join.",
            "When filtering by grade: apply condition T2.grade > 5 to select high schoolers with grades over 5.",
            "When counting friends per student: group results by T1.student_id and count the number of friend records for each student.",
            "When requiring minimum friend count: include only groups having count(*) >= 2.",
            "When combining Friend and Highschooler tables, When filtering by grade, When counting friends per student, When requiring minimum friend count, When selecting output columns: return T2.name as the result column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM high_schoolers WHERE grade > 5 AND (SELECT COUNT(*) FROM friends WHERE friends.student_id = high_schoolers.id) >= 2;",
            "SELECT T2.name \nFROM Friend AS T1 \nJOIN Highschooler AS T2 ON T1.student_id = T2.ID \nWHERE T2.grade > 5 \nGROUP BY T1.student_id \nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T2.name \nFROM Friend T1 \nINNER JOIN Highschooler T2 ON T1.student_id = T2.ID \nWHERE T2.grade > 5 \nGROUP BY T1.student_id \nHAVING COUNT(*) >= 2"
        ]
    },
    "912": {
        "db_id": "network_1",
        "question": "How many likes does Kyle have?",
        "ground_truth": "SELECT count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.name  =  \"Kyle\"",
        "amends": [
            "Do use `count(*)` with lowercase instead of `COUNT(*)` with uppercase. Do add `FROM Likes AS T1 JOIN Highschooler AS T2` instead of `FROM users`. Do add join condition `ON T1.student_id = T2.id` instead of omitting it. Do change filter to `WHERE T2.name = \"Kyle\"` instead of `WHERE name = 'Kyle'`. The amended query now correctly counts likes from the student named Kyle by joining the Likes and Highschooler tables instead of incorrectly querying a non-existent users table."
        ],
        "rules": [
            "When the question asks about \"likes\" for a student: use the \"Likes\" table as T1 and \"Highschooler\" table as T2 instead of a \"users\" table.",
            "When combining T1 and T2 for shared entities: link rows where T1.student_id equals T2.id exactly and keep only matching pairs (inner match).",
            "When filtering for a student named \"Kyle\": use the exact literal \"Kyle\" with double quotes in the condition T2.name = \"Kyle\".",
            "When counting likes: use count(*) with lowercase instead of uppercase COUNT(*).",
            "When the question asks about \"likes\" for a student, When combining T1 and T2 for shared entities, When filtering for a student named \"Kyle\", When counting likes, When answering about \"how many likes does Kyle have\": make sure to count all likes associated with the student named Kyle through the join relationship."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE name = 'Kyle';",
            "SELECT count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.ID WHERE T2.name = \"Kyle\""
        ],
        "rule_sql": [
            "SELECT count(*) FROM Likes T1 JOIN Highschooler T2 ON T1.student_id = T2.ID WHERE T2.name = \"Kyle\""
        ]
    },
    "913": {
        "db_id": "network_1",
        "question": "Return the number of likes that the high schooler named Kyle has.",
        "ground_truth": "SELECT count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.name  =  \"Kyle\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM likes WHERE student_id = (SELECT id FROM highschooler WHERE name = 'Kyle');"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Likes \nJOIN Highschooler ON Likes.student_id = Highschooler.ID \nWHERE Highschooler.name = 'Kyle'"
        ]
    },
    "914": {
        "db_id": "network_1",
        "question": "Find the average grade of all students who have some friends.",
        "ground_truth": "SELECT avg(grade) FROM Highschooler WHERE id IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id)",
        "amends": [
            "Do use `avg(grade)` from `Highschooler` instead of `AVG(grade)` from `students`. Do add a subquery with `id IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id)` instead of the simple filter `WHERE friend_count > 0`. Do change the table source to `Highschooler` instead of `students` and introduce a join between `Friend` and `Highschooler` tables instead of relying on a direct column filter. The amended query now correctly calculates average grades for students who have friends by verifying friendship relationships through the Friend table join rather than using a potentially incorrect friend_count field."
        ],
        "rules": [
            "When answering about \"average grade of all students who have some friends\": make sure the output order: avg(grade).",
            "When the question mentions \"students who have some friends\": use a subquery with id IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id) instead of a simple friend_count filter.",
            "When combining Friend and Highschooler tables: link rows where T1.student_id = T2.id and keep only matching pairs (inner match).",
            "When answering about \"average grade of all students who have some friends\", When the question mentions \"students who have some friends\", When combining Friend and Highschooler tables, When computing average grade: use avg(grade) from Highschooler table instead of students table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(grade) FROM students WHERE friend_count > 0",
            "SELECT AVG(grade) FROM Highschooler WHERE ID IN (SELECT student_id FROM Friend)"
        ],
        "rule_sql": [
            "SELECT AVG(grade) FROM Highschooler WHERE ID IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id)"
        ]
    },
    "915": {
        "db_id": "network_1",
        "question": "What is the average grade of students who have friends?",
        "ground_truth": "SELECT avg(grade) FROM Highschooler WHERE id IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id)",
        "amends": [
            "Do select `avg(grade)` from `Highschooler` instead of `AVG(grade)` from `students`. Do use a subquery with `id IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id)` instead of filtering with `WHERE friend_count > 0`. Do join `Friend` table with `Highschooler` on `T1.student_id = T2.id` instead of relying on a direct `friend_count` column. The amended query now correctly identifies students who have friends by checking the Friend relationship table rather than assuming a friend_count column exists, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"average grade of students who have friends\": make sure the output order: avg(grade).",
            "When the question mentions \"students who have friends\": use a subquery with id IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id) instead of filtering with friend_count > 0.",
            "When combining Friend and Highschooler tables: link rows where T1.student_id = T2.id and keep only matching pairs (inner match).",
            "When answering about \"average grade of students who have friends\", When the question mentions \"students who have friends\", When combining Friend and Highschooler tables, When computing average grade: use avg(grade) from Highschooler table instead of AVG(grade) from students table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(grade) FROM students WHERE friend_count > 0",
            "SELECT AVG(grade) FROM Highschooler WHERE id IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id)"
        ],
        "rule_sql": [
            "SELECT AVG(grade) FROM Highschooler WHERE ID IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id)"
        ]
    },
    "916": {
        "db_id": "network_1",
        "question": "Find the minimum grade of students who have no friends.",
        "ground_truth": "SELECT min(grade) FROM Highschooler WHERE id NOT IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id)",
        "amends": [
            "Do query the `Highschooler` table instead of the `students` table. Do use `min(grade)` with lowercase function name instead of `MIN(grade)`. Do change the subquery to use `Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id` instead of `SELECT friend_id FROM friends`, adding proper table aliases and join conditions. Do reference `T1.student_id` in the subquery's SELECT list instead of `friend_id`. The amended query now correctly identifies students without friends by properly joining the Friend and Highschooler tables to validate friend relationships."
        ],
        "rules": [
            "When answering about \"minimum grade of students who have no friends\": query the \"Highschooler\" table instead of a \"students\" table.",
            "When computing the minimum grade: use lowercase function name \"min(grade)\" instead of uppercase \"MIN(grade)\".",
            "When identifying students without friends: use a subquery that joins \"Friend AS T1\" with \"Highschooler AS T2\" where \"T1.student_id = T2.id\" instead of a simple \"SELECT friend_id FROM friends\".",
            "When answering about \"minimum grade of students who have no friends\", When computing the minimum grade, When identifying students without friends, When referencing the friend relationship in the subquery: use \"T1.student_id\" instead of \"friend_id\" to properly identify students who have friends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(grade) FROM students WHERE id NOT IN (SELECT friend_id FROM friends)",
            "SELECT min(grade) FROM Highschooler WHERE ID NOT IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.ID)"
        ],
        "rule_sql": [
            "SELECT min(grade) FROM Highschooler WHERE ID NOT IN (SELECT T2.ID FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.ID)"
        ]
    },
    "917": {
        "db_id": "network_1",
        "question": "What is the lowest grade of students who do not have any friends?",
        "ground_truth": "SELECT min(grade) FROM Highschooler WHERE id NOT IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id)",
        "amends": [
            "Do reference table `Highschooler` instead of `students` in the FROM clause. Do use the correct subquery structure with `Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id` instead of `SELECT DISTINCT student_id FROM friends`. Do remove the WHERE clause filter entirely instead of keeping it, as the filtering logic is now handled within the subquery. The amended query now correctly identifies minimum grades from Highschooler where IDs are not found in the Friend relationship table, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"lowest grade of students who do not have any friends\": make sure the output order: MIN(grade).",
            "When the question mentions \"students\": \"students\" actually means \"Highschooler\" in schema.",
            "When the question mentions \"friends\": \"friends\" actually means \"Friend\" in schema.",
            "When combining Highschooler and Friend for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (T1.student_id = T2.id); keep only matching pairs (inner match).",
            "When answering about \"lowest grade of students who do not have any friends\", When the question mentions \"students\", When the question mentions \"friends\", When combining Highschooler and Friend for shared entities, When identifying students without friends: find Highschooler rows where id values are not present in the Friend relationship table through the join condition T1.student_id = T2.id."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(grade) FROM students WHERE id NOT IN (SELECT DISTINCT student_id FROM friends);",
            "SELECT MIN(grade) FROM Highschooler WHERE ID NOT IN (SELECT student_id FROM Friend)"
        ],
        "rule_sql": [
            "SELECT MIN(grade) \nFROM Highschooler \nWHERE ID NOT IN (SELECT student_id FROM Friend)"
        ]
    },
    "918": {
        "db_id": "dog_kennels",
        "question": "Which states have both owners and professionals living there?",
        "ground_truth": "SELECT state FROM Owners INTERSECT SELECT state FROM Professionals",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT state FROM owners INTERSECT SELECT state FROM professionals;"
        ],
        "rule_sql": [
            "SELECT DISTINCT o.state\nFROM Owners o\nINNER JOIN Professionals p ON o.state = p.state\nWHERE o.state IS NOT NULL AND p.state IS NOT NULL\nORDER BY o.state;"
        ]
    },
    "919": {
        "db_id": "dog_kennels",
        "question": "Find the states where both owners and professionals live.",
        "ground_truth": "SELECT state FROM Owners INTERSECT SELECT state FROM Professionals",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT state FROM owners INTERSECT SELECT DISTINCT state FROM professionals;"
        ],
        "rule_sql": [
            "SELECT DISTINCT o.state\nFROM Owners o\nINNER JOIN Professionals p ON o.state = p.state"
        ]
    },
    "920": {
        "db_id": "dog_kennels",
        "question": "What is the average age of the dogs who have gone through any treatments?",
        "ground_truth": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )",
        "amends": [
            "Do use `avg(age)` with lowercase function instead of `AVG(age)` with uppercase function. Do filter with `dog_id IN (subquery)` instead of `treatment_id IS NOT NULL`. Do reference the `Dogs` table with proper capitalization instead of `dogs` lowercase. Do add a correlated subquery `SELECT dog_id FROM Treatments` to properly identify dogs that have received treatments instead of checking for non-null treatment_id directly in the dogs table. The amended query now correctly identifies dogs that have treatment records by checking against the Treatments table rather than relying on a potentially incorrect treatment_id field in the dogs table, ensuring the query matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"average age of dogs who have gone through treatments\": make sure the output order: avg(age).",
            "When the question mentions \"dogs who have gone through any treatments\": use a subquery to select dog_id from the Treatments table instead of checking treatment_id IS NOT NULL.",
            "When computing the average age: use lowercase avg(age) function instead of uppercase AVG(age).",
            "When answering about \"average age of dogs who have gone through treatments\", When the question mentions \"dogs who have gone through any treatments\", When computing the average age, When referencing the Dogs table: use proper capitalization \"Dogs\" instead of lowercase \"dogs\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age) FROM dogs WHERE treatment_id IS NOT NULL;",
            "SELECT avg(age) FROM Dogs WHERE dog_id IN (SELECT dog_id FROM Treatments)"
        ],
        "rule_sql": [
            "SELECT avg(age) FROM Dogs WHERE dog_id IN (SELECT dog_id FROM Treatments);"
        ]
    },
    "921": {
        "db_id": "dog_kennels",
        "question": "Find the average age of the dogs who went through treatments.",
        "ground_truth": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )",
        "amends": [
            "Do use `avg(age)` with lowercase function instead of `AVG(age)` with uppercase. Do filter using `dog_id IN (subquery)` instead of `treatment_id IS NOT NULL`. Do reference table as `Dogs` instead of `dogs`. Do add a correlated subquery `SELECT dog_id FROM Treatments` to properly identify dogs that have treatments instead of checking for non-null treatment_id values. The amended query now correctly calculates average age only for dogs that have corresponding treatment records, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"average age of dogs who went through treatments\": make sure the output order: avg(age).",
            "When the question mentions \"dogs who went through treatments\": use a subquery to select dog_id from Treatments table instead of checking for non-null treatment_id values.",
            "When computing average age: use lowercase avg(age) function instead of uppercase AVG(age).",
            "When referencing the dogs table: use exact identifier \"Dogs\" with proper casing instead of lowercase \"dogs\".",
            "When answering about \"average age of dogs who went through treatments\", When the question mentions \"dogs who went through treatments\", When computing average age, When referencing the dogs table, When filtering dogs with treatments: use dog_id IN (SELECT dog_id FROM Treatments) to properly identify dogs that have corresponding treatment records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age) FROM dogs WHERE treatment_id IS NOT NULL;",
            "SELECT avg(age) FROM Dogs WHERE dog_id IN (SELECT dog_id FROM Treatments)"
        ],
        "rule_sql": [
            "SELECT avg(age) FROM Dogs WHERE dog_id IN (SELECT dog_id FROM Treatments)"
        ]
    },
    "922": {
        "db_id": "dog_kennels",
        "question": "Which professionals live in the state of Indiana or have done treatment on more than 2 treatments? List his or her id, last name and cell phone.",
        "ground_truth": "SELECT professional_id ,  last_name ,  cell_number FROM Professionals WHERE state  =  'Indiana' UNION SELECT T1.professional_id ,  T1.last_name ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >  2",
        "amends": [
            "Do use `professional_id` instead of `id` in the SELECT list and change `cell_phone` to `cell_number` instead of keeping the original column name. Do add a UNION operation instead of using a single query with OR logic. Do change the first part to select from `Professionals` instead of `professionals` with proper table name casing. Do add a second query that performs a `JOIN` with `Treatments` table on `professional_id` instead of omitting this table entirely. Do move the count condition to `HAVING count(*) > 2` instead of using `treatment_count > 2` in the WHERE clause. Do use proper table aliasing with `AS T1` and `AS T2` instead of no aliases. Do include `GROUP BY T1.professional_id` instead of omitting grouping. The amended query now correctly handles the union of Indiana professionals and those with more than two treatments through proper table joining and aggregation."
        ],
        "rules": [
            "When selecting professional identifiers: use \"professional_id\" instead of \"id\" in the output columns.",
            "When selecting phone numbers: use \"cell_number\" instead of \"cell_phone\" as the column name.",
            "When querying the professionals table: use exact table name \"Professionals\" with proper casing instead of lowercase \"professionals\".",
            "When finding professionals who have done more than 2 treatments: join \"Professionals\" (as T1) with \"Treatments\" (as T2) on T1.professional_id = T2.professional_id instead of using a single table.",
            "When counting treatments per professional: group by T1.professional_id and use HAVING count(*) > 2 instead of checking treatment_count > 2 in WHERE clause.",
            "When combining results for Indiana professionals and those with many treatments: use UNION operation instead of OR logic in a single query.",
            "When selecting professional identifiers, When selecting phone numbers, When querying the professionals table, When finding professionals who have done more than 2 treatments, When counting treatments per professional, When combining results for Indiana professionals and those with many treatments, When outputting results: maintain the column order as professional_id, last_name, cell_number."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, last_name, cell_phone FROM professionals WHERE state = 'Indiana' OR treatment_count > 2;",
            "SELECT professional_id, last_name, cell_number FROM Professionals WHERE state = 'Indiana'\nUNION\nSELECT T1.professional_id, T1.last_name, T1.cell_number \nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT professional_id, last_name, cell_number\nFROM Professionals\nWHERE state = 'Indiana'\nUNION\nSELECT T1.professional_id, T1.last_name, T1.cell_number\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) > 2\nORDER BY professional_id;"
        ]
    },
    "923": {
        "db_id": "dog_kennels",
        "question": "Find the id, last name and cell phone of the professionals who live in the state of Indiana or have performed more than two treatments.",
        "ground_truth": "SELECT professional_id ,  last_name ,  cell_number FROM Professionals WHERE state  =  'Indiana' UNION SELECT T1.professional_id ,  T1.last_name ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >  2",
        "amends": [
            "Do use `professional_id` instead of `id` and `cell_number` instead of `cell_phone` in the SELECT list. Do change the table name to `Professionals` instead of `professionals`. Do replace the WHERE clause with a UNION operation instead of using OR logic. Do add a second query that joins `Professionals AS T1` with `Treatments AS T2` on `T1.professional_id = T2.professional_id` instead of omitting this join. Do move the count condition to `HAVING count(*) > 2` instead of keeping it in the WHERE clause. Do use proper table aliases and group by `T1.professional_id` instead of not grouping. The amended query now correctly separates Indiana professionals from those with more than 2 treatments using UNION instead of incorrect OR logic that would miss the join requirement."
        ],
        "rules": [
            "When selecting professional information: use \"professional_id\" instead of \"id\" and \"cell_number\" instead of \"cell_phone\" in the output columns.",
            "When referring to the professionals table: use the exact table name \"Professionals\" with proper capitalization.",
            "When finding professionals who live in Indiana or have performed more than two treatments: use a UNION operation instead of OR logic to combine two separate result sets.",
            "When counting treatments per professional: join \"Professionals AS T1\" with \"Treatments AS T2\" on \"T1.professional_id = T2.professional_id\" using an inner match.",
            "When filtering professionals by treatment count: group by \"T1.professional_id\" and use \"HAVING count(*) > 2\" instead of a WHERE clause condition.",
            "When selecting professional information, When referring to the professionals table, When finding professionals who live in Indiana or have performed more than two treatments, When counting treatments per professional, When filtering professionals by treatment count, When the question mentions \"state of Indiana\": use the exact literal value 'Indiana' with proper capitalization for state comparison."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, last_name, cell_phone FROM professionals WHERE state = 'Indiana' OR treatment_count > 2",
            "SELECT professional_id, last_name, cell_number FROM Professionals WHERE state = 'Indiana'\nUNION\nSELECT T1.professional_id, T1.last_name, T1.cell_number \nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT professional_id, last_name, cell_number FROM Professionals WHERE state = 'Indiana'\nUNION\nSELECT T1.professional_id, T1.last_name, T1.cell_number \nFROM Professionals AS T1\nINNER JOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) > 2"
        ]
    },
    "924": {
        "db_id": "dog_kennels",
        "question": "Which dogs have not cost their owner more than 1000 for treatment ? List the dog names .",
        "ground_truth": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )",
        "amends": [
            "Do use a subquery with `NOT IN` instead of a simple `WHERE` filter. Do add a correlated subquery that selects `dog_id` from the `treatments` table instead of omitting it. Do use `GROUP BY dog_id` and `HAVING sum(cost_of_treatment) > 1000` instead of filtering directly on `treatment_cost`. Do remove the direct column reference `treatment_cost` from the main query instead of keeping it, as the cost calculation now happens in the subquery. The amended query now correctly identifies dogs whose total treatment costs do not exceed 1000 by aggregating costs per dog in the treatments table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks about dogs that have not cost more than a specific amount for treatment: use a subquery with NOT IN instead of a simple WHERE filter to identify dogs whose total treatment costs exceed the threshold.",
            "When calculating total treatment costs per dog: use GROUP BY dog_id and HAVING sum(cost_of_treatment) > 1000 in the subquery instead of filtering directly on individual treatment costs.",
            "When referencing the treatments table: select dog_id from the treatments table in the correlated subquery to properly aggregate costs by dog.",
            "When producing the final result: remove direct column references to treatment_cost from the main query since cost calculation now happens in the subquery.",
            "When the question asks about dogs that have not cost more than a specific amount for treatment, When calculating total treatment costs per dog, When referencing the treatments table, When producing the final result, When identifying dogs by their canonical key: use dog_id as the counting and grouping key for aggregating treatment costs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM dogs WHERE treatment_cost <= 1000;",
            "SELECT name FROM Dogs WHERE dog_id NOT IN (SELECT dog_id FROM Treatments GROUP BY dog_id HAVING SUM(cost_of_treatment) > 1000)"
        ],
        "rule_sql": [
            "SELECT name \nFROM Dogs \nWHERE dog_id NOT IN (\n    SELECT dog_id \n    FROM Treatments \n    GROUP BY dog_id \n    HAVING SUM(cost_of_treatment) > 1000\n)"
        ]
    },
    "925": {
        "db_id": "dog_kennels",
        "question": "What are the names of the dogs for which the owner has not spend more than 1000 for treatment ?",
        "ground_truth": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )",
        "amends": [
            "Do use a subquery with `NOT IN` instead of multiple joins. Do filter by `dog_id` instead of `id` in the subquery. Do aggregate with `SUM(cost_of_treatment)` instead of filtering individual `cost` values. Do remove the joins with `owners` and `treatments` tables instead of including them. Do reference `cost_of_treatment` instead of `cost` in the aggregation. The amended query now correctly identifies dogs whose total treatment costs do not exceed 1000, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for dogs whose owners have not spent more than 1000 for treatment: use a subquery with NOT IN instead of multiple joins to filter dogs.",
            "When filtering by treatment costs: aggregate using SUM(\"cost_of_treatment\") instead of filtering individual cost values.",
            "When referencing treatment costs: use the exact column name \"cost_of_treatment\" instead of \"cost\".",
            "When identifying dogs in the subquery: filter by \"dog_id\" instead of \"id\".",
            "When the question asks for dogs whose owners have not spent more than 1000 for treatment, When filtering by treatment costs, When referencing treatment costs, When identifying dogs in the subquery, When combining treatment data: remove joins with \"owners\" and \"treatments\" tables and instead use a subquery approach."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.name \nFROM dogs d \nJOIN owners o ON d.owner_id = o.id \nJOIN treatments t ON d.id = t.dog_id \nWHERE t.cost > 1000;",
            "SELECT name FROM Dogs WHERE dog_id NOT IN (SELECT dog_id FROM Treatments GROUP BY dog_id HAVING SUM(cost_of_treatment) > 1000)"
        ],
        "rule_sql": [
            "SELECT name \nFROM Dogs \nWHERE dog_id NOT IN (\n    SELECT dog_id \n    FROM Treatments \n    GROUP BY dog_id \n    HAVING SUM(cost_of_treatment) > 1000\n)"
        ]
    },
    "926": {
        "db_id": "dog_kennels",
        "question": "Which first names are used for professionals or owners but are not used as dog names?",
        "ground_truth": "SELECT first_name FROM Professionals UNION SELECT first_name FROM Owners EXCEPT SELECT name FROM Dogs",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT first_name \nFROM professionals \nWHERE first_name NOT IN (SELECT name FROM dogs)\nUNION\nSELECT DISTINCT first_name \nFROM owners \nWHERE first_name NOT IN (SELECT name FROM dogs);"
        ],
        "rule_sql": [
            "SELECT DISTINCT first_name \nFROM (\n    SELECT first_name FROM Professionals\n    UNION \n    SELECT first_name FROM Owners\n) \nWHERE first_name NOT IN (SELECT name FROM Dogs WHERE name IS NOT NULL)"
        ]
    },
    "927": {
        "db_id": "dog_kennels",
        "question": "Find the first names that are used for professionals or owners but are not used as dog names.",
        "ground_truth": "SELECT first_name FROM Professionals UNION SELECT first_name FROM Owners EXCEPT SELECT name FROM Dogs",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT first_name \nFROM professionals \nWHERE first_name NOT IN (SELECT name FROM dogs)\nUNION\nSELECT DISTINCT first_name \nFROM owners \nWHERE first_name NOT IN (SELECT name FROM dogs);"
        ],
        "rule_sql": [
            "SELECT DISTINCT first_name \nFROM (\n    SELECT first_name FROM Professionals\n    UNION \n    SELECT first_name FROM Owners\n)\nWHERE first_name NOT IN (SELECT name FROM Dogs WHERE name IS NOT NULL)"
        ]
    },
    "928": {
        "db_id": "dog_kennels",
        "question": "Which professional did not operate any treatment on dogs? List the professional's id, role and email.",
        "ground_truth": "SELECT professional_id ,  role_code ,  email_address FROM Professionals EXCEPT SELECT T1.professional_id ,  T1.role_code ,  T1.email_address FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id",
        "amends": [
            "Do use `EXCEPT` set operation instead of a `LEFT JOIN` with `IS NULL` filter. Do select `professional_id`, `role_code`, and `email_address` instead of `id`, `role`, and `email`. Do reference the `Professionals` table with proper casing instead of lowercase. Do join `Treatments` with an `INNER JOIN` on `professional_id` instead of a filtered `LEFT JOIN`. Do remove the `animal_type = 'Dog'` filter condition instead of including it. Do use table aliases `T1` and `T2` instead of single letters. The amended query now correctly identifies professionals who have never performed any treatments by using set difference rather than null checking, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about professionals who did not operate any treatment on dogs: use EXCEPT set operation instead of LEFT JOIN with IS NULL filter.",
            "When selecting professional information: select \"professional_id\", \"role_code\", and \"email_address\" instead of \"id\", \"role\", and \"email\".",
            "When referencing the Professionals table: use proper casing \"Professionals\" instead of lowercase.",
            "When combining Professionals and Treatments tables: use INNER JOIN on \"professional_id\" instead of filtered LEFT JOIN.",
            "When filtering for treatments on dogs: remove the \"animal_type = 'Dog'\" filter condition instead of including it.",
            "When answering about professionals who did not operate any treatment on dogs, When selecting professional information, When referencing the Professionals table, When combining Professionals and Treatments tables, When filtering for treatments on dogs, When using table aliases: use \"T1\" for Professionals and \"T2\" for Treatments instead of single letters."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.id, p.role, p.email \nFROM professionals p\nLEFT JOIN treatments t ON p.id = t.professional_id AND t.animal_type = 'Dog'\nWHERE t.professional_id IS NULL;",
            "SELECT professional_id, role_code, email_address FROM Professionals\nEXCEPT\nSELECT T1.professional_id, T1.role_code, T1.email_address \nFROM Professionals T1\nINNER JOIN Treatments T2 ON T1.professional_id = T2.professional_id"
        ],
        "rule_sql": [
            "SELECT professional_id, role_code, email_address FROM Professionals\nEXCEPT\nSELECT T1.professional_id, T1.role_code, T1.email_address\nFROM Professionals T1\nINNER JOIN Treatments T2 ON T1.professional_id = T2.professional_id"
        ]
    },
    "929": {
        "db_id": "dog_kennels",
        "question": "Give me the id, role and email of the professionals who did not perform any treatment on dogs.",
        "ground_truth": "SELECT professional_id ,  role_code ,  email_address FROM Professionals EXCEPT SELECT T1.professional_id ,  T1.role_code ,  T1.email_address FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id",
        "amends": [
            "Do select `professional_id`, `role_code`, and `email_address` instead of `id`, `role`, and `email`. Do use `EXCEPT` set operation instead of `NOT IN` subquery. Do reference table as `Professionals` instead of `professionals`. Do join `Professionals AS T1` with `Treatments AS T2` on `T1.professional_id = T2.professional_id` instead of using a subquery with `professional_id` and `animal_type` filter. Do remove the `WHERE animal_type = 'dog'` condition instead of keeping it. The amended query now correctly excludes professionals who have any treatments rather than just those with dog treatments, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When selecting professional information: use \"professional_id\", \"role_code\", and \"email_address\" as output columns instead of \"id\", \"role\", and \"email\".",
            "When referencing the professionals table: use \"Professionals\" (with exact case) instead of \"professionals\".",
            "When finding professionals without any treatments: use EXCEPT set operation instead of NOT IN subquery.",
            "When combining Professionals and Treatments tables: join \"Professionals AS T1\" with \"Treatments AS T2\" on \"T1.professional_id = T2.professional_id\" for inner matching.",
            "When selecting professional information, When referencing the professionals table, When finding professionals without any treatments, When combining Professionals and Treatments tables, When excluding professionals with treatments: remove any animal_type filter condition since the question asks about professionals who did not perform any treatment, not just dog treatments."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, role, email FROM professionals WHERE id NOT IN (SELECT professional_id FROM treatments WHERE animal_type = 'dog')",
            "SELECT professional_id, role_code, email_address FROM Professionals\nEXCEPT\nSELECT T1.professional_id, T1.role_code, T1.email_address\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id"
        ],
        "rule_sql": [
            "SELECT professional_id, role_code, email_address\nFROM Professionals\nEXCEPT\nSELECT T1.professional_id, T1.role_code, T1.email_address\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id"
        ]
    },
    "930": {
        "db_id": "dog_kennels",
        "question": "Which owner owns the most dogs? List the owner id, first name and last name.",
        "ground_truth": "SELECT T1.owner_id ,  T2.first_name ,  T2.last_name FROM Dogs AS T1 JOIN Owners AS T2 ON T1.owner_id  =  T2.owner_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `Dogs AS T1` to `Owners AS T2` on `T1.owner_id = T2.owner_id` instead of selecting from only `owners` table. Do select `T1.owner_id`, `T2.first_name`, and `T2.last_name` instead of including `COUNT(dog_id) as dog_count` in the SELECT list. Do use `count(*)` in the ORDER BY clause instead of ordering by the aliased `dog_count`. Do remove the explicit aggregation column from GROUP BY and instead group by `T1.owner_id` only. The amended query now correctly joins the Dogs and Owners tables to find the owner with the most dogs while properly handling the relationship between these tables."
        ],
        "rules": [
            "When answering about \"which owner owns the most dogs\": make sure the output order: owner_id, first_name, last_name.",
            "When combining Dogs and Owners tables: link rows where T1.owner_id = T2.owner_id and keep only matching pairs (inner match).",
            "When counting dogs per owner: compute the number of rows using the canonical key T1.owner_id for grouping.",
            "When the question asks for \"most dogs\": rank owners by dog count in descending order and keep the first 1 row.",
            "When answering about \"which owner owns the most dogs\", When combining Dogs and Owners tables, When counting dogs per owner, When the question asks for \"most dogs\", When selecting owner information: use T1.owner_id from Dogs table and T2.first_name, T2.last_name from Owners table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT owner_id, first_name, last_name, COUNT(dog_id) as dog_count FROM owners GROUP BY owner_id ORDER BY dog_count DESC LIMIT 1;",
            "SELECT T2.owner_id, T2.first_name, T2.last_name\nFROM Dogs AS T1\nJOIN Owners AS T2 ON T1.owner_id = T2.owner_id\nGROUP BY T1.owner_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT d.owner_id, o.first_name, o.last_name\nFROM Dogs d\nINNER JOIN Owners o ON d.owner_id = o.owner_id\nGROUP BY d.owner_id, o.first_name, o.last_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "931": {
        "db_id": "dog_kennels",
        "question": "Return the owner id, first name and last name of the owner who has the most dogs.",
        "ground_truth": "SELECT T1.owner_id ,  T2.first_name ,  T2.last_name FROM Dogs AS T1 JOIN Owners AS T2 ON T1.owner_id  =  T2.owner_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `Dogs` and `Owners` tables with a `JOIN` on `T1.owner_id = T2.owner_id` instead of querying only the `owners` table. Do change the SELECT list to reference `T1.owner_id`, `T2.first_name`, and `T2.last_name` instead of `owner_id`, `first_name`, and `last_name` without table qualification. Do add `GROUP BY T1.owner_id` instead of omitting grouping. Do change the ORDER BY to use `count(*)` instead of `COUNT(dogs.owner_id)` without proper grouping. The amended query now correctly counts dogs per owner and returns the owner with the most dogs, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"owner who has the most dogs\": make sure the output order: T1.owner_id, T2.first_name, T2.last_name.",
            "When the question mentions \"owner\": \"owner\" actually means \"T1.owner_id in schema\" and owner details come from T2.first_name and T2.last_name.",
            "When combining Dogs and Owners tables: link rows where T1.owner_id = T2.owner_id and keep only matching pairs (inner match).",
            "When the question asks for \"count of dogs per owner\": compute the number of rows using T1.owner_id as the grouping key and count(*) as the aggregate.",
            "When answering about \"owner who has the most dogs\", When the question mentions \"owner\", When combining Dogs and Owners tables, When the question asks for \"count of dogs per owner\", When the question asks for \"most dogs\": rank owners by count(*) in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT owner_id, first_name, last_name FROM owners ORDER BY COUNT(dogs.owner_id) DESC LIMIT 1;",
            "SELECT T1.owner_id, T2.first_name, T2.last_name\nFROM Dogs T1\nJOIN Owners T2 ON T1.owner_id = T2.owner_id\nGROUP BY T1.owner_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.owner_id, T2.first_name, T2.last_name\nFROM Dogs T1\nINNER JOIN Owners T2 ON T1.owner_id = T2.owner_id\nGROUP BY T1.owner_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "932": {
        "db_id": "dog_kennels",
        "question": "Which professionals have done at least two treatments? List the professional's id, role, and first name.",
        "ground_truth": "SELECT T1.professional_id ,  T1.role_code ,  T1.first_name FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2",
        "amends": [
            "Do add `Treatments AS T2` table with `JOIN` instead of querying only `professionals` table. Do use `T1.professional_id = T2.professional_id` join condition instead of no join. Do change `role` to `role_code` instead of using incorrect column name. Do add `GROUP BY T1.professional_id` instead of omitting grouping. Do change `WHERE COUNT(treatment_id) = 1` to `HAVING count(*) >= 2` instead of using aggregate in WHERE clause with wrong condition. Do use table aliases `T1` and `T2` instead of no aliases. The amended query now correctly finds professionals with at least two treatments by properly joining tables and using HAVING clause for aggregate filtering."
        ],
        "rules": [
            "When answering about professionals who have done treatments: combine Professionals table (as T1) and Treatments table (as T2) using T1.professional_id = T2.professional_id instead of querying only one table.",
            "When the question mentions \"role\": \"role\" actually means \"role_code\" in schema.",
            "When the question asks for professionals with at least two treatments: group results by T1.professional_id and filter groups having count(*) >= 2 instead of using aggregate conditions in WHERE clause.",
            "When using table aliases: use T1 for Professionals table and T2 for Treatments table consistently.",
            "When answering about professionals who have done treatments, When the question mentions \"role\", When the question asks for professionals with at least two treatments, When using table aliases, When counting treatments per professional: count all rows in the Treatments table (T2) that match each professional using count(*) instead of counting a specific column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT professional_id, role, first_name \nFROM professionals \nWHERE COUNT(treatment_id) = 1;",
            "SELECT T1.professional_id, T1.role_code, T1.first_name\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T1.professional_id, T1.role_code, T1.first_name\nFROM Professionals T1\nJOIN Treatments T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id, T1.role_code, T1.first_name\nHAVING COUNT(*) >= 2;"
        ]
    },
    "933": {
        "db_id": "dog_kennels",
        "question": "What are the id, role, and first name of the professionals who have performed two or more treatments?",
        "ground_truth": "SELECT T1.professional_id ,  T1.role_code ,  T1.first_name FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2",
        "amends": [
            "Do select `T1.professional_id`, `T1.role_code`, and `T1.first_name` instead of `id`, `role`, and `first_name` without table qualification. Do join `Treatments AS T2` on `T1.professional_id = T2.professional_id` instead of querying only the `professionals` table. Do use `GROUP BY T1.professional_id` with `HAVING count(*) >= 2` instead of filtering `WHERE treatment_count = 2` which incorrectly assumes a direct column rather than counting related treatment records. The amended query now correctly counts treatment associations per professional and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When selecting columns from the Professionals table: use \"T1.professional_id\", \"T1.role_code\", and \"T1.first_name\" instead of unqualified column names.",
            "When counting treatments performed by professionals: join the Treatments table as T2 on \"T1.professional_id = T2.professional_id\" to access treatment records.",
            "When determining professionals with two or more treatments: group by \"T1.professional_id\" and use having count(*) >= 2 instead of filtering on a non-existent treatment_count column.",
            "When selecting columns from the Professionals table, When counting treatments performed by professionals, When determining professionals with two or more treatments, When combining Professionals and Treatments tables: perform an inner match where \"T1.professional_id = T2.professional_id\" to link professionals with their treatments."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, role, first_name \nFROM professionals \nWHERE treatment_count = 2;",
            "SELECT T1.professional_id, T1.role_code, T1.first_name\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T1.professional_id, T1.role_code, T1.first_name\nFROM Professionals T1\nINNER JOIN Treatments T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) >= 2"
        ]
    },
    "934": {
        "db_id": "dog_kennels",
        "question": "What is the name of the breed with the most dogs?",
        "ground_truth": "SELECT T1.breed_name FROM Breeds AS T1 JOIN Dogs AS T2 ON T1.breed_code  =  T2.breed_code GROUP BY T1.breed_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add a `JOIN` between `Breeds AS T1` and `Dogs AS T2` on `T1.breed_code = T2.breed_code` instead of querying only the `dogs` table. Do specify the table alias `T1.breed_name` in the SELECT clause instead of just `breed_name`. Do include the proper join condition `T1.breed_code = T2.breed_code` instead of missing the relationship between breeds and dogs tables. The amended query now correctly joins the breeds and dogs tables to count dogs by breed and returns the breed with the highest count, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"breed with the most dogs\": make sure to join Breeds as T1 and Dogs as T2 using the exact join condition T1.breed_code = T2.breed_code to establish the relationship between breeds and dogs.",
            "When counting dogs per breed: count using the canonical key from the Dogs table (T2.breed_code) to determine the number of dogs for each breed.",
            "When selecting the breed name: use the exact identifier T1.breed_name from the Breeds table instead of just breed_name.",
            "When answering about \"breed with the most dogs\", When counting dogs per breed, When selecting the breed name, When finding the breed with the highest count: rank rows by the count of dogs in descending order and keep only the first row (top result)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT breed_name FROM dogs GROUP BY breed_name ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T1.breed_name\nFROM Breeds AS T1\nJOIN Dogs AS T2 ON T1.breed_code = T2.breed_code\nGROUP BY T1.breed_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.breed_name\nFROM Breeds AS T1\nJOIN Dogs AS T2 ON T1.breed_code = T2.breed_code\nGROUP BY T1.breed_code, T1.breed_name\nORDER BY COUNT(T2.breed_code) DESC\nLIMIT 1;"
        ]
    },
    "935": {
        "db_id": "dog_kennels",
        "question": "Which breed do the most dogs have? Give me the breed name.",
        "ground_truth": "SELECT T1.breed_name FROM Breeds AS T1 JOIN Dogs AS T2 ON T1.breed_code  =  T2.breed_code GROUP BY T1.breed_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `Breeds AS T1` and `Dogs AS T2` on `T1.breed_code = T2.breed_code` instead of querying only the `dogs` table. Do select `T1.breed_name` instead of `breed` and maintain the same aggregate count logic. Do group by `T1.breed_name` instead of `breed` to properly reference the joined table column. Do keep the `ORDER BY count(*) DESC LIMIT 1` unchanged as it correctly identifies the breed with the highest count. The amended query now properly joins the breed reference table to resolve breed names from codes and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"which breed do the most dogs have\": make sure the output order: T1.breed_name.",
            "When the question mentions \"breed\": \"breed\" actually means \"T1.breed_name in schema\".",
            "When combining T1 and T2 for shared entities: link rows where T1.breed_code = T2.breed_code exactly as shown in the amends; keep only matching pairs (inner match).",
            "When the question asks for \"count of dogs\": compute the number of rows using the canonical key token for dogs (e.g., T2.breed_code).",
            "When answering about \"which breed do the most dogs have\", When the question mentions \"breed\", When combining T1 and T2 for shared entities, When the question asks for \"count of dogs\", When the question mentions \"most\" or \"highest\": rank rows by count of dogs in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT breed, COUNT(*) as count FROM dogs GROUP BY breed ORDER BY count DESC LIMIT 1;",
            "SELECT T1.breed_name\nFROM Breeds AS T1\nJOIN Dogs AS T2 ON T1.breed_code = T2.breed_code\nGROUP BY T1.breed_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT b.breed_name\nFROM Breeds b\nJOIN Dogs d ON b.breed_code = d.breed_code\nGROUP BY b.breed_name\nORDER BY COUNT(d.dog_id) DESC\nLIMIT 1;"
        ]
    },
    "936": {
        "db_id": "dog_kennels",
        "question": "Which owner has paid for the most treatments on his or her dogs? List the owner id and last name.",
        "ground_truth": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do remove `o.last_name` from the SELECT list and GROUP BY clause instead of including it, as the owner_id alone uniquely identifies each group. Do use `count(*)` in the ORDER BY instead of referencing the alias `treatment_count` since that alias is not available at the ORDER BY level. Do reference tables with aliases `T1`, `T2`, and `T3` instead of `o`, `d`, and `t` for consistency, though this is primarily cosmetic. The amended query now correctly identifies the owner with the most treatments by counting all treatment records per owner without relying on an unavailable column alias."
        ],
        "rules": [
            "When counting treatments per owner: use count(*) to count all treatment records for each owner group.",
            "When grouping by owner: group only by T1.owner_id since it uniquely identifies each owner and T1.last_name is not needed for grouping.",
            "When ordering results by treatment count: use count(*) directly in the ORDER BY clause instead of referencing an alias that is not available at that level.",
            "When counting treatments per owner, When grouping by owner, When ordering results by treatment count, When combining tables T1 (owners), T2 (dogs), and T3 (treatments): link T1 to T2 using T1.owner_id = T2.owner_id and T2 to T3 using T2.dog_id = T3.dog_id to find treatments for each owner's dogs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT o.owner_id, o.last_name, COUNT(t.treatment_id) as treatment_count\nFROM owners o\nJOIN dogs d ON o.owner_id = d.owner_id\nJOIN treatments t ON d.dog_id = t.dog_id\nGROUP BY o.owner_id, o.last_name\nORDER BY treatment_count DESC\nLIMIT 1;",
            "SELECT T1.owner_id, T1.last_name\nFROM Owners T1\nJOIN Dogs T2 ON T1.owner_id = T2.owner_id\nJOIN Treatments T3 ON T2.dog_id = T3.dog_id\nGROUP BY T1.owner_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.owner_id, T1.last_name\nFROM Owners T1\nJOIN Dogs T2 ON T1.owner_id = T2.owner_id\nJOIN Treatments T3 ON T2.dog_id = T3.dog_id\nGROUP BY T1.owner_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "937": {
        "db_id": "dog_kennels",
        "question": "Tell me the owner id and last name of the owner who spent the most on treatments of his or her dogs.",
        "ground_truth": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use explicit table aliases `T1`, `T2`, and `T3` instead of unaliased table names. Do change the subquery approach to explicit `JOIN` operations with `Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id = T2.owner_id JOIN Treatments AS T3 ON T2.dog_id = T3.dog_id` instead of a subquery with implicit joins. Do add `GROUP BY T1.owner_id` at the main query level instead of grouping within a subquery. Do change the ordering criterion to `ORDER BY count(*) DESC` instead of `ORDER BY SUM(cost) DESC`. Do remove the `WHERE owner_id IN` subquery filter and instead use the join structure to naturally filter the results. The amended query now correctly identifies owners based on treatment count rather than treatment cost sum, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"owner who spent the most on treatments\": use explicit table aliases T1 for Owners, T2 for Dogs, and T3 for Treatments instead of unaliased table names.",
            "When combining tables for shared entities: link rows where T1.owner_id = T2.owner_id and T2.dog_id = T3.dog_id; keep only matching pairs (inner match).",
            "When the question asks for \"the most\" by treatment spending: group results by T1.owner_id and compute the count of treatments using T3 records.",
            "When ranking for \"the most\": order rows by count(*) in descending direction and keep only the first row.",
            "When answering about \"owner who spent the most on treatments\", When combining tables for shared entities, When the question asks for \"the most\" by treatment spending, When ranking for \"the most\", When producing output: include T1.owner_id and T1.last_name in the result columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT owner_id, last_name \nFROM owners \nWHERE owner_id IN (\n    SELECT owner_id \n    FROM dogs \n    JOIN treatments ON dogs.dog_id = treatments.dog_id \n    GROUP BY owner_id \n    ORDER BY SUM(cost) DESC \n    LIMIT 1\n)",
            "SELECT T1.owner_id, T1.last_name\nFROM Owners AS T1\nJOIN Dogs AS T2 ON T1.owner_id = T2.owner_id\nJOIN Treatments AS T3 ON T2.dog_id = T3.dog_id\nGROUP BY T1.owner_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.owner_id, T1.last_name\nFROM Owners T1\nINNER JOIN Dogs T2 ON T1.owner_id = T2.owner_id\nINNER JOIN Treatments T3 ON T2.dog_id = T3.dog_id\nGROUP BY T1.owner_id, T1.last_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "938": {
        "db_id": "dog_kennels",
        "question": "What is the description of the treatment type that costs the least money in total?",
        "ground_truth": "SELECT T1.treatment_type_description FROM Treatment_types AS T1 JOIN Treatments AS T2 ON T1.treatment_type_code  =  T2.treatment_type_code GROUP BY T1.treatment_type_code ORDER BY sum(cost_of_treatment) ASC LIMIT 1",
        "amends": [
            "Do select `T1.treatment_type_description` instead of `description` and add a `JOIN` with `Treatments AS T2` on `T1.treatment_type_code = T2.treatment_type_code` instead of querying only `treatment_types`. Do add `GROUP BY T1.treatment_type_code` instead of omitting grouping and change the ordering to `sum(cost_of_treatment) ASC` instead of `cost ASC`. The amended query now correctly finds the treatment type with the lowest total cost across all treatments rather than just the single cheapest treatment type instance, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"treatment type that costs the least money in total\": make sure the output order: T1.treatment_type_description.",
            "When combining T1 (treatment_types) and T2 (Treatments) for shared entities: link rows where T1.treatment_type_code = T2.treatment_type_code; keep only matching pairs (inner match).",
            "When the question asks for total cost by treatment type: organize results by T1.treatment_type_code and compute sum(cost_of_treatment) per group.",
            "When answering about \"treatment type that costs the least money in total\", When combining T1 (treatment_types) and T2 (Treatments) for shared entities, When the question asks for total cost by treatment type, When finding the treatment type with lowest total cost: rank rows by sum(cost_of_treatment) in ascending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description FROM treatment_types ORDER BY cost ASC LIMIT 1;",
            "SELECT T1.treatment_type_description \nFROM Treatment_Types AS T1\nJOIN Treatments AS T2 ON T1.treatment_type_code = T2.treatment_type_code\nGROUP BY T1.treatment_type_code\nORDER BY SUM(T2.cost_of_treatment) ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.treatment_type_description\nFROM Treatment_Types T1\nINNER JOIN Treatments T2 ON T1.treatment_type_code = T2.treatment_type_code\nGROUP BY T1.treatment_type_code, T1.treatment_type_description\nORDER BY SUM(T2.cost_of_treatment) ASC\nLIMIT 1;"
        ]
    },
    "939": {
        "db_id": "dog_kennels",
        "question": "Give me the description of the treatment type whose total cost is the lowest.",
        "ground_truth": "SELECT T1.treatment_type_description FROM Treatment_types AS T1 JOIN Treatments AS T2 ON T1.treatment_type_code  =  T2.treatment_type_code GROUP BY T1.treatment_type_code ORDER BY sum(cost_of_treatment) ASC LIMIT 1",
        "amends": [
            "Do select `T1.treatment_type_description` instead of `description` and add a `JOIN` with `Treatments AS T2` on `T1.treatment_type_code = T2.treatment_type_code` instead of querying only `treatment_types`. Do add `GROUP BY T1.treatment_type_code` instead of omitting grouping and use `sum(cost_of_treatment)` for ordering instead of `total_cost`. Do order by `sum(cost_of_treatment) ASC` instead of `total_cost ASC` while keeping the `LIMIT 1`. The amended query now correctly calculates the total treatment cost per type before selecting the cheapest one, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"treatment type whose total cost is the lowest\": make sure the output order: T1.treatment_type_description.",
            "When the question mentions \"description\": \"description\" actually means \"T1.treatment_type_description\" in schema.",
            "When combining T1 and T2 for shared entities: link rows where T1.treatment_type_code = T2.treatment_type_code; keep only matching pairs (inner match).",
            "When the question says \"per treatment type\"/\"by treatment type\": organize results by T1.treatment_type_code and compute requested aggregates per group.",
            "When the question asks for \"total cost\": compute sum(cost_of_treatment) instead of total_cost.",
            "When answering about \"treatment type whose total cost is the lowest\", When the question mentions \"description\", When combining T1 and T2 for shared entities, When the question says \"per treatment type\"/\"by treatment type\", When the question asks for \"total cost\", When the question asks for \"lowest\" total cost: rank rows by sum(cost_of_treatment) in ascending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description FROM treatment_types ORDER BY total_cost ASC LIMIT 1;",
            "SELECT T1.treatment_type_description\nFROM Treatment_Types AS T1\nJOIN Treatments AS T2 ON T1.treatment_type_code = T2.treatment_type_code\nGROUP BY T1.treatment_type_code\nORDER BY SUM(T2.cost_of_treatment) ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.treatment_type_description\nFROM Treatment_Types T1\nINNER JOIN Treatments T2 ON T1.treatment_type_code = T2.treatment_type_code\nGROUP BY T1.treatment_type_code, T1.treatment_type_description\nORDER BY SUM(T2.cost_of_treatment) ASC\nLIMIT 1;"
        ]
    },
    "940": {
        "db_id": "dog_kennels",
        "question": "Which owner has paid the largest amount of money in total for their dogs? Show the owner id and zip code.",
        "ground_truth": "SELECT T1.owner_id ,  T1.zip_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY sum(T3.cost_of_treatment) DESC LIMIT 1",
        "amends": [
            "Do change the SELECT list to `T1.owner_id, T1.zip_code` instead of `owner_id, zip_code, SUM(amount) as total_paid`. Do change the FROM clause to join `Owners AS T1` with `Dogs AS T2` on `T1.owner_id = T2.owner_id` and then join `Treatments AS T3` on `T2.dog_id = T3.dog_id` instead of using a single `payments` table. Do remove the `zip_code` from GROUP BY and use only `T1.owner_id` instead of grouping by both `owner_id, zip_code`. Do change the ORDER BY to `sum(T3.cost_of_treatment) DESC` instead of `total_paid ASC`. Do remove the alias `total_paid` and reference the aggregate function directly in ORDER BY. The amended query now correctly identifies the owner with the highest total treatment costs across their dogs instead of summarizing payments by zip code."
        ],
        "rules": [
            "When answering about \"owner has paid the largest amount of money in total for their dogs\": make sure the output order: T1.owner_id, T1.zip_code",
            "When combining Owners as T1 and Dogs as T2 for shared entities: link rows where T1.owner_id = T2.owner_id and keep only matching pairs (inner match)",
            "When combining Dogs as T2 and Treatments as T3 for shared entities: link rows where T2.dog_id = T3.dog_id and keep only matching pairs (inner match)",
            "When the question asks for \"total amount paid for dogs\": compute the sum of T3.cost_of_treatment per owner",
            "When the question mentions \"largest amount\": rank owners by sum(T3.cost_of_treatment) in descending order and keep the first 1 row",
            "When grouping by owner: organize results by T1.owner_id only, not by zip_code",
            "When answering about \"owner has paid the largest amount of money in total for their dogs\", When combining Owners as T1 and Dogs as T2 for shared entities, When combining Dogs as T2 and Treatments as T3 for shared entities, When the question asks for \"total amount paid for dogs\", When the question mentions \"largest amount\", When grouping by owner, When producing output: include T1.owner_id and T1.zip_code in the results"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT owner_id, zip_code, SUM(amount) as total_paid\nFROM payments\nGROUP BY owner_id, zip_code\nORDER BY total_paid ASC\nLIMIT 1;",
            "SELECT T1.owner_id, T1.zip_code\nFROM Owners AS T1\nJOIN Dogs AS T2 ON T1.owner_id = T2.owner_id\nJOIN Treatments AS T3 ON T2.dog_id = T3.dog_id\nGROUP BY T1.owner_id\nORDER BY SUM(T3.cost_of_treatment) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.owner_id, T1.zip_code\nFROM Owners AS T1\nINNER JOIN Dogs AS T2 ON T1.owner_id = T2.owner_id\nINNER JOIN Treatments AS T3 ON T2.dog_id = T3.dog_id\nGROUP BY T1.owner_id\nORDER BY SUM(T3.cost_of_treatment) DESC\nLIMIT 1;"
        ]
    },
    "941": {
        "db_id": "dog_kennels",
        "question": "Find the owner id and zip code of the owner who spent the most money in total for his or her dogs.",
        "ground_truth": "SELECT T1.owner_id ,  T1.zip_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY sum(T3.cost_of_treatment) DESC LIMIT 1",
        "amends": [
            "Do select only `owner_id` and `zip_code` instead of including `SUM(amount)` and aliasing it as `total_spent`. Do join `Treatments` table as `T3` instead of `purchases` table. Do use `T2.dog_id = T3.dog_id` join condition instead of `d.dog_id = p.dog_id`. Do group by only `owner_id` instead of both `owner_id` and `zip_code`. Do order by `sum(T3.cost_of_treatment)` in descending order instead of `total_spent` in ascending order. The amended query now correctly calculates the highest treatment cost per owner rather than purchase amounts, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"owner who spent the most money in total for his or her dogs\": make sure the output order: owner_id, zip_code.",
            "When the question mentions \"spent the most money\": this actually means sum of \"cost_of_treatment\" in the Treatments table.",
            "When combining Owners (T1), Dogs (T2), and Treatments (T3) tables: link rows where T1.owner_id = T2.owner_id and T2.dog_id = T3.dog_id using exact key equality; keep only matching pairs (inner match).",
            "When grouping by owner: organize results by owner_id only, not by both owner_id and zip_code.",
            "When ranking for \"the most money\": rank rows by sum(T3.cost_of_treatment) in descending order and keep only the first 1 row.",
            "When answering about \"owner who spent the most money in total for his or her dogs\", When the question mentions \"spent the most money\", When combining Owners (T1), Dogs (T2), and Treatments (T3) tables, When grouping by owner, When ranking for \"the most money\", When producing output: select only owner_id and zip_code columns, do not include the sum amount in the final output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT owner_id, zip_code, SUM(amount) as total_spent\nFROM owners o\nJOIN dogs d ON o.owner_id = d.owner_id\nJOIN purchases p ON d.dog_id = p.dog_id\nGROUP BY owner_id, zip_code\nORDER BY total_spent ASC\nLIMIT 1;",
            "SELECT o.owner_id, o.zip_code\nFROM Owners o\nJOIN Dogs d ON o.owner_id = d.owner_id\nJOIN Treatments T3 ON d.dog_id = T3.dog_id\nGROUP BY o.owner_id\nORDER BY SUM(T3.cost_of_treatment) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT o.owner_id, o.zip_code\nFROM Owners o\nJOIN Dogs d ON o.owner_id = d.owner_id\nJOIN Treatments t ON d.dog_id = t.dog_id\nGROUP BY o.owner_id\nORDER BY SUM(t.cost_of_treatment) DESC\nLIMIT 1;"
        ]
    },
    "942": {
        "db_id": "dog_kennels",
        "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.",
        "ground_truth": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2",
        "amends": [
            "Do join `Treatments AS T2` instead of querying only the `professionals` table. Do use `T1.professional_id = T2.professional_id` as the join condition instead of missing the join entirely. Do select `T1.cell_number` instead of `cell_phone` and qualify columns with table aliases. Do add `GROUP BY T1.professional_id` instead of omitting grouping. Do move the count filter to `HAVING count(*) >= 2` instead of using `WHERE COUNT(DISTINCT treatment_type) >= 2` which cannot reference aggregates in the WHERE clause. Do count all rows with `count(*)` instead of counting distinct `treatment_type` values. The amended query now correctly identifies professionals with at least two treatments by properly using aggregation with HAVING instead of the invalid WHERE clause with aggregate function."
        ],
        "rules": [
            "When answering about professionals and their treatments: combine data from the professionals table (as T1) and Treatments table (as T2) using the join condition T1.professional_id = T2.professional_id to link professionals to their treatments.",
            "When counting treatments per professional: group results by T1.professional_id and count all treatment rows using count(*) instead of counting distinct treatment types.",
            "When filtering for professionals with multiple treatments: use HAVING count(*) >= 2 instead of WHERE with aggregate functions.",
            "When selecting professional contact information: use T1.cell_number instead of cell_phone for the phone number field.",
            "When answering about professionals and their treatments, When counting treatments per professional, When filtering for professionals with multiple treatments, When selecting professional contact information, When qualifying columns: always use table aliases (T1 or T2) to specify which table each column comes from."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT professional_id, cell_phone \nFROM professionals \nWHERE COUNT(DISTINCT treatment_type) >= 2;",
            "SELECT T1.professional_id, T1.cell_number\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T1.professional_id, T1.cell_number\nFROM Professionals T1\nJOIN Treatments T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) >= 2"
        ]
    },
    "943": {
        "db_id": "dog_kennels",
        "question": "Find the id and cell phone of the professionals who operate two or more types of treatments.",
        "ground_truth": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2",
        "amends": [
            "Do select `T1.professional_id` and `T1.cell_number` instead of `id` and `cell_phone`. Do join `Treatments AS T2` on `T1.professional_id = T2.professional_id` instead of querying only the `professionals` table. Do use `GROUP BY T1.professional_id` with `HAVING count(*) >= 2` instead of `WHERE COUNT(DISTINCT treatment_type) >= 2` to properly aggregate and filter professionals with multiple treatments. The amended query now correctly identifies professionals who have provided at least two treatments by joining the relevant tables and using appropriate aggregation."
        ],
        "rules": [
            "When selecting professional identifiers and contact information: use \"T1.professional_id\" and \"T1.cell_number\" instead of \"id\" and \"cell_phone\".",
            "When finding professionals who operate multiple treatment types: join \"Treatments AS T2\" with \"T1\" where \"T1.professional_id = T2.professional_id\" to access treatment records.",
            "When counting treatment types per professional: group by \"T1.professional_id\" and use \"count(*) >= 2\" to filter for professionals with at least two treatments.",
            "When selecting professional identifiers and contact information, When finding professionals who operate multiple treatment types, When counting treatment types per professional, When the question asks about \"two or more types of treatments\": this means counting the number of treatment records (not distinct treatment types) per professional and requiring at least two records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, cell_phone FROM professionals WHERE COUNT(DISTINCT treatment_type) >= 2;",
            "SELECT T1.professional_id, T1.cell_number\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T1.professional_id, T1.cell_number\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) >= 2"
        ]
    },
    "944": {
        "db_id": "dog_kennels",
        "question": "What are the first name and last name of the professionals who have done treatment with cost below average?",
        "ground_truth": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to remove duplicate professional records. Do reference columns with table aliases `T1.first_name` and `T1.last_name` instead of unqualified column names. Do join `Professionals AS T1` with `Treatments AS T2` instead of querying only the Professionals table. Do filter on `cost_of_treatment` instead of `treatment_cost` to use the correct column name from the Treatments table. Do compare against the average `cost_of_treatment` instead of `treatment_cost` in the subquery to maintain consistency. The amended query now correctly identifies professionals whose treatment costs are below average by properly joining the relevant tables and using the correct column references.",
            "Do remove the `ON T1.professional_id = T2.professional_id` join condition instead of including it, and do remove the alias qualification from `cost_of_treatment` in the WHERE clause instead of keeping `T2.cost_of_treatment`. The amended query now correctly filters professionals based on treatment costs below the average without unnecessary join predicates and matches the RIGHT_SQL's behavior.",
            "Do remove the `ON T1.professional_id = T2.professional_id` join condition instead of including it, and do remove the table alias `T2.` from `cost_of_treatment` in the WHERE clause instead of keeping it. The amended query now correctly joins without an explicit condition and references the column directly, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about professionals who have done treatment with cost below average: make sure the output order: first_name, last_name.",
            "When the question mentions \"professionals\": \"professionals\" actually means \"Professionals AS T1\" in schema.",
            "When the question mentions \"treatment with cost\": \"treatment cost\" actually means \"T2.cost_of_treatment\" in schema.",
            "When combining T1 and T2 for shared entities: link rows where the canonical keys are equal as shown in the amends; keep only matching pairs (inner match).",
            "When filtering for cost below average: compare T2.cost_of_treatment against the average of T2.cost_of_treatment from all treatments.",
            "When answering about professionals who have done treatment with cost below average, When the question mentions \"professionals\", When the question mentions \"treatment with cost\", When combining T1 and T2 for shared entities, When filtering for cost below average, When selecting professional information: use T1.first_name and T1.last_name with DISTINCT to remove duplicate professional records.",
            "When joining Professionals and Treatments tables: do not include any join condition between T1.professional_id and T2.professional_id, instead perform a cartesian product between the tables.",
            "When filtering by cost_of_treatment below average: use the unqualified column name \"cost_of_treatment\" in the WHERE clause instead of the aliased form T2.cost_of_treatment.",
            "When joining Professionals and Treatments tables, When filtering by cost_of_treatment below average, When calculating the average cost of treatment: compute the average of the \"cost_of_treatment\" column from the Treatments table without any table alias qualification.",
            "When joining Professionals (T1) and Treatments tables: do not use any explicit join condition between T1.professional_id and T2.professional_id, instead perform a cross join without specified conditions.",
            "When referencing the cost_of_treatment column in the WHERE clause: use the column name directly without table alias prefix (use cost_of_treatment instead of T2.cost_of_treatment).",
            "When joining Professionals (T1) and Treatments tables, When referencing the cost_of_treatment column in the WHERE clause, When filtering for treatments with cost below average: compare cost_of_treatment against the average cost calculated from all treatments using (SELECT AVG(cost_of_treatment) FROM Treatments)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM professionals WHERE treatment_cost < (SELECT AVG(treatment_cost) FROM treatments)",
            "SELECT DISTINCT T1.first_name, T1.last_name\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nWHERE T2.cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments);",
            "SELECT DISTINCT T1.first_name, T1.last_name\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nWHERE T2.cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments)",
            "SELECT DISTINCT T1.first_name, T1.last_name\nFROM Professionals AS T1\nJOIN Treatments AS T2\nWHERE T2.cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments)"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.first_name, T1.last_name\nFROM Professionals AS T1, Treatments AS T2\nWHERE cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments);"
        ]
    },
    "945": {
        "db_id": "dog_kennels",
        "question": "Which professionals have operated a treatment that costs less than the average? Give me theor first names and last names.",
        "ground_truth": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to remove duplicate professional records. Do reference columns with table aliases `T1.first_name` and `T1.last_name` instead of unqualified `first_name` and `last_name`. Do join `Professionals AS T1` with `Treatments AS T2` instead of querying only the `professionals` table. Do use column name `cost_of_treatment` instead of `treatment_cost` in both the main filter and subquery. Do reference the correct table `Treatments` in the subquery instead of `treatments`. The amended query now correctly joins professionals with their treatments and filters based on the average treatment cost.",
            "Do remove the `ON T1.professional_id = T2.professional_id` join condition instead of including it, and do remove the table alias `T2.` from `cost_of_treatment` in the WHERE clause instead of keeping it. The amended query now matches RIGHT_SQL's behavior.",
            "Do remove the `ON T1.professional_id = T2.professional_id` join condition instead of including it, as the RIGHT_SQL uses a cross join without explicit join predicates. Do keep the `DISTINCT` modifier, `T1.first_name` and `T1.last_name` column selections, `Professionals AS T1` and `Treatments AS T2` table sources, and the `cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments)` filter condition unchanged, as these elements match between both queries. The amended query now matches RIGHT_SQL's behavior with a Cartesian product between Professionals and Treatments tables filtered by the cost comparison."
        ],
        "rules": [
            "When answering about professionals operating treatments: join Professionals AS T1 with Treatments AS T2 instead of querying only the Professionals table.",
            "When filtering by treatment cost: use column name \"cost_of_treatment\" instead of \"treatment_cost\" in both the main filter and subquery.",
            "When computing average treatment cost: reference the correct table \"Treatments\" in the subquery instead of \"treatments\".",
            "When selecting professional names: use table aliases T1.first_name and T1.last_name instead of unqualified column names.",
            "When answering about professionals operating treatments, When filtering by treatment cost, When computing average treatment cost, When selecting professional names, When returning professional records: use DISTINCT instead of omitting it to remove duplicate professional records.",
            "When joining Professionals and Treatments tables: do not use any join condition between T1.professional_id and T2.professional_id, instead perform a cartesian product of all rows from both tables.",
            "When comparing treatment cost to average cost: reference cost_of_treatment without any table alias prefix in the WHERE clause instead of using T2.cost_of_treatment.",
            "When joining Professionals and Treatments tables, When comparing treatment cost to average cost, When answering about professionals operating treatments costing less than average: output first_name and last_name columns from the Professionals table (T1).",
            "When combining Professionals and Treatments tables: do not use any join condition and create a Cartesian product between all rows of both tables.",
            "When filtering by cost of treatment: keep only rows where T2.cost_of_treatment is less than the average cost_of_treatment from all Treatments.",
            "When selecting distinct professionals: return unique combinations of T1.first_name and T1.last_name from the filtered results.",
            "When combining Professionals and Treatments tables, When filtering by cost of treatment, When selecting distinct professionals, When handling output columns: maintain the exact order of T1.first_name followed by T1.last_name in the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM professionals WHERE treatment_cost < (SELECT AVG(treatment_cost) FROM treatments);",
            "SELECT DISTINCT T1.first_name, T1.last_name\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nWHERE T2.cost_of_treatment < (\n    SELECT AVG(cost_of_treatment)\n    FROM Treatments\n)",
            "SELECT DISTINCT T1.first_name, T1.last_name\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nWHERE cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments)",
            "SELECT DISTINCT T1.first_name, T1.last_name\nFROM Professionals AS T1, Treatments AS T2\nWHERE T2.cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments)"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.first_name, T1.last_name\nFROM Professionals AS T1, Treatments AS T2\nWHERE T2.cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments);"
        ]
    },
    "946": {
        "db_id": "dog_kennels",
        "question": "List the date of each treatment, together with the first name of the professional who operated it.",
        "ground_truth": "SELECT T1.date_of_treatment ,  T2.first_name FROM Treatments AS T1 JOIN Professionals AS T2 ON T1.professional_id  =  T2.professional_id",
        "amends": [
            "Do select `date_of_treatment` and `first_name` instead of `treatment_date` and `last_name`. Do use table aliases `T1` and `T2` instead of no aliases. Do reference `T1.date_of_treatment` and `T2.first_name` instead of unqualified column names. Do specify `Treatments AS T1` and `Professionals AS T2` instead of simple table names. The amended query now correctly retrieves the treatment date and professional's first name with proper table aliasing."
        ],
        "rules": [
            "When the question asks for \"date of each treatment\": select \"date_of_treatment\" from table \"Treatments\" (aliased as T1) instead of \"treatment_date\".",
            "When the question asks for \"first name of the professional\": select \"first_name\" from table \"Professionals\" (aliased as T2) instead of \"last_name\".",
            "When combining tables Treatments and Professionals: use table aliases T1 for Treatments and T2 for Professionals.",
            "When the question asks for \"date of each treatment\", When the question asks for \"first name of the professional\", When combining tables Treatments and Professionals, When referencing columns from joined tables: qualify column names with their table aliases as T1.date_of_treatment and T2.first_name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT treatment_date, last_name FROM treatments JOIN professionals ON treatments.professional_id = professionals.professional_id;",
            "SELECT T1.date_of_treatment, T2.first_name FROM Treatments AS T1 JOIN Professionals AS T2 ON T1.professional_id = T2.professional_id;"
        ],
        "rule_sql": [
            "SELECT T1.date_of_treatment, T2.first_name FROM Treatments T1 JOIN Professionals T2 ON T1.professional_id = T2.professional_id;"
        ]
    },
    "947": {
        "db_id": "dog_kennels",
        "question": "What are the date and the operating professional's first name of each treatment?",
        "ground_truth": "SELECT T1.date_of_treatment ,  T2.first_name FROM Treatments AS T1 JOIN Professionals AS T2 ON T1.professional_id  =  T2.professional_id",
        "amends": [
            "Do use `T1.date_of_treatment` instead of `date` and `T2.first_name` instead of `first_name` for explicit table aliases. Do specify `Treatments AS T1` instead of `treatments` and `Professionals AS T2` instead of `professionals` with proper table aliasing. Do join on `T1.professional_id = T2.professional_id` instead of `treatments.professional_id = professionals.id` to use the correct join condition between professional IDs. The amended query now correctly retrieves treatment dates and professional names using proper table aliases and join conditions."
        ],
        "rules": [
            "When answering about \"date and the operating professional's first name of each treatment\": make sure the output order: T1.date_of_treatment, T2.first_name.",
            "When the question mentions \"date\": \"date\" actually means \"T1.date_of_treatment\" in schema.",
            "When the question mentions \"first name\": \"first name\" actually means \"T2.first_name\" in schema.",
            "When answering about \"date and the operating professional's first name of each treatment\", When the question mentions \"date\", When the question mentions \"first name\", When combining T1 (Treatments) and T2 (Professionals) for shared entities: link rows where T1.professional_id = T2.professional_id; keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT date, first_name FROM treatments JOIN professionals ON treatments.professional_id = professionals.id",
            "SELECT T1.date_of_treatment, T2.first_name FROM Treatments AS T1 JOIN Professionals AS T2 ON T1.professional_id = T2.professional_id"
        ],
        "rule_sql": [
            "SELECT T1.date_of_treatment, T2.first_name FROM Treatments T1 INNER JOIN Professionals T2 ON T1.professional_id = T2.professional_id;"
        ]
    },
    "948": {
        "db_id": "dog_kennels",
        "question": "List the cost of each treatment and the corresponding treatment type description.",
        "ground_truth": "SELECT T1.cost_of_treatment ,  T2.treatment_type_description FROM Treatments AS T1 JOIN treatment_types AS T2 ON T1.treatment_type_code  =  T2.treatment_type_code",
        "amends": [
            "Do specify table aliases `T1.cost_of_treatment` and `T2.treatment_type_description` instead of unqualified column names `cost` and `treatment_type_description`. Do add a `JOIN` with `treatment_types AS T2` instead of querying only the `treatments` table. Do use the join condition `ON T1.treatment_type_code = T2.treatment_type_code` instead of omitting the necessary table relationship. The amended query now correctly retrieves treatment cost and description by properly joining the treatments table with treatment_types using the appropriate foreign key relationship."
        ],
        "rules": [
            "When answering about \"cost of each treatment and corresponding treatment type description\": make sure the output order: T1.cost_of_treatment, T2.treatment_type_description.",
            "When the question mentions \"cost\": \"cost\" actually means \"T1.cost_of_treatment\" in schema.",
            "When the question mentions \"treatment type description\": \"treatment type description\" actually means \"T2.treatment_type_description\" in schema.",
            "When answering about \"cost of each treatment and corresponding treatment type description\", When the question mentions \"cost\", When the question mentions \"treatment type description\", When combining T1 (treatments) and T2 (treatment_types) for shared entities: link rows where T1.treatment_type_code = T2.treatment_type_code; keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT cost, treatment_type_description FROM treatments",
            "SELECT T1.cost_of_treatment, T2.treatment_type_description FROM Treatments AS T1 JOIN Treatment_Types AS T2 ON T1.treatment_type_code = T2.treatment_type_code"
        ],
        "rule_sql": [
            "SELECT T1.cost_of_treatment, T2.treatment_type_description \nFROM Treatments T1\nINNER JOIN Treatment_Types T2 ON T1.treatment_type_code = T2.treatment_type_code\nORDER BY T1.cost_of_treatment, T2.treatment_type_description"
        ]
    },
    "949": {
        "db_id": "dog_kennels",
        "question": "What are the cost and treatment type description of each treatment?",
        "ground_truth": "SELECT T1.cost_of_treatment ,  T2.treatment_type_description FROM Treatments AS T1 JOIN treatment_types AS T2 ON T1.treatment_type_code  =  T2.treatment_type_code",
        "amends": [
            "Do specify table aliases `T1.cost_of_treatment` and `T2.treatment_type_description` instead of unqualified `cost` and `treatment_type`. Do add `JOIN treatment_types AS T2` instead of querying only the `treatments` table. Do include the join condition `ON T1.treatment_type_code = T2.treatment_type_code` instead of omitting the necessary table relationship. The amended query now correctly joins the two related tables to retrieve the complete treatment information."
        ],
        "rules": [
            "When answering about \"cost and treatment type description of each treatment\": make sure the output order: T1.cost_of_treatment, T2.treatment_type_description.",
            "When the question mentions \"cost\": \"cost\" actually means \"T1.cost_of_treatment\" in schema.",
            "When the question mentions \"treatment type description\": \"treatment type description\" actually means \"T2.treatment_type_description\" in schema.",
            "When answering about \"cost and treatment type description of each treatment\", When the question mentions \"cost\", When the question mentions \"treatment type description\", When combining T1 (treatments) and T2 (treatment_types) for shared entities: link rows where T1.treatment_type_code = T2.treatment_type_code exactly as shown in the amends; keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT cost, treatment_type FROM treatments;",
            "SELECT T1.cost_of_treatment, T2.treatment_type_description FROM Treatments AS T1 JOIN Treatment_Types AS T2 ON T1.treatment_type_code = T2.treatment_type_code"
        ],
        "rule_sql": [
            "SELECT T1.cost_of_treatment, T2.treatment_type_description\nFROM Treatments T1\nINNER JOIN Treatment_Types T2 ON T1.treatment_type_code = T2.treatment_type_code\nORDER BY T1.cost_of_treatment, T2.treatment_type_description;"
        ]
    },
    "950": {
        "db_id": "dog_kennels",
        "question": "List each owner's first name, last name, and the size of his for her dog.",
        "ground_truth": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference column `size_code` instead of `size` in the SELECT list. Do use table name `Owners` instead of `owner` and `Dogs` instead of `dog`. Do join on `T1.owner_id = T2.owner_id` instead of `owner.id = dog.owner_id`, correcting the join condition to use the proper column names. The amended query now correctly retrieves owner information with dog size codes using the proper table and column references."
        ],
        "rules": [
            "When using table aliases: use T1 for the Owners table and T2 for the Dogs table instead of full table names.",
            "When selecting dog size information: reference column \"size_code\" instead of \"size\" in the output.",
            "When referring to table names: use \"Owners\" instead of \"owner\" and \"Dogs\" instead of \"dog\".",
            "When using table aliases, When selecting dog size information, When referring to table names, When joining Owners and Dogs tables: link rows where T1.owner_id = T2.owner_id to correctly match owners with their dogs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT owner.first_name, owner.last_name, dog.size FROM owner JOIN dog ON owner.id = dog.owner_id",
            "SELECT T1.first_name, T1.last_name, T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id = T2.owner_id"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.last_name, T2.size_code FROM Owners T1 JOIN Dogs T2 ON T1.owner_id = T2.owner_id;"
        ]
    },
    "951": {
        "db_id": "dog_kennels",
        "question": "What are each owner's first name, last name, and the size of their dog?",
        "ground_truth": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of no aliases. Do reference `T1.first_name` and `T1.last_name` instead of unqualified `first_name` and `last_name`. Do select `T2.size_code` instead of `dog_size`. Do use `Owners AS T1` and `Dogs AS T2` instead of unaliased `owners` and `dogs`. Do join on `T1.owner_id = T2.owner_id` instead of `owners.id = dogs.owner_id`. The amended query now correctly matches the intended logic by using proper table aliases and the correct join condition between owner_id fields."
        ],
        "rules": [
            "When answering about \"each owner's first name, last name, and the size of their dog\": make sure the output order: T1.first_name, T1.last_name, T2.size_code.",
            "When the question mentions \"owner\": use table \"Professionals\" as T1 with columns first_name and last_name.",
            "When the question mentions \"dog size\": use column T2.size_code from the Dogs table instead of dog_size.",
            "When combining T1 (Professionals) and T2 (Dogs) for shared entities: link rows where T1.owner_id = T2.owner_id and keep only matching pairs (inner match).",
            "When answering about \"each owner's first name, last name, and the size of their dog\", When the question mentions \"owner\", When the question mentions \"dog size\", When combining T1 (Professionals) and T2 (Dogs) for shared entities, When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table and column names."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, dog_size FROM owners JOIN dogs ON owners.id = dogs.owner_id",
            "SELECT T1.first_name, T1.last_name, T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id = T2.owner_id;"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.last_name, T2.size_code FROM Professionals T1 INNER JOIN Dogs T2 ON T1.owner_id = T2.owner_id ORDER BY T1.first_name, T1.last_name, T2.size_code"
        ]
    },
    "952": {
        "db_id": "dog_kennels",
        "question": "List pairs of the owner's first name and the dogs's name.",
        "ground_truth": "SELECT T1.first_name ,  T2.name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names `owner` and `dog`. Do reference `T1.first_name` and `T2.name` instead of `owner.first_name` and `dog.name`. Do join on `T1.owner_id = T2.owner_id` instead of `owner.id = dog.owner_id`. Do use table names `Owners` and `Dogs` instead of `owner` and `dog`. The amended query now correctly matches the intended join logic and table structure."
        ],
        "rules": [
            "When answering about \"List pairs of the owner's first name and the dog's name\": make sure the output order: T1.first_name, T2.name.",
            "When combining Owners (T1) and Dogs (T2) for shared entities: link rows where T1.owner_id = T2.owner_id exactly as shown; keep only matching pairs (inner match).",
            "When answering about \"List pairs of the owner's first name and the dog's name\", When combining Owners (T1) and Dogs (T2) for shared entities, When choosing identifier delimiters: do not replace table names Owners and Dogs with lowercase owner and dog."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT owner.first_name, dog.name FROM owner JOIN dog ON owner.id = dog.owner_id",
            "SELECT T1.first_name, T2.name FROM Owners T1 JOIN Dogs T2 ON T1.owner_id = T2.owner_id"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T2.name FROM Owners T1 INNER JOIN Dogs T2 ON T1.owner_id = T2.owner_id"
        ]
    },
    "953": {
        "db_id": "dog_kennels",
        "question": "What are each owner's first name and their dogs's name?",
        "ground_truth": "SELECT T1.first_name ,  T2.name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id",
        "amends": [
            "Do use `T1.first_name` and `T2.name` as column selections instead of `owner_name` and `dog_name`. Do specify table aliases `AS T1` for `Owners` and `AS T2` for `Dogs` instead of using unaliased table names. Do join on `T1.owner_id = T2.owner_id` instead of `owners.id = dogs.owner_id` to correctly match the owner_id fields between tables. The amended query now correctly retrieves first names from the Owners table and dog names from the Dogs table using the proper join condition on owner_id fields."
        ],
        "rules": [
            "When selecting owner information from the Owners table: use T1.first_name as the exact column token for owner's first name.",
            "When selecting dog information from the Dogs table: use T2.name as the exact column token for dog's name.",
            "When combining Owners and Dogs tables: link rows where T1.owner_id = T2.owner_id to correctly match owner records with their dogs.",
            "When selecting owner information from the Owners table, When selecting dog information from the Dogs table, When combining Owners and Dogs tables, When assigning table aliases: use AS T1 for Owners table and AS T2 for Dogs table as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT owner_name, dog_name FROM owners JOIN dogs ON owners.id = dogs.owner_id;",
            "SELECT T1.first_name, T2.name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id = T2.owner_id"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T2.name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id = T2.owner_id"
        ]
    },
    "954": {
        "db_id": "dog_kennels",
        "question": "List the names of the dogs of the rarest breed and the treatment dates of them.",
        "ground_truth": "SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT 1 )",
        "amends": [
            "Do use `T1.name` and `T2.date_of_treatment` as column aliases instead of `d.name` and `t.treatment_date`. Do reference table aliases `Dogs AS T1` and `Treatments AS T2` instead of `dogs d` and `treatments t`. Do join on `T1.dog_id = T2.dog_id` instead of `d.dog_id = t.dog_id`. Do filter on `T1.breed_code` instead of `d.breed`. Do use `breed_code` in the subquery instead of `breed` for both the selection and grouping. The amended query now correctly matches the RIGHT_SQL's behavior with proper column references and table aliasing."
        ],
        "rules": [
            "When answering about \"names of dogs and treatment dates\": make sure the output order: T1.name, T2.date_of_treatment",
            "When the question mentions \"breed\": \"breed\" actually means \"breed_code in schema\"",
            "When the question asks for \"rarest breed\": find the breed_code with the smallest count of dogs and use that value for filtering",
            "When combining T1 (Dogs) and T2 (Treatments) for shared entities: link rows where T1.dog_id = T2.dog_id; keep only matching pairs (inner match)",
            "When answering about \"names of dogs and treatment dates\", When the question mentions \"breed\", When the question asks for \"rarest breed\", When combining T1 (Dogs) and T2 (Treatments) for shared entities, When filtering for the rarest breed: use the exact breed_code value that has the minimum count from the Dogs table"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.name, t.treatment_date \nFROM dogs d \nJOIN treatments t ON d.dog_id = t.dog_id \nWHERE d.breed = (SELECT breed FROM dogs GROUP BY breed ORDER BY COUNT(*) ASC LIMIT 1)",
            "SELECT T1.name, T2.date_of_treatment\nFROM Dogs AS T1\nJOIN Treatments AS T2 ON T1.dog_id = T2.dog_id\nWHERE T1.breed_code = (\n    SELECT breed_code\n    FROM Dogs\n    GROUP BY breed_code\n    ORDER BY COUNT(*) ASC\n    LIMIT 1\n)\nORDER BY T2.date_of_treatment;"
        ],
        "rule_sql": [
            "SELECT T1.name, T2.date_of_treatment\nFROM Dogs T1\nINNER JOIN Treatments T2 ON T1.dog_id = T2.dog_id\nWHERE T1.breed_code = (\n    SELECT breed_code\n    FROM Dogs\n    GROUP BY breed_code\n    ORDER BY COUNT(*) ASC\n    LIMIT 1\n)\nORDER BY T1.name, T2.date_of_treatment;"
        ]
    },
    "955": {
        "db_id": "dog_kennels",
        "question": "Which dogs are of the rarest breed? Show their names and treatment dates.",
        "ground_truth": "SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT 1 )",
        "amends": [
            "Do use `T1.name` and `T2.date_of_treatment` instead of `d.name` and `t.treatment_date` for column aliases. Do reference `Dogs AS T1` and `Treatments AS T2` instead of `dogs d` and `treatments t` for table aliases. Do join on `T1.dog_id = T2.dog_id` instead of `d.dog_id = t.dog_id` for the join condition. Do filter on `T1.breed_code` instead of `d.breed` for the breed column reference. Do use `breed_code` instead of `breed` in the subquery's SELECT and GROUP BY clauses. The amended query now correctly matches the RIGHT_SQL's behavior with proper column and table references."
        ],
        "rules": [
            "When answering about \"rarest breed\": find the breed_code with the lowest count of dogs in T1 (Dogs table) and use that breed_code for filtering.",
            "When the question mentions \"breed\": use T1.breed_code instead of breed as the column reference.",
            "When showing dog names and treatment dates: output T1.name and T2.date_of_treatment as the result columns.",
            "When combining Dogs and Treatments tables: link rows where T1.dog_id = T2.dog_id using an inner join.",
            "When answering about \"rarest breed\", When the question mentions \"breed\", When showing dog names and treatment dates, When combining Dogs and Treatments tables, When ordering results: sort by T2.date_of_treatment in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.name, t.treatment_date \nFROM dogs d \nJOIN treatments t ON d.dog_id = t.dog_id \nWHERE d.breed = (SELECT breed FROM dogs GROUP BY breed ORDER BY COUNT(*) ASC LIMIT 1)\nORDER BY t.treatment_date DESC;",
            "SELECT T1.name, T2.date_of_treatment\nFROM Dogs AS T1\nJOIN Treatments AS T2 ON T1.dog_id = T2.dog_id\nWHERE T1.breed_code = (\n    SELECT breed_code\n    FROM Dogs\n    GROUP BY breed_code\n    ORDER BY COUNT(*) ASC\n    LIMIT 1\n)"
        ],
        "rule_sql": [
            "SELECT T1.name, T2.date_of_treatment\nFROM Dogs T1\nINNER JOIN Treatments T2 ON T1.dog_id = T2.dog_id\nWHERE T1.breed_code = (\n    SELECT breed_code\n    FROM Dogs\n    GROUP BY breed_code\n    ORDER BY COUNT(*) ASC\n    LIMIT 1\n)\nORDER BY T2.date_of_treatment DESC;"
        ]
    },
    "956": {
        "db_id": "dog_kennels",
        "question": "Which dogs are owned by someone who lives in Virginia? List the owner's first name and the dog's name.",
        "ground_truth": "SELECT T1.first_name ,  T2.name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T1.state  =  'Virginia'",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference `T1.owner_id` in the JOIN condition instead of `dogs.owner_id`. Do use `T1.owner_id = T2.owner_id` instead of `dogs.owner_id = owners.id`. Do reference `T1.state` in the WHERE clause instead of `owners.state`. The amended query now correctly joins on the owner_id field from both tables and uses proper table aliasing throughout."
        ],
        "rules": [
            "When joining tables dogs and owners: use table aliases T1 for dogs and T2 for owners.",
            "When combining dogs and owners tables: link rows where T1.owner_id = T2.owner_id and keep only matching pairs (inner match).",
            "When filtering for owners in Virginia: use T2.state = 'Virginia' with exact case and spacing.",
            "When joining tables dogs and owners, When combining dogs and owners tables, When filtering for owners in Virginia, When answering about dogs owned by Virginia residents: make sure the output order: owner's first name (T2.first_name) and dog's name (T1.name)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT owner.first_name, dog.name FROM dogs JOIN owners ON dogs.owner_id = owners.id WHERE owners.state = 'Virginia';",
            "SELECT T2.first_name, T1.name \nFROM Dogs T1 \nJOIN Owners T2 ON T1.owner_id = T2.owner_id \nWHERE T2.state = 'Virginia'"
        ],
        "rule_sql": [
            "SELECT T2.first_name, T1.name FROM Dogs T1 INNER JOIN Owners T2 ON T1.owner_id = T2.owner_id WHERE T2.state = 'Virginia' ORDER BY T2.first_name, T1.name;"
        ]
    },
    "957": {
        "db_id": "dog_kennels",
        "question": "Find the first names of owners living in Virginia and the names of dogs they own.",
        "ground_truth": "SELECT T1.first_name ,  T2.name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T1.state  =  'Virginia'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT o.first_name, d.name FROM owners o JOIN dogs d ON o.owner_id = d.owner_id WHERE o.state = 'Virginia';"
        ],
        "rule_sql": [
            "SELECT o.first_name, d.name \nFROM Owners o\nJOIN Dogs d ON o.owner_id = d.owner_id\nWHERE o.state = 'Virginia'\nORDER BY o.first_name, d.name;"
        ]
    },
    "958": {
        "db_id": "dog_kennels",
        "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?",
        "ground_truth": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do use `T1.date_arrived` and `T1.date_departed` instead of `arriving_date` and `departing_date`. Do add `Treatments AS T2` table with `JOIN` instead of querying only the `dogs` table. Do use join condition `T1.dog_id = T2.dog_id` instead of filtering with `WHERE treatment = 'yes'`. Do remove the `WHERE` filter condition instead of keeping it, as the join now properly filters to dogs with treatments. The amended query now correctly retrieves distinct arrival and departure dates for dogs that have treatments by joining the Dogs and Treatments tables."
        ],
        "rules": [
            "When answering about \"arriving date and departing date of dogs who have gone through treatment\": make sure the output order: T1.date_arrived, T1.date_departed.",
            "When the question mentions \"dogs who have gone through a treatment\": this requires joining the Dogs table (T1) with the Treatments table (T2) using T1.dog_id = T2.dog_id to find matching pairs.",
            "When retrieving dates for dogs with treatments: use T1.date_arrived and T1.date_departed instead of arriving_date and departing_date.",
            "When ensuring each dog appears only once in results: use DISTINCT to remove duplicate rows.",
            "When answering about \"arriving date and departing date of dogs who have gone through treatment\", When the question mentions \"dogs who have gone through a treatment\", When retrieving dates for dogs with treatments, When ensuring each dog appears only once in results, When filtering for dogs with treatments: do not use a WHERE condition on treatment status, as the join itself properly filters to only dogs that have treatments."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT arriving_date, departing_date FROM dogs WHERE treatment = 'yes';",
            "SELECT DISTINCT T1.date_arrived, T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id = T2.dog_id"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.date_arrived, T1.date_departed\nFROM Dogs T1\nJOIN Treatments T2 ON T1.dog_id = T2.dog_id"
        ]
    },
    "959": {
        "db_id": "dog_kennels",
        "question": "Find the arriving date and the departing date of the dogs that received a treatment.",
        "ground_truth": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id",
        "amends": [
            "Do add `DISTINCT` instead of omitting it, and use `date_arrived` and `date_departed` instead of `arrival_date` and `departure_date`. Do join `Treatments` table on `dog_id` instead of filtering only by `treatment_received = 'yes'`, and reference the table as `Dogs AS T1` instead of just `dogs`. Do remove the `WHERE` clause filter entirely instead of keeping it, as the join condition now properly identifies dogs that have received treatments. The amended query now correctly returns distinct arrival and departure dates for dogs that have treatment records, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"arriving date and departing date of dogs that received a treatment\": use \"date_arrived\" and \"date_departed\" columns from table \"Dogs\" instead of \"arrival_date\" and \"departure_date\".",
            "When identifying dogs that received treatments: join \"Treatments\" table with \"Dogs AS T1\" using \"dog_id\" column instead of filtering by \"treatment_received = 'yes'\".",
            "When returning results for dogs with treatments: ensure distinct arrival and departure dates by removing duplicate combinations of date_arrived and date_departed.",
            "When answering about \"arriving date and departing date of dogs that received a treatment\", When identifying dogs that received treatments, When returning results for dogs with treatments, When combining Dogs and Treatments tables: link rows where T1.dog_id equals Treatments.dog_id and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT arrival_date, departure_date FROM dogs WHERE treatment_received = 'yes';",
            "SELECT DISTINCT T1.date_arrived, T1.date_departed\nFROM Dogs AS T1\nJOIN Treatments ON T1.dog_id = Treatments.dog_id"
        ],
        "rule_sql": [
            "SELECT DISTINCT d.date_arrived, d.date_departed\nFROM Dogs d\nINNER JOIN Treatments t ON d.dog_id = t.dog_id;"
        ]
    },
    "960": {
        "db_id": "dog_kennels",
        "question": "List the last name of the owner owning the youngest dog.",
        "ground_truth": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )",
        "amends": [
            "Do add `T1.last_name` with table alias instead of `last_name` without qualification. Do add `FROM Owners AS T1 JOIN Dogs AS T2` with explicit join instead of single table `FROM owners`. Do add `ON T1.owner_id = T2.owner_id` join condition instead of omitting any join. Do add `WHERE T2.age = (SELECT max(age) FROM Dogs)` subquery filter instead of `ORDER BY dog_age ASC`. Do remove `LIMIT 1` instead of keeping it, as the subquery now precisely identifies the maximum age. The amended query now correctly finds owners with dogs of maximum age instead of attempting to sort by a non-existent column."
        ],
        "rules": [
            "When answering about \"last name of the owner\": make sure the output column is T1.last_name with table alias qualification.",
            "When combining Owners and Dogs tables: link rows where T1.owner_id = T2.owner_id and keep only matching pairs (inner match).",
            "When the question asks for owners with the youngest dog: use WHERE T2.age = (SELECT max(age) FROM Dogs) to filter for dogs with maximum age instead of sorting.",
            "When the question mentions \"youngest dog\": \"youngest\" actually means \"maximum age\" in the Dogs table.",
            "When answering about \"last name of the owner\", When combining Owners and Dogs tables, When the question asks for owners with the youngest dog, When the question mentions \"youngest dog\", When the question asks for a single result from a subquery filter: do not use LIMIT 1 as the subquery precisely identifies the maximum age."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM owners ORDER BY dog_age ASC LIMIT 1;",
            "SELECT T1.last_name \nFROM Owners AS T1 \nJOIN Dogs AS T2 ON T1.owner_id = T2.owner_id \nWHERE T2.age = (SELECT MAX(age) FROM Dogs)"
        ],
        "rule_sql": [
            "SELECT T1.last_name\nFROM Owners T1\nINNER JOIN Dogs T2 ON T1.owner_id = T2.owner_id\nWHERE T2.age = (SELECT MAX(age) FROM Dogs)"
        ]
    },
    "961": {
        "db_id": "dog_kennels",
        "question": "Who owns the youngest dog? Give me his or her last name.",
        "ground_truth": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )",
        "amends": [
            "Do add `T1.last_name` with table alias instead of `last_name` without qualification. Do add `FROM Owners AS T1 JOIN Dogs AS T2` with explicit join instead of single table `FROM owners`. Do add `ON T1.owner_id = T2.owner_id` join condition instead of missing join predicate. Do add `WHERE T2.age = (SELECT max(age) FROM Dogs)` subquery filter instead of `ORDER BY dog_age ASC` sorting. Do remove `LIMIT 1` instead of keeping it, as the subquery filter now precisely identifies the maximum age record. The amended query now correctly joins the Owners and Dogs tables to find owners with dogs of maximum age, matching RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"Who owns the youngest dog? Give me his or her last name\": make sure the output order: T1.last_name.",
            "When the question mentions \"youngest dog\": \"youngest dog\" actually means \"dogs with maximum age in schema\" using T2.age = (SELECT max(age) FROM Dogs).",
            "When combining T1 (Owners) and T2 (Dogs) for shared entities: link rows where T1.owner_id = T2.owner_id exactly as shown in the amends; keep only matching pairs (inner match).",
            "When answering about \"Who owns the youngest dog? Give me his or her last name\", When the question mentions \"youngest dog\", When combining T1 (Owners) and T2 (Dogs) for shared entities, When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table and column names like T1.last_name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM owners ORDER BY dog_age ASC LIMIT 1;",
            "SELECT T1.last_name \nFROM Owners AS T1 \nJOIN Dogs AS T2 ON T1.owner_id = T2.owner_id \nWHERE T2.age = (SELECT MAX(age) FROM Dogs)"
        ],
        "rule_sql": [
            "SELECT T1.last_name FROM Owners T1 INNER JOIN Dogs T2 ON T1.owner_id = T2.owner_id WHERE T2.age = (SELECT MAX(age) FROM Dogs)"
        ]
    },
    "962": {
        "db_id": "dog_kennels",
        "question": "List the emails of the professionals who live in the state of Hawaii or the state of Wisconsin.",
        "ground_truth": "SELECT email_address FROM Professionals WHERE state  =  'Hawaii' OR state  =  'Wisconsin'",
        "amends": [
            "Do reference the `email_address` column instead of `email` and use `OR` between state conditions instead of `AND` to properly select professionals from either Hawaii or Wisconsin, instead of incorrectly requiring both states simultaneously which would never match any records."
        ],
        "rules": [
            "When the question asks for emails of professionals: use the exact column name \"email_address\" from the Professionals table instead of \"email\".",
            "When the question asks for professionals in Hawaii OR Wisconsin: use OR between state conditions instead of AND to select professionals from either state, not both simultaneously.",
            "When the question asks for emails of professionals, When the question asks for professionals in Hawaii OR Wisconsin, When specifying state values: use the exact literals 'Hawaii' and 'Wisconsin' with proper capitalization and spelling."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT email FROM professionals WHERE state = 'Hawaii' AND state = 'Wisconsin';",
            "SELECT email_address FROM Professionals WHERE state = 'Hawaii' OR state = 'Wisconsin'"
        ],
        "rule_sql": [
            "SELECT email_address FROM Professionals WHERE state = 'Hawaii' OR state = 'Wisconsin'"
        ]
    },
    "963": {
        "db_id": "dog_kennels",
        "question": "What are the emails of the professionals living in either the state of Hawaii or the state of Wisconsin?",
        "ground_truth": "SELECT email_address FROM Professionals WHERE state  =  'Hawaii' OR state  =  'Wisconsin'",
        "amends": [
            "Do reference the `email_address` column instead of `email` and use `OR` between state conditions instead of `AND` to correctly find professionals in either Hawaii or Wisconsin instead of incorrectly requiring both states simultaneously. Do use the correct table name `Professionals` instead of `professionals` to match the schema. The amended query now correctly returns email addresses for professionals located in either Hawaii or Wisconsin."
        ],
        "rules": [
            "When the question asks for \"emails\": use the exact column token \"email_address\" from the Professionals table instead of \"email\".",
            "When the question mentions professionals living in \"either the state of Hawaii or the state of Wisconsin\": use OR logic between state conditions instead of AND to find professionals in either state.",
            "When the question asks for \"emails\", When the question mentions professionals living in \"either the state of Hawaii or the state of Wisconsin\", When referencing the professionals table: use the exact table name \"Professionals\" with proper capitalization as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT email FROM professionals WHERE state = 'Hawaii' AND state = 'Wisconsin';",
            "SELECT email_address FROM Professionals WHERE state = 'Hawaii' OR state = 'Wisconsin'"
        ],
        "rule_sql": [
            "SELECT email_address FROM Professionals WHERE state = 'Hawaii' OR state = 'Wisconsin'"
        ]
    },
    "964": {
        "db_id": "dog_kennels",
        "question": "What are the arriving date and the departing date of all the dogs?",
        "ground_truth": "SELECT date_arrived ,  date_departed FROM Dogs",
        "amends": [
            "Do reference `date_arrived` and `date_departed` columns instead of `arrival_date` and `departure_date`. Do query from `Dogs` table instead of `cats` table. The amended query now correctly selects the appropriate date columns from the intended table."
        ],
        "rules": [
            "When the question asks about \"arriving date\" and \"departing date\" of dogs: use columns \"date_arrived\" and \"date_departed\" from table \"Dogs\".",
            "When querying about dogs: use table \"Dogs\" instead of any other table like \"cats\".",
            "When the question asks about \"arriving date\" and \"departing date\" of dogs, When querying about dogs, When selecting date columns for dogs: ensure the output order is \"date_arrived\" followed by \"date_departed\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT arrival_date, departure_date FROM cats;",
            "SELECT date_arrived, date_departed FROM Dogs;"
        ],
        "rule_sql": [
            "SELECT date_arrived, date_departed FROM Dogs;"
        ]
    },
    "965": {
        "db_id": "dog_kennels",
        "question": "List the arrival date and the departure date for all the dogs.",
        "ground_truth": "SELECT date_arrived ,  date_departed FROM Dogs",
        "amends": [
            "Do reference table `Dogs` instead of `cats` in the FROM clause. Do select columns `date_arrived` and `date_departed` instead of `arrival_date` and `departure_date` in the SELECT list. The amended query now correctly retrieves arrival and departure dates from the Dogs table instead of the cats table, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"arrival date and departure date for all the dogs\": make sure the output order: date_arrived, date_departed.",
            "When the question mentions \"dogs\": \"dogs\" actually means table \"Dogs\" in schema.",
            "When the question mentions \"arrival date\": \"arrival date\" actually means column \"date_arrived\" in table \"Dogs\".",
            "When answering about \"arrival date and departure date for all the dogs\", When the question mentions \"dogs\", When the question mentions \"arrival date\", When the question mentions \"departure date\": \"departure date\" actually means column \"date_departed\" in table \"Dogs\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT arrival_date, departure_date FROM cats",
            "SELECT date_arrived, date_departed FROM Dogs;"
        ],
        "rule_sql": [
            "SELECT date_arrived, date_departed FROM Dogs;"
        ]
    },
    "966": {
        "db_id": "dog_kennels",
        "question": "How many dogs went through any treatments?",
        "ground_truth": "SELECT count(DISTINCT dog_id) FROM Treatments",
        "amends": [
            "Do count `DISTINCT dog_id` instead of `COUNT(*)` to count unique dogs rather than all treatment records. Do query from the `Treatments` table instead of `dogs` to access the treatment-specific data. Do remove the `WHERE treatment_id IS NOT NULL` filter instead of keeping it since counting distinct dog_ids inherently excludes null values. The amended query now correctly counts unique dogs that have received treatments rather than counting all treatment records, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When counting dogs that went through treatments: count distinct \"dog_id\" values instead of all records.",
            "When accessing treatment-specific data: use the \"Treatments\" table instead of the \"dogs\" table.",
            "When counting dogs that went through treatments, When accessing treatment-specific data, When counting distinct dog_ids: do not apply a \"treatment_id IS NOT NULL\" filter since counting distinct values inherently excludes null values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM dogs WHERE treatment_id IS NOT NULL;",
            "SELECT COUNT(DISTINCT dog_id) FROM Treatments;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT dog_id) FROM Treatments;"
        ]
    },
    "967": {
        "db_id": "dog_kennels",
        "question": "Count the number of dogs that went through a treatment.",
        "ground_truth": "SELECT count(DISTINCT dog_id) FROM Treatments",
        "amends": [
            "Do count `DISTINCT dog_id` instead of `COUNT(*)` to count unique dogs rather than all treatment records. Do source from `Treatments` table instead of `dogs` table to access the correct treatment data. Do remove the `WHERE treatment = 'yes'` filter instead of keeping it since the count should include all treatments regardless of status. The amended query now correctly counts distinct dogs that have received treatments rather than counting all treatment records, matching the intended behavior."
        ],
        "rules": [
            "When counting the number of dogs that went through treatment: count distinct \"dog_id\" values from the \"Treatments\" table instead of counting all rows.",
            "When accessing treatment data: use the \"Treatments\" table as the source instead of the \"dogs\" table.",
            "When counting the number of dogs that went through treatment, When accessing treatment data, When filtering treatment records: do not apply any status filter (remove WHERE treatment = 'yes') to include all treatments regardless of status."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM dogs WHERE treatment = 'yes';",
            "SELECT COUNT(DISTINCT dog_id) FROM Treatments;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT dog_id) FROM Treatments;"
        ]
    },
    "968": {
        "db_id": "dog_kennels",
        "question": "How many professionals have performed any treatment to dogs?",
        "ground_truth": "SELECT count(DISTINCT professional_id) FROM Treatments",
        "amends": [
            "Do select `count(DISTINCT professional_id)` instead of `COUNT(*)` to count unique professionals rather than all rows. Do query from the `Treatments` table instead of the `professionals` table to access treatment-specific data. Do remove the `WHERE treatment_type = 'dog'` filter instead of keeping it, as the count should include all treatments rather than filtering by type. The amended query now correctly counts distinct professionals from the Treatments table, matching the intended behavior."
        ],
        "rules": [
            "When counting professionals: count distinct \"professional_id\" values instead of counting all rows.",
            "When accessing treatment data: use the \"Treatments\" table instead of the \"professionals\" table.",
            "When counting professionals, When accessing treatment data, When counting professionals who performed treatments: include all treatments without filtering by treatment type."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM professionals WHERE treatment_type = 'dog'",
            "SELECT COUNT(DISTINCT professional_id) FROM Treatments;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT professional_id) FROM Treatments;"
        ]
    },
    "969": {
        "db_id": "dog_kennels",
        "question": "Find the number of professionals who have ever treated dogs.",
        "ground_truth": "SELECT count(DISTINCT professional_id) FROM Treatments",
        "amends": [
            "Do count `DISTINCT professional_id` instead of `COUNT(*)` to count unique professionals rather than all records. Do query from the `Treatments` table instead of the `professionals` table to access the correct data source for treatment-related information. Do remove the `WHERE pet_type = 'dog'` filter instead of keeping it since the right query does not include any filtering conditions. Do change the aggregate function to count distinct professional identifiers instead of counting all rows to accurately measure the number of unique professionals providing treatments."
        ],
        "rules": [
            "When counting professionals who have provided treatments: count distinct \"professional_id\" values instead of counting all rows to get unique professionals.",
            "When accessing treatment-related information: use the \"Treatments\" table as the data source instead of the \"professionals\" table.",
            "When counting professionals who have provided treatments, When accessing treatment-related information, When the question asks about professionals who have \"ever treated dogs\": do not apply any filtering conditions since we want to count all professionals who have provided any treatments."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM professionals WHERE pet_type = 'dog';",
            "SELECT COUNT(DISTINCT professional_id) FROM Treatments;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT professional_id) FROM Treatments;"
        ]
    },
    "970": {
        "db_id": "dog_kennels",
        "question": "Which professionals live in a city containing the substring 'West'? List his or her role, street, city and state.",
        "ground_truth": "SELECT role_code ,  street ,  city ,  state FROM professionals WHERE city LIKE '%West%'",
        "amends": [
            "Do use `role_code` instead of `role` in the SELECT list to reference the correct column name. The amended query now matches RIGHT_SQL's behavior by selecting the appropriate column while maintaining the same filtering logic."
        ],
        "rules": [
            "When the question asks for \"role\" from the Professionals table: use the exact column name \"role_code\" instead of \"role\" in the output.",
            "When filtering for cities containing the substring 'West': use the exact literal 'West' with case sensitivity and the LIKE operator pattern '%West%' to match any city containing this substring.",
            "When the question asks for \"role\" from the Professionals table, When filtering for cities containing the substring 'West', When selecting output columns for professionals: maintain the order role_code, street, city, state as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT role, street, city, state FROM professionals WHERE city LIKE '%West%';",
            "SELECT role_code, street, city, state FROM Professionals WHERE city LIKE '%West%';"
        ],
        "rule_sql": [
            "SELECT role_code, street, city, state FROM Professionals WHERE city LIKE '%West%';"
        ]
    },
    "971": {
        "db_id": "dog_kennels",
        "question": "Find the role, street, city and state of the professionals living in a city that contains the substring 'West'.",
        "ground_truth": "SELECT role_code ,  street ,  city ,  state FROM professionals WHERE city LIKE '%West%'",
        "amends": [
            "Do use `role_code` instead of `role` in the SELECT list to reference the correct column name. The amended query now matches RIGHT_SQL's behavior by selecting the appropriate column while maintaining the same filtering logic."
        ],
        "rules": [
            "When the question asks for \"role\": use the exact column name \"role_code\" from the Professionals table instead of \"role\".",
            "When the question asks for \"role\", When filtering for cities containing the substring 'West': use the exact literal 'West' with case sensitivity and apply pattern matching to find cities containing this substring anywhere in their name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT role, street, city, state FROM professionals WHERE city LIKE '%West%';",
            "SELECT role_code, street, city, state FROM Professionals WHERE city LIKE '%West%'"
        ],
        "rule_sql": [
            "SELECT role_code, street, city, state FROM Professionals WHERE city LIKE '%West%';"
        ]
    },
    "972": {
        "db_id": "dog_kennels",
        "question": "Which owners live in the state whose name contains the substring 'North'? List his first name, last name and email.",
        "ground_truth": "SELECT first_name ,  last_name ,  email_address FROM Owners WHERE state LIKE '%North%'",
        "amends": [
            "Do use `email_address` instead of `email` in the SELECT list. Do reference the table as `Owners` instead of `owners` to match the correct case. The amended query now correctly selects the appropriate email column and maintains proper table reference casing to match the intended behavior."
        ],
        "rules": [
            "When the question asks for email information: use the exact column name \"email_address\" instead of \"email\" from the Professionals table.",
            "When referencing the owners table: use the exact table name \"Owners\" with proper case instead of \"owners\".",
            "When the question asks for email information, When referencing the owners table, When the question mentions \"state whose name contains the substring 'North'\": use the exact literal '%North%' with proper case and percentage wildcards for pattern matching."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name, email FROM owners WHERE state LIKE '%North%';",
            "SELECT first_name, last_name, email_address FROM Owners WHERE state LIKE '%North%';"
        ],
        "rule_sql": [
            "SELECT first_name, last_name, email_address FROM Owners WHERE state LIKE '%North%';"
        ]
    },
    "973": {
        "db_id": "dog_kennels",
        "question": "Return the first name, last name and email of the owners living in a state whose name contains the substring 'North'.",
        "ground_truth": "SELECT first_name ,  last_name ,  email_address FROM Owners WHERE state LIKE '%North%'",
        "amends": [
            "Do reference `email_address` instead of `email` in the SELECT list. Do use the correct table name `Owners` instead of `owners` in the FROM clause. The amended query now correctly retrieves the email address field from the Owners table with proper case sensitivity and matches the intended behavior."
        ],
        "rules": [
            "When the question asks for \"email\": use the exact column name \"email_address\" from the Professionals table instead.",
            "When referencing the owners table: use the exact table name \"Owners\" with proper case sensitivity.",
            "When the question asks for \"email\", When referencing the owners table, When the question mentions \"owners living in a state whose name contains the substring 'North'\": filter rows where the state column contains the literal substring 'North' exactly as specified."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name, email FROM owners WHERE state LIKE '%North%';",
            "SELECT first_name, last_name, email_address FROM Owners WHERE state LIKE '%North%';"
        ],
        "rule_sql": [
            "SELECT first_name, last_name, email_address FROM Owners WHERE state LIKE '%North%';"
        ]
    },
    "974": {
        "db_id": "dog_kennels",
        "question": "How many dogs have an age below the average?",
        "ground_truth": "SELECT count(*) FROM Dogs WHERE age  <  ( SELECT avg(age) FROM Dogs )",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM dogs WHERE age < (SELECT AVG(age) FROM dogs WHERE age IS NOT NULL);"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS count_dogs_below_avg_age\nFROM Dogs\nWHERE CAST(age AS REAL) < (SELECT AVG(CAST(age AS REAL)) FROM Dogs WHERE age IS NOT NULL AND age != '');"
        ]
    },
    "975": {
        "db_id": "dog_kennels",
        "question": "Count the number of dogs of an age below the average.",
        "ground_truth": "SELECT count(*) FROM Dogs WHERE age  <  ( SELECT avg(age) FROM Dogs )",
        "amends": [
            "Do use the comparison operator `<` instead of `>` in the WHERE filter. Do maintain the same aggregate function `AVG(age)` in the subquery instead of changing it. Do preserve the table name `Dogs` with consistent casing instead of using different case variations. Do keep the same structure with a correlated subquery filtering the main table instead of altering the approach. The amended query now correctly counts dogs younger than the average age instead of those older than average, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When counting dogs with age below average: use the comparison operator `<` instead of `>` in the filter condition.",
            "When computing the average age: maintain the aggregate function `AVG(age)` in the subquery without changing it.",
            "When referring to the table: preserve the table name `Dogs` with consistent casing throughout the query.",
            "When counting dogs with age below average, When computing the average age, When referring to the table, When structuring the query: keep the same structure with a correlated subquery filtering the main table instead of altering the approach."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM dogs WHERE age > (SELECT AVG(age) FROM dogs);",
            "SELECT COUNT(*) \nFROM Dogs \nWHERE age < (SELECT AVG(age) FROM Dogs)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Dogs WHERE age < (SELECT AVG(age) FROM Dogs);"
        ]
    },
    "976": {
        "db_id": "dog_kennels",
        "question": "How much does the most recent treatment cost?",
        "ground_truth": "SELECT cost_of_treatment FROM Treatments ORDER BY date_of_treatment DESC LIMIT 1",
        "amends": [
            "Do select `cost_of_treatment` instead of using `MAX(cost)` aggregation. Do reference table `Treatments` instead of `treatments`. Do order by `date_of_treatment` instead of `date`. Do remove the unnecessary aggregation function and instead directly select the column value while maintaining the same ordering and limiting behavior to retrieve the most recent treatment cost."
        ],
        "rules": [
            "When the question asks for the cost of the most recent treatment: select \"cost_of_treatment\" from table \"Treatments\" instead of using MAX(cost) aggregation.",
            "When ordering by treatment date to find the most recent: order by \"date_of_treatment\" in descending order instead of \"date\".",
            "When the question asks for the cost of the most recent treatment, When ordering by treatment date to find the most recent, When retrieving the single most recent treatment: limit the result to 1 row after ordering by \"date_of_treatment\" descending."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(cost) FROM treatments ORDER BY date DESC LIMIT 1;",
            "SELECT cost_of_treatment FROM Treatments ORDER BY date_of_treatment DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT cost_of_treatment FROM Treatments ORDER BY date_of_treatment DESC LIMIT 1;"
        ]
    },
    "977": {
        "db_id": "dog_kennels",
        "question": "Show me the cost of the most recently performed treatment.",
        "ground_truth": "SELECT cost_of_treatment FROM Treatments ORDER BY date_of_treatment DESC LIMIT 1",
        "amends": [
            "Do reference the column `cost_of_treatment` instead of `cost` in the SELECT list. Do reference the column `date_of_treatment` instead of `treatment_date` in the ORDER BY clause. The amended query now correctly retrieves the most recent treatment cost using the proper column names from the Treatments table."
        ],
        "rules": [
            "When the question asks for \"cost of treatment\": use the exact column name \"cost_of_treatment\" from the Treatments table.",
            "When ordering by treatment date to find the most recent treatment: use the exact column name \"date_of_treatment\" from the Treatments table and sort in descending order.",
            "When the question asks for \"cost of treatment\", When ordering by treatment date to find the most recent treatment, When retrieving the single most recent treatment: take only the first row after ordering by date_of_treatment in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT cost FROM treatments ORDER BY treatment_date DESC LIMIT 1;",
            "SELECT cost_of_treatment FROM Treatments ORDER BY date_of_treatment DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT cost_of_treatment FROM Treatments ORDER BY date_of_treatment DESC LIMIT 1;"
        ]
    },
    "978": {
        "db_id": "dog_kennels",
        "question": "How many dogs have not gone through any treatment?",
        "ground_truth": "SELECT count(*) FROM Dogs WHERE dog_id NOT IN ( SELECT dog_id FROM Treatments )",
        "amends": [
            "Do use `count(*)` instead of `COUNT(*)` for consistency. Do reference the table as `Dogs` instead of `dogs` to match the correct case. Do change the filter to `dog_id NOT IN (subquery)` instead of `treatment_id IS NULL` to properly identify dogs without treatments. Do add a subquery `SELECT dog_id FROM Treatments` instead of omitting it, which correctly identifies dogs that have received treatments. The amended query now matches RIGHT_SQL's behavior by accurately counting dogs that have never received any treatment."
        ],
        "rules": [
            "When counting entities: use count(*) instead of COUNT(*) for consistency.",
            "When referencing the Dogs table: use exact case \"Dogs\" instead of \"dogs\".",
            "When identifying dogs without treatments: use dog_id NOT IN (subquery) instead of treatment_id IS NULL.",
            "When creating the subquery for treatments: select dog_id FROM Treatments to identify dogs that have received treatments.",
            "When counting entities, When referencing the Dogs table, When identifying dogs without treatments, When creating the subquery for treatments, When counting dogs without any treatment: ensure the query accurately counts dogs that have never received any treatment by excluding those found in the Treatments subquery."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM dogs WHERE treatment_id IS NULL;",
            "SELECT count(*) FROM Dogs WHERE dog_id NOT IN (SELECT dog_id FROM Treatments)"
        ],
        "rule_sql": [
            "SELECT count(*) FROM Dogs WHERE dog_id NOT IN (SELECT dog_id FROM Treatments)"
        ]
    },
    "979": {
        "db_id": "dog_kennels",
        "question": "Tell me the number of dogs that have not received any treatment .",
        "ground_truth": "select count(*) from dogs where dog_id not in ( select dog_id from treatments )",
        "amends": [
            "Do use a subquery with `dog_id not in (select dog_id from treatments)` instead of checking `treatment_id IS NULL` directly. Do reference the `treatments` table instead of omitting it from the query structure. Do filter based on the absence of records in the treatments table instead of relying on a potentially incorrect NULL check in the dogs table. The amended query now correctly identifies dogs that have never received any treatment by checking for their absence in the treatments table, matching the right SQL's behavior."
        ],
        "rules": [
            "When counting dogs that have not received any treatment: use a subquery to check for dog_id values that are not present in the treatments table instead of checking for NULL values in the dogs table.",
            "When combining information about dogs and treatments: reference both the dogs table and treatments table, filtering based on absence of records in the treatments table.",
            "When counting dogs that have not received any treatment, When combining information about dogs and treatments, When identifying dogs without treatments: use the exact identifier \"dog_id\" to match between the dogs table and treatments table subquery."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM dogs WHERE treatment_id IS NULL;",
            "SELECT COUNT(*) \nFROM Dogs \nWHERE dog_id NOT IN (SELECT dog_id FROM Treatments)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS number_of_dogs_without_treatment\nFROM Dogs d\nWHERE d.dog_id NOT IN (SELECT dog_id FROM Treatments)"
        ]
    },
    "980": {
        "db_id": "dog_kennels",
        "question": "How many owners temporarily do not have any dogs?",
        "ground_truth": "SELECT count(*) FROM Owners WHERE owner_id NOT IN ( SELECT owner_id FROM Dogs )",
        "amends": [
            "Do use a subquery with `NOT IN` filtering on `owner_id` instead of checking for `dog_id IS NULL`. Do reference the `Owners` table (capitalized) instead of `owners`. Do count all rows from the filtered result set instead of counting rows where a non-existent `dog_id` column would be null. The amended query now correctly identifies owners who do not have any dogs by checking for `owner_id` values that are not present in the Dogs table, rather than relying on a potentially non-existent or incorrectly named column."
        ],
        "rules": [
            "When the question asks about owners without dogs: use the \"Owners\" table (capitalized) instead of \"owners\".",
            "When identifying owners who temporarily do not have any dogs: find owner_id values from Owners that are not present in the Dogs table's owner_id column.",
            "When the question asks about owners without dogs, When identifying owners who temporarily do not have any dogs, When counting owners without dogs: count all rows from the filtered result set where owner_id is not in the Dogs table's owner_id values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM owners WHERE dog_id IS NULL;",
            "SELECT COUNT(*) FROM Owners WHERE owner_id NOT IN (SELECT DISTINCT owner_id FROM Dogs)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Owners WHERE owner_id NOT IN (SELECT owner_id FROM Dogs)"
        ]
    },
    "981": {
        "db_id": "dog_kennels",
        "question": "Find the number of owners who do not own any dogs at this moment.",
        "ground_truth": "SELECT count(*) FROM Owners WHERE owner_id NOT IN ( SELECT owner_id FROM Dogs )",
        "amends": [
            "Do use a subquery with `NOT IN` to find owners without dogs instead of checking for `dog_id IS NULL` which incorrectly assumes a direct relationship. Do reference `owner_id` in both the main query and subquery instead of using `dog_id` which doesn't exist in the owners table. Do select from the `Dogs` table in the subquery to identify owners who have dogs instead of omitting this necessary join logic. The amended query now correctly identifies owners without any dogs by checking which owner_ids are not present in the Dogs table, matching the right SQL's behavior."
        ],
        "rules": [
            "When counting owners who do not own any dogs: use a subquery to find owner_ids that are not present in the Dogs table instead of checking for NULL values.",
            "When referencing owners: use the exact identifier \"owner_id\" from the Owners table as the counting key.",
            "When checking for owners without dogs: compare \"owner_id\" from Owners against \"owner_id\" in the Dogs table using a NOT IN condition.",
            "When counting owners who do not own any dogs, When referencing owners, When checking for owners without dogs, When selecting from the Dogs table in the subquery: use the exact column \"owner_id\" to identify which owners currently have dogs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM owners WHERE dog_id IS NULL;",
            "SELECT COUNT(*) FROM Owners WHERE owner_id NOT IN (SELECT DISTINCT owner_id FROM Dogs)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Owners \nWHERE owner_id NOT IN (SELECT owner_id FROM Dogs)"
        ]
    },
    "982": {
        "db_id": "dog_kennels",
        "question": "How many professionals did not operate any treatment on dogs?",
        "ground_truth": "SELECT count(*) FROM Professionals WHERE professional_id NOT IN ( SELECT professional_id FROM Treatments )",
        "amends": [
            "Do remove the `WHERE animal_type = 'dog'` filter from the subquery instead of keeping it, as the correct logic requires checking for professionals not in any treatments regardless of animal type. Do use consistent table name casing `Professionals` instead of `professionals` to match the schema. The amended query now correctly counts professionals who have not provided any treatments, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks about professionals who did not operate any treatment: check for professionals not in any treatments regardless of animal type, not just treatments for dogs.",
            "When referring to the Professionals table: use the exact identifier \"Professionals\" with proper casing as shown in the schema.",
            "When the question asks about professionals who did not operate any treatment, When referring to the Professionals table, When counting professionals who provided no treatments: use the professional_id as the counting key to identify unique professionals."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM professionals WHERE professional_id NOT IN (SELECT professional_id FROM treatments WHERE animal_type = 'dog')",
            "SELECT COUNT(*) \nFROM Professionals p\nLEFT JOIN Treatments t ON p.professional_id = t.professional_id\nWHERE t.treatment_id IS NULL;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Professionals p\nWHERE p.professional_id NOT IN (\n    SELECT DISTINCT professional_id \n    FROM Treatments\n)"
        ]
    },
    "983": {
        "db_id": "dog_kennels",
        "question": "Find the number of professionals who have not treated any dogs.",
        "ground_truth": "SELECT count(*) FROM Professionals WHERE professional_id NOT IN ( SELECT professional_id FROM Treatments )",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM professionals WHERE professional_id NOT IN (SELECT professional_id FROM treatments)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS number_of_professionals_without_treatments\nFROM Professionals p\nLEFT JOIN Treatments t ON p.professional_id = t.professional_id\nWHERE t.treatment_id IS NULL;"
        ]
    },
    "984": {
        "db_id": "dog_kennels",
        "question": "List the dog name, age and weight of the dogs who have been abandoned? 1 stands for yes, and 0 stands for no.",
        "ground_truth": "SELECT name ,  age ,  weight FROM Dogs WHERE abandoned_yn  =  1",
        "amends": [
            "Do use table name `Dogs` instead of `dogs` to match the correct schema. Do change the filter condition to `abandoned_yn = 1` instead of `abandoned = 0`, using the correct column name and value that properly identifies abandoned dogs. The amended query now correctly selects non-abandoned dogs by checking the abandoned_yn flag set to 1, matching the intended behavior of the RIGHT_SQL."
        ],
        "rules": [
            "When the question mentions \"dogs\": use the exact table name \"Dogs\" with capital D as shown in the schema.",
            "When identifying abandoned dogs: use the column \"abandoned_yn\" with value 1 (not",
            "to properly identify abandoned status.",
            "When the question mentions \"dogs\", When identifying abandoned dogs, to properly identify abandoned status., When selecting dog attributes: output the columns \"name\", \"age\", and \"weight\" in that exact order as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, age, weight FROM dogs WHERE abandoned = 0;",
            "SELECT name, age, weight FROM Dogs WHERE abandoned_yn = '1';"
        ],
        "rule_sql": [
            "SELECT name, age, weight FROM Dogs WHERE abandoned_yn = '1';"
        ]
    },
    "985": {
        "db_id": "dog_kennels",
        "question": "What are the dog name, age and weight of the dogs that were abandoned? Note that 1 stands for yes, and 0 stands for no in the tables.",
        "ground_truth": "SELECT name ,  age ,  weight FROM Dogs WHERE abandoned_yn  =  1",
        "amends": [
            "Do reference table `Dogs` instead of `dogs` to match the correct table name. Do change the filter condition to `abandoned_yn = 1` instead of `abandoned = 0` to use the correct column name and value for identifying abandoned dogs. The amended query now correctly selects non-abandoned dogs from the Dogs table."
        ],
        "rules": [
            "When the question mentions \"dogs\": use the exact table name \"Dogs\" with proper case.",
            "When identifying abandoned dogs: use the column \"abandoned_yn\" and the value 1 (not",
            "to match the schema's representation where 1 means yes/abandoned.",
            "When the question mentions \"dogs\", When identifying abandoned dogs, to match the schema's representation where 1 means yes/abandoned., When selecting dog attributes: output the columns \"name\", \"age\", and \"weight\" in that order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, age, weight FROM dogs WHERE abandoned = 0;",
            "SELECT name, age, weight FROM Dogs WHERE abandoned_yn = '1';"
        ],
        "rule_sql": [
            "SELECT name, age, weight FROM Dogs WHERE abandoned_yn = '1';"
        ]
    },
    "986": {
        "db_id": "dog_kennels",
        "question": "What is the average age of all the dogs?",
        "ground_truth": "SELECT avg(age) FROM Dogs",
        "amends": [
            "Do select `avg(age)` instead of `AVG(height)` to calculate the average age rather than height. Do reference the table as `Dogs` instead of `dogs` to match the correct case sensitivity. The amended query now correctly calculates the average age from the Dogs table."
        ],
        "rules": [
            "When the question asks for \"average age of all the dogs\": calculate the average of the \"age\" column instead of \"height\".",
            "When the question asks for \"average age of all the dogs\", When referencing the table containing dog information: use the exact table name \"Dogs\" with proper case sensitivity as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(height) FROM dogs;",
            "SELECT AVG(age) FROM Dogs;"
        ],
        "rule_sql": [
            "SELECT AVG(age) AS average_age FROM Dogs;"
        ]
    },
    "987": {
        "db_id": "dog_kennels",
        "question": "Compute the average age of all the dogs.",
        "ground_truth": "SELECT avg(age) FROM Dogs",
        "amends": [
            "Do reference table `Dogs` instead of `cats` to query the correct data source, and do use lowercase `avg` function instead of uppercase `AVG` for consistent function naming, though this is a cosmetic change that does not affect functionality. The amended query now correctly calculates the average age from the Dogs table instead of the cats table."
        ],
        "rules": [
            "When answering about \"average age of all the dogs\": use table \"Dogs\" as the data source instead of \"cats\".",
            "When answering about \"average age of all the dogs\", When computing the average age: use the lowercase \"avg\" function for consistent naming convention."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age) FROM cats;",
            "SELECT avg(age) FROM Dogs;"
        ],
        "rule_sql": [
            "SELECT avg(age) FROM Dogs;"
        ]
    },
    "988": {
        "db_id": "dog_kennels",
        "question": "What is the age of the oldest dog?",
        "ground_truth": "SELECT max(age) FROM Dogs",
        "amends": [
            "Do use `max(age)` instead of `MIN(age)` to find the maximum age instead of the minimum age. Do capitalize `Dogs` instead of `dogs` to match the correct table name case. The amended query now correctly returns the maximum age from the Dogs table instead of the minimum age."
        ],
        "rules": [
            "When the question asks for the \"oldest\" dog: use max(age) instead of min(age) to find the maximum age.",
            "When the question asks for the \"oldest\" dog, When referring to the table containing dog information: use the exact table name \"Dogs\" with capital D, not \"dogs\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(age) FROM dogs;",
            "SELECT MAX(age) FROM Dogs;"
        ],
        "rule_sql": [
            "SELECT MAX(age) AS oldest_age FROM Dogs;"
        ]
    },
    "989": {
        "db_id": "dog_kennels",
        "question": "Tell me the age of the oldest dog.",
        "ground_truth": "SELECT max(age) FROM Dogs",
        "amends": [
            "Do use `max(age)` instead of `MIN(age)` to calculate the maximum age instead of the minimum age. Do capitalize `Dogs` instead of `dogs` to match the proper table name casing. The amended query now correctly returns the maximum age from the Dogs table instead of the minimum age."
        ],
        "rules": [
            "When the question asks for the \"oldest\" dog: use max(age) instead of min(age) to find the maximum age.",
            "When the question asks for the \"oldest\" dog, When referring to the table containing dog information: use the exact table name \"Dogs\" with proper capitalization as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(age) FROM dogs;",
            "SELECT MAX(age) FROM Dogs;"
        ],
        "rule_sql": [
            "SELECT MAX(age) AS oldest_age FROM Dogs;"
        ]
    },
    "990": {
        "db_id": "dog_kennels",
        "question": "How much does each charge type costs? List both charge type and amount.",
        "ground_truth": "SELECT charge_type ,  charge_amount FROM Charges",
        "amends": [
            "Do select `charge_amount` instead of using `SUM(amount)` aggregate function. Do remove the `GROUP BY charge_type` clause instead of keeping it, as the right query retrieves individual records rather than aggregated totals. The amended query now directly selects the charge_amount column from the Charges table without aggregation, matching the right SQL's behavior of returning individual charge records."
        ],
        "rules": [
            "When the question asks for charge type costs and lists both charge type and amount: select individual charge records with exact column names \"charge_type\" and \"charge_amount\" instead of using aggregate functions.",
            "When retrieving individual charge records: do not use GROUP BY clauses or aggregation functions like SUM().",
            "When the question asks for charge type costs and lists both charge type and amount, When retrieving individual charge records, When selecting charge amounts: use the exact column name \"charge_amount\" as specified in the schema, not generic names like \"amount\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT charge_type, SUM(amount) FROM charges GROUP BY charge_type;",
            "SELECT charge_type, charge_amount FROM Charges;"
        ],
        "rule_sql": [
            "SELECT charge_type, charge_amount FROM Charges;"
        ]
    },
    "991": {
        "db_id": "dog_kennels",
        "question": "List each charge type and its amount.",
        "ground_truth": "SELECT charge_type ,  charge_amount FROM Charges",
        "amends": [
            "Do select the `charge_amount` column directly instead of using `SUM(amount)` aggregation. Do reference the table as `Charges` instead of `charges` with proper case sensitivity. Do remove the `GROUP BY charge_type` clause instead of keeping it since no aggregation is needed. The amended query now correctly retrieves individual charge records with their type and amount values rather than attempting to sum amounts by type."
        ],
        "rules": [
            "When the question asks to list charge types and amounts: select the exact column \"charge_amount\" from table \"Charges\" without any aggregation.",
            "When referencing the table name: use exact case-sensitive identifier \"Charges\" instead of lowercase \"charges\".",
            "When no aggregation is requested: do not use GROUP BY clauses or aggregate functions like SUM().",
            "When the question asks to list charge types and amounts, When referencing the table name, When no aggregation is requested, When retrieving individual records: return each charge record with its type and amount values directly from the table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT charge_type, SUM(amount) FROM charges GROUP BY charge_type",
            "SELECT charge_type, charge_amount FROM Charges;"
        ],
        "rule_sql": [
            "SELECT charge_type, charge_amount FROM Charges;"
        ]
    },
    "992": {
        "db_id": "dog_kennels",
        "question": "How much does the most expensive charge type costs?",
        "ground_truth": "SELECT max(charge_amount) FROM Charges",
        "amends": [
            "Do select `max(charge_amount)` instead of `MIN(cost)` to use the maximum aggregation function on the correct column. Do reference table `Charges` instead of `charge_types` to query from the appropriate data source. The amended query now correctly retrieves the maximum charge amount from the Charges table instead of attempting to find the minimum cost from an incorrect table."
        ],
        "rules": [
            "When the question asks for the \"most expensive charge type\": use the maximum aggregation function on the charge_amount column.",
            "When referencing the charge amount data: query from the \"Charges\" table instead of \"charge_types\".",
            "When the question asks for the \"most expensive charge type\", When referencing the charge amount data, When computing the maximum charge amount: use max(charge_amount) instead of MIN(cost) to correctly find the highest value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(cost) FROM charge_types;",
            "SELECT MAX(charge_amount) FROM Charges;"
        ],
        "rule_sql": [
            "SELECT MAX(charge_amount) AS most_expensive_charge FROM Charges;"
        ]
    },
    "993": {
        "db_id": "dog_kennels",
        "question": "What is the charge amount of the most expensive charge type?",
        "ground_truth": "SELECT max(charge_amount) FROM Charges",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(charge_amount) FROM charges WHERE charge_type = (SELECT charge_type FROM charges ORDER BY charge_amount DESC LIMIT 1);"
        ],
        "rule_sql": [
            "SELECT charge_amount FROM Charges ORDER BY charge_amount DESC LIMIT 1;"
        ]
    },
    "994": {
        "db_id": "dog_kennels",
        "question": "List the email, cell phone and home phone of all the professionals.",
        "ground_truth": "SELECT email_address ,  cell_number ,  home_phone FROM professionals",
        "amends": [
            "Do select `email_address`, `cell_number`, and `home_phone` instead of `email` and `cell_phone`, adding the `home_phone` column instead of omitting it. The amended query now matches RIGHT_SQL's behavior by including all three specified columns from the professionals table."
        ],
        "rules": [
            "When the question asks for \"email\": use the exact column name \"email_address\" from the Professionals table.",
            "When the question asks for \"cell phone\": use the exact column name \"cell_number\" from the Professionals table.",
            "When the question asks for \"home phone\": use the exact column name \"home_phone\" from the Professionals table.",
            "When the question asks for \"email\", When the question asks for \"cell phone\", When the question asks for \"home phone\", When answering about \"List the email, cell phone and home phone of all the professionals\": make sure the output order: email_address, cell_number, home_phone."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT email, cell_phone FROM professionals;",
            "SELECT email_address, cell_number, home_phone FROM Professionals;"
        ],
        "rule_sql": [
            "SELECT email_address, cell_number, home_phone FROM Professionals;"
        ]
    },
    "995": {
        "db_id": "dog_kennels",
        "question": "What are the email, cell phone and home phone of each professional?",
        "ground_truth": "SELECT email_address ,  cell_number ,  home_phone FROM professionals",
        "amends": [
            "Do select `email_address`, `cell_number`, and `home_phone` instead of `email` and `cell_phone`, adding the `home_phone` column instead of omitting it. The amended query now matches the right SQL's behavior by including all three specified columns from the professionals table."
        ],
        "rules": [
            "When the question asks for \"email\": use the exact column name \"email_address\" from the Professionals table.",
            "When the question asks for \"cell phone\": use the exact column name \"cell_number\" from the Professionals table.",
            "When the question asks for \"home phone\": use the exact column name \"home_phone\" from the Professionals table.",
            "When the question asks for \"email\", When the question asks for \"cell phone\", When the question asks for \"home phone\", When answering about \"email, cell phone and home phone of each professional\": make sure the output order: email_address, cell_number, home_phone."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT email, cell_phone FROM professionals;",
            "SELECT email_address, cell_number, home_phone FROM Professionals;"
        ],
        "rule_sql": [
            "SELECT email_address, cell_number, home_phone FROM Professionals;"
        ]
    },
    "996": {
        "db_id": "dog_kennels",
        "question": "What are all the possible breed type and size type combinations?",
        "ground_truth": "SELECT DISTINCT breed_code ,  size_code FROM dogs",
        "amends": [
            "Do select `breed_code` and `size_code` instead of `breed_type` and `size_type`. Do use `DISTINCT` instead of `GROUP BY breed_type, size_type`. The amended query now correctly retrieves unique combinations of breed_code and size_code from the dogs table."
        ],
        "rules": [
            "When the question asks for breed type and size type combinations: use \"breed_code\" and \"size_code\" columns from the Dogs table instead of \"breed_type\" and \"size_type\".",
            "When retrieving all possible combinations of two columns: use DISTINCT to get unique pairs of values from \"breed_code\" and \"size_code\".",
            "When the question asks for breed type and size type combinations, When retrieving all possible combinations of two columns, When the question asks for combinations without aggregation: do not use GROUP BY, use DISTINCT on the column pair instead."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT breed_type, size_type FROM dogs GROUP BY breed_type, size_type;",
            "SELECT DISTINCT breed_code, size_code FROM Dogs;"
        ],
        "rule_sql": [
            "SELECT DISTINCT breed_code, size_code FROM Dogs;"
        ]
    },
    "997": {
        "db_id": "dog_kennels",
        "question": "Find the distinct breed type and size type combinations for dogs.",
        "ground_truth": "SELECT DISTINCT breed_code ,  size_code FROM dogs",
        "amends": [
            "Do select `breed_code` and `size_code` instead of `breed` and `size`. Do use `DISTINCT` instead of `GROUP BY breed, size`. The amended query now matches the right SQL's behavior by selecting distinct breed and size codes rather than grouping by the original columns."
        ],
        "rules": [
            "When the question asks for distinct breed type and size type combinations: use DISTINCT instead of GROUP BY to get unique combinations.",
            "When selecting breed type information: use the exact column token \"breed_code\" instead of \"breed\".",
            "When selecting size type information: use the exact column token \"size_code\" instead of \"size\".",
            "When the question asks for distinct breed type and size type combinations, When selecting breed type information, When selecting size type information, When outputting the results: maintain the column order as breed_code followed by size_code."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT breed, size FROM dogs GROUP BY breed, size",
            "SELECT DISTINCT breed_code, size_code FROM Dogs;"
        ],
        "rule_sql": [
            "SELECT DISTINCT breed_code, size_code FROM Dogs;"
        ]
    },
    "998": {
        "db_id": "dog_kennels",
        "question": "List the first name of all the professionals along with the description of the treatment they have done.",
        "ground_truth": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to remove duplicate rows. Do select `T3.treatment_type_description` instead of `treatment_description` from the correct table. Do add `JOIN Treatment_types AS T3` instead of omitting this necessary table. Do use join condition `T1.professional_id = T2.professional_id` instead of `professionals.id = treatments.professional_id` with proper table aliases. Do add second join condition `T2.treatment_type_code = T3.treatment_type_code` instead of omitting this critical relationship. Do use table aliases `T1`, `T2`, and `T3` instead of no aliases for clarity. The amended query now correctly retrieves distinct professional names with their associated treatment type descriptions through proper table relationships."
        ],
        "rules": [
            "When answering about professionals and their treatment descriptions: make sure the output order: first_name, treatment_type_description",
            "When the question mentions \"professionals\" and \"treatment they have done\": \"professionals\" actually means \"T1\" in schema and \"treatment they have done\" actually means \"T3.treatment_type_description\" in schema",
            "When combining multiple tables for this question: link T1 and T2 where T1.professional_id = T2.professional_id, then link T2 and T3 where T2.treatment_type_code = T3.treatment_type_code, keeping only matching pairs (inner match)",
            "When selecting professional names and treatment descriptions: use DISTINCT to remove duplicate rows",
            "When answering about professionals and their treatment descriptions, When the question mentions \"professionals\" and \"treatment they have done\", When combining multiple tables for this question, When selecting professional names and treatment descriptions, When referring to table roles: use T1 for professionals table, T2 for treatments table, and T3 for Treatment_types table"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, treatment_description FROM professionals JOIN treatments ON professionals.id = treatments.professional_id;",
            "SELECT DISTINCT T1.first_name, T3.treatment_type_description\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nJOIN Treatment_Types AS T3 ON T2.treatment_type_code = T3.treatment_type_code;"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.first_name, T3.treatment_type_description\nFROM Professionals T1\nINNER JOIN Treatments T2 ON T1.professional_id = T2.professional_id\nINNER JOIN Treatment_Types T3 ON T2.treatment_type_code = T3.treatment_type_code\nORDER BY T1.first_name, T3.treatment_type_description"
        ]
    },
    "999": {
        "db_id": "dog_kennels",
        "question": "What are each professional's first name and description of the treatment they have performed?",
        "ground_truth": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code",
        "amends": [
            "Do select `T1.first_name` and `T3.treatment_type_description` instead of `first_name` and `treatment_description`. Do add `DISTINCT` instead of omitting it. Do add `JOIN Treatment_types AS T3` instead of omitting this table. Do change the join condition to `T1.professional_id = T2.professional_id` instead of `professionals.id = treatments.professional_id`. Do add the join condition `T2.treatment_type_code = T3.treatment_type_code` instead of omitting it. The amended query now correctly retrieves distinct professional names with their associated treatment type descriptions by properly joining through the intermediate treatments table to the treatment types reference table."
        ],
        "rules": [
            "When the question asks for \"each professional's first name\": select \"T1\".\"first_name\" exactly as shown in the schema.",
            "When the question asks for \"description of the treatment they have performed\": select \"T3\".\"treatment_type_description\" instead of \"treatment_description\".",
            "When retrieving information about professionals and their treatments: join \"Professionals\" as T1 to \"treatments\" as T2 using \"T1\".\"professional_id\" = \"T2\".\"professional_id\".",
            "When needing treatment type descriptions: join \"Treatment_types\" as T3 to T2 using \"T2\".\"treatment_type_code\" = \"T3\".\"treatment_type_code\".",
            "When the question asks for \"each professional's first name\", When the question asks for \"description of the treatment they have performed\", When retrieving information about professionals and their treatments, When needing treatment type descriptions, When the question asks for \"each professional\": use DISTINCT to ensure each professional appears only once in the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, treatment_description FROM professionals JOIN treatments ON professionals.id = treatments.professional_id",
            "SELECT DISTINCT T1.first_name, T3.treatment_type_description\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nJOIN Treatment_Types AS T3 ON T2.treatment_type_code = T3.treatment_type_code"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.first_name, T3.treatment_type_description\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nJOIN Treatment_Types AS T3 ON T2.treatment_type_code = T3.treatment_type_code;"
        ]
    },
    "1000": {
        "db_id": "singer",
        "question": "How many singers are there?",
        "ground_truth": "SELECT count(*) FROM singer",
        "amends": [
            "Do reference the `singer` table instead of the `songs` table in the FROM clause. Do count records from the correct table instead of the wrong one. The amended query now correctly counts records from the singer table as intended."
        ],
        "rules": [
            "When answering about \"how many singers\": make sure to count records from the \"singer\" table instead of the \"songs\" table.",
            "When answering about \"how many singers\", When counting entities: use the canonical key for counting (typically the primary key of the table being counted)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM songs;",
            "SELECT COUNT(*) FROM singer;"
        ],
        "rule_sql": [
            "SELECT COUNT(Singer_ID) FROM singer;"
        ]
    },
    "1001": {
        "db_id": "singer",
        "question": "What is the count of singers?",
        "ground_truth": "SELECT count(*) FROM singer",
        "amends": [
            "Do reference the `singer` table instead of the `singers` table. Do remove the `WHERE age > 100` filter instead of keeping it. The amended query now correctly counts all records in the singer table without any age restriction, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"count of singers\": use the exact table name \"singer\" instead of \"singers\".",
            "When answering about \"count of singers\", When counting all records in a table: do not apply any WHERE filter conditions unless explicitly specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM singers WHERE age > 100;",
            "SELECT COUNT(*) FROM singer;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM singer;"
        ]
    },
    "1002": {
        "db_id": "singer",
        "question": "List the name of singers in ascending order of net worth.",
        "ground_truth": "SELECT Name FROM singer ORDER BY Net_Worth_Millions ASC",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the correct table name `singer` instead of `singers`. Do order by `Net_Worth_Millions` instead of `net_worth` and use `ASC` ordering instead of `DESC`. The amended query now correctly references the proper column and table names with the intended ascending order by net worth."
        ],
        "rules": [
            "When the question asks for \"name of singers\": use the exact column token \"Name\" from table \"singer\" (not \"name\" from \"singers\").",
            "When ordering by \"net worth\": use the exact column token \"Net_Worth_Millions\" from table \"singer\".",
            "When the question asks for \"name of singers\", When ordering by \"net worth\", When the question specifies \"ascending order\": order the results in ascending (ASC) direction, not descending (DESC)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers ORDER BY net_worth DESC;",
            "SELECT Name FROM singer ORDER BY Net_Worth_Millions ASC;"
        ],
        "rule_sql": [
            "SELECT Name FROM singer ORDER BY Net_Worth_Millions ASC;"
        ]
    },
    "1003": {
        "db_id": "singer",
        "question": "What are the names of singers ordered by ascending net worth?",
        "ground_truth": "SELECT Name FROM singer ORDER BY Net_Worth_Millions ASC",
        "amends": [
            "Do reference the `Name` column instead of `name` to match the correct case sensitivity. Do reference the `singer` table instead of `singers` to use the correct table name. Do order by `Net_Worth_Millions` instead of `net_worth` to use the correct column name for ordering. The amended query now correctly selects from the proper table with accurate column references and ordering criteria."
        ],
        "rules": [
            "When the question asks for singer names: use the exact column \"Name\" from table \"singer\" (not \"name\" or \"singers\").",
            "When ordering singers by net worth: use the exact column \"Net_Worth_Millions\" for ordering in ascending direction.",
            "When the question asks for singer names, When ordering singers by net worth, When selecting from the singer table: use the exact table name \"singer\" (not \"singers\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers ORDER BY net_worth ASC;",
            "SELECT Name FROM singer ORDER BY Net_Worth_Millions ASC;"
        ],
        "rule_sql": [
            "SELECT Name FROM singer ORDER BY Net_Worth_Millions ASC;"
        ]
    },
    "1004": {
        "db_id": "singer",
        "question": "What are the birth year and citizenship of singers?",
        "ground_truth": "SELECT Birth_Year ,  Citizenship FROM singer",
        "amends": [
            "Do reference the table as `singer` instead of `singers` to match the correct table name. Do capitalize column names as `Birth_Year` and `Citizenship` instead of lowercase `birth_year` and `citizenship` to match the correct column naming convention. The WHERE clause remains unchanged as `birth_year > 2000` since the filter logic is correct. The amended query now correctly references the singer table with proper column capitalization.",
            "Do include all records without any filter instead of filtering with `birth_year > 2000` in the WHERE clause. The amended query now matches RIGHT_SQL's behavior by returning all singer records regardless of birth year."
        ],
        "rules": [
            "When the question mentions \"singers\": use the exact table name \"singer\" instead of \"singers\".",
            "When selecting columns \"birth year\" and \"citizenship\": use the exact column names \"Birth_Year\" and \"Citizenship\" with proper capitalization.",
            "When the question mentions \"singers\", When selecting columns \"birth year\" and \"citizenship\", When filtering by birth year greater than 2000: keep the condition \"birth_year > 2000\" unchanged as the filter logic is correct.",
            "When answering about \"birth year and citizenship of singers\": make sure the output order: Birth_Year, Citizenship.",
            "When the question asks for all singers: include all records without any filter condition on birth_year or other columns.",
            "When answering about \"birth year and citizenship of singers\", When the question asks for all singers, When handling the singer table: use the exact column identifiers Birth_Year and Citizenship as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT birth_year, citizenship FROM singers WHERE birth_year > 2000;",
            "SELECT Birth_Year, Citizenship FROM singer WHERE birth_year > 2000",
            "SELECT Birth_Year, Citizenship FROM singer"
        ],
        "rule_sql": [
            "SELECT Birth_Year, Citizenship FROM singer;"
        ]
    },
    "1005": {
        "db_id": "singer",
        "question": "What are the birth years and citizenships of the singers?",
        "ground_truth": "SELECT Birth_Year ,  Citizenship FROM singer",
        "amends": [
            "Do reference the table as `singer` instead of `singers` to match the correct table name. Do capitalize column names as `Birth_Year` and `Citizenship` instead of lowercase `birth_year` and `citizenship` to match the correct column naming convention. The WHERE clause condition `birth_year > 2000` remains unchanged as it correctly filters for records after the year 2000. The amended query now correctly references the intended table and columns while preserving the filtering logic.",
            "Do include all records without any filter instead of applying `WHERE Birth_Year > 2000` which incorrectly restricts the results. The amended query now returns all singers regardless of birth year, matching the right SQL's behavior of showing complete data from the singer table."
        ],
        "rules": [
            "When the question mentions \"singers\": use the exact table name \"singer\" instead of \"singers\".",
            "When selecting birth year and citizenship columns: use the exact column names \"Birth_Year\" and \"Citizenship\" with proper capitalization.",
            "When the question mentions \"singers\", When selecting birth year and citizenship columns, When filtering for birth years after 2000: apply the condition Birth_Year > 2000 to select records born after the year 2000.",
            "When answering about \"birth years and citizenships of the singers\": make sure the output order: Birth_Year, Citizenship",
            "When the question asks for all singers' information: do not apply any filtering conditions on Birth_Year or other columns",
            "When answering about \"birth years and citizenships of the singers\", When the question asks for all singers' information, When selecting from the singer table: include all records without any WHERE clause restrictions"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT birth_year, citizenship FROM singers WHERE birth_year > 2000;",
            "SELECT Birth_Year, Citizenship FROM singer WHERE Birth_Year > 2000",
            "SELECT Birth_Year, Citizenship FROM singer"
        ],
        "rule_sql": [
            "SELECT Birth_Year, Citizenship FROM singer;"
        ]
    },
    "1006": {
        "db_id": "singer",
        "question": "List the name of singers whose citizenship is not \"France\".",
        "ground_truth": "SELECT Name FROM singer WHERE Citizenship != \"France\"",
        "amends": [
            "Do reference the table as `singer` instead of `singers` and use the column name `Name` instead of `name`. Do use the inequality filter `!= \"France\"` instead of the equality filter `= 'France'` and reference the column as `Citizenship` instead of `citizenship`. The amended query now correctly selects names of singers who are not French citizens instead of those who are French citizens."
        ],
        "rules": [
            "When the question asks about singers: use the table name \"singer\" exactly as shown in the schema.",
            "When the question mentions \"name\": use the column \"Name\" from the \"singer\" table.",
            "When the question mentions \"citizenship\": use the column \"Citizenship\" from the \"singer\" table.",
            "When the question asks about singers, When the question mentions \"name\", When the question mentions \"citizenship\", When filtering for singers whose citizenship is not \"France\": use the inequality condition != \"France\" (exact case and quotes) instead of equality."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers WHERE citizenship = 'France';",
            "SELECT Name FROM singer WHERE Citizenship != \"France\";"
        ],
        "rule_sql": [
            "SELECT Name FROM singer WHERE Citizenship != \"France\";"
        ]
    },
    "1007": {
        "db_id": "singer",
        "question": "What are the names of the singers who are not French citizens?",
        "ground_truth": "SELECT Name FROM singer WHERE Citizenship != \"France\"",
        "amends": [
            "Do reference the `Name` column instead of `name` and use table `singer` instead of `singers`. Do filter with `Citizenship != \"France\"` instead of `nationality != 'French'` to match the correct column name and country value format. The amended query now correctly selects from the appropriate table with the proper column references and filter condition."
        ],
        "rules": [
            "When answering about \"names of singers who are not French citizens\": make sure the output order: Name from table singer.",
            "When the question mentions \"singers\": \"singers\" actually means \"singer\" in schema.",
            "When the question mentions \"not French citizens\": \"French citizens\" actually means \"Citizenship = 'France'\" in schema, so filter for Citizenship != \"France\".",
            "When answering about \"names of singers who are not French citizens\", When the question mentions \"singers\", When the question mentions \"not French citizens\", When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for column names like \"Citizenship\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers WHERE nationality != 'French';",
            "SELECT Name FROM singer WHERE Citizenship != \"France\";"
        ],
        "rule_sql": [
            "SELECT \"Name\" FROM \"singer\" WHERE \"Citizenship\" != 'France' ORDER BY \"Name\""
        ]
    },
    "1008": {
        "db_id": "singer",
        "question": "Show the name of singers whose birth year is either 1948 or 1949?",
        "ground_truth": "SELECT Name FROM singer WHERE Birth_Year  =  1948 OR Birth_Year  =  1949",
        "amends": [
            "Do reference the `Name` column instead of `name` to match the correct column name. Do reference the `singer` table instead of `singers` to use the correct table name. Do reference the `Birth_Year` column instead of `birth_year` to match the correct column name. The amended query now correctly selects from the singer table using the proper column names while maintaining the same filtering logic for birth years 1948 and 1949."
        ],
        "rules": [
            "When the question asks for singer names: use the exact column token \"Name\" from the singer table.",
            "When the question mentions birth year: use the exact column token \"Birth_Year\" from the singer table.",
            "When the question specifies birth years 1948 or 1949: filter for rows where \"Birth_Year\" equals exactly 1948 or exactly 1949.",
            "When the question asks for singer names, When the question mentions birth year, When the question specifies birth years 1948 or 1949, When selecting from the singer table: use the exact table name \"singer\" (not \"singers\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers WHERE birth_year = 1948 OR birth_year = 1949;",
            "SELECT Name FROM singer WHERE Birth_Year = 1948 OR Birth_Year = 1949;"
        ],
        "rule_sql": [
            "SELECT Name FROM singer WHERE Birth_Year = 1948 OR Birth_Year = 1949;"
        ]
    },
    "1009": {
        "db_id": "singer",
        "question": "What are the names of the singers whose birth years are either 1948 or 1949?",
        "ground_truth": "SELECT Name FROM singer WHERE Birth_Year  =  1948 OR Birth_Year  =  1949",
        "amends": [
            "Do reference the `Name` column instead of `name` to match the correct column name. Do reference the `singer` table instead of `singers` to use the correct table name. Do reference the `Birth_Year` column instead of `birth_year` to match the correct column name capitalization. The amended query now correctly references the proper table and column names while maintaining the same filtering logic for birth years 1948 and 1949."
        ],
        "rules": [
            "When the question asks for singer names: use the exact column token \"Name\" from the singer table.",
            "When the question mentions birth years: use the exact column token \"Birth_Year\" from the singer table.",
            "When filtering for specific birth years 1948 or 1949: use exact numeric values 1948 and 1949 without quotes.",
            "When the question asks for singer names, When the question mentions birth years, When filtering for specific birth years 1948 or 1949, When referencing the table containing singer information: use the exact table name \"singer\" (singular) not \"singers\" (plural)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers WHERE birth_year = 1948 OR birth_year = 1949;",
            "SELECT Name FROM singer WHERE Birth_Year = 1948 OR Birth_Year = 1949;"
        ],
        "rule_sql": [
            "SELECT Name FROM singer WHERE Birth_Year = 1948 OR Birth_Year = 1949;"
        ]
    },
    "1010": {
        "db_id": "singer",
        "question": "What is the name of the singer with the largest net worth?",
        "ground_truth": "SELECT Name FROM singer ORDER BY Net_Worth_Millions DESC LIMIT 1",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the correct table name `singer` instead of `singers`. Do order by `Net_Worth_Millions DESC` instead of `net_worth ASC` to sort by the correct column name in descending order rather than ascending. The amended query now correctly retrieves the singer with the highest net worth from the proper table structure."
        ],
        "rules": [
            "When the question asks about \"singer\": use the exact table name \"singer\" instead of \"singers\".",
            "When the question asks for \"name\": use the exact column name \"Name\" instead of \"name\".",
            "When the question asks for the \"largest net worth\": use the exact column name \"Net_Worth_Millions\" and sort in descending order instead of ascending order.",
            "When the question asks about \"singer\", When the question asks for \"name\", When the question asks for the \"largest net worth\", When answering about \"the singer with the largest net worth\": make sure the output order: \"Name\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers ORDER BY net_worth ASC LIMIT 1;",
            "SELECT Name FROM singer ORDER BY Net_Worth_Millions DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name FROM singer ORDER BY Net_Worth_Millions DESC LIMIT 1;"
        ]
    },
    "1011": {
        "db_id": "singer",
        "question": "What is the name of the singer who is worth the most?",
        "ground_truth": "SELECT Name FROM singer ORDER BY Net_Worth_Millions DESC LIMIT 1",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the correct table name `singer` instead of `singers`. Do order by `Net_Worth_Millions` instead of `net_worth` to use the proper column name for sorting by net worth in millions. The amended query now correctly selects from the singer table and orders by the appropriate net worth column to match the intended behavior."
        ],
        "rules": [
            "When the question asks about singers: use the exact table name \"singer\" instead of \"singers\".",
            "When selecting the name of a singer: use the exact column name \"Name\" from the singer table.",
            "When ordering by net worth to find the highest value: use the exact column name \"Net_Worth_Millions\" for sorting in descending order.",
            "When the question asks about singers, When selecting the name of a singer, When ordering by net worth to find the highest value, When finding the singer with the highest net worth: take only the first row after ordering by \"Net_Worth_Millions\" in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers ORDER BY net_worth DESC LIMIT 1;",
            "SELECT Name FROM singer ORDER BY Net_Worth_Millions DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name FROM singer ORDER BY Net_Worth_Millions DESC LIMIT 1;"
        ]
    },
    "1012": {
        "db_id": "singer",
        "question": "Show different citizenship of singers and the number of singers of each citizenship.",
        "ground_truth": "SELECT Citizenship ,  COUNT(*) FROM singer GROUP BY Citizenship",
        "amends": [
            "Do reference the `Citizenship` column instead of `citizenship` to match the correct column name. Do group by `Citizenship` instead of `singer_id` to properly aggregate counts by citizenship rather than by individual singers. Do reference the `singer` table instead of `singers` to use the correct table name. The amended query now correctly counts singers grouped by their citizenship rather than producing counts per individual singer ID."
        ],
        "rules": [
            "When the question asks about \"citizenship\": use the exact column name \"Citizenship\" from the singer table.",
            "When counting singers per citizenship: group by \"Citizenship\" and count using the canonical key for singers.",
            "When the question asks for \"number of singers\": compute the count of singers grouped by their citizenship values.",
            "When the question asks about \"citizenship\", When counting singers per citizenship, When the question asks for \"number of singers\", When referencing the table containing singer information: use the exact table name \"singer\" (not \"singers\")."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT citizenship, COUNT(*) FROM singers GROUP BY singer_id;",
            "SELECT Citizenship, COUNT(*) AS Number_of_Singers FROM singer GROUP BY Citizenship;"
        ],
        "rule_sql": [
            "SELECT Citizenship, COUNT(Singer_ID) AS Number_of_Singers FROM singer GROUP BY Citizenship;"
        ]
    },
    "1013": {
        "db_id": "singer",
        "question": "For each citizenship, how many singers are from that country?",
        "ground_truth": "SELECT Citizenship ,  COUNT(*) FROM singer GROUP BY Citizenship",
        "amends": [
            "Do reference the correct table name `singer` instead of `singers` in the FROM clause. Do use the correct column name `Citizenship` instead of `country` in both the SELECT list and GROUP BY clause, ensuring the aggregation aligns with the grouping criteria. Do maintain the COUNT(*) aggregation to preserve the row counting functionality while correcting the underlying table and column references."
        ],
        "rules": [
            "When answering about \"citizenship and count of singers\": make sure the output order: Citizenship, COUNT(*)",
            "When the question mentions \"citizenship\": \"citizenship\" actually means \"Citizenship in schema\"",
            "When the question asks for \"count of singers\": compute the number of rows using the table singer",
            "When the question says \"per citizenship\"/\"by citizenship\": organize results by Citizenship and compute requested aggregates per group",
            "When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms",
            "When answering about \"citizenship and count of singers\", When the question mentions \"citizenship\", When the question asks for \"count of singers\", When the question says \"per citizenship\"/\"by citizenship\", When choosing identifier delimiters, When handling text literals: do not change case, spacing, or punctuation"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT citizenship, COUNT(*) FROM singers GROUP BY country;",
            "SELECT Citizenship, COUNT(*) FROM singer GROUP BY Citizenship;"
        ],
        "rule_sql": [
            "SELECT \"Citizenship\", COUNT(*) FROM \"singer\" GROUP BY \"Citizenship\""
        ]
    },
    "1014": {
        "db_id": "singer",
        "question": "Please show the most common citizenship of singers.",
        "ground_truth": "SELECT Citizenship FROM singer GROUP BY Citizenship ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do use `Citizenship` instead of `citizenship` for the column name and change the table reference to `singer` instead of `singers`. Do order by `COUNT(*) DESC` instead of `count ASC` to find the most common citizenship rather than the least common. Do remove the alias `count` from the SELECT clause instead of keeping it since it's not needed in the final output. Do maintain the `GROUP BY Citizenship` and `LIMIT 1` structure to return the single most frequent citizenship value. The amended query now correctly identifies the most common citizenship among singers rather than the least common."
        ],
        "rules": [
            "When the question asks about \"citizenship\": use the exact column name \"Citizenship\" from the singer table.",
            "When the question asks for \"most common\": order by the count in descending direction to find the highest frequency.",
            "When grouping by citizenship: use \"GROUP BY Citizenship\" to organize results by citizenship values.",
            "When limiting to the single most common result: use \"LIMIT 1\" to return only the top result.",
            "When counting occurrences: use COUNT(*) to count all rows per citizenship group.",
            "When the question asks about \"citizenship\", When the question asks for \"most common\", When grouping by citizenship, When limiting to the single most common result, When counting occurrences, When producing output: return only the citizenship value without any count alias in the final output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT citizenship, COUNT(*) as count FROM singers GROUP BY citizenship ORDER BY count ASC LIMIT 1;",
            "SELECT Citizenship FROM singer GROUP BY Citizenship ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Citizenship FROM singer GROUP BY Citizenship ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "1015": {
        "db_id": "singer",
        "question": "What is the most common singer citizenship ?",
        "ground_truth": "select citizenship from singer group by citizenship order by count(*) desc limit 1",
        "amends": [
            "Do order by `count(*) desc` instead of `count ASC` to find the most common citizenship rather than the least common. Do remove the explicit `COUNT(*) as count` column from the SELECT list instead of including it, as only the citizenship value is needed in the final result. Do keep the `GROUP BY citizenship` and `LIMIT 1` clauses unchanged. The amended query now correctly returns the most frequent citizenship among singers instead of the least frequent."
        ],
        "rules": [
            "When the question asks for \"most common\" or \"highest frequency\": order the results by count in descending order to find the maximum value.",
            "When the question asks for a single most common value: use LIMIT 1 to return only the top result.",
            "When the output should show only the categorical value (not the count): exclude the count column from the final SELECT list.",
            "When the question asks for \"most common\" or \"highest frequency\", When the question asks for a single most common value, When the output should show only the categorical value (not the count), When grouping by a categorical column like citizenship: maintain the GROUP BY clause to organize results by that column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT citizenship, COUNT(*) as count FROM singers GROUP BY citizenship ORDER BY count ASC LIMIT 1;",
            "SELECT Citizenship FROM singer GROUP BY Citizenship ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Citizenship FROM singer GROUP BY Citizenship ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "1016": {
        "db_id": "singer",
        "question": "Show different citizenships and the maximum net worth of singers of each citizenship.",
        "ground_truth": "SELECT Citizenship ,  max(Net_Worth_Millions) FROM singer GROUP BY Citizenship",
        "amends": [
            "Do use column name `Net_Worth_Millions` instead of `net_worth` to match the actual column schema. Do use table name `singer` instead of `singers` to reference the correct table. Do use proper case `Citizenship` instead of `citizenship` for the grouping column to maintain consistency with the schema. The amended query now correctly aggregates maximum net worth by citizenship using the proper table and column names."
        ],
        "rules": [
            "When the question asks about \"citizenships\": use the exact column name \"Citizenship\" from the singer table.",
            "When the question asks about \"net worth\": use the exact column name \"Net_Worth_Millions\" from the singer table.",
            "When the question asks for \"maximum net worth\" grouped by citizenship: compute the maximum value of \"Net_Worth_Millions\" for each distinct value of \"Citizenship\".",
            "When referencing the table containing singer information: use the exact table name \"singer\" (not \"singers\").",
            "When the question asks about \"citizenships\", When the question asks about \"net worth\", When the question asks for \"maximum net worth\" grouped by citizenship, When referencing the table containing singer information, When organizing results by citizenship: group by the \"Citizenship\" column to compute aggregates per citizenship group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT citizenship, MAX(net_worth) FROM singers GROUP BY citizenship;",
            "SELECT Citizenship, MAX(Net_Worth_Millions) AS Max_Net_Worth FROM singer GROUP BY Citizenship;"
        ],
        "rule_sql": [
            "SELECT Citizenship, MAX(Net_Worth_Millions) AS Max_Net_Worth FROM singer GROUP BY Citizenship;"
        ]
    },
    "1017": {
        "db_id": "singer",
        "question": "For each citizenship, what is the maximum net worth?",
        "ground_truth": "SELECT Citizenship ,  max(Net_Worth_Millions) FROM singer GROUP BY Citizenship",
        "amends": [
            "Do use `max(Net_Worth_Millions)` instead of `MIN(net_worth) as max_net_worth` to correctly calculate the maximum value rather than the minimum. Do reference `Citizenship` instead of `citizenship` to match the correct column name. Do remove the alias `max_net_worth` instead of keeping it since the right query doesn't include an alias. Do use table `singer` instead of `people` to query from the correct data source. The amended query now correctly calculates the maximum net worth by citizenship from the appropriate table."
        ],
        "rules": [
            "When answering about maximum net worth per citizenship: use max(Net_Worth_Millions) to calculate the maximum value.",
            "When the question mentions \"citizenship\": \"citizenship\" actually means \"Citizenship\" in schema.",
            "When the question asks for maximum values: do not use aliases in the output.",
            "When answering about maximum net worth per citizenship, When the question mentions \"citizenship\", When the question asks for maximum values, When querying data about singers: use table singer instead of people to access the correct data source."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT citizenship, MIN(net_worth) as max_net_worth FROM people GROUP BY citizenship;",
            "SELECT Citizenship, MAX(Net_Worth_Millions) FROM singer GROUP BY Citizenship;"
        ],
        "rule_sql": [
            "SELECT Citizenship, max(Net_Worth_Millions) FROM singer GROUP BY Citizenship;"
        ]
    },
    "1018": {
        "db_id": "singer",
        "question": "Show titles of songs and names of singers.",
        "ground_truth": "SELECT T2.Title ,  T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID",
        "amends": [
            "Do specify explicit table aliases `T1` and `T2` instead of omitting them. Do use `JOIN` with an explicit `ON T1.Singer_ID = T2.Singer_ID` condition instead of querying a single table without joins. Do reference columns with table aliases as `T2.Title` and `T1.Name` instead of unqualified `title` and `name`. Do query from the `singer` table as `T1` and `song` table as `T2` instead of only the `songs` table. The amended query now correctly joins the singer and song tables to retrieve song titles with corresponding singer names, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"titles of songs and names of singers\": make sure the output order: T2.Title, T1.Name",
            "When combining singer table as T1 and song table as T2: link rows where T1.Singer_ID = T2.Singer_ID and keep only matching pairs (inner match)",
            "When referencing columns from joined tables: always qualify column names with table aliases as T2.Title and T1.Name instead of unqualified column names",
            "When answering about \"titles of songs and names of singers\", When combining singer table as T1 and song table as T2, When referencing columns from joined tables, When querying multiple tables: always specify explicit table aliases T1 for singer table and T2 for song table instead of omitting them"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title, name FROM songs",
            "SELECT T2.Title, T1.Name FROM singer T1 JOIN song T2 ON T1.Singer_ID = T2.Singer_ID"
        ],
        "rule_sql": [
            "SELECT T2.Title, T1.Name FROM singer AS T1 INNER JOIN song AS T2 ON T1.Singer_ID = T2.Singer_ID"
        ]
    },
    "1019": {
        "db_id": "singer",
        "question": "What are the song titles and singer names?",
        "ground_truth": "SELECT T2.Title ,  T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of no aliases. Do reference columns as `T2.Title` and `T1.Name` instead of `title` and `name`. Do join `singer AS T1` to `song AS T2` instead of `songs` to `singers`. Do use the join condition `T1.Singer_ID = T2.Singer_ID` instead of `songs.singer_id = singers.id`. The amended query now correctly matches the intended behavior with proper table references and join conditions."
        ],
        "rules": [
            "When answering about \"song titles and singer names\": make sure the output order: T2.Title, T1.Name",
            "When combining singer and song tables: link rows where T1.Singer_ID = T2.Singer_ID exactly as shown; keep only matching pairs (inner match)",
            "When referring to table roles: use T1 for singer table and T2 for song table as established by the amends",
            "When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms",
            "When answering about \"song titles and singer names\", When combining singer and song tables, When referring to table roles, When choosing identifier delimiters, When handling text literals: do not change case, spacing, or punctuation"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title, name FROM songs JOIN singers ON songs.singer_id = singers.id",
            "SELECT T2.Title, T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID = T2.Singer_ID"
        ],
        "rule_sql": [
            "SELECT T2.\"Title\", T1.\"Name\" FROM \"singer\" T1 INNER JOIN \"song\" T2 ON T1.\"Singer_ID\" = T2.\"Singer_ID\""
        ]
    },
    "1020": {
        "db_id": "singer",
        "question": "Show distinct names of singers that have songs with sales more than 300000.",
        "ground_truth": "SELECT DISTINCT T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID WHERE T2.Sales  >  300000",
        "amends": [
            "Do use `DISTINCT T1.Name` instead of just `name` to eliminate duplicate singer names. Do join `singer AS T1` with `song AS T2` instead of querying only the singers table. Do specify the join condition `ON T1.Singer_ID = T2.Singer_ID` instead of missing the table relationship entirely. Do filter on `T2.Sales > 300000` instead of `sales > 300000` to correctly reference song sales rather than singer sales. The amended query now properly identifies singers who have songs with sales exceeding 300,000, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for \"distinct names of singers\": use DISTINCT T1.Name to eliminate duplicate singer names.",
            "When combining singers and songs tables: link rows where T1.Singer_ID = T2.Singer_ID and keep only matching pairs (inner match).",
            "When filtering for songs with sales more than 300000: apply the condition T2.Sales > 300000 to reference song sales rather than singer sales.",
            "When the question asks for \"distinct names of singers\", When combining singers and songs tables, When filtering for songs with sales more than 300000, When answering about singers with songs meeting criteria: make sure the output order: T1.Name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers WHERE sales > 300000",
            "SELECT DISTINCT T1.Name \nFROM singer AS T1 \nJOIN song AS T2 ON T1.Singer_ID = T2.Singer_ID \nWHERE T2.Sales > 300000"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Name \nFROM singer T1 \nINNER JOIN song T2 ON T1.Singer_ID = T2.Singer_ID \nWHERE T2.Sales > 300000 \nORDER BY T1.Name"
        ]
    },
    "1021": {
        "db_id": "singer",
        "question": "what are the different names of the singers that have sales more than 300000?",
        "ground_truth": "SELECT DISTINCT T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID WHERE T2.Sales  >  300000",
        "amends": [
            "Do use `DISTINCT T1.Name` instead of just `name` to eliminate duplicate singer names. Do join `singer AS T1` with `song AS T2` instead of querying only the `singers` table. Do specify the join condition `ON T1.Singer_ID = T2.Singer_ID` instead of missing the table relationship entirely. Do filter on `T2.Sales > 300000` instead of `sales > 300000` to correctly reference the song sales column rather than an ambiguous or non-existent singers sales column. The amended query now properly identifies singers who have songs with sales exceeding 300,000, matching the intended behavior."
        ],
        "rules": [
            "When answering about \"different names of singers\": make sure to use DISTINCT T1.Name to eliminate duplicate singer names.",
            "When combining singers table (T1) and song table (T2): link rows where T1.Singer_ID = T2.Singer_ID and keep only matching pairs (inner match).",
            "When filtering for songs with sales more than 300000: use T2.Sales > 300000 to reference the song sales column.",
            "When answering about \"different names of singers\", When combining singers table (T1) and song table (T2), When filtering for songs with sales more than 300000, When the question asks for \"different names\": ensure the output shows only unique singer names from T1.Name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers WHERE sales > 300000",
            "SELECT DISTINCT T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID = T2.Singer_ID WHERE T2.Sales > 300000"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Name FROM singer T1 INNER JOIN song T2 ON T1.Singer_ID = T2.Singer_ID WHERE T2.Sales > 300000"
        ]
    },
    "1022": {
        "db_id": "singer",
        "question": "Show the names of singers that have more than one song.",
        "ground_truth": "SELECT T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID GROUP BY T1.Name HAVING COUNT(*)  >  1",
        "amends": [
            "Do add table `song` with a `JOIN` on `singer.Singer_ID = song.Singer_ID` instead of querying only the `singers` table. Do change the source to `singer AS T1` instead of `singers`. Do use `GROUP BY T1.Name` with `HAVING COUNT(*) > 1` instead of filtering `song_count > 1` in the `WHERE` clause. Do select `T1.Name` with proper table qualification instead of just `name`. The amended query now correctly counts songs per singer and filters for those with more than one song, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When answering about \"singers that have more than one song\": make sure the output order: T1.Name",
            "When the question mentions \"singers\": \"singers\" actually means \"singer AS T1\" in schema",
            "When the question mentions \"more than one song\": count songs using COUNT(*) per singer and filter for COUNT(*) > 1",
            "When combining T1 and song for shared entities: link rows where T1.Singer_ID = song.Singer_ID; keep only matching pairs (inner match)",
            "When the question asks for \"names of singers\": select T1.Name with proper table qualification instead of just name",
            "When answering about \"singers that have more than one song\", When the question mentions \"singers\", When the question mentions \"more than one song\", When combining T1 and song for shared entities, When the question asks for \"names of singers\", When the question says \"per singer\"/\"by singer\": organize results by T1.Name and compute requested aggregates per group"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers WHERE song_count > 1;",
            "SELECT T1.Name FROM singer AS T1 JOIN song ON T1.Singer_ID = song.Singer_ID GROUP BY T1.Name HAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T1.Name\nFROM singer AS T1\nINNER JOIN song ON T1.Singer_ID = song.Singer_ID\nGROUP BY T1.Name\nHAVING COUNT(*) > 1\nORDER BY T1.Name"
        ]
    },
    "1023": {
        "db_id": "singer",
        "question": "What are the names of the singers that have more than one songs?",
        "ground_truth": "SELECT T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID GROUP BY T1.Name HAVING COUNT(*)  >  1",
        "amends": [
            "Do join `singer` and `song` tables on `Singer_ID` instead of querying only the `singers` table without proper table relationships. Do use `GROUP BY T1.Name` with `HAVING COUNT(*) > 1` instead of applying the aggregate function `COUNT(songs)` directly in the `WHERE` clause without grouping. Do reference the joined table columns with proper aliases `T1.Name` instead of just `name` from an unspecified source. Do count all rows with `COUNT(*)` instead of attempting to count a specific column `songs` that may not exist in the schema. The amended query now correctly identifies singers who have more than one song by properly joining the related tables and using aggregate filtering in the HAVING clause."
        ],
        "rules": [
            "When answering about \"names of singers that have more than one songs\": make sure the output order: T1.Name",
            "When the question mentions \"singers that have more than one songs\": join table \"singer\" as T1 and table \"song\" as T2 where T1.Singer_ID = T2.Singer_ID and keep only matching pairs (inner match)",
            "When counting songs per singer: organize results by T1.Name and compute COUNT(*) per group",
            "When filtering for singers with more than one song: use HAVING COUNT(*) > 1 instead of WHERE clause for aggregate conditions",
            "When answering about \"names of singers that have more than one songs\", When the question mentions \"singers that have more than one songs\", When counting songs per singer, When filtering for singers with more than one song, When referencing singer names: use T1.Name with exact alias T1 from the joined singer table"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers WHERE COUNT(songs) > 1",
            "SELECT T1.Name \nFROM singer T1\nJOIN song T2 ON T1.Singer_ID = T2.Singer_ID\nGROUP BY T1.Name\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T1.Name \nFROM singer AS T1 \nINNER JOIN song AS T2 ON T1.Singer_ID = T2.Singer_ID \nGROUP BY T1.Name \nHAVING COUNT(*) > 1 \nORDER BY T1.Name"
        ]
    },
    "1024": {
        "db_id": "singer",
        "question": "Show the names of singers and the total sales of their songs.",
        "ground_truth": "SELECT T1.Name ,  sum(T2.Sales) FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID GROUP BY T1.Name",
        "amends": [
            "Do reference `T1.Name` and `sum(T2.Sales)` instead of `singer_name` and `SUM(sales)`. Do join `singer AS T1` with `song AS T2` on `T1.Singer_ID = T2.Singer_ID` instead of querying only the `songs` table. Do group by `T1.Name` instead of `singer_name`. The amended query now correctly aggregates sales by singer name using the proper table relationships."
        ],
        "rules": [
            "When answering about \"names of singers and the total sales of their songs\": make sure the output order: T1.Name, sum(T2.Sales).",
            "When the question mentions \"singers\": \"singers\" actually means \"T1.Name in schema\".",
            "When the question mentions \"total sales\": \"total sales\" actually means \"sum(T2.Sales) in schema\".",
            "When combining T1 and T2 for shared entities: link rows where T1.Singer_ID = T2.Singer_ID; keep only matching pairs (inner match).",
            "When answering about \"names of singers and the total sales of their songs\", When the question mentions \"singers\", When the question mentions \"total sales\", When combining T1 and T2 for shared entities, When the question says \"per singer\"/\"by singer\": organize results by T1.Name and compute sum(T2.Sales) per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT singer_name, SUM(sales) FROM songs GROUP BY singer_name;",
            "SELECT T1.Name, SUM(T2.Sales) FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID = T2.Singer_ID GROUP BY T1.Name"
        ],
        "rule_sql": [
            "SELECT T1.Name, SUM(T2.Sales) \nFROM singer T1 \nJOIN song T2 ON T1.Singer_ID = T2.Singer_ID \nGROUP BY T1.Name"
        ]
    },
    "1025": {
        "db_id": "singer",
        "question": "For each singer name, what is the total sales for their songs?",
        "ground_truth": "SELECT T1.Name ,  sum(T2.Sales) FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID GROUP BY T1.Name",
        "amends": [
            "Do reference `T1.Name` and `sum(T2.Sales)` instead of `singer_name` and `SUM(sales)`. Do join `singer AS T1` with `song AS T2` on `T1.Singer_ID = T2.Singer_ID` instead of querying only the `songs` table. Do use explicit table aliases and proper join conditions instead of omitting the table relationship. The amended query now correctly aggregates sales by singer name through the proper table relationship."
        ],
        "rules": [
            "When answering about \"total sales for each singer name\": make sure the output order: T1.Name, sum(T2.Sales).",
            "When the question mentions \"singer name\": \"singer name\" actually means \"T1.Name in schema\".",
            "When the question mentions \"total sales\": \"total sales\" actually means \"sum(T2.Sales) in schema\".",
            "When combining T1 and T2 for shared entities: link rows where T1.Singer_ID = T2.Singer_ID; keep only matching pairs (inner match).",
            "When answering about \"total sales for each singer name\", When the question mentions \"singer name\", When the question mentions \"total sales\", When combining T1 and T2 for shared entities, When the question says \"per singer name\": organize results by T1.Name and compute sum(T2.Sales) per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT singer_name, SUM(sales) FROM songs GROUP BY singer_name;",
            "SELECT T1.Name, SUM(T2.Sales) \nFROM singer AS T1 \nJOIN song AS T2 ON T1.Singer_ID = T2.Singer_ID \nGROUP BY T1.Name"
        ],
        "rule_sql": [
            "SELECT T1.Name, SUM(T2.Sales) \nFROM singer T1 \nINNER JOIN song T2 ON T1.Singer_ID = T2.Singer_ID \nGROUP BY T1.Name \nORDER BY T1.Name, SUM(T2.Sales)"
        ]
    },
    "1026": {
        "db_id": "singer",
        "question": "List the name of singers that do not have any song.",
        "ground_truth": "SELECT Name FROM singer WHERE Singer_ID NOT IN (SELECT Singer_ID FROM song)",
        "amends": [
            "Do select `Name` from `singer` instead of `name` from `singers`. Do use a `NOT IN` subquery checking for `Singer_ID` values that exist in the `song` table instead of filtering with `song_id IS NULL`. Do reference the correct table name `singer` instead of `singers` and use the proper column `Singer_ID` for the correlation instead of the incorrect `song_id` field. The amended query now correctly identifies singers who have no associated songs by checking for missing relationships in the song table rather than relying on null values, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When the question asks for \"name of singers\": select \"Name\" from table \"singer\" instead of \"name\" from \"singers\".",
            "When identifying singers without songs: use a NOT IN subquery checking for \"Singer_ID\" values that exist in the \"song\" table instead of filtering with \"song_id IS NULL\".",
            "When referencing the singer table: use the correct table name \"singer\" instead of \"singers\".",
            "When the question asks for \"name of singers\", When identifying singers without songs, When referencing the singer table, When correlating between singer and song tables: use the proper column \"Singer_ID\" for the correlation instead of the incorrect \"song_id\" field."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers WHERE song_id IS NULL;",
            "SELECT Name FROM singer WHERE Singer_ID NOT IN (SELECT Singer_ID FROM song)"
        ],
        "rule_sql": [
            "SELECT \"Name\" FROM \"singer\" WHERE \"Singer_ID\" NOT IN (SELECT \"Singer_ID\" FROM \"song\")"
        ]
    },
    "1027": {
        "db_id": "singer",
        "question": "What is the sname of every sing that does not have any song?",
        "ground_truth": "SELECT Name FROM singer WHERE Singer_ID NOT IN (SELECT Singer_ID FROM song)",
        "amends": [
            "Do select `Name` from the `singer` table instead of `sname` from `sing`. Do use a `WHERE` clause with `Singer_ID NOT IN` subquery instead of checking `song_id IS NULL`. Do reference the correct table name `singer` instead of `sing`. Do use the proper column name `Singer_ID` in both the main query and subquery instead of `song_id`. Do include a correlated subquery that checks for singers without songs in the `song` table instead of simply checking for null values. The amended query now correctly identifies singers who have no associated songs by using a NOT IN subquery rather than a simple null check."
        ],
        "rules": [
            "When answering about \"sname of every sing that does not have any song\": select \"Name\" from the \"singer\" table instead of \"sname\" from \"sing\".",
            "When identifying singers without songs: use a WHERE clause with \"Singer_ID NOT IN\" subquery instead of checking for null values.",
            "When referencing the singer table: use the correct table name \"singer\" instead of \"sing\".",
            "When using the singer identifier: use the proper column name \"Singer_ID\" in both the main query and subquery instead of \"song_id\".",
            "When answering about \"sname of every sing that does not have any song\", When identifying singers without songs, When referencing the singer table, When using the singer identifier, When checking for singers without songs: include a correlated subquery that checks for singers without songs in the \"song\" table instead of simply checking for null values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT sname FROM sing WHERE song_id IS NULL;",
            "SELECT Name FROM singer WHERE Singer_ID NOT IN (SELECT Singer_ID FROM song)"
        ],
        "rule_sql": [
            "SELECT Name FROM singer WHERE Singer_ID NOT IN (SELECT Singer_ID FROM song)"
        ]
    },
    "1028": {
        "db_id": "singer",
        "question": "Show the citizenship shared by singers with birth year before 1945 and after 1955.",
        "ground_truth": "SELECT Citizenship FROM singer WHERE Birth_Year  <  1945 INTERSECT SELECT Citizenship FROM singer WHERE Birth_Year  >  1955",
        "amends": [
            "Do use `INTERSECT` to find common citizenships instead of `OR` which would return all records matching either condition. Do reference the correct table name `singer` instead of `singers`. Do use proper column names `Citizenship` and `Birth_Year` with correct capitalization instead of lowercase `citizenship` and `birth_year`. Do split into two separate queries with `INTERSECT` to find citizenships that appear in both the pre-1945 and post-1955 birth year groups instead of using a single query with `OR` that returns citizenships from either group independently. The amended query now correctly identifies only those citizenships that have singers born both before 1945 AND after 1955, matching the RIGHT_SQL's set intersection behavior."
        ],
        "rules": [
            "When the question asks for a citizenship shared by singers meeting two different conditions: use INTERSECT to find citizenships that appear in both groups rather than OR which would return citizenships from either group independently.",
            "When referencing the singer table: use the exact table name \"singer\" instead of \"singers\".",
            "When selecting citizenship information: use the exact column name \"Citizenship\" with proper capitalization instead of lowercase \"citizenship\".",
            "When filtering by birth year: use the exact column name \"Birth_Year\" with proper capitalization instead of lowercase \"birth_year\".",
            "When finding singers born before 1945: create one query selecting \"Citizenship\" from \"singer\" where \"Birth_Year\" < 1945.",
            "When finding singers born after 1955: create another query selecting \"Citizenship\" from \"singer\" where \"Birth_Year\" > 1955.",
            "When the question asks for a citizenship shared by singers meeting two different conditions, When referencing the singer table, When selecting citizenship information, When filtering by birth year, When finding singers born before 1945, When finding singers born after 1955, When combining the two groups: use INTERSECT between the two queries to find only citizenships that appear in both the pre-1945 and post-1955 birth year groups."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT citizenship FROM singers WHERE birth_year < 1945 OR birth_year > 1955;",
            "SELECT Citizenship FROM singer WHERE Birth_Year < 1945\nINTERSECT\nSELECT Citizenship FROM singer WHERE Birth_Year > 1955"
        ],
        "rule_sql": [
            "SELECT \"Citizenship\" FROM \"singer\" WHERE \"Birth_Year\" < 1945\nINTERSECT\nSELECT \"Citizenship\" FROM \"singer\" WHERE \"Birth_Year\" > 1955"
        ]
    },
    "1029": {
        "db_id": "singer",
        "question": "What are the citizenships that are shared by singers with a birth year before 1945 and after 1955?",
        "ground_truth": "SELECT Citizenship FROM singer WHERE Birth_Year  <  1945 INTERSECT SELECT Citizenship FROM singer WHERE Birth_Year  >  1955",
        "amends": [
            "Do use `INTERSECT` between two separate queries instead of `OR` in a single query. Do reference `Citizenship` with proper capitalization instead of lowercase `citizenship`. Do use table name `singer` instead of plural `singers`. Do remove `DISTINCT` since `INTERSECT` inherently returns distinct values instead of keeping it. Do maintain the same column selection `Citizenship` but with proper case handling. Do split the birth year conditions into separate queries with `Birth_Year < 1945` and `Birth_Year > 1955` instead of combining them with `OR`. The amended query now correctly finds citizenships that appear in both the pre-1945 and post-1955 birth year groups, matching the RIGHT_SQL's intersection behavior."
        ],
        "rules": [
            "When the question asks for citizenships shared by two groups: use INTERSECT between separate queries for each group instead of OR in a single query.",
            "When referencing the citizenship column: use exact token \"Citizenship\" with proper capitalization instead of lowercase \"citizenship\".",
            "When referencing the table: use exact table name \"singer\" instead of plural \"singers\".",
            "When using INTERSECT: remove DISTINCT since INTERSECT inherently returns distinct values.",
            "When the question asks for citizenships shared by two groups, When referencing the citizenship column, When referencing the table, When using INTERSECT, When splitting birth year conditions: create separate queries with \"Birth_Year < 1945\" and \"Birth_Year > 1955\" instead of combining them with OR."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT citizenship \nFROM singers \nWHERE birth_year < 1945 OR birth_year > 1955;",
            "SELECT Citizenship FROM singer WHERE Birth_Year < 1945\nINTERSECT\nSELECT Citizenship FROM singer WHERE Birth_Year > 1955"
        ],
        "rule_sql": [
            "SELECT Citizenship FROM singer WHERE Birth_Year < 1945\nINTERSECT\nSELECT Citizenship FROM singer WHERE Birth_Year > 1955"
        ]
    },
    "1030": {
        "db_id": "real_estate_properties",
        "question": "How many available features are there in total?",
        "ground_truth": "SELECT count(*) FROM Other_Available_Features",
        "amends": [
            "Do reference the `Other_Available_Features` table instead of the `features` table. Do filter for available status with `status = 'available'` instead of unavailable status with `status = 'unavailable'`. The amended query now correctly counts available features from the appropriate table, matching the intended behavior.",
            "Do remove the `WHERE status = 'available'` filter instead of keeping it, and do remove the `AS total_available_features` alias instead of including it. The amended query now counts all rows in the Other_Available_Features table without any status filtering, matching the behavior of the right SQL."
        ],
        "rules": [
            "When answering about \"available features\": use the table \"Other_Available_Features\" instead of \"features\".",
            "When filtering for available status: use the condition status = 'available' instead of status = 'unavailable'.",
            "When answering about \"available features\", When filtering for available status, When counting available features: count all rows from \"Other_Available_Features\" where status equals 'available'.",
            "When counting all available features: count all rows in the \"Other_Available_Features\" table without any filtering conditions.",
            "When the question asks for \"how many available features are there in total\": do not apply any status filter and include all rows from the \"Other_Available_Features\" table.",
            "When counting all available features, When the question asks for \"how many available features are there in total\", When producing output for count results: do not use column aliases like \"total_available_features\" and return the count directly."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM features WHERE status = 'unavailable';",
            "SELECT COUNT(*) AS total_available_features FROM Other_Available_Features WHERE status = 'available'",
            "SELECT COUNT(*) FROM Other_Available_Features;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Other_Available_Features;"
        ]
    },
    "1031": {
        "db_id": "real_estate_properties",
        "question": "What is the feature type name of feature AirCon?",
        "ground_truth": "SELECT T2.feature_type_name FROM Other_Available_Features AS T1 JOIN Ref_Feature_Types AS T2 ON T1.feature_type_code  =  T2.feature_type_code WHERE T1.feature_name  =  \"AirCon\"",
        "amends": [
            "Do select `T2.feature_type_name` instead of `feature_name`. Do use `FROM Other_Available_Features AS T1 JOIN Ref_Feature_Types AS T2` instead of `FROM features`. Do apply join condition `ON T1.feature_type_code = T2.feature_type_code` instead of no join. Do filter with `WHERE T1.feature_name = \"AirCon\"` instead of `WHERE feature_type = 'AirCon'`. The amended query now correctly joins reference tables to retrieve the feature type name rather than the feature name itself, matching the intended behavior."
        ],
        "rules": [
            "When the question asks for \"feature type name of feature AirCon\": select T2.feature_type_name instead of feature_name.",
            "When combining Other_Available_Features and Ref_Feature_Types: link rows where T1.feature_type_code = T2.feature_type_code and keep only matching pairs (inner match).",
            "When filtering for feature \"AirCon\": use T1.feature_name = \"AirCon\" exactly as specified with double quotes.",
            "When the question asks for \"feature type name of feature AirCon\", When combining Other_Available_Features and Ref_Feature_Types, When filtering for feature \"AirCon\", When answering about feature type name: make sure the output order: T2.feature_type_name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT feature_name FROM features WHERE feature_type = 'AirCon';",
            "SELECT T2.feature_type_name \nFROM Other_Available_Features AS T1 \nJOIN Ref_Feature_Types AS T2 ON T1.feature_type_code = T2.feature_type_code \nWHERE T1.feature_name = 'AirCon'"
        ],
        "rule_sql": [
            "SELECT T2.feature_type_name \nFROM Other_Available_Features T1 \nINNER JOIN Ref_Feature_Types T2 ON T1.feature_type_code = T2.feature_type_code \nWHERE T1.feature_name = \"AirCon\""
        ]
    },
    "1032": {
        "db_id": "real_estate_properties",
        "question": "Show the property type descriptions of properties belonging to that code.",
        "ground_truth": "SELECT T2.property_type_description FROM Properties AS T1 JOIN Ref_Property_Types AS T2 ON T1.property_type_code  =  T2.property_type_code GROUP BY T1.property_type_code",
        "amends": [
            "Do select `T2.property_type_description` from the joined table instead of directly selecting `property_type_description` from the base table. Do add a `JOIN` with `Ref_Property_Types AS T2` on `T1.property_type_code = T2.property_type_code` instead of querying only the `properties` table. Do use `GROUP BY T1.property_type_code` to aggregate results instead of filtering by `property_code = 'that code'`. Do remove the `WHERE` clause filter entirely instead of keeping the specific property code condition. The amended query now correctly retrieves property type descriptions by joining with the reference table and grouping by type code rather than filtering for a single specific property."
        ],
        "rules": [
            "When answering about \"property type descriptions of properties\": make sure the output order: T2.property_type_description",
            "When combining T1 (properties) and T2 (Ref_Property_Types) for shared entities: link rows where T1.property_type_code = T2.property_type_code and keep only matching pairs (inner match)",
            "When the question says \"per property type code\": organize results by T1.property_type_code and compute requested descriptions per group",
            "When answering about \"property type descriptions of properties\", When combining T1 (properties) and T2 (Ref_Property_Types) for shared entities, When the question says \"per property type code\", When the question mentions \"that code\": do not filter by property_code = 'that code' as this is incorrect for grouping by property type"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT property_type_description FROM properties WHERE property_code = 'that code';",
            "SELECT T2.property_type_description \nFROM Properties AS T1\nJOIN Ref_Property_Types AS T2 ON T1.property_type_code = T2.property_type_code\nGROUP BY T1.property_type_code"
        ],
        "rule_sql": [
            "SELECT T2.property_type_description \nFROM Properties T1 \nINNER JOIN Ref_Property_Types T2 ON T1.property_type_code = T2.property_type_code \nGROUP BY T1.property_type_code \nORDER BY T2.property_type_description"
        ]
    },
    "1033": {
        "db_id": "real_estate_properties",
        "question": "What are the names of properties that are either houses or apartments with more than 1 room?",
        "ground_truth": "SELECT property_name FROM Properties WHERE property_type_code  =  \"House\" UNION SELECT property_name FROM Properties WHERE property_type_code  =  \"Apartment\" AND room_count  >  1",
        "amends": [
            "Do select `property_name` instead of `name` and use `UNION` to combine results instead of `OR` logic. Do reference table `Properties` instead of `properties` and use column `property_type_code` instead of `type`. Do use exact string values `\"House\"` and `\"Apartment\"` instead of `'house'` and `'apartment'`. Do use column `room_count` instead of `rooms` and apply the `room_count > 1` filter only to the apartment condition instead of applying it to both house and apartment conditions. The amended query now correctly separates the house selection (without room count restriction) from the apartment selection (with room count requirement) using UNION, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "When selecting property names: use \"property_name\" instead of \"name\" as the output column.",
            "When the question mentions \"houses\" or \"apartments\": these correspond to exact string values \"House\" and \"Apartment\" in column \"property_type_code\".",
            "When combining results for different property types: use UNION to separate house selection (without room count restriction) from apartment selection (with room count requirement).",
            "When filtering apartments: apply room_count > 1 condition only to apartments, not to houses.",
            "When referring to the table: use \"Properties\" (exact case) instead of \"properties\".",
            "When selecting property names, When the question mentions \"houses\" or \"apartments\", When combining results for different property types, When filtering apartments, When referring to the table, When counting rooms: use column \"room_count\" instead of \"rooms\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM properties WHERE type = 'house' OR type = 'apartment' AND rooms > 1;",
            "SELECT property_name FROM Properties WHERE property_type_code = 'House' UNION SELECT property_name FROM Properties WHERE property_type_code = 'Apartment' AND room_count > 1"
        ],
        "rule_sql": [
            "SELECT property_name FROM Properties WHERE property_type_code = 'House' \nUNION \nSELECT property_name FROM Properties WHERE property_type_code = 'Apartment' AND room_count > 1"
        ]
    }
}